[
    {
        "title": "A. 1-3-5",
        "description": "In Berland, coins of worth $$$1$$$, $$$3$$$ and $$$5$$$ burles are commonly used (burles are local currency).\nEva has to pay exactly $$$n$$$ burles in a shop. She has an infinite amount of coins of all three types. However, she doesn't like to pay using coins worth $$$1$$$ burle — she thinks they are the most convenient to use.\nHelp Eva to calculate the minimum number of coins worth $$$1$$$ burle she has to use, if she has to pay exactly $$$n$$$ burles. Note that she can spend any number of coins worth $$$3$$$ and/or $$$5$$$ burles.\nInput\nThe first line contains one integer $$$t$$$ ($$$1 \\le t \\le 100$$$) — the number of test cases.\nEach test case consists of one line, containing one integer $$$n$$$ ($$$1 \\le n \\le 100$$$).\nOutput\nFor each test case, print one integer — the minimum number of $$$1$$$-burle coins Eva has to use.\nExample\ninput\nCopy\n5\n7\n8\n42\n2\n11\noutput\nCopy\n1\n0\n0\n2\n0\nNote\nIn the first test case, Eva should use $$$1$$$ coin worth $$$1$$$ burle, and $$$2$$$ coins worth $$$3$$$ burles.\nIn the second test case, Eva should use $$$1$$$ coin worth $$$3$$$ burles and $$$1$$$ coin worth $$$5$$$ burles.\nIn the third test case, Eva should use $$$14$$$ coins worth $$$3$$$ burles.\nIn the fourth test case, Eva should use $$$2$$$ coins worth $$$1$$$ burle.\nIn the fifth test case, Eva should use $$$2$$$ coins worth $$$3$$$ burles and $$$1$$$ coin worth $$$5$$$ burles.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*1100"
        ],
        "link": "https://codeforces.com/contest/1958/problem/A",
        "solution": "fun main() = repeat(readln().toInt()){\n    val s = readln().toInt()\n    println(if((s<8)&&(s!=5)) s%3 else 0)\n}"
    },
    {
        "title": "C. Firewood",
        "description": "It's pretty cold in Berland (yes, even in May). So Monocarp has to light his fireplace.\nMonocarp has a big log of wood, which weighs $$$2^n$$$ grams. Monocarp has watched the weather forecast and decided that he has to burn $$$k$$$ grams of wood in the fireplace today, and the remaining $$$2^n-k$$$ grams of wood will be used tomorrow.\nIn one minute, Monocarp can use his saw to split one of his logs in half. Initially he has only one log, but of course, after splitting a log, he gets two new logs. If the weight of the log is $$$x$$$, then each of the resulting logs has weight equal to $$$\\frac{x}{2}$$$. Monocarp can't split logs of weight $$$1$$$ gram.\nMonocarp has to cut his log in such a way that some of the resulting logs weigh exactly $$$k$$$ grams in total (and since the total weight of wood doesn't change, the remaining logs will have a total weight equal to exactly $$$2^n-k$$$). Help him to calculate the minimum number of minutes he has to spend cutting the logs.\nInput\nThe first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nEach test case consists of one line containing two integers $$$n$$$ and $$$k$$$ ($$$1 \\le n \\le 60$$$; $$$1 \\le k \\le 2^n-1$$$).\nOutput\nFor each test case, print one integer — the minimum number of minutes Monocarp has to spend splitting the wood.\nExample\ninput\nCopy\n4\n2 2\n2 1\n10 3\n50 36679020707840\noutput\nCopy\n1\n2\n10\n16\nNote\nIn the first test case, Monocarp has to cut his log exactly once. Then he will have two logs weighing $$$2$$$ grams each.\nIn the second test case, Monocarp has to cut his log of $$$4$$$ grams once, then cut one of the resulting logs. He will have one log of weight $$$2$$$ and two logs of weight $$$1$$$, so he can use two logs to get exactly $$$3$$$ grams.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*1500"
        ],
        "link": "https://codeforces.com/contest/1958/problem/C",
        "solution": "fun main() {\n  repeat(readln().toInt()) {\n      val(n, k) = readln().split(' ').map {it.toLong()}\n      println(n - k.countTrailingZeroBits())\n  }\n}"
    },
    {
        "title": "F. Narrow Paths",
        "description": "Monocarp is wandering through a matrix consisting of $$$2$$$ rows and $$$n$$$ columns. Let's denote the cell in the $$$i$$$-th row and $$$j$$$-th column as $$$(i, j)$$$. Monocarp starts at cell $$$(1, 1)$$$ and wants to reach cell $$$(2, n)$$$.\nIn one move, Monocarp can move in one of two directions:\nright — from cell $$$(i, j)$$$ to cell $$$(i, j + 1)$$$;\ndown — from cell $$$(i, j)$$$ to cell $$$(i + 1, j)$$$.\nMonocarp can't go outside the matrix.\nPolycarp wants to prevent Monocarp from freely wandering through the matrix. To do this, he wants to choose exactly $$$k$$$ different cells in the matrix and block them. He cannot choose cells $$$(1, 1)$$$ and $$$(2, n)$$$.\nFor each $$$i$$$ from $$$0$$$ to $$$n$$$, Polycarp wants to know how many ways he can block exactly $$$k$$$ cells, so that Monocarp has exactly $$$i$$$ different paths from $$$(1, 1)$$$ to $$$(2, n)$$$. Two paths are considered different if there exists a cell that Monocarp visits in one path but not in the other.\nAs the number of ways can be quite large, output it modulo $$$10^9 + 7$$$.\nInput\nThe only line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$2 \\le k \\le 2 \\cdot n - 2$$$) — the number of columns in the matrix and the number of cells Polycarp wants to block.\nOutput\nOutput $$$n + 1$$$ integers: for each $$$i$$$ from $$$0$$$ to $$$n$$$, the number of ways to block exactly $$$k$$$ cells, so that Monocarp has exactly $$$i$$$ different paths from $$$(1, 1)$$$ to $$$(2, n)$$$. Output all answers modulo $$$10^9 + 7$$$.\nExamples\ninput\nCopy\n2 2\noutput\nCopy\n1 0 0\ninput\nCopy\n10 2\noutput\nCopy\n45 24 21 18 15 12 9 6 3 0 0\ninput\nCopy\n10 5\noutput\nCopy\n7812 420 210 90 30 6 0 0 0 0 0\ninput\nCopy\n22 10\noutput\nCopy\n467563090 1847560 1016158 534820 267410 125840 55055 22022 7865 2420 605 110 11 0 0 0 0 0 0 0 0 0 0",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "combinatorics",
            "*2000"
        ],
        "link": "https://codeforces.com/contest/1958/problem/F",
        "solution": "fun main() {\n    val MOD = 1_000_000_007L\n    val FAC = LongArray(400_001)\n    val INV = LongArray(400_001)\n    FAC[0] = 1\n    for (i in 1 until FAC.size) FAC[i] = FAC[i - 1] * i % MOD\n    INV[0] = 1\n    INV[1] = 1\n    for (i in 2 until INV.size) INV[i] = INV[MOD.toInt() % i] * (MOD - MOD / i) % MOD\n    for (i in 2 until INV.size) INV[i] = INV[i - 1] * INV[i] % MOD\n     fun comb(n: Int, k: Int) = FAC[n] * INV[k] % MOD * INV[n - k] % MOD\n     val (n, k) = readln().split(' ').map { it.toInt() }\n    val ans = LongArray(n + 1)\n    for (i in 1..(n-k)) ans[i] = ((n - i - 1) * comb(n - i - 2, k - 2) + 2 * comb(n - i - 1, k - 1)) % MOD\n    ans[0] = (comb(2 * n - 2, k) - ans.sum()) % MOD\n    if (ans[0] < 0L) ans[0] += MOD\n    println(ans.joinToString(\" \"))\n}"
    },
    {
        "title": "H. Composite Spells",
        "description": "Monocarp plays a fantasy RPG. His character is a mage, so he casts spells. There are two types of spells he knows — basic spells and composite spells.\nThere are $$$n$$$ basic spells in Monocarp's spell book, numbered from $$$1$$$ to $$$n$$$. Each basic spell simply changes the health of the target: either decreases it or increases it. The $$$i$$$-th basic spell changes the target's health value by $$$b_i$$$ (increases by $$$b_i$$$ if $$$b_i$$$ is non-negative, or decreases by $$$|b_i|$$$ if $$$b_i$$$ is negative). If the target's health value goes to $$$0$$$ or below, it dies, and all next spells cast at it do nothing.\nThere are also $$$m$$$ composite spells in the spell book, numbered from $$$n+1$$$ to $$$n+m$$$. Each composite spell is a sequence of other spells, cast in specific order. A composite spell can consist both of basic spells and composite spells; the $$$i$$$-th spell consists of $$$s_i$$$ other spells, and each of those spells has index strictly less than $$$i$$$ (so there is no situation that composite spells infinitely cast each other). So, actually, each composite spell can be considered a finite sequence of basic spells, although its length might be huge. Note that the same spell can appear in a composite spell multiple times.\nMonocarp has decided to cast the $$$(n+m)$$$-th spell from his spell book. The target of this spell is a monster with an initial health value of $$$hp$$$. Monocarp wants to know whether the monster will be killed or not, and if it will be killed, which basic spell will kill it.\nInput\nThe first line contains one integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases.\nEach test case is given as follows:\nthe first line contains two integers $$$n$$$ and $$$hp$$$ ($$$1 \\le n \\le 5000$$$; $$$1 \\le hp \\le 10^{9}$$$) — the number of basic spells and the initial health value of the monster;\nthe second line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$-10^9 \\le b_i \\le 10^9$$$) — the descriptions of basic spells;\nthe third line contains one integer $$$m$$$ ($$$1 \\le m \\le 5000$$$) — the number of composite spells;\nthen $$$m$$$ lines follow, the $$$i$$$-th of these lines describes the $$$(n+i)$$$-th spell: it begins with an integer $$$s_{n+i}$$$ ($$$1 \\le s_{n+i} \\le 5000$$$) denoting the length of the spell (the number of spells it consists of); then a sequence of integers from $$$1$$$ to $$$(n+i-1)$$$ follows, denoting the sequence of spells.\nAdditional constraints on the input:\nthe sum of $$$n$$$ over all test cases does not exceed $$$5000$$$;\nthe sum of $$$m$$$ over all test cases does not exceed $$$5000$$$;\nthe total length of all composite spells over all test cases does not exceed $$$5000$$$.\nOutput\nFor each test case, print one integer:\nif the monster dies, print the index of the basic spell that kills the monster;\notherwise, print $$$-1$$$.\nExample\ninput\nCopy\n4\n4 9\n1 -2 3 -4\n3\n3 1 4 3\n4 1 2 1 2\n6 6 5 6 5 6 5\n4 9\n1 -2 3 -4\n3\n3 1 4 3\n4 1 2 1 2\n7 6 5 6 5 6 6 5\n3 31\n-10 -20 30\n1\n6 1 2 3 1 2 3\n6 20\n-1 -5 -9 -7 -1 -1\n4\n3 6 5 2\n4 3 3 7 6\n6 4 8 4 4 6 7\n3 6 5 7\noutput\nCopy\n4\n4\n-1\n-1",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*2600"
        ],
        "link": "https://codeforces.com/contest/1958/problem/H",
        "solution": "import java.math.BigInteger\n fun main() = repeat(readLine()!!.toInt()) {\n  val (n, hp) = readLine()!!.split(\" \").let { (n, hp) -> n.toInt() to BigInteger(hp) } \n  val s = readLine()!!.split(\" \").map { BigInteger(it) }\n  val m = readLine()!!.toInt()\n  val c = Array(m) { readLine()!!.split(\" \").drop(1).map { it.toInt() - 1 } }\n  val delta = Array(m) { BigInteger.ZERO }\n  val minDelta = Array(m) { BigInteger.ZERO }\n  for (i in 0 until m) {\n    var curHP = BigInteger.ZERO\n    for (id in c[i]) {\n      if (id < n) {\n        curHP += s[id]\n        minDelta[i] = minOf(minDelta[i], curHP)\n      } else {\n        minDelta[i] = minOf(minDelta[i], curHP + minDelta[id - n])\n        curHP += delta[id - n]\n      }\n    }\n    delta[i] = curHP\n  }\n    fun rec(remHP : BigInteger, idCompSpell : Int) : Int {\n    var curHP = remHP\n    for (id in c[idCompSpell]) {\n      if (id < n) {\n        curHP += s[id]\n        if (curHP <= BigInteger.ZERO)\n          return id + 1\n      } else {\n        if (curHP + minDelta[id - n] <= BigInteger.ZERO)\n          return rec(curHP, id - n)\n        curHP += delta[id - n]\n      }\n    }\n    return -1\n  }\n    println(rec(hp, m - 1))\n}"
    },
    {
        "title": "J. Necromancer",
        "description": "Monocarp is playing a computer game. In this game, his character is a necromancer. He is fighting $$$n$$$ monsters numbered from $$$1$$$ to $$$n$$$. Each monster has two parameters: health and strength.\nMonocarp considers $$$q$$$ scenarios of the battle. In each scenario, he chooses some segment $$$[l, r]$$$ of monsters and calculates the number of moves it takes to defeat all these monsters.\nEach scenario proceeds as follows. First, Monocarp kills monster $$$l$$$ and revives it as a zombie (this does not count as a move). Then each move the following happens: let $$$i$$$ be the index of the first monster in the segment $$$[l, r]$$$ that is still alive. All zombies attack monster $$$i$$$, reducing its health by their total strength. After that, if monster $$$i$$$ has $$$0$$$ or less health, it dies and Monocarp revives it as a zombie.\nWhen the monster is revived, the zombie's strength is equal to the monster's strength.\nHelp Monocarp for each scenario to calculate how many moves it will take to kill all the monsters in the segment.\nInput\nThe first line contains two integers $$$n$$$ and $$$q$$$ ($$$1 \\le n, q \\le 2 \\cdot 10^5$$$) — the number of monsters and the number of scenarios, respectively.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^4$$$), where $$$a_i$$$ is the number of health points of the $$$i$$$-th monster.\nThe third line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$1 \\le b_i \\le 10^4$$$), where $$$b_i$$$ is the strength of the $$$i$$$-th monster.\nThen $$$q$$$ lines follow. The $$$j$$$-th of them contains two integers $$$l_j$$$ and $$$r_j$$$ ($$$1 \\le l_j \\le r_j \\le n$$$) — the boundaries of the $$$j$$$-th scenario.\nOutput\nFor each scenario, print a single integer — the number of moves it will take to kill all the monsters in the segment.\nExample\ninput\nCopy\n7 5\n4 5 9 9 4 2 4\n1 3 3 1 2 3 3\n3 5\n1 4\n6 6\n1 7\n2 6\noutput\nCopy\n4\n10\n0\n13\n7",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*3200"
        ],
        "link": "https://codeforces.com/contest/1958/problem/J",
        "solution": "const val M = 1000\nconst val K = 10\n fun main() {  \n  val (n, q) = readLine()!!.split(\" \").map { it.toInt() }\n  val a = readLine()!!.split(\" \").map { it.toInt() }\n  val b = readLine()!!.split(\" \").map { it.toInt() }\n  val l = IntArray(q)\n  val r = IntArray(q)\n  for (i in 0 until q) {\n    val (x, y) = readLine()!!.split(\" \").map { it.toInt() - 1}\n    l[i] = x\n    r[i] = y\n  }\n  val s = b.scan(0, Int::plus)\n  val ev = Array(n) { mutableListOf<Int>() }\n  for (i in 0 until n) {\n    for (j in 1 until K) {\n      val x = s[i] - (a[i] + j - 1) / j + 1\n      val pos = s.binarySearch { if (it < x) -1 else 1 }.inv()\n      if (pos < i) ev[pos].add(i)\n    }\n  }\n  val qr = Array(n) { mutableListOf<Int>() }\n  for (i in 0 until q) qr[l[i]].add(i)\n  val f = IntArray(n) { 0 }\n  fun inc(i : Int) = generateSequence(i) { (it or (it + 1)).takeIf { it < n } }.forEach { ++f[it] }\n  fun sum(i : Int) = generateSequence(i) { ((it and (it + 1)) - 1).takeIf { it >= 0 } }.sumOf { f[it] }\n  for (i in 0 until n) inc(i)\n  val ans = IntArray(q) { 0 }\n  for (i in 0 until n) {\n    for (j in ev[i]) inc(j)\n    for (j in qr[i]) {\n      var cur = b[l[j]]\n      for (x in 1 until M.coerceAtMost(r[j] - l[j] + 1)) {\n        ans[j] += (a[l[j] + x] + cur - 1) / cur\n        cur += b[l[j] + x]\n      }\n      if (l[j] + M <= r[j]) ans[j] += sum(r[j]) - sum(l[j] + M - 1)\n    }\n  }\n  println(ans.joinToString(\"\\n\"))\n}"
    },
    {
        "title": "B. Compare T-Shirt Sizes",
        "description": "Two T-shirt sizes are given: $$$a$$$ and $$$b$$$. The T-shirt size is either a string M or a string consisting of several (possibly zero) characters X and one of the characters S or L.\nFor example, strings M, XXL, S, XXXXXXXS could be the size of some T-shirts. And the strings XM, LL, SX are not sizes.\nThe letter M stands for medium, S for small, L for large. The letter X refers to the degree of size (from eXtra). For example, XXL is extra-extra-large (bigger than XL, and smaller than XXXL).\nYou need to compare two given sizes of T-shirts $$$a$$$ and $$$b$$$.\nThe T-shirts are compared as follows:\nany small size (no matter how many letters X) is smaller than the medium size and any large size;\nany large size (regardless of the number of letters X) is larger than the medium size and any small size;\nthe more letters X before S, the smaller the size;\nthe more letters X in front of L, the larger the size.\nFor example:\nXXXS < XS\nXXXL > XL\nXL > M\nXXL = XXL\nXXXXXS < M\nXL > XXXS\nInput\nThe first line of the input contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nEach test case consists of one line, in which $$$a$$$ and $$$b$$$ T-shirt sizes are written. The lengths of the strings corresponding to the T-shirt sizes do not exceed $$$50$$$. It is guaranteed that all sizes are correct.\nOutput\nFor each test case, print on a separate line the result of comparing $$$a$$$ and $$$b$$$ T-shirt sizes (lines \"<\", \">\" or \"=\" without quotes).\nExample\ninput\nCopy\n6\nXXXS XS\nXXXL XL\nXL M\nXXL XXL\nXXXXXS M\nL M\noutput\nCopy\n<\n>\n>\n=\n<\n>",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "implementation",
            "strings"
        ],
        "link": "https://codeforces.com/contest/1959/problem/B",
        "solution": "fun main() {\n    val T = readln().toInt()\n    repeat(T) {\n        val parts = readln().split(\" \").map { it.length * (\"SML\".indexOf(it[it.length - 1]) - 1) }\n        println(if (parts[0] == parts[1]) '=' else if (parts[0] < parts[1]) '<' else '>')\n    }\n}"
    },
    {
        "title": "E. Range Minimum Sum",
        "description": "For an array\n[a1,a2,…,an]\nof length\nn\n, define\nf(a)\nas the sum of the minimum element over all subsegments. That is,\nf(a)=\nn\n∑\nl=1\nn\n∑\nr=l\nmin\nl≤i≤r\nai.\nA permutation is a sequence of integers from\n1\nto\nn\nof length\nn\ncontaining each number exactly once. You are given a permutation\n[a1,a2,…,an]\n. For each\ni\n, solve the following problem independently:\nErase\nai\nfrom\na\n, concatenating the remaining parts, resulting in\nb=[a1,a2,…,ai−1,ai+1,…,an]\n.\nCalculate\nf(b)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤105\n). Description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤5⋅105\n).\nThe second line of each test case contains\nn\ndistinct integers\na1,…,an\n(\n1≤ai≤n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n106\n.\nOutput\nFor each test case, print one line containing\nn\nintegers. The\ni\n-th integer should be the answer when erasing\nai\n.\nExample\ninput\nCopy\n4\n1\n1\n3\n3 1 2\n5\n4 2 1 5 3\n8\n8 1 4 6 7 3 5 2\noutput\nCopy\n0 \n4 7 5 \n19 21 27 17 19 \n79 100 72 68 67 80 73 80 \nNote\nIn the second test case,\na=[3,1,2]\n.\nWhen removing\na1\n,\nb=[1,2]\n.\nf(b)=1+2+min{1,2}=4\n.\nWhen removing\na2\n,\nb=[3,2]\n.\nf(b)=3+2+min{3,2}=7\n.\nWhen removing\na3\n,\nb=[3,1]\n.\nf(b)=3+1+min{3,1}=5\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "implementation",
            "*2300"
        ],
        "link": "https://codeforces.com/contest/1988/problem/E",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll _=5e5+5;\nll N,n,k,t,a[_],b[_],l[_],r[_],s[_],i;\ninline void p2(ll x,ll y,ll L,ll M,ll R){\n if(!x&&!y)return;\n if(x&&(!y||a[x]<a[y]))s[M]+=(x-L)*(R-M-1)*a[x],p2(r[x],y,x,M,R);\n else s[M]+=(M-L-1)*(R-y)*a[y],p2(x,l[y],L,M,y);\n}\ninline void p1(ll x,ll L,ll R,ll u,ll v){\n k+=(x-L)*(R-x)*a[x];s[x]-=u+v+(x-L)*(R-x)*a[x];p2(l[x],r[x],L,x,R);\n if(l[x])p1(l[x],L,x,u,v+(R-x)*a[x]);if(r[x])p1(r[x],x,R,u+(x-L)*a[x],v);\n}\ninline void P(){\n cin>>n;\n for(t=i=0;i<=n;i++)l[i]=r[i]=s[i]=0;\n for(i=1;i<=n;i++){\n  cin>>a[i];\n  while(t&&a[i]<a[b[t]])l[i]=b[t--];\n  r[b[t]]=i;b[++t]=i;\n }\n k=0;p1(r[0],0,n+1,0,0);\n for(i=1;i<=n;i++)cout<<k+s[i]<<\" \\n\"[i==n];\n}\nint main(){\n ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n cin>>N;while(N--)P();\n}"
    },
    {
        "title": "F. Heartbeat",
        "description": "For an array\nu1,u2,…,un\n, define\na prefix maximum as an index\ni\nsuch that\nui>uj\nfor all\nj<i\n;\na suffix maximum as an index\ni\nsuch that\nui>uj\nfor all\nj>i\n;\nan ascent as an index\ni\n(\ni>1\n) such that\nui>ui−1\n.\nYou are given three cost arrays:\n[a1,a2,…,an]\n,\n[b1,b2,…,bn]\n, and\n[c0,c1,…,cn−1]\n.\nDefine the cost of an array that has\nx\nprefix maximums,\ny\nsuffix maximums, and\nz\nascents as\nax⋅by⋅cz\n.\nLet the sum of costs of all permutations of\n1,2,…,n\nbe\nf(n)\n. Find\nf(1)\n,\nf(2)\n, ...,\nf(n)\nmodulo\n998244353\n.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤700\n).\nThe second line contains\nn\nintegers\na1,…,an\n(\n0≤ai<998244353\n).\nThe third line contains\nn\nintegers\nb1,…,bn\n(\n0≤bi<998244353\n).\nThe fourth line contains\nn\nintegers\nc0,…,cn−1\n(\n0≤ci<998244353\n).\nOutput\nPrint\nn\nintegers: the\ni\n-th one is\nf(i)\nmodulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 1 1\n1 1 1\n1 1 1\noutput\nCopy\n1 2 6 \ninput\nCopy\n3\n1 2 3\n2 3 1\n3 1 2\noutput\nCopy\n6 13 34 \ninput\nCopy\n5\n1 4 2 5 3\n2 5 1 3 4\n300000000 100000000 500000000 400000000 200000000\noutput\nCopy\n600000000 303511294 612289529 324650937 947905622 \nNote\nIn the second example:\nConsider permutation\n[1,2,3]\n. Indices\n1,2,3\nare prefix maximums. Index\n3\nis the only suffix maximum. Indices\n2,3\nare ascents. In conclusion, it has\n3\nprefix maximums,\n1\nsuffix maximums, and\n2\nascents. Therefore, its cost is\na3b1c2=12\n.\nPermutation\n[1,3,2]\nhas\n2\nprefix maximums,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n6\n.\nPermutation\n[2,1,3]\nhas\n2\nprefix maximums,\n1\nsuffix maximum, and\n1\nascent. Its cost is\n4\n.\nPermutation\n[2,3,1]\nhas\n2\nprefix maximums,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n6\n.\nPermutation\n[3,1,2]\nhas\n1\nprefix maximum,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n3\n.\nPermutation\n[3,2,1]\nhas\n1\nprefix maximum,\n3\nsuffix maximums, and\n0\nascents. Its cost is\n3\n.\nThe sum of all permutations' costs is\n34\n, so\nf(3)=34\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math",
            "*3000"
        ],
        "link": "https://codeforces.com/contest/1988/problem/F",
        "solution": "// LUOGU_RID: 171594872\n#include<bits/stdc++.h>\n#define ll long long\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=710,mod=998244353;\nint n,a[N],b[N],c[N],C[N][N];\nll f[2][N][N],pre[N][N],suf[N][N],g[N][N],ans;\nvoid upd(ll &x,ll y){x=(x+y)%mod;}\nint main(){\n scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",a+i);rep(i,1,n) scanf(\"%d\",b+i);rep(i,0,n-1) scanf(\"%d\",c+i);\n    C[0][0]=1;rep(i,1,n){C[i][0]=1;rep(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;}\n    f[1][1][0]=1;pre[0][0]=a[1];suf[0][0]=b[1];\n    rep(i,1,n){\n        int nw=i&1,nx=nw^1;memset(f[nx],0,sizeof(f[nx]));\n        rep(j,1,i) rep(k,0,i-1) if(f[nw][j][k]){\n            ll val=f[nw][j][k];\n            upd(pre[i][k],val*a[j+1]);upd(suf[i][i-1-k],val*b[j+1]);\n            upd(f[nx][j+1][k+1],val);upd(f[nx][j][k],val*(k+1));upd(f[nx][j][k+1],val*(i-k-1));\n        }\n    }\n    rep(i,0,n) rep(x,0,i) rep(y,0,n-x-1) upd(g[i][y],pre[i][x]*c[x+y+(i>0)]);\n    rep(i,1,n){ans=0;rep(p,1,i) rep(y,0,i-p) upd(ans,g[p-1][y]*suf[i-p][y]%mod*C[i-1][p-1]%mod);printf(\"%lld \",ans);}\n return 0;\n}"
    },
    {
        "title": "A. Catch the Coin",
        "description": "Monocarp visited a retro arcade club with arcade cabinets. There got curious about the \"Catch the Coin\" cabinet.\nThe game is pretty simple. The screen represents a coordinate grid such that:\nthe X-axis is directed from left to right;\nthe Y-axis is directed from bottom to top;\nthe center of the screen has coordinates $$$(0, 0)$$$.\nAt the beginning of the game, the character is located in the center, and $$$n$$$ coins appear on the screen — the $$$i$$$-th coin is at coordinates $$$(x_i, y_i)$$$. The coordinates of all coins are different and not equal to $$$(0, 0)$$$.\nIn one second, Monocarp can move the character in one of eight directions. If the character is at coordinates $$$(x, y)$$$, then it can end up at any of the coordinates $$$(x, y + 1)$$$, $$$(x + 1, y + 1)$$$, $$$(x + 1, y)$$$, $$$(x + 1, y - 1)$$$, $$$(x, y - 1)$$$, $$$(x - 1, y - 1)$$$, $$$(x - 1, y)$$$, $$$(x - 1, y + 1)$$$.\nIf the character ends up at the coordinates with a coin, then Monocarp collects that coin.\nAfter Monocarp makes a move, all coins fall down by $$$1$$$, that is, they move from $$$(x, y)$$$ to $$$(x, y - 1)$$$. You can assume that the game field is infinite in all directions.\nMonocarp wants to collect at least one coin, but cannot decide which coin to go for. Help him determine, for each coin, whether he can collect it.\nInput\nThe first line contains a single integer $$$n$$$ ($$$1 \\le n \\le 500$$$) — the number of coins.\nIn the $$$i$$$-th of the next $$$n$$$ lines, two integers $$$x_i$$$ and $$$y_i$$$ ($$$-50 \\le x_i, y_i \\le 50$$$) are written — the coordinates of the $$$i$$$-th coin. The coordinates of all coins are different. No coin is located at $$$(0, 0)$$$.\nOutput\nFor each coin, print \"YES\" if Monocarp can collect it. Otherwise, print \"NO\".\nExample\ninput\nCopy\n5\n24 42\n-2 -1\n-1 -2\n0 -50\n15 0\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nNote\nPay attention to the second coin in the example. Monocarp can first move from $$$(0, 0)$$$ to $$$(-1, -1)$$$. Then the coin falls $$$1$$$ down and ends up at $$$(-2, -2)$$$. Finally, Monocarp moves to $$$(-2, -2)$$$ and collects the coin.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1989/problem/A",
        "solution": "/ /&&print$'>-2?Yes:No,$/for<>#FREE_KURSK"
    },
    {
        "title": "B. Substring and Subsequence",
        "description": "You are given two strings $$$a$$$ and $$$b$$$, both consisting of lowercase Latin letters.\nA subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string. A substring of a string is a contiguous subsequence of that string.\nFor example, consider the string abac:\na, b, c, ab, aa, ac, ba, bc, aba, abc, aac, bac and abac are its subsequences;\na, b, c, ab, ba, ac, aba, bac and abac are its substrings.\nYour task is to calculate the minimum possible length of the string that contains $$$a$$$ as a substring and $$$b$$$ as a subsequence.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$) — the number of test cases.\nThe first line of each test case contains a string $$$a$$$ ($$$1 \\le |a| \\le 100$$$), consisting of lowercase Latin letters.\nThe second line of each test case contains a string $$$b$$$ ($$$1 \\le |b| \\le 100$$$), consisting of lowercase Latin letters.\nOutput\nFor each test case, print a single integer — the minimum possible length of the string that contains $$$a$$$ as a substring and $$$b$$$ as a subsequence.\nExample\ninput\nCopy\n5\naba\ncb\ner\ncf\nmmm\nmmm\ncontest\ntest\ncde\nabcefg\noutput\nCopy\n4\n4\n3\n7\n7\nNote\nIn the examples below, the characters that correspond to the subsequence equal to $$$b$$$ are bolded.\nIn the first example, one of the possible answers is caba.\nIn the second example, one of the possible answers is ercf.\nIn the third example, one of the possible answers is mmm.\nIn the fourth example, one of the possible answers is contest.\nIn the fifth example, one of the possible answers is abcdefg.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1200"
        ],
        "link": "https://codeforces.com/contest/1989/problem/B",
        "solution": "I=input\nfor _ in[0]*int(I()):\n n=len(a:=I());m=len(b:=I());r=i=0\n while i<m:\n  k=i;j=0\n  while(j<n)&(k<m):k+=a[j]==b[k];j+=1\n  r=max(r,k-i);i+=1\n print(n+m-r)"
    },
    {
        "title": "C. Two Movies",
        "description": "A movie company has released $$$2$$$ movies. These $$$2$$$ movies were watched by $$$n$$$ people. For each person, we know their attitude towards the first movie (liked it, neutral, or disliked it) and towards the second movie.\nIf a person is asked to leave a review for the movie, then:\nif that person liked the movie, they will leave a positive review, and the movie's rating will increase by $$$1$$$;\nif that person disliked the movie, they will leave a negative review, and the movie's rating will decrease by $$$1$$$;\notherwise, they will leave a neutral review, and the movie's rating will not change.\nEvery person will review exactly one movie — and for every person, you can choose which movie they will review.\nThe company's rating is the minimum of the ratings of the two movies. Your task is to calculate the maximum possible rating of the company.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nThe first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$).\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$-1 \\le a_i \\le 1$$$), where $$$a_i$$$ is equal to $$$-1$$$ if the first movie was disliked by the $$$i$$$-th viewer; equal to $$$1$$$ if the first movie was liked; and $$$0$$$ if the attitude is neutral.\nThe third line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$-1 \\le b_i \\le 1$$$), where $$$b_i$$$ is equal to $$$-1$$$ if the second movie was disliked by the $$$i$$$-th viewer; equal to $$$1$$$ if the second movie was liked; and $$$0$$$ if the attitude is neutral.\nAdditional constraint on the input: the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, print a single integer — the maximum possible rating of the company, if for each person, choose which movie to leave a review on.\nExample\ninput\nCopy\n4\n2\n-1 1\n-1 -1\n1\n-1\n-1\n5\n0 -1 1 0 1\n-1 1 0 0 1\n4\n-1 -1 -1 1\n-1 1 1 1\noutput\nCopy\n0\n-1\n1\n1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1400"
        ],
        "link": "https://codeforces.com/contest/1989/problem/C",
        "solution": "import sys; R = sys.stdin.readline\nS = lambda: map(int,R().split())\n for _ in range(int(R())):\n    n = int(R())\n    a,b,c,d = 0,0,0,0\n    for x,y in zip(S(),S()):\n        if x>y: a += x\n        elif x<y: b += y\n        elif x>0: c += 1\n        elif x: d += 1\n    m = (a+b+c-d)//2\n    if a>b: a,b = b,a\n    print(m if a+c>=b-d else a+c)"
    },
    {
        "title": "D. Smithing Skill",
        "description": "You are playing a famous computer game (that just works) where you have various skills you can level up. Today, you focused on the \"Smithing\" skill. Your tactic is obvious: forging weapons from ingots and then melting them back to return the materials partially. For simplicity, every time you create an item, you get $$$1$$$ experience point, and every time you melt an item, you also get $$$1$$$ experience point.\nThere are $$$n$$$ classes of weapons you can forge and $$$m$$$ types of metal ingots.\nYou can create one weapon of the $$$i$$$-th class, spending $$$a_i$$$ ingots of metal of the same type. Melting a weapon of the $$$i$$$-th class (which you crafted earlier) returns you $$$b_i$$$ ingots of the type of metal it was made of.\nYou have $$$c_j$$$ metal ingots of the $$$j$$$-th type, and you know that you can craft a weapon of any class from any metal type. Each combination of a weapon class and a metal type can be used any number of times.\nWhat is the maximum total amount of experience you can earn by crafting and melting weapons?\nInput\nThe first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 10^6$$$) — the number of weapon classes and metal types.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$ ($$$1 \\le a_i \\le 10^6$$$), where $$$a_i$$$ is the number of ingots you need to forge one weapon of the $$$i$$$-th class.\nThe third line contains $$$n$$$ integers $$$b_1, b_2, \\dots, b_n$$$ ($$$0 \\le b_i < a_i$$$), where $$$b_i$$$ is the number of ingots you return by melting one weapon of the $$$i$$$-th class you forged earlier.\nThe fourth line contains $$$m$$$ integers $$$c_1, c_2, \\dots, c_m$$$ ($$$1 \\le c_j \\le 10^9$$$) — the number of ingots you have of the corresponding metal type.\nOutput\nPrint one integer — the maximum total experience points you can gain by repeatedly forging and melting weapons.\nExamples\ninput\nCopy\n5 3\n9 6 7 5 5\n8 4 5 1 2\n10 4 7\noutput\nCopy\n12\ninput\nCopy\n3 4\n10 20 20\n0 0 0\n9 10 19 20\noutput\nCopy\n8\ninput\nCopy\n1 5\n3\n1\n1000000000 1000000000 1000000000 1000000000 1000000000\noutput\nCopy\n4999999990\nNote\nIn the first example, you can do the following:\ncraft one weapon of the $$$1$$$-st class from the $$$1$$$-st type of metal, spending $$$9$$$ ingots;\nmelt that weapon, returning $$$8$$$ ingots of the $$$1$$$-st metal type;\nagain, craft and melt one weapon of the $$$1$$$-st class from the $$$1$$$-st metal type;\ncraft and melt one weapon of the $$$3$$$-rd class from the $$$1$$$-st metal type;\ncraft and melt one weapon of the $$$3$$$-rd class from the $$$3$$$-rd metal type;\ncraft and melt one weapon of the $$$4$$$-th class from the $$$1$$$-st metal type;\ncraft and melt one weapon of the $$$5$$$-th class from the $$$3$$$-rd metal type;\nIn the end you'll have $$$c = [2, 4, 2]$$$ ingots left. In total, you've crafted $$$6$$$ weapons and melted $$$6$$$ weapons, gaining $$$12$$$ experience points in total.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "math",
            "sortings",
            "two pointers",
            "*1900"
        ],
        "link": "https://codeforces.com/contest/1989/problem/D",
        "solution": "I = lambda: map(int, input().split())\nI()\nM = 10**6\nA = [M]*(M+1)\n for a, b in zip(I(), I()):\n A[a] = min(A[a], a-b)\n x, a = M, 0\nfor i in range(M+1):\n if A[i]<x: x, a = A[i], i\n if a>=x and a<=i:\n  d = (i-a+x)//x\n  A[i] = A[i-x*d]+2*d\n else:\n  A[i] = 0\ns = 0\nfor c in I():\n d = max(0, (c-a+x))//x\n s += A[c-x*d]+2*d\n print(s)"
    },
    {
        "title": "E. Distance to Different",
        "description": "Consider an array $$$a$$$ of $$$n$$$ integers, where every element is from $$$1$$$ to $$$k$$$, and every integer from $$$1$$$ to $$$k$$$ appears at least once.\nLet the array $$$b$$$ be constructed as follows: for the $$$i$$$-th element of $$$a$$$, $$$b_i$$$ is the distance to the closest element in $$$a$$$ which is not equal to $$$a_i$$$. In other words, $$$b_i = \\min \\limits_{j \\in [1, n], a_j \\ne a_i} |i - j|$$$.\nFor example, if $$$a = [1, 1, 2, 3, 3, 3, 3, 1]$$$, then $$$b = [2, 1, 1, 1, 2, 2, 1, 1]$$$.\nCalculate the number of different arrays $$$b$$$ you can obtain if you consider all possible arrays $$$a$$$, and print it modulo $$$998244353$$$.\nInput\nThe only line of the input contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 2 \\cdot 10^5$$$; $$$2 \\le k \\le \\min(n, 10)$$$).\nOutput\nPrint one integer — the number of different arrays $$$b$$$ you can obtain, taken modulo $$$998244353$$$.\nExamples\ninput\nCopy\n2 2\noutput\nCopy\n1\ninput\nCopy\n4 3\noutput\nCopy\n3\ninput\nCopy\n6 2\noutput\nCopy\n20\ninput\nCopy\n6 5\noutput\nCopy\n3\ninput\nCopy\n133 7\noutput\nCopy\n336975971",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2300"
        ],
        "link": "https://codeforces.com/contest/1989/problem/E",
        "solution": "n,k=map(int,input().split())\na,b,c,mod,dp=1,0,0,998244353,[1]*(3*k-3)\nfor j in range(n-1):\n    a,b,c=b,c,(c*2-b+a)%mod\n    for i in range(3*k-6,0,-3):\n        dp[i],dp[i+1],dp[i+2]=(dp[i-3]+dp[i+1])%mod,dp[i+2],(dp[i-3]+dp[i+2])%mod\nprint(1 if n==k else 3 if n==k+1 else(2*c+a-dp[-1]+mod)%mod)"
    },
    {
        "title": "F. Simultaneous Coloring",
        "description": "You are given a matrix, consisting of $$$n$$$ rows and $$$m$$$ columns.\nYou can perform two types of actions on it:\npaint the entire column in blue;\npaint the entire row in red.\nNote that you cannot choose which color to paint the row or column.\nIn one second, you can perform either one action or multiple actions at the same time. If you perform one action, it will be free. If you perform $$$k > 1$$$ actions at the same time, it will cost $$$k^2$$$ coins. When multiple actions are performed at the same time, for each cell affected by actions of both types, the color can be chosen independently.\nYou are asked to process $$$q$$$ queries. Before each query, all cells become colorless. Initially, there are no restrictions on the color of any cells. In the $$$i$$$-th query, a restriction of the following form is added:\n$$$x_i~y_i~c_i$$$ — the cell in row $$$x_i$$$ in column $$$y_i$$$ should be painted in color $$$c_i$$$.\nThus, after $$$i$$$ queries, there are $$$i$$$ restrictions on the required colors of the matrix cells. After each query, output the minimum cost of painting the matrix according to the restrictions.\nInput\nThe first line contains three integers $$$n, m$$$ and $$$q$$$ ($$$1 \\le n, m, q \\le 2 \\cdot 10^5$$$) — the size of the matrix and the number of queries.\nIn the $$$i$$$-th of the next $$$q$$$ lines, two integers $$$x_i, y_i$$$ and a character $$$c_i$$$ ($$$1 \\le x_i \\le n$$$; $$$1 \\le y_i \\le m$$$; $$$c_i \\in$$$ {'R', 'B'}, where 'R' means red, and 'B' means blue) — description of the $$$i$$$-th restriction. The cells in all queries are pairwise distinct.\nOutput\nPrint $$$q$$$ integers — after each query, output the minimum cost of painting the matrix according to the restrictions.\nExamples\ninput\nCopy\n2 2 4\n1 1 R\n2 2 R\n1 2 B\n2 1 B\noutput\nCopy\n0\n0\n0\n16\ninput\nCopy\n3 5 10\n1 1 B\n2 5 B\n2 2 B\n2 3 R\n2 1 B\n3 2 R\n3 3 B\n1 2 R\n1 3 B\n3 1 B\noutput\nCopy\n0\n0\n0\n0\n0\n0\n16\n16\n25\n25",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dfs and similar",
            "divide and conquer",
            "graphs",
            "*3000"
        ],
        "link": "https://codeforces.com/contest/1989/problem/F",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;using ll=long long;\nint rd(int x=0,char c=getchar()){int f=1;while(!isdigit(c))f=(c^'-'?1:-1),c=getchar();while(isdigit(c))x=x*10+(c^48),c=getchar();return x*f;}\nconst int N=4e5+5;\nint n,m,q;\nvector<int> E[N],nd[N];\nint in[N],low[N],dfn[N],T,bl[N],C;\nstack<int> st;\nstruct dat{int u,v,t;};\nvector<dat> Q;\nvoid tjn(int u){\n low[u]=dfn[u]=++T;in[u]=1;st.push(u);\n for(int v:E[u])if(!dfn[v])tjn(v),low[u]=min(low[u],low[v]);\n else if(in[v])low[u]=min(low[u],dfn[v]);\n if(dfn[u]==low[u]){\n  int x;C++;\n  do{x=st.top();in[x]=0;bl[x]=C;st.pop();}while(x^u);\n }\n}\nvoid sol(int l,int r,vector<dat>&Q){\n int mid=(l+r)>>1;\n T=C=0;\n for(auto[x,y,z]:Q)low[x]=low[y]=dfn[x]=dfn[y]=bl[x]=bl[y]=0,E[x].clear(),E[y].clear();\n vector<dat> Q1,Q2;\n for(auto[x,y,z]:Q)if(z<=mid)E[x].push_back(y);\n for(auto[x,y,z]:Q)if(!dfn[x])tjn(x);\n if(l==r){\n  for(auto[x,y,z]:Q)if(bl[x]==bl[y])nd[l].push_back(z);\n  return;\n }\n for(auto[x,y,z]:Q)if(bl[x]==bl[y]){\n  if(z<=mid)Q1.push_back({x,y,z});\n }else Q2.push_back({bl[x],bl[y],z});\n sol(l,mid,Q1);sol(mid+1,r,Q2);\n}\nint F[N],sz[N];ll ans;\nint getf(int x){return F[x]==x?x:F[x]=getf(F[x]);}\nvoid mrg(int x,int y){\n x=getf(x),y=getf(y);\n if(x==y)return;\n ans-=(sz[x]>1)*(ll)sz[x]*sz[x]+(sz[y]>1)*(ll)sz[y]*sz[y];\n sz[x]+=sz[y];F[y]=x;\n ans+=(ll)sz[x]*sz[x]; \n}\nint main(){\n n=rd(),m=rd(),q=rd();Q.resize(q); \n for(int i=1;i<=n+m;i++)F[i]=i,sz[i]=1;\n for(int i=1;i<=q;i++){\n  int x=rd(),y=rd();char op=getchar();\n  if(op=='R')Q[i-1]={x,y+n,i};\n  else Q[i-1]={y+n,x,i};\n }\n sol(1,q,Q);;\n for(int i=1;i<=q;i++){\n  for(int x:nd[i])mrg(Q[x-1].u,Q[x-1].v);\n  printf(\"%lld\\n\",ans);\n }\n return 0;\n}"
    },
    {
        "title": "A. Submission Bait",
        "description": "Alice and Bob are playing a game in an array\na\nof size\nn\n.\nThey take turns to do operations, with Alice starting first. The player who can not operate will lose. At first, a variable\nmx\nis set to\n0\n.\nIn one operation, a player can do:\nChoose an index\ni\n(\n1≤i≤n\n) such that\nai≥mx\nand set\nmx\nto\nai\n. Then, set\nai\nto\n0\n.\nDetermine whether Alice has a winning strategy.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤103\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n2≤n≤50\n) — the size of the array.\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤n\n) — the elements of the array.\nOutput\nFor each test case, if Alice has a winning strategy, output \"YES\". Otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n5\n2\n2 1\n2\n1 1\n3\n3 3 3\n4\n3 3 4 4\n4\n1 2 2 2\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first test case, Alice can choose\ni=1\nsince\na1=2≥mx=0\n.\nAfter Alice's operation,\na=[0,1]\nand\nmx=2\n. Bob can not do any operation. Alice wins.\nIn the second test case, Alice doesn't have a winning strategy.\nFor example, if Alice chooses\ni=1\n, after Alice's operation:\na=[0,1]\nand\nmx=1\n. Then, Bob can choose\ni=2\nsince\na2=1≥mx=1\n. After Bob's operation:\na=[0,0]\nand\nmx=1\n. Alice can not do any operation. Bob wins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "sortings",
            "*900"
        ],
        "link": "https://codeforces.com/contest/1990/problem/A",
        "solution": "for s in[*open(0)][2::2]:a=s.split();print('NYOE S'[any(a.count(x)%2for x in a)::2])"
    },
    {
        "title": "B. Array Craft",
        "description": "For an array $$$b$$$ of size $$$m$$$, we define:\nthe maximum prefix position of $$$b$$$ is the smallest index $$$i$$$ that satisfies $$$b_1+\\ldots+b_i=\\max_{j=1}^{m}(b_1+\\ldots+b_j)$$$;\nthe maximum suffix position of $$$b$$$ is the largest index $$$i$$$ that satisfies $$$b_i+\\ldots+b_m=\\max_{j=1}^{m}(b_j+\\ldots+b_m)$$$.\nYou are given three integers $$$n$$$, $$$x$$$, and $$$y$$$ ($$$x > y$$$). Construct an array $$$a$$$ of size $$$n$$$ satisfying:\n$$$a_i$$$ is either $$$1$$$ or $$$-1$$$ for all $$$1 \\le i \\le n$$$;\nthe maximum prefix position of $$$a$$$ is $$$x$$$;\nthe maximum suffix position of $$$a$$$ is $$$y$$$.\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\nInput\nThe first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$) — the number of test cases.\nFor each test case:\nThe only line contains three integers $$$n$$$, $$$x$$$, and $$$y$$$ ($$$2 \\leq n \\leq 10^5, 1 \\le y \\lt x \\le n)$$$.\nIt is guaranteed that the sum of $$$n$$$ over all test cases will not exceed $$$10^5$$$.\nOutput\nFor each test case, output $$$n$$$ space-separated integers $$$a_1, a_2, \\ldots, a_n$$$ in a new line.\nExample\ninput\nCopy\n3\n2 2 1\n4 4 3\n6 5 1\noutput\nCopy\n1 1\n1 -1 1 1\n1 1 -1 1 1 -1\nNote\nIn the second test case,\n$$$i=x=4$$$ is the smallest index that satisfies $$$a_1+\\ldots +a_i=\\max_{j=1}^{n}(a_1+\\ldots+a_j)=2$$$;\n$$$i=y=3$$$ is the greatest index that satisfies $$$a_i+\\ldots +a_n=\\max_{j=1}^{n}(a_j+\\ldots+a_n)=2$$$.\nThus, the array $$$a=[1,-1,1,1]$$$ is considered correct.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "link": "https://codeforces.com/contest/1990/problem/B",
        "solution": "for s in[*open(0)][1:]:n,x,y=map(int,s.split());t=[-1,1]*n;print(*t[-y:]+[1]*(x-y)+t[:n-x])"
    },
    {
        "title": "C. Mad MAD Sum",
        "description": "We define the $$$\\operatorname{MAD}$$$ (Maximum Appearing Duplicate) in an array as the largest number that appears at least twice in the array. Specifically, if there is no number that appears at least twice, the $$$\\operatorname{MAD}$$$ value is $$$0$$$.\nFor example, $$$\\operatorname{MAD}([1, 2, 1]) = 1$$$, $$$\\operatorname{MAD}([2, 2, 3, 3]) = 3$$$, $$$\\operatorname{MAD}([1, 2, 3, 4]) = 0$$$.\nYou are given an array $$$a$$$ of size $$$n$$$. Initially, a variable $$$sum$$$ is set to $$$0$$$.\nThe following process will be executed in a sequential loop until all numbers in $$$a$$$ become $$$0$$$:\nSet $$$sum := sum + \\sum_{i=1}^{n} a_i$$$;\nLet $$$b$$$ be an array of size $$$n$$$. Set $$$b_i :=\\ \\operatorname{MAD}([a_1, a_2, \\ldots, a_i])$$$ for all $$$1 \\le i \\le n$$$, and then set $$$a_i := b_i$$$ for all $$$1 \\le i \\le n$$$.\nFind the value of $$$sum$$$ after the process.\nInput\nThe first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 2 \\cdot 10^4$$$) — the number of test cases.\nFor each test case:\nThe first line contains an integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the size of the array $$$a$$$;\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq n$$$) — the elements of the array.\nIt is guaranteed that the sum of $$$n$$$ over all test cases will not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output the value of $$$sum$$$ in a new line.\nExample\ninput\nCopy\n4\n1\n1\n3\n2 2 3\n4\n2 1 1 2\n4\n4 4 4 4\noutput\nCopy\n1\n13\n9\n40\nNote\nIn the first test case, $$$a=[1]$$$ initially.\nIn the first loop:\nSet $$$sum := sum + a_1 = 0+1=1$$$;\nSet $$$b_1 :=\\ \\operatorname{MAD}([a_1])=\\ \\operatorname{MAD}([1])=0$$$, and then set $$$a_1 := b_1$$$.\nAfter the first loop, $$$a=[0]$$$ and the process ends. The value of $$$sum$$$ after the process is $$$1$$$.\nIn the second test case, $$$a=[2,2,3]$$$ initially.\nAfter the first loop, $$$a=[0,2,2]$$$ and $$$sum=7$$$.\nAfter the second loop, $$$a=[0,0,2]$$$ and $$$sum=11$$$.\nAfter the third loop, $$$a=[0,0,0]$$$ and $$$sum=13$$$. Then the process ends.\nThe value of $$$sum$$$ after the process is $$$13$$$.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1500"
        ],
        "link": "https://codeforces.com/contest/1990/problem/C",
        "solution": "O = [0]*4**9\nI = input\nfor t in range(1, int(I())+1):\n n = int(I())\n a = [*map(int, I().split())]\n ans = 0\n for _ in range(2):\n  m = 0\n  ans += sum(a)\n  for i in range(n):\n   e = a[i]\n   if O[e] == t: m = max(m, e)\n   O[e] = max(O[e], t)\n   a[i] = m\n  for e in a: O[e] = 0\n  for i in range(n):\n  ans += a[-i-1]*(i+1)\n print(ans)"
    },
    {
        "title": "D. Grid Puzzle",
        "description": "You are given an array\na\nof size\nn\n.\nThere is an\nn×n\ngrid. In the\ni\n-th row, the first\nai\ncells are black and the other cells are white. In other words, note\n(i,j)\nas the cell in the\ni\n-th row and\nj\n-th column, cells\n(i,1),(i,2),…,(i,ai)\nare black, and cells\n(i,ai+1),…,(i,n)\nare white.\nYou can do the following operations any number of times in any order:\nDye a\n2×2\nsubgrid white;\nDye a whole row white. Note you can not dye a whole column white.\nFind the minimum number of operations to dye all cells white.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n1≤n≤2⋅105\n) — the size of the array\na\n.\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n0≤ai≤n\n).\nIt's guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅105\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations to dye all cells white.\nExample\ninput\nCopy\n10\n1\n0\n4\n2 4 4 2\n4\n3 2 1 0\n3\n0 3 0\n3\n0 1 3\n3\n3 1 0\n4\n3 1 0 3\n4\n0 2 2 2\n6\n1 3 4 2 0 4\n8\n2 2 5 2 3 4 2 4\noutput\nCopy\n0\n3\n2\n1\n2\n2\n3\n2\n4\n6\nNote\nIn the first test case, you don't need to do any operation.\nIn the second test case, you can do:\nDye\n(1,1),(1,2),(2,1)\n, and\n(2,2)\nwhite;\nDye\n(2,3),(2,4),(3,3)\n, and\n(3,4)\nwhite;\nDye\n(3,1),(3,2),(4,1)\n, and\n(4,2)\nwhite.\nIt can be proven\n3\nis the minimum number of operations.\nIn the third test case, you can do:\nDye the first row white;\nDye\n(2,1),(2,2),(3,1)\n, and\n(3,2)\nwhite.\nIt can be proven\n2\nis the minimum number of operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1800"
        ],
        "link": "https://codeforces.com/contest/1990/problem/D",
        "solution": "<>;\n while(<>){\n $c = 0;\n  for(\n  split 0,\n  join '',\n  map {\n   $_ < 1 ? 0 :\n   $_ < 3 ? 1 :\n   $_ < 5 ? 2 :\n   0 * ++ $c\n   }\n   split ' ', <>\n  ){\n    0 while 0 \n    || s/^2//\n    || s/^11//\n    || s/^12./111/\n    || s/.//\n    and ++ $c\n  }\n  print $c . $/\n }"
    },
    {
        "title": "E1. Catch the Mole(Easy Version)",
        "description": "This is the easy version of the problem. The only difference is the limit on the number of queries.\nThis is an interactive problem.\nYou are given a tree of $$$n$$$ nodes with node $$$1$$$ as its root node.\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer $$$x$$$ ($$$1 \\le x \\le n$$$) to make an inquiry to the jury. Next, the jury will return $$$1$$$ when the mole is in subtree $$$x$$$. Otherwise, the judge will return $$$0$$$. If the judge returns $$$0$$$ and the mole is not in root node $$$1$$$, the mole will move to the parent node of the node it is currently on.\nUse at most $$$300$$$ operations to find the current node where the mole is located.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). The description of the test cases follows.\nInteraction\nThe first line of each test case contains one integer $$$n$$$ ($$$2 \\le n \\le 5000$$$).\nThe following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.\nIt is guaranteed that the input data represents a tree.\nThe interactor in this task is not adaptive. In other words, the node where the mole is located at first is fixed in every test case and does not change during the interaction.\nTo ask a query, you need to pick a vertex $$$x$$$ ($$$1 \\le x \\le n$$$) and print the line of the following form:\n\"? x\"\nAfter that, you receive:\n$$$0$$$ if the mole is not in subtree $$$x$$$;\n$$$1$$$ if the mole is in subtree $$$x$$$.\nYou can make at most $$$300$$$ queries of this form for each test case.\nNext, if your program has found the current node where the mole is located, print the line of the following form:\n\"! x\"\nNote that this line is not considered a query and is not taken into account when counting the number of queries asked.\nAfter this, proceed to the next test case.\nIf you make more than $$$300$$$ queries during an interaction, your program must terminate immediately, and you will receive the Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict Idleness Limit Exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo hack, follow the test format below.\nThe first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). The description of the test cases follows.\nThe first line of each test case contains two integers $$$n$$$ and $$$x$$$ ($$$2 \\le n \\le 5000$$$, $$$1 \\le x \\le n$$$) — the size of the tree and the initial position of the mole.\nThe following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.\nThe input data must represent a tree.\nExample\ninput\nCopy\n2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1\noutput\nCopy\n? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4\nNote\nIn the first test case, the mole is in node $$$2$$$ initially.\nFor the query \"? 2\", the jury returns $$$1$$$ because the mole is in subtree $$$2$$$. After this query, the mole does not move.\nThe answer $$$2$$$ is the current node where the mole is located, so the answer is considered correct.\nIn the second test case, the mole is in node $$$6$$$ initially.\nFor the query \"? 2\", the jury returns $$$0$$$ because the mole is not in subtree $$$2$$$. After this query, the mole moves from node $$$6$$$ to node $$$5$$$.\nFor the query \"? 6\", the jury returns $$$0$$$ because the mole is not in subtree $$$6$$$. After this query, the mole moves from node $$$5$$$ to node $$$4$$$.\nFor the query \"? 4\", the jury returns $$$1$$$ because the mole is in subtree $$$4$$$. After this query, the mole does not move.\nThe answer $$$4$$$ is the current node where the mole is located, so the answer is considered correct.\nPlease note that the example is only for understanding the statement, and the queries in the example do not guarantee to determine the unique position of the mole.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "interactive",
            "trees",
            "*2500"
        ],
        "link": "https://codeforces.com/contest/1990/problem/E1",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;\ninline int ask(int x){\n  cout<<\"? \"<<x+1<<endl;\n  int b; cin>>b; return b;\n}\ninline int solve(vector<set<int> > g){\n  vector<int> f(g.size()),d(g.size()),m(g.size());\n  function<void(int,int)> dfs=[&](int u,int p){\n    f[u]=p,m[u]=d[u];\n    for(int i:g[u])\n      if(i!=p)d[i]=d[u]+1,dfs(i,u),m[u]=max(m[u],m[i]);\n  };\n  dfs(0,0);\n  vector<bool> b(g.size());\n  int l=max_element(d.begin(),d.end())-d.begin();\n  if(ask(l))return l;\n  for(int i=0;i<g.size();i++)\n    if(m[i]-d[i]==51&&!b[i]){\n      if(b[i]=true;ask(i)){\n        if(i){\n          while(ask(l),ask(i));\n          return ask(f[i])?f[i]:f[f[f[i]]];\n        }\n        else break;\n      }\n      else g[f[i]].erase(i),g[i].erase(f[i]),dfs(0,0),i=-1;\n    }\n  for(int i=0;i<100;i++)ask(l);\n  return 0;\n}\nint main(){\n  ios::sync_with_stdio(false);\n  int t; cin>>t;\n  while(t--){\n    int n; cin>>n;\n    vector<set<int> > g(n);\n    for(int i=1;i<n;i++){\n      int u,v; cin>>u>>v;\n      g[--u].emplace(--v),g[v].emplace(u);\n    }\n    int x=solve(g);\n    cout<<\"! \"<<x+1<<endl;\n  }\n  return 0;\n}"
    },
    {
        "title": "E2. Catch the Mole(Hard Version)",
        "description": "This is the hard version of the problem. The only difference is the limit on the number of queries.\nThis is an interactive problem.\nYou are given a tree of $$$n$$$ nodes with node $$$1$$$ as its root node.\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer $$$x$$$ ($$$1 \\le x \\le n$$$) to make an inquiry to the jury. Next, the jury will return $$$1$$$ when the mole is in subtree $$$x$$$. Otherwise, the judge will return $$$0$$$. If the judge returns $$$0$$$ and the mole is not in root node $$$1$$$, the mole will move to the parent node of the node it is currently on.\nUse at most $$$160$$$ operations to find the current node where the mole is located.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). The description of the test cases follows.\nInteraction\nThe first line of each test case contains one integer $$$n$$$ ($$$2 \\le n \\le 5000$$$).\nThe following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.\nIt is guaranteed that the input data represents a tree.\nThe interactor in this task is not adaptive. In other words, the node where the mole is located at first is fixed in every test case and does not change during the interaction.\nTo ask a query, you need to pick a vertex $$$x$$$ ($$$1 \\le x \\le n$$$) and print the line of the following form:\n\"? x\"\nAfter that, you receive:\n$$$0$$$ if the mole is not in subtree $$$x$$$;\n$$$1$$$ if the mole is in subtree $$$x$$$.\nYou can make at most $$$160$$$ queries of this form for each test case.\nNext, if your program has found the current node where the mole is located, print the line of the following form:\n\"! x\"\nNote that this line is not considered a query and is not taken into account when counting the number of queries asked.\nAfter this, proceed to the next test case.\nIf you make more than $$$160$$$ queries during an interaction, your program must terminate immediately, and you will receive the Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict Idleness Limit Exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo hack, follow the test format below.\nThe first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 100$$$). The description of the test cases follows.\nThe first line of each test case contains one integer $$$n$$$ and $$$x$$$ ($$$2 \\le n \\le 5000$$$, $$$1 \\le x \\le n$$$) — the size of the tree and the initial position of the mole.\nThe following $$$n-1$$$ lines describe the edges of the tree. Each line contains two space-separated integers $$$u_i$$$ and $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$), indicating an edge between nodes $$$u_i$$$ and $$$v_i$$$.\nThe input data must represent a tree.\nExample\ninput\nCopy\n2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1\noutput\nCopy\n? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4\nNote\nIn the first test case, the mole is in node $$$2$$$ initially.\nFor the query \"? 2\", the jury returns $$$1$$$ because the mole is in subtree $$$2$$$. After this query, the mole does not move.\nThe answer $$$2$$$ is the current node where the mole is located, so the answer is considered correct.\nIn the second test case, the mole is in node $$$6$$$ initially.\nFor the query \"? 2\", the jury returns $$$0$$$ because the mole is not in subtree $$$2$$$. After this query, the mole moves from node $$$6$$$ to node $$$5$$$.\nFor the query \"? 6\", the jury returns $$$0$$$ because the mole is not in subtree $$$6$$$. After this query, the mole moves from node $$$5$$$ to node $$$4$$$.\nFor the query \"? 4\", the jury returns $$$1$$$ because the mole is in subtree $$$4$$$. After this query, the mole does not move.\nThe answer $$$4$$$ is the current node where the mole is located, so the answer is considered correct.\nPlease note that the example is only for understanding the statement, and the queries in the example do not guarantee to determine the unique position of the mole.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "interactive",
            "trees",
            "*2600"
        ],
        "link": "https://codeforces.com/contest/1990/problem/E2",
        "solution": "#include <bits/stdc++.h>\nusing namespace std; const int N = 5005;\nvector<int> g[N], ord; int d[N], s = 73, c, t;\nbool check(int x) { return cout << \"? \" << x << '\\n', cin >> x, x; }\nvoid dfs(int v, int p = -1) {\n ord.push_back(v);\n for (auto u: g[v]) if (u != p && d[u] >= s) c = u;\n for (auto u: g[v]) if (u != p && d[u] >= s) if (u == c || check(u)) return dfs(u, v);\n}\nvoid cfs(int v, int p = -1) { for (auto u: g[v]) if (u != p) cfs(u, v), d[v] = max(d[u] + 1, d[v]); }\nint main() {\n for (cin >> t; t--;) {\n  int n, q = 0, fl = 0;\n  cin >> n;\n  for (int v = 1; v <= n; ++v) d[v] = 0, g[v].clear();\n  for (int i = 1, x, y; i < n && cin >> x >> y; ++i) g[x].push_back(y), g[y].push_back(x);\n  for (int i = 2; i <= n; ++i) if (g[i].size() == 1) q = i;\n  for (int i = 0; i < s; ++i) fl |= check(q);\n  if (fl) {\n   cout << \"! \" << q << '\\n';\n   continue;\n  }\n  ord.clear(), cfs(1), dfs(1);\n  int l = 0, r = ord.size() - 1, mid;\n  while (l != r) mid = (l + r + 1) >> 1, check(ord[mid]) ? l = mid : (r = mid - 2, --l, l = max(l, 0), r = max(r, 0));\n  cout << \"! \" << ord[l] << '\\n';\n }\n}"
    },
    {
        "title": "F. Polygonal Segments",
        "description": "You are given an array\na\nof size\nn\n.\nA segment\n[l,r](1≤l<r≤n)\nis called a polygonal segment only if the following conditions hold:\n(r−l+1)≥3\n;\nConsidering\nal,al+1,…,ar\nas side lengths, these sides can form a polygon with\n(r−l+1)\nsides.\nProcess\nq\nqueries of two types:\n\"1 l r\": find the length of the longest segment among all polygonal segments\n[l0,r0]\nsatisfying\nl≤l0≤r0≤r\n. If there is no such polygonal segment, output\n−1\ninstead;\n\"2 i x\": assign\nai:=x\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nFor each test case:\nThe first line of each testcase contains two integers\nn\n,\nq\n(\n4≤n≤2⋅105\n,\n1≤q≤105\n);\nThe second line of each testcase contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤1012\n);\nThe following\nq\nlines contain the description of queries. Each line is of one of two types:\n\"1 l r\" (\n1≤l<r≤n\n,\nr−l+1≥3\n);\n\"2 i x\" (\n1≤i≤n\n,\n1≤x≤1012\n).\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅105\n, and the sum of\nq\nover all test cases will not exceed\n105\n.\nOutput\nFor each query, if there is no suitable segment, output\n−1\nin a new line. Otherwise, output the length of the longest segment satisfying the condition above in a new line.\nExample\ninput\nCopy\n2\n5 6\n3 1 2 2 8\n1 1 3\n1 1 4\n1 1 5\n2 1 5\n1 1 4\n1 1 5\n4 10\n500000000000 500000000000 1000000000000 500000000000\n1 1 3\n1 2 4\n1 1 4\n2 1 499999999999\n2 3 999999999999\n1 1 3\n1 2 4\n1 1 4\n2 3 1000000000000\n1 1 3\noutput\nCopy\n-1\n4\n4\n3\n5\n-1\n-1\n4\n-1\n3\n4\n-1\nNote\nIn the first query of the first test case, there is no polygonal segment under the given condition. For example, considering segment\n[1,3]\n, you can not form a triangle with side lengths of\na1=3\n,\na2=1\n, and\na3=2\n.\nIn the second query of the first test case, the longest polygonal segment is\n[1,4]\n. You can form a quadrilateral with side lengths of\na1=3\n,\na2=1\n,\na3=2\n, and\na4=2\n.\nAn example of a quadrilateral with side lengths of\n3\n,\n1\n,\n2\n, and\n2\n.",
        "time_limit": "8 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "two pointers",
            "*2800"
        ],
        "link": "https://codeforces.com/contest/1990/problem/F",
        "solution": "#include <bits/stdc++.h>\n#define pb push_back\n#define fst first\n#define snd second\n#define fore(i,a,b) for(ll i=a,jet=b;i<jet;++i)\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define FIN ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\n#define imp(v) {for(auto gdljh:v)cout<<gdljh<<\" \"; cout<<\"\\n\";}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\nconst ll MAXN=2e5+5;\nll a[MAXN];\ntypedef ll node;\nnode NEUT[3]={-1,0,-1};\nnode oper(node i, node j, ll ty){\n if(ty==1)return i+j;\n if(ty==0){\n  if(i==-1)return j;\n  if(j==-1)return i;\n  return (a[i]>=a[j]?i:j);\n }\n return max(i,j);\n}\nstruct STree{\n int n,ty; vector<node>t;\n STree(int n, int ty):n(n),ty(ty),t(2*n+5,NEUT[ty]){}\n void upd(int p, node v){\n  for(p+=n,t[p]=v;p>1;p>>=1)t[p>>1]=oper(t[p],t[p^1],ty);\n }\n node query(int l, int r){\n  node res=NEUT[ty];\n  for(l+=n,r+=n;l<r;l>>=1,r>>=1){\n   if(l&1)res=oper(res,t[l++],ty);\n   if(r&1)res=oper(res,t[--r],ty);\n  }\n  return res;\n }\n};\nmap<ll,ii>dp[MAXN];\nint main(){FIN;\n ll t; cin>>t;\n while(t--){\n  ll n,q; cin>>n>>q;\n  fore(i,0,n)cin>>a[i];\n  STree stm(n,0),sts(n,1),tim(n,2);\n  fore(i,0,n)sts.upd(i,a[i]),stm.upd(i,i);\n      ll cnt=0;\n  auto f=[&](ll l, ll r, auto &&f)->ll{\n   if(r-l<=0)return -1;\n   ll vis=dp[l].count(r);\n   auto &res=dp[l][r];\n     if(vis&&tim.query(l,r)<=res.snd)return res.fst;\n   res.snd=cnt;\n   ll p=stm.query(l,r),s=sts.query(l,r);\n      if(s-a[p]>a[p])return res.fst=r-l;\n   return res.fst=max(f(l,p,f),f(p+1,r,f));\n  };\n  while(q--){\n   ll ty,l,r; cin>>ty>>l>>r; l--;\n   if(ty==1){\n    cout<<f(l,r,f)<<\"\\n\";\n   }\n   else {\n    a[l]=r;\n    sts.upd(l,r);\n    stm.upd(l,l);\n    tim.upd(l,cnt);\n   }\n   cnt++;\n     }\n  fore(i,0,n)dp[i].clear();\n }\n return 0;\n}"
    },
    {
        "title": "A. Maximize the Last Element",
        "description": "You are given an array $$$a$$$ of $$$n$$$ integers, where $$$n$$$ is odd.\nIn one operation, you will remove two adjacent elements from the array $$$a$$$, and then concatenate the remaining parts of the array. For example, given the array $$$[4,7,4,2,9]$$$, we can obtain the arrays $$$[4,2,9]$$$ and $$$[4,7,9]$$$ by the operations $$$[\\underline{4,7}, 4,2,9] \\to [4,2,9]$$$ and $$$[4,7,\\underline{4,2},9] \\to [4,7,9]$$$ respectively. However, we cannot obtain the array $$$[7,2,9]$$$ as it requires deleting non-adjacent elements $$$[\\underline{4},7,\\underline{4},2,9]$$$.\nYou will repeatedly perform this operation until exactly one element remains in $$$a$$$.\nFind the maximum possible value of the remaining element in $$$a$$$.\nInput\nEach test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 99$$$; $$$n$$$ is odd) — the length of the array $$$a$$$.\nThe second line of each test case contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 100$$$) — the elements of the array $$$a$$$.\nNote that there is no bound on the sum of $$$n$$$ over all test cases.\nOutput\nFor each test case, output a single integer — the maximum possible value of the remaining element in $$$a$$$.\nExample\ninput\nCopy\n4\n1\n6\n3\n1 3 2\n5\n4 7 4 2 9\n7\n3 1 4 1 5 9 2\noutput\nCopy\n6\n2\n9\n5\nNote\nIn the first test case, the array $$$a$$$ is $$$[6]$$$. Since there is only one element, no operations are needed. The maximum possible value of the remaining element is $$$6$$$.\nIn the second test case, the array $$$a$$$ is $$$[1, 3, 2]$$$. We can remove the first two elements $$$[\\underline{1, 3}, 2] \\to [2]$$$, or remove the last two elements $$$[1, \\underline{3, 2}] \\to [1]$$$. Therefore, the maximum possible value of the remaining element is $$$2$$$.\nIn the third test case, the array $$$a$$$ is $$$[4, 7, 4, 2, 9]$$$. One way to maximize the remaining element is $$$[4, \\underline{7, 4}, 2, 9] \\to [\\underline{4, 2}, 9] \\to [9]$$$. Therefore, the maximum possible value of the remaining element is $$$9$$$.\nIn the fourth test case, the array $$$a$$$ is $$$[3, 1, 4, 1, 5, 9, 2]$$$. It can be shown that the maximum possible value of the remaining element is $$$5$$$.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1991/problem/A",
        "solution": "for s in[*open(0)][2::2]:print(max(s.split()[::2],key=int))"
    },
    {
        "title": "B. AND Reconstruction",
        "description": "You are given an array\nb\nof\nn−1\nintegers.\nAn array\na\nof\nn\nintegers is called good if\nbi=ai&ai+1\nfor\n1≤i≤n−1\n, where\n&\ndenotes the bitwise AND operator.\nConstruct a good array, or report that no good arrays exist.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤105\n) — the length of the array\na\n.\nThe second line of each test case contains\nn−1\nintegers\nb1,b2,…,bn−1\n(\n0≤bi<230\n) — the elements of the array\nb\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n105\n.\nOutput\nFor each test case, output a single integer\n−1\nif no good arrays exist.\nOtherwise, output\nn\nspace-separated integers\na1,a2,…,an\n(\n0≤ai<230\n) — the elements of a good array\na\n.\nIf there are multiple solutions, you may output any of them.\nExample\ninput\nCopy\n4\n2\n1\n3\n2 0\n4\n1 2 3\n5\n3 5 4 2\noutput\nCopy\n5 3\n3 2 1\n-1\n3 7 5 6 3\nNote\nIn the first test case,\nb=[1]\n. A possible good array is\na=[5,3]\n, because\na1&a2=5&3=1=b1\n.\nIn the second test case,\nb=[2,0]\n. A possible good array is\na=[3,2,1]\n, because\na1&a2=3&2=2=b1\nand\na2&a3=2&1=0=b2\n.\nIn the third test case,\nb=[1,2,3]\n. It can be shown that no good arrays exist, so the output is\n−1\n.\nIn the fourth test case,\nb=[3,5,4,2]\n. A possible good array is\na=[3,7,5,6,3]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "link": "https://codeforces.com/contest/1991/problem/B",
        "solution": "for s in[*open(0)][2::2]:*b,=map(int,s.split());print(*(a:=[x|y\nfor x,y in zip([0]+b,b+[0])],[-1])[b<[x&y for x,y in zip(a,a[1:])]])"
    },
    {
        "title": "C. Absolute Zero",
        "description": "You are given an array\na\nof\nn\nintegers.\nIn one operation, you will perform the following two-step move:\nChoose an integer\nx\n(\n0≤x≤109\n).\nReplace each\nai\nwith\n|ai−x|\n, where\n|v|\ndenotes the absolute value of\nv\n.\nFor example, by choosing\nx=8\n, the array\n[5,7,10]\nwill be changed into\n[|5−8|,|7−8|,|10−8|]=[3,1,2]\n.\nConstruct a sequence of operations to make all elements of\na\nequal to\n0\nin at most\n40\noperations or determine that it is impossible. You do not need to minimize the number of operations.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅105\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n0≤ai≤109\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output a single integer\n−1\nif it is impossible to make all array elements equal to\n0\nin at most\n40\noperations.\nOtherwise, output two lines. The first line of output should contain a single integer\nk\n(\n0≤k≤40\n) — the number of operations. The second line of output should contain\nk\nintegers\nx1,x2,…,xk\n(\n0≤xi≤109\n) — the sequence of operations, denoting that on the\ni\n-th operation, you chose\nx=xi\n.\nIf there are multiple solutions, output any of them.\nYou do not need to minimize the number of operations.\nExample\ninput\nCopy\n5\n1\n5\n2\n0 0\n3\n4 6 8\n4\n80 40 20 10\n5\n1 2 3 4 5\noutput\nCopy\n1\n5\n0\n\n3\n6 1 1\n7\n60 40 20 10 30 25 5\n-1\nNote\nIn the first test case, we can perform only one operation by choosing\nx=5\n, changing the array from\n[5]\nto\n[0]\n.\nIn the second test case, no operations are needed because all elements of the array are already\n0\n.\nIn the third test case, we can choose\nx=6\nto change the array from\n[4,6,8]\nto\n[2,0,2]\n, then choose\nx=1\nto change it to\n[1,1,1]\n, and finally choose\nx=1\nagain to change the array into\n[0,0,0]\n.\nIn the fourth test case, we can make all elements\n0\nby following the operation sequence\n(60,40,20,10,30,25,5)\n.\nIn the fifth test case, it can be shown that it is impossible to make all elements\n0\nin at most\n40\noperations. Therefore, the output is\n−1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1300"
        ],
        "link": "https://codeforces.com/contest/1991/problem/C",
        "solution": "for s in[*open(0)][2::2]:s={~int(x)&1for x in s.split()};print(*(s>{0}and[-1]or[31,*(1<<i\nfor i in range(29,-1,-1)),s.pop()]))"
    },
    {
        "title": "D. Prime XOR Coloring",
        "description": "You are given an undirected graph with $$$n$$$ vertices, numbered from $$$1$$$ to $$$n$$$. There is an edge between vertices $$$u$$$ and $$$v$$$ if and only if $$$u \\oplus v$$$ is a prime number, where $$$\\oplus$$$ denotes the bitwise XOR operator.\nColor all vertices of the graph using the minimum number of colors, such that no two vertices directly connected by an edge have the same color.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 500$$$). The description of test cases follows.\nThe only line contains a single integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — the number of vertices in the graph.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output two lines.\nThe first line should contain a single integer $$$k$$$ ($$$1 \\le k \\le n$$$) — the minimum number of colors required.\nThe second line should contain $$$n$$$ integers $$$c_1, c_2, \\ldots, c_n$$$ ($$$1 \\le c_i \\le k$$$) — the color of each vertex.\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n6\n1\n2\n3\n4\n5\n6\noutput\nCopy\n1\n1\n2\n1 2\n2\n1 2 2\n3\n1 2 2 3\n3\n1 2 2 3 3\n4\n1 2 2 3 3 4\nNote\nIn the first test case, the minimum number of colors is $$$1$$$, because there is only one vertex.\nIn the second test case, the minimum number of colors is $$$2$$$, because there is an edge connecting $$$1$$$ and $$$2$$$ ($$$1 \\oplus 2 = 3$$$, which is a prime number).\nIn the third test case, the minimum number of colors is still $$$2$$$, because $$$2$$$ and $$$3$$$ can be colored the same since there is no edge between $$$2$$$ and $$$3$$$ ($$$2 \\oplus 3 = 1$$$, which is not a prime number).\nIn the fourth test case, it can be shown that the minimum number of colors is $$$3$$$.\nIn the fifth test case, it can be shown that the minimum number of colors is $$$3$$$.\nIn the sixth test case, it can be shown that the minimum number of colors is $$$4$$$.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "graphs",
            "greedy",
            "math",
            "number theory",
            "*1900"
        ],
        "link": "https://codeforces.com/contest/1991/problem/D",
        "solution": "for t in range(int(input())):\n n = int(input())\n if n < 6:\n  z = [1, 2, 2, 3, 3][:n]\n else:\n  z = [i % 4 + 1 for i in range(n)]\n print(max(z))\n print(*z)"
    },
    {
        "title": "E. Coloring Game",
        "description": "This is an interactive problem.\nConsider an undirected connected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. Each vertex can be colored with one of three colors: $$$1$$$, $$$2$$$, or $$$3$$$. Initially, all vertices are uncolored.\nAlice and Bob are playing a game consisting of $$$n$$$ rounds. In each round, the following two-step process happens:\nAlice chooses two different colors.\nBob chooses an uncolored vertex and colors it with one of the two colors chosen by Alice.\nAlice wins if there exists an edge connecting two vertices of the same color. Otherwise, Bob wins.\nYou are given the graph. Your task is to decide which player you wish to play as and win the game.\nInput\nEach test contains multiple test cases. The first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers $$$n$$$, $$$m$$$ ($$$1 \\le n \\le 10^4$$$, $$$n - 1 \\le m \\le \\min(\\frac{n \\cdot (n - 1)}{2}, 10^4)$$$) — the number of vertices and the number of edges in the graph, respectively.\nEach of the next $$$m$$$ lines of each test case contains two integers $$$u_i$$$, $$$v_i$$$ ($$$1 \\le u_i, v_i \\le n$$$) — the edges of the graph. It is guaranteed that the graph is connected and there are no multiple edges or self-loops.\nIt is guaranteed that the sum of $$$n$$$ and the sum of $$$m$$$ over all test cases does not exceed $$$10^4$$$.\nInteraction\nFor each test case, you need to output a single line containing either \"Alice\" or \"Bob\", representing the player you choose.\nThen for each of the following $$$n$$$ rounds, the following two-step process happens:\nAlice (either you or the interactor) will output two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b \\le 3$$$, $$$a \\neq b$$$) — the colors chosen by Alice.\nBob (either you or the interactor) will output two integers $$$i$$$ and $$$c$$$ ($$$1 \\le i \\le n$$$, $$$c = a$$$ or $$$c = b$$$) — the vertex and the color chosen by Bob. Vertex $$$i$$$ must be a previously uncolored vertex.\nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nAt the end of all $$$n$$$ turns, if you have lost the game, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nIf your program has received a $$$-1$$$ instead of a valid value, it must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nNote that if you are playing as Alice, and there already exists an edge connected two vertices of the same color, the interactor will not terminate early and you will keep playing all $$$n$$$ rounds.\nAfter outputting, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nIn this problem, hacks are disabled.\nExample\ninput\nCopy\n2\n3 3\n1 2\n2 3\n3 1\n\n\n3 1\n\n2 2\n\n1 1\n4 4\n1 2\n2 3\n3 4\n4 1\n\n2 3\n\n1 2\n\n2 1\n\n3 1\noutput\nCopy\nAlice\n3 1\n\n1 2\n\n2 1\n\n\n\n\n\n\nBob\n\n1 2\n\n2 1\n\n4 1\n\n3 3\nNote\nNote that the sample test cases are example games and do not necessarily represent the optimal strategy for both players.\nIn the first test case, you choose to play as Alice.\nAlice chooses two colors: $$$3$$$ and $$$1$$$. Bob chooses vertex $$$3$$$ and colors it with color $$$1$$$.\nAlice chooses two colors: $$$1$$$ and $$$2$$$. Bob chooses vertex $$$2$$$ and colors it with color $$$2$$$.\nAlice chooses two colors: $$$2$$$ and $$$1$$$. Bob chooses vertex $$$1$$$ and colors it with color $$$1$$$.\nAlice wins because the edge $$$(3, 1)$$$ connects two vertices of the same color.\nIn the second test case, you choose to play as Bob.\nAlice chooses two colors: $$$2$$$ and $$$3$$$. Bob chooses vertex $$$1$$$ and colors it with color $$$2$$$.\nAlice chooses two colors: $$$1$$$ and $$$2$$$. Bob chooses vertex $$$2$$$ and colors it with color $$$1$$$.\nAlice chooses two colors: $$$2$$$ and $$$1$$$. Bob chooses vertex $$$4$$$ and colors it with color $$$1$$$.\nAlice chooses two colors: $$$3$$$ and $$$1$$$. Bob chooses vertex $$$3$$$ and colors it with color $$$3$$$.\nBob wins because there are no edges with vertices of the same color.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "games",
            "graphs",
            "greedy",
            "interactive",
            "*1900"
        ],
        "link": "https://codeforces.com/contest/1991/problem/E",
        "solution": "#include<bits/stdc++.h>\n#define eb emplace_back\nusing namespace std;\ntypedef long long ll;\nconst ll _=1e5+5;\nll N,n,m,x,y,t,a[_],b[_],c[_],i;vector<ll>E[_],A,B;\ninline void p1(ll x){\n for(auto y:E[x]){\n  if(!a[y])a[y]=a[x]^1,p1(y);\n  else if(a[y]==a[x])t=1;\n }\n}\ninline void P(){\n cin>>n>>m;A.clear();B.clear();\n for(i=0;i<=n;i++)a[i]=b[i]=c[i]=0,E[i].clear();\n while(m--)cin>>x>>y,E[x].eb(y),E[y].eb(x);\n a[1]=2;t=0;p1(1);\n if(t){\n  cout<<\"Alice\"<<endl;\n  for(i=0;i<n;i++){\n   cout<<\"1 2\"<<endl;\n   cin>>x>>y;\n  }\n }\n else{\n  cout<<\"Bob\"<<endl;\n  for(i=1;i<=n;i++)(a[i]==2?A:B).eb(i);\n  for(i=0;i<n;i++){\n   cin>>x>>y;x^=y;\n   if(x==1){\n    if(A.size())cout<<A.back()<<\" 2\"<<endl,A.pop_back();\n    else cout<<B.back()<<\" 3\"<<endl,B.pop_back();\n   }\n   else{\n    if(B.size())cout<<B.back()<<\" 1\"<<endl,B.pop_back();\n    else cout<<A.back()<<' '<<(x^1)<<endl,A.pop_back();\n   }\n  }\n }\n}\nint main(){cin>>N;while(N--)P();}"
    },
    {
        "title": "F. Triangle Formation",
        "description": "You are given $$$n$$$ sticks, numbered from $$$1$$$ to $$$n$$$. The length of the $$$i$$$-th stick is $$$a_i$$$.\nYou need to answer $$$q$$$ queries. In each query, you are given two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l < r \\le n$$$, $$$r - l + 1 \\ge 6$$$). Determine whether it is possible to choose $$$6$$$ distinct sticks from the sticks numbered $$$l$$$ to $$$r$$$, to form $$$2$$$ non-degenerate triangles$$$^{\\text{∗}}$$$.\n$$$^{\\text{∗}}$$$A triangle with side lengths $$$a$$$, $$$b$$$, and $$$c$$$ is called non-degenerate if:\n$$$a < b + c$$$,\n$$$b < a + c$$$, and\n$$$c < a + b$$$.\nInput\nThe first line contains two integers $$$n$$$ and $$$q$$$ ($$$6 \\le n \\le 10^5$$$, $$$1 \\le q \\le 10^5$$$) — the number of sticks and the number of queries respectively.\nThe second line contains $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — $$$a_i$$$ denotes the length of the $$$i$$$-th stick.\nEach of the following $$$q$$$ lines contains two integers $$$l$$$ and $$$r$$$ ($$$1 \\le l < r \\le n$$$, $$$r - l + 1 \\ge 6$$$) — the parameters of each query.\nOutput\nFor each query, output \"YES\" (without quotes) if it is possible to form $$$2$$$ triangles, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n10 5\n5 2 2 10 4 10 6 1 5 3\n1 6\n2 7\n2 8\n5 10\n4 10\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first query, the lengths of the sticks are $$$[5, 2, 2, 10, 4, 10]$$$. Two sets of sticks $$$[2, 4, 5]$$$ and $$$[2, 10, 10]$$$ can be selected to form $$$2$$$ non-degenerate triangles.\nIn the second query, the lengths of the sticks are $$$[2, 2, 10, 4, 10, 6]$$$. It can be shown that it is impossible to form $$$2$$$ non-degenerate triangles.\nIn the third query, the lengths of the sticks are $$$[2, 2, 10, 4, 10, 6, 1]$$$. Two sets of sticks $$$[1, 2, 2]$$$ and $$$[4, 10, 10]$$$ can be selected to form $$$2$$$ non-degenerate triangles.\nIn the fourth query, the lengths of the sticks are $$$[4, 10, 6, 1, 5, 3]$$$. It can be shown that it is impossible to form $$$2$$$ non-degenerate triangles.\nIn the fifth query, the lengths of the sticks are $$$[10, 4, 10, 6, 1, 5, 3]$$$. Two sets of sticks $$$[1, 10, 10]$$$ and $$$[3, 4, 5]$$$ can be selected to form $$$2$$$ non-degenerate triangles.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*2200"
        ],
        "link": "https://codeforces.com/contest/1991/problem/F",
        "solution": "function solve(){var i=readline().split(\" \"),n=parseInt(i[0]),m=parseInt(i[1]),a=[];for(i=readline().split(\" \"),j=0;j<n;j++)a[j]=parseInt(i[j]);for(;m--;){var l=readline().split(\" \"),r=parseInt(l[1])-1,l=parseInt(l[0])-1;if(r-l+1>48)print(\"YES\");else{for(var v=[],j=l;j<=r;j++)v.push(a[j]);var o=0,c=0;for(v.sort(((a,b)=>a-b)),j=0;j<v.length-5;j++)for(k=j;k<=j+4;k++)for(p=k+1;p<=j+4;p++)if(v[k]+v[p]>v[j+5]){var w=[];for(q=j;q<=j+4;q++)q!=k&&q!=p&&w.push(v[q]);w[0]+w[1]>w[2]&&(o=1)}for(j=0;j<v.length-2;j++)v[j]+v[j+1]>v[j+2]&&(c++,j+=2);o||c>1?print(\"YES\"):print(\"NO\")}}}solve();"
    },
    {
        "title": "G. Grid Reset",
        "description": "You are given a grid consisting of\nn\nrows and\nm\ncolumns, where each cell is initially white. Additionally, you are given an integer\nk\n, where\n1≤k≤min(n,m)\n.\nYou will process\nq\noperations of two types:\nH\n(horizontal operation) — You choose a\n1×k\nrectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\nV\n(vertical operation) — You choose a\nk×1\nrectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\nAfter each operation, if any rows or columns become completely black, all cells in these rows and columns are simultaneously reset to white. Specifically, if all cells in the row and column a cell is contained in become black, all cells in both the row and column will be reset to white.\nChoose the rectangles in a way that you can perform all given operations, or determine that it is impossible.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains four integers\nn\n,\nm\n,\nk\n, and\nq\n(\n1≤n,m≤100\n,\n1≤k≤min(n,m)\n,\n1≤q≤1000\n) — the number of rows and columns in the grid, the size of the operation rectangle, and the number of operations, respectively.\nThe second line of each test case contains a string\ns\nof length\nq\n, consisting only of characters\nH\nand\nV\n — the sequence of operation types.\nIt is guaranteed that the sum of\nq\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output a single integer\n−1\nif it is impossible to perform all the operations.\nOtherwise, output\nq\nlines. Each line contains two integers\ni\n,\nj\n(\n1≤i≤n\n,\n1≤j≤m\n) — the coordinates of the top-left cell of the operation rectangle.\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n1\n4 5 3 6\nHVVHHV\noutput\nCopy\n1 1\n2 1\n1 1\n2 3\n3 3\n2 2\nNote\nIllustration of example.\nThe first operation is horizontal. The operation rectangle starts at\n(1,1)\nand is a\n1×3\nrectangle. After the operation, cells\n(1,1)\n,\n(1,2)\n, and\n(1,3)\nbecome black.\nThe second operation is vertical. The operation rectangle starts at\n(2,1)\nand is a\n3×1\nrectangle. After the operation, cells\n(2,1)\n,\n(3,1)\n, and\n(4,1)\nbecome black. At this point, the first column becomes completely black, so all cells in the first column are reset to white.\nThe third operation is vertical. The operation rectangle starts at\n(1,1)\nand is a\n3×1\nrectangle. After the operation, cells\n(1,1)\n,\n(2,1)\n, and\n(3,1)\nbecome black.\nThe fourth operation is horizontal. The operation rectangle starts at\n(2,3)\nand is a\n1×3\nrectangle. After the operation, cells\n(2,3)\n,\n(2,4)\n, and\n(2,5)\nbecome black.\nThe fifth operation is horizontal. The operation rectangle starts at\n(3,3)\nand is a\n1×3\nrectangle. After the operation, cells\n(3,3)\n,\n(3,4)\n, and\n(3,5)\nbecome black.\nThe sixth operation is vertical. The operation rectangle starts at\n(2,2)\nand is a\n3×1\nrectangle. After the operation, cells\n(2,2)\n,\n(3,2)\n, and\n(4,2)\nbecome black. At this point, two rows and one column become completely black, so all cells in these rows and the column are reset to white.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*2700"
        ],
        "link": "https://codeforces.com/contest/1991/problem/G",
        "solution": "#include<stdio.h>\nchar s[1001];\nint main(){\n int T,N,M,K,Q;\n for(scanf(\"%d\",&T);T--;){\n  scanf(\"%d%d%d%d %s\",&N,&M,&K,&Q,s);\n  if(N==K&&M==K){\n   for(int i=0;i<Q;++i)puts(\"1 1\");\n  }else if(N==K){\n   for(int i=0,p=0;i<Q;++i)\n    if(s[i]=='H'){\n     printf(\"%d 1\\n\",++p);\n     if(p==N)p=0;\n    }else printf(\"1 %d\\n\",M);\n  }else if(M==K){\n   for(int i=0,p=0;i<Q;++i)\n    if(s[i]=='V'){\n     printf(\"1 %d\\n\",++p);\n     if(p==M)p=0;\n    }else printf(\"%d 1\\n\",N);\n  }else{\n   int x=N,y=M,p=K,q=K;\n   for(int i=0;i<Q;++i)\n    if(s[i]=='H'){\n     printf(\"%d 1\\n\",x--);\n     if(!x){\n      if(y<=K)q=y,y=M,x=K;\n      else x=N;\n     }else if(x==K)x=p,p=K;\n    }else{\n     printf(\"1 %d\\n\",y--);\n     if(!y){\n      if(x<=K)p=x,x=N,y=K;\n      else y=M;\n     }else if(y==K)y=q,q=K;\n    }\n  }\n }\n return 0;\n}"
    },
    {
        "title": "H. Prime Split Game",
        "description": "Alice and Bob are playing a game with\nn\npiles of stones, where the\ni\n-th pile has\nai\nstones. Players take turns making moves, with Alice going first.\nOn each move, the player does the following three-step process:\nChoose an integer\nk\n(\n1≤k≤\nn\n2\n). Note that the value of\nk\ncan be different for different moves.\nRemove\nk\npiles of stones.\nChoose another\nk\npiles of stones and split each pile into two piles. The number of stones in each new pile must be a prime number.\nThe player who is unable to make a move loses.\nDetermine who will win if both players play optimally.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅105\n) — the number of piles of stones.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤2⋅105\n) — the number of stones in the piles.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output \"Alice\" (without quotes) if Alice wins and \"Bob\" (without quotes) otherwise.\nYou can output each letter in any case (upper or lower). For example, the strings \"alIcE\", \"Alice\", and \"alice\" will all be considered identical.\nExample\ninput\nCopy\n4\n2\n2 1\n3\n3 5 7\n4\n4 6 8 10\n5\n8 8 8 8 8\noutput\nCopy\nBob\nAlice\nAlice\nBob\nNote\nIn the first test case, there are\n2\npiles of stones with\n2\nand\n1\nstones respectively. Since neither\n1\nnor\n2\ncan be split into two prime numbers, Alice cannot make a move, so Bob wins.\nIn the second test case, there are\n3\npiles of stones with\n3\n,\n5\n, and\n7\nstones respectively. Alice can choose\nk=1\n, remove the pile of\n7\nstones, and then split the pile of\n5\nstones into two piles of prime numbers of stones,\n2\nand\n3\n. Then, the piles consist of\n3\npiles of stones with\n3\n,\n2\n, and\n3\nstones respectively, leaving Bob with no valid moves, so Alice wins.\nIn the third test case, there are\n4\npiles of stones with\n4\n,\n6\n,\n8\n, and\n10\nstones respectively. Alice can choose\nk=2\n, removing two piles of\n8\nand\n10\nstones. She splits the pile of\n4\nstones into two piles of prime numbers of stones,\n2\nand\n2\n, and the pile of\n6\nstones into two piles of\n3\nand\n3\nstones. Then, Bob has no valid moves, so Alice wins.\nIn the fourth test case, there are\n5\npiles of stones, each containing\n8\nstones. It can be shown that if both players play optimally, Bob will win.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "fft",
            "games",
            "math",
            "number theory",
            "*3300"
        ],
        "link": "https://codeforces.com/contest/1991/problem/H",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;\n typedef long long ll;\nconst int N=2e5+3;\nbool vis[N];\nbitset<N>win,lose,good,nb;\nvoid Init()\n{\n vis[1]=1;win[4]=1;\n for(int i=2;i<N;i++)for(int j=i+i;j<N;j+=i)vis[j]=1;\n    for(int i=3;i<N;i+=2)\n    {\n        int x=0,j=i;\n        while(!vis[j-2])x++,j-=2;\n  win[i]=x%2;lose[i]=!vis[i]&&!win[i];\n }\n    for(int i=3;i<N;i+=2)if(lose[i])win|=lose<<i;\n    for(int i=1;i<N;i++)if(!vis[i])nb[i]=win[i];\n    for(int i=1;i<N;i+=2)if(nb[i])good|=nb<<i;\n}\nvoid Solve()\n{\n int n,sx=0,sy=0;cin>>n;\n for(int i=1,x;i<=n;i++)cin>>x,sx+=win[x],sy+=good[x];\n if(sx<=n-n%2)puts(sx?\"Alice\":\"Bob\");\n else puts(sy&&sy<n?\"Alice\":\"Bob\");\n}\nint main()\n{\n int T;cin>>T;Init();\n while(T--)Solve();\n return 0;\n}"
    },
    {
        "title": "I. Grid Game",
        "description": "This is an interactive problem.\nYou are given a grid with\nn\nrows and\nm\ncolumns. You need to fill each cell with a unique integer from\n1\nto\nn⋅m\n.\nAfter filling the grid, you will play a game on this grid against the interactor. Players take turns selecting one of the previously unselected cells from the grid, with the interactor going first.\nOn the first turn, the interactor can choose any cell from the grid. After that, any chosen cell must be orthogonally adjacent to at least one previously selected cell. Two cells are considered orthogonally adjacent if they share an edge. The game continues until all cells have been selected.\nYour goal is to let the sum of numbers in the cells selected by you be strictly less than the sum of numbers in the cells selected by the interactor.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of test cases follows.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n4≤n,m≤10\n) — the number of rows and columns in the grid.\nInteraction\nFirst, output\nn\nlines, each containing\nm\nintegers, representing the integers that you filled in the grid. Each integer from\n1\nto\nn⋅m\nshould appear exactly once.\nThen, the game begins. The interactor and you take turns outputting coordinates to select a cell for\nn×m\nturns, with the interactor starting first.\nOn each player's (either you or the interactor) turn, the player will output two integers\ni\nand\nj\n(\n1≤i≤n\n,\n1≤j≤m\n), denoting that the player has selected the cell on the\ni\n-th row and\nj\n-th column. This cell should not have been selected in a previous round. Additionally, if it is not the first turn, the cell must be orthogonally adjacent to at least one previously selected cell.\nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nAt the end of all\nn⋅m\nturns, if the sum of numbers in the cells selected by you is not strictly less than the sum of numbers in the cells selected by the interactor, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nIf your program has received a Wrong Answer verdict, it must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nAfter outputting, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nIn this problem, hacks are disabled.\nExample\ninput\nCopy\n1\n4 4\n\n\n\n\n3 4\n\n4 4\n\n4 2\n\n4 1\n\n1 4\n\n1 2\n\n2 2\n\n2 1\noutput\nCopy\n2 3 4 10\n12 6 11 15\n5 13 16 8\n9 7 1 14\n\n2 4\n\n4 3\n\n3 3\n\n3 1\n\n1 3\n\n1 1\n\n2 3\n\n3 2\nNote\nNote that this is an example game and does not necessarily represent the optimal strategy for both players.\nFirst, we fill a\n4×4\ngrid with unique integers from\n1\nto\n16\nin the following way:\n2\n3\n4\n10\n12\n6\n11\n15\n5\n13\n16\n8\n9\n7\n1\n14\nNext, the game begins.\nThe interactor first selects\n(3,4)\n, which is the number\n8\n. For this selection, the interactor could choose any number. From the next selection onwards, each chosen number has to be adjacent to any previously selected number.\nWe select\n(2,4)\n, which is the number\n15\n, adjacent to\n(3,4)\n.\nThe interactor selects\n(4,4)\n, which is the number\n14\n, adjacent to\n(3,4)\n.\nWe select\n(4,3)\n, which is the number\n1\n, adjacent to\n(4,4)\n.\n…\nThis is continued until all numbers are selected.\nIn the end, the numbers we selected were\n[15,1,16,5,4,2,11,13]\n, and the numbers selected by the interactor were\n[8,14,7,9,10,3,6,12]\n. The sum of the numbers we selected is\n67\n, which is less than the sum of the numbers selected by the interactor\n69\n. Therefore, we have won this game.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "graph matchings",
            "greedy",
            "interactive",
            "*3500"
        ],
        "link": "https://codeforces.com/contest/1991/problem/I",
        "solution": "#include <algorithm>\n#include <array>\n#include <iostream>\n#include <vector>\n using namespace std;\n constexpr int N = 10;\n int a[N][N], b[N][N];\n int main() {\n  for (int tc = (cin >> tc, tc); tc--; ) {\n    int n, m; cin >> n >> m;\n    fill(a[0], a[n], 0);\n    fill(b[0], b[n], 0);\n    int l = 0;\n    if (!(n & m & 1)) {\n      int t = ~n & ~m & 1, R = n * m - 12;\n      for (int x: {2, N, (n + t - 3) * N + m - 1, n * N + m - N - 2 - t}) {\n        int r = x / N, c = x % N;\n        a[r][c] = b[r][c] = ++l;\n        for (int dr: {-1, 0, 1})\n        for (int dc: {-1, 0, 1}) if (!dr != !dc && r >= dr && r - dr < n && c >= dc && c - dc < m) {\n          b[r - dr][c - dc] = l;\n          a[r - dr][c - dc] = ++R;\n        }\n      }\n    }\n    for (int i = 0; cout << '\\n', i < n; ++i)\n    for (int j = 0; j < m; ++j) cout << (a[i][j] = a[i][j] ?: ++l) << ' ';\n    cout << '\\n';\n    for (int i = 0; i < n * m; ++i) if (i % 2) {\n      int msk = 0;\n      for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j) if (a[i][j] == 1e9) {\n        msk |= 1 << b[i][j];\n      }\n      array<int, 3> ch{-1u / 2};\n      for (int i = 0; i < n; ++i)\n      for (int j = 0; j < m; ++j) if (bool f = (msk & 1 << b[i][j]) && a[i][j] != 1e9) {\n        for (int dr: {-1, 0, 1})\n        for (int dc: {-1, 0, 1}) f &= !(!dr != !dc && i >= dr && i - dr < n && j >= dc && j - dc < m && a[i - dr][j - dc] == 1e9);\n        if (!f) ch = min(ch, array{a[i][j], i, j});\n      }\n      auto [_, i, j] = ch;\n      cout << i + 1 << ' ' << j + 1 << '\\n';\n      a[i][j] = 1e9;\n    } else {\n      int i, j; cin >> i >> j;\n      a[i - 1][j - 1] = 1e9;\n    }\n  }\n}"
    },
    {
        "title": "A. Only Pluses",
        "description": "Kmes has written three integers $$$a$$$, $$$b$$$ and $$$c$$$ in order to remember that he has to give Noobish_Monk $$$a \\times b \\times c$$$ bananas.\nNoobish_Monk has found these integers and decided to do the following at most $$$5$$$ times:\npick one of these integers;\nincrease it by $$$1$$$.\nFor example, if $$$a = 2$$$, $$$b = 3$$$ and $$$c = 4$$$, then one can increase $$$a$$$ three times by one and increase $$$b$$$ two times. After that $$$a = 5$$$, $$$b = 5$$$, $$$c = 4$$$. Then the total number of bananas will be $$$5 \\times 5 \\times 4 = 100$$$.\nWhat is the maximum value of $$$a \\times b \\times c$$$ Noobish_Monk can achieve with these operations?\nInput\nEach test contains multiple test cases. The first line of input contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains three integers $$$a$$$, $$$b$$$ and $$$c$$$ ($$$1 \\le a, b, c \\le 10$$$) — Kmes's integers.\nOutput\nFor each test case, output a single integer — the maximum amount of bananas Noobish_Monk can get.\nExample\ninput\nCopy\n2\n2 3 4\n10 1 10\noutput\nCopy\n100\n600",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1992/problem/A",
        "solution": "exec'a=map(int,raw_input().split());exec\"a.sort();a[0]+=1;\"*5;a,b,c=a;print a*b*c;'*input()"
    },
    {
        "title": "B. Angry Monk",
        "description": "To celebrate his recovery, k1o0n has baked an enormous $$$n$$$ metres long potato casserole.\nTurns out, Noobish_Monk just can't stand potatoes, so he decided to ruin k1o0n's meal. He has cut it into $$$k$$$ pieces, of lengths $$$a_1, a_2, \\dots, a_k$$$ meters.\nk1o0n wasn't keen on that. Luckily, everything can be fixed. In order to do that, k1o0n can do one of the following operations:\nPick a piece with length $$$a_i \\ge 2$$$ and divide it into two pieces with lengths $$$1$$$ and $$$a_i - 1$$$. As a result, the number of pieces will increase by $$$1$$$;\nPick a slice $$$a_i$$$ and another slice with length $$$a_j=1$$$ ($$$i \\ne j$$$) and merge them into one piece with length $$$a_i+1$$$. As a result, the number of pieces will decrease by $$$1$$$.\nHelp k1o0n to find the minimum number of operations he needs to do in order to merge the casserole into one piece with length $$$n$$$.\nFor example, if $$$n=5$$$, $$$k=2$$$ and $$$a = [3, 2]$$$, it is optimal to do the following:\nDivide the piece with length $$$2$$$ into two pieces with lengths $$$2-1=1$$$ and $$$1$$$, as a result $$$a = [3, 1, 1]$$$.\nMerge the piece with length $$$3$$$ and the piece with length $$$1$$$, as a result $$$a = [4, 1]$$$.\nMerge the piece with length $$$4$$$ and the piece with length $$$1$$$, as a result $$$a = [5]$$$.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases $$$t$$$ ($$$1 \\le t \\le 10^4$$$).\nDescription of each test case consists of two lines. The first line contains two integers $$$n$$$ and $$$k$$$ ($$$2 \\le n \\le 10^9$$$, $$$2 \\le k \\le 10^5$$$) — length of casserole and the number of pieces.\nThe second line contains $$$k$$$ integers $$$a_1, a_2, \\ldots, a_k$$$ ($$$1 \\le a_i \\le n - 1$$$, $$$\\sum a_i = n$$$) — lengths of pieces of casserole, which Noobish_Monk has cut.\nIt is guaranteed that the sum of $$$k$$$ over all $$$t$$$ test cases doesn't exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output the minimum number of operations K1o0n needs to restore his pie after the terror of Noobish_Monk.\nExample\ninput\nCopy\n4\n5 3\n3 1 1\n5 2\n3 2\n11 4\n2 3 1 5\n16 6\n1 6 1 1 1 6\noutput\nCopy\n2\n3\n9\n15",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1992/problem/B",
        "solution": "for s in[*open(0)][2::2]:print(2*sum(a:=sorted(map(int,s.split()))[:-1])-len(a))"
    },
    {
        "title": "C. Gorilla and Permutation",
        "description": "Gorilla and Noobish_Monk found three numbers $$$n$$$, $$$m$$$, and $$$k$$$ ($$$m < k$$$). They decided to construct a permutation$$$^{\\dagger}$$$ of length $$$n$$$.\nFor the permutation, Noobish_Monk came up with the following function: $$$g(i)$$$ is the sum of all the numbers in the permutation on a prefix of length $$$i$$$ that are not greater than $$$m$$$. Similarly, Gorilla came up with the function $$$f$$$, where $$$f(i)$$$ is the sum of all the numbers in the permutation on a prefix of length $$$i$$$ that are not less than $$$k$$$. A prefix of length $$$i$$$ is a subarray consisting of the first $$$i$$$ elements of the original array.\nFor example, if $$$n = 5$$$, $$$m = 2$$$, $$$k = 5$$$, and the permutation is $$$[5, 3, 4, 1, 2]$$$, then:\n$$$f(1) = 5$$$, because $$$5 \\ge 5$$$; $$$g(1) = 0$$$, because $$$5 > 2$$$;\n$$$f(2) = 5$$$, because $$$3 < 5$$$; $$$g(2) = 0$$$, because $$$3 > 2$$$;\n$$$f(3) = 5$$$, because $$$4 < 5$$$; $$$g(3) = 0$$$, because $$$4 > 2$$$;\n$$$f(4) = 5$$$, because $$$1 < 5$$$; $$$g(4) = 1$$$, because $$$1 \\le 2$$$;\n$$$f(5) = 5$$$, because $$$2 < 5$$$; $$$g(5) = 1 + 2 = 3$$$, because $$$2 \\le 2$$$.\nHelp them find a permutation for which the value of $$$\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right)$$$ is maximized.\n$$$^{\\dagger}$$$A permutation of length $$$n$$$ is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in any order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation (as $$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation (as $$$n=3$$$, but $$$4$$$ appears in the array).\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$)  — the number of test cases.\nThe only line of each case contains three integers $$$n$$$, $$$m$$$, $$$k$$$ ($$$2\\le n \\le 10^5$$$; $$$1 \\le m < k \\le n$$$) — the size of the permutation to be constructed and two integers.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output the permutation  — a set of numbers that satisfies the conditions of the problem. If there are multiple solutions, output any of them.\nExample\ninput\nCopy\n3\n5 2 5\n3 1 3\n10 3 8\noutput\nCopy\n5 3 4 1 2\n3 2 1\n10 9 8 4 7 5 6 1 2 3\nNote\nIn the first example, $$$\\left(\\sum_{i=1}^n f(i) - \\sum_{i=1}^n g(i)\\right) = 5 \\cdot 5 - (0 \\cdot 3 + 1 + 3) = 25 - 4 = 21$$$",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*900"
        ],
        "link": "https://codeforces.com/contest/1992/problem/C",
        "solution": "for s in[*open(0)][1:]:n,m,k=map(int,s.split());print(*range(n,m,-1),*range(1,m+1))"
    },
    {
        "title": "D. Test of Love",
        "description": "ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of $$$1$$$ meter and a length of $$$n$$$ meters.\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from $$$0$$$ to $$$n+1$$$) ErnKor can swim in the water for no more than $$$k$$$ meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the $$$0$$$ and $$$n+1$$$ meters respectively. The river can be represented as $$$n$$$ segments, each with a length of $$$1$$$ meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows:\nIf he is on the surface (i.e., on the bank or on a log), he can jump forward for no more than $$$m$$$ ($$$1 \\le m \\le 10$$$) meters (he can jump on the bank, on a log, or in the water).\nIf he is in the water, he can only swim to the next river segment (or to the bank if he is at the $$$n$$$-th meter).\nErnKor cannot land in a segment with a crocodile in any way.\nDetermine if ErnKor can reach the right bank.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$)  — the number of test cases.\nThe first line of each test case contains three numbers $$$n, m, k$$$ ($$$0 \\le k \\le 2 \\cdot 10^5$$$, $$$1 \\le n \\le 2 \\cdot 10^5$$$, $$$1 \\le m \\le 10$$$) — the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\nThe second line of each test case contains a string $$$a$$$ of length $$$n$$$. $$$a_i$$$ denotes the object located at the $$$i$$$-th meter. ($$$a_i \\in \\{$$$'W','C','L'$$$\\}$$$)\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n6\n6 2 0\nLWLLLW\n6 1 1\nLWLLLL\n6 1 1\nLWLLWL\n6 2 15\nLWLLCC\n6 10 0\nCCCCCC\n6 6 1\nWCCCCW\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nYES\nNote\nLet's consider examples:\nFirst example: We jump from the shore to the first log ($$$0 \\rightarrow 1$$$), from the first log to the second ($$$1 \\rightarrow 3$$$), from the second to the fourth ($$$3 \\rightarrow 5$$$), and from the last log to the shore ($$$5 \\rightarrow 7$$$). So, we have $$$0 \\rightarrow 1 \\rightarrow 3 \\rightarrow 5 \\rightarrow 7$$$. Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».\nSecond example: $$$0 \\rightarrow 1$$$, we jump into the water from the first log ($$$1 \\rightarrow 2$$$), swim a cell to the log ($$$2 \\leadsto 3$$$), $$$3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 6 \\rightarrow 7$$$. Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».\nIn the third example, ErnKor needs to swim two cells 'W', but can only swim one. Therefore, the answer is «NO».\nSixth example: We jump from the shore into the water ($$$0 \\rightarrow 6$$$) and swim one cell in the water ($$$6 \\leadsto 7$$$). Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1200"
        ],
        "link": "https://codeforces.com/contest/1992/problem/D",
        "solution": "I=input\nfor _ in[0]*int(I()):n,m,k=map(int,I().split());print('YNEOS'[sum(len(t:=x[m-1:])+k*('C'in t)for\nx in I().split('L'))>k::2])"
    },
    {
        "title": "E. Novice's Mistake",
        "description": "One of the first programming problems by K1o0n looked like this: \"Noobish_Monk has\nn\n(1≤n≤100)\nfriends. Each of them gave him\na\n(1≤a≤10000)\napples for his birthday. Delighted with such a gift, Noobish_Monk returned\nb\n(1≤b≤min(10000,a⋅n))\napples to his friends. How many apples are left with Noobish_Monk?\"\nK1o0n wrote a solution, but accidentally considered the value of\nn\nas a string, so the value of\nn⋅a−b\nwas calculated differently. Specifically:\nwhen multiplying the string\nn\nby the integer\na\n, he will get the string\ns=\nn+n+⋯+n+n\n⏟\na times\nwhen subtracting the integer\nb\nfrom the string\ns\n, the last\nb\ncharacters will be removed from it. If\nb\nis greater than or equal to the length of the string\ns\n, it will become empty.\nLearning about this, ErnKor became interested in how many pairs\n(a,b)\nexist for a given\nn\n, satisfying the constraints of the problem, on which K1o0n's solution gives the correct answer.\n\"The solution gives the correct answer\" means that it outputs a non-empty string, and this string, when converted to an integer, equals the correct answer, i.e., the value of\nn⋅a−b\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n)  — the number of test cases.\nFor each test case, a single line of input contains an integer\nn\n(\n1≤n≤100\n).\nIt is guaranteed that in all test cases,\nn\nis distinct.\nOutput\nFor each test case, output the answer in the following format:\nIn the first line, output the integer\nx\n — the number of bad tests for the given\nn\n.\nIn the next\nx\nlines, output two integers\nai\nand\nbi\n — such integers that K1o0n's solution on the test \"\nn\nai\nbi\n\" gives the correct answer.\nExample\ninput\nCopy\n3\n2\n3\n10\noutput\nCopy\n3\n20 18 \n219 216 \n2218 2214 \n1\n165 162 \n1\n1262 2519 \nNote\nIn the first example,\na=20\n,\nb=18\nare suitable, as \"\n2\n\"\n⋅20−18=\n\"\n22222222222222222222\n\"\n−18=22=2⋅20−18",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "math",
            "strings",
            "*1700"
        ],
        "link": "https://codeforces.com/contest/1992/problem/E",
        "solution": "for t in range(int(input())):\n    n=int(input())\n    l=[]\n    for a in range(1,10001):\n        p=str(n)*a\n        for b in range(max(len(p)-7,1),min(len(p),10001)):\n            x=p[:-b]\n            if int(x)==n*a-b:\n                l.append([a,b])\n    print(len(l))\n    for i in l:\n        print(i[0],i[1])"
    },
    {
        "title": "F. Valuable Cards",
        "description": "In his favorite cafe Kmes once again wanted to try the herring under a fur coat. Previously, it would not have been difficult for him to do this, but the cafe recently introduced a new purchasing policy.\nNow, in order to make a purchase, Kmes needs to solve the following problem: $$$n$$$ cards with prices for different positions are laid out in front of him, on the $$$i$$$-th card there is an integer $$$a_i$$$, among these prices there is no whole positive integer $$$x$$$.\nKmes is asked to divide these cards into the minimum number of bad segments (so that each card belongs to exactly one segment). A segment is considered bad if it is impossible to select a subset of cards with a product equal to $$$x$$$. All segments, in which Kmes will divide the cards, must be bad.\nFormally, the segment $$$(l, r)$$$ is bad if there are no indices $$$i_1 < i_2 < \\ldots < i_k$$$ such that $$$l \\le i_1, i_k \\le r$$$, and $$$a_{i_1} \\cdot a_{i_2} \\ldots \\cdot a_{i_k} = x$$$.\nHelp Kmes determine the minimum number of bad segments in order to enjoy his favorite dish.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^3$$$) — the number of test cases.\nThe first line of each set of input data gives you $$$2$$$ integers $$$n$$$ and $$$x$$$ ($$$1 \\le n \\le 10^5, 2 \\le x \\le 10^5$$$) — the number of cards and the integer, respectively.\nThe second line of each set of input data contains $$$n$$$ integers $$$a_i$$$ ($$$1 \\le a_i \\le 2 \\cdot 10^5, a_i \\neq x$$$) — the prices on the cards.\nIt is guaranteed that the sum of $$$n$$$ over all sets of test data does not exceed $$$10^5$$$.\nOutput\nFor each set of input data, output the minimum number of bad segments.\nExample\ninput\nCopy\n8\n6 4\n2 3 6 2 1 2\n9 100000\n50000 25000 12500 6250 3125 2 4 8 16\n5 2\n1 1 1 1 1\n8 6\n4 3 4 3 4 3 4 3\n7 12\n6 11 1 3 11 10 2\n10 5\n2 4 4 2 4 4 4 3 1 1\n7 8\n4 6 5 1 2 4 1\n8 27\n3 9 17 26 2 20 9 3\noutput\nCopy\n3\n2\n1\n1\n2\n1\n3\n3",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "number theory",
            "two pointers",
            "*1900"
        ],
        "link": "https://codeforces.com/contest/1992/problem/F",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;main(){int t,n,x,o,c;cin>>t;while(t--){cin>>n>>x,o=1;set<int>s{1};for(int i=1;i<=n;i++){cin>>c;if(x%c==0)if(s.count(x/c))++o,s={1,c};else{auto d=s;for(auto e:d)if(x%(1ll*c*e)==0)s.insert(c*e);}}cout<<o<<'\\n';}}"
    },
    {
        "title": "G. Ultra-Meow",
        "description": "K1o0n gave you an array $$$a$$$ of length $$$n$$$, consisting of numbers $$$1, 2, \\ldots, n$$$. Accept it? Of course! But what to do with it? Of course, calculate $$$\\text{MEOW}(a)$$$.\nLet $$$\\text{MEX}(S, k)$$$ be the $$$k$$$-th positive (strictly greater than zero) integer in ascending order that is not present in the set $$$S$$$. Denote $$$\\text{MEOW}(a)$$$ as the sum of $$$\\text{MEX}(b, |b| + 1)$$$, over all distinct subsets $$$b$$$ of the array $$$a$$$.\nExamples of $$$\\text{MEX}(S, k)$$$ values for sets:\n$$$\\text{MEX}(\\{3,2\\}, 1) = 1$$$, because $$$1$$$ is the first positive integer not present in the set;\n$$$\\text{MEX}(\\{4,2,1\\}, 2) = 5$$$, because the first two positive integers not present in the set are $$$3$$$ and $$$5$$$;\n$$$\\text{MEX}(\\{\\}, 4) = 4$$$, because there are no numbers in the empty set, so the first $$$4$$$ positive integers not present in it are $$$1, 2, 3, 4$$$.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nIn a single line of each test case, an integer $$$n$$$ ($$$1 \\le n \\le 5000$$$) is entered, the size of the array of gifted numbers.\nIt is guaranteed that the sum of $$$n^2$$$ over all test cases does not exceed $$$25 \\cdot 10^6$$$.\nOutput\nFor each test case, output a single number — $$$\\text{MEOW}(a)$$$. Since it may be very large, output it modulo $$$10^9 + 7$$$.\nExample\ninput\nCopy\n5\n2\n3\n4999\n5\n1\noutput\nCopy\n12\n31\n354226409\n184\n4",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2000"
        ],
        "link": "https://codeforces.com/contest/1992/problem/G",
        "solution": "M, a, l, h, p = 1000000007, [1], 1, 0, [[0], [1], [1, 1]]\nfor i in range(3, 5002): p.append([1] + [(p[i-1][j-1] + p[i-1][j]) % M for j in range(1, i-1)] + [1])\nfor _ in range(int(input())):\n    n = int(input())\n    while l <= n: s = (a[l-1] + h + sum((2*i+3) * p[l][i] for i in range(l))) % M; h = h * 2 + (l // 2 * (pow(l//2 + 1, M-2, M) * p[l][l//2] % M) % M if l % 2 else 0); a.append((s - h) % M); l += 1\n    print(a[n])"
    },
    {
        "title": "A. Question Marks",
        "description": "Tim is doing a test consisting of $$$4n$$$ questions; each question has $$$4$$$ options: 'A', 'B', 'C', and 'D'. For each option, there are exactly $$$n$$$ correct answers corresponding to that option — meaning there are $$$n$$$ questions with the answer 'A', $$$n$$$ questions with the answer 'B', $$$n$$$ questions with the answer 'C', and $$$n$$$ questions with the answer 'D'.\nFor each question, Tim wrote his answer on the answer sheet. If he could not figure out the answer, he would leave a question mark '?' for that question.\nYou are given his answer sheet of $$$4n$$$ characters. What is the maximum number of correct answers Tim can get?\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 1000$$$) — the number of test cases.\nThe first line of each test case contains an integer $$$n$$$ ($$$1 \\le n \\le 100$$$).\nThe second line of each test case contains a string $$$s$$$ of $$$4n$$$ characters ($$$s_i \\in \\{\\texttt{A}, \\texttt{B}, \\texttt{C}, \\texttt{D}, \\texttt{?}\\}$$$) — Tim's answers for the questions.\nOutput\nFor each test case, print a single integer — the maximum score that Tim can achieve.\nExample\ninput\nCopy\n6\n1\nABCD\n2\nAAAAAAAA\n2\nAAAABBBB\n2\n????????\n3\nABCABCABCABC\n5\nACADC??ACAC?DCAABC?C\noutput\nCopy\n4\n2\n4\n0\n9\n13\nNote\nIn the first test case, there is exactly one question with each answer 'A', 'B', 'C', and 'D'; so it's possible that Tim gets all his answers correct.\nIn the second test case, there are only two correct answers 'A' which makes him get exactly $$$2$$$ points in any case.\nIn the third test case, Tim can get at most $$$2$$$ correct answers with option 'A' and $$$2$$$ correct answers with option 'B'. For example, he would get $$$4$$$ points if the answers were 'AACCBBDD'.\nIn the fourth test case, he refuses to answer any question at all, which makes him get $$$0$$$ points.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1993/problem/A",
        "solution": "for s in[*open(0)][2::2]:print(sum(min(s.count(x),len(s)//4)for x in'ABCD'))"
    },
    {
        "title": "B. Parity and Sum",
        "description": "Given an array\na\nof\nn\npositive integers.\nIn one operation, you can pick any pair of indexes\n(i,j)\nsuch that\nai\nand\naj\nhave distinct parity, then replace the smaller one with the sum of them. More formally:\nIf\nai<aj\n, replace\nai\nwith\nai+aj\n;\nOtherwise, replace\naj\nwith\nai+aj\n.\nFind the minimum number of operations needed to make all elements of the array have the same parity.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅105\n).\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤109\n) — the elements of array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required.\nExample\ninput\nCopy\n7\n5\n1 3 5 7 9\n4\n4 4 4 4\n3\n2 3 4\n4\n3 2 2 8\n6\n4 3 6 1 2 1\n6\n3 6 1 2 1 2\n5\n999999996 999999997 999999998 999999999 1000000000\noutput\nCopy\n0\n0\n2\n4\n3\n3\n3\nNote\nIn the first test case, all integers already have the same parity. Therefore, no operation is needed.\nIn the third test case, we can perform two operations\n(1,2)\nand\n(1,3)\n. The array\na\ntransforms as follows:\na=[2,3,4]⟶[5,3,4]⟶[5,3,9]\n.\nIn the fourth test case, an example of an optimal sequence of operations is\n(1,2)\n,\n(1,3)\n,\n(1,4)\n, and\n(1,4)\n. The array\na\ntransforms as follows:\na=[3,2,2,8]⟶[3,5,2,8]⟶[3,5,5,8]⟶[11,5,5,8]⟶[11,5,5,19]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "link": "https://codeforces.com/contest/1993/problem/B",
        "solution": "for s in[*open(0)][2::2]:\n a=b,c=[[],[]];r=0\n for x in sorted(map(int,s.split())):a[x%2]+=x,\n for x in c and b:f=x>c[-1];r+=1+f;c[-1]+=x+f*1e9\n print(r)"
    },
    {
        "title": "C. Light Switches",
        "description": "There is an apartment consisting of $$$n$$$ rooms, each with its light initially turned off.\nTo control the lights in these rooms, the owner of the apartment decided to install chips in the rooms so that each room has exactly one chip, and the chips are installed at different times. Specifically, these times are represented by the array $$$a_1, a_2, \\ldots, a_n$$$, where $$$a_i$$$ is the time (in minutes) at which a chip is installed in the $$$i$$$-th room.\nAs soon as a chip is installed, it changes the room's light status every $$$k$$$ minutes — it turns on the light for $$$k$$$ minutes, then turns it off for the next $$$k$$$ minutes, then turns it back on for the next $$$k$$$ minutes, and so on. In other words, the light status is changed by the chip at minute $$$a_i$$$, $$$a_i + k$$$, $$$a_i + 2k$$$, $$$a_i + 3k$$$, $$$\\ldots$$$ for the $$$i$$$-th room.\nWhat is the earliest moment when all rooms in the apartment have their lights turned on?\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nThe first line of each test case contains two integers $$$n$$$ and $$$k$$$ ($$$1 \\le k \\le n \\le 2 \\cdot 10^5$$$) — the number of rooms in the apartment and the period of the chips.\nThe second line contains $$$n$$$ distinct integers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) — the moments when the chips are installed.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, print a single integer — the answer to the question (in minutes). If there is no such moment that the lights are turned on in all the rooms, print $$$-1$$$ instead.\nExample\ninput\nCopy\n9\n4 4\n2 3 4 5\n4 3\n2 3 4 5\n4 3\n3 4 8 9\n3 3\n6 2 1\n1 1\n1\n7 5\n14 34 6 25 46 7 17\n6 5\n40 80 99 60 90 50\n6 5\n64 40 50 68 70 10\n2 1\n1 1000000000\noutput\nCopy\n5\n-1\n10\n8\n1\n47\n100\n-1\n-1\nNote\nIn the first test case, all lights will be on by the minute $$$5$$$ without any of them being turned off by the chips. The answer is $$$5$$$.\nIn the second test case, due to $$$k=3$$$, the $$$1$$$-st light will be on at minutes $$$2, 3, 4, 8, 9, 10, 14, \\ldots$$$; meanwhile, the $$$4$$$-th light will be on at minutes $$$5, 6, 7, 11, 12, 13, 17, \\ldots$$$. These two sequences don't have any number in common, so they will never be on at the same time.\nIn the third test case, it can be seen that the $$$1$$$-st and $$$2$$$-nd lights will be turned off at minutes $$$6$$$ and $$$7$$$, but the chips will turn them back on at minutes $$$9$$$ and $$$10$$$. The $$$3$$$-rd and $$$4$$$-th lights will also be on at minute $$$10$$$, so the answer is $$$10$$$.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1400"
        ],
        "link": "https://codeforces.com/contest/1993/problem/C",
        "solution": "for _ in range(int(input())):\n n, k = map(int, input().split())\n A = list(map(int, input().split()))\n A_max = max(A)\n mods = [(A_max - a + k) % (2*k) for a in A]\n if k - min(mods) < 2*k - max(mods):\n  print(A_max + k - min(mods))\n else:\n  print(-1)\n "
    },
    {
        "title": "D. Med-imize",
        "description": "Given two positive integers\nn\nand\nk\n, and another array\na\nof\nn\nintegers.\nIn one operation, you can select any subarray of size\nk\nof\na\n, then remove it from the array without changing the order of other elements. More formally, let\n(l,r)\nbe an operation on subarray\nal,al+1,…,ar\nsuch that\nr−l+1=k\n, then performing this operation means replacing\na\nwith\n[a1,…,al−1,ar+1,…,an]\n.\nFor example, if\na=[1,2,3,4,5]\nand we perform operation\n(3,5)\non this array, it will become\na=[1,2]\n. Moreover, operation\n(2,4)\nresults in\na=[1,5]\n, and operation\n(1,3)\nresults in\na=[4,5]\n.\nYou have to repeat the operation while the length of\na\nis greater than\nk\n(which means\n|a|>k\n). What is the largest possible median\n†\nof all remaining elements of the array\na\nafter the process?\n†\nThe median of an array of length\nn\nis the element whose index is\n⌊(n+1)/2⌋\nafter we sort the elements in non-decreasing order. For example:\nmedian([2,1,5,4,3])=3\n,\nmedian([5])=5\n, and\nmedian([6,8,2,4])=4\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤5⋅105\n).\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤109\n) — the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅105\n.\nOutput\nFor each test case, print a single integer — the largest median possible after performing the operations.\nExample\ninput\nCopy\n5\n4 3\n3 9 9 2\n5 3\n3 2 5 6 4\n7 1\n5 9 2 6 5 4 6\n8 2\n7 1 2 6 8 3 4 5\n4 5\n3 4 5 6\noutput\nCopy\n3\n4\n9\n6\n4\nNote\nIn the first test case, you can select a subarray\n(l,r)\nwhich can be either\n(1,3)\nor\n(2,4)\n. Thus, two obtainable final arrays are\n[3]\nand\n[2]\n. The former one has the larger median (\n3>2\n) so the answer is\n3\n.\nIn the second test case, three obtainable final arrays are\n[6,4]\n,\n[3,4]\n, and\n[3,2]\n. Their medians are\n4\n,\n3\n, and\n2\nrespectively. The answer is\n4\n.\nIn the third test case, only one element is left in the final array and it can be any element of the initial array. The largest one among them is\n9\n, so the answer is\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "*2200"
        ],
        "link": "https://codeforces.com/contest/1993/problem/D",
        "solution": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+2,V=1e9;\nint T,n,k,a[N],f[N];\nbool check(int x){\n memset(f+1,192,sizeof(int)*k);\n for(int i=0,j=0;i<n;++i,++j){\n  if(j==k) j=0;\n  f[j+1]=max(f[j+1],f[j]+(a[i]<x?-1:1));\n }\n return f[(n-1)%k+1]>0;\n}\nint main(){\n cin.tie(0)->sync_with_stdio(0);\n for(cin>>T;T--;){\n  cin>>n>>k;\n  for(int i=0;i<n;++i) cin>>a[i];\n  int l=1,r=V,mid;\n  while(l<r){\n   mid=(l+r+1)>>1;\n   check(mid)?l=mid:r=mid-1;\n  }\n  cout<<l<<'\\n';\n }\n return 0;\n}"
    },
    {
        "title": "E. Xor-Grid Problem",
        "description": "Given a matrix $$$a$$$ of size $$$n \\times m$$$, each cell of which contains a non-negative integer. The integer lying at the intersection of the $$$i$$$-th row and the $$$j$$$-th column of the matrix is called $$$a_{i,j}$$$.\nLet's define $$$f(i)$$$ and $$$g(j)$$$ as the XOR of all integers in the $$$i$$$-th row and the $$$j$$$-th column, respectively. In one operation, you can either:\nSelect any row $$$i$$$, then assign $$$a_{i,j} := g(j)$$$ for each $$$1 \\le j \\le m$$$; or\nSelect any column $$$j$$$, then assign $$$a_{i,j} := f(i)$$$ for each $$$1 \\le i \\le n$$$.\nAn example of applying an operation on column $$$2$$$ of the matrix.\nIn this example, as we apply an operation on column $$$2$$$, all elements in this column are changed:\n$$$a_{1,2} := f(1) = a_{1,1} \\oplus a_{1,2} \\oplus a_{1,3} \\oplus a_{1,4} = 1 \\oplus 1 \\oplus 1 \\oplus 1 = 0$$$\n$$$a_{2,2} := f(2) = a_{2,1} \\oplus a_{2,2} \\oplus a_{2,3} \\oplus a_{2,4} = 2 \\oplus 3 \\oplus 5 \\oplus 7 = 3$$$\n$$$a_{3,2} := f(3) = a_{3,1} \\oplus a_{3,2} \\oplus a_{3,3} \\oplus a_{3,4} = 2 \\oplus 0 \\oplus 3 \\oplus 0 = 1$$$\n$$$a_{4,2} := f(4) = a_{4,1} \\oplus a_{4,2} \\oplus a_{4,3} \\oplus a_{4,4} = 10 \\oplus 11 \\oplus 12 \\oplus 16 = 29$$$\nYou can apply the operations any number of times. Then, we calculate the $$$\\textit{beauty}$$$ of the final matrix by summing the absolute differences between all pairs of its adjacent cells.\nMore formally, $$$\\textit{beauty}(a) = \\sum|a_{x,y} - a_{r,c}|$$$ for all cells $$$(x, y)$$$ and $$$(r, c)$$$ if they are adjacent. Two cells are considered adjacent if they share a side.\nFind the minimum $$$\\textit{beauty}$$$ among all obtainable matrices.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 250$$$) — the number of test cases.\nThe first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\le n, m \\le 15$$$) — the number of rows and columns of $$$a$$$, respectively.\nThe next $$$n$$$ lines, each containing $$$m$$$ integers $$$a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$$$ ($$$0 \\le a_{i,j} < 2^{20}$$$) — description of the matrix $$$a$$$.\nIt is guaranteed that the sum of $$$(n^2 + m^2)$$$ over all test cases does not exceed $$$500$$$.\nOutput\nFor each test case, print a single integer $$$b$$$ — the smallest possible $$$\\textit{beauty}$$$ of the matrix.\nExample\ninput\nCopy\n4\n1 2\n1 3\n2 3\n0 1 0\n5 4 4\n2 3\n0 2 4\n4 5 1\n3 3\n1 2 3\n4 5 6\n7 8 9\noutput\nCopy\n1\n3\n13\n24\nNote\nLet's denote $$$r(i)$$$ as the first type operation applied on the $$$i$$$-th row, and $$$c(j)$$$ as the second type operation applied on the $$$j$$$-th column.\nIn the first test case, you can apply an operation $$$c(1)$$$, which assigns $$$a_{1,1} := 1 \\oplus 3 = 2$$$. Then, we'll receive this matrix:\n2 3\nIn the second test case, you can apply an operation $$$r(1)$$$, which assigns:\n$$$a_{1,1} := g(1) = 0 \\oplus 5 = 5$$$\n$$$a_{1,2} := g(2) = 1 \\oplus 4 = 5$$$\n$$$a_{1,3} := g(3) = 0 \\oplus 4 = 4$$$\nThe resulting matrix after performing the operation is:\n5 5 4\n5 4 4\nIn the third test case, the best way to achieve minimum $$$\\textit{beauty}$$$ is applying three operations: $$$c(3)$$$, $$$r(2)$$$, and $$$c(2)$$$. The resulting matrix is:\n0 4 6\n4 5 6",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "implementation",
            "*2700"
        ],
        "link": "https://codeforces.com/contest/1993/problem/E",
        "solution": "T=int(input())\nfor t in range(T):\n    N,M=map(int,input().split())\n    A=[list(map(int,input().split())) for n in range(N)]\n    for n in range(N):\n        A[n].append(0)\n        for m in range(M):\n            A[n][-1]^=A[n][m]\n    A.append([0]*(M+1))\n    for n in range(N):\n        for m in range(M+1):\n            A[N][m]^=A[n][m]\n    def solve(A):\n        retu=[]\n        N=len(A)\n        M=len(A[0])\n        for x in range(N):\n            C=[[sum(abs(A[n][m0]-A[n][m1]) for n in range(N) if n!=x) for m1 in range(M)] for m0 in range(M)]\n            inf=1<<60\n            dp=[inf]*(M<<M)\n            for bit in range(1,1<<M):\n                idx=[m for m in range(M) if bit&1<<m]\n                if len(idx)==1:\n                    m=idx[0]\n                    dp[m<<M|bit]=0\n                else:\n                    for m1 in idx:\n                        for m0 in idx:\n                            if m0==m1:\n                                continue\n                            dp[m1<<M|bit]=min(dp[m1<<M|bit],dp[m0<<M|bit^1<<m1]+C[m0][m1])\n            retu.append([min(dp[mm<<M|(1<<M)-1-(1<<m)] for mm in range(M)) for m in range(M)])\n        return retu\n    C0=solve(A)\n    C1=solve([[A[n][m] for n in range(N+1)] for m in range(M+1)])\n    ans=min(C0[n][m]+C1[m][n] for n in range(N+1) for m in range(M+1))\n    print(ans)"
    },
    {
        "title": "F1. Dyn-scripted Robot (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is that in this version\nk≤n\n. You can make hacks only if both versions of the problem are solved.\nGiven a\nw×h\nrectangle on the\nOxy\nplane, with points\n(0,0)\nat the bottom-left and\n(w,h)\nat the top-right of the rectangle.\nYou also have a robot initially at point\n(0,0)\nand a script\ns\nof\nn\ncharacters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\nThe robot can only move inside the rectangle; otherwise, it will change the script\ns\nas follows:\nIf it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\nIf it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\nThen, it will execute the changed script starting from the character which it couldn't execute.\nAn example of the robot's movement process,\ns=\"ULULURD\"\nThe script\ns\nwill be executed for\nk\ntimes continuously. All changes to the string\ns\nwill be retained even when it is repeated. During this process, how many times will the robot move to the point\n(0,0)\nin total? Note that the initial position does NOT count.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains four integers\nn\n,\nk\n,\nw\n, and\nh\n(\n1≤n,w,h≤106\n;\n1≤k≤n\n).\nThe second line contains a single string\ns\nof size\nn\n(\nsi∈{L,R,U,D}\n) — the script to be executed.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n106\n.\nOutput\nFor each test case, print a single integer — the number of times the robot reaches\n(0,0)\nwhen executing script\ns\nfor\nk\ntimes continuously.\nExample\ninput\nCopy\n5\n2 2 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 5 3 3\nRUURD\n7 5 3 4\nRRDLUUU\noutput\nCopy\n0\n4\n3\n0\n1\nNote\nIn the first test case, the robot only moves up and right. In the end, it occupies the position\n(2,2)\nbut never visits\n(0,0)\n. So the answer is\n0\n.\nIn the second test case, each time executing the script the robot visits the origin twice. And since\nk=2\n, it visits the origin\n2⋅2=4\ntimes overall.\nIn the third test case, the visualization is shown as below:",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "chinese remainder theorem",
            "constructive algorithms",
            "math",
            "number theory",
            "*2400"
        ],
        "link": "https://codeforces.com/contest/1993/problem/F1",
        "solution": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint t,n,k,w,h;\nstring a;\nsigned main(){\n cin>>t;\n while(t--){\n  cin>>n>>k>>w>>h;\n  cin>>a;\n  int x=0,y=0;\n  map<pair<int,int>,int>ma;\n  for(int i=0;i<n;i++){\n   if(a[i]=='U') y++;\n   if(a[i]=='D') y--;\n   if(a[i]=='L') x--;\n   if(a[i]=='R') x++;\n   x=(x+2*w)%(2*w);\n   y=(y+2*h)%(2*h);\n   ma[{x,y}]++;\n  }\n  int s=0;\n  for(int i=0;i<k;i++){\n   int xx=(2*w-x)*i%(2*w);\n   int yy=(2*h-y)*i%(2*h);\n   s+=ma[{xx,yy}];\n  }\n  cout<<s<<'\\n';\n }\n}"
    },
    {
        "title": "F2. Dyn-scripted Robot (Hard Version)",
        "description": "This is the hard version of the problem. The only difference is that in this version $$$k \\le 10^{12}$$$. You can make hacks only if both versions of the problem are solved.\nGiven a $$$w \\times h$$$ rectangle on the $$$Oxy$$$ plane, with points $$$(0, 0)$$$ at the bottom-left and $$$(w, h)$$$ at the top-right of the rectangle.\nYou also have a robot initially at point $$$(0, 0)$$$ and a script $$$s$$$ of $$$n$$$ characters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\nThe robot can only move inside the rectangle; otherwise, it will change the script $$$s$$$ as follows:\nIf it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\nIf it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\nThen, it will execute the changed script starting from the character which it couldn't execute.\nAn example of the robot's movement process, $$$s = \\texttt{\"ULULURD\"}$$$\nThe script $$$s$$$ will be executed for $$$k$$$ times continuously. All changes to the string $$$s$$$ will be retained even when it is repeated. During this process, how many times will the robot move to the point $$$(0, 0)$$$ in total? Note that the initial position does NOT count.\nInput\nThe first line contains a single integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases.\nThe first line of each test case contains four integers $$$n$$$, $$$k$$$, $$$w$$$, and $$$h$$$ ($$$1 \\le n, w, h \\le 10^6$$$; $$$1 \\le k \\le 10^{12}$$$).\nThe second line contains a single string $$$s$$$ of size $$$n$$$ ($$$s_i \\in \\{\\texttt{L}, \\texttt{R}, \\texttt{U}, \\texttt{D}\\}$$$) — the script to be executed.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^6$$$.\nOutput\nFor each test case, print a single integer — the number of times the robot reaches $$$(0, 0)$$$ when executing script $$$s$$$ for $$$k$$$ times continuously.\nExample\ninput\nCopy\n6\n2 4 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 6 3 3\nRUURD\n7 5 3 4\nRRDLUUU\n7 123456789999 3 2\nULULURD\noutput\nCopy\n1\n4\n3\n1\n1\n41152263332\nNote\nIn the first test case, the robot only moves up and right for the first two executions. After that, it occupies the position $$$(2, 2)$$$. For the next two executions, it moves down and left and finishes at $$$(0, 0)$$$. So the answer is $$$1$$$.\nIn the second test case, each time executing the script the robot visits the origin twice. And since $$$k=2$$$, it visits the origin $$$2 \\cdot 2 = 4$$$ times overall.\nIn the third test case, the visualization is shown as below:",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "chinese remainder theorem",
            "math",
            "number theory",
            "*2800"
        ],
        "link": "https://codeforces.com/contest/1993/problem/F2",
        "solution": "from math import gcd\n ans = []\nfor _ in range(int(input())):\n n,k,w,h = [int(t) for t in input().split()]\n w *= 2; h *= 2\n  px,py = 0,0\n m = {}\n for inst in input():\n  if inst == \"U\": py = (py+1)%h\n  if inst == \"D\": py = (py+h-1)%h\n  if inst == \"L\": px = (px+w-1)%w\n  if inst == \"R\": px = (px+1)%w\n   m[(px,py)] = m[(px,py)]+1 if (px,py) in m else 1\n  gx = gcd(px,w); gy = gcd(py,h)\n mx = w//gx; my = h//gy\n G = gcd(mx,my)\n dx = mx//G; dy = my//G\n L = mx*my//G\n  res = 0\n for (a,b) in m:\n  if a%gx or b%gy: continue\n   #a + t*px = 0 (mod w)\n  r1 = -(a//gx) * pow(px//gx, -1, mx)\n  r2 = -(b//gy) * pow(py//gy, -1, my)\n   if (r1-r2)%G: continue\n   s = r1%G\n  r1 = (r1-s)//G; r2 = (r2-s)//G\n   #(r1%dx) + dx*t = r2 (mod dy)\n  t = (r1%dx) + dx * ((r2 - (r1%dx)) * pow(dx,-1,dy))\n  t = t*G + s\n  t = ((t%L)+L)%L\n    res += m[(a,b)]*((k-1-t)//L + 1)\n ans.append(res)\n for w in ans:\n print(w)"
    },
    {
        "title": "A. Diverse Game",
        "description": "Petr, watching Sergey's stream, came up with a matrix\na\n, consisting of\nn\nrows and\nm\ncolumns (the number in the\ni\n-th row and\nj\n-th column is denoted as\nai,j\n), which contains all integers from\n1\nto\nn⋅m\n. But he didn't like the arrangement of the numbers, and now he wants to come up with a new matrix\nb\n, consisting of\nn\nrows and\nm\ncolumns, which will also contain all integers from\n1\nto\nn⋅m\n, such that for any\n1≤i≤n,1≤j≤m\nit holds that\nai,j≠bi,j\n.\nYou are given the matrix\na\n, construct any matrix\nb\nthat meets Petr's requirements, or determine that it is impossible.\nHurry up! Otherwise, he will donate all his money to the stream in search of an answer to his question.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤103\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤10\n) — the number of rows and columns of matrix\na\n.\nThe next\nn\nlines contain\nm\nintegers each, describing matrix\na\n. The\ni\n-th of these lines contains the elements of matrix\nai,1,ai,2,…,ai,m\n.\nIt is guaranteed that all numbers in matrix\na\nare distinct and\n1≤ai,j≤n⋅m\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n5⋅104\n.\nOutput\nFor each test case, output\nn⋅m\nintegers — any suitable matrix\nb\n, or\n−1\nif such a matrix does not exist.\nExample\ninput\nCopy\n5\n1 1\n1\n2 1\n2\n1\n1 5\n2 4 5 3 1\n2 4\n1 2 3 4\n5 6 7 8\n3 3\n4 2 1\n9 8 3\n6 7 5\noutput\nCopy\n-1\n1 \n2 \n4 5 3 1 2 \n6 7 8 5 \n2 3 4 1 \n8 3 9 \n7 5 6 \n2 1 4 \nNote\nIn the first test case, there is only one element in the matrix, so matrix\nb\nis the only matrix and it does not fit.\nIn the second test case\na1,1=2≠1=b1,1\n,\na2,1=1≠2=b2,1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*800"
        ],
        "link": "https://codeforces.com/contest/1994/problem/A",
        "solution": "g=\"q(''+input().split()[0])\"\nq=eval\nexec(q(g)*f\"f,*a=q('[]'+{g}*g[4:20]);print(*a,a and f or-1);\")"
    },
    {
        "title": "B. Fun Game",
        "description": "Vova really loves the XOR operation (denoted as $$$\\oplus$$$). Recently, when he was going to sleep, he came up with a fun game.\nAt the beginning of the game, Vova chooses two binary sequences $$$s$$$ and $$$t$$$ of length $$$n$$$ and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers $$$0$$$ and $$$1$$$. Vanya can choose integers $$$l, r$$$ such that $$$1 \\leq l \\leq r \\leq n$$$, and for all $$$l \\leq i \\leq r$$$ simultaneously replace $$$s_i$$$ with $$$s_i \\oplus s_{i - l + 1}$$$, where $$$s_i$$$ is the $$$i$$$-th element of the sequence $$$s$$$.\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence $$$t$$$ from the sequence $$$s$$$. Determine if the game will be interesting for the sequences $$$s$$$ and $$$t$$$.\nInput\nEach test consists of multiple test cases. The first line contains an integer $$$q$$$ ($$$1 \\le q \\le 10^{4}$$$) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5$$$) — the length of the sequences $$$s$$$ and $$$t$$$.\nThe second line of each test case contains a binary sequence $$$s$$$ of length $$$n$$$.\nThe third line of each test case contains a binary sequence $$$t$$$ of length $$$n$$$.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n6\n1\n0\n1\n7\n0110100\n0110100\n9\n100101010\n101111110\n4\n0011\n1011\n4\n0100\n0001\n8\n10110111\n01100000\noutput\nCopy\nNO\nYES\nYES\nNO\nYES\nYES\nNote\nIn the first test case, Vanya will not be able to change the sequence $$$s$$$ with the only possible action of choosing $$$l = r = 1$$$.\nIn the second test case, the sequences $$$s$$$ and $$$t$$$ are already equal.\nIn the third test case, Vanya can act as follows:\nChoose $$$l = 3$$$ and $$$r = 5$$$, then $$$s$$$ will become $$$\\mathtt{101101010}$$$.\nChoose $$$l = 5$$$ and $$$r = 6$$$, then $$$s$$$ will become $$$\\mathtt{101111010}$$$.\nChoose $$$l = 7$$$ and $$$r = 7$$$, then $$$s$$$ will become $$$\\mathtt{101111110}$$$.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "link": "https://codeforces.com/contest/1994/problem/B",
        "solution": "f=\"input().find('1')%1e6\"\nexec(int(input())*f\"{f};print('YNEOS'[{f}>{f}::2]);\")"
    },
    {
        "title": "C. Hungry Games",
        "description": "Yaroslav is playing a computer game, and at one of the levels, he encountered $$$n$$$ mushrooms arranged in a row. Each mushroom has its own level of toxicity; the $$$i$$$-th mushroom from the beginning has a toxicity level of $$$a_i$$$. Yaroslav can choose two integers $$$1 \\le l \\le r \\le n$$$, and then his character will take turns from left to right to eat mushrooms from this subsegment one by one, i.e., the mushrooms with numbers $$$l, l+1, l+2, \\ldots, r$$$.\nThe character has a toxicity level $$$g$$$, initially equal to $$$0$$$. The computer game is defined by the number $$$x$$$ — the maximum toxicity level at any given time. When eating a mushroom with toxicity level $$$k$$$, the following happens:\nThe toxicity level of the character is increased by $$$k$$$.\nIf $$$g \\leq x$$$, the process continues; otherwise, $$$g$$$ becomes zero and the process continues.\nYaroslav became interested in how many ways there are to choose the values of $$$l$$$ and $$$r$$$ such that the final value of $$$g$$$ is not zero. Help Yaroslav find this number!\nInput\nEach test consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^{4}$$$) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers $$$n$$$, $$$x$$$ ($$$1 \\leq n \\leq 2 \\cdot 10^5, 1 \\le x \\le 10^9$$$) — the number of mushrooms and the maximum toxicity level.\nThe second line of each test case contains $$$n$$$ numbers $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$).\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2 \\cdot 10^5$$$.\nOutput\nFor each test case, output a single number — the number of subsegments such that the final value of $$$g$$$ will not be zero.\nExample\ninput\nCopy\n5\n4 2\n1 1 1 1\n3 2\n1 2 3\n1 6\n10\n6 3\n1 2 1 4 3 8\n5 999999999\n999999999 999999998 1000000000 1000000000 500000000\noutput\nCopy\n8\n2\n0\n10\n7\nNote\nIn the first test case, the subsegments $$$(1, 1)$$$, $$$(1, 2)$$$, $$$(1, 4)$$$, $$$(2, 2)$$$, $$$(2, 3)$$$, $$$(3, 3)$$$, $$$(3, 4)$$$ and $$$(4, 4)$$$ are suitable.\nIn the second test case, non-zero $$$g$$$ will remain only on the subsegments $$$(1, 1)$$$ and $$$(2, 2)$$$.\nIn the third test case, on the only possible subsegment, $$$g$$$ will be zero.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "two pointers",
            "*1600"
        ],
        "link": "https://codeforces.com/contest/1994/problem/C",
        "solution": "I=lambda:map(int,input().split())\nt,=I()\nwhile t:\n t-=1\n n,x=I();*l,=I();k=s=0;g=n*(n+1)//2\n while n:\n  n-=1\n  k+=l[n]\n  if k>x:k=0;s+=n+1\n print(g-s)"
    },
    {
        "title": "D. Funny Game",
        "description": "Vanya has a graph with $$$n$$$ vertices (numbered from $$$1$$$ to $$$n$$$) and an array $$$a$$$ of $$$n$$$ integers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform $$$n - 1$$$ operations.\nOperation number $$$x$$$ (operations are numbered in order starting from $$$1$$$) is as follows:\nChoose $$$2$$$ different numbers $$$1 \\leq u,v \\leq n$$$, such that $$$|a_u - a_v|$$$ is divisible by $$$x$$$.\nAdd an undirected edge between vertices $$$u$$$ and $$$v$$$ to the graph.\nHelp Vanya get a connected$$$^{\\text{∗}}$$$ graph using the $$$n - 1$$$ operations, or determine that it is impossible.\n$$$^{\\text{∗}}$$$A graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\nInput\nEach test consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^{3}$$$) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains the number $$$n$$$ ($$$1 \\leq n \\leq 2000$$$) — the number of vertices in the graph.\nThe second line of each test case contains $$$n$$$ numbers $$$a_1, a_2, \\cdots a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$).\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$2000$$$.\nOutput\nFor each test case, if there is no solution, then output \"No\" (without quotes).\nOtherwise, output \"Yes\" (without quotes), and then output $$$n - 1$$$ lines, where in the $$$i$$$-th line, output the numbers $$$u$$$ and $$$v$$$ that need to be chosen for operation $$$i$$$.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n8\n2\n1 4\n4\n99 7 1 13\n5\n10 2 31 44 73\n5\n87 6 81 44 32\n5\n62 35 33 79 16\n5\n6 51 31 69 42\n5\n52 63 25 21 5\n12\n33 40 3 11 31 43 37 8 50 5 12 22\noutput\nCopy\nYES\n2 1\nYES\n4 1\n2 1\n3 2\nYES\n5 1\n4 1\n3 1\n2 1\nYES\n4 1\n3 1\n2 1\n5 4\nYES\n3 1\n5 1\n2 1\n4 2\nYES\n4 1\n5 1\n2 1\n3 2\nYES\n2 1\n5 2\n3 1\n4 3\nYES\n9 1\n12 9\n11 1\n10 1\n6 1\n7 6\n2 1\n8 2\n5 2\n3 1\n4 1\nNote\nLet's consider the second test case.\nFirst operation $$$(x = 1)$$$: we can connect vertices $$$4$$$ and $$$1$$$, since $$$|a_4 - a_1| = |13 - 99| = |-86| = 86$$$, and $$$86$$$ is divisible by $$$1$$$.\nSecond operation $$$(x = 2)$$$: we can connect vertices $$$2$$$ and $$$1$$$, since $$$|a_2 - a_1| = |7 - 99| = |-92| = 92$$$, and $$$92$$$ is divisible by $$$2$$$.\nThird operation $$$(x = 3)$$$: we can connect vertices $$$3$$$ and $$$2$$$, since $$$|a_3 - a_2| = |1 - 7| = |-6| = 6$$$, and $$$6$$$ is divisible by $$$3$$$.\nFrom the picture, it can be seen that a connected graph is obtained.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dsu",
            "graphs",
            "greedy",
            "math",
            "number theory",
            "trees",
            "*1900"
        ],
        "link": "https://codeforces.com/contest/1994/problem/D",
        "solution": "for _ in range(int(input())):\n n = int(input())\n a = [None] + list(map(int, input().split()))\n f = [True] * (n + 1)\n  print(\"YES\")\n ans = []\n for m in range(n - 1, 0, -1):\n  d = [None] * m\n   for i in range(1, n + 1):\n   if f[i]:\n    j = a[i] % m\n    if d[j]:\n     f[i] = False\n     ans.append((i, d[j]))\n     break\n    else:\n     d[j] = i\n  for i in ans[::-1]:\n  print(*i)"
    },
    {
        "title": "E. Wooden Game",
        "description": "You are given a forest of\nk\nrooted trees\n∗\n. Lumberjack Timofey wants to cut down the entire forest by applying the following operation:\nSelect a subtree\n†\nof any vertex of one of the trees and remove it from the tree.\nTimofey loves bitwise operations, so he wants the bitwise OR of the sizes of the subtrees he removed to be maximum. Help him and find the maximum result he can obtain.\n∗\nA tree is a connected graph without cycles, loops, or multiple edges. In a rooted tree, a selected vertex is called a root. A forest is a collection of one or more trees.\n†\nThe subtree of a vertex\nv\nis the set of vertices for which\nv\nlies on the shortest path from this vertex to the root, including\nv\nitself.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤104\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nk\n(\n1≤k≤106\n) — the number of trees in the forest.\nThis is followed by a description of each of the\nk\ntrees:\nThe first line contains a single integer\nn\n(\n1≤n≤106\n) — the size of the tree. The vertices of the tree are numbered with integers from\n1\nto\nn\n. The root of the tree is vertex number\n1\n.\nThe second line contains\nn−1\nintegers\np2,p3,…pn\n(\n1≤pi<i\n), where\npi\n — the parent of vertex\ni\n.\nIt is guaranteed that the sum of\nk\nand\nn\nfor all sets of input data does not exceed\n106\n.\nOutput\nFor each test case, output a single integer — the maximum result that can be obtained.\nExample\ninput\nCopy\n3\n1\n1\n\n2\n4\n1 2 2\n6\n1 1 3 1 3\n1\n10\n1 2 2 1 1 5 7 6 4\noutput\nCopy\n1\n7\n10\nNote\nIn the second test case, the trees look like this:\nThe first operation removes the entire second tree.\nThe second operation removes vertex\n4\nfrom the first tree.\nThe third operation removes the first tree. The result is\n6|1|3=7\n(\n|\ndenotes bitwise OR).\nIn the third test case, the entire tree needs to be removed.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "trees",
            "*2000"
        ],
        "link": "https://codeforces.com/contest/1994/problem/E",
        "solution": "main(k,n,i,s){for(scanf(\"%*d\");~scanf(\"%d\",&k);printf(\"%d\\n\",s))for(s=0;k--;s|=n)for(scanf(\"%d\",&n),i=n;--i;s&n?n=i:0)scanf(\"%*d\");}"
    },
    {
        "title": "F. Stardew Valley",
        "description": "Pelican Town represents $$$n$$$ houses connected by $$$m$$$ bidirectional roads. Some roads have NPCs standing on them. Farmer Buba needs to walk on each road with an NPC and talk to them.\nHelp the farmer find a route satisfying the following properties:\nThe route starts at some house, follows the roads, and ends at the same house.\nThe route does not follow any road more than once (in both directions together).\nThe route follows each road with an NPC exactly once.\nNote that the route can follow roads without NPCs, and you do not need to minimize the length of the route.\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\nInput\nEach test consists of multiple test cases. The first line contains an integer $$$t$$$ ($$$1 \\le t \\le 10^{4}$$$) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers $$$n$$$ and $$$m$$$ ($$$2 \\leq n \\leq 5 \\cdot 10^5, 1 \\leq m \\leq 5 \\cdot 10^5$$$) — the number of houses and roads in Pelican Town respectively.\nIn each of the next $$$m$$$ lines, three integers $$$u$$$, $$$v$$$, and $$$c$$$ ($$$1 \\leq u, v \\leq n, c = 0/1$$$) are given — the ends of the road and whether an NPC is on this road. If $$$c = 1$$$, then the road has an NPC. If $$$c = 0$$$, then the road has no NPC.\nThe graph may contain multiple edges and loops, and if there are multiple edges with NPCs standing on them, the route must follow each of these roads.\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\nIt is guaranteed that the sum of $$$n$$$ and $$$m$$$ for all test cases does not exceed $$$5 \\cdot 10^5$$$.\nOutput\nFor each test case, if there is no solution, then output \"No\" (without quotes).\nOtherwise, output \"Yes\" (without quotes), and then output $$$k$$$ — the number of roads in the route. In the next line, output $$$k + 1$$$ numbers — the houses of the route in the order of traversal. Note that the first house should match the last one, as the route is cyclic.\nIf there are multiple answers, you can print any of them.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n3\n3 2\n1 2 1\n2 3 1\n3 3\n1 2 1\n1 3 1\n2 3 0\n5 9\n1 2 0\n5 2 1\n5 4 1\n5 1 1\n2 3 1\n5 2 1\n4 1 0\n4 3 0\n5 2 0\noutput\nCopy\nNO\nYES\n3\n1 2 3 1 \nYES\n7\n1 2 5 4 3 2 5 1 \nNote\nNote that in the third test case, there are multiple edges $$$(5, 2)$$$. You must walk on two of them.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "trees",
            "*2500"
        ],
        "link": "https://codeforces.com/contest/1994/problem/F",
        "solution": "#include<bits/stdc++.h> \nusing namespace std;\n#define N 500005\nint t,n,m,a[N],c,deg[N],vis[N];\nvector<int> T[N];\nmultiset<int> G[N];\nvoid dfs(int u,int fa){\n vis[u]=1;\n for(int v:T[u])if(!vis[v])dfs(v,u);\n if(fa&&(deg[u]&1))G[u].insert(fa),G[fa].insert(u),++deg[u],++deg[fa];\n}\nvoid dfs(int u){\n while(G[u].size()){\n  int v=*G[u].begin();G[u].erase(G[u].begin());G[v].erase(G[v].lower_bound(u));\n  dfs(v);\n }\n a[++c]=u;\n}\nvoid work(){\n scanf(\"%d%d\",&n,&m);\n for(int i=1;i<=n;i++)deg[i]=vis[i]=0,T[i].clear(),G[i].clear();c=0;\n for(int i=1,u,v,c;i<=m;i++){\n  scanf(\"%d%d%d\",&u,&v,&c);\n  if(c)++deg[u],++deg[v],G[u].insert(v),G[v].insert(u);\n  else T[u].push_back(v),T[v].push_back(u);\n }\n for(int i=1;i<=n;i++)if(!vis[i]){\n  dfs(i,0);\n  if(deg[i]&1)return puts(\"NO\"),void();\n }\n puts(\"YES\");\n dfs(1);\n printf(\"%d\\n\",c-1);\n for(int i=1;i<=c;i++)printf(\"%d \",a[i]);\n puts(\"\");\n}\nint main(){\n scanf(\"%d\",&t);\n while(t--)work();\n}"
    },
    {
        "title": "G. Minecraft",
        "description": "After winning another Bed Wars game, Masha and Olya wanted to relax and decided to play a new game. Masha gives Olya an array\na\nof length\nn\nand a number\ns\n. Now Olya's task is to find a non-negative number\nx\nsuch that\nn\n∑\ni=1\nai⊕x=s\n. But she is very tired after a tight round, so please help her with this.\nBut this task seemed too simple to them, so they decided to make the numbers larger (up to\n2k\n) and provide you with their binary representation.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k,n⋅k≤2⋅106\n) — the length of the array\na\nand the length of the binary representation of all numbers.\nThe second line contains a string of length\nk\n, consisting of zeros and ones — the binary representation of the number\ns\n, starting from the most significant bits.\nThe next\nn\nlines also contain strings of length\nk\n, consisting of zeros and ones, the\ni\n-th of these strings contains the binary representation of the number\nai\n, starting from the most significant bits.\nIt is guaranteed that the sum of the values\nn⋅k\nfor all test cases does not exceed\n2⋅106\n.\nOutput\nFor each test case, output a string of length\nk\non a separate line, consisting of zeros or ones — the binary representation of any suitable number\nx\n(\nx≥0\n), starting from the most significant bits, or\n−1\nif such\nx\ndoes not exist.\nExample\ninput\nCopy\n4\n4 5\n01011\n01110\n00110\n01100\n01111\n2 8\n00101001\n10111111\n10011110\n5 4\n0101\n0010\n0000\n0000\n0010\n0011\n6 5\n00011\n10110\n11001\n01010\n11100\n10011\n10000\noutput\nCopy\n01110\n10011010\n0010\n-1\nNote\nIn the first test case,\ns=11,a=[14,6,12,15]\n, if\nx=14\n, then\nn\n∑\ni=1\nai⊕x=(14⊕14)+(6⊕14)+(12⊕14)+(15⊕14)=0+8+2+1=11=s\n.\nIn the second test case,\ns=41,a=[191,158]\n, if\nx=154\n, then\nn\n∑\ni=1\nai⊕x=(191⊕154)+(158⊕154)=37+4=41=s\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "graphs",
            "math",
            "*2600"
        ],
        "link": "https://codeforces.com/contest/1994/problem/G",
        "solution": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;const int N=2e6+5;\nint T,n,m,s[N];vector<int>f[N];string t,h;\nint main(){\n ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n cin>>T;\n while(T--){cin>>n>>m>>t;for(int i=0;i<m;i++)s[i]=0;\n  for(int i=1;i<=n;i++){cin>>h;for(int j=0;j<m;j++)if(h[j]=='1')s[j]++;}\n  for(int i=0;i<=m;i++){f[i].resize(2*n+1);\n   for(int j=0;j<=2*n;j++)f[i][j]=-1;\n  }f[m][0]=0;\n  for(int i=m-1;~i;i--)for(int j=0;j<=2*n;j++)if(f[i+1][j]!=-1){\n   if((j/2+s[i]&1)==t[i]-'0')f[i][j/2+s[i]]=j;\n   if((j/2+n-s[i]&1)==t[i]-'0')f[i][j/2+n-s[i]]=j;\n  }\n  if(f[0][t[0]-'0']!=-1){\n   for(int u=t[0]-'0',i=0;i<m;i++){\n    if(f[i][u]/2+s[i]==u)cout<<\"0\";else cout<<\"1\";\n    u=f[i][u];\n   }cout<<\"\\n\";\n  }else cout<<\"-1\\n\";\n }\n}"
    },
    {
        "title": "H. Fortnite",
        "description": "This is an interactive problem!\nTimofey is writing a competition called Capture the Flag (or CTF for short). He has one task left, which involves hacking a security system. The entire system is based on polynomial hashes\n∗\n.\nTimofey can input a string consisting of lowercase Latin letters into the system, and the system will return its polynomial hash. To hack the system, Timofey needs to find the polynomial hash parameters (\np\nand\nm\n) that the system uses.\nTimofey doesn't have much time left, so he will only be able to make\n3\nqueries. Help him solve the task.\n∗\nThe polynomial hash of a string\ns\n, consisting of lowercase Latin letters of length\nn\n, based on\np\nand modulo\nm\nis\n(ord(s1)⋅p0+ord(s2)⋅p1+ord(s3)⋅p2+…+ord(sn)⋅pn−1)modm\n. Where\nsi\ndenotes the\ni\n-th character of the string\ns\n,\nord(chr)\ndenotes the ordinal number of the character\nchr\nin the English alphabet, and\nxmodm\nis the remainder of\nx\nwhen divided by\nm\n.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤103\n) — the number of test cases.\nIt is guaranteed that the\np\nand\nm\nused by the system satisfy the conditions:\n26<p≤50\nand\np+1<m≤2⋅109\n.\nInteraction\nTo make a query to the system, output ?\ns\n, where\ns\nis a string of no more than\n50\ncharacters in length, the hash of which you want to know. In response to this query, you will receive the polynomial hash of the string\ns\n.\nTo output the answer, output !\np\nm\n, where\np\nis the base of the hash, and\nm\nis the modulus. After that, immediately proceed to the next test case.\nYou have to make not more than\n3\nqueries ?, otherwise you will get verdict Wrong Answer.\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive the verdict Idleness limit exceeded. To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nExample\ninput\nCopy\n1\n\n32\n\n28\noutput\nCopy\n? aa\n\n? yb\n\n! 31 59\nNote\nAnswer for the first query is\n(ord(a)⋅310+ord(a)⋅311)mod59=(1+1⋅31)mod59=32\n.\nAnswer for the second query is\n(ord(y)⋅310+ord(b)⋅311)mod59=(25+2⋅31)mod59=28\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "games",
            "greedy",
            "hashing",
            "interactive",
            "math",
            "number theory",
            "strings",
            "*3500"
        ],
        "link": "https://codeforces.com/contest/1994/problem/H",
        "solution": "for _ in range(int(input())):\n    print(\"? aa\")\n    p=int(input())-1\n    print(\"? zzzzzzzzzz\")\n    hsh=int(input())+1\n    hsho=hsh-1\n    nom=0\n    cnt=1\n    v=[0]*10\n    for i in range(10):\n        nom+=26*cnt\n        cnt*=p\n        v[i]=26-(hsh%p)\n        hsh//=p\n    s=\"\"\n    cnt=1\n    ch=0\n    for i in range(10):\n        if v[i]<1:\n            v[i]=26\n            v[i+1]-=1\n        ch+=cnt*v[i]\n        cnt*=p\n        s+=chr(ord('a')+v[i]-1)\n    print(\"? \"+s)\n    ans=int(input())\n    print(\"! \"+str(p)+\" \"+str(ans + nom - ch - hsho))"
    }
]