[
    {
        "title": "I2. Affectionate Arrays (Hard Version)",
        "description": "You are the beginning of the letter, the development of a poem, and the end of a fairy tale.\n— ilem, Pinky Promise\nThis is the hard version of the problem. The difference between the versions is that in this version, you need to compute the number of different arrays. You can hack only if you solved all versions of this problem.\nIris treasures an integer array\na\n1\n,\na\n2\n,…,\na\nn\n. She knows this array has an interesting property: the maximum absolute value of all elements is less than or equal to the sum of all elements, that is,\nmax(|\na\ni\n|)≤∑\na\ni\n.\nIris defines the boredom of an array as its maximum subarray\n∗\nsum.\nIris's birthday is coming, and Victor is going to send her another array\nb\n1\n,\nb\n2\n,…,\nb\nm\nas a gift. For some seemingly obvious reasons, he decides the array\nb\n1\n,\nb\n2\n,…,\nb\nm\nshould have the following properties.\na\n1\n,\na\n2\n,…,\na\nn\nshould be a subsequence\n†\n†\nof\nb\n1\n,\nb\n2\n,…,\nb\nm\n.\nThe two arrays have the same sum. That is,\n∑\ni=1\nn\na\ni\n=\n∑\ni=1\nm\nb\ni\n.\nThe boredom of\nb\n1\n,\nb\n2\n,…,\nb\nm\nis the smallest possible.\nAmong the arrays with the smallest boredom, the length of the array\nb\n(i.e.,\nm\n) is the smallest possible. And in this case, Iris will understand his regard as soon as possible!\nEven constrained as above, there are still too many possible gifts. So Victor asks you to count the number of possible arrays\nb\n1\n,\nb\n2\n,…,\nb\nm\nsatisfying all the conditions above. Since the answer may be large, Victor only needs the number modulo\n998244353\n. He promises you: if you help him successfully, he will share a bit of Iris's birthday cake with you.\nNote: since the input is large, you may need to optimize it for this problem.\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr); std::cout.tie(nullptr);\n}\n∗\nAn array\nc\nis a subarray of an array\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n†\n†\nA sequence\nc\nis a subsequence of a sequence\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) element from arbitrary positions.\nInput\nEach test contains multiple test cases. The first line of input contains an integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n6\n) — the length of the array\na\n1\n,\na\n2\n,…,\na\nn\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the initial array. It is guaranteed that\nmax(|\na\ni\n|)≤∑\na\ni\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n6\n.\nOutput\nFor each test case, output a single line containing an integer: the number of different valid arrays\nb\n1\n,\nb\n2\n,…,\nb\nm\n, modulo\n998244353\n.\nExample\ninput\nCopy\n4\n4\n1 2 3 4\n4\n2 -3 2 2\n10\n2 -7 6 3 -1 4 2 -5 8 -4\n20\n4 -2 4 3 -2 1 5 2 3 6 -5 -1 -4 -2 -3 5 -3 1 -4 1\noutput\nCopy\n1\n2\n20\n1472\nNote\nIn the first test case,\na=[1,2,3,4]\n. The only possible array\nb\nis\n[1,2,3,4]\n.\nIn the second test case,\na=[2,−3,2,2]\n. The possible arrays\nb\nare\n[1,2,−3,2,−1,2]\nand\n[2,1,−3,2,−1,2]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "graphs",
            "greedy",
            "math",
            "shortest paths",
            "two pointers"
        ]
    },
    {
        "title": "I1. Affectionate Arrays (Easy Version)",
        "description": "You are the beginning of the letter, the development of a poem, and the end of a fairy tale.\n— ilem, Pinky Promise\nThis is the easy version of the problem. The difference between the versions is that in this version, you need to compute the minimum length of the arrays. You can hack only if you solved all versions of this problem.\nIris treasures an integer array\na\n1\n,\na\n2\n,…,\na\nn\n. She knows this array has an interesting property: the maximum absolute value of all elements is less than or equal to the sum of all elements, that is,\nmax(|\na\ni\n|)≤∑\na\ni\n.\nIris defines the boredom of an array as its maximum subarray\n∗\nsum.\nIris's birthday is coming, and Victor is going to send her another array\nb\n1\n,\nb\n2\n,…,\nb\nm\nas a gift. For some seemingly obvious reasons, he decides the array\nb\n1\n,\nb\n2\n,…,\nb\nm\nshould have the following properties.\na\n1\n,\na\n2\n,…,\na\nn\nshould be a subsequence\n†\nof\nb\n1\n,\nb\n2\n,…,\nb\nm\n.\nThe two arrays have the same sum. That is,\n∑\ni=1\nn\na\ni\n=\n∑\ni=1\nm\nb\ni\n.\nThe boredom of\nb\n1\n,\nb\n2\n,…,\nb\nm\nis the smallest possible.\nAmong the arrays with the smallest boredom, the length of the array\nb\n(i.e.,\nm\n) is the smallest possible. And in this case, Iris will understand his regard as soon as possible!\nEven constrained as above, there are still too many possible gifts. So Victor asks you to compute the value of\nm\nof any array\nb\n1\n,\nb\n2\n,…,\nb\nm\nsatisfying all the conditions above. He promises you: if you help him successfully, he will share a bit of Iris's birthday cake with you.\nNote: since the input is large, you may need to optimize it for this problem.\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr); std::cout.tie(nullptr);\n}\n∗\nAn array\nc\nis a subarray of an array\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n†\nA sequence\nc\nis a subsequence of a sequence\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) element from arbitrary positions.\nInput\nEach test contains multiple test cases. The first line of input contains an integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n6\n) — the length of the array\na\n1\n,\na\n2\n,…,\na\nn\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the initial array. It is guaranteed that\nmax(|\na\ni\n|)≤∑\na\ni\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n6\n.\nOutput\nFor each test case, output a single line containing an integer: the length\nm\nof a valid array\nb\n.\nExample\ninput\nCopy\n4\n4\n1 2 3 4\n4\n2 -3 2 2\n10\n2 -7 6 3 -1 4 2 -5 8 -4\n20\n4 -2 4 3 -2 1 5 2 3 6 -5 -1 -4 -2 -3 5 -3 1 -4 1\noutput\nCopy\n4\n6\n14\n25\nNote\nIn the first test case,\na=[1,2,3,4]\n. The only array\nb\nwhich satisfies all the properties above is\n[1,2,3,4]\n, so we should output\n4\n.\nIn the second test case,\na=[2,−3,2,2]\n. The possible arrays\nb\nare\n[1,2,−3,2,−1,2]\nand\n[2,1,−3,2,−1,2]\n, so we should output\n6\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "greedy"
        ]
    },
    {
        "title": "H. Delicate Anti-monotonous Operations",
        "description": "I shall be looking for you who would be out of Existence.\n— HyuN, Disorder\nThere are always many repetitive tasks in life. Iris always dislikes them, so she refuses to repeat them. However, time cannot be turned back; we only have to move forward.\nFormally, Iris has an integer sequence\na\n1\n,\na\n2\n,…,\na\nn\n, where each number in the sequence is between\n1\nand\nw\n, inclusive. It is guaranteed that\nw≥2\n.\nIris defines an operation as selecting two numbers\na\ni\n,\na\ni+1\nsatisfying\na\ni\n=\na\ni+1\n, and then changing them to two arbitrary integers within the range\n[1,w]\n. Iris does not like equality, so she must guarantee that\na\ni\n≠\na\ni+1\nafter the operation. Two identical pairs\na\ni\n,\na\ni+1\ncan be selected multiple times.\nIris wants to know the maximum possible sum of all elements of\na\nafter several (possible, zero) operations, as well as the minimum number of operations required to achieve this maximum value.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nw\n(\n1≤n≤2⋅\n10\n5\n,\n2≤w≤\n10\n8\n) — the length of the array, and the maximum allowed value of the elements.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤w\n) — the elements in the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output two integers — the maximum possible sum of all elements of\na\nand the minimum number of operations required, respectively.\nExample\ninput\nCopy\n2\n5 8\n1 2 3 4 5\n7 5\n3 1 2 3 4 1 1\noutput\nCopy\n15 0\n34 6\nNote\nIn the first test case, no operation can be performed so the answers are\n∑\na\ni\n=15\nand\n0\n, respectively.\nIn the second test case, the operations can be performed as follows:\n[3,1,2,3,4,\n1,1\n–\n–\n–\n–\n]→[3,1,2,3,\n4,4\n–\n–\n–\n–\n,5]→[3,1,2,\n3,3\n–\n–\n–\n–\n,5,5]→[3,1,\n2,2\n–\n–\n–\n–\n,5,5,5]→[3,\n1,1\n–\n–\n–\n–\n,5,5,5,5]→[\n3,3\n–\n–\n–\n–\n,5,5,5,5,5]→[4,5,5,5,5,5,5]\n[\n3\n1\n2\n3\n4\n1\n1\n]\n[\n3\n1\n2\n3\n4\n4\n5\n]\n[\n3\n1\n2\n3\n3\n5\n5\n]\n[\n3\n1\n2\n2\n5\n5\n5\n]\n[\n3\n1\n1\n5\n5\n5\n5\n]\n[\n3\n3\n5\n5\n5\n5\n5\n]\n[\n4\n5\n5\n5\n5\n5\n5\n]\nIt can be shown this is optimal, so we should output\n∑\na\ni\n=34\nand the number of operations,\n6\n, respectively.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation"
        ]
    },
    {
        "title": "G. Naive String Splits",
        "description": "And I will: love the world that you've adored; wish the smile that you've longed for. Your hand in mine as we explore, please take me to tomorrow's shore.\n— Faye Wong, As Wished\nCocoly has a string\nt\nof length\nm\n, consisting of lowercase English letters, and he would like to split it into parts. He calls a pair of strings\n(x,y)\nbeautiful if and only if there exists a sequence of strings\na\n1\n,\na\n2\n,…,\na\nk\n, such that:\nt=\na\n1\n+\na\n2\n+…+\na\nk\n, where\n+\ndenotes string concatenation.\nFor each\n1≤i≤k\n, at least one of the following holds:\na\ni\n=x\n, or\na\ni\n=y\n.\nCocoly has another string\ns\nof length\nn\n, consisting of lowercase English letters. Now, for each\n1≤i<n\n, Cocoly wants you to determine whether the pair of strings\n(\ns\n1\ns\n2\n…\ns\ni\n,\ns\ni+1\ns\ni+2\n…\ns\nn\n)\nis beautiful.\nNote: since the input and output are large, you may need to optimize them for this problem.\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr); std::cout.tie(nullptr);\n}\nInput\nEach test contains multiple test cases. The first line contains an integer\nT\n(\n1≤T≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤m≤5⋅\n10\n6\n) — the lengths of\ns\nand the length of\nt\n.\nThe second line of each test case contains a single string\ns\nof length\nn\n, consisting only of lowercase English letters.\nThe third line of each test case contains a single string\nt\nof length\nm\n, consisting only of lowercase English letters.\nIt is guaranteed that the sum of\nm\nover all test cases does not exceed\n10\n7\n.\nOutput\nFor each test case, output a single binary string\nr\nof length\nn−1\n: for each\n1≤i<n\n, if the\ni\n-th pair is beautiful,\nr\ni\n=1\n; otherwise,\nr\ni\n=0\n. Do not output spaces.\nExample\ninput\nCopy\n7\n3 5\naba\nababa\n4 10\nczzz\nczzzzzczzz\n5 14\ndream\ndredreamamamam\n5 18\ntcccc\ntcctccccctccctcccc\n7 11\nabababc\nabababababc\n7 26\naaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaa\n19 29\nbbbbbbbbbbbbbbbbbbb\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\noutput\nCopy\n11\n011\n0010\n0000\n010100\n111111\n110010001100010011\nNote\nIn the first test case,\ns=aba\n,\nt=ababa\n.\nFor\ni=1\n: Cocoly can split\nt=a+ba+ba\n, so the string pair\n(a,ba)\nis beautiful.\nFor\ni=2\n: Cocoly can split\nt=ab+ab+a\n, so the string pair\n(ab,a)\nis beautiful.\nIn the second test case,\ns=czzz\n,\nt=czzzzzczzz\n.\nFor\ni=1\n: It can be proven that there is no solution to give a partition of\nt\nusing strings\nc\nand\nzzz\n.\nFor\ni=2\n: Cocoly can split\nt\ninto\ncz+zz+zz+cz+zz\n.\nFor\ni=3\n: Cocoly can split\nt\ninto\nczz+z+z+z+czz+z\n.",
        "time_limit": "10 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "hashing",
            "strings"
        ]
    },
    {
        "title": "F. Earnest Matrix Complement",
        "description": "3, 2, 1, ... We are the — RiOI Team!\n— Felix & All, Special Thanks 3\nPeter: Good news: My problem T311013 is approved!\nδ\n: I'm glad my computer had gone out of battery so that I wouldn't have participated in wyrqwq's round and gained a negative delta.\nFelix: [thumbs_up] The problem statement concerning a removed song!\nAquawave: Do I mourn my Chemistry?\nE.Space: ahh?\nTrine: Bread.\nIris: So why am I always testing problems?\nTime will pass, and we might meet again. Looking back at the past, everybody has lived the life they wanted.\nAquawave has a matrix\nA\nof size\nn×m\n, whose elements can only be integers in the range\n[1,k]\n, inclusive. In the matrix, some cells are already filled with an integer, while the rest are currently not filled, denoted by\n−1\n.\nYou are going to fill in all the unfilled places in\nA\n. After that, let\ncu,i\nbe the number of occurrences of element\nu\nin the\ni\n-th row. Aquawave defines the beauty of the matrix as\nk\n∑\nu=1\nn−1\n∑\ni=1\ncu,i⋅cu,i+1.\nYou have to find the maximum possible beauty of\nA\nafter filling in the blanks optimally.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤2⋅104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n≤2⋅105\n,\n2≤m≤2⋅105\n,\nn⋅m≤6⋅105\n,\n1≤k≤n⋅m\n) — the number of rows and columns of the matrix\nA\n, and the range of the integers in the matrix, respectively.\nThen\nn\nlines follow, the\ni\n-th line containing\nm\nintegers\nAi,1,Ai,2,…,Ai,m\n(\n1≤Ai,j≤k\nor\nAi,j=−1\n) — the elements in\nA\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n6⋅105\n.\nOutput\nFor each test case, output a single integer — the maximum possible beauty.\nExample\ninput\nCopy\n9\n3 3 3\n1 2 2\n3 1 3\n3 2 1\n2 3 3\n-1 3 3\n2 2 -1\n3 3 6\n-1 -1 1\n1 2 -1\n-1 -1 4\n3 4 5\n1 3 2 3\n-1 -1 2 -1\n3 1 5 1\n5 3 8\n5 -1 2\n1 8 -1\n-1 5 6\n7 7 -1\n4 4 4\n6 6 5\n-1 -1 5 -1 -1 -1\n-1 -1 -1 -1 2 -1\n-1 1 3 3 -1 -1\n-1 1 -1 -1 -1 4\n4 2 -1 -1 -1 4\n-1 -1 1 2 -1 -1\n6 6 4\n-1 -1 -1 -1 1 -1\n3 -1 2 2 4 -1\n3 1 2 2 -1 -1\n3 3 3 3 -1 2\n-1 3 3 -1 1 3\n3 -1 2 2 3 -1\n5 5 3\n1 1 3 -1 1\n2 2 -1 -1 3\n-1 -1 -1 2 -1\n3 -1 -1 -1 2\n-1 1 2 3 -1\n6 2 7\n-1 7\n-1 6\n7 -1\n-1 -1\n-1 -1\n2 2\noutput\nCopy\n4\n4\n10\n10\n8\n102\n93\n58\n13\nNote\nIn the first test case, the matrix\nA\nis already determined. Its beauty is\nk\n∑\nu=1\nn−1\n∑\ni=1\ncu,i⋅cu,i+1=c1,1⋅c1,2+c1,2⋅c1,3+c2,1⋅c2,2+c2,2⋅c2,3+c3,1⋅c3,2+c3,2⋅c3,3=1⋅1+1⋅1+2⋅0+0⋅1+0⋅2+2⋅1=4.\nIn the second test case, one can fill the matrix as follows:\n[\n2 3 3\n2 2 3\n],\nand get the value\n4\n. It can be proven this is the maximum possible answer one can get.\nIn the third test case, one of the possible optimal configurations is:\n[\n1 1 1\n1 2 1\n1 1 4\n].\nIn the fourth test case, one of the possible optimal configurations is:\n[\n1 3 2 3\n1 3 2 1\n3 1 5 1\n].\nIn the fifth test case, one of the possible optimal configurations is:\n[\n5 5 2\n1 8 5\n7 5 6\n7 7 4\n4 4 4\n].",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "implementation"
        ]
    },
    {
        "title": "E. Resourceful Caterpillar Sequence",
        "description": "Endless Repeating 7 Days\n— r-906, Panopticon\nThere is a tree consisting of\nn\nvertices. Let a caterpillar be denoted by an integer pair\n(p,q)\n(\n1≤p,q≤n\n,\np≠q\n): its head is at vertex\np\n, its tail is at vertex\nq\n, and it dominates all the vertices on the simple path from\np\nto\nq\n(including\np\nand\nq\n). The caterpillar sequence of\n(p,q)\nis defined as the sequence consisting only of the vertices on the simple path, sorted in the ascending order of the distance to\np\n.\nNora and Aron are taking turns moving the caterpillar, with Nora going first. Both players will be using his or her own optimal strategy:\nThey will play to make himself or herself win;\nHowever, if it is impossible, they will play to prevent the other person from winning (thus, the game will end in a tie).\nIn Nora's turn, she must choose a vertex\nu\nadjacent to vertex\np\n, which is not dominated by the caterpillar, and move all the vertices in it by one edge towards vertex\nu\n∗\n. In Aron's turn, he must choose a vertex\nv\nadjacent to vertex\nq\n, which is not dominated by the caterpillar, and move all the vertices in it by one edge towards vertex\nv\n. Note that the moves allowed to the two players are different.\nWhenever\np\nis a leaf\n†\n†\n, Nora wins\n‡\n‡\n. Whenever\nq\nis a leaf, Aron wins. If either initially both\np\nand\nq\nare leaves, or after\n10\n100\nturns the game has not ended, the result is a tie.\nPlease count the number of integer pairs\n(p,q)\nwith\n1≤p,q≤n\nand\np≠q\nsuch that, if the caterpillar is initially\n(p,q)\n, Aron wins the game.\n∗\nIn other words: Let the current caterpillar sequence be\nc\n1\n,\nc\n2\n,…,\nc\nk\n, then after the move, the new caterpillar sequence becomes\nd(u,\nc\n1\n),d(u,\nc\n2\n),…,d(u,\nc\nk\n)\n. Here,\nd(x,y)\nis the next vertex on the simple path from\ny\nto\nx\n.\n†\n†\nIn a tree, a vertex is called a leaf if and only if its degree is\n1\n.\n‡\n‡\nTherefore, Nora never fails to choose a vertex\nu\nwhen the game has not ended. The same goes for Aron.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nThe following\nn−1\nlines each contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n), denoting an edge between vertices\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing an integer: the number of integer pairs\n(p,q)\nwhich make Aron win.\nExample\ninput\nCopy\n5\n2\n1 2\n5\n1 2\n1 3\n2 4\n2 5\n12\n1 6\n11 2\n4 8\n12 3\n2 7\n6 12\n8 1\n2 3\n5 12\n9 2\n10 3\n10\n1 2\n2 3\n3 4\n4 5\n5 6\n4 7\n6 8\n4 9\n4 10\n25\n1 16\n11 22\n6 14\n3 1\n20 14\n23 17\n25 19\n10 11\n3 18\n10 6\n2 21\n4 5\n11 12\n4 9\n9 13\n8 6\n6 1\n3 7\n8 19\n10 24\n15 13\n1 2\n3 4\n17 8\noutput\nCopy\n0\n6\n40\n27\n171\nNote\nIn the first test case, all possible caterpillars are\n(1,2)\nand\n(2,1)\n, resulting in a tie at the beginning, since both\np\nand\nq\nare leaves.\nIn the second test case, the caterpillars that allow Aron to win are the following:\n(1,3)\n,\n(1,4)\n,\n(1,5)\n,\n(2,3)\n,\n(2,4)\n,\n(2,5)\n. Let's look at some specific caterpillars.\nFor the caterpillar\n(1,5)\n: vertex\np=1\nis not a leaf, but vertex\nq=5\nis, so Aron wins at the beginning.\nFor the caterpillar\n(2,1)\n: vertex\np=2\nis not a leaf, neither is vertex\nq=1\n. In Nora's first move, she can choose to move the caterpillar towards vertex\n5\n, therefore the caterpillar becomes\n(5,2)\n, and vertex\np=5\nis a leaf, so Nora will win.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "games",
            "graphs",
            "implementation",
            "trees"
        ]
    },
    {
        "title": "D. Refined Product Optimality",
        "description": "As a tester, when my solution has a different output from the example during testing, I suspect the author first.\n— Chris, a comment\nAlthough Iris occasionally sets a problem where the solution is possibly wrong, she still insists on creating problems with her imagination; after all, everyone has always been on the road with their stubbornness... And like ever before, Iris has set a problem to which she gave a wrong solution, but Chris is always supposed to save it! You are going to play the role of Chris now:\nChris is given two arrays\na\nand\nb\n, both consisting of\nn\nintegers.\nIris is interested in the largest possible value of\nP=\n∏\ni=1\nn\nmin(\na\ni\n,\nb\ni\n)\nafter an arbitrary rearrangement of\nb\n. Note that she only wants to know the maximum value of\nP\n, and no actual rearrangement is performed on\nb\n.\nThere will be\nq\nmodifications. Each modification can be denoted by two integers\no\nand\nx\n(\no\nis either\n1\nor\n2\n,\n1≤x≤n\n). If\no=1\n, then Iris will increase\na\nx\nby\n1\n; otherwise, she will increase\nb\nx\nby\n1\n.\nIris asks Chris the maximum value of\nP\nfor\nq+1\ntimes: once before any modification, then after every modification.\nSince\nP\nmight be huge, Chris only needs to calculate it modulo\n998244353\n.\nChris soon worked out this problem, but he was so tired that he fell asleep. Besides saying thanks to Chris, now it is your turn to write a program to calculate the answers for given input data.\nNote: since the input and output are large, you may need to optimize them for this problem.\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr); std::cout.tie(nullptr);\n}\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) — the length of the array and the number of operations.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤5⋅\n10\n8\n) — the array\na\n.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤5⋅\n10\n8\n) — the array\nb\n.\nThen\nq\nlines follow, each line contains two integers\no\nand\nx\n(\no∈{1,2}\n,\n1≤x≤n\n), representing an operation.\nIt's guaranteed that the sum of\nn\nand the sum of\nq\nover all test cases does not exceed\n4⋅\n10\n5\n, respectively.\nOutput\nFor each test case, output\nq+1\nintegers in a line, representing the answers that Chris will calculate, modulo\n998244353\n.\nExample\ninput\nCopy\n4\n3 4\n1 1 2\n3 2 1\n1 3\n2 3\n1 1\n2 1\n6 8\n1 4 2 7 3 5\n7 6 5 6 3 3\n2 5\n1 6\n1 5\n1 5\n1 5\n2 3\n2 3\n1 6\n13 8\n7 7 6 6 5 5 5 2 2 3 4 5 1\n1 4 1 9 6 6 9 1 5 1 3 8 4\n2 2\n2 11\n2 4\n2 4\n1 7\n1 1\n2 12\n1 5\n5 3\n10000000 20000000 30000000 40000000 50000000\n10000000 20000000 30000000 40000000 50000000\n1 1\n2 2\n2 1\noutput\nCopy\n2 3 3 6 6\n840 840 1008 1344 1680 2016 2016 2016 2352\n2116800 2646000 3528000 3528000 3528000 4233600 4838400 4838400 4838400\n205272023 205272023 205272023 264129429\nNote\nIn the first test case:\nBefore the modifications, Chris can rearrange\nb\nto\n[1,2,3]\nso that\nP=\n∏\ni=1\nn\nmin(\na\ni\n,\nb\ni\n)=1⋅1⋅2=2\n. We can prove that this is the maximum possible value. For example, if Chris rearranges\nb=[2,3,1]\n,\nP\nwill be equal\n1⋅1⋅1=1<2\n, which is not optimal.\nAfter the first modification, Chris can rearrange\nb\nto\n[1,2,3]\nso that\nP=1⋅1⋅3=3\n, which is maximized.\nAfter the second modification, Chris can rearrange\nb\nto\n[2,2,3]\nso that\nP=1⋅1⋅3=3\n, which is maximized.\nAfter the third modification, Chris can rearrange\nb\nto\n[2,2,3]\nso that\nP=6\n, which is maximized.\nAfter the fourth modification, Chris can rearrange\nb\nto\n[2,2,4]\nso that\nP=6\n, which is maximized.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "schedules",
            "sortings"
        ]
    },
    {
        "title": "C. Bewitching Stargazer",
        "description": "I'm praying for owning a transparent heart; as well as eyes with tears more than enough...\n— Escape Plan, Brightest Star in the Dark\nIris looked at the stars and a beautiful problem emerged in her mind. She is inviting you to solve it so that a meteor shower is believed to form.\nThere are\nn\nstars in the sky, arranged in a row. Iris has a telescope, which she uses to look at the stars.\nInitially, Iris observes stars in the segment\n[1,n]\n, and she has a lucky value of\n0\n. Iris wants to look for the star in the middle position for each segment\n[l,r]\nthat she observes. So the following recursive procedure is used:\nFirst, she will calculate\nm=⌊\nl+r\n2\n⌋\n.\nIf the length of the segment (i.e.\nr−l+1\n) is even, Iris will divide it into two equally long segments\n[l,m]\nand\n[m+1,r]\nfor further observation.\nOtherwise, Iris will aim the telescope at star\nm\n, and her lucky value will increase by\nm\n; subsequently, if\nl≠r\n, Iris will continue to observe two segments\n[l,m−1]\nand\n[m+1,r]\n.\nIris is a bit lazy. She defines her laziness by an integer\nk\n: as the observation progresses, she will not continue to observe any segment\n[l,r]\nwith a length strictly less than\nk\n. In this case, please predict her final lucky value.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤2⋅\n10\n9\n).\nOutput\nFor each test case, output a single integer — the final lucky value.\nExample\ninput\nCopy\n6\n7 2\n11 3\n55 13\n5801 6\n8919 64\n8765432 1\noutput\nCopy\n12\n18\n196\n1975581\n958900\n38416403456028\nNote\nIn the first test case, at the beginning, Iris observes\n[1,7]\n. Since\n[1,7]\nhas an odd length, she aims at star\n4\nand therefore increases her lucky value by\n4\n. Then it is split into\n2\nnew segments:\n[1,3]\nand\n[5,7]\n. The segment\n[1,3]\nagain has an odd length, so Iris aims at star\n2\nand increases her lucky value by\n2\n. Then it is split into\n2\nnew segments:\n[1,1]\nand\n[3,3]\n, both having a length less than\n2\n, so no further observation is conducted. For range\n[5,7]\n, the progress is similar and the lucky value eventually increases by\n6\n. Therefore, the final lucky value is\n4+2+6=12\n.\nIn the last test case, Iris finally observes all the stars and the final lucky value is\n1+2+⋯+8765432=38416403456028\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "divide and conquer",
            "dp",
            "math"
        ]
    },
    {
        "title": "B. Outstanding Impressionist",
        "description": "If it was so, then let's make it a deal...\n— MayDay, Gentleness\nEven after copying the paintings from famous artists for ten years, unfortunately, Eric is still unable to become a skillful impressionist painter. He wants to forget something, but the white bear phenomenon just keeps hanging over him.\nEric still remembers\nn\npieces of impressions in the form of an integer array. He records them as\nw1,w2,…,wn\n. However, he has a poor memory of the impressions. For each\n1≤i≤n\n, he can only remember that\nli≤wi≤ri\n.\nEric believes that impression\ni\nis unique if and only if there exists a possible array\nw1,w2,…,wn\nsuch that\nwi≠wj\nholds for all\n1≤j≤n\nwith\nj≠i\n.\nPlease help Eric determine whether impression\ni\nis unique for every\n1≤i≤n\n, independently for each\ni\n. Perhaps your judgment can help rewrite the final story.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅105\n) — the number of impressions.\nThen\nn\nlines follow, the\ni\n-th containing two integers\nli\nand\nri\n(\n1≤li≤ri≤2⋅n\n) — the minimum possible value and the maximum possible value of\nwi\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output a binary string\ns\nof length\nn\n: for each\n1≤i≤n\n, if impression\ni\nis unique,\nsi=1\n; otherwise,\nsi=0\n. Do not output spaces.\nExample\ninput\nCopy\n5\n2\n1 1\n1 1\n4\n1 3\n1 3\n1 3\n1 3\n6\n3 6\n2 2\n1 2\n1 1\n3 4\n2 2\n7\n3 4\n4 4\n4 4\n1 3\n2 5\n1 4\n2 2\n3\n4 5\n4 4\n5 5\noutput\nCopy\n00\n1111\n100110\n1001111\n011\nNote\nIn the first test case, the only possible array\nw\nis\n[1,1]\n, making neither impression\n1\nnor\n2\nunique (since\nw1=w2\n).\nIn the second test case, all impressions can be made unique:\nFor\ni=1\n, we can set\nw\nto\n[1,3,2,3]\n, in which\nw1≠w2\n,\nw1≠w3\n, and\nw1≠w4\n;\nFor\ni=2\n, we can set\nw\nto\n[2,3,1,2]\n, in which\nw2≠w1\n,\nw2≠w3\n, and\nw2≠w4\n;\nFor\ni=3\n, we can set\nw\nto\n[1,1,3,1]\n;\nFor\ni=4\n, we can set\nw\nto\n[2,3,3,1]\n.\nIn the third test case, for\ni=4\n, we can set\nw\nto\n[3,2,2,1,3,2]\n. Thus, impression\n4\nis unique.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy"
        ]
    },
    {
        "title": "A. Tender Carpenter",
        "description": "I would use a firework to announce, a wave to bid farewell, and a bow to say thanks: bygones are bygones; not only on the following path will I be walking leisurely and joyfully, but also the footsteps won't halt as time never leaves out flowing; for in the next year, we will meet again.\n— Cocoly1990, Goodbye 2022\nIn his dream, Cocoly would go on a long holiday with no worries around him. So he would try out for many new things, such as... being a carpenter. To learn it well, Cocoly decides to become an apprentice of Master, but in front of him lies a hard task waiting for him to solve.\nCocoly is given an array\na1,a2,…,an\n. Master calls a set of integers\nS\nstable if and only if, for any possible\nu\n,\nv\n, and\nw\nfrom the set\nS\n(note that\nu\n,\nv\n, and\nw\ndo not necessarily have to be pairwise distinct), sticks of length\nu\n,\nv\n, and\nw\ncan form a non-degenerate triangle\n∗\n.\nCocoly is asked to partition the array\na\ninto several (possibly,\n1\nor\nn\n) non-empty continuous subsegments\n†\n, such that: for each of the subsegments, the set containing all the elements in it is stable.\nMaster wants Cocoly to partition\na\nin at least two different\n‡\nways. You have to help him determine whether it is possible.\n∗\nA triangle with side lengths\nx\n,\ny\n, and\nz\nis called non-degenerate if and only if:\nx+y>z\n,\ny+z>x\n, and\nz+x>y\n.\n†\nA sequence\nb\nis a subsegment of a sequence\nc\nif\nb\ncan be obtained from\nc\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n‡\nTwo partitions are considered different if and only if at least one of the following holds:\nthe numbers of continuous subsegments split in two partitions are different;\nthere is an integer\nk\nsuch that the lengths of the\nk\n-th subsegment in two partitions are different.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤200\n) — the length of the array\na\n.\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤105\n) — the elements in the array\na\n.\nOutput\nFor each test case, print\nYES\nif there are at least two ways to partition\na\n, and\nNO\notherwise.\nYou can output the answer in any case (upper or lower). For example, the strings\nyEs\n,\nyes\n,\nYes\n, and\nYES\nwill be recognized as positive responses.\nExample\ninput\nCopy\n5\n4\n2 3 5 7\n4\n115 9 2 28\n5\n8 4 1 6 2\n6\n1 5 4 1 4 7\n2\n100000 100000\noutput\nCopy\nYES\nNO\nNO\nYES\nYES\nNote\nIn the first test case, here are two possible partitions:\n[2,3],[5,7]\n, since\n[2,3]\nis stable because sticks of lengths\n(2,2,2),(2,2,3),(2,3,3),(3,3,3)\nrespectively can all form non-degenerate triangles.\n[5,7]\nis stable because sticks of lengths\n(5,5,5),(5,5,7),(5,7,7),(7,7,7)\nrespectively can all form non-degenerate triangles.\nand\n[2],[3,5],[7]\n, since\n[2]\nis stable because sticks of lengths\n(2,2,2)\nrespectively can form a non-degenerate triangle.\n[3,5]\nis stable because sticks of lengths\n(3,3,3),(3,3,5),(3,5,5),(5,5,5)\nrespectively can all form non-degenerate triangles.\n[7]\nis stable because sticks of lengths\n(7,7,7)\nrespectively can form a non-degenerate triangle.\nNote that some other partitions also satisfy the constraints, such as\n[2],[3],[5],[7]\nand\n[2],[3],[5,7]\n.\nIn the second test case, Cocoly can only partition each element as a single subsegment, resulting in\n[115],[9],[2],[28]\n. Since we only have one possible partition, the answer is\nNO\n.\nIn the third test case, please note that the partition\n[8,4],[1],[6],[2]\ndoes not satisfy the constraints, because\n{8,4}\nis not a stable set: sticks of lengths\n4\n,\n4\n, and\n8\ncannot form a non-degenerate triangle.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "geometry",
            "implementation",
            "math"
        ]
    },
    {
        "title": "J. Judicious Watching",
        "description": "Jill loves having good grades in university, so she never misses deadlines for her homework assignments. But even more, she loves watching the series and discussing it with her best friend Johnny. And unfortunately, today she needs to choose between these two activities!\nJill needs to complete\nn\nhomework tasks. The\ni\n-th task would require\na\ni\nminutes to complete and needs to be submitted to the teacher at most\nd\ni\nminutes from now. Also, there are\nm\nnew episodes of the series that Johnny and Jill want to discuss. The\nj\n-th episode lasts\nl\nj\nminutes. Jill can complete tasks in any order, but she needs to watch the episodes in the order they come. Neither completing a homework task nor watching an episode can be interrupted after starting.\nJohnny and Jill need to agree on a time\nt\nk\nwhen they would have a call to discuss the series. They are not sure yet which time to choose. For each possible time, compute the maximum number of episodes Jill could watch before that time while still being able to complete all\nn\nhomework tasks in time.\nNote that for the purpose of this problem we assume that discussing the series with Johnny at time\nt\nk\ndoes not consume significant time from Jill and can happen even if she is in the middle of completing any of her homework tasks.\nInput\nThere are several test cases in the input. The input begins with the number of test cases\nT\n(\n1≤T≤1000\n).\nEach test case starts with a line with three integers\nn\n(\n1≤n≤200000\n) — the number of homework tasks,\nm\n(\n1≤m≤200000\n) — the number of episodes, and\nq\n(\n1≤q≤200000\n) — the number of possible times for the call with Jill.\nThe second line contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of minutes it takes to complete the task. The next line contains\nn\nintegers\nd\ni\n(\n1≤\nd\ni\n≤\n10\n15\n) — the deadline before which this task must be completed. The next line contains\nm\nintegers\nl\nj\n(\n1≤\nl\nj\n≤\n10\n9\n) — the length of episodes in the order they need to be watched. The next line contains\nq\nintegers\nt\nk\n(\n1≤\nt\nk\n≤\n10\n15\n) — the possible times of call with Jill.\nIt is possible to complete all tasks within their respective deadlines.\nThe sum of each of\nn\n,\nm\n,\nq\nover all test cases in input doesn't exceed\n200000\n.\nOutput\nFor each test case output a single line with\nq\nintegers — for each possible time\nt\nk\nthe maximum number of episodes Jill can watch.\nExample\ninput\nCopy\n2\n1 2 3\n10\n15\n5 5\n5 15 20\n3 4 5\n8 100 8\n10 150 20\n2 32 1 1\n9 200 51 50 10\noutput\nCopy\n1 1 2\n1 4 2 2 1",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*2000"
        ]
    },
    {
        "title": "G. Geometric Balance",
        "description": "Peter's little brother Ivan likes to play with a turtle. The turtle is a special toy that lives on the plane and can execute three commands:\nRotate\na\ndegrees counterclockwise.\nDraw\nd\nunits in the direction it is facing while dispensing ink. No segment of the plane will be covered by ink more than once.\nMove\nd\nunits in the direction it is facing without drawing.\nIvan just learned about the compass, so he will only rotate his turtle so it faces one of eight cardinal or ordinal directions (angles\na\nin rotate commands are always divisible by 45). Also, he will perform at least one draw command.\nPeter has noted all the commands Ivan has given to his turtle. He thinks that the image drawn by the turtle is adorable. Now Peter wonders about the smallest positive angle\nb\nsuch that he can perform the following operations: move the turtle to a point of his choosing, rotate it by\nb\ndegrees, and execute all the commands in the same order. These operations should produce the same image as the original one. Can you help Peter?\nNote, two images are considered the same if the sets of points covered by ink on the plane are the same in both of the images.\nInput\nThe first line of the input contains a single integer\nn(1≤n≤50000)\n — the number of commands Ivan has given.\nThe next\nn\nlines contain commands. Each command is one of:\n\"rotate\na\n\" (\n45≤a≤360\n) where\na\nis divisible by\n45\n;\n\"draw\nd\n\" (\n1≤d≤\n10\n9\n);\n\"move\nd\n\" (\n1≤d≤\n10\n9\n).\nAt least one and at most 2000 of the commands are draw. It is guaranteed that no segment of the plane will be covered by ink more than once.\nOutput\nOutput a single number, the answer to the question. The answer always exists.\nExamples\ninput\nCopy\n1\ndraw 10\noutput\nCopy\n180\ninput\nCopy\n7\ndraw 1\nrotate 90\ndraw 1\nrotate 90\ndraw 1\nrotate 90\ndraw 1\noutput\nCopy\n90\ninput\nCopy\n3\ndraw 1\nmove 1\ndraw 2\noutput\nCopy\n360",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "geometry",
            "implementation",
            "*2800"
        ]
    },
    {
        "title": "F. Fix Flooded Floor",
        "description": "Archimedes conducted his famous experiments on buoyancy. But not everyone knows that while he was taking a bath, he was too focused and didn't notice the moment when the water overflowed over the edge of the bath and flooded the floor near the wall. His expensive parquet was irreversibly damaged!\nArchimedes noticed that not all was lost, and there were still several undamaged parquet pieces. The parquet near the wall had the shape of a long narrow stripe of\n2×n\ncells. Archimedes had an unlimited supply of\n1×2\nparquet pieces that could be placed parallel or perpendicular to the wall. Archimedes didn't want to cut the parquet pieces. As a great scientist, he figured out that there was exactly one way to restore the parquet by filling the damaged area of the parquet with the non-overlapping\n1×2\ncell shaped pieces.\nHelp historians to check Archimedes' calculations. For the given configuration of the\n2×n\nparquet floor, determine whether there is exactly one way to fill the damaged parquet cells with the\n1×2\ncell parquet pieces. If Archimedes was wrong, find out whether there are multiple ways to restore the parquet, or there are no ways at all.\nInput\nThe first line contains a single integer\nT\n(\n1≤T≤\n10\n4\n) — the number of test cases to solve.\nThen the description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the parquet floor.\nThe following two lines contain exactly\nn\ncharacters each and describe the parquet, where '.' denotes a damaged cell and '#' denotes an undamaged cell.\nThe total sum of\nn\nin all\nT\ntest cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print \"Unique\" if there is exactly one way to restore the parquet, \"Multiple\" if there are multiple ways to do so, or \"None\" if it is impossible to restore the parquet.\nExample\ninput\nCopy\n4\n10\n#.......##\n##..#.##..\n6\n...#..\n..#...\n8\n........\n........\n3\n###\n###\noutput\nCopy\nUnique\nNone\nMultiple\nUnique",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "graphs",
            "*1700"
        ]
    },
    {
        "title": "E. Expression Correction",
        "description": "Eve is studying mathematics in school. They've already learned how to perform addition and subtraction of decimal numbers and are practicing it by solving fun puzzles. The specific type of the puzzle they are solving is described below. They are given an equality with addition and subtraction which may or may not be a correct one. They have to verify the equality, and if it is not a correct one, then they have to tell if it is possible to turn it into a correct one by moving one digit to a different place in the equality.\nLet us formally define the equality in this puzzle:\nNumber is a string of at least one and at most 10 decimal digits ('0' to '9') that has no extra leading zeroes (the only number that is allowed to start with the zero digit is \"0\").\nExpression is a string composed of one or more numbers, as defined above, that are separated with addition ('+') or subtraction ('-') operators.\nEquality is a string composed of an expression, as defined above, followed by an equals sign ('='), followed by another expression.\nCorrect equality is an equality where both expressions on the left and right hand sides of the equals sign evaluate to the same decimal number according to the standard arithmetic. Note that while all the numbers in the expression are positive, the evaluated number can be negative. Also, the evaluated number can be longer than 10 digits.\nMoving a digit in an equality means removing a digit from any position in the string and inserting it into another position so that the resulting string is again an equality.\nThe puzzle is pretty straightforward once you know how to add and subtract decimal numbers, but it is tenuous. It is easy to get distracted and make a mistake while performing computation. Your task is to write a program that solves the expression correction puzzle to help Eve.\nInput\nThe input file consists of a single line — an equality as defined in the problem statement. The total length of the input string does not exceed 100 characters.\nOutput\nWrite a single line to the output. If the input contains a correct equality, output a single word \"Correct\". Otherwise, if the input equality can be turned into a correct one by moving one digit, output the resulting correct equality. If there are multiple possible correct equalities after moving one digit, you may output any one of them. Otherwise, output a single word \"Impossible\".\nExamples\ninput\nCopy\n2+2=4\noutput\nCopy\nCorrect\ninput\nCopy\n123456789+9876543210=111111110+11-1\noutput\nCopy\n123456789+987654321=1111111100+11-1\ninput\nCopy\n10+9=10\noutput\nCopy\nImpossible\ninput\nCopy\n24=55-13\noutput\nCopy\n42=55-13\ninput\nCopy\n1000000000-10=9999999999\noutput\nCopy\nImpossible",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "expression parsing",
            "strings",
            "*1900"
        ]
    },
    {
        "title": "D. DAG Serialization",
        "description": "Consider a simple single-bit boolean register that supports two operations:\nset — sets the register to true if it was false, and returns true; otherwise, it returns false;\nunset — sets the register to false if it was true, and returns true; otherwise, it returns false.\nThe initial state of the register is false. Suppose there were\nn\noperations\no\np\ni\n(for\n1≤i≤n\n) where at most two operations returned true. Also, we are given the partial order of operations as a directed acyclic graph (DAG): an edge\ni→j\nmeans that\no\np\ni\nhappened before\no\np\nj\n. You are asked whether it is possible to put these operations in some linear sequential order that satisfies the given partial order and such that if operations are applied to the register in that order, their results are the same as given.\nInput\nIn the first line, you are given an integer\nn\n— the number of operations (\n1≤n≤\n10\n5\n). In the following\nn\nlines, you are given operations in the format \"type result\", where type is either \"set\" or \"unset\" and result is either \"true\" or \"false\". It is guaranteed that at most two operations have \"true\" results.\nIn the next line, you are given an integer\nm\n— the number of arcs of the DAG (\n0≤m≤\n10\n5\n). In the following\nm\nlines, you are given arcs — pairs of integers\na\nand\nb\n(\n1≤a,b≤n\n;\na≠b\n). Each arc indicates that operation\no\np\na\nhappened before operation\no\np\nb\n.\nOutput\nPrint any linear order of operations that satisfies the DAG constraints and ensures the results of the operations match the ones given in the input. If a correct operation order does not exist, print\n−1\n.\nExamples\ninput\nCopy\n5\nset true\nunset true\nset false\nunset false\nunset false\n2\n1 4\n5 2\noutput\nCopy\n5 1 3 2 4 \ninput\nCopy\n3\nunset true\nunset false\nset true\n0\noutput\nCopy\n2 3 1 \ninput\nCopy\n2\nunset false\nset true\n1\n2 1\noutput\nCopy\n-1\ninput\nCopy\n2\nunset false\nset false\n0\noutput\nCopy\n-1 ",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "graphs",
            "*2100"
        ]
    },
    {
        "title": "A. Adrenaline Rush",
        "description": "Alice's friend is a big fan of the Adrenaline Rush racing competition and always strives to attend every race. However, this time, Alice is the one watching the race. To ensure her friend does not miss any important details, Alice decides to take notes on everything that happens on the track.\nThe first thing Alice notices before the race begins is the numbering of the cars. All the cars line up in front of the starting line in a specific order. The car closest to the line is numbered\n1\n, the second car is numbered\n2\n, and so on, up to the last car, which is numbered\nn\n. How convenient! — Alice thought.\nThe race begins with the countdown: \"Three! Two! One! Go!\". Alice observes that the cars start in their original order. However, as the race progresses, their order changes. She records whenever one car overtakes another, essentially swapping places with it on the track.\nDuring the race, Alice notices something curious: no car overtakes another more than once. In other words, for any two cars\nx\nand\ny\n, there are at most two overtakes between them during the race: \"\nx\novertakes\ny\n\" and/or \"\ny\novertakes\nx\n\".\nAt the end of the race, Alice carefully writes down the final order of the cars\nc1,c2,…,cn\n, where\nc1\nrepresents the winner of the race.\nAlice's friend, however, is only interested in the final ranking and discards all of Alice's notes except for the final ordering. As Alice is quite curious, she wonders: What is the longest possible sequence of overtakes she could have observed during the race? Your task is to help Alice answer this question.\nInput\nThe first line of the input contains a single integer\nn(1≤n≤1000)\n — the number of cars in the race.\nThe second line contains a permutation\nc1,c2,…,cn(1≤ci≤n,ci≠cj)\n — the final order of the cars.\nOutput\nThe first line of the output should contain a single integer\nm\n — the maximum possible number of overtakes that can occur during the race.\nEach of the next\nm\nlines should contain two integers\nx\nand\ny\n(\n1≤x,y≤n\n,\nx≠y\n) representing an overtake event, where car\nx\novertakes car\ny\n. This means that car\nx\nwas directly behind car\ny\nand overtakes it. The overtakes must be listed in the order they occurred during the race.\nAfter all\nm\novertakes have occurred, the cars must arrive at the finish line in the order\nc1,c2,…,cn\n. Note that any car\nx\nshould not overtake another car\ny\nmore than once.\nIf there are multiple possible longest sequences of overtakes, output any of them.\nExamples\ninput\nCopy\n3\n2 3 1\noutput\nCopy\n4\n2 1\n3 1\n3 2\n2 3\ninput\nCopy\n1\n1\noutput\nCopy\n0\ninput\nCopy\n2\n1 2\noutput\nCopy\n2\n2 1\n1 2",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "*1600"
        ]
    },
    {
        "title": "G. Snakes",
        "description": "Suppose you play a game where the game field looks like a strip of\n1×109\nsquare cells, numbered from\n1\nto\n109\n.\nYou have\nn\nsnakes (numbered from\n1\nto\nn\n) you need to place into some cells. Initially, each snake occupies exactly one cell, and you can't place more than one snake into one cell. After that, the game starts.\nThe game lasts for\nq\nseconds. There are two types of events that may happen each second:\nsnake\nsi\nenlarges: if snake\nsi\noccupied cells\n[l,r]\n, it enlarges to a segment\n[l,r+1]\n;\nsnake\nsi\nshrinks: if snake\nsi\noccupied cells\n[l,r]\n, it shrinks to a segment\n[l+1,r]\n.\nEach second, exactly one of the events happens.\nIf at any moment of time, any snake runs into some obstacle (either another snake or the end of the strip), you lose. Otherwise, you win with the score equal to the maximum cell occupied by any snake so far.\nWhat is the minimum possible score you can achieve?\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤n≤20\n;\n1≤q≤2⋅105\n) — the number of snakes and the number of events. Next\nq\nlines contain the description of events — one per line.\nThe\ni\n-th line contains\neither \"\nsi\n+\" (\n1≤si≤n\n) meaning that the\nsi\n-th snake enlarges\nor \"\nsi\n-\" (\n1≤si≤n\n) meaning that the\nsi\n-th snake shrinks.\nAdditional constraint on the input: the given sequence of events is valid, i. e. a snake of length\n1\nnever shrinks.\nOutput\nPrint one integer — the minimum possible score.\nExamples\ninput\nCopy\n3 6\n1 +\n1 -\n3 +\n3 -\n2 +\n2 -\noutput\nCopy\n4\ninput\nCopy\n5 13\n5 +\n3 +\n5 -\n2 +\n4 +\n3 +\n5 +\n5 -\n2 +\n3 -\n3 +\n3 -\n2 +\noutput\nCopy\n11\nNote\nIn the first test, the optimal strategy is to place the second snake at cell\n1\n, the third snake — at\n2\n, and the first one — at\n3\n. The maximum occupied cell is cell\n4\n, and it's the minimum possible score.\nIn the second test, one of the optimal strategies is to place:\nsnake\n2\nat position\n1\n;\nsnake\n3\nat position\n4\n;\nsnake\n5\nat position\n6\n;\nsnake\n1\nat position\n9\n;\nsnake\n4\nat position\n10\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "dsu",
            "graphs"
        ]
    },
    {
        "title": "F. Joker",
        "description": "Consider a deck of\nn\ncards. The positions in the deck are numbered from\n1\nto\nn\nfrom top to bottom. A joker is located at position\nm\n.\nq\noperations are applied sequentially to the deck. During the\ni\n-th operation, you need to take the card at position\nai\nand move it either to the beginning or to the end of the deck. For example, if the deck is\n[2,1,3,5,4]\n, and\nai=2\n, then after the operation the deck will be either\n[1,2,3,5,4]\n(the card from the second position moved to the beginning) or\n[2,3,5,4,1]\n(the card from the second position moved to the end).\nYour task is to calculate the number of distinct positions where the joker can be after each operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nq\n(\n2≤n≤109\n;\n1≤m≤n\n;\n1≤q≤2⋅105\n).\nThe second line contains\nq\nintegers\na1,a2,…,aq\n(\n1≤ai≤n\n).\nAdditional constraint on the input: the sum of\nq\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, print\nq\nintegers — the number of distinct positions where the joker can be after each operation.\nExample\ninput\nCopy\n5\n6 5 3\n1 2 3\n2 1 4\n2 1 1 2\n5 3 1\n3\n3 2 4\n2 1 1 1\n18 15 4\n13 15 1 16\noutput\nCopy\n2 3 5 \n2 2 2 2 \n2 \n2 3 3 3 \n2 4 6 8 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math"
        ]
    },
    {
        "title": "E. Best Price",
        "description": "A batch of Christmas trees has arrived at the largest store in Berland.\nn\ncustomers have already come to the store, wanting to buy them.\nBefore the sales begin, the store needs to determine the price for one tree (the price is the same for all customers). To do this, the store has some information about each customer.\nFor the\ni\n-th customer, two integers\na\ni\nand\nb\ni\nare known, which define their behavior:\nif the price of the product is at most\na\ni\n, the customer will buy a tree and leave a positive review;\notherwise, if the price of the product is at most\nb\ni\n, the customer will buy a tree but leave a negative review;\notherwise, the customer will not buy a tree at all.\nYour task is to calculate the maximum possible earnings for the store, given that it can receive no more than\nk\nnegative reviews.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n;\n0≤k≤n\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n9\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤2⋅\n10\n9\n;\na\ni\n<\nb\ni\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible earnings for the store, given that it can receive no more than\nk\nnegative reviews.\nExample\ninput\nCopy\n5\n2 0\n2 1\n3 4\n1 1\n2\n5\n3 3\n1 5 2\n3 6 4\n4 3\n2 3 2 8\n3 7 3 9\n3 1\n2 9 5\n12 14 9\noutput\nCopy\n2\n5\n9\n14\n15\nNote\nConsider the example from the statement:\nIn the first test case, the price should be set to\n1\n. Then both customers will buy one tree each and leave no negative reviews;\nIn the second test case, the price should be set to\n5\n. Then the only customer will buy a tree and leave a negative review;\nIn the third test case, the price should be set to\n3\n. Then all customers will buy one tree each, and the store will receive two negative reviews.\nIn the fourth test case, the price should be set to\n7\n. Then two customers will buy one tree each, and the store will receive one negative review.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "greedy",
            "sortings"
        ]
    },
    {
        "title": "D. Counting Pairs",
        "description": "You are given a sequence\na\n, consisting of\nn\nintegers, where the\ni\n-th element of the sequence is equal to\na\ni\n. You are also given two integers\nx\nand\ny\n(\nx≤y\n).\nA pair of integers\n(i,j)\nis considered interesting if the following conditions are met:\n1≤i<j≤n\n;\nif you simultaneously remove the elements at positions\ni\nand\nj\nfrom the sequence\na\n, the sum of the remaining elements is at least\nx\nand at most\ny\n.\nYour task is to determine the number of interesting pairs of integers for the given sequence\na\n.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines:\nThe first line contains three integers\nn,x,y\n(\n3≤n≤2⋅\n10\n5\n,\n1≤x≤y≤2⋅\n10\n14\n);\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the number of interesting pairs of integers for the given sequence\na\n.\nExample\ninput\nCopy\n7\n4 8 10\n4 6 3 6\n6 22 27\n4 9 6 3 4 5\n3 8 10\n3 2 1\n3 1 1\n2 3 4\n3 3 6\n3 2 1\n4 4 12\n3 3 2 1\n6 8 8\n1 1 2 2 2 3\noutput\nCopy\n4\n7\n0\n0\n1\n5\n6\nNote\nIn the first example, there are\n4\ninteresting pairs of integers:\n(1,2)\n;\n(1,4)\n;\n(2,3)\n;\n(3,4)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "sortings",
            "two pointers"
        ]
    },
    {
        "title": "C. Preparing for the Exam",
        "description": "Monocarp is preparing for his first exam at the university. There are\nn\ndifferent questions which can be asked during the exam, numbered from\n1\nto\nn\n. There are\nm\ndifferent lists of questions; each list consists of exactly\nn−1\ndifferent questions. Each list\ni\nis characterized by one integer\na\ni\n, which is the index of the only question which is not present in the\ni\n-th list. For example, if\nn=4\nand\na\ni\n=3\n, the\ni\n-th list contains questions\n[1,2,4]\n.\nDuring the exam, Monocarp will receive one of these\nm\nlists of questions. Then, the professor will make Monocarp answer all questions from the list. So, Monocarp will pass only if he knows all questions from the list.\nMonocarp knows the answers for\nk\nquestions\nq\n1\n,\nq\n2\n,…,\nq\nk\n. For each list, determine if Monocarp will pass the exam if he receives that list.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains three integers\nn\n,\nm\nand\nk\n(\n2≤n≤3⋅\n10\n5\n;\n1≤m,k≤n\n);\nthe second line contains\nm\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nm\n(\n1≤\na\ni\n≤n\n;\na\ni\n<\na\ni+1\n);\nthe third line contains\nk\ndistinct integers\nq\n1\n,\nq\n2\n,…,\nq\nk\n(\n1≤\nq\ni\n≤n\n;\nq\ni\n<\nq\ni+1\n).\nAdditional constraints on the input:\nthe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a string of\nm\ncharacters. The\ni\n-th character should be 1 if Monocarp passes the exam if he receives the\ni\n-th question list, 0 if Monocarp won't pass.\nExample\ninput\nCopy\n4\n4 4 3\n1 2 3 4\n1 3 4\n5 4 3\n1 2 3 4\n1 3 4\n4 4 4\n1 2 3 4\n1 2 3 4\n2 2 1\n1 2\n2\noutput\nCopy\n0100\n0000\n1111\n10\nNote\nIn the first test case, Monocarp knows the questions\n[1,3,4]\n. Let's consider all the question lists:\nthe first list consists of questions\n[2,3,4]\n. Monocarp doesn't know the\n2\n-nd question, so he won't pass;\nthe second list consists of questions\n[1,3,4]\n. Monocarp knows all these questions, so he will pass;\nthe third list consists of questions\n[1,2,4]\n. Monocarp doesn't know the\n2\n-nd question, so he won't pass;\nthe fourth list consists of questions\n[1,2,3]\n. Monocarp doesn't know the\n2\n-nd question, so he won't pass.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation"
        ]
    },
    {
        "title": "B. Journey",
        "description": "Monocarp decided to embark on a long hiking journey.\nHe decided that on the first day he would walk\na\nkilometers, on the second day he would walk\nb\nkilometers, on the third day he would walk\nc\nkilometers, on the fourth day, just like on the first, he would walk\na\nkilometers, on the fifth day, just like on the second, he would walk\nb\nkilometers, on the sixth day, just like on the third, he would walk\nc\nkilometers, and so on.\nMonocarp will complete his journey on the day when he has walked at least\nn\nkilometers in total. Your task is to determine the day on which Monocarp will complete his journey.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of one line containing four integers\nn\n,\na\n,\nb\n,\nc\n(\n1≤n≤\n10\n9\n;\n1≤a,b,c≤\n10\n6\n).\nOutput\nFor each test case, output one integer — the day on which Monocarp will have walked at least\nn\nkilometers in total and will complete his journey.\nExample\ninput\nCopy\n4\n12 1 5 3\n6 6 7 4\n16 3 4 1\n1000000000 1 1 1\noutput\nCopy\n5\n1\n6\n1000000000\nNote\nIn the first example, over the first four days, Monocarp will cover\n1+5+3+1=10\nkilometers. On the fifth day, he will cover another\n5\nkilometers, meaning that in total over five days he will have covered\n10+5=15\nkilometers. Since\nn=12\n, Monocarp will complete his journey on the fifth day.\nIn the second example, Monocarp will cover\n6\nkilometers on the first day. Since\nn=6\n, Monocarp will complete his journey on the very first day.\nIn the third example, Monocarp will cover\n3+4+1+3+4+1=16\nkilometers over the first six days. Since\nn=16\n, Monocarp will complete his journey on the sixth day.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math"
        ]
    },
    {
        "title": "A. Preparing for the Olympiad",
        "description": "Monocarp and Stereocarp are preparing for the Olympiad. There are\nn\ndays left until the Olympiad. On the\ni\n-th day, if Monocarp plans to practice, he will solve\na\ni\nproblems. Similarly, if Stereocarp plans to practice on the same day, he will solve\nb\ni\nproblems.\nMonocarp can train on any day he wants. However, Stereocarp watches Monocarp and follows a different schedule: if Monocarp trained on day\ni\nand\ni<n\n, then Stereocarp will train on day\n(i+1)\n.\nMonocarp wants to organize his training process in a way that the difference between the number of problems he solves and the number of problems Stereocarp solves is as large as possible. Formally, Monocarp wants to maximize the value of\n(m−s)\n, where\nm\nis the number of problems he solves, and\ns\nis the number of problems Stereocarp solves. Help Monocarp determine the maximum possible difference in the number of solved problems between them.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤100\n).\nOutput\nFor each test case, print a single integer — the maximum possible difference between the number of problems Monocarp solves and the number of problems Stereocarp solves.\nExample\ninput\nCopy\n4\n2\n3 2\n2 1\n1\n5\n8\n3\n1 1 1\n2 2 2\n6\n8 2 5 6 2 6\n8 2 7 4 3 4\noutput\nCopy\n4\n5\n1\n16\nNote\nLet's analyze the example from the statement:\nIn the first test case, it is optimal for Monocarp to train both days; then Stereocarp will train on day\n2\n.\nIn the second test case, it is optimal for Monocarp to train on the only day, and Stereocarp will not train at all.\nIn the third test case, it is optimal for Monocarp to train on the last day (and only on that day).\nIn the fourth test case, it is optimal for Monocarp to train on days\n1,3,4,6\n; then Stereocarp will train on days\n2,4,5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy"
        ]
    },
    {
        "title": "G. Tree Destruction",
        "description": "Given a tree\n∗\nwith\nn\nvertices. You can choose two vertices\na\nand\nb\nonce and remove all vertices on the path from\na\nto\nb\n, including the vertices themselves. If you choose\na=b\n, only one vertex will be removed.\nYour task is to find the maximum number of connected components\n†\n†\nthat can be formed after removing the path from the tree.\n∗\nA tree is a connected graph without cycles.\n†\n†\nA connected component is a set of vertices such that there is a path along the edges from any vertex to any other vertex in the set (and it is not possible to reach vertices not belonging to this set)\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains one integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the size of the tree.\nThe next\nn−1\nlines contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — the vertices connected by an edge. It is guaranteed that the edges form a tree.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the maximum number of connected components that can be achieved using the described operation.\nExample\ninput\nCopy\n6\n2\n1 2\n5\n1 2\n2 3\n3 4\n3 5\n4\n1 2\n2 3\n3 4\n5\n2 1\n3 1\n4 1\n5 4\n6\n2 1\n3 1\n4 1\n5 3\n6 3\n6\n2 1\n3 2\n4 2\n5 3\n6 4\noutput\nCopy\n1\n3\n2\n3\n4\n3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "F. Maximum modulo equality",
        "description": "You are given an array\na\nof length\nn\nand\nq\nqueries\nl\n,\nr\n.\nFor each query, find the maximum possible\nm\n, such that all elements\na\nl\n,\na\nl+1\n, ...,\na\nr\nare equal modulo\nm\n. In other words,\na\nl\nmodm=\na\nl+1\nmodm=⋯=\na\nr\nmodm\n, where\namodb\n — is the remainder of division\na\nby\nb\n. In particular, when\nm\ncan be infinite, print\n0\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\n,\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the length of the array and the number of queries.\nThe second line of each test case contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array.\nIn the following\nq\nlines of each test case, two integers\nl\n,\nr\nare provided (\n1≤l≤r≤n\n) — the range of the query.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n, and the sum of\nq\ndoes not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output the maximum value\nm\ndescribed in the statement.\nExample\ninput\nCopy\n3\n5 5\n5 14 2 6 3\n4 5\n1 4\n2 4\n3 5\n1 1\n1 1\n7\n1 1\n3 2\n1 7 8\n2 3\n1 2\noutput\nCopy\n3 1 4 1 0 \n0 \n1 6 \nNote\nIn the first query of the first sample,\n6mod3=3mod3=0\n. It can be shown that for greater\nm\n, the required condition will not be fulfilled.\nIn the third query of the first sample,\n14mod4=2mod4=6mod4=2\n. It can be shown that for greater\nm\n, the required condition will not be fulfilled.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "math",
            "number theory",
            "*1700"
        ]
    },
    {
        "title": "E. Three Strings",
        "description": "You are given three strings:\na\n,\nb\n, and\nc\n, consisting of lowercase Latin letters. The string\nc\nwas obtained in the following way:\nAt each step, either string\na\nor string\nb\nwas randomly chosen, and the first character of the chosen string was removed from it and appended to the end of string\nc\n, until one of the strings ran out. After that, the remaining characters of the non-empty string were added to the end of\nc\n.\nThen, a certain number of characters in string\nc\nwere randomly changed.\nFor example, from the strings\na=abra\nand\nb=cada\n, without character replacements, the strings\ncaabdraa\n,\nabracada\n,\nacadabra\ncould be obtained.\nFind the minimum number of characters that could have been changed in string\nc\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains one string of lowercase Latin letters\na\n(\n1≤|a|≤\n10\n3\n) — the first string, where\n|a|\ndenotes the length of string\na\n.\nThe second line of each test case contains one string of lowercase Latin letters\nb\n(\n1≤|b|≤\n10\n3\n) — the second string, where\n|b|\ndenotes the length of string\nb\n.\nThe third line of each test case contains one string of lowercase Latin letters\nc\n(\n|c|=|a|+|b|\n) — the third string.\nIt is guaranteed that the sum of\n|a|\nacross all test cases does not exceed\n2⋅\n10\n3\n. Also, the sum of\n|b|\nacross all test cases does not exceed\n2⋅\n10\n3\n.\nOutput\nFor each test case, output a single integer — the minimum number of characters that could have been changed in string\nc\n.\nExample\ninput\nCopy\n7\na\nb\ncb\nab\ncd\nacbd\nab\nba\naabb\nxxx\nyyy\nxyxyxy\na\nbcd\ndecf\ncodes\nhorse\ncodeforces\negg\nannie\negaegaeg\noutput\nCopy\n1\n0\n2\n0\n3\n2\n3",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "strings",
            "*1500"
        ]
    },
    {
        "title": "D. Digital string maximization",
        "description": "You are given a string\ns\n, consisting of digits from\n0\nto\n9\n. In one operation, you can pick any digit in this string, except for\n0\nor the leftmost digit, decrease it by\n1\n, and then swap it with the digit left to the picked.\nFor example, in one operation from the string\n1023\n, you can get\n1103\nor\n1022\n.\nFind the lexicographically maximum string you can obtain after any number of operations.\nInput\nThe first line of the input consists of an integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nEach test case consists of a single line consisting of a digital string\ns\n(\n1≤|s|≤2⋅\n10\n5\n), where\n|s|\ndenotes the length of\ns\n. The string does not contain leading zeroes.\nIt is guaranteed that the sum of\n|s|\nof all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print the answer on a separate line.\nExample\ninput\nCopy\n6\n19\n1709\n11555\n51476\n9876543210\n5891917899\noutput\nCopy\n81\n6710\n33311\n55431\n9876543210\n7875567711\nNote\nIn the first example, the following sequence of operations is suitable:\n19→81\n.\nIn the second example, the following sequence of operations is suitable:\n1709→1780→6180→6710\n.\nIn the fourth example, the following sequence of operations is suitable:\n51476→53176→53616→53651→55351→55431\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "strings",
            "*1300"
        ]
    },
    {
        "title": "C. Uninteresting Number",
        "description": "You are given a number\nn\nwith a length of no more than\n10\n5\n.\nYou can perform the following operation any number of times: choose one of its digits, square it, and replace the original digit with the result. The result must be a digit (that is, if you choose the digit\nx\n, then the value of\nx\n2\nmust be less than\n10\n).\nIs it possible to obtain a number that is divisible by\n9\nthrough these operations?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains the number\nn\n, without leading zeros. The length of the number does not exceed\n10\n5\n.\nIt is guaranteed that the sum of the lengths of the numbers across all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if it is possible to obtain a number divisible by\n9\nusing the described operations, and \"NO\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n9\n123\n322\n333333333333\n9997\n5472778912773\n1234567890\n23\n33\n52254522632\noutput\nCopy\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\nYES\nNote\nIn the first example, from the integer\n123\n, it is possible to obtain only\n123\n,\n143\n,\n129\n, and\n149\n, none of which are divisible by\n9\n.\nIn the second example, you need to replace the second digit with its square; then\nn\nwill equal\n342=38⋅9\n.\nIn the third example, the integer is already divisible by\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "math",
            "*1200"
        ]
    },
    {
        "title": "B. Transfusion",
        "description": "You are given an array\na\nof length\nn\n. In one operation, you can pick an index\ni\nfrom\n2\nto\nn−1\ninclusive, and do one of the following actions:\nDecrease\na\ni−1\nby\n1\n, then increase\na\ni+1\nby\n1\n.\nDecrease\na\ni+1\nby\n1\n, then increase\na\ni−1\nby\n1\n.\nAfter each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?\nInput\nFirst line of input consists of one integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nFirst line of each test case consists of one integer\nn\n(\n3≤n≤2⋅\n10\n5\n).\nSecond line of each test case consists of\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nof all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print \"YES\" without quotation marks if it is possible to make all the elements equal after any number of operations; otherwise, print \"NO\" without quotation marks.\nYou can print answers in any register: \"yes\", \"YeS\", \"nO\"  — will also be considered correct.\nExample\ninput\nCopy\n8\n3\n3 2 1\n3\n1 1 3\n4\n1 2 5 4\n4\n1 6 6 1\n5\n6 2 1 4 2\n4\n1 4 2 1\n5\n3 1 2 1 3\n3\n2 4 2\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNO\nNO\nNO",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Line Breaks",
        "description": "Kostya has a text\ns\nconsisting of\nn\nwords made up of Latin alphabet letters. He also has two strips on which he must write the text. The first strip can hold\nm\ncharacters, while the second can hold as many as needed.\nKostya must choose a number\nx\nand write the first\nx\nwords from\ns\non the first strip, while all the remaining words are written on the second strip. To save space, the words are written without gaps, but each word must be entirely on one strip.\nSince space on the second strip is very valuable, Kostya asks you to choose the maximum possible number\nx\nsuch that all words\ns\n1\n,\ns\n2\n,…,\ns\nx\nfit on the first strip of length\nm\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤50\n;\n1≤m≤500\n) — the number of words in the list and the maximum number of characters that can be on the first strip.\nThe next\nn\nlines contain one word\ns\ni\nof lowercase Latin letters, where the length of\ns\ni\ndoes not exceed\n10\n.\nOutput\nFor each test case, output the maximum number of words\nx\nsuch that the first\nx\nwords have a total length of no more than\nm\n.\nExample\ninput\nCopy\n5\n3 1\na\nb\nc\n2 9\nalpha\nbeta\n4 12\nhello\nworld\nand\ncodeforces\n3 2\nab\nc\nd\n3 2\nabc\nab\na\noutput\nCopy\n1\n2\n2\n1\n0",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F. MEX OR Mania",
        "description": "An integer sequence\nb\n1\n,\nb\n2\n,…,\nb\nn\nis good if\nmex(\nb\n1\n,\nb\n2\n,…,\nb\nn\n)−(\nb\n1\n|\nb\n2\n|…|\nb\nn\n)=1\n. Here,\nmex(c)\ndenotes the MEX\n∗\nof the collection\nc\n, and\n|\nis the bitwise OR operator.\nShohag has an integer sequence\na\n1\n,\na\n2\n,…,\na\nn\n. He will perform the following\nq\nupdates on\na\n:\ni\nx\n — increase\na\ni\nby\nx\n.\nAfter each update, help him find the length of the longest good subarray\n†\n†\nof\na\n.\n∗\nThe minimum excluded (MEX) of a collection of integers\nc\n1\n,\nc\n2\n,…,\nc\nk\nis defined as the smallest non-negative integer\ny\nwhich does not occur in the collection\nc\n.\n†\n†\nAn array\nd\nis a subarray of an array\nf\nif\nd\ncan be obtained from\nf\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two space-separated integers\nn\nand\nq\n(\n1≤n,q≤\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n\n).\nThe next\nq\nlines of each test case are of the following form:\ni\nx\n(\n1≤i,x≤n\n) — it means you should increase\na\ni\nby\nx\n.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n10\n5\nand the sum of\nq\ndoesn't exceed\n10\n5\n.\nOutput\nFor each test case, output\nq\nlines — on the\ni\n-th line output the length of the longest good subarray of\na\nafter the\ni\n-th update.\nExample\ninput\nCopy\n2\n6 3\n0 0 1 0 1 0\n6 1\n3 2\n6 3\n3 1\n1 3 1\n1 1\noutput\nCopy\n6\n3\n2\n0\nNote\nIn the first test case, after the first update, the array becomes\n[0,0,1,0,1,1]\n, and here the whole array is good because\nmex([0,0,1,0,1,1])−(0|0|1|0|1|1)=2−1=1\n.\nAfter the second update, the array becomes\n[0,0,3,0,1,1]\n, and here the subarray\n[0,1,1]\nhas the maximum length among all the good subarrays.\nFinally, after the third update, the array becomes\n[0,0,3,0,1,4]\n, and here the subarrays\n[0,0]\nand\n[0,1]\nboth have the maximum length among all the good subarrays.",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "data structures",
            "dsu",
            "implementation"
        ]
    },
    {
        "title": "E. Broken Queries",
        "description": "You, a wizard whose creation was destroyed by a dragon, are determined to hunt it down with a magical AOE tracker. But it seems to be toyed with...\nThis is an interactive problem.\nThere is a hidden binary array\na\nof length\nn\n(\nn\nis a power of 2) and a hidden integer\nk (2≤k≤n−1)\n. The array\na\ncontains exactly one 1 (and all other elements are 0). For two integers\nl\nand\nr\n(\n1≤l≤r≤n\n), define the range sum\ns(l,r)=al+al+1+⋯+ar\n.\nYou have a magical device that takes ranges and returns range sums, but it returns the opposite result when the range has length at least\nk\n. Formally, in one query, you can give it a pair of integers\n[l,r]\nwhere\n1≤l≤r≤n\n, and it will return either\n0\nor\n1\naccording to the following rules:\nIf\nr−l+1<k\n, it will return\ns(l,r)\n.\nIf\nr−l+1≥k\n, it will return\n1−s(l,r)\n.\nFind\nk\nusing at most\n33\nqueries.\nThe device is not adaptive. It means that the hidden\na\nand\nk\nare fixed before the interaction and will not change during the interaction.\nInteraction\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains one positive integer\nn\n(\n4≤n≤230\n) — the length of the hidden array. It is guaranteed that\nn\nis a power of 2; that is,\nn=2m\nfor some non-negative integer\nm\n.\nYou can make queries in the following way — print one line of the form \"\n?lr\n\" where\n1≤l≤r≤n\n. After that, read a single integer:\n0\nor\n1\n, as described in the statement.\nIf you want to print the answer\nk\n, output \"\n!k\n\". Then, the interaction continues with the next test case.\nPrinting the answer does not count towards the number of queries made.\nAfter printing each query do not forget to output the end of line and flush\n∗\nthe output. Otherwise, you will get Idleness limit exceeded verdict.\nIf, at any interaction step, you read\n−1\ninstead of valid data, your solution must exit immediately. This means that your solution will receive Wrong answer because of an invalid query or any other mistake. Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.\nHacks\nThe format of the hacks should be the following: the first line should contain one integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases should follow.\nThe first and only line of each test case should contain three integers\nn\n,\np\n, and\nk\n(\n4≤n≤230\n,\n1≤p≤n\n,\n2≤k≤n−1\n) — the length of the hidden array\na\n, the position of the only 1 in\na\n, and the hidden\nk\n.\nn\nmust be a power of\n2\n.\n∗\nTo flush, use:\nfflush(stdout) or cout.flush() in C++;\nsys.stdout.flush() in Python;\nsee the documentation for other languages.\nExample\ninput\nCopy\n2\n8\n\n0\n\n0\n\n1\n\n0\n\n4\n\n1\n\n0\noutput\nCopy\n? 3 5\n\n? 1 8\n\n? 4 8\n\n? 3 8\n\n! 6\n\n? 3 3\n\n? 3 4\n\n! 2\nNote\nIn the first test case,\nk=6\nand the 1 in the hidden array is at index 6, so\na=[0,0,0,0,0,1,0,0]\n.\nFor the query 3 5, since\n5−3+1=3<k\n, the device answers correctly. Since 6 is not contained in the range\n[3,5]\n, the device answers\n0\n.\nFor the query 1 8, since\n8−1+1=8≥k\n, the device answers\n0\nincorrectly.\nFor the query 4 8, since\n8−4+1=5<k\n, the device answers\n1\ncorrectly.\nFor the query 3 8, since\n8−3+1=6≥k\n, the device answers\n0\nincorrectly.\nThe example solution then outputs\n6\nas the answer, which is correct.\nIn the second test case,\nk=2\nand the 1 in the hidden array is at index 3, so\na=[0,0,1,0]\n.\nNote that the example solution may not have enough information to determine\nk\nabove; this is only an example.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "implementation",
            "interactive"
        ]
    },
    {
        "title": "D. Shift + Esc",
        "description": "After having fun with a certain contraption and getting caught, Evirir the dragon decides to put their magical skills to good use — warping reality to escape fast!\nYou are given a grid with\nn\nrows and\nm\ncolumns of non-negative integers and an integer\nk\n. Let\n(i,j)\ndenote the cell in the\ni\n-th row from the top and\nj\n-th column from the left (\n1≤i≤n\n,\n1≤j≤m\n). For every cell\n(i,j)\n, the integer\na\ni,j\nis written on the cell\n(i,j)\n.\nYou are initially at\n(1,1)\nand want to go to\n(n,m)\n. You may only move down or right. That is, if you are at\n(i,j)\n, you can only move to\n(i+1,j)\nor\n(i,j+1)\n(if the corresponding cell exists).\nBefore you begin moving, you may do the following operation any number of times:\nChoose an integer\ni\nbetween\n1\nand\nn\nand cyclically shift row\ni\nto the left by\n1\n. Formally, simultaneously set\na\ni,j\nto\na\ni,(jmodm)+1\nfor all integers\nj\n(\n1≤j≤m\n).\nNote that you may not do any operation after you start moving.\nAfter moving from\n(1,1)\nto\n(n,m)\n, let\nx\nbe the number of operations you have performed before moving, and let\ny\nbe the sum of the integers written on visited cells (including\n(1,1)\nand\n(n,m)\n). Then the cost is defined as\nkx+y\n.\nFind the minimum cost to move from\n(1,1)\nto\n(n,m)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line contains three space-separated integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤200\n,\n0≤k≤\n10\n9\n).\nThen,\nn\nlines follow. The\ni\n-th line contains\nm\nspace-separated integers,\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n0≤\na\ni,j\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n5⋅\n10\n4\n.\nOutput\nFor each test case, output a single integer, the minimum cost to move from\n(1,1)\nto\n(n,m)\n.\nExample\ninput\nCopy\n5\n3 3 100\n3 4 9\n5 2 4\n0 101 101\n3 4 1\n10 0 0 10\n0 0 10 0\n10 10 0 10\n1 1 3\n4\n3 2 3\n1 2\n3 6\n5 4\n10 10 14\n58 49 25 12 89 69 8 49 71 23\n45 27 65 59 36 100 73 23 5 84\n82 91 54 92 53 15 43 46 11 65\n61 69 71 87 67 72 51 42 55 80\n1 64 8 54 61 70 47 100 84 50\n86 93 43 51 47 35 56 20 33 61\n100 59 5 68 15 55 69 8 8 60\n33 61 20 79 69 51 23 24 56 28\n67 76 3 69 58 79 75 10 65 63\n6 64 73 79 17 62 55 53 61 58\noutput\nCopy\n113\n6\n4\n13\n618\nNote\nIn the first test case, the minimum cost of\n113\ncan be achieved as follows:\nCyclically shift row 3 once. The grid now becomes\n⎡\n⎣\n⎢\n3\n5\n101\n4\n2\n101\n9\n4\n0\n⎤\n⎦\n⎥\n.\n[\n]\nMove as follows:\n(1,1)→(1,2)→(2,2)→(2,3)→(3,3)\n.\nx=1\noperation is done before moving. The sum of integers on visited cells is\ny=3+4+2+4+0=13\n. Therefore, the cost is\nkx+y=100⋅1+13=113\n.\nIn the second test case, one can shift row 1 once, row 2 twice, and row 3 thrice. Then, the grid becomes\n⎡\n⎣\n⎢\n0\n10\n10\n0\n0\n10\n10\n0\n10\n10\n0\n0\n⎤\n⎦\n⎥\n.\n[\n]\nx=6\noperations were done before moving, and there is a path of cost\ny=0\n. Therefore, the cost is\n6⋅1+0=6\n.",
        "time_limit": "2.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp"
        ]
    },
    {
        "title": "C. MEX Cycle",
        "description": "Evirir the dragon has many friends. They have 3 friends! That is one more than the average dragon.\nYou are given integers\nn\n,\nx\n, and\ny\n. There are\nn\ndragons sitting in a circle. The dragons are numbered\n1,2,…,n\n. For each\ni\n(\n1≤i≤n\n), dragon\ni\nis friends with dragon\ni−1\nand\ni+1\n, where dragon\n0\nis defined to be dragon\nn\nand dragon\nn+1\nis defined to be dragon\n1\n. Additionally, dragons\nx\nand\ny\nare friends with each other (if they are already friends, this changes nothing). Note that all friendships are mutual.\nOutput\nn\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nn\nsuch that for each dragon\ni\n(\n1≤i≤n\n), the following holds:\nLet\nf\n1\n,\nf\n2\n,…,\nf\nk\nbe the friends of dragon\ni\n. Then\na\ni\n=mex(\na\nf\n1\n,\na\nf\n2\n,…,\na\nf\nk\n)\n.\n∗\n∗\nThe minimum excluded (MEX) of a collection of integers\nc\n1\n,\nc\n2\n,…,\nc\nm\nis defined as the smallest non-negative integer\nt\nwhich does not occur in the collection\nc\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first and only line of each test case contains three integers\nn\n,\nx\n,\ny\n(\n3≤n≤2⋅\n10\n5\n,\n1≤x<y≤n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nspace-separated non-negative integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) on a line that satisfy the condition in the statement. If there are multiple solutions, print any of them. It can be proven that under the problem constraints, a solution with\n0≤\na\ni\n≤\n10\n9\nalways exists.\nExample\ninput\nCopy\n7\n5 1 3\n4 2 4\n6 3 5\n7 3 6\n3 2 3\n5 1 5\n6 2 5\noutput\nCopy\n0 2 1 0 1\n1 2 1 0\n1 2 0 1 2 0\n0 1 2 0 1 0 1\n2 0 1\n1 0 2 1 0\n0 1 2 0 2 1\nNote\nFor the first test case:\ni=1\n: Dragon\n1\n's friends are dragons\n2,3,5\n.\nmex(\na\n2\n,\na\n3\n,\na\n5\n)=mex(2,1,1)=0=\na\n1\n, so the condition for dragon\n1\nis satisfied.\ni=2\n: Dragon\n2\n's friends are dragons\n1,3\n.\nmex(\na\n1\n,\na\n3\n)=mex(0,1)=2=\na\n2\n.\ni=3\n: Dragon\n3\n's friends are dragons\n1,2,4\n.\nmex(\na\n1\n,\na\n2\n,\na\n4\n)=mex(0,2,0)=1=\na\n3\n.\ni=4\n: Dragon\n4\n's friends are dragons\n3,5\n.\nmex(\na\n3\n,\na\n5\n)=mex(1,1)=0=\na\n4\n.\ni=5\n: Dragon\n5\n's friends are dragons\n1,4\n.\nmex(\na\n1\n,\na\n4\n)=mex(0,0)=1=\na\n5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation"
        ]
    },
    {
        "title": "B. pspspsps",
        "description": "Cats are attracted to pspspsps, but Evirir, being a dignified dragon, is only attracted to pspspsps with oddly specific requirements...\nGiven a string\ns=\ns\n1\ns\n2\n…\ns\nn\nof length\nn\nconsisting of characters p, s, and . (dot), determine whether a permutation\n∗\np\nof length\nn\nexists, such that for all integers\ni\n(\n1≤i≤n\n):\nIf\ns\ni\nis p, then\n[\np\n1\n,\np\n2\n,…,\np\ni\n]\nforms a permutation (of length\ni\n);\nIf\ns\ni\nis s, then\n[\np\ni\n,\np\ni+1\n,…,\np\nn\n]\nforms a permutation (of length\nn−i+1\n);\nIf\ns\ni\nis ., then there is no additional restriction.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤500\n), the length of\ns\n.\nThe second line of each test case contains a string\ns\nof length\nn\nthat consists of the characters p, s, and ..\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, output YES or NO on a line. Output YES if there is such a permutation and NO otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n9\n4\ns.sp\n6\npss..s\n5\nppppp\n2\nsp\n4\n.sp.\n8\npsss....\n1\n.\n8\npspspsps\n20\n....................\noutput\nCopy\nYES\nNO\nYES\nYES\nNO\nNO\nYES\nNO\nYES\nNote\nFor the first test case, one permutation that works is\np=[3,4,1,2]\n. The restrictions are as follows:\ns\n1\n=\ns:\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n]=[3,4,1,2]\nforms a permutation.\ns\n2\n=\n.: No additional restriction.\ns\n3\n=\ns:\n[\np\n3\n,\np\n4\n]=[1,2]\nforms a permutation.\ns\n4\n=\np:\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n]=[3,4,1,2]\nforms a permutation.\nFor the second test case, it can be proven that there is no permutation that satisfies all restrictions.\nFor the third test case, one permutation that satisfies the constraints is\np=[1,2,3,4,5]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "graph matchings",
            "implementation"
        ]
    },
    {
        "title": "A. MEX Destruction",
        "description": "Evirir the dragon snuck into a wizard's castle and found a mysterious contraption, and their playful instincts caused them to play with (destroy) it...\nEvirir the dragon found an array\na\n1\n,\na\n2\n,…,\na\nn\nof\nn\nnon-negative integers.\nIn one operation, they can choose a non-empty subarray\n∗\nb\nof\na\nand replace it with the integer\nmex(b)\n†\n†\n. They want to use this operation any number of times to make\na\nonly contain zeros. It can be proven that this is always possible under the problem constraints.\nWhat is the minimum number of operations needed?\n∗\nAn array\nc\nis a subarray of an array\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n†\n†\nThe minimum excluded (MEX) of a collection of integers\nf\n1\n,\nf\n2\n,…,\nf\nk\nis defined as the smallest non-negative integer\nx\nwhich does not occur in the collection\nf\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤200\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n), the length of\na\n.\nThe second line of each test case contains\nn\nspace-separated integers,\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤100\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, output a single integer on a line, the minimum number of operations needed to make\na\ncontain only zeros.\nExample\ninput\nCopy\n10\n4\n0 1 2 3\n6\n0 0 0 0 0 0\n5\n1 0 1 0 1\n5\n3 1 4 1 5\n4\n3 2 1 0\n7\n9 100 0 89 12 2 3\n4\n0 3 9 0\n7\n0 7 0 2 0 7 0\n1\n0\n2\n0 1\noutput\nCopy\n1\n0\n2\n1\n1\n2\n1\n2\n0\n1\nNote\nIn the first test case, Evirir can choose the subarray\nb=[1,2,3]\nand replace it with\nmex(1,2,3)=0\n, changing\na\nfrom\n[0,\n1,2,3\n–\n–\n–\n–\n–\n–\n]\nto\n[0,0]\n(where the chosen subarray is underlined). Therefore, the answer is\n1\n.\nIn the second test case,\na\nalready contains only\n0\ns, so no operation is needed.\nIn the third test case, Evirir can change\na\nas follows:\n[1,\n0,1,0,1\n–\n–\n–\n–\n–\n–\n–\n–\n]→[\n1,2\n–\n–\n–\n–\n]→[0]\n. Here,\nmex(0,1,0,1)=2\nand\nmex(1,2)=0\n.\nIn the fourth test case, Evirir can choose\nb\nto be the entire array\na\n, changing\na\nfrom\n[\n3,1,4,1,5\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n]\nto\n[0]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation"
        ]
    },
    {
        "title": "I2. Kevin and Puzzle (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the versions is that in this version, you need to count the number of good arrays. You can hack only if you solved all versions of this problem.\nKevin is visiting the Red Church, and he found a puzzle on the wall.\nFor an array\na\n, let\nc(l,r)\nindicate how many distinct numbers are among\na\nl\n,\na\nl+1\n,…,\na\nr\n. In particular, if\nl>r\n, define\nc(l,r)=0\n.\nYou are given a string\ns\nof length\nn\nconsisting of letters\nL\nand\nR\nonly. Let a non-negative array\na\nbe called good, if the following conditions hold for\n1≤i≤n\n:\nif\ns\ni\n=L\n, then\nc(1,i−1)=\na\ni\n;\nif\ns\ni\n=R\n, then\nc(i+1,n)=\na\ni\n.\nYou need to count the number of good arrays\na\n. Since the answer may be large, you only need to output the answer modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of string\ns\n.\nThe second line of each test case contains a string\ns\nwith a length\nn\n, containing only English uppercase letters\nL\nand\nR\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the number of good arrays modulo\n998244353\n.\nExample\ninput\nCopy\n4\n3\nLLR\n3\nRRL\n4\nRRLR\n5\nLLRLR\noutput\nCopy\n1\n2\n0\n1\nNote\nAll arrays satisfying the conditions can be found in the easy version of this problem.",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "fft",
            "math",
            "*3500"
        ]
    },
    {
        "title": "I1. Kevin and Puzzle (Easy Version)",
        "description": "This is the easy version of the problem. The difference between the versions is that in this version, you need to find any one good array. You can hack only if you solved all versions of this problem.\nKevin is visiting the Red Church, and he found a puzzle on the wall.\nFor an array\na\n, let\nc(l,r)\nindicate how many distinct numbers are among\na\nl\n,\na\nl+1\n,…,\na\nr\n. In particular, if\nl>r\n, define\nc(l,r)=0\n.\nYou are given a string\ns\nof length\nn\nconsisting of letters\nL\nand\nR\nonly. Let a non-negative array\na\nbe called good, if the following conditions hold for\n1≤i≤n\n:\nif\ns\ni\n=L\n, then\nc(1,i−1)=\na\ni\n;\nif\ns\ni\n=R\n, then\nc(i+1,n)=\na\ni\n.\nIf there is a good array\na\n, print any of the good arrays. Otherwise, report that no such arrays exists.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of string\ns\n.\nThe second line of each test case contains a string\ns\nwith a length\nn\n, containing only English uppercase letters\nL\nand\nR\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if a good array exists, print\nn\nnon-negative integers: a good array\na\n. Otherwise, print a single integer\n−1\n.\nIf there are multiple arrays\na\nsatisfying the conditions, you can output any of them.\nExample\ninput\nCopy\n4\n3\nLLR\n3\nRRL\n4\nRRLR\n5\nLLRLR\noutput\nCopy\n0 1 0\n2 1 2\n-1\n0 1 2 3 0\nNote\nIn the first test case, the array\n[0,1,0]\nsatisfies the conditions because:\nWhen\ni=1\n,\ns\ni\n=L\n, and\nc(1,0)=0\n;\nWhen\ni=2\n,\ns\ni\n=L\n, and\nc(1,1)=1\n, since there is only one distinct number in\na\n1\n;\nWhen\ni=3\n,\ns\ni\n=R\n, and\nc(4,3)=0\n.\nIn the second test case, another suitable answer is\n[1,1,1]\n.\nIn the third test case, it can be proven that there's no array satisfying the conditions.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "*3500"
        ]
    },
    {
        "title": "H. Kevin and Strange Operation",
        "description": "Kevin is exploring problems related to binary strings in Chinatown. When he was at a loss, a stranger approached him and introduced a peculiar operation:\nSuppose the current binary string is\nt\n, with a length of\n|t|\n. Choose an integer\n1≤p≤|t|\n. For all\n1≤i<p\n, simultaneously perform the operation\nt\ni\n=max(\nt\ni\n,\nt\ni+1\n)\n, and then delete\nt\np\n.\nFor example, suppose the current binary string is 01001, and you choose\np=4\n. Perform\nt\ni\n=max(\nt\ni\n,\nt\ni+1\n)\nfor\nt\n1\n,\nt\n2\n, and\nt\n3\n, transforming the string into 11001, then delete\nt\n4\n, resulting in 1101.\nKevin finds this strange operation quite interesting. Thus, he wants to ask you: Given a binary string\ns\n, how many distinct non-empty binary strings can you obtain through any number of operations (possibly zero)?\nSince the answer may be very large, you only need to output the result modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case, the only line contains a binary string\ns\n(\n1≤|s|≤\n10\n6\n).\nIt is guaranteed that the sum of\n|s|\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print a single integer in the only line of the output — the number of distinct non-empty binary strings you can obtain, modulo\n998244353\n.\nExample\ninput\nCopy\n2\n11001\n000110111001100\noutput\nCopy\n9\n73\nNote\nIn the first test case, all the binary strings you can obtain are: 11001, 1001, 1101, 001, 101, 111, 01, 11, and 1. There are\n9\nin total.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "*3100"
        ]
    },
    {
        "title": "G. Kevin and Matrices",
        "description": "Kevin has been transported to Sacred Heart Hospital, which contains all the\nn×m\nmatrices with integer values in the range\n[1,v]\n.\nNow, Kevin wants to befriend some matrices, but he is willing to befriend a matrix\na\nif and only if the following condition is satisfied:\nmin\n1≤i≤n\n(\nmax\n1≤j≤m\na\ni,j\n)≤\nmax\n1≤j≤m\n(\nmin\n1≤i≤n\na\ni,j\n).\n(\n)\n(\nPlease count how many matrices in Sacred Heart Hospital can be friends with Kevin.\nSince Kevin is very friendly, there could be many matrices that meet this condition. Therefore, you only need to output the result modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤8⋅\n10\n3\n).\nThe only line of each test case contains three integers\nn\n,\nm\n,\nv\n(\n1≤n,v,n⋅v≤\n10\n6\n,\n1≤m≤\n10\n9\n).\nIt is guaranteed that the sum of\nn⋅v\nover all test cases doesn't exceed\n10\n6\n.\nOutput\nFor each test case, output one integer — the number of matrices that can be friends with Kevin modulo\n998244353\n.\nExample\ninput\nCopy\n3\n2 2 2\n2 3 4\n11 45 14\noutput\nCopy\n14\n2824\n883799966\nNote\nIn the first test case, besides the matrices\na=[\n1\n2\n2\n1\n]\nand\na=[\n2\n1\n1\n2\n]\n, which do not satisfy the condition, the remaining\n2\n2⋅2\n−2=14\nmatrices can all be friends with Kevin.",
        "time_limit": "6 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "math",
            "*2800"
        ]
    },
    {
        "title": "F. Kevin and Math Class",
        "description": "Kevin is a student from Eversleeping Town, currently attending a math class where the teacher is giving him division exercises.\nOn the board, there are two rows of positive integers written, each containing\nn\nnumbers. The first row is\na\n1\n,\na\n2\n,…,\na\nn\n, and the second row is\nb\n1\n,\nb\n2\n,…,\nb\nn\n.\nFor each division exercise, Kevin can choose any segment\n[l,r]\nand find the smallest value\nx\namong\nb\nl\n,\nb\nl+1\n,…,\nb\nr\n. He will then modify each\na\ni\nfor\nl≤i≤r\nto be the ceiling of\na\ni\ndivided by\nx\n.\nFormally, he selects two integers\n1≤l≤r≤n\n, sets\nx=\nmin\nl≤i≤r\nb\ni\n, and changes all\na\ni\nfor\nl≤i≤r\nto\n⌈\na\ni\nx\n⌉\n.\nKevin can leave class and go home when all\na\ni\nbecome\n1\n. He is eager to leave and wants to know the minimum number of division exercises required to achieve this.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n).\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the sequence\na\nand\nb\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n18\n) — the first row of integers on the board.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n2≤\nb\ni\n≤\n10\n18\n) — the second row of integers on the board.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the minimum number of division exercises required to leave class.\nExample\ninput\nCopy\n3\n3\n5 4 2\n6 3 2\n5\n3 6 1 3 2\n3 5 3 2 2\n6\n8 3 3 7 5 8\n3 2 3 4 2 3\noutput\nCopy\n2\n3\n3\nNote\nFor the first test case:\n[5,4,2]\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\nmin(\nb\n1\n,\nb\n2\n)=3\noperate segment [1,2]\n[2,2,2]\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\nmin(\nb\n1\n,\nb\n2\n,\nb\n3\n)=2\noperate segment [1,3]\n[1,1,1]\n.\nFor the second test case:\n[3,6,1,3,2]\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\nmin(\nb\n1\n,\nb\n2\n,\nb\n3\n)=3\noperate segment [1,3]\n[1,2,1,3,2]\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\nmin(\nb\n2\n,\nb\n3\n,\nb\n4\n)=2\noperate segment [2,4]\n[1,1,1,2,2]\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\nmin(\nb\n4\n,\nb\n5\n)=2\noperate segment [4,5]\n[1,1,1,1,1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "dp",
            "implementation",
            "math",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E. Kevin and Bipartite Graph",
        "description": "The Arms Factory needs a poster design pattern and finds Kevin for help.\nA poster design pattern is a bipartite graph with\n2n\nvertices in the left part and\nm\nvertices in the right part, where there is an edge between each vertex in the left part and each vertex in the right part, resulting in a total of\n2nm\nedges.\nKevin must color each edge with a positive integer in the range\n[1,n]\n. A poster design pattern is good if there are no monochromatic cycles\n∗\nin the bipartite graph.\nKevin needs your assistance in constructing a good bipartite graph or informing him if it is impossible.\n∗\nA monochromatic cycle refers to a simple cycle in which all the edges are colored with the same color.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n).\nThe only line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤\n10\n3\n) — the bipartite graph has\n2n\nvertices in the left part and\nm\nvertices in the right part.\nIt is guaranteed that both the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n10\n3\n.\nOutput\nFor each test case, if there is no solution, then output No.\nOtherwise, output Yes, and then output\n2n\nlines, with each line containing\nm\npositive integers. The\ni\n-th line's\nj\n-th integer represents the color of the edge between the\ni\n-th vertex in the left part and the\nj\n-th vertex in the right part.\nIf there are multiple answers, you can print any of them.\nYou can output each letter in any case (for example, the strings yEs, yes, Yes, and YES will be recognized as a positive answer).\nExample\ninput\nCopy\n3\n2 2\n3 7\n5 4\noutput\nCopy\nYES\n1 2\n2 1\n2 2\n2 1\nNO\nYES\n1 1 1 1\n1 2 2 2\n1 2 3 3\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\n1 2 3 4\nNote\nFor the first test case, the graph is shown as follows:\nFor the second test case, it can be proven that there is no valid solution.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "greedy",
            "*2000"
        ]
    },
    {
        "title": "D. Kevin and Competition Memories",
        "description": "Kevin used to get into Rio's Memories, and in Rio's Memories, a series of contests was once held. Kevin remembers all the participants and all the contest problems from that time, but he has forgotten the specific rounds, the distribution of problems, and the exact rankings.\nThere are\nm\nproblems in total, with the\ni\n-th problem having a difficulty of\nb\ni\n. Let each contest consist of\nk\nproblems, resulting in a total of\n⌊\nm\nk\n⌋\ncontests. This means that you select exactly\n⌊\nm\nk\n⌋⋅k\nproblems for the contests in any combination you want, with each problem being selected at most once, and the remaining\nmmodk\nproblems are left unused. For example, if\nm=17\nand\nk=3\n, you should create exactly\n5\ncontests consisting of\n3\nproblems each, and exactly\n2\nproblems will be left unused.\nThere are\nn\nparticipants in the contests, with Kevin being the\n1\n-st participant. The\ni\n-th participant has a rating of\na\ni\n. During the contests, each participant solves all problems with a difficulty not exceeding their rating, meaning the\ni\n-th participant solves the\nj\n-th problem if and only if\na\ni\n≥\nb\nj\n. In each contest, Kevin's rank is one plus the number of participants who solve more problems than he does.\nFor each\nk=1,2,…,m\n, Kevin wants to know the minimum sum of his ranks across all\n⌊\nm\nk\n⌋\ncontests. In other words, for some value of\nk\n, after selecting the problems for each contest, you calculate the rank of Kevin in each contest and sum up these ranks over all\n⌊\nm\nk\n⌋\ncontests. Your goal is to minimize this value.\nNote that contests for different values of\nk\nare independent. It means that for different values of\nk\n, you can select the distribution of problems into the contests independently.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n4\n).\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤3⋅\n10\n5\n) — the number of participants and the number of problems.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the rating of each participant.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n0≤\nb\ni\n≤\n10\n9\n) — the difficulty of each problem.\nIt is guaranteed that both the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output\nm\nintegers — the minimum sum of Kevin's ranks for each\nk=1,2,…,m\n.\nExample\ninput\nCopy\n4\n4 4\n4 3 7 5\n2 5 4 6\n5 5\n5 0 4 8 6\n1 3 9 2 7\n6 7\n1 1 4 5 1 4\n1 9 1 9 8 1 0\n7 6\n1 9 1 9 8 1 0\n1 1 4 5 1 4\noutput\nCopy\n7 4 2 3\n6 2 1 1 2\n7 3 2 1 1 1 1\n15 9 5 4 4 4\nNote\nFor the first test case:\nWhen\nk=1\n, since each contest only contains one problem, the distribution is in fact unique. For example, in the contest which only includes the third problem (which has a difficulty of\n4\n), all participants except the\n2\n-nd can solve it. Since no one solves strictly more problems than Kevin, his ranking in this contest is\n1\n. Similarly, in all\n4\ncontests, Kevin's rankings are\n1,3,1,2\n, and the sum is\n7\n.\nWhen\nk=2\n, one optimal way is to choose the\n1\n-st and the\n3\n-rd problem to form a contest, while the\n2\n-nd and\n4\n-th for another. In the former contest,\n4\nparticipants respectively solve\n2,1,2,2\nproblems, so Kevin's ranking is\n1\n; in the latter one, they respectively solve\n0,0,2,1\n, since there are\n2\nparticipants (\n3\n-rd and\n4\n-th) solve more problems than Kevin, his ranking is\n1+2=3\n. Thus the answer is\n1+3=4\n. It can be proven that there's no way to achieve a lower sum.\nWhen\nk=3\n, we can simply choose the\n1\n-st, the\n3\n-rd, and the\n4\n-th problem to make a contest, and Kevin has a ranking of\n2\n, which is optimal.\nWhen\nk=4\n, since there's only one contest, the distribution is also unique, and Kevin's ranking is\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "greedy",
            "sortings",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "C. Kevin and Binary Strings",
        "description": "Kevin discovered a binary string\ns\nthat starts with 1 in the river at Moonlit River Park and handed it over to you. Your task is to select two non-empty substrings\n∗\nof\ns\n(which can be overlapped) to maximize the XOR value of these two substrings.\nThe XOR of two binary strings\na\nand\nb\nis defined as the result of the\n⊕\noperation applied to the two numbers obtained by interpreting\na\nand\nb\nas binary numbers, with the leftmost bit representing the highest value. Here,\n⊕\ndenotes the bitwise XOR operation.\nThe strings you choose may have leading zeros.\n∗\nA string\na\nis a substring of a string\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n).\nThe only line of each test case contains a binary string\ns\nthat starts with 1 (\n1≤|s|≤5000\n).\nIt is guaranteed that the sum of\n|s|\nover all test cases doesn't exceed\n5000\n.\nOutput\nFor each test case, output four integers\nl\n1\n,\nr\n1\n,\nl\n2\n,\nr\n2\n(\n1≤\nl\n1\n≤\nr\n1\n≤|s|\n,\n1≤\nl\n2\n≤\nr\n2\n≤|s|\n) — in the case the two substrings you selected are\ns\nl\n1\ns\nl\n1\n+1\n…\ns\nr\n1\nand\ns\nl\n2\ns\nl\n2\n+1\n…\ns\nr\n2\n.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n5\n111\n1000\n10111\n11101\n1100010001101\noutput\nCopy\n2 2 1 3\n1 3 1 4\n1 5 1 4\n3 4 1 5\n1 13 1 11\nNote\nIn the first test case, we can choose\ns\n2\n=1\nand\ns\n1\ns\n2\ns\n3\n=111\n, and\n1⊕111=110\n. It can be proven that it is impossible to obtain a larger result. Additionally,\nl\n1\n=3\n,\nr\n1\n=3\n,\nl\n2\n=1\n,\nr\n2\n=3\nis also a valid solution.\nIn the second test case,\ns\n1\ns\n2\ns\n3\n=100\n,\ns\n1\ns\n2\ns\n3\ns\n4\n=1000\n, the result is\n100⊕1000=1100\n, which is the maximum.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "implementation",
            "strings",
            "*1200"
        ]
    },
    {
        "title": "B. Kevin and Permutation",
        "description": "Kevin is a master of permutation-related problems. You are taking a walk with Kevin in Darkwoods, and during your leisure time, he wants to ask you the following question.\nGiven two positive integers\nn\nand\nk\n, construct a permutation\n∗\np\nof length\nn\nto minimize the sum of the minimum values of all subarrays\n†\n†\nof length\nk\n. Formally, you need to minimize\n∑\ni=1\nn−k+1\n(\nmin\nj=i\ni+k−1\np\nj\n).\nk\n+\n1\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\n†\n†\nAn array\na\nis a subarray of an array\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. Two subarrays are considered different if the sets of positions of the deleted elements are different.\nInput\nEach test consists of multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n).\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤\n10\n5\n).\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers on a single line — the permutation\np\nyou constructed.\nIf there are multiple answers, you can print any of them.\nExample\ninput\nCopy\n3\n4 2\n6 1\n8 3\noutput\nCopy\n3 1 2 4\n5 2 1 6 4 3\n4 6 2 8 3 1 5 7\nNote\nIn the first test case, with\nk=2\n, consider all subarrays of length\n2\n: the minimum value of\np\n1\n,\np\n2\nis\n1\n, the minimum value of\np\n2\n,\np\n3\nis\n1\n, and the minimum value of\np\n3\n,\np\n4\nis\n2\n. The sum\n1+1+2=4\nis the smallest among all possible permutations.\nIn the second test case, all subarrays of length\n1\nhave minimum values of\n5,2,1,6,4,3\n, and the sum\n5+2+1+6+4+3=21\nis proven to be the smallest.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*900"
        ]
    },
    {
        "title": "A. Kevin and Combination Lock",
        "description": "Kevin is trapped in Lakeside Village by Grace. At the exit of the village, there is a combination lock that can only be unlocked if Kevin solves it.\nThe combination lock starts with an integer\nx\n. Kevin can perform one of the following two operations zero or more times:\nIf\nx≠33\n, he can select two consecutive digits\n3\nfrom\nx\nand remove them simultaneously. For example, if\nx=13323\n, he can remove the second and third\n3\n, changing\nx\nto\n123\n.\nIf\nx≥33\n, he can change\nx\nto\nx−33\n. For example, if\nx=99\n, he can choose this operation to change\nx\nto\n99−33=66\n.\nWhen the value of\nx\non the combination lock becomes\n0\n, Kevin can unlock the lock and escape from Lakeside Village. Please determine whether it is possible for Kevin to unlock the combination lock and escape.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n).\nThe only line of each test case contains a positive integer\nx\n(\n1≤x≤\n10\n9\n).\nOutput\nFor each test case, output \"YES\" or \"NO\" (without quotes) in one line, representing whether Kevin can unlock the combination lock and escape. You can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n5\n165\n6369\n666\n114514\n133333332\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nNote\nFor the first test case,\n165\n−\n→\n−\n−33\n132\n−\n→\n−\n−33\n99\n−\n→\n−\n−33\n66\n−\n→\n−\n−33\n33\n−\n→\n−\n−33\n0\n.\nFor the second test case,\n6369\n−\n→\n−\n−33\n6336\n−\n→\n−\n−\n−\n−\n−\n−\nremove \"33\"\n66\n−\n→\n−\n−33\n33\n−\n→\n−\n−33\n0\n.\nFor the third test case, it can be proven that, regardless of the operations performed,\n666\ncannot be transformed into\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "B. Replace Character",
        "description": "You're given a string\ns\nof length\nn\n, consisting of only lowercase English letters.\nYou must do the following operation exactly once:\nChoose any two indices\ni\nand\nj\n(\n1≤i,j≤n\n). You can choose\ni=j\n.\nSet\ns\ni\n:=\ns\nj\n.\nYou need to minimize the number of distinct permutations\n†\n†\nof\ns\n. Output any string with the smallest number of distinct permutations after performing exactly one operation.\n†\n†\nA permutation of the string is an arrangement of its characters into any order. For example, \"bac\" is a permutation of \"abc\" but \"bcc\" is not.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains\nn\n(\n1≤n≤10\n) — the length of string\ns\n.\nThe second line of each test case contains\ns\nof length\nn\n. The string contains only lowercase English letters.\nOutput\nFor each test case, output the required\ns\nafter applying exactly one operation. If there are multiple solutions, print any of them.\nExample\ninput\nCopy\n6\n3\nabc\n4\nxyyx\n8\nalphabet\n1\nk\n10\naabbccddee\n6\nttbddq\noutput\nCopy\ncbc\nyyyx\nalphaaet\nk\neabbccddee\ntttddq\nNote\nIn the first test case, we can obtain the following strings in one operation: \"abc\", \"bbc\", \"cbc\", \"aac\", \"acc\", \"aba\", and \"abb\".\nThe string \"abc\" has\n6\ndistinct permutations: \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", and \"cba\".\nThe string \"cbc\" has\n3\ndistinct permutations: \"bcc\", \"cbc\", and \"ccb\", which is the lowest of all the obtainable strings. In fact, all obtainable strings except \"abc\" have\n3\npermutations, so any of them would be accepted.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "greedy",
            "strings",
            "*900"
        ]
    },
    {
        "title": "A. Alyona and a Square Jigsaw Puzzle",
        "description": "Alyona assembles an unusual square Jigsaw Puzzle. She does so in\nn\ndays in the following manner:\nOn the first day, she starts by placing the central piece in the center of the table.\nOn each day after the first one, she places a certain number of pieces around the central piece in clockwise order, always finishing each square layer completely before starting a new one.\nFor example, she places the first\n14\npieces in the following order:\nThe colors denote the layers. The third layer is still unfinished.\nAlyona is happy if at the end of the day the assembled part of the puzzle does not have any started but unfinished layers. Given the number of pieces she assembles on each day, find the number of days Alyona is happy on.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line contains a single integer\nn\n(\n1≤n≤100\n), the number of days.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n,\na\n1\n=1\n), where\na\ni\nis the number of pieces Alyona assembles on the\ni\n-th day.\nIt is guaranteed in each test case that at the end of the\nn\ndays, there are no unfinished layers.\nOutput\nFor each test case, print a single integer: the number of days when Alyona is happy.\nExample\ninput\nCopy\n5\n1\n1\n2\n1 8\n5\n1 3 2 1 2\n7\n1 2 1 10 2 7 2\n14\n1 10 10 100 1 1 10 1 10 2 10 2 10 1\noutput\nCopy\n1\n2\n2\n2\n3\nNote\nIn the first test case, in the only day Alyona finishes the only layer.\nIn the second test case, on the first day, Alyona finishes the first layer, and on the second day, she finishes the second layer.\nIn the third test case, she finishes the second layer in a few days.\nIn the fourth test case, she finishes the second layer and immediately starts the next one on the same day, therefore, she is not happy on that day. She is only happy on the first and last days.\nIn the fifth test case, Alyona is happy on the first, fourth, and last days.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F2. Yandex Cuneiform (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the versions is that in this version, there is no restriction on the number of question marks. You can hack only if you solved all versions of this problem.\nFor a long time, no one could decipher Sumerian cuneiform. However, it has finally succumbed to pressure! Today, you have the chance to decipher Yandex cuneiform.\nYandex cuneiform is defined by the following rules:\nAn empty string is a Yandex cuneiform.\nIf you insert exactly one copy of each of the three letters 'Y', 'D', and 'X' into a Yandex cuneiform in such a way that no two adjacent letters become equal after the operation, you obtain a Yandex cuneiform.\nIf a string can't be obtained using the above rules, it is not a Yandex cuneiform.\nYou are given a template. A template is a string consisting of the characters 'Y', 'D', 'X', and '?'.\nYou need to check whether there exists a way to replace each question mark with 'Y', 'D', or 'X' to obtain a Yandex cuneiform, and if it exists, output any of the matching options, as well as a sequence of insertion operations to obtain the resulting cuneiform.\nIn this version of the problem, the number of question marks in the template can be arbitrary.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n4\n). The description of the test cases follows.\nEach test case consists of a single line containing a template of length\nn\n(\n3≤n<2⋅\n10\n5\n,\nnmod3=0\n), consisting only of characters 'Y', 'D', 'X', and '?'.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing 'NO' if it is not possible to obtain a cuneiform from the given template.\nOtherwise, output 'YES' on the first line, and on the second line, any obtainable cuneiform. After that, you need to output the sequence of operations that leads to the cuneiform you printed.\nA sequence of operations is described by\nn\n3\ntriples of pairs. A pair has the form c p, where\nc\nis one of the letters 'Y', 'D', or 'X', and\np\nis the position at which the letter\nc\nshould be inserted. The insertion position is the number of letters to skip from the beginning of the string for the insertion. For example, after inserting the character 'D' into the string \"YDX\" with\np=3\n, the result is \"YDXD\", and with\np=0\n, it is \"DYDX\". Note that the index cannot exceed the current length of the string.\nThe operations are applied from top to bottom, left to right. After inserting each triple to the string, there should be no two adjacent identical characters.\nExample\ninput\nCopy\n4\n???\nY??D?X\n???\nD??DXYXYX\noutput\nCopy\nYES\nYDX\nX 0 D 0 Y 0 \nYES\nYDXDYX\nX 0 Y 0 D 1\nX 2 D 3 Y 4\nYES\nYDX\nY 0 D 1 X 2\nNO\nNote\nIn the second example, the string is transformed like this:\n\"\"→YDX→YDXDYX\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "*3500"
        ]
    },
    {
        "title": "F1. Yandex Cuneiform (Easy Version)",
        "description": "This is the easy version of the problem. The difference between the versions is that in this version, there are no question marks. You can hack only if you solved all versions of this problem.\nFor a long time, no one could decipher Sumerian cuneiform. However, it has finally succumbed to pressure! Today, you have the chance to decipher Yandex cuneiform.\nYandex cuneiform is defined by the following rules:\nAn empty string is a Yandex cuneiform.\nIf you insert exactly one copy of each of the three letters 'Y', 'D', and 'X' into a Yandex cuneiform in such a way that no two adjacent letters become equal after the operation, you obtain a Yandex cuneiform.\nIf a string can't be obtained using the above rules, it is not a Yandex cuneiform.\nYou are given a template. A template is a string consisting of the characters 'Y', 'D', 'X', and '?'.\nYou need to check whether there exists a way to replace each question mark with 'Y', 'D', or 'X' to obtain a Yandex cuneiform, and if it exists, output any of the matching options, as well as a sequence of insertion operations to obtain the resulting cuneiform.\nIn this version of the problem, there are no question marks in the template.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n4\n). The description of the test cases follows.\nEach test case consists of a single line containing a template of length\nn\n(\n3≤n<2⋅\n10\n5\n,\nnmod3=0\n), consisting only of characters 'Y', 'D', 'X'.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing 'NO' if it is not possible to obtain a cuneiform from the given template.\nOtherwise, output 'YES' on the first line, and on the second line, any obtainable cuneiform. After that, you need to output the sequence of operations that leads to the cuneiform you printed.\nA sequence of operations is described by\nn\n3\ntriples of pairs. A pair has the form c p, where\nc\nis one of the letters 'Y', 'D', or 'X', and\np\nis the position at which the letter\nc\nshould be inserted. The insertion position is the number of letters to skip from the beginning of the string for the insertion. For example, after inserting the character 'D' into the string \"YDX\" with\np=3\n, the result is \"YDXD\", and with\np=0\n, it is \"DYDX\". Note that the index cannot exceed the current length of the string.\nThe operations are applied from top to bottom, left to right. After inserting each triple to the string, there should be no two adjacent identical characters.\nExample\ninput\nCopy\n4\nYDX\nYDXDYX\nYDX\nDYYDXYXYX\noutput\nCopy\nYES\nYDX\nX 0 D 0 Y 0 \nYES\nYDXDYX\nX 0 Y 0 D 1\nX 2 D 3 Y 4\nYES\nYDX\nY 0 D 1 X 2\nNO\nNote\nIn the second example, the string is transformed like this:\n\"\"→YDX→YDXDYX\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*3300"
        ]
    },
    {
        "title": "E2. Cheops and a Contest (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the versions is that in this version,\nm\nis arbitrary. You can hack only if you solved all versions of this problem.\nThere is a problem-solving competition in Ancient Egypt with\nn\nparticipants, numbered from\n1\nto\nn\n. Each participant comes from a certain city; the cities are numbered from\n1\nto\nm\n. There is at least one participant from each city.\nThe\ni\n-th participant has strength\na\ni\n, specialization\ns\ni\n, and wisdom\nb\ni\n, so that\nb\ni\n≥\na\ni\n. Each problem in the competition will have a difficulty\nd\nand a unique topic\nt\n. The\ni\n-th participant will solve the problem if\na\ni\n≥d\n, i.e., their strength is not less than the problem's difficulty, or\ns\ni\n=t\n, and\nb\ni\n≥d\n, i.e., their specialization matches the problem's topic, and their wisdom is not less than the problem's difficulty.\nCheops wants to choose the problems in such a way that each participant from city\ni\nwill solve strictly more problems than each participant from city\nj\n, for all\ni<j\n.\nPlease find a set of at most\n5n\nproblems, where the topics of all problems are distinct, so that Cheops' will is satisfied, or state that it is impossible.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nT\n(\n1≤T≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n2≤m≤n≤3⋅\n10\n5\n) — the number of participants and the number of cities.\nThe following\nn\nlines describe the participants. The\ni\n-th line contains three integers —\na\ni\n,\nb\ni\n,\ns\ni\n(\n0≤\na\ni\n,\nb\ni\n,\ns\ni\n≤\n10\n9\n,\na\ni\n≤\nb\ni\n) — strength, wisdom, and specialization of the\ni\n-th participant, respectively.\nThe next\nm\nlines describe the cities. In the\ni\n-th line, the first number is an integer\nk\ni\n(\n1≤\nk\ni\n≤n\n) — the number of participants from the\ni\n-th city. It is followed by\nk\ni\nintegers\nq\ni,1\n,\nq\ni,2\n,…,\nq\ni,\nk\ni\n — (\n1≤\nq\ni,j\n≤n\n,\n1≤j≤\nk\ni\n) — the indices of the participants from this city. It is guaranteed that each participant is mentioned exactly once.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, if there exists a set of problems that satisfies Cheops' conditions, then in the first line output a single integer\np\n(\n1≤p≤5n\n) — the number of problems in your solution.\nThen output\np\nlines, each containing two integers\nd\nand\nt\n(\n0≤d,t≤\n10\n9\n) — the difficulty and topic of the respective problem. The topics must be distinct.\nIf there is no set of problems that meets Cheops' wishes, print\n−1\ninstead.\nExample\ninput\nCopy\n2\n5 2\n5 7 1\n6 7 2\n3 9 2\n5 10 3\n4 4 1\n2 1 2\n3 3 4 5\n2 2\n1 2 1\n1 2 1\n1 2\n1 1\noutput\nCopy\n7\n6 4\n6 5\n5 6\n5 7\n4 8\n4 9\n7 1\n-1",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*3500"
        ]
    },
    {
        "title": "E1. Cheops and a Contest (Easy Version)",
        "description": "This is the easy version of the problem. The difference between the versions is that in this version,\nm\nequals\n2\n. You can hack only if you solved all versions of this problem.\nThere is a problem-solving competition in Ancient Egypt with\nn\nparticipants, numbered from\n1\nto\nn\n. Each participant comes from a certain city; the cities are numbered from\n1\nto\nm\n. There is at least one participant from each city.\nThe\ni\n-th participant has strength\na\ni\n, specialization\ns\ni\n, and wisdom\nb\ni\n, so that\nb\ni\n≥\na\ni\n. Each problem in the competition will have a difficulty\nd\nand a unique topic\nt\n. The\ni\n-th participant will solve the problem if\na\ni\n≥d\n, i.e., their strength is not less than the problem's difficulty, or\ns\ni\n=t\n, and\nb\ni\n≥d\n, i.e., their specialization matches the problem's topic, and their wisdom is not less than the problem's difficulty.\nCheops wants to choose the problems in such a way that each participant from city\ni\nwill solve strictly more problems than each participant from city\nj\n, for all\ni<j\n.\nPlease find a set of at most\n5n\nproblems, where the topics of all problems are distinct, so that Cheops' will is satisfied, or state that it is impossible.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nT\n(\n1≤T≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n2=m≤n≤3⋅\n10\n5\n) — the number of participants and the number of cities.\nThe following\nn\nlines describe the participants. The\ni\n-th line contains three integers —\na\ni\n,\nb\ni\n,\ns\ni\n(\n0≤\na\ni\n,\nb\ni\n,\ns\ni\n≤\n10\n9\n,\na\ni\n≤\nb\ni\n) — strength, wisdom, and specialization of the\ni\n-th participant, respectively.\nThe next\nm\nlines describe the cities. In the\ni\n-th line, the first number is an integer\nk\ni\n(\n1≤\nk\ni\n≤n\n) — the number of participants from the\ni\n-th city. It is followed by\nk\ni\nintegers\nq\ni,1\n,\nq\ni,2\n,…,\nq\ni,\nk\ni\n — (\n1≤\nq\ni,j\n≤n\n,\n1≤j≤\nk\ni\n) — the indices of the participants from this city. It is guaranteed that each participant is mentioned exactly once.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, if there exists a set of problems that satisfies Cheops' conditions, then in the first line output a single integer\np\n(\n1≤p≤5n\n) — the number of problems in your solution.\nThen output\np\nlines, each containing two integers\nd\nand\nt\n(\n0≤d,t≤\n10\n9\n) — the difficulty and topic of the respective problem. The topics must be distinct.\nIf there is no set of problems that meets Cheops' wishes, print\n−1\ninstead.\nExample\ninput\nCopy\n2\n5 2\n5 7 1\n6 7 2\n3 9 2\n5 10 3\n4 4 1\n2 1 2\n3 3 4 5\n2 2\n1 2 1\n1 2 1\n1 2\n1 1\noutput\nCopy\n7\n6 4\n6 5\n5 6\n5 7\n4 8\n4 9\n7 1\n-1",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*2900"
        ]
    },
    {
        "title": "D. For the Emperor!",
        "description": "In Ancient Rome, a plan to defeat the barbarians was developed, but for its implementation, each city must be informed about it.\nThe northern part of the Roman Empire consists of\nn\ncities connected by\nm\none-way roads. Initially, the\ni\n-th city has\na\ni\nmessengers, and each messenger can freely move between cities following the existing roads. A messenger can carry a copy of the plan with him and inform the cities he visits, and can make unlimited copies for other messengers in the city he is currently in.\nAt the start, you will produce some number of plans and deliver them to messengers of your choice. Your goal is to make sure that every city is visited by a messenger with a plan. Find the smallest number of the plans you need to produce originally, so that the messengers will deliver them to every city, or determine that it is impossible to do so at all.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line contains two integers\nn\nand\nm\n(\n2≤n≤200\n,\n1≤m≤800\n) — the number of cities and roads.\nThe second line contains\nn\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n\n) — the initial number of messengers in each city.\nEach of the following\nm\nlines contains two integers\nu\nand\nv\n(\n1≤u,v≤n,u≠v\n), indicating that there is a one-way road from city\nu\nto city\nv\n. The roads may repeat.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n200\n. It is guaranteed that the sum of\nm\nover all test cases does not exceed\n800\n.\nOutput\nOutput a single line containing a single integer — the smallest number of messengers you need to give a copy of the plan in the beginning, or\n−1\nif it is not possible to inform all cities.\nExample\ninput\nCopy\n2\n7 6\n2 1 0 1 2 3 4\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n4 4\n1 1 1 1\n1 2\n1 3\n2 4\n3 4\noutput\nCopy\n2\n2",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "flows",
            "graphs",
            "*3100"
        ]
    },
    {
        "title": "C. Adventurers",
        "description": "Once, four Roman merchants met in a Roman mansion to discuss their trading plans. They faced the following problem: they traded the same type of goods, and if they traded in the same city, they would inevitably incur losses. They decided to divide up the cities between them where they would trade.\nThe map of Rome can be represented in this problem as a plane with certain points marked — the cities of the Roman Empire.\nThe merchants decided to choose a certain dividing point\n(\nx\n0\n,\ny\n0\n)\n. Then, in a city with coordinates\n(\nx\ni\n,\ny\ni\n)\n,\nthe first merchant sells goods if\nx\n0\n≤\nx\ni\nand\ny\n0\n≤\ny\ni\n;\nthe second merchant sells goods if\nx\n0\n>\nx\ni\nand\ny\n0\n≤\ny\ni\n;\nthe third merchant sells goods if\nx\n0\n≤\nx\ni\nand\ny\n0\n>\ny\ni\n;\nthe fourth merchant sells goods if\nx\n0\n>\nx\ni\nand\ny\n0\n>\ny\ni\n.\nThe merchants want to choose\n(\nx\n0\n,\ny\n0\n)\nin such a way as to maximize the smallest number of cities that any of them gets (i. e., as fair as possible). Please find such a point for them.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n4≤n≤\n10\n5\n) — the number of cities on the map.\nEach of the next\nn\nlines contains two integers\nx\ni\n,\ny\ni\n(\n−\n10\n9\n≤\nx\ni\n,\ny\ni\n≤\n10\n9\n) — the coordinates of the cities.\nNote that some points may coincide. This is because some cities may be so close that they cannot be distinguished on the map at the given scale.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, in the first line, print a single integer\nk\n(\n0≤k≤\nn\n4\n) — the maximum possible number of cities that each merchant can get at a minimum.\nIn the second line, print two integers\nx\n0\nand\ny\n0\n(\n|\nx\n0\n|,|\ny\n0\n|≤\n10\n9\n) — the coordinates of the dividing point. If there are multiple suitable points, print any of them.\nExample\ninput\nCopy\n4\n4\n1 1\n1 2\n2 1\n2 2\n4\n0 0\n0 0\n0 0\n0 0\n8\n1 2\n2 1\n2 -1\n1 -2\n-1 -2\n-2 -1\n-2 1\n-1 2\n7\n1 1\n1 2\n1 3\n1 4\n2 1\n3 1\n4 1\noutput\nCopy\n1\n2 2\n0\n0 0\n2\n1 0\n0\n0 0",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "sortings",
            "ternary search",
            "two pointers",
            "*2100"
        ]
    },
    {
        "title": "B. Move Back at a Cost",
        "description": "You are given an array of integers\na\nof length\nn\n. You can perform the following operation zero or more times:\nIn one operation choose an index\ni\n(\n1≤i≤n\n), assign\na\ni\n:=\na\ni\n+1\n, and then move\na\ni\nto the back of the array (to the rightmost position). For example, if\na=[3,5,1,9]\n, and you choose\ni=2\n, the array becomes\n[3,1,9,6]\n.\nFind the lexicographically smallest\n∗\narray you can get by performing these operations.\n∗\nAn array\nc\nis lexicographically smaller than an array\nd\nif and only if one of the following holds:\nc\nis a prefix of\nd\n, but\nc≠d\n; or\nin the first position where\nc\nand\nd\ndiffer, the array\nc\nhas a smaller element than the corresponding element in\nd\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n5\n), the length of the array.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, print the lexicographically smallest array you can get.\nExample\ninput\nCopy\n3\n3\n2 1 3\n5\n1 2 2 1 4\n6\n1 2 3 6 5 4\noutput\nCopy\n1 3 3 \n1 1 3 3 5 \n1 2 3 4 6 7 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "sortings",
            "*1600"
        ]
    },
    {
        "title": "A. Swap Columns and Find a Path",
        "description": "There is a matrix consisting of\n2\nrows and\nn\ncolumns. The rows are numbered from\n1\nto\n2\nfrom top to bottom; the columns are numbered from\n1\nto\nn\nfrom left to right. Let's denote the cell on the intersection of the\ni\n-th row and the\nj\n-th column as\n(i,j)\n. Each cell contains an integer; initially, the integer in the cell\n(i,j)\nis\na\ni,j\n.\nYou can perform the following operation any number of times (possibly zero):\nchoose two columns and swap them (i. e. choose two integers\nx\nand\ny\nsuch that\n1≤x<y≤n\n, then swap\na\n1,x\nwith\na\n1,y\n, and then swap\na\n2,x\nwith\na\n2,y\n).\nAfter performing the operations, you have to choose a path from the cell\n(1,1)\nto the cell\n(2,n)\n. For every cell\n(i,j)\nin the path except for the last, the next cell should be either\n(i+1,j)\nor\n(i,j+1)\n. Obviously, the path cannot go outside the matrix.\nThe cost of the path is the sum of all integers in all\n(n+1)\ncells belonging to the path. You have to perform the operations and choose a path so that its cost is maximum possible.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5000\n). The description of the test cases follows.\nEach test case consists of three lines:\nthe first line contains one integer\nn\n(\n1≤n≤5000\n) — the number of columns in the matrix;\nthe second line contains\nn\nintegers\na\n1,1\n,\na\n1,2\n,…,\na\n1,n\n(\n−\n10\n5\n≤\na\ni,j\n≤\n10\n5\n) — the first row of the matrix;\nthe third line contains\nn\nintegers\na\n2,1\n,\na\n2,2\n,…,\na\n2,n\n(\n−\n10\n5\n≤\na\ni,j\n≤\n10\n5\n) — the second row of the matrix.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, print one integer — the maximum cost of a path you can obtain.\nExample\ninput\nCopy\n3\n1\n-10\n5\n3\n1 2 3\n10 -5 -3\n4\n2 8 5 3\n1 10 3 4\noutput\nCopy\n-5\n16\n29\nNote\nHere are the explanations of the first three test cases of the example. The left matrix is the matrix given in the input, the right one is the state of the matrix after several column swaps (possibly zero). The optimal path is highlighted in green.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ]
    },
    {
        "title": "M. Mirror Maze",
        "description": "You are given a grid of\nR\nrows (numbered from\n1\nto\nR\nfrom north to south) and\nC\ncolumns (numbered from\n1\nto\nC\nfrom west to east). Every cell in this grid is a square of the same size. The cell located at row\nr\nand column\nc\nis denoted as\n(r,c)\n. Each cell can either be empty or have a mirror in one of the cell's diagonals. Each mirror is represented by a line segment. The mirror is type\n1\nif it is positioned diagonally from the southwest corner to the northeast corner of the cell, or type\n2\nfor the other diagonal.\nThese mirrors follow the law of reflection, that is, the angle of reflection equals the angle of incidence. Formally, for type\n1\nmirror, if a beam of light comes from the north, south, west, or east of the cell, then it will be reflected to the west, east, north, and south of the cell, respectively. Similarly, for type\n2\nmirror, if a beam of light comes from the north, south, west, or east of the cell, then it will be reflected to the east, west, south, and north of the cell, respectively.\nYou want to put a laser from outside the grid such that all mirrors are hit by the laser beam. There are\n2⋅(R+C)\npossible locations to put the laser:\nfrom the north side of the grid at column\nc\n, for\n1≤c≤C\n, shooting a laser beam to the south;\nfrom the south side of the grid at column\nc\n, for\n1≤c≤C\n, shooting a laser beam to the north;\nfrom the east side of the grid at row\nr\n, for\n1≤r≤R\n, shooting a laser beam to the west; and\nfrom the west side of the grid at row\nr\n, for\n1≤r≤R\n, shooting a laser beam to the east.\nDetermine all possible locations for the laser such that all mirrors are hit by the laser beam.\nInput\nThe first line consists of two integers\nR\nC\n(\n1≤R,C≤200\n).\nEach of the next\nR\nlines consists of a string\nS\nr\nof length\nC\n. The\nc\n-th character of string\nS\nr\nrepresents cell\n(r,c)\n. Each character can either be . if the cell is empty, / if the cell has type\n1\nmirror, or \\ if the cell has type\n2\nmirror. There is at least one mirror in the grid.\nOutput\nOutput a single integer representing the number of possible locations for the laser such that all mirrors are hit by the laser beam. Denote this number as\nk\n.\nIf\nk>0\n, then output\nk\nspace-separated strings representing the location of the laser. Each string consists of a character followed without any space by an integer. The character represents the side of the grid, which could be N, S, E, or W if you put the laser on the north, south, east, or west side of the grid, respectively. The integer represents the row/column number. You can output the strings in any order.\nExamples\ninput\nCopy\n4 4\n.//.\n.\\\\.\n.\\/.\n....\noutput\nCopy\n2\nN3 W2\ninput\nCopy\n4 6\n./..\\.\n.\\...\\\n./../\\\n......\noutput\nCopy\n2\nE3 S2\ninput\nCopy\n4 4\n....\n./\\.\n.\\/.\n....\noutput\nCopy\n0\nNote\nExplanation for the sample input/output #1\nThe following illustration shows one of the solutions of this sample.\nExplanation for the sample input/output #2\nThe following illustration shows one of the solutions of this sample.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "graphs",
            "implementation",
            "*1800"
        ]
    },
    {
        "title": "L. Buggy DFS",
        "description": "You are currently studying a graph traversal algorithm called the Depth First Search (DFS). However, due to a bug, your algorithm is slightly different from the standard DFS. The following is an algorithm for your Buggy DFS (BDFS), assuming the graph has\nN\nnodes (numbered from\n1\nto\nN\n).\n\n  BDFS():\n    let S be an empty stack\n    let FLAG be a boolean array of size N which are all false initially\n    let counter be an integer initialized with 0\n\n    push 1 to S\n\n    while S is not empty:\n      pop the top element of S into u\n      FLAG[u] = true\n\n      for each v neighbour of u in ascending order:\n        counter = counter + 1\n        if FLAG[v] is false:\n          push v to S\n\n    return counter\nYou realized that the bug made the algorithm slower than standard DFS, which can be investigated by the return value of the function BDFS(). To investigate the behavior of this algorithm, you want to make some test cases by constructing an undirected simple graph such that the function BDFS() returns\nK\n, or determine if it is impossible to do so.\nInput\nA single line consisting of an integer\nK\n(\n1≤K≤\n10\n9\n).\nOutput\nIf it is impossible to construct an undirected simple graph such that the function BDFS() returns\nK\n, then output -1 -1 in a single line.\nOtherwise, output the graph in the following format. The first line consists of two integers\nN\nand\nM\n, representing the number of nodes and undirected edges in the graph, respectively. Each of the next\nM\nlines consists of two integers\nu\nand\nv\n, representing an undirected edge that connects node\nu\nand node\nv\n. You are allowed to output the edges in any order. This graph has to satisfy the following constraints:\n1≤N≤32768\n1≤M≤65536\n1≤u,v≤N\n, for all edges.\nThe graph is a simple graph, i.e. there are no multi-edges nor self-loops.\nNote that you are not required to minimize the number of nodes or edges. It can be proven that if constructing a graph in which the return value of BDFS() is\nK\nis possible, then there exists one that satisfies all the constraints above. If there are several solutions, you can output any of them.\nExamples\ninput\nCopy\n8\noutput\nCopy\n3 3\n1 2\n1 3\n2 3\ninput\nCopy\n1\noutput\nCopy\n-1 -1\ninput\nCopy\n23\noutput\nCopy\n5 7\n4 5\n2 3\n3 1\n2 4\n4 3\n2 1\n1 5\nNote\nExplanation for the sample input/output #1\nThe graph on the left describes the output of this sample. The graph on the right describes another valid solution for this sample.\nExplanation for the sample input/output #3\nThe following graph describes the output of this sample.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "*3000"
        ]
    },
    {
        "title": "K. GCDDCG",
        "description": "You are playing the Greatest Common Divisor Deck-Building Card Game (GCDDCG). There are\nN\ncards (numbered from\n1\nto\nN\n). Card\ni\nhas the value of\nA\ni\n, which is an integer between\n1\nand\nN\n(inclusive).\nThe game consists of\nN\nrounds (numbered from\n1\nto\nN\n). Within each round, you need to build two non-empty decks, deck\n1\nand deck\n2\n. A card cannot be inside both decks, and it is allowed to not use all\nN\ncards. In round\ni\n, the greatest common divisor (GCD) of the card values in each deck must equal\ni\n.\nYour creativity point during round\ni\nis the product of\ni\nand the number of ways to build two valid decks. Two ways are considered different if one of the decks contains different cards.\nFind the sum of creativity points across all\nN\nrounds. Since the sum can be very large, calculate the sum modulo\n998244353\n.\nInput\nThe first line consists of an integer\nN\n(\n2≤N≤200000)\n.\nThe second line consists of\nN\nintegers\nA\ni\n(\n1≤\nA\ni\n≤N\n).\nOutput\nOutput a single integer representing the sum of creativity points across all\nN\nrounds modulo\n998244353\n.\nExamples\ninput\nCopy\n3\n3 3 3\noutput\nCopy\n36\ninput\nCopy\n4\n2 2 4 4\noutput\nCopy\n44\ninput\nCopy\n9\n4 2 6 9 7 7 7 3 3\noutput\nCopy\n10858\nNote\nExplanation for the sample input/output #1\nThe creativity point during each of rounds\n1\nand\n2\nis\n0\n.\nDuring round\n3\n, there are\n12\nways to build both decks. Denote\nB\nand\nC\nas the set of card numbers within deck\n1\nand deck\n2\n, respectively. The\n12\nways to build both decks are:\nB={1},C={2}\n;\nB={1},C={3}\n;\nB={1},C={2,3}\n;\nB={2},C={1}\n;\nB={2},C={3}\n;\nB={2},C={1,3}\n;\nB={3},C={1}\n;\nB={3},C={2}\n;\nB={3},C={1,2}\n;\nB={1,2},C={3}\n;\nB={2,3},C={1}\n; and\nB={1,3},C={2}\n.\nExplanation for the sample input/output #2\nFor rounds\n1\n,\n2\n,\n3\nand\n4\n, there are\n0\n,\n18\n,\n0\n, and\n2\nways to build both decks, respectively.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "*2900"
        ]
    },
    {
        "title": "J. Xorderable Array",
        "description": "You are given an array\nA\nof\nN\nintegers:\n[\nA\n1\n,\nA\n2\n,…,\nA\nN\n]\n.\nThe array\nA\nis\n(p,q)\n-xorderable if it is possible to rearrange\nA\nsuch that for each pair\n(i,j)\nthat satisfies\n1≤i<j≤N\n, the following conditions must be satisfied after the rearrangement:\nA\ni\n⊕p≤\nA\nj\n⊕q\nand\nA\ni\n⊕q≤\nA\nj\n⊕p\n. The operator\n⊕\nrepresents the bitwise xor.\nYou are given another array\nX\nof length\nM\n:\n[\nX\n1\n,\nX\n2\n,…,\nX\nM\n]\n. Calculate the number of pairs\n(u,v)\nwhere array\nA\nis\n(\nX\nu\n,\nX\nv\n)\n-xorderable for\n1≤u<v≤M\n.\nInput\nThe first line consists of two integers\nN\nM\n(\n2≤N,M≤200000)\n.\nThe second line consists of\nN\nintegers\nA\ni\n(\n0≤\nA\ni\n<\n2\n30\n)\n.\nThe third line consists of\nM\nintegers\nX\nu\n(\n0≤\nX\nu\n<\n2\n30\n)\n.\nOutput\nOutput a single integer representing the number of pairs\n(u,v)\nwhere array\nA\nis\n(\nX\nu\n,\nX\nv\n)\n-xorderable for\n1≤u<v≤M\n.\nExamples\ninput\nCopy\n3 4\n0 3 0\n1 2 1 1\noutput\nCopy\n3\ninput\nCopy\n5 2\n0 7 13 22 24\n12 10\noutput\nCopy\n1\ninput\nCopy\n3 3\n0 0 0\n1 2 3\noutput\nCopy\n0\nNote\nExplanation for the sample input/output #1\nThe array\nA\nis\n(1,1)\n-xorderable by rearranging the array\nA\nto\n[0,0,3]\n.\nExplanation for the sample input/output #2\nThe array\nA\nis\n(12,10)\n-xorderable by rearranging the array\nA\nto\n[13,0,7,24,22]\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "data structures",
            "*2600"
        ]
    },
    {
        "title": "I. Microwavable Subsequence",
        "description": "You are given an array of\nN\nintegers:\n[\nA\n1\n,\nA\n2\n,…,\nA\nN\n]\n.\nA subsequence can be derived from an array by removing zero or more elements without changing the order of the remaining elements. For example,\n[2,1,2]\n,\n[3,3]\n,\n[1]\n, and\n[3,2,1,3,2]\nare subsequences of array\n[3,2,1,3,2]\n, while\n[1,2,3]\nis not a subsequence of array\n[3,2,1,3,2]\n.\nA subsequence is microwavable if the subsequence consists of at most two distinct values and each element differs from its adjacent elements. For example,\n[2,1,2]\n,\n[3,2,3,2]\n, and\n[1]\nare microwavable, while\n[3,3]\nand\n[3,2,1,3,2]\nare not microwavable.\nDenote a function\nf(x,y)\nas the length of the longest microwavable subsequence of array\nA\nsuch that each element within the subsequence is either\nx\nor\ny\n. Find the sum of\nf(x,y)\nfor all\n1≤x<y≤M\n.\nInput\nThe first line consists of two integers\nN\nM\n(\n1≤N,M≤300000\n).\nThe second line consists of\nN\nintegers\nA\ni\n(\n1≤\nA\ni\n≤M\n).\nOutput\nOutput a single integer representing the sum of\nf(x,y)\nfor all\n1≤x<y≤M\n.\nExamples\ninput\nCopy\n5 4\n3 2 1 3 2\noutput\nCopy\n13\ninput\nCopy\n3 3\n1 1 1\noutput\nCopy\n2\nNote\nExplanation for the sample input/output #1\nThe value of\nf(1,2)\nis\n3\n, taken from the subsequence\n[2,1,2]\nthat can be obtained by removing\nA\n1\nand\nA\n4\n. The value of\nf(1,3)\nis\n3\n, taken from the subsequence\n[3,1,3]\nthat can be obtained by removing\nA\n2\nand\nA\n5\n. The value of\nf(2,3)\nis\n4\n, taken from the subsequence\n[3,2,3,2]\nthat can be obtained by removing\nA\n3\n. The value of\nf(1,4)\n,\nf(2,4)\n, and\nf(3,4)\nare all\n1\n.\nExplanation for the sample input/output #2\nThe value of\nf(1,2)\nand\nf(1,3)\nare both\n1\n, while the value of\nf(2,3)\nis\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "*2100"
        ]
    },
    {
        "title": "H. Missing Separators",
        "description": "You have a dictionary, which is a list of distinct words sorted in alphabetical order. Each word consists of uppercase English letters.\nYou want to print this dictionary. However, there is a bug with the printing system, and all words in the list are printed next to each other without any separators between words. Now, you ended up with a string\nS\nthat is a concatenation of all the words in the dictionary in the listed order.\nYour task is to reconstruct the dictionary by splitting\nS\ninto one or more words. Note that the reconstructed dictionary must consist of distinct words sorted in alphabetical order. Furthermore, you want to maximize the number of words in the dictionary. If there are several possible dictionaries with the maximum number of words, you can choose any of them.\nInput\nA single line consisting of a string\nS\n(\n1≤|S|≤5000)\n. String\nS\nconsists of only uppercase English letters.\nOutput\nFirst, output an integer in a single line representing the maximum number of the words in the reconstructed dictionary. Denote this number as\nn\n.\nThen, output\nn\nlines, each containing a single string representing the word. The words must be distinct, and the list must be sorted alphabetically. The concatenation of the words in the listed order must equal\nS\n.\nIf there are several possible dictionaries with the maximum number of words, output any of them.\nExamples\ninput\nCopy\nABACUS\noutput\nCopy\n4\nA\nBA\nC\nUS\ninput\nCopy\nAAAAAA\noutput\nCopy\n3\nA\nAA\nAAA\ninput\nCopy\nEDCBA\noutput\nCopy\n1\nEDCBA",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "dp",
            "sortings",
            "string suffix structures",
            "strings",
            "*2200"
        ]
    },
    {
        "title": "G. X Aura",
        "description": "Mount ICPC can be represented as a grid of\nR\nrows (numbered from\n1\nto\nR\n) and\nC\ncolumns (numbered from\n1\nto\nC\n). The cell located at row\nr\nand column\nc\nis denoted as\n(r,c)\nand has a height of\nH\nr,c\n. Two cells are adjacent to each other if they share a side. Formally,\n(r,c)\nis adjacent to\n(r−1,c)\n,\n(r+1,c)\n,\n(r,c−1)\n, and\n(r,c+1)\n, if any exists.\nYou can move only between adjacent cells, and each move comes with a penalty. With an aura of an odd positive integer\nX\n, moving from a cell with height\nh\n1\nto a cell with height\nh\n2\ngives you a penalty of\n(\nh\n1\n−\nh\n2\n)\nX\n. Note that the penalty can be negative.\nYou want to answer\nQ\nindependent scenarios. In each scenario, you start at the starting cell\n(\nR\ns\n,\nC\ns\n)\nand you want to go to the destination cell\n(\nR\nf\n,\nC\nf\n)\nwith minimum total penalty. In some scenarios, the total penalty might become arbitrarily small; such a scenario is called invalid. Find the minimum total penalty to move from the starting cell to the destination cell, or determine if the scenario is invalid.\nInput\nThe first line consists of three integers\nR\nC\nX\n(\n1≤R,C≤1000;1≤X≤9;X\nis an odd integer).\nEach of the next\nR\nlines consists of a string\nH\nr\nof length\nC\n. Each character in\nH\nr\nis a number from 0 to 9. The\nc\n-th character of\nH\nr\nrepresents the height of cell\n(r,c)\n, or\nH\nr,c\n.\nThe next line consists of an integer\nQ\n(\n1≤Q≤100000)\n.\nEach of the next\nQ\nlines consists of four integers\nR\ns\nC\ns\nR\nf\nC\nf\n(\n1≤\nR\ns\n,\nR\nf\n≤R;1≤\nC\ns\n,\nC\nf\n≤C\n).\nOutput\nFor each scenario, output the following in a single line. If the scenario is invalid, output INVALID. Otherwise, output a single integer representing the minimum total penalty to move from the starting cell to the destination cell.\nExamples\ninput\nCopy\n3 4 1\n3359\n4294\n3681\n5\n1 1 3 4\n3 3 2 1\n2 2 1 4\n1 3 3 2\n1 1 1 1\noutput\nCopy\n2\n4\n-7\n-1\n0\ninput\nCopy\n2 4 5\n1908\n2023\n2\n1 1 2 4\n1 1 1 1\noutput\nCopy\nINVALID\nINVALID\ninput\nCopy\n3 3 9\n135\n357\n579\n2\n3 3 1 1\n2 2 2 2\noutput\nCopy\n2048\n0\nNote\nExplanation for the sample input/output #1\nFor the first scenario, one of the solutions is to move as follows:\n(1,1)→(2,1)→(3,1)→(3,2)→(3,3)→(3,4)\n. The total penalty of this solution is\n(3−4\n)\n1\n+(4−3\n)\n1\n+(3−6\n)\n1\n+(6−8\n)\n1\n+(8−1\n)\n1\n=2\n.\nExplanation for the sample input/output #2\nFor the first scenario, the cycle\n(1,1)→(2,1)→(2,2)→(1,2)→(1,1)\nhas a penalty of\n(1−2\n)\n5\n+(2−0\n)\n5\n+(0−9\n)\n5\n+(9−1\n)\n5\n=−26250\n. You can keep repeating this cycle to make your total penalty arbitrarily small. Similarly, for the second scenario, you can move to\n(1,1)\nfirst, then repeat the same cycle.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "graphs",
            "math",
            "shortest paths",
            "*2200"
        ]
    },
    {
        "title": "F. Grid Game 3-angle",
        "description": "Your friends, Anda and Kamu decide to play a game called Grid Game and ask you to become the gamemaster. As the gamemaster, you set up a triangular grid of size\nN\n. The grid has\nN\nrows (numbered from\n1\nto\nN\n). Row\nr\nhas\nr\ncells; the\nc\n-th cell of row\nr\nis denoted as\n(r,c)\n.\nBefore the game starts,\nM\ndifferent cells (numbered from\n1\nto\nM\n) are chosen: at cell\n(\nR\ni\n,\nC\ni\n)\n, you add\nA\ni\nstones on it. You then give Anda and Kamu an integer\nK\nand commence the game.\nAnda and Kamu will take turns alternately with Anda taking the first turn. A player on their turn will do the following.\nChoose a cell\n(r,c)\nwith at least one stone on it.\nRemove at least one but at most\nK\nstones from the chosen cell.\nFor each cell\n(x,y)\nsuch that\nr+1≤x≤min(N,r+K)\nand\nc≤y≤c+x−r\n, add zero or more stones but at most\nK\nstones to cell\n(x,y)\n.\nThe following illustrations show all the possible cells in which you can add stones for\nK=3\n. You choose the cell\n(2,1)\nfor the left illustration and the cell\n(4,3)\nfor the right illustration.\nA player who is unable to complete their turn (because there are no more stones on the grid) will lose the game, and the opposing player wins. Determine who will win the game if both players play optimally.\nInput\nThis problem is a multi-case problem. The first line consists of an integer\nT\n(\n1≤T≤100\n) that represents the number of test cases.\nEach test case starts with a single line consisting of three integers\nN\nM\nK\n(\n1≤N≤\n10\n9\n;1≤M,K≤200000\n). Then, each of the next\nM\nlines consists of three integers\nR\ni\nC\ni\nA\ni\n(\n1≤\nC\ni\n≤\nR\ni\n≤N;1≤\nA\n1\n≤\n10\n9\n). The pairs\n(\nR\ni\n,\nC\ni\n)\nare distinct.\nThe sum of\nM\nacross all test cases does not exceed\n200000\n.\nOutput\nFor each case, output a string in a single line representing the player who will win the game if both players play optimally. Output Anda if Anda, the first player, wins. Otherwise, output Kamu.\nExample\ninput\nCopy\n3\n2 2 4\n1 1 3\n2 1 2\n100 2 1\n4 1 10\n4 4 10\n10 5 2\n1 1 4\n3 1 2\n4 2 5\n2 2 1\n5 3 4\noutput\nCopy\nAnda\nKamu\nAnda\nNote\nExplanation for the sample input/output #1\nFor the first case, during the first turn, Anda will remove all the stones from cell\n(1,1)\nand then add three stones at\n(2,1)\n. The only cell with stones left is now cell\n(2,1)\nwith five stones, so Kamu must remove stones from that cell. No matter how many stones are removed by Kamu, Anda can remove all the remaining stones at\n(2,1)\nand win the game.\nFor the second case, Kamu can always mirror whatever move made by Anda until Anda can no longer complete their turn.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "games",
            "math",
            "*3000"
        ]
    },
    {
        "title": "E. Narrower Passageway",
        "description": "You are a strategist of The ICPC Kingdom. You received an intel that there will be monster attacks on a narrow passageway near the kingdom. The narrow passageway can be represented as a grid with\n2\nrows (numbered from\n1\nto\n2\n) and\nN\ncolumns (numbered from\n1\nto\nN\n). Denote\n(r,c)\nas the cell in row\nr\nand column\nc\n. A soldier with a power of\nP\nr,c\nis assigned to protect\n(r,c)\nevery single day.\nIt is known that the passageway is very foggy. Within a day, each column in the passageway has a\n50%\nchance of being covered in fog. If a column is covered in fog, the two soldiers assigned to that column are not deployed that day. Otherwise, the assigned soldiers will be deployed.\nDefine a connected area\n[u,v]\n(\nu≤v\n) as a maximal set of consecutive columns from\nu\nto\nv\n(inclusive) such that each column in the set is not covered in fog. The following illustration is an example of connected areas. The grayed cells are cells covered in fog. There are\n4\nconnected areas:\n[1,2]\n,\n[4,6]\n,\n[9,9]\n, and\n[11,11]\n.\nThe strength of a connected area\n[u,v]\ncan be calculated as follows. Let\nm\n1\nand\nm\n2\nbe the maximum power of the soldiers in the first and second rows of the connected area, respectively. Formally,\nm\nr\n=max(\nP\nr,u\n,\nP\nr,u+1\n,…,\nP\nr,v\n)\nfor\nr∈{1,2}\n. If\nm\n1\n=\nm\n2\n, then the strength is\n0\n. Otherwise, the strength is\nmin(\nm\n1\n,\nm\n2\n)\n.\nThe total strength of the deployment is the sum of the strengths for all connected areas. Determine the expected total strength of the deployment on any single day.\nInput\nThe first line consists of an integer\nN\n(\n1≤N≤100000\n).\nEach of the next two lines consists of\nN\nintegers\nP\nr,c\n(\n1≤\nP\nr,c\n≤200000\n).\nOutput\nLet\nM=998244353\n. It can be shown that the expected total strength can be expressed as an irreducible fraction\nx\ny\nsuch that\nx\nand\ny\nare integers and\ny≢0(modM)\n. Output an integer\nk\nin a single line such that\n0≤k<M\nand\nk⋅y≡x(modM)\n.\nExamples\ninput\nCopy\n3\n8 4 5\n5 4 8\noutput\nCopy\n249561092\ninput\nCopy\n5\n10 20 5 8 5\n5 20 7 5 8\noutput\nCopy\n811073541\nNote\nExplanation for the sample input/output #1\nThere are\n8\npossible scenarios for the passageway.\nEach scenario is equally likely to happen. Therefore, the expected total strength is\n(0+5+10+5+5+0+5+0)/8=\n15\n4\n. Since\n249561092⋅4≡15(mod998244353)\n, the output of this sample is\n249561092\n.\nExplanation for the sample input/output #2\nThe expected total strength is\n67\n16\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "*2700"
        ]
    },
    {
        "title": "D. Aquatic Dragon",
        "description": "You live in an archipelago consisting of\nN\nislands (numbered from\n1\nto\nN\n) laid out in a single line. Island\ni\nis adjacent to island\ni+1\n, for\n1≤i<N\n. Between adjacent islands\ni\nand\ni+1\n, there is a pair of one-directional underwater tunnels: one that allows you to walk from island\ni\nto island\ni+1\nand one for the opposite direction. Each tunnel can only be traversed at most once.\nYou also have a dragon with you. It has a stamina represented by a non-negative integer. The stamina is required for the dragon to perform its abilities: swim and fly. Initially, its stamina is\n0\n.\nYour dragon's stamina can be increased as follows. There is a magical shrine on each island\ni\nthat will immediately increase your dragon's stamina by\nP\ni\n(regardless the position of the dragon) when you visit island\ni\nfor the first time. This event takes no time.\nWhen you are on an island, there are\n3\nmoves that you can perform.\nSwim with your dragon to an adjacent island if your dragon and you are on the same island. You can perform if your dragon's stamina is at least\nD\n. This move reduces your dragon's stamina by\nD\n, and it takes\nT\ns\nseconds to perform.\nFly with your dragon to an adjacent island if your dragon and you are on the same island. You can perform this move if your dragon's stamina is not\n0\n. This move sets your dragon's stamina to\n0\n, and it takes\nT\nf\nseconds to perform.\nWalk alone without your dragon to an adjacent island through the underwater tunnel. This move takes\nT\nw\nseconds to perform. Once you walk through this tunnel, it cannot be used again.\nNote that both swimming and flying do not use tunnels.\nYour dragon and you are currently on island\n1\n. Your mission is to go to island\nN\nwith your dragon. Determine the minimum possible time to complete your mission.\nInput\nThe first line consists of five integers\nN\nD\nT\ns\nT\nf\nT\nw\n(\n2≤N≤200000;1≤D,\nT\ns\n,\nT\nf\n,\nT\nw\n≤200000\n).\nThe second line consists of\nN\nintegers\nP\ni\n(\n1≤\nP\ni\n≤200000)\n.\nOutput\nOutput an integer in a single line representing the minimum possible time to go to island\nN\nwith your dragon.\nExamples\ninput\nCopy\n5 4 2 9 1\n1 2 4 2 1\noutput\nCopy\n28\ninput\nCopy\n5 4 2 1 1\n1 2 4 2 1\noutput\nCopy\n4\ninput\nCopy\n3 4 2 10 1\n3 1 2\noutput\nCopy\n16\nNote\nExplanation for the sample input/output #1\nThe following sequence of events will complete your mission in the minimum time.\nThe shrine on island\n1\nincreases your dragon's stamina to\n1\n.\nFly with your dragon to island\n2\n. The shrine on island\n2\nincreases your dragon's stamina to\n2\n.\nWalk alone to island\n3\n. The shrine on island\n3\nincreases your dragon's stamina to\n6\n.\nWalk alone to island\n4\n. The shrine on island\n4\nincreases your dragon's stamina to\n8\n.\nWalk alone to island\n3\n.\nWalk alone to island\n2\n.\nSwim with your dragon to island\n3\n. Your dragon's stamina is now\n4\n.\nSwim with your dragon to island\n4\n. Your dragon's stamina is now\n0\n.\nWalk alone to island\n5\n. The shrine on island\n5\nincreases your dragon's stamina to\n1\n.\nWalk alone to island\n4\n.\nFly with your dragon to island\n5\n.\nExplanation for the sample input/output #2\nRepeat the following process for\n1≤i<5\n: The shrine on island\ni\nincreases your dragon's stamina, then use the stamina to fly with your dragon to island\ni+1\n.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "*3500"
        ]
    },
    {
        "title": "C. Saraga",
        "description": "The word saraga is an abbreviation of sarana olahraga, an Indonesian term for a sports facility. It is created by taking the prefix sara of the word sarana and the suffix ga of the word olahraga. Interestingly, it can also be created by the prefix sa of the word sarana and the suffix raga of the word olahraga.\nAn abbreviation of two strings\nS\nand\nT\nis interesting if there are at least two different ways to split the abbreviation into two non-empty substrings such that the first substring is a prefix of\nS\nand the second substring is a suffix of\nT\n.\nYou are given two strings\nS\nand\nT\n. You want to create an interesting abbreviation of strings\nS\nand\nT\nwith minimum length, or determine if it is impossible to create an interesting abbreviation.\nInput\nThe first line consists of a string\nS\n(\n1≤|S|≤200000\n).\nThe second line consists of a string\nT\n(\n1≤|T|≤200000\n).\nBoth strings\nS\nand\nT\nonly consist of lowercase English letters.\nOutput\nIf it is impossible to create an interesting abbreviation, output -1.\nOtherwise, output a string in a single line representing an interesting abbreviation of strings\nS\nand\nT\nwith minimum length. If there are multiple solutions, output any of them.\nExamples\ninput\nCopy\nsarana\nolahraga\noutput\nCopy\nsaga\ninput\nCopy\nberhiber\nwortelhijau\noutput\nCopy\nberhijau\ninput\nCopy\nicpc\nicpc\noutput\nCopy\nicpc\ninput\nCopy\nicpc\njakarta\noutput\nCopy\n-1\nNote\nExplanation for the sample input/output #1\nYou can split saga into s and aga, or sa and ga. The abbreviation saraga is interesting, but saga has a smaller length.\nExplanation for the sample input/output #2\nThe abbreviation belhijau is also interesting with minimum length, so it is another valid solution.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1400"
        ]
    },
    {
        "title": "B. ICPC Square",
        "description": "ICPC Square is a hotel provided by the ICPC Committee for the accommodation of the participants. It consists of\nN\nfloors (numbered from\n1\nto\nN\n). This hotel has a very unique elevator. If a person is currently at floor\nx\n, by riding the elevator once, they can go to floor\ny\nif and only if\ny\nis a multiple of\nx\nand\ny−x≤D\n.\nYou are currently at floor\nS\n. You want to go to the highest possible floor by riding the elevator zero or more times. Determine the highest floor you can reach.\nInput\nA single line consisting of three integers\nN\nD\nS\n(\n2≤N≤\n10\n12\n;1≤D≤N−1;1≤S≤N\n).\nOutput\nOutput a single integer representing the highest floor you can reach by riding the elevator zero or more times.\nExamples\ninput\nCopy\n64 35 3\noutput\nCopy\n60\ninput\nCopy\n2024 2023 1273\noutput\nCopy\n1273\nNote\nExplanation for the sample input/output #1\nFirst, ride the elevator from floor\n3\nto floor\n15\n. This is possible because\n15\nis a multiple of\n3\nand\n15−3≤35\n. Then, ride the elevator from floor\n15\nto floor\n30\n. This is possible because\n30\nis a multiple of\n15\nand\n30−15≤35\n. Finally, ride the elevator from floor\n30\nto floor\n60\n. This is possible because\n60\nis a multiple of\n30\nand\n60−30≤35\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "math",
            "number theory",
            "*2000"
        ]
    },
    {
        "title": "A. Scrambled Scrabble",
        "description": "You are playing a word game using a standard set of\n26\nuppercase English letters: A — Z. In this game, you can form vowels and consonants as follows.\nThe letters A, E, I, O, and U can only form a vowel.\nThe letter Y can form either a vowel or a consonant.\nEach of the remaining letters other than A, E, I, O, U, and Y can only form a consonant.\nThe string NG can form a single consonant when concatenated together.\nDenote a syllable as a concatenation of a consonant, a vowel, and a consonant in that order. A word is a concatenation of one or more syllables.\nYou are given a string\nS\nand you want to create a word from it. You are allowed to delete zero or more letters from\nS\nand rearrange the remaining letters to form the word. Find the length of the longest word that can be created, or determine if no words can be created.\nInput\nA single line consisting of a string\nS\n(\n1≤|S|≤5000\n). The string\nS\nconsists of only uppercase English letters.\nOutput\nIf a word cannot be created, output 0. Otherwise, output a single integer representing the length of longest word that can be created.\nExamples\ninput\nCopy\nICPCJAKARTA\noutput\nCopy\n9\ninput\nCopy\nNGENG\noutput\nCopy\n5\ninput\nCopy\nYYY\noutput\nCopy\n3\ninput\nCopy\nDANGAN\noutput\nCopy\n6\ninput\nCopy\nAEIOUY\noutput\nCopy\n0\nNote\nExplanation for the sample input/output #1\nA possible longest word is JAKCARTAP, consisting of the syllables JAK, CAR, and TAP.\nExplanation for the sample input/output #2\nThe whole string\nS\nis a word consisting of one syllable which is the concatenation of the consonant NG, the vowel E, and the consonant NG.\nExplanation for the sample input/output #3\nThe whole string\nS\nis a word consisting of one syllable which is the concatenation of the consonant Y, the vowel Y, and the consonant Y.\nExplanation for the sample input/output #4\nThe whole string\nS\nis a word consisting of two syllables: DAN and GAN.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1700"
        ]
    },
    {
        "title": "H. Hard Demon Problem",
        "description": "Swing is opening a pancake factory! A good pancake factory must be good at flattening things, so Swing is going to test his new equipment on 2D matrices.\nSwing is given an\nn×n\nmatrix\nM\ncontaining positive integers. He has\nq\nqueries to ask you.\nFor each query, he gives you four integers\nx\n1\n,\ny\n1\n,\nx\n2\n,\ny\n2\nand asks you to flatten the submatrix bounded by\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\ninto an array\nA\n. Formally,\nA=[\nM\n(x1,y1)\n,\nM\n(x1,y1+1)\n,…,\nM\n(x1,y2)\n,\nM\n(x1+1,y1)\n,\nM\n(x1+1,y1+1)\n,…,\nM\n(x2,y2)\n]\n.\nThe following image depicts the flattening of a submatrix bounded by the red dotted lines. The orange arrows denote the direction that the elements of the submatrix are appended to the back of\nA\n, and\nA\nis shown at the bottom of the image.\nAfterwards, he asks you for the value of\n∑\n|A|\ni=1\nA\ni\n⋅i\n(sum of\nA\ni\n⋅i\nover all\ni\n).\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test contains two integers\nn\nand\nq\n(\n1≤n≤2000,1≤q≤\n10\n6\n) — the length of\nM\nand the number of queries.\nThe following\nn\nlines contain\nn\nintegers each, the\ni\n'th of which contains\nM\n(i,1)\n,\nM\n(i,2)\n,…,\nM\n(i,n)\n(\n1≤\nM\n(i,j)\n≤\n10\n6\n).\nThe following\nq\nlines contain four integers\nx\n1\n,\ny\n1\n,\nx\n2\n, and\ny\n2\n(\n1≤\nx\n1\n≤\nx\n2\n≤n,1≤\ny\n1\n≤\ny\n2\n≤n\n) — the bounds of the query.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\nand the sum of\nq\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output the results of the\nq\nqueries on a new line.\nExample\ninput\nCopy\n2\n4 3\n1 5 2 4\n4 9 5 3\n4 5 2 3\n1 5 5 2\n1 1 4 4\n2 2 3 3\n1 2 4 3\n3 3\n1 2 3\n4 5 6\n7 8 9\n1 1 1 3\n1 3 3 3\n2 2 2 2\noutput\nCopy\n500 42 168 \n14 42 5 \nNote\nIn the second query of the first test case,\nA=[9,5,5,2]\n. Therefore, the sum is\n1⋅9+2⋅5+3⋅5+4⋅2=42\n.",
        "time_limit": "3.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dp",
            "implementation",
            "math",
            "*2100"
        ]
    },
    {
        "title": "G2. Medium Demon Problem (hard version)",
        "description": "This is the hard version of the problem. The key difference between the two versions is highlighted in bold.\nA group of\nn\nspiders has come together to exchange plushies. Initially, each spider has\n1\nplushie. Every year, if spider\ni\nhas at least one plushie, he will give exactly one plushie to spider\nr\ni\n. Otherwise, he will do nothing. Note that all plushie transfers happen at the same time. In this version, each spider is allowed to have more than 1 plushie at any point in time.\nThe process is stable in the current year if each spider has the same number of plushies (before the current year's exchange) as he did the previous year (before the previous year's exchange). Note that year\n1\ncan never be stable.\nFind the first year in which the process becomes stable.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of spiders.\nThe following line contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\n1≤\nr\ni\n≤n,\nr\ni\n≠i\n) — the recipient of the plushie of each spider.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer on a new line, the first year in which the process becomes stable.\nExample\ninput\nCopy\n5\n2\n2 1\n5\n2 3 4 5 1\n5\n2 1 4 2 3\n5\n4 1 1 5 4\n10\n4 3 9 1 6 7 9 10 10 3\noutput\nCopy\n2\n2\n5\n5\n5\nNote\nFor the second test case:\nAt year\n1\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Then, year\n1\n's exchange happens.\nAt year\n2\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Since this array is the same as the previous year, this year is stable.\nFor the third test case:\nAt year\n1\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Then, year\n1\n's exchange happens.\nAt year\n2\n, the following array shows the number of plushies each spider has:\n[1,2,1,1,0]\n. Then, year\n2\n's exchange happens.\nAt year\n3\n, the following array shows the number of plushies each spider has:\n[1,3,0,1,0]\n. Then, year\n3\n's exchange happens.\nAt year\n4\n, the following array shows the number of plushies each spider has:\n[1,4,0,0,0]\n. Then, year\n4\n's exchange happens.\nAt year\n5\n, the following array shows the number of plushies each spider has:\n[1,4,0,0,0]\n. Since this array is the same as the previous year, this year is stable.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "dsu",
            "graphs",
            "implementation",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "G1. Medium Demon Problem (easy version)",
        "description": "This is the easy version of the problem. The key difference between the two versions is highlighted in bold.\nA group of\nn\nspiders has come together to exchange plushies. Initially, each spider has\n1\nplushie. Every year, if spider\ni\nhas at least one plushie, he will give exactly one plushie to spider\nr\ni\n. Otherwise, he will do nothing. Note that all plushie transfers happen at the same time. In this version, if any spider has more than\n1\nplushie at any point in time, they will throw all but\n1\naway.\nThe process is stable in the current year if each spider has the same number of plushies (before the current year's exchange) as he did the previous year (before the previous year's exchange). Note that year\n1\ncan never be stable.\nFind the first year in which the process becomes stable.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of spiders.\nThe following line contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\n1≤\nr\ni\n≤n,\nr\ni\n≠i\n) — the recipient of the plushie of each spider.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer on a new line, the first year in which the process becomes stable.\nExample\ninput\nCopy\n5\n2\n2 1\n5\n2 3 4 5 1\n5\n2 1 4 2 3\n5\n4 1 1 5 4\n10\n4 3 9 1 6 7 9 10 10 3\noutput\nCopy\n2\n2\n5\n4\n5\nNote\nFor the second test case:\nAt year\n1\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Then, year\n1\n's exchange happens.\nAt year\n2\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Since this array is the same as the previous year, this year is stable.\nFor the third test case:\nAt year\n1\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,1]\n. Then, year\n1\n's exchange happens.\nAt year\n2\n, the following array shows the number of plushies each spider has:\n[1,1,1,1,0]\n. Then, year\n2\n's exchange happens. Note that even though two spiders gave spider\n2\nplushies, spider\n2\nmay only keep one plushie.\nAt year\n3\n, the following array shows the number of plushies each spider has:\n[1,1,0,1,0]\n. Then, year\n3\n's exchange happens.\nAt year\n4\n, the following array shows the number of plushies each spider has:\n[1,1,0,0,0]\n. Then, year\n4\n's exchange happens.\nAt year\n5\n, the following array shows the number of plushies each spider has:\n[1,1,0,0,0]\n. Since this array is the same as the previous year, this year is stable.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "graph matchings",
            "graphs",
            "implementation",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "F. Easy Demon Problem",
        "description": "For an arbitrary grid, Robot defines its beauty to be the sum of elements in the grid.\nRobot gives you an array\na\nof length\nn\nand an array\nb\nof length\nm\n. You construct a\nn\nby\nm\ngrid\nM\nsuch that\nM\ni,j\n=\na\ni\n⋅\nb\nj\nfor all\n1≤i≤n\nand\n1≤j≤m\n.\nThen, Robot gives you\nq\nqueries, each consisting of a single integer\nx\n. For each query, determine whether or not it is possible to perform the following operation exactly once so that\nM\nhas a beauty of\nx\n:\nChoose integers\nr\nand\nc\nsuch that\n1≤r≤n\nand\n1≤c≤m\nSet\nM\ni,j\nto be\n0\nfor all ordered pairs\n(i,j)\nsuch that\ni=r\n,\nj=c\n, or both.\nNote that queries are not persistent, meaning that you do not actually set any elements to\n0\nin the process — you are only required to output if it is possible to find\nr\nand\nc\nsuch that if the above operation is performed, the beauty of the grid will be\nx\n. Also, note that you must perform the operation for each query, even if the beauty of the original grid is already\nx\n.\nInput\nThe first line contains three integers\nn\n,\nm\n, and\nq\n(\n1≤n,m≤2⋅\n10\n5\n,1≤q≤5⋅\n10\n4\n) — the length of\na\n, the length of\nb\n, and the number of queries respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤|\na\ni\n|≤n\n).\nThe third line contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n0≤|\nb\ni\n|≤m\n).\nThe following\nq\nlines each contain a single integer\nx\n(\n1≤|x|≤2⋅\n10\n5\n), the beauty of the grid you wish to achieve by setting all elements in a row and a column to\n0\n.\nOutput\nFor each testcase, output \"YES\" (without quotes) if there is a way to perform the aforementioned operation such that the beauty is\nx\n, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nExamples\ninput\nCopy\n3 3 6\n-2 3 -3\n-2 2 -1\n-1\n1\n-2\n2\n-3\n3\noutput\nCopy\nNO\nYES\nNO\nNO\nYES\nNO\ninput\nCopy\n5 5 6\n1 -2 3 0 0\n0 -2 5 0 -3\n4\n-3\n5\n2\n-1\n2\noutput\nCopy\nYES\nYES\nYES\nYES\nNO\nYES\nNote\nIn the second example, the grid is\n0 -2 5 0 -3\n0 4 -10 0 6\n0 -6 15 0 -9\n0 0 0 0 0\n0 0 0 0 0\nBy performing the operation with\nr=4\nand\nc=2\n, we create the following grid:\n0 0 5 0 -3\n0 0 -10 0 6\n0 0 15 0 -9\n0 0 0 0 0\n0 0 0 0 0\nwhich has beauty\n4\n. Thus, we output YES.\nIn the second query, selecting\nr=3\nand\nc=5\ncreates a grid with beauty\n−3\n.\nIn the third query, selecting\nr=3\nand\nc=3\ncreates a grid with beauty\n5\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "math",
            "number theory",
            "*1900"
        ]
    },
    {
        "title": "E. Insane Problem",
        "description": "Wave is given five integers\nk\n,\nl\n1\n,\nr\n1\n,\nl\n2\n, and\nr\n2\n. Wave wants you to help her count the number of ordered pairs\n(x,y)\nsuch that all of the following are satisfied:\nl\n1\n≤x≤\nr\n1\n.\nl\n2\n≤y≤\nr\n2\n.\nThere exists a non-negative integer\nn\nsuch that\ny\nx\n=\nk\nn\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains five integers\nk\n,\nl\n1\n,\nr\n1\n,\nl\n2\n, and\nr\n2\n(\n2≤k≤\n10\n9\n,1≤\nl\n1\n≤\nr\n1\n≤\n10\n9\n,1≤\nl\n2\n≤\nr\n2\n≤\n10\n9\n).\nOutput\nFor each test case, output the number of matching ordered pairs\n(x,y)\non a new line.\nExample\ninput\nCopy\n5\n2 2 6 2 12\n2 1 1000000000 1 1000000000\n3 5 7 15 63\n1000000000 1 5 6 1000000000\n15 17 78 2596 20914861\noutput\nCopy\n12\n1999999987\n6\n1\n197\nNote\nIn the third test case, the matching ordered pairs are the following:\n(5,15)\n(5,45)\n(6,18)\n(6,54)\n(7,21)\n(7,63)\nIn the fourth test case, the only valid ordered pair is\n(1,1000000000)",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*1300"
        ]
    },
    {
        "title": "D. Harder Problem",
        "description": "Given a sequence of positive integers, a positive integer is called a mode of the sequence if it occurs the maximum number of times that any positive integer occurs. For example, the mode of\n[2,2,3]\nis\n2\n. Any of\n9\n,\n8\n, or\n7\ncan be considered to be a mode of the sequence\n[9,9,8,8,7,7]\n.\nYou gave UFO an array\na\nof length\nn\n. To thank you, UFO decides to construct another array\nb\nof length\nn\nsuch that\na\ni\nis a mode of the sequence\n[\nb\n1\n,\nb\n2\n,…,\nb\ni\n]\nfor all\n1≤i≤n\n.\nHowever, UFO doesn't know how to construct array\nb\n, so you must help her. Note that\n1≤\nb\ni\n≤n\nmust hold for your array for all\n1≤i≤n\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of\na\n.\nThe following line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nnumbers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n) on a new line. It can be shown that\nb\ncan always be constructed. If there are multiple possible arrays, you may print any.\nExample\ninput\nCopy\n4\n2\n1 2\n4\n1 1 1 2\n8\n4 5 5 5 1 1 2 1\n10\n1 1 2 2 1 1 3 3 1 1\noutput\nCopy\n1 2\n1 1 2 2\n4 5 5 1 1 2 2 3\n1 8 2 2 1 3 3 9 1 1\nNote\nLet's verify the correctness for our sample output in test case\n2\n.\nAt\ni=1\n,\n1\nis the only possible mode of\n[1]\n.\nAt\ni=2\n,\n1\nis the only possible mode of\n[1,1]\n.\nAt\ni=3\n,\n1\nis the only possible mode of\n[1,1,2]\n.\nAt\ni=4\n,\n1\nor\n2\nare both modes of\n[1,1,2,2]\n. Since\na\ni\n=2\n, this array is valid.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "C. Hard Problem",
        "description": "Ball is the teacher in Paperfold University. The seats of his classroom are arranged in\n2\nrows with\nm\nseats each.\nBall is teaching\na+b+c\nmonkeys, and he wants to assign as many monkeys to a seat as possible. Ball knows that\na\nof them only want to sit in row\n1\n,\nb\nof them only want to sit in row\n2\n, and\nc\nof them have no preference. Only one monkey may sit in each seat, and each monkey's preference must be followed if it is seated.\nWhat is the maximum number of monkeys that Ball can seat?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains four integers\nm\n,\na\n,\nb\n, and\nc\n(\n1≤m,a,b,c≤\n10\n8\n).\nOutput\nFor each test case, output the maximum number of monkeys you can seat.\nExample\ninput\nCopy\n5\n10 5 5 10\n3 6 1 1\n15 14 12 4\n1 1 1 1\n420 6 9 69\noutput\nCopy\n20\n5\n30\n2\n84\nNote\nIn the second test case,\n6\nmonkeys want to sit in the front row, but only\n3\nseats are available. The monkeys that have no preference and the monkeys who prefer sitting in the second row can sit in the second row together. Thus, the answer is\n3+2=5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "B. Normal Problem",
        "description": "A string consisting of only characters 'p', 'q', and 'w' is painted on a glass window of a store. Ship walks past the store, standing directly in front of the glass window, and observes string\na\n. Ship then heads inside the store, looks directly at the same glass window, and observes string\nb\n.\nShip gives you string\na\n. Your job is to find and output\nb\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe only line of each test case contains a string\na\n(\n1≤|a|≤100\n) — the string Ship observes from outside the store. It is guaranteed that\na\nonly contains characters 'p', 'q', and 'w'.\nOutput\nFor each test case, output string\nb\n, the string Ship observes from inside the store, on a new line.\nExample\ninput\nCopy\n5\nqwq\nppppp\npppwwwqqq\nwqpqwpqwwqp\npqpqpqpq\noutput\nCopy\npwp\nqqqqq\npppwwwqqq\nqpwwpqwpqpw\npqpqpqpq",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "A. Easy Problem",
        "description": "Cube is given an integer\nn\n. She wants to know how many ordered pairs of positive integers\n(a,b)\nthere are such that\na=n−b\n. Since Cube is not very good at math, please help her!\nInput\nThe first line contains an integer\nt\n(\n1≤t≤99\n) — the number of test cases.\nThe only line of each test case contains an integer\nn\n(\n2≤n≤100\n).\nOutput\nFor each test case, output the number of ordered pairs\n(a,b)\non a new line.\nExample\ninput\nCopy\n3\n2\n4\n6\noutput\nCopy\n1\n3\n5\nNote\nIn the first test case, the only ordered pair that works is\n(a,b)=(1,1)\n.\nIn the second test case, the three ordered pairs of\n(a,b)\nthat work are\n(3,1),(2,2),(1,3)\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Problem with Queries",
        "description": "You are given an array\na\n, consisting of\nn\nintegers. Your task is to process\nq\nqueries of two types:\n1 p x\n — set the value of the element at index\np\nequal to\nx\n;\n2 l r\n — count the number of pairs of indices\n(i,j)\nsuch that\nl≤i<j≤r\nand\nai≠aj\n.\nNote that the queries in this task are encoded; each subsequent query can only be decoded after calculating the answer to the preceding query of the second type.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤105\n).\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤n\n).\nThe third line contains a single integer\nq\n(\n1≤q≤3⋅105\n) — the number of queries.\nThe next\nq\nlines describe the queries in one of the following formats:\n1 p′ x′\n(\n0≤p′,x′≤n−1\n);\n2 l′ r′\n(\n0≤l′,r′≤n−1\n).\nThe queries are encoded as follows: let\nlast\nbe the answer to the latest processed query of the second type (initially,\nlast=0\n).\nif the type of the query is\n1\n, then\np=((p′+last)modn)+1\n,\nx=((x′+last)modn)+1\n.\nif the type of the query is\n2\n,\nl=((l′+last)modn)+1\n,\nr=((r′+last)modn)+1\n. If\nl>r\n, swap their values.\nDon't forget to update the value of\nlast\nafter answering each query of the second type.\nAdditional constraint on the input: there is at least one query of the second type.\nOutput\nFor each query of the second type, print the answer — the number of pairs of indices\n(i,j)\nsuch that\nl≤i<j≤r\nand\nai≠aj\n.\nExamples\ninput\nCopy\n3\n1 2 3\n5\n2 0 2\n1 0 2\n2 0 2\n1 2 0\n2 1 0\noutput\nCopy\n3 2 0 \ninput\nCopy\n7\n1 3 4 4 7 1 3\n3\n2 1 6\n2 1 0\n2 5 6\noutput\nCopy\n13 18 0 \nNote\nIn the first example, the actual queries (after decoding) are:\n2 1 3\n1 1 3\n2 1 3\n1 2 3\n2 1 3",
        "time_limit": "8 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation"
        ]
    },
    {
        "title": "F. Nim",
        "description": "Recall the rules of the game \"Nim\". There are\nn\npiles of stones, where the\ni\n-th pile initially contains some number of stones. Two players take turns choosing a non-empty pile and removing any positive (strictly greater than\n0\n) number of stones from it. The player unable to make a move loses the game.\nYou are given an array\na\n, consisting of\nn\nintegers. Artem and Ruslan decided to play Nim on segments of this array. Each of the\nq\nrounds is defined by a segment\n(\nl\ni\n,\nr\ni\n)\n, where the elements\na\nl\ni\n,\na\nl\ni\n+1\n,…,\na\nr\ni\nrepresent the sizes of the piles of stones.\nBefore the game starts, Ruslan can remove any number of piles from the chosen segment. However, at least one pile must remain, so in a single round he can remove at most\n(\nr\ni\n−\nl\ni\n)\npiles. He is allowed to remove\n0\npiles. After the removal, the game is played on the remaining piles within the segment.\nAll rounds are independent: the changes made in one round do not affect the original array or any other rounds.\nRuslan wants to remove as many piles as possible so that Artem, who always makes the first move, loses.\nFor each round, determine:\nthe maximum number of piles Ruslan can remove;\nthe number of ways to choose the maximum number of piles for removal.\nTwo ways are considered different if there exists an index\ni\nsuch that the pile at index\ni\nis removed in one way but not in the other. Since the number of ways can be large, output it modulo\n998244353\n.\nIf Ruslan cannot ensure Artem's loss in a particular round, output -1 for that round.\nInput\nThe first line of input contains two integers\nn\nand\nq\n(\n1≤n,q≤\n10\n5\n) — the size of the array and the number of segments for which the answers need to be calculated.\nThe second line of input contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤50\n) — the elements of the initial array.\nThe\ni\n-th of the next\nq\nlines contains two integers\nl\ni\n,\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the bounds of the segment on which the boys want to play the game during the\ni\n-th round.\nOutput\nFor each round:\nif Ruslan can win, print two integers — the maximum number of piles that can be removed, and the number of ways to remove the maximum number of piles, taken modulo\n998244353\n;\notherwise print -1.\nExample\ninput\nCopy\n9 5\n0 1 2 1 3 4 5 6 0\n1 5\n2 5\n3 5\n4 5\n1 9\noutput\nCopy\n4 1\n2 1\n0 1\n-1\n8 2",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "dp",
            "games",
            "greedy",
            "implementation",
            "shortest paths"
        ]
    },
    {
        "title": "E. Matrix Transformation",
        "description": "You are given two matrices\nA\nand\nB\nof size\nn×m\n, filled with integers between\n0\nand\n10\n9\n. You can perform the following operations on matrix\nA\nin any order and any number of times:\n&=: choose two integers\ni\nand\nx\n(\n1≤i≤n\n,\nx≥0\n) and replace each element in row\ni\nwith the result of the bitwise AND operation between\nx\nand that element. Formally, for every\nj∈[1,m]\n, the element\nA\ni,j\nis replaced with\nA\ni,j\n & x\n;\n|=: choose two integers\nj\nand\nx\n(\n1≤j≤m\n,\nx≥0\n) and replace each element in column\nj\nwith the result of the bitwise OR operation between\nx\nand that element. Formally, for every\ni∈[1,n]\n, the element\nA\ni,j\nis replaced with\nA\ni,j\n | x\n.\nThe value of\nx\nmay be chosen differently for different operations.\nDetermine whether it is possible to transform matrix\nA\ninto matrix\nB\nusing the given operations any number of times (including zero).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. Then,\nt\ntest cases follow.\nEach test case is given as follows:\nthe first line contains two integers\nn\nand\nm\n(\n1≤n,m≤\n10\n3\n;\nn⋅m≤\n10\n3\n) — the dimensions of the matrices\nA\nand\nB\n;\nthe following\nn\nlines describe the matrix\nA\n, where the\ni\n-th line contains\nm\nintegers\nA\ni,1\n,\nA\ni,2\n,…,\nA\ni,m\n(\n0≤\nA\ni,j\n≤\n10\n9\n);\nthe following\nn\nlines describe the matrix\nB\n, where the\ni\n-th line contains\nm\nintegers\nB\ni,1\n,\nB\ni,2\n,…,\nB\ni,m\n(\n0≤\nB\ni,j\n≤\n10\n9\n).\nOutput\nFor each test case, output Yes if it is possible to transform the matrix\nA\ninto the matrix\nB\n; otherwise, output No. Each letter can be output in any case, upper or lower.\nExample\ninput\nCopy\n4\n1 1\n12\n13\n2 2\n10 10\n42 42\n21 21\n21 21\n2 2\n74 10\n42 106\n21 85\n85 21\n2 4\n1 2 3 4\n5 6 7 8\n3 2 3 4\n1 0 1 0\noutput\nCopy\nYes\nYes\nNo\nYes\nNote\nLet's consider the second set of input data and show a sequence of operations that transforms matrix\nA\ninto matrix\nB\n:\nInitially, the matrix looks like this:\n[\n10\n42\n10\n42\n]\n[\nApply an operation of the first type with parameters\ni=1\nand\nx=0\n. As a result, we get the matrix:\n[\n0\n42\n0\n42\n]\n[\nApply an operation of the first type with parameters\ni=2\nand\nx=0\n. As a result, we get the matrix:\n[\n0\n0\n0\n0\n]\n[\nApply an operation of the second type with parameters\nj=1\nand\nx=21\n. As a result, we get the matrix:\n[\n21\n21\n0\n0\n]\n[\nApply an operation of the second type with parameters\nj=2\nand\nx=21\n. As a result, we get the matrix:\n[\n21\n21\n21\n21\n]\n[\nThus, we have transformed matrix\nA\ninto matrix\nB\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "greedy",
            "implementation"
        ]
    },
    {
        "title": "D. Problem about GCD",
        "description": "Given three integers\nl\n,\nr\n, and\nG\n, find two integers\nA\nand\nB\n(\nl≤A≤B≤r\n) such that their greatest common divisor (GCD) equals\nG\nand the distance\n|A−B|\nis maximized.\nIf there are multiple such pairs, choose the one where\nA\nis minimized. If no such pairs exist, output \"-1 -1\".\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. Then,\nt\ntest cases follow.\nEach test case consists of a single line containing three integers\nl,r,G\n(\n1≤l≤r≤\n10\n18\n;\n1≤G≤\n10\n18\n) — the range boundaries and the required GCD.\nOutput\nFor each test case, output two integers\nA\nand\nB\n— the solution to the problem, or \"-1 -1\" if no such pair exists.\nExample\ninput\nCopy\n4\n4 8 2\n4 8 3\n4 8 4\n5 7 6\noutput\nCopy\n4 6\n-1 -1\n4 8\n6 6",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory"
        ]
    },
    {
        "title": "C. Sums on Segments",
        "description": "You are given an array\na\nof\nn\nintegers, where all elements except for at most one are equal to\n−1\nor\n1\n. The remaining element\nx\nsatisfies\n−\n10\n9\n≤x≤\n10\n9\n.\nFind all possible sums of subarrays of\na\n, including the empty subarray, whose sum is defined as\n0\n. In other words, find all integers\nx\nsuch that the array\na\nhas at least one subarray (possibly empty) with sum equal to\nx\n. A subarray is a contiguous subsegment of an array.\nOutput these sums in ascending order. Each sum should be printed only once, even if it is achieved by multiple subarrays.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then,\nt\ntest cases follow.\nEach test case consists of two lines:\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n. In the array\na\n, there is at most one element that is neither\n1\nnor\n−1\n.\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two lines:\nIn the first line, print a single integer — the number of distinct subarray sums.\nIn the second line, print these sums in ascending order.\nEach sum should be printed only once, even if it is produced by multiple subarrays.\nExample\ninput\nCopy\n5\n5\n1 -1 10 1 1\n5\n-1 -1 -1 -1 -1\n2\n-1 2\n2\n7 1\n3\n1 4 -1\noutput\nCopy\n8\n-1 0 1 2 9 10 11 12 \n6\n-5 -4 -3 -2 -1 0 \n4\n-1 0 1 2 \n4\n0 1 7 8 \n6\n-1 0 1 3 4 5 \nNote\nLet's define\na[i,j]\nas the subarray of\na\nfrom position\ni\nto position\nj\n.\nConsider the first test case of the example:\n−1\nis produced by\na[2,2]\n;\n0\nis produced by the empty subarray;\n1\nis produced by\na[4,4]\n;\n2\nis produced by\na[4,5]\n;\n9\nis produced by\na[2,3]\n;\n10\nis produced by\na[1,3]\n;\n11\nis produced by\na[3,4]\n;\n12\nis produced by\na[3,5]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "math"
        ]
    },
    {
        "title": "B. Digits",
        "description": "Artem wrote the digit\nd\non the board exactly\nn!\ntimes in a row. So, he got the number\ndddddd…ddd\n(exactly\nn!\ndigits).\nNow he is curious about which odd digits from\n1\nto\n9\ndivide the number written on the board.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The next\nt\ntest cases follow.\nEach test case consists of a single line containing two integers\nn\nand\nd\n(\n2≤n≤\n10\n9\n,\n1≤d≤9\n).\nOutput\nFor each test case, output the odd digits in ascending order that divide the number written on the board.\nExample\ninput\nCopy\n3\n2 6\n7 1\n8 5\noutput\nCopy\n1 3 \n1 3 7 9 \n1 3 5 7 9 \nNote\nThe factorial of a positive integer\nn\n(\nn!\n) is the product of all integers from\n1\nto\nn\n. For example, the factorial of\n5\nis\n1⋅2⋅3⋅4⋅5=120\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "number theory"
        ]
    },
    {
        "title": "A. Coin Transformation",
        "description": "Initially, you have a coin with value\nn\n. You can perform the following operation any number of times (possibly zero):\ntransform one coin with value\nx\n, where\nx\nis greater than\n3\n(\nx>3\n), into two coins with value\n⌊\nx\n4\n⌋\n.\nWhat is the maximum number of coins you can have after performing this operation any number of times?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of one line containing one integer\nn\n(\n1≤n≤\n10\n18\n).\nOutput\nFor each test case, print one integer — the maximum number of coins you can have after performing the operation any number of times.\nExample\ninput\nCopy\n4\n1\n5\n16\n1000000000000000000\noutput\nCopy\n1\n2\n4\n536870912\nNote\nIn the first example, you have a coin of value\n1\n, and you can't do anything with it. So, the answer is\n1\n.\nIn the second example, you can transform a coin of value\n5\ninto two coins with value\n1\n.\nIn the third example, you can transform a coin of value\n16\ninto two coins with value\n4\n. Each of the resulting coins can be transformed into two coins with value\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "math"
        ]
    },
    {
        "title": "F. Two Subarrays",
        "description": "You are given two integer arrays\na\nand\nb\n, both of size\nn\n.\nLet's define the cost of the subarray\n[l,r]\nas\na\nl\n+\na\nl+1\n+⋯+\na\nr−1\n+\na\nr\n+\nb\nl\n+\nb\nr\n. If\nl=r\n, then the cost of the subarray is\na\nl\n+2⋅\nb\nl\n.\nYou have to perform queries of three types:\n\"\n1\np\nx\n\" — assign\na\np\n:=x\n;\n\"\n2\np\nx\n\" — assign\nb\np\n:=x\n;\n\"\n3\nl\nr\n\" — find two non-empty non-overlapping subarrays within the segment\n[l,r]\nwith the maximum total cost and print their total cost.\nInput\nThe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n−\n10\n9\n≤\nb\ni\n≤\n10\n9\n).\nThe fourth line contains a single integer\nq\n(\n1≤q≤2⋅\n10\n5\n).\nThe next\nq\nlines contain the queries: one per line. Each query is of one of three types:\n\"\n1\np\nx\n\" (\n1≤p≤n\n;\n−\n10\n9\n≤x≤\n10\n9\n);\n\"\n2\np\nx\n\" (\n1≤p≤n\n;\n−\n10\n9\n≤x≤\n10\n9\n);\n\"\n3\nl\nr\n\" (\n1≤l<r≤n\n).\nIt is guaranteed that there is at least one query of the third type.\nOutput\nFor each query of the third type, print the maximum possible total cost of two non-empty non-overlapping subarrays within the segment\n[l,r]\n.\nExamples\ninput\nCopy\n7\n3 -1 4 -3 2 4 0\n0 6 1 0 -3 -2 -1\n6\n3 1 7\n1 2 0\n3 3 6\n2 5 -3\n1 3 2\n3 1 5\noutput\nCopy\n18\n7\n16\ninput\nCopy\n10\n2 -1 -3 -2 0 4 5 6 2 5\n2 -4 -5 -1 6 2 5 -6 4 2\n10\n3 6 7\n1 10 -2\n3 5 7\n3 2 8\n2 1 -5\n2 7 4\n3 1 3\n3 3 8\n3 2 3\n1 4 4\noutput\nCopy\n23\n28\n28\n-17\n27\n-22",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "matrices",
            "*2600"
        ]
    },
    {
        "title": "E. Vertex Pairs",
        "description": "You are given a tree consisting of\n2n\nvertices. Recall that a tree is a connected undirected graph with no cycles. Each vertex has an integer from\n1\nto\nn\nwritten on it. Each value from\n1\nto\nn\nis written on exactly two different vertices. Each vertex also has a cost —vertex\ni\ncosts\n2\ni\n.\nYou need to choose a subset of vertices of the tree such that:\nthe subset is connected; that is, from each vertex in the subset, you can reach every other vertex in the subset by passing only through the vertices in the subset;\neach value from\n1\nto\nn\nis written on at least one vertex in the subset.\nAmong all such subsets, you need to find the one with the smallest total cost of the vertices in it. Note that you are not required to minimize the number of vertices in the subset.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line contains\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n1≤\na\ni\n≤n\n). Each value from\n1\nto\nn\nappears exactly twice.\nEach of the next\n2n−1\nlines contains two integers\nv\nand\nu\n(\n1≤v,u≤2n\n) — the edges of the tree. These edges form a valid tree.\nOutput\nIn the first line, print a single integer\nk\n — the number of vertices in the subset.\nIn the second line, print\nk\ndistinct integers from\n1\nto\n2n\n — the indices of the vertices in the chosen subset. The vertices can be printed in an arbitrary order.\nExamples\ninput\nCopy\n3\n1 1 3 2 3 2\n4 2\n1 6\n6 2\n6 3\n2 5\noutput\nCopy\n3\n2 4 5 \ninput\nCopy\n3\n2 3 1 3 2 1\n6 4\n2 4\n5 2\n3 6\n3 1\noutput\nCopy\n4\n1 3 4 6 \ninput\nCopy\n6\n5 2 3 4 6 4 2 5 6 1 1 3\n10 8\n2 10\n12 7\n4 10\n5 9\n6 2\n1 9\n3 4\n12 6\n11 5\n4 5\noutput\nCopy\n6\n2 3 4 5 8 10 \nNote\nThe images show the answers to the first two examples. The numbers in parentheses are the values written on the vertices.\nIn the first example, there are valid subsets such as:\n[2,4,5]\n(with a cost of\n2\n2\n+\n2\n4\n+\n2\n5\n=52\n),\n[2,4,5,6]\n(with a cost of\n116\n),\n[1,6,3]\n(with a cost of\n74\n),\n[2,6,3]\n(with a cost of\n76\n), and many others.\nIn the second example, the cost of the subset\n[4,6,3,1]\nis\n90\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "greedy",
            "implementation",
            "trees",
            "*2900"
        ]
    },
    {
        "title": "D. Recommendations",
        "description": "Suppose you are working in some audio streaming service. The service has\nn\nactive users and\n10\n9\ntracks users can listen to. Users can like tracks and, based on likes, the service should recommend them new tracks.\nTracks are numbered from\n1\nto\n10\n9\n. It turned out that tracks the\ni\n-th user likes form a segment\n[\nl\ni\n,\nr\ni\n]\n.\nLet's say that the user\nj\nis a predictor for user\ni\n(\nj≠i\n) if user\nj\nlikes all tracks the\ni\n-th user likes (and, possibly, some other tracks too).\nAlso, let's say that a track is strongly recommended for user\ni\nif the track is not liked by the\ni\n-th user yet, but it is liked by every predictor for the\ni\n-th user.\nCalculate the number of strongly recommended tracks for each user\ni\n. If a user doesn't have any predictors, then print\n0\nfor that user.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Next,\nt\ncases follow.\nThe first line of each test case contains one integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of users.\nThe next\nn\nlines contain two integers\nl\ni\nand\nr\ni\nper line (\n1≤\nl\ni\n≤\nr\ni\n≤\n10\n9\n) — the segment of tracks the\ni\n-th user likes.\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print\nn\nintegers, where the\ni\n-th integer is the number of strongly recommended tracks for the\ni\n-th user (or\n0\n, if that user doesn't have any predictors).\nExample\ninput\nCopy\n4\n3\n3 8\n2 5\n4 5\n2\n42 42\n1 1000000000\n3\n42 42\n1 1000000000\n42 42\n6\n1 10\n3 10\n3 7\n5 7\n4 4\n1 2\noutput\nCopy\n0\n0\n1\n999999999\n0\n0\n0\n0\n0\n2\n3\n2\n4\n8\nNote\nIn the first test case:\nthe first user has no predictors;\nthe second user has no predictors;\nthe third user has two predictors: users\n1\nand\n2\n; only track\n3\nis liked by both of them and not liked by the third user.\nIn the second test case, the second user is a predictor for the first user. Therefore, all tracks, except\n42\n, are strongly recommended for the first user.\nIn the third test case, the first user has two predictors: users\n2\nand\n3\n, but there is no track that is liked by them and not liked by the first user himself.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "sortings",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "C. Competitive Fishing",
        "description": "Alice and Bob participate in a fishing contest! In total, they caught\nn\nfishes, numbered from\n1\nto\nn\n(the bigger the fish, the greater its index). Some of these fishes were caught by Alice, others — by Bob.\nTheir performance will be evaluated as follows. First, an integer\nm\nwill be chosen, and all fish will be split into\nm\nnon-empty groups. The first group should contain several (at least one) smallest fishes, the second group — several (at least one) next smallest fishes, and so on. Each fish should belong to exactly one group, and each group should be a contiguous subsegment of fishes. Note that the groups are numbered in exactly that order; for example, the fishes from the second group cannot be smaller than the fishes from the first group, since the first group contains the smallest fishes.\nThen, each fish will be assigned a value according to its group index: each fish in the first group gets value equal to\n0\n, each fish in the second group gets value equal to\n1\n, and so on. So, each fish in the\ni\n-th group gets value equal to\n(i−1)\n.\nThe score of each contestant is simply the total value of all fishes that contestant caught.\nYou want Bob's score to exceed Alice's score by at least\nk\npoints. What is the minimum number of groups (\nm\n) you have to split the fishes into? If it is impossible, you should report that.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n;\n1≤k≤\n10\n9\n).\nThe second line contains a string, consisting of exactly\nn\ncharacters. The\ni\n-th character is either 0 (denoting that the\ni\n-th fish was caught by Alice) or 1 (denoting that the\ni\n-th fish was caught by Bob).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum number of groups you have to split the fishes into; or -1 if it's impossible.\nExample\ninput\nCopy\n7\n4 1\n1001\n4 1\n1010\n4 1\n0110\n4 2\n0110\n6 3\n001110\n10 20\n1111111111\n5 11\n11111\noutput\nCopy\n2\n-1\n2\n-1\n3\n4\n-1\nNote\nIn the first test case of the example, you can split the fishes into groups as follows: the first three fishes form the\n1\n-st group, the last fish forms the\n2\n-nd group. Then, Bob's score will be\n1\n, and Alice's score will be\n0\n.\nIn the third test case of the example, you can split the fishes into groups as follows: the first fish forms the\n1\n-st group, the last three fishes form the\n2\n-nd group. Then, Bob's score will be\n2\n, and Alice's score will be\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "*1800"
        ]
    },
    {
        "title": "B. Game with Colored Marbles",
        "description": "Alice and Bob play a game. There are\nn\nmarbles, the\ni\n-th of them has color\nc\ni\n. The players take turns; Alice goes first, then Bob, then Alice again, then Bob again, and so on.\nDuring their turn, a player must take one of the remaining marbles and remove it from the game. If there are no marbles left (all\nn\nmarbles have been taken), the game ends.\nAlice's score at the end of the game is calculated as follows:\nshe receives\n1\npoint for every color\nx\nsuch that she has taken at least one marble of that color;\nadditionally, she receives\n1\npoint for every color\nx\nsuch that she has taken all marbles of that color (of course, only colors present in the game are considered).\nFor example, suppose there are\n5\nmarbles, their colors are\n[1,3,1,3,4]\n, and the game goes as follows: Alice takes the\n1\n-st marble, then Bob takes the\n3\n-rd marble, then Alice takes the\n5\n-th marble, then Bob takes the\n2\n-nd marble, and finally, Alice takes the\n4\n-th marble. Then, Alice receives\n4\npoints:\n3\npoints for having at least one marble for colors\n1\n,\n3\nand\n4\n, and\n1\npoint for having all marbles of color\n4\n. Note that this strategy is not necessarily optimal for both players.\nAlice wants to maximize her score at the end of the game. Bob wants to minimize it. Both players play optimally (i. e. Alice chooses a strategy which allows her to get as many points as possible, and Bob chooses a strategy which minimizes the amount of points Alice can get).\nCalculate Alice's score at the end of the game.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n1≤n≤1000\n) — the number of marbles;\nthe second line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤n\n) — the colors of the marbles.\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, print one integer — Alice's score at the end of the game, assuming that both players play optimally.\nExample\ninput\nCopy\n3\n5\n1 3 1 3 4\n3\n1 2 3\n4\n4 4 4 4\noutput\nCopy\n4\n4\n1\nNote\nIn the second test case of the example, the colors of all marbles are distinct, so, no matter how the players act, Alice receives\n4\npoints for having all marbles of two colors, and no marbles of the third color.\nIn the third test case of the example, the colors of all marbles are the same, so, no matter how the players act, Alice receives\n1\npoint for having at least one (but not all) marble of color\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "games",
            "greedy",
            "*900"
        ]
    },
    {
        "title": "A. Greedy Monocarp",
        "description": "There are\nn\nchests; the\ni\n-th chest initially contains\na\ni\ncoins. For each chest, you can choose any non-negative (\n0\nor greater) number of coins to add to that chest, with one constraint: the total number of coins in all chests must become at least\nk\n.\nAfter you've finished adding coins to the chests, greedy Monocarp comes, who wants the coins. He will take the chests one by one, and since he is greedy, he will always choose the chest with the maximum number of coins. Monocarp will stop as soon as the total number of coins in chests he takes is at least\nk\n.\nYou want Monocarp to take as few coins as possible, so you have to add coins to the chests in such a way that, when Monocarp stops taking chests, he will have exactly\nk\ncoins. Calculate the minimum number of coins you have to add.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains two integers\nn\nand\nk\n(\n1≤n≤50\n;\n1≤k≤\n10\n7\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤k\n).\nOutput\nFor each test case, print one integer — the minimum number of coins you have to add so that, when Monocarp stops taking the chests, he has exactly\nk\ncoins. It can be shown that under the constraints of the problem, it is always possible.\nExample\ninput\nCopy\n4\n5 4\n4 1 2 3 2\n5 10\n4 1 2 3 2\n2 10\n1 1\n3 8\n3 3 3\noutput\nCopy\n0\n1\n8\n2\nNote\nIn the first test case of the example, you don't have to add any coins. When Monocarp arrives, he will take the chest with\n4\ncoins, so he will have exactly\n4\ncoins.\nIn the second test case of the example, you can add\n1\ncoin to the\n4\n-th chest, so, when Monocarp arrives, he will take a chest with\n4\ncoins, then another chest with\n4\ncoins, and a chest with\n2\ncoins.\nIn the third test case of the example, you can add\n3\ncoins to the\n1\n-st chest and\n5\ncoins to the\n2\n-nd chest.\nIn the fourth test case of the example, you can add\n1\ncoin to the\n1\n-st chest and\n1\ncoin to the\n3\n-rd chest.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "N. Railway Construction",
        "description": "The country of Truckski is located in a rugged, mountainous region, and the geological condition has engendered a wide range of issues. The challenging terrain separates the different states in the country, resulting in an extremely inconvenient inter-state commute and more crucially a lack of central governmental control. Adding on top of that is a rampant crime rate that increases annually, and this severely disrupts the everyday lives of innocent citizens.\nA recent protest finally shed light on the situation, as the newly elected president has announced an ambitious project to resolve these issues. Her plan consists of two major components. The first is the construction of high-speed railways between the states to facilitate better connections and unity across the country. Since the states are mostly running independently from each other, to construct a railway between states\nu\nand\nv\n, the government has to pay a fee of\na\nu\n+\na\nv\ndollars, with\na\nu\ndollars given to state\nu\nand\na\nv\ndollars given to state\nv\n. The railway operates bidirectionally, meaning that once it is built, people from state\nu\ncan now travel to state\nv\nand vice versa. A railway can be built between almost any pair of states, except for\nm\nparticular pairs for which the terrain dividing them is so treacherous that the construction of a direct railroad between the two states becomes impossible.\nThe second component of the project is to build a centralized prison that manages all criminals across the country. Given the large number of estimated prisoners, the president decided to pick one of the states to build the central prison and sever the connection from the state to the rest of the country.\nAn illustration for the sample input 1. (a) The costs of building direct railways between the states. (b) Consider building the central prison in State #3. All direct railroads that do not involve State #3 have to be built, with a total cost of\n3+3+2=8\ndollars.\nGiven the above, the president would like to search for the minimum cost plan to construct railroads between the states so that:\nthe state with the central prison should not have any railway connecting it to any other states, and\nall the other states should be connected, i.e., people should be able to travel from one such state to another, possibly by taking more than one train.\nYou are working for the team in charge of the overall planning of the construction. The meeting with the president is happening in just a few hours, at which time you will have to brief her on the cost of different construction plans. Please calculate, for each state\nu\n, the minimum cost plan to construct railroads between states meeting the above conditions when\nu\nis where the central prison is built.\nInput\nThe first line of the input contains two integers\nn\nand\nm\n, the number of states in Truckski and the number of pairs for which railroad construction is not feasible. The next line contains\nn\nintegers\na\n1\n,…,\na\nn\n, the construction fee the government needs to pay to the\ni\n-th state. Then,\nm\nlines follow. The\ni\n-th line contains two integers\nu\ni\nand\nv\ni\nmeaning that it is impossible to build a (direct) railway between states\nu\ni\nand\nv\ni\n.\n2≤n≤\n10\n5\n0≤m≤\n10\n5\n1≤\na\ni\n≤\n10\n9\n1≤\nu\ni\n<\nv\ni\n≤n\nFor all\ni≠j,(\nu\ni\n,\nv\ni\n)≠(\nu\nj\n,\nv\nj\n)\n.\nOutput\nOutput\nn\nintegers in one line. The\ni\n-th integer is the minimum construction cost when the\ni\n-th state is where the prison is built. If it is impossible to find a feasible railroad construction, output -1 instead.\nExamples\ninput\nCopy\n5 3\n1 2 1 1 1\n1 4\n1 5\n2 5\noutput\nCopy\n7 6 8 7 7\ninput\nCopy\n3 2\n1 2 3\n1 2\n2 3\noutput\nCopy\n-1 4 -1",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "*3300"
        ]
    },
    {
        "title": "M. Selection Sort",
        "description": "Every student enrolled in the algorithms course is required to submit an assignment this week. The task is to implement an\nO(\nn\n2\n)\n-time algorithm to sort\nn\ngiven integers in non-decreasing order. Alice has already completed her assignment, and her implementation is shown below.\nint alice_sort(int *s, int n){\n  for(int i = 0; i < n; ++i){\n    for(int j = i + 1; j < n; ++j){\n      if(s[i] > s[j]){\n        int swap = s[i];\n        s[i] = s[j];\n        s[j] = swap;\n      }\n    }\n  }\n  return 0;\n}\nWhile you have access to Alice's code, you prefer not to simply copy it. Instead, you want to use Alice's sorting function as a building block for your own solution. There are two ways as listed below you can utilize her function, but each of them can be applied at most once. The order in which these two operations are invoked can be arbitrary.\nPrefix sort: choose a length\ni∈{1,2,…,n}\nand call\nalicesort(s,i)\n. This sorts the first\ni\nelements in the array\ns\n.\nSuffix sort: choose a length\ni∈{1,2,…,n}\nand call\nalicesort(s+n−i,i)\n. This sorts the last\ni\nelements in the array\ns\n.\nDue to the time complexity of the sorting algorithm, the cost of performing either a prefix or suffix sort is\ni\n2\n, where\ni\nis the length of the chosen subarray. Your goal is to determine the minimum cost to sort the input array\ns\nof\nn\nintegers in non-decreasing order using Alice's function, following the rules mentioned above.\nFor example, Let\ns=[3,2,5,5,4,1]\n. We can first perform a suffix sort of length\n4\n, and the array becomes\n[3,2,1,4,5,5]\n. Then, we perform a prefix sort of length\n3\n, and the array becomes\n[1,2,3,4,5,5]\n, which is a sorted array. The cost is\n4\n2\n+\n3\n2\n=25\n. Here is another example, let\ns=[4,3,2,1]\n. We can complete the sorting by performing only a prefix sort of length\n4\n, and the cost is\n4\n2\n=16\n.\nInput\nThe first line contains exactly one integer\nn\nwhich indicates the number of integers in the array\ns\n. The second line contains the\nn\nintegers in\ns=[\ns\n0\n,\ns\n1\n,…,\ns\nn−1\n]\n.\n1≤n≤\n10\n6\nFor all\ni\n(\n0≤i<n\n),\n0≤\ns\ni\n<\n2\n31\n−1\n.\nOutput\nOutput an integer on a line, indicating the minimum cost to sort the input array\ns\nof\nn\nintegers in non-decreasing order using Alice's function, following the rules mentioned above.\nExamples\ninput\nCopy\n6\n3 2 5 5 4 1\noutput\nCopy\n25\ninput\nCopy\n4\n4 3 2 1\noutput\nCopy\n16",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "two pointers",
            "*2000"
        ]
    },
    {
        "title": "K. Trophic Balance Species",
        "description": "Image generated by ChatGPT 4o.\nIn an interdisciplinary collaboration, an ecosystem scientist and a computer scientist join forces to analyze the structure of a complex ecosystem using computational methods. The ecosystem scientist models the ecosystem as a directed graph\nD=(V,A)\n, where each species is represented by a node\nv∈V\n, and each feeding relationship is represented as a directed edge\n(x,y)∈A\nfrom prey\nx\nto predator\ny\n. This graph structure allows them to simulate the flow of energy throughout the ecosystem from one species to another.\nTwo essential features of the ecosystem are defined:\nIndependent Trophic Group: A set\nS\nof animal species is classified as an independent trophic group if no species\nx∈S\ncan reach another species\ny∈S\n(for some\ny≠x\n) through a series of directed feeding relationships, meaning there is no directed path in\nD\nfrom\nx\nto\ny\n.\nTrophic Balance Species: A species is termed a trophic balance species if it has a nearly equal number of species that affect it as directly or indirectly predators (species it can reach via a directed path in\nD\n, excluding itself) and species that affect it as directly or indirectly prey (species that can reach it via a directed path in\nD\n, excluding itself). Specifically, trophic balance species are those for which the absolute difference between the above two numbers is minimum among all species in the ecosystem.\nConsider an ecosystem with\nn=4\nspecies and\nm=3\nfeeding relationships:\nSpecies 1: Grass (Node 1)\nSpecies 2: Rabbits (Node 2)\nSpecies 3: Foxes (Node 3)\nSpecies 4: Hawks (Node 4)\nThe directed edges representing the feeding relationships are as follows:\n(1,2)\n: Grass is eaten by Rabbits.\n(2,3)\n: Rabbits are eaten by Foxes.\n(2,4)\n: Rabbits are also eaten by Hawks.\nNow, consider the set\nS={3,4}\n(Foxes and Hawks). There are no directed paths between Foxes (Node 3) and Hawks (Node 4); Foxes cannot reach Hawks, and Hawks cannot reach Foxes through any directed paths. Therefore, this set qualifies as an independent trophic group.\nExamination of Species\nSpecies 1 (Grass):\nCan reach: 3 (Rabbits, Foxes, and Hawks)\nCan be reached by: 0 (None)\nAbsolute difference:\n|3−0|=3\nSpecies 2 (Rabbits):\nCan reach: 2 (Foxes and Hawks)\nCan be reached by: 1 (Grass)\nAbsolute difference:\n|2−1|=1\nSpecies 3 (Foxes):\nCan reach: 0 (None)\nCan be reached by: 2 (Grass and Rabbits)\nAbsolute difference:\n|0−2|=2\nSpecies 4 (Hawks):\nCan reach: 0 (None)\nCan be reached by: 2 (Grass and Rabbits)\nAbsolute difference:\n|0−2|=2\nAmong these species, Rabbits have the smallest absolute difference of\n1\n, indicating that they are a trophic balance species within the ecosystem.\nIt is known that any independent trophic group in the ecosystem has a size of at most\nk\n. The task is to find the set of all trophic balance species in the ecosystem.\nInput\nThe first line contains exactly two integers\nn\nand\nm\n, where\nn\n(resp.\nm\n) denotes the number of nodes (resp. edges) in the directed graph\nD\ninduced by the investigated ecosystem. The nodes are numbered as\n1,2,…,n\n. Then,\nm\nlines follow. The\ni\n-th line contains two integers\nxi\nand\nyi\nindicating a directed edge from node\nxi\nto node\nyi\n.\n1≤n≤2×105\n0≤m≤min{n(n−1),4×105}\nk\nis not an input value, and it is guaranteed that\n1≤k≤16\nfor each investigated ecosystem.\nFor all\ni\n(\n1≤i≤m\n),\n1≤xi,yi≤n\nand\nxi≠yi\n.\nEach ordered pair\n(xi,yi)\nappears at most once in the input.\nOutput\nOutput on a single line the node identidiers of all trophic balance species in ascending order. For any two consecutive node identifiers, separate them by a space.\nExamples\ninput\nCopy\n4 3\n1 2\n2 3\n2 4\noutput\nCopy\n2\ninput\nCopy\n4 5\n1 2\n1 3\n1 4\n2 3\n3 2\noutput\nCopy\n2 3 4",
        "time_limit": "3 seconds",
        "memory_limit": "128 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dfs and similar",
            "graphs",
            "*3100"
        ]
    },
    {
        "title": "J. Bottle Arrangement",
        "description": "Image generated by ChatGPT 4o.\nMayaw works in a renowned Epah (aboriginal Taiwanese millet wine; Epah is the Pangcah term for aboriginal Taiwanese millet wine, named in the language of the Pangcah people, the largest Indigenous group in Taiwan) bar in the Fata'an Village. To showcase the depth of its collections, the bar has a two-row wine rack where each row can fit exactly\nn\nbottles. There are already\nn\nbottles placed on the back row of the rack, where the\ni\n-th bottle from left has height\nai\n. The owner of the bar has another\nn\nbottles with distinct heights\nb1,…,bn\nthat he would like Mayaw to put on the first row. To ensure that all bottles on the rack are visible, the owner requires that each bottle on the back row should not be blocked by the one put in front of it. That is, if a bottle of height\nh\nis put on the\ni\n-th spot (from left) in the first row, then\nh\nmust be less than\nai\n. However, not all such arrangements are good for the owner. To pay tributes to the Maxi Mountain nearby, he additionally demands that the bottles in the front row should display a mountain-like shape. In particular, the heights of the bottles, when listing from left to right, should form a sequence that is first (non-strictly) increasing and then (non-strictly) decreasing.\nUnfortunately, sometimes it is impossible to achieve owner's requirements. That is why Mayaw is also allowed to slightly reduce a bottle's height by removing its cap that has a height of\n1\n. In other words, after the removal of the cap, the height of the bottle decreases by exactly\n1\n. Of course, exposing the Epah inside the bottle to the open air is detrimental to its quality, and therefore it is desirable to remove as few bottle caps as possible.\nCan you help Mayaw determine the minimum number of caps needed to be removed so that he can arrange the bottles in a way that satisfies the owner's requirements? Note that the positions of the bottles in the back row are fixed and Mayaw is not allowed to modify them.\nInput\nThe first line contains an integer\nn\nwhich represents the number of bottles in each row. The second line contains\nn\nintegers\na1,…,an\n, the height of the bottles in the back row. The third line contains\nn\ndistinct integers\nb1,…,bn\n, the height of the bottles in the front row.\n1≤n≤5×105\n1≤ai,bi≤109\nAll\nbi\n's are distinct.\nOutput\nOutput the minimum number of bottle caps needed to be removed so that Mayaw can arrange the bottles in the desired way. If it is impossible to achieve that (regardless of the number of caps removed), output -1 instead.\nExamples\ninput\nCopy\n5\n2 4 6 5 4\n1 2 3 4 5\noutput\nCopy\n0\ninput\nCopy\n5\n2 3 6 5 4\n1 2 3 4 5\noutput\nCopy\n0\ninput\nCopy\n5\n6 2 6 6 6\n1 2 3 4 5\noutput\nCopy\n1\ninput\nCopy\n5\n7 2 7 7 7\n1 3 4 5 6\noutput\nCopy\n-1\ninput\nCopy\n10\n18 20 16 18 16 10 13 6 4 10\n19 10 9 15 4 16 6 12 3 17\noutput\nCopy\n4",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "dp",
            "dsu",
            "greedy",
            "*2700"
        ]
    },
    {
        "title": "I. Auto Complete",
        "description": "You are designing a snazzy new text editor, and you want to add a nifty auto-complete feature to help users save time. Here is how it will work: if a user types \"App\", your editor will magically suggest the word \"Application\"! Even better, users can personalize the words that auto-complete in your editor.\nYour editor will support 4 kinds of operations (Let's say the current text in your editor is\nt\n):\nAdd an auto complete pattern\np\ni\n.\nDelete an auto complete pattern\np\ni\n.\nAppend a string\ns\nto the end of\nt\n.\nDelete\nc\ncharacters from the end of\nt\n. Note that if\nc\nis larger then the length of\nt\n, delete all the characters from\nt\n.\nAfter each action, your editor should suggest an auto-complete candidate\ni\nthat matches the following criteria:\nThe string\np\ni\nhas a prefix equal to\nt\n.\nIf there are multiple\np\ni\n, pick the longest one.\nIf there are still multiple\np\ni\n, pick the one with the smallest lexicographic order.\nIf there are still multiple\np\ni\n, pick the one with the smallest ID.\nTo simplify the question, for each action, print the suggested auto complete pattern ID. If there's no match, print -1.\nFor example, let us say we have three candidates: \"alice\", \"bob\", and \"charlie\", with ID 1, 2, and 3. At first, there is nothing on the screen, so \"charlie\" (3) should be suggested because it is the longest. Then, let us say the user types \"b\". You should suggest \"bob\" (2) because it is the only one that starts with \"b\". Finally, let us say the user type \"body\". You should print -1 because there is no matched pattern.\nInput\nThe first line contains an integer\nn\n, followed by\nn\nlines, with each line containing an action.\nThere are four types of actions:\ni\np\ni\ni\ns\nc\nThe add actions are followed by an integer\ni\nand a pattern\np\ni\n, which means the user wants to add a pattern with ID\ni\n. The delete actions are followed by an integer\ni\n, which means the user wants to delete\np\ni\nfrom the pattern set. The append actions are followed by a string\ns\n, which means the user appends\ns\nto the end of\nt\n. The backspace actions are followed by an integer\nc\n, which means the user deletes\nc\ncharacters from the end of\nt\n. All the parameters are splitted by a single space character.\n1≤n≤\n10\n6\nThe total number of characters in all\np\ni\nand\ns\ndoes not exceed\n2×\n10\n6\n.\n1≤c≤2×\n10\n6\nThe strings\np\ni\nand\ns\nmay contain any printable characters, excluding all space characters (ASCII number in the range from\n33\nto\n126\n).\nThe ID\ni\nfor each add operation is unique.\nThe ID\ni\nfor each delete is guaranteed to be valid.\nEach ID\ni\nsatisfies\n0≤i≤n\n.\nOutput\nThe program should output\nn\nlines. For each action, output an integer\ni\n, which means that after the action,\np\ni\nis the suggested auto complete candidate. If there is no\np\ni\nthat matches the requirement, output -1.\nExamples\ninput\nCopy\n6\nadd 1 pattern1_alice\nadd 2 pattern2_bob\nadd 3 pattern3_charlie\nappend pattern\nappend 2_bobabc\nbackspace 3\noutput\nCopy\n1\n1\n3\n3\n-1\n2\ninput\nCopy\n6\nappend pattern\nadd 1 pattern1_alice____\nadd 2 pattern2_bob______\nadd 3 pattern3_charlie__\ndelete 1\ndelete 2\noutput\nCopy\n-1\n1\n1\n1\n2\n3",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "hashing",
            "implementation",
            "sortings",
            "strings",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "G. Grid Game",
        "description": "Claire loves drawing lines. She receives a sheet of paper with an\nn×n\ngrid and begins drawing \"lines\" on it. Well—the concept of a \"line\" here is not what we usually think of. Claire refers each line to be a set of consecutive vertical grid cells. When she draws a line, these cells are all covered with black ink. Initially, all the cells are white, and drawing lines turns some of them black. After drawing a few lines, Claire wonders: how many ways she can color an additional white cell black so that the remaining white cells do not form a single connected component.\nTwo cells are directly connected if they share an edge. Two cells\nx\nand\ny\nare indirectly connected if there exists a sequence of cells\nc\n0\n,\nc\n1\n,…,\nc\nk\nwith\nk>1\nsuch that\nc\n0\n=x\n,\nc\nk\n=y\n, and for every\ni∈{1,2,…,k}\nthe cells\nc\ni\nand\nc\ni−1\nare directly connected. A set of cells forms a single connected component if each pair of cells in the set is either directly or indirectly connected.\nThe grid has\nn\nrows and\nn\ncolumns, both indexed from\n1\nto\nn\n. Claire will draw\nq\nlines. The\ni\n-th line is drawn in the\ny\ni\n-th column, from the\ns\ni\n-th row to the\nf\ni\n-th row, where\ns\ni\n≤\nf\ni\nfor each\ni∈{1,2,…,q}\n. Note that the cells that are passed by at least one of the\nq\nlines are colored black. The following figure shows an example of a\n20×20\ngrid with\nq=67\nlines. The grid cells marked with red star symbols refer to the cells such that, if Claire colors that cell black, all white cells no longer form a single connected component.\nYou may assume that, after drawing the\nq\nlines, the remaining white cells form a single connected component with at least three white cells.\nInput\nThe first line contains exactly one integer\nt\n, indicating the number of test cases. For each test case, it begins with a line containing exactly two integers\nn\nand\nq\n. This indicates that the grid is\nn\nby\nn\nand that Claire draws\nq\nlines on it. Then\nq\nlines follow. For each\ni∈{1,2,…,q}\n, the\ni\n-th line among the\nq\nlines contains exactly three integers\ny\ni\n,\ns\ni\n, and\nf\ni\n.\n1≤t≤125\n2≤n≤\n10\n9\nq≥1\n; the sum of all\nq\nvalues is at most\n10\n5\n.\n1≤\ny\ni\n≤n\n1≤\ns\ni\n≤\nf\ni\n≤n\nThere are at least three white cells and all white cells form a connected component.\nOutput\nPrint an integer on a line, indicating how many ways Claire can color an additional white cell black so that the remaining white cells do not form a single connected component.\nExample\ninput\nCopy\n2\n3 1\n2 1 2\n5 2\n2 1 4\n4 2 5\noutput\nCopy\n5\n15",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "*3100"
        ]
    },
    {
        "title": "F. Segmentation Folds",
        "description": "Peter loves folding segments. There is a segment on a number line occupying the interval\n[ℓ,r]\n. Since it is the prime time for folding the segments, Peter decides to fold the segment carefully. In each step, he chooses one of the two following operations whenever possible:\nOperation\nLTR\n: he folds the segment from left to right, where\nℓ\ncoincides with a point\nx\n(\nℓ<x≤r\n) such that\nℓ+x\nis a prime number\n∗\n. When Peter chooses this operation, he always chooses the largest possible value\nx\n. Note that the segment occupies the interval\n[\n1\n2\n(ℓ+x),r]\nafterwards.\nOperation\nRTL\n: he folds the segment from right to left, where\nr\ncoincides with a point\nx\n(\nℓ≤x<r\n) such that\nr+x\nis a prime number. When Peter chooses this operation, he always chooses the smallest possible value\nx\n. Note that the segment occupies the interval\n[ℓ,\n1\n2\n(r+x)]\nafterwards.\nA folding sequence refers to a sequence of operations specified above. Peter wants to fold the segment several times, resulting in the shortest possible interval whose length that cannot be further reduced. The length of an interval\n[ℓ,r]\nis defined naturally to be\nr−ℓ\n. Let's consider the following example. Suppose that we are folding a segment initially occupying the interval\n[1,30]\n. There are three folding sequences that lead to the shortest possible resulting interval, as shown in the following figure.\nPlease help Peter determine the number of folding sequences such that the resulting interval has a shortest possible length. Output the number modulo\n998244353\n.\n∗\nRecall that an integer\np>1\nis a prime number if there do not exist integers\na,b>1\nsuch that\np=ab\n.\nInput\nThe first line contains an integer\nt\n, denoting the number of test cases. In each of the following\nt\nlines, there are two integers\nℓ\nand\nr\n.\n1≤t≤10\n1≤ℓ<r≤\n10\n12\nr−ℓ≤\n10\n5\nOutput\nFor each test case, please output a line denoting the number of ways to fold the given segment such that the resulting segment has the shortest possible length, modulo\n998244353\n.\nExample\ninput\nCopy\n3\n1 30\n16 18\n142857 240135\noutput\nCopy\n3\n1\n63",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "E. Beautiful Array",
        "description": "Image generated by ChatGPT 4o.\nA-Ming's birthday is coming and his friend A-May decided to give him an integer array as a present. A-Ming has two favorite numbers\na\nand\nb\n, and he thinks an array is beautiful if its mean is exactly\na\nand its median is exactly\nb\n. Please help A-May find a beautiful array so her gift can impress A-Ming.\nThe mean of an array is its sum divided by its length. For example, the mean of array\n[3,−1,5,5]\nis\n12÷4=3\n.\nThe median of an array is its middle element after sorting if its length is odd, or the mean of two middle elements after sorting if its length is even. For example, the median of\n[1,1,2,4,8]\nis\n2\nand the median of\n[3,−1,5,5]\nis\n(3+5)÷2=4\n.\nNote that the mean and median are not rounded to an integer. For example, the mean of array\n[1,2]\nis\n1.5\n.\nInput\nThe only line contains two integers\na\nand\nb\n.\n−100≤a,b≤100\n.\nThe length of the array must be between\n1\nand\n1000\n.\nThe elements of the array must be integers and their absolute values must not exceed\n10\n6\n.\nOutput\nIn the first line, print the length of the array.\nIn the second line, print the elements of the array.\nIf there are multiple solutions, you can print any. It can be proved that, under the constraints of the problem, a solution always exists.\nExamples\ninput\nCopy\n3 4\noutput\nCopy\n4\n3 -1 5 5\ninput\nCopy\n-100 -100\noutput\nCopy\n1\n-100",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ]
    },
    {
        "title": "D. Drunken Maze",
        "description": "Image generated by ChatGPT 4o.\nYou are given a two-dimensional maze with a start and end position. Your task is to find the fastest way to get from the start to the end position. The fastest way is to make the minimum number of steps where one step is going left, right, up, or down. Of course, you cannot walk through walls.\nThere is, however, a catch: If you make more than three steps in the same direction, you lose balance and fall down. Therefore, it is forbidden to make more than three consecutive steps in the same direction. It is okay to walk three times to the right, then one step to the left, and then again three steps to the right. This has the same effect as taking five steps to the right, but is slower.\nInput\nThe first line contains two numbers\nn\nand\nm\n, which are the height and width of the maze. This is followed by an ASCII-representation of the maze where\n#\nis a wall,\n.\nis an empty space, and\nS\nand\nT\nare the start and end positions.\n12≤n×m≤200000\n.\n3≤n,m≤10000\n.\nCharacters are only\n.#ST\nand there is exactly one\nS\nand one\nT\n.\nThe outer borders are only\n#\n(walls).\nOutput\nThe minimum number of steps to reach the end position from the start position or -1 if that is impossible.\nExamples\ninput\nCopy\n7 12\n############\n#S........T#\n#.########.#\n#..........#\n#..........#\n#..#..#....#\n############\noutput\nCopy\n15\ninput\nCopy\n5 8\n########\n#......#\n#.####.#\n#...T#S#\n########\noutput\nCopy\n14\ninput\nCopy\n5 8\n########\n#.#S...#\n#.####.#\n#...T#.#\n########\noutput\nCopy\n-1",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "graphs",
            "shortest paths",
            "*1700"
        ]
    },
    {
        "title": "C. Cube",
        "description": "You are given an\nn×n×n\nbig three-dimensional cube that contains\nn\n3\nnumbers. You have to choose\nn\nof those numbers so that their sum is as small as possible. It is, however, forbidden to choose two numbers that are located in the same plane. That is, if we identify the positions in the cube by three Cartesian coordinates, then choosing two numbers from positions\n(x,y,z)\nand\n(\nx\n′\n,\ny\n′\n,\nz\n′\n)\nis forbidden if\nx=\nx\n′\n,\ny=\ny\n′\n, or \nz=\nz\n′\n.\nInput\nThe input consists of the number\nn\nfollowed by\nn\n3\nnumbers in the cube. The numbers are presented as\nn\ntwo-dimensional matrices, one for each layer of the cube. More precisely, there will be\nn\n2\nlines follow, each having\nn\nnumbers. For each\nx,y,z\n(\n1≤x,y,z≤n\n), the number at the position\n(x,y,z)\nis listed as the\nz\n-th number in the\n((x−1)×n+y)\n-th line.\n2≤n≤12\nAll numbers in the cube are integers between\n0\nand\n2×\n10\n7\n.\nOutput\nThe output consists of a single number. It is the minimum sum of\nn\nnumbers chosen from the cube according to the above rules.\nExample\ninput\nCopy\n3\n1 2 3\n4 5 6\n7 8 9\n1 1 1\n2 2 2\n3 3 3\n4 3 0\n2 1 4\n9 8 9\noutput\nCopy\n5",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "dfs and similar",
            "dp",
            "*2000"
        ]
    },
    {
        "title": "B. Bowling Frame",
        "description": "Bowling is a national sport in Taiwan; everyone in the country plays the sport on a daily basis since their youth. Naturally, there are a lot of bowling alleys all over the country, and the competition between them is as intense as you can imagine.\nMaw-Shang owns one such bowling alley. To stand out from other competitors in the industry and draw attention from customers, he decided to hold a special event every month that features various unorthodox bowling rules. For the event this month, he came up with a new version of the game called X-pin bowling. In the traditional\n10\n-pin bowling game, a frame is built out of ten bowling pins forming a triangular shape of side length four. The pin closest to the player forms the first row, and the two pins behind it form the second row, and so on. Unlike the standard version, the game of\nX\n-pin bowling Maw-Shang designed allows a much larger number of pins that form a larger frame. The following figure shows a standard\n10\n-pin frame on the left, and on the right it shows a\n21\n-pin frame that forms a triangular shape of side length six which is allowed in the game of\nX\n-pin bowling.\nBeing the national sport, the government of Taiwan strictly regulates and standardizes the manufacturing of bowling pins. There are two types of bowling pins allowed, one in black and the other in white, and the bowling alley Maw-Shang owns has\nw\nwhite pins and\nb\nblack pins. To make this new game exciting for the customers, Maw-Shang wants to build the largest possible frame from these\nw+b\npins. However, even though he is okay with using both colors in building the frame, for aesthetic reasons, Maw-Shang still wants the colors of the pins on the same row to be identical. For example, the following figure shows two possible frames of side length six, but only the left one is acceptable to Maw-Shang since the other one has white and black pins mixed in the third row.\nThe monthly special event is happening in just a few hours. Please help Maw-Shang calculate the side length of the largest frame that he can build from his\nw+b\npins!\nInput\nThe first line of the input contains a single integer\nt\n, the number of test cases. Each of the following\nt\nlines contains two integers\nw\nand\nb\n, the number of white and black pins, respectively.\n1≤t≤100\n0≤w,b≤\n10\n9\nOutput\nFor each test case, output in a single line the side length\nk\nof the largest pin satisfying Maw-Shang's requirement you can build with the given pins.\nExample\ninput\nCopy\n4\n1 2\n3 2\n3 3\n12 0\noutput\nCopy\n2\n2\n3\n4",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. The Bento Box Adventure",
        "description": "Image generated by ChatGPT 4o.\nBoxed meals in Taiwan are very common, offering convenient and affordable nutrition-balanced choices for students and office workers. These meals typically include a variety of vegetables, protein, and rice, providing a well-rounded diet. With numerous options available at local self-service restaurants, they are a popular choice for those looking for a quick, healthy lunch.\nThere are five Taiwanese self-service restaurants numbered from 1 to 5. You plan to visit a different restaurant each day from Monday to Friday to pack a boxed meal for lunch. You've already visited one restaurant from Monday to Thursday, each time visiting a different one. Now, it's Friday, and you want to visit the last remaining restaurant that you haven't been to yet this week.\nWrite a program that takes as input the four restaurants you've already visited (one for each day from Monday to Thursday) and outputs the restaurant you should visit on Friday.\nInput\nA single line of input containing four integers\na,b,c,d\n, each between 1 and 5 (inclusive), representing the restaurant numbers you visited from Monday to Thursday, in order.\n1≤a,b,c,d≤5\nAll four numbers will be different.\nOutput\nOutput the restaurant number you should visit on Friday.\nExamples\ninput\nCopy\n1 3 2 5\noutput\nCopy\n4\ninput\nCopy\n2 5 4 3\noutput\nCopy\n1",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1300"
        ]
    },
    {
        "title": "F. Number of Cubes",
        "description": "Consider a rectangular parallelepiped with sides\na\n,\nb\n, and\nc\n, that consists of unit cubes of\nk\ndifferent colors. We can apply cyclic shifts to the parallelepiped in any of the three directions any number of times\n∗\n.\nThere are\nd\ni\ncubes of the\ni\n-th color (\n1≤i≤k\n). How many different parallelepipeds (with the given sides) can be formed from these cubes, no two of which can be made equal by some combination of cyclic shifts?\n∗\nOn the image:\nTop left shows the top view of the original parallelepiped. Lower layers will shift in the same way as the top layer.\nTop right shows the top view of a parallelepiped shifted to the right by\n1\n.\nBottom left shows the top view of a parallelepiped shifted down by\n2\n.\nBottom right shows the top view of a parallelepiped shifted to the right by\n1\nand down by\n2\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains four integers:\na\n,\nb\n,\nc\n, and\nk\n(\n1≤a,b,c≤3⋅\n10\n6\n;\na⋅b⋅c≤3⋅\n10\n6\n;\n1≤k≤\n10\n6\n) — three sides of the parallelepiped and the number of colors of unit cubes.\nThe second line of each test case contains\nk\nintegers\nd\n1\n,\nd\n2\n,…,\nd\nk\n(\n1≤\nd\n1\n≤\nd\n2\n≤…≤\nd\nk\n≤3⋅\n10\n6\n) — the elements of the array\nd\n: the number of cubes of a given color.\nIt is guaranteed that in each test case the sum of the elements of the array\nd\nis equal to\na⋅b⋅c\n.\nIt is guaranteed that the sum of\nk\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print one integer — the number of different parallelepipeds modulo\n998244353\n.\nExample\ninput\nCopy\n6\n1 1 1 1\n1\n6 1 1 3\n1 2 3\n12 1 1 3\n2 4 6\n3 3 1 2\n3 6\n2 3 3 2\n6 12\n72 60 96 4\n17280 86400 120960 190080\noutput\nCopy\n1\n10\n1160\n12\n1044\n231490207\nNote\nIn the first test case, there is only one parallelepiped, which consists of one unit cube.\nPossible parallelepipeds in the second test case",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "*2700"
        ]
    },
    {
        "title": "E. Control of Randomness",
        "description": "You are given a tree with\nn\nvertices.\nLet's place a robot in some vertex\nv≠1\n, and suppose we initially have\np\ncoins. Consider the following process, where in the\ni\n-th step (starting from\ni=1\n):\nIf\ni\nis odd, the robot moves to an adjacent vertex in the direction of vertex\n1\n;\nElse,\ni\nis even. You can either pay one coin (if there are some left) and then the robot moves to an adjacent vertex in the direction of vertex\n1\n, or not pay, and then the robot moves to an adjacent vertex chosen uniformly at random.\nThe process stops as soon as the robot reaches vertex\n1\n. Let\nf(v,p)\nbe the minimum possible expected number of steps in the process above if we spend our coins optimally.\nAnswer\nq\nqueries, in the\ni\n-th of which you have to find the value of\nf(\nv\ni\n,\np\ni\n)\n, modulo\n∗\n998244353\n.\n∗\nFormally, let\nM=998244353\n. It can be shown that the answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n2≤n≤2⋅\n10\n3\n;\n1≤q≤2⋅\n10\n3\n) — the number of vertices in the tree and the number of queries.\nThe next\nn−1\nlines contain the edges of the tree, one edge per line. The\ni\n-th line contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n;\nu\ni\n≠\nv\ni\n), denoting the edge between the nodes\nu\ni\nand\nv\ni\n.\nThe next\nq\nlines contain two integers\nv\ni\nand\np\ni\n(\n2≤\nv\ni\n≤n\n;\n0≤\np\ni\n≤n\n).\nIt's guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n3\n.\nIt is guaranteed that the sum of\nq\nover all test cases does not exceed\n2⋅\n10\n3\n.\nOutput\nFor each test case, print\nq\nintegers: the values of\nf(\nv\ni\n,\np\ni\n)\nmodulo\n998244353\n.\nFormally, let\nM=998244353\n. It can be shown that the answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nExample\ninput\nCopy\n2\n4 4\n1 2\n2 3\n2 4\n2 0\n3 0\n4 0\n3 1\n12 10\n1 2\n2 3\n2 4\n1 5\n5 6\n6 7\n6 8\n6 9\n8 10\n10 11\n10 12\n6 0\n9 0\n10 0\n11 0\n3 1\n7 1\n10 1\n12 1\n12 2\n11 12\noutput\nCopy\n1\n6\n6\n2\n4\n9\n8\n15\n2\n3\n6\n9\n5\n5\nNote\nThe tree in the first test case:\nIn the first query, the expected value is equal to\n1\n, since the robot starts moving from vertex\n2\nto vertex\n1\nin the first step and the process stops.\nLet's calculate the expected value in the second query (\nx\nis the number of steps):\nP(x<2)=0\n, the distance to vertex\n1\nis\n2\nand the robot cannot reach it in fewer steps.\nP(x=2)=\n1\n3\n, since there is only one sequence of steps leading to\nx=2\n. This is\n3\n→\n1\n2\n→\n0.33\n1\nwith probability\n1⋅\n1\n3\n.\nP(xmod2=1)=0\n, since the robot can reach vertex\n1\nby only taking an even number of steps.\nP(x=4)=\n2\n9\n: possible paths\n3\n→\n1\n2\n→\n0.67\n[3,4]\n→\n1\n2\n→\n0.33\n1\n.\nP(x=6)=\n4\n27\n: possible paths\n3\n→\n1\n2\n→\n0.67\n[3,4]\n→\n1\n2\n→\n0.67\n[3,4]\n→\n1\n2\n→\n0.33\n1\n.\nP(x=i⋅2)=\n2\ni−1\n3\ni\nin the general case.\nAs a result,\nf(v,p)=\n∑\ni=1\n∞\ni⋅2⋅\n2\ni−1\n3\ni\n=6\n.\nThe tree in the second test case:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "dp",
            "graphs",
            "greedy",
            "math",
            "probabilities",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "D. Non Prime Tree",
        "description": "You are given a tree with\nn\nvertices.\nYou need to construct an array\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\n, consisting of unique integers from\n1\nto\n2⋅n\n, and such that for each edge\nu\ni\n↔\nv\ni\nof the tree, the value\n|\na\nu\ni\n−\na\nv\ni\n|\nis not a prime number.\nFind any array that satisfies these conditions, or report that there is no such array.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nThe next\nn−1\nlines contain the edges of the tree, one edge per line. The\ni\n-th line contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n;\nu\ni\n≠\nv\ni\n), denoting the edge between the nodes\nu\ni\nand\nv\ni\n.\nIt's guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if an array that satisfies the conditions exists, print its elements\na\n1\n,\na\n2\n,…,\na\nn\n. Otherwise, print\n−1\n.\nExample\ninput\nCopy\n2\n5\n1 2\n2 3\n2 4\n3 5\n7\n1 2\n1 3\n2 4\n3 5\n3 6\n3 7\noutput\nCopy\n2 10 1 6 5 \n8 7 12 1 4 6 3 \nNote\nThe possible answers are shown below. Instead of the vertex numbers, the corresponding elements of the array\na\nare written in them.\nThe image of the tree in the first test case\nThe image of the tree in the second test case",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "greedy",
            "number theory",
            "trees",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "C. Ordered Permutations",
        "description": "Consider a permutation\n∗\np\n1\n,\np\n2\n,…,\np\nn\nof integers from\n1\nto\nn\n. We can introduce the following sum for it\n†\n†\n:\nS(p)=\n∑\n1≤l≤r≤n\nmin(\np\nl\n,\np\nl+1\n,…,\np\nr\n)\n∑\nLet us consider all permutations of length\nn\nwith the maximum possible value of\nS(p)\n. Output the\nk\n-th of them in lexicographical\n‡\n‡\norder, or report that there are less than\nk\nof them.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\n†\n†\nFor example:\nFor the permutation\n[1,2,3]\nthe value of\nS(p)\nis equal to\nmin(1)+min(1,2)+min(1,2,3)+min(2)+min(2,3)+min(3)=\n1+1+1+2+2+3=10\nFor the permutation\n[2,4,1,3]\nthe value of\nS(p)\nis equal to\nmin(2)+min(2,4)+min(2,4,1)+min(2,4,1,3) +\nmin(4)+min(4,1)+min(4,1,3) +\nmin(1)+min(1,3) +\nmin(3)=\n2+2+1+1+4+1+1+1+1+3=17\n.\n‡\n‡\nAn array\na\nis lexicographically smaller than an array\nb\nif and only if one of the following holds:\na\nis a prefix of\nb\n, but\na≠b\n; or\nin the first position where\na\nand\nb\ndiffer, the array\na\nhas a smaller element than the corresponding element in\nb\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n;\n1≤k≤\n10\n12\n) — the length of the permutation and the index number of the desired permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if there are less than\nk\nsuitable permutations, print\n−1\n.\nOtherwise, print the\nk\n-th suitable permutation.\nExample\ninput\nCopy\n6\n3 2\n3 3\n4 11\n4 6\n6 39\n7 34\noutput\nCopy\n1 3 2 \n2 3 1 \n-1\n2 4 3 1 \n-1\n2 3 4 5 7 6 1 \nNote\nLet us calculate the required sum for all permutations of length\n3\n(ordered lexicographically):\nPermutation Value of\nS(p)\n[1,2,3]\n10\n[1,3,2]\n10\n[2,1,3]\n9\n[2,3,1]\n10\n[3,1,2]\n9\n[3,2,1]\n10\nIn the first test case, you have to print the second suitable permutation of length\n3\n. Looking at the table, we see that it is the permutation\n[1,3,2]\n.\nIn the second test case, you have to print the third suitable permutation of length\n3\n. Looking at the table, we see that it is the permutation\n[2,3,1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "constructive algorithms",
            "greedy",
            "math",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "B. Paint a Strip",
        "description": "You have an array of zeros\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\n.\nYou can perform two types of operations on it:\nChoose an index\ni\nsuch that\n1≤i≤n\nand\na\ni\n=0\n, and assign\n1\nto\na\ni\n;\nChoose a pair of indices\nl\nand\nr\nsuch that\n1≤l≤r≤n\n,\na\nl\n=1\n,\na\nr\n=1\n,\na\nl\n+…+\na\nr\n≥⌈\nr−l+1\n2\n⌉\n, and assign\n1\nto\na\ni\nfor all\nl≤i≤r\n.\nWhat is the minimum number of operations of the first type needed to make all elements of the array equal to one?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array.\nNote that there is no limit on the sum of\nn\nover all test cases.\nOutput\nFor each test case, print one integer — the minimum number of needed operations of first type.\nExample\ninput\nCopy\n4\n1\n2\n4\n20\noutput\nCopy\n1\n2\n2\n4\nNote\nIn the first test case, you can perform an operation of the\n1\nst type with\ni=1\n.\nIn the second test case, you can perform the following sequence of operations:\nOperation of\n1\nst type,\ni=1\n. After performing this operation, the array will look like this:\n[1,0]\n.\nOperation of\n1\nst type,\ni=2\n. After performing this operation, the array will look like this:\n[1,1]\n.\nThe sequence of operations in the second test case\nIn the third test case, you can perform the following sequence of operations:\nOperation of\n1\nst type,\ni=1\n. After performing this operation, the array will look like this:\n[1,0,0,0]\n.\nOperation of\n1\nst type,\ni=4\n. After performing this operation, the array will look like this:\n[1,0,0,1]\n.\nOperation of\n2\nnd type,\nl=1\n,\nr=4\n. On this segment,\na\nl\n+…+\na\nr\n=\na\n1\n+\na\n2\n+\na\n3\n+\na\n4\n=2\n, which is not less than\n⌈\nr−l+1\n2\n⌉=2\n. After performing this operation, the array will look like this:\n[1,1,1,1]\n.\nThe sequence of operations in the third test case",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ]
    },
    {
        "title": "A. Game of Division",
        "description": "You are given an array of integers\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\nand an integer\nk\n.\nTwo players are playing a game. The first player chooses an index\n1≤i≤n\n. Then the second player chooses a different index\n1≤j≤n,i≠j\n. The first player wins if\n|\na\ni\n−\na\nj\n|\nis not divisible by\nk\n. Otherwise, the second player wins.\nWe play as the first player. Determine whether it is possible to win, and if so, which index\ni\nshould be chosen.\nThe absolute value of a number\nx\nis denoted by\n|x|\nand is equal to\nx\nif\nx≥0\n, and\n−x\notherwise.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤100\n;\n1≤k≤100\n) — the length of the array and the number\nk\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n) — the elements of the array\na\n.\nOutput\nFor each test case, if it is impossible for the first player to win, print \"NO\" (without quotes).\nOtherwise, print \"YES\" (without quotes) and on the next line the appropriate index\n1≤i≤n\n. If there are multiple solutions, print any of them.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer.\nExample\ninput\nCopy\n7\n3 2\n1 2 3\n4 2\n1 2 4 5\n5 3\n10 7 3 4 5\n5 3\n1 31 15 55 36\n2 1\n17 17\n2 2\n17 18\n1 3\n6\noutput\nCopy\nYES\n2\nNO\nYES\n3\nNO\nNO\nYES\n2\nYES\n1\nNote\nIn the first test case, the first player can choose\na\n2\n=2\n. Then:\nIf the second player chooses\na\n1\n=1\n, the resulting difference is\n|2−1|=1\nwhich is not divisible by\nk=2\n.\nIf the second player chooses\na\n3\n=3\n, the resulting difference is\n|2−3|=1\nwhich is not divisible by\nk=2\n.\nIn the second test case:\nIf the first player chooses\na\n1\n=1\nand then the second player chooses\na\n4\n=5\n, the resulting difference is\n|1−5|=4\nwhich is divisible by\nk=2\n.\nIf the first player chooses\na\n2\n=2\nand then the second player chooses\na\n3\n=4\n, the resulting difference is\n|2−4|=2\nwhich is divisible by\nk=2\n.\nIf the first player chooses\na\n3\n=4\nand then the second player chooses\na\n2\n=2\n, the resulting difference is\n|4−2|=2\nwhich is divisible by\nk=2\n.\nIf the first player chooses\na\n4\n=5\nand then the second player chooses\na\n1\n=1\n, the resulting difference is\n|5−1|=4\nwhich is divisible by\nk=2\n.\nIn any case, the second player wins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "math",
            "*800"
        ]
    },
    {
        "title": "H2. Cool Swap Walk (Hard Version)",
        "description": "This is the hard version of the problem. The only difference is the maximum number of operations you can perform. You can only make hacks if both versions are solved.\nYou are given an array\na\nof size\nn\n.\nA cool swap walk is the following process:\nIn an\nn×n\ngrid, we note the cells in row\ni\nand column\nj\nas\n(i,j)\n. You need to walk from\n(1,1)\nto\n(n,n)\n, taking only steps to the right or down.\nFormally, if you are in\n(x,y)\ncurrently, you can step to either\n(x+1,y)\nor\n(x,y+1)\n, but you can not step beyond the boundaries of the grid.\nWhen you step in\n(i,j)\n, you must swap\na\ni\nand\na\nj\nwhen\ni≠j\n.\nYou can perform at most\nn+4\ncool swap walks. Sort the array\na\n1\n,\na\n2\n,…,\na\nn\nin non-decreasing order. We can show that it's always possible to do so.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤500\n) — the size of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n2.5⋅\n10\n5\n.\nOutput\nFor each test case, your output should consist of several lines:\nThe first line contains an integer\nk\n(\n0≤k≤n+4\n), representing the number of cool swap walks you perform.\nEach of the next\nk\nlines contains a string\ns\nof length\n2n−2\nconsisting only of R and D, representing the path (letters are case sensitive). For all\n1≤i≤2n−2\n, if\ns\ni\n=\nR, you walk right in the\ni\n-th step, otherwise you walk down in the\ni\n-th step.\nExample\ninput\nCopy\n3\n2\n1 2\n3\n2 1 3\n4\n3 2 3 4\noutput\nCopy\n0\n2\nRRDD\nDRDR\n3\nRRDRDD\nDRDDRR\nDDRRRD\nNote\nIn the first test case, the array\na\nis already non-decreasing, so you don't need to perform any walk.\nIn the second test case,\na=[2,1,3]\ninitially.\nIn the first walk:\nIn the\n1\n-st step, you step right to\n(1,2)\n. Then,\na=[1,2,3]\n. Note that although the array\na\nis already non-decreasing, you can not stop until you reach\n(n,n)\n.\nIn the\n2\n-nd step, you step right to\n(1,3)\n. Then,\na=[3,2,1]\n.\nIn the\n3\n-rd step, you step down to\n(2,3)\n. Then,\na=[3,1,2]\n.\nIn the\n4\n-th step, you step down to\n(3,3)\n. Then,\na=[3,1,2]\n.\nIn the second walk:\nIn the\n1\n-st step, you step down to\n(2,1)\n. Then,\na=[1,3,2]\n.\nIn the\n2\n-nd step, you step right to\n(2,2)\n. Then,\na=[1,3,2]\n.\nIn the\n3\n-rd step, you step down to\n(3,2)\n. Then,\na=[1,2,3]\n.\nIn the\n4\n-th step, you step down to\n(3,3)\n. Then,\na=[1,2,3]\n.\nAfter the two cool swap walks above, we get\na=[1,2,3]\n, which is non-decreasing.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "constructive algorithms",
            "constructive algorithms",
            "implementation",
            "sortings",
            "*3500"
        ]
    },
    {
        "title": "H1. Cool Swap Walk (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is the maximum number of operations you can perform. You can only make hacks if both versions are solved.\nYou are given an array\na\nof size\nn\n.\nA cool swap walk is the following process:\nIn an\nn×n\ngrid, we note the cells in row\ni\nand column\nj\nas\n(i,j)\n. You need to walk from\n(1,1)\nto\n(n,n)\n, taking only steps to the right or down.\nFormally, if you are in\n(x,y)\ncurrently, you can step to either\n(x+1,y)\nor\n(x,y+1)\n, but you can not step beyond the boundaries of the grid.\nWhen you step in\n(i,j)\n, you must swap\na\ni\nand\na\nj\nwhen\ni≠j\n.\nYou can perform at most\n2n+4\ncool swap walks. Sort the array\na\n1\n,\na\n2\n,…,\na\nn\nin non-decreasing order. We can show that it's always possible to do so.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤500\n) — the size of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n2.5⋅\n10\n5\n.\nOutput\nFor each test case, your output should consist of several lines:\nThe first line contains an integer\nk\n(\n0≤k≤2n+4\n), representing the number of cool swap walks you perform.\nEach of the next\nk\nlines contains a string\ns\nof length\n2n−2\nconsisting only of R and D, representing the path (letters are case sensitive). For all\n1≤i≤2n−2\n, if\ns\ni\n=\nR, you walk right in the\ni\n-th step, otherwise you walk down in the\ni\n-th step.\nExample\ninput\nCopy\n3\n2\n1 2\n3\n2 1 3\n4\n3 2 3 4\noutput\nCopy\n0\n2\nRRDD\nDRDR\n3\nRRDRDD\nDRDDRR\nDDRRRD\nNote\nIn the first test case, the array\na\nis already non-decreasing, so you don't need to perform any walk.\nIn the second test case,\na=[2,1,3]\ninitially.\nIn the first walk:\nIn the\n1\n-st step, you step right to\n(1,2)\n. Then,\na=[1,2,3]\n. Note that although the array\na\nis already non-decreasing, you can not stop until you reach\n(n,n)\n.\nIn the\n2\n-nd step, you step right to\n(1,3)\n. Then,\na=[3,2,1]\n.\nIn the\n3\n-rd step, you step down to\n(2,3)\n. Then,\na=[3,1,2]\n.\nIn the\n4\n-th step, you step down to\n(3,3)\n. Then,\na=[3,1,2]\n.\nIn the second walk:\nIn the\n1\n-st step, you step down to\n(2,1)\n. Then,\na=[1,3,2]\n.\nIn the\n2\n-nd step, you step right to\n(2,2)\n. Then,\na=[1,3,2]\n.\nIn the\n3\n-rd step, you step down to\n(3,2)\n. Then,\na=[1,2,3]\n.\nIn the\n4\n-th step, you step down to\n(3,3)\n. Then,\na=[1,2,3]\n.\nAfter the two cool swap walks above, we get\na=[1,2,3]\n, which is non-decreasing.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "sortings",
            "*3500"
        ]
    },
    {
        "title": "G. Shohag Loves Pebae",
        "description": "Shohag has a tree with\nn\nnodes.\nPebae has an integer\nm\n. She wants to assign each node a value — an integer from\n1\nto\nm\n. So she asks Shohag to count the number, modulo\n998244353\n, of assignments such that following conditions are satisfied:\nFor each pair\n1≤u<v≤n\n, the least common multiple (LCM) of the values of the nodes in the unique simple path from\nu\nto\nv\nis not divisible by the number of nodes in the path.\nThe greatest common divisor (GCD) of the values of all nodes from\n1\nto\nn\nis\n1\n.\nBut this problem is too hard for Shohag to solve. As Shohag loves Pebae, he has to solve the problem. Please save Shohag!\nInput\nThe first line contains two space-separated integers\nn\nand\nm\n(\n2≤n≤\n10\n6\n,\n1≤m≤\n10\n9\n).\nEach of the next\nn−1\nlines contains two integers\nu\nand\nv\n(\n1≤u,v≤n\n) indicating there is an edge between vertices\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nOutput\nPrint a single integer — the number of valid ways to assign each vertex a value, modulo\n998244353\n.\nExamples\ninput\nCopy\n6 6\n1 2\n2 3\n3 4\n4 5\n3 6\noutput\nCopy\n2\ninput\nCopy\n2 5\n1 2\noutput\nCopy\n7\ninput\nCopy\n12 69\n3 5\n1 4\n2 3\n4 5\n5 6\n8 9\n7 3\n4 8\n9 10\n1 11\n12 1\noutput\nCopy\n444144548\nNote\nIn the first test case, the valid assignments are\n[1,1,1,1,1,1]\nand\n[1,1,1,1,1,5]\n.\nIn the second test case, the valid assignments are\n[1,1]\n,\n[1,3]\n,\n[1,5]\n,\n[3,1]\n,\n[3,5]\n,\n[5,1]\nand\n[5,3]\n.",
        "time_limit": "5 seconds",
        "memory_limit": "768 megabytes",
        "tags": [
            "math",
            "number theory",
            "*3500"
        ]
    },
    {
        "title": "F2. Shohag Loves Counting (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions of this problem are the constraints on\nt\n,\nm\n, and the sum of\nm\n. You can only make hacks if both versions of the problem are solved.\nFor an integer array\na\nof length\nn\n, define\nf(k)\nas the greatest common divisor (GCD) of the maximum values of all subarrays\n∗\nof length\nk\n. For example, if the array is\n[2,1,4,6,2]\n, then\nf(3)=gcd(max([2,1,4]),max([1,4,6]),max([4,6,2]))=gcd(4,6,6)=2\n.\nAn array is good if\nf(i)≠f(j)\nis satisfied over all pairs\n1≤i<j≤n\n.\nShohag has an integer\nm\n. Help him count the number, modulo\n998244353\n, of non-empty good arrays of arbitrary length such that each element of the array is an integer from\n1\nto\nm\n.\n∗\nAn array\nd\nis a subarray of an array\nc\nif\nd\ncan be obtained from\nc\nby deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤3⋅\n10\n5\n) — the number of test cases.\nThe first and only line of each test case contains an integer\nm\n(\n1≤m≤\n10\n6\n).\nNote that there is no limit on the sum of\nm\nover all test cases.\nOutput\nFor each test case, output an integer — the number of valid arrays modulo\n998244353\n.\nExample\ninput\nCopy\n3\n2\n5\n9\noutput\nCopy\n4\n29\n165\nNote\nIn the first test case, the valid arrays are\n[1]\n,\n[1,2]\n,\n[2]\n, and\n[2,1]\n.\nIn the second test case, there are a total of\n29\nvalid arrays. In particular, the array\n[2,1,4]\nwith length\nn=3\nis valid because all elements are from\n1\nto\nm=5\nand\nf(1)\n,\nf(2)\nand\nf(n=3)\nall are distinct:\nf(1)=gcd(max([2]),max([1]),max([4]))=gcd(2,1,4)=1.\nf(2)=gcd(max([2,1]),max([1,4]))=gcd(2,4)=2.\nf(3)=gcd(max([2,1,4]))=gcd(4)=4.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "number theory",
            "*3200"
        ]
    },
    {
        "title": "F1. Shohag Loves Counting (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions of this problem are the constraints on\nt\n,\nm\n, and the sum of\nm\n. You can only make hacks if both versions of the problem are solved.\nFor an integer array\na\nof length\nn\n, define\nf(k)\nas the greatest common divisor (GCD) of the maximum values of all subarrays\n∗\nof length\nk\n. For example, if the array is\n[2,1,4,6,2]\n, then\nf(3)=gcd(max([2,1,4]),max([1,4,6]),max([4,6,2]))=gcd(4,6,6)=2\n.\nAn array is good if\nf(i)≠f(j)\nis satisfied over all pairs\n1≤i<j≤n\n.\nShohag has an integer\nm\n. Help him count the number, modulo\n998244353\n, of non-empty good arrays of arbitrary length such that each element of the array is an integer from\n1\nto\nm\n.\n∗\nAn array\nd\nis a subarray of an array\nc\nif\nd\ncan be obtained from\nc\nby deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains an integer\nm\n(\n1≤m≤\n10\n5\n).\nIt is guaranteed that the sum of\nm\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output an integer — the number of valid arrays modulo\n998244353\n.\nExample\ninput\nCopy\n3\n2\n5\n9\noutput\nCopy\n4\n29\n165\nNote\nIn the first test case, the valid arrays are\n[1]\n,\n[1,2]\n,\n[2]\n, and\n[2,1]\n.\nIn the second test case, there are a total of\n29\nvalid arrays. In particular, the array\n[2,1,4]\nwith length\nn=3\nis valid because all elements are from\n1\nto\nm=5\nand\nf(1)\n,\nf(2)\nand\nf(n=3)\nall are distinct:\nf(1)=gcd(max([2]),max([1]),max([4]))=gcd(2,1,4)=1.\nf(2)=gcd(max([2,1]),max([1,4]))=gcd(2,4)=2.\nf(3)=gcd(max([2,1,4]))=gcd(4)=4.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "*2800"
        ]
    },
    {
        "title": "E. Shohag Loves Inversions",
        "description": "Shohag has an array\na\nof integers. Initially\na=[0,1]\n. He can repeatedly perform the following operation any number of times:\nLet\nk\nbe the number of inversions\n∗\nin the current array\na\n.\nInsert\nk\nat any position in\na\n, including the beginning or the end.\nFor example, if\na=[4,6,2,4]\n, then the number of inversions is\nk=3\n. So Shohag can obtain the following arrays after the operation:\n[3,4,6,2,4]\n,\n[4,3,6,2,4]\n,\n[4,6,3,2,4]\n,\n[4,6,2,3,4]\n, and\n[4,6,2,4,3]\n.\nGiven an integer\nn\n, help Shohag count, modulo\n998244353\n, the number of distinct arrays of length\nn\nthat can be obtained after performing the operations.\n∗\nThe number of inversions in an array\na\nis the number of pairs of indices (\ni\n,\nj\n) such that\ni<j\nand\na\ni\n>\na\nj\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains an integer\nn\n(\n2≤n≤\n10\n6\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output an integer — the number of possible arrays modulo\n998244353\n.\nExample\ninput\nCopy\n4\n4\n2\n7\n69\noutput\nCopy\n5\n1\n682\n325188814\nNote\nIn the first test case, the following\n5\narrays can be obtained (the inserted inversion count is shown in bold):\n[0,1]→[0,0,1]→[0,0,1,0]\n,\n[0,1]→[0,0,1]→[0,0,0,1]\n,\n[0,1]→[0,1,0]→[0,1,0,1]\n,\n[0,1]→[0,1,0]→[0,1,1,0]\n,\n[0,1]→[0,1,0]→[1,0,1,0]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "implementation",
            "math",
            "*2200"
        ]
    },
    {
        "title": "D. Shohag Loves GCD",
        "description": "Shohag has an integer\nn\nand a set\nS\nof\nm\nunique integers. Help him find the lexicographically largest\n∗\ninteger array\na\n1\n,\na\n2\n,…,\na\nn\nsuch that\na\ni\n∈S\nfor each\n1≤i≤n\nand\na\ngcd(i,j)\n≠gcd(\na\ni\n,\na\nj\n)\n†\n†\nis satisfied over all pairs\n1≤i<j≤n\n, or state that no such array exists.\n∗\nAn array\na\nis lexicographically larger than an array\nb\nof the same length if\na≠b\n, and in the first position where\na\nand\nb\ndiffer, the array\na\nhas a larger element than the corresponding element in\nb\n.\n†\n†\ngcd(x,y)\ndenotes the greatest common divisor (GCD) of integers\nx\nand\ny\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤m≤n≤\n10\n5\n).\nThe second line contains\nm\nunique integers in increasing order, representing the elements of the set\nS\n(\n1≤x≤n\nfor each\nx∈S\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, if there is no solution print\n−1\n, otherwise print\nn\nintegers — the lexicographically largest integer array that satisfies the conditions.\nExample\ninput\nCopy\n3\n6 3\n3 4 6\n1 1\n1\n2 1\n2\noutput\nCopy\n6 4 4 3 4 3 \n1 \n-1\nNote\nIn the first test case, every element in the array belongs to the given set\nS={3,4,6}\n, and all pairs of indices of the array satisfy the necessary conditions. In particular, for pair\n(2,3)\n,\na\ngcd(2,3)\n=\na\n1\n=6\nand\ngcd(\na\n2\n,\na\n3\n)=gcd(4,4)=4\n, so they are not equal. There are other arrays that satisfy the conditions as well but this one is the lexicographically largest among them.\nIn the third test case, there is no solution possible because we are only allowed to use\na=[2,2]\nbut for this array, for pair\n(1,2)\n,\na\ngcd(1,2)\n=\na\n1\n=2\nand\ngcd(\na\n1\n,\na\n2\n)=gcd(2,2)=2\n, so they are equal which is not allowed!",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1700"
        ]
    },
    {
        "title": "C2. Shohag Loves XOR (Hard Version)",
        "description": "This is the hard version of the problem. The differences between the two versions are highlighted in bold. You can only make hacks if both versions of the problem are solved.\nShohag has two integers\nx\nand\nm\n. Help him count the number of integers\n1≤y≤m\nsuch that\nx⊕y\nis divisible\n∗\nby either\nx\n,\ny\n, or both. Here\n⊕\nis the bitwise XOR operator.\n∗\nThe number\na\nis divisible by the number\nb\nif there exists an integer\nc\nsuch that\na=b⋅c\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains two space-separated integers\nx\nand\nm\n(\n1≤x≤\n10\n6\n,\n1≤m≤\n10\n18\n).\nIt is guaranteed that the sum of\nx\nover all test cases does not exceed\n10\n7\n.\nOutput\nFor each test case, print a single integer — the number of suitable\ny\n.\nExample\ninput\nCopy\n5\n7 10\n2 3\n6 4\n1 6\n4 1\noutput\nCopy\n3\n2\n2\n6\n1\nNote\nIn the first test case, for\nx=7\n, there are\n3\nvalid values for\ny\namong the integers from\n1\nto\nm=10\n, and they are\n1\n,\n7\n, and\n9\n.\ny=1\nis valid because\nx⊕y=7⊕1=6\nand\n6\nis divisible by\ny=1\n.\ny=7\nis valid because\nx⊕y=7⊕7=0\nand\n0\nis divisible by both\nx=7\nand\ny=7\n.\ny=9\nis valid because\nx⊕y=7⊕9=14\nand\n14\nis divisible by\nx=7\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "math",
            "number theory",
            "*1800"
        ]
    },
    {
        "title": "C1. Shohag Loves XOR (Easy Version)",
        "description": "This is the easy version of the problem. The differences between the two versions are highlighted in bold. You can only make hacks if both versions of the problem are solved.\nShohag has two integers\nx\nand\nm\n. Help him count the number of integers\n1≤y≤m\nsuch that\nx≠y\nand\nx⊕y\nis a divisor\n∗\nof either\nx\n,\ny\n, or both. Here\n⊕\nis the bitwise XOR operator.\n∗\nThe number\nb\nis a divisor of the number\na\nif there exists an integer\nc\nsuch that\na=b⋅c\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains two space-separated integers\nx\nand\nm\n(\n1≤x≤\n10\n6\n,\n1≤m≤\n10\n18\n).\nIt is guaranteed that the sum of\nx\nover all test cases does not exceed\n10\n7\n.\nOutput\nFor each test case, print a single integer — the number of suitable\ny\n.\nExample\ninput\nCopy\n5\n6 9\n5 7\n2 3\n6 4\n4 1\noutput\nCopy\n3\n2\n1\n1\n0\nNote\nIn the first test case, for\nx=6\n, there are\n3\nvalid values for\ny\namong the integers from\n1\nto\nm=9\n, and they are\n4\n,\n5\n, and\n7\n.\ny=4\nis valid because\nx⊕y=6⊕4=2\nand\n2\nis a divisor of both\nx=6\nand\ny=4\n.\ny=5\nis valid because\nx⊕y=6⊕5=3\nand\n3\nis a divisor of\nx=6\n.\ny=7\nis valid because\nx⊕y=6⊕7=1\nand\n1\nis a divisor of both\nx=6\nand\ny=7\n.\nIn the second test case, for\nx=5\n, there are\n2\nvalid values for\ny\namong the integers from\n1\nto\nm=7\n, and they are\n4\nand\n6\n.\ny=4\nis valid because\nx⊕y=5⊕4=1\nand\n1\nis a divisor of both\nx=5\nand\ny=4\n.\ny=6\nis valid because\nx⊕y=5⊕6=3\nand\n3\nis a divisor of\ny=6\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "B. Shohag Loves Strings",
        "description": "For a string\np\n, let\nf(p)\nbe the number of distinct non-empty substrings\n∗\nof\np\n.\nShohag has a string\ns\n. Help him find a non-empty string\np\nsuch that\np\nis a substring of\ns\nand\nf(p)\nis even or state that no such string exists.\n∗\nA string\na\nis a substring of a string\nb\nif\na\ncan be obtained from\nb\nby deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains a string\ns\n(\n1≤|s|≤\n10\n5\n) consisting of lowercase English letters.\nIt is guaranteed that the sum of the length of\ns\nover all test cases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a non-empty string that satisfies the conditions mentioned in the statement, or\n−1\nif no such string exists. If there are multiple solutions, output any.\nExample\ninput\nCopy\n5\ndcabaac\na\nyouknowwho\ncodeforces\nbangladesh\noutput\nCopy\nabaa\n-1\nyouknowwho\neforce\nbang\nNote\nIn the first test case, we can set\np=\nabaa because it is a substring of\ns\nand the distinct non-empty substrings of\np\nare a, b, aa, ab, ba, aba, baa and abaa, so it has a total of\n8\ndistinct substrings which is even.\nIn the second test case, we can only set\np=\na but it has one distinct non-empty substring but this number is odd, so not valid.\nIn the third test case, the whole string contains\n52\ndistinct non-empty substrings, so the string itself is a valid solution.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "strings",
            "*1000"
        ]
    },
    {
        "title": "A. Shohag Loves Mod",
        "description": "Shohag has an integer\nn\n. Please help him find an increasing integer sequence\n1≤\na\n1\n<\na\n2\n<…<\na\nn\n≤100\nsuch that\na\ni\nmodi≠\na\nj\nmodj\n∗\nis satisfied over all pairs\n1≤i<j≤n\n.\nIt can be shown that such a sequence always exists under the given constraints.\n∗\namodb\ndenotes the remainder of\na\nafter division by\nb\n. For example,\n7mod3=1,8mod4=0\nand\n69mod10=9\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤50\n) — the number of test cases.\nThe first and only line of each test case contains an integer\nn\n(\n2≤n≤50\n).\nOutput\nFor each test case, print\nn\nintegers — the integer sequence that satisfies the conditions mentioned in the statement. If there are multiple such sequences, output any.\nExample\ninput\nCopy\n2\n3\n6\noutput\nCopy\n2 7 8\n2 3 32 35 69 95\nNote\nIn the first test case, the sequence is increasing, values are from\n1\nto\n100\nand each pair of indices satisfies the condition mentioned in the statement:\nFor pair\n(1,2)\n,\na\n1\nmod1=2mod1=0\n, and\na\n2\nmod2=7mod2=1\n. So they are different.\nFor pair\n(1,3)\n,\na\n1\nmod1=2mod1=0\n, and\na\n3\nmod3=8mod3=2\n. So they are different.\nFor pair\n(2,3)\n,\na\n2\nmod2=7mod2=1\n, and\na\n3\nmod3=8mod3=2\n. So they are different.\nNote that you do not necessarily have to print the exact same sequence, you can print any other sequence as long as it satisfies the necessary conditions.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "N. Fixing the Expression",
        "description": "An expression is a string consisting of three characters, where the first and the last characters are digits (from\n0\nto\n9\n), and the middle character is a comparison symbol (<, = or >).\nAn expression is true if the comparison symbol matches the digits (for example, if the first digit is strictly less than the last digit, the comparison symbol should be <).\nFor example, the expressions 1<3, 4>2, 0=0 are true, while 5>5, 7<3 are not.\nYou are given a string\ns\n, which is an expression. Change as few characters as possible so that\ns\nbecomes a true expression. Note that if\ns\nis already true, you should leave it as it is.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤300\n) — the number of test cases.\nEach test case consists of one line containing the string\ns\n(\n|s|=3\n, the first and the last characters of\ns\nare digits, the second character is a comparison symbol).\nOutput\nFor each test case, print a string consisting of\n3\ncharacters — a true expression which can be obtained by changing as few characters as possible in\ns\n. If there are multiple answers, print any of them.\nExample\ninput\nCopy\n5\n3<7\n3>7\n8=9\n0=0\n5<3\noutput\nCopy\n3<7\n8>7\n8<9\n0=0\n0<3",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "M. Royal Flush",
        "description": "Consider the following game. There is a deck, which consists of cards of\nn\ndifferent suits. For each suit, there are\n13\ncards in the deck, all with different ranks (the ranks are\n2\n,\n3\n,\n4\n, ...,\n10\n, Jack, Queen, King and Ace).\nInitially, the deck is shuffled randomly (all\n(13n)!\npossible orders of cards have the same probability). You draw\n5\ntopmost cards from the deck. Then, every turn of the game, the following events happen, in the given order:\nif the cards in your hand form a Royal Flush (a\n10\n, a Jack, a Queen, a King, and an Ace, all of the same suit), you win, and the game ends;\nif you haven't won yet, and the deck is empty, you lose, and the game ends;\nif the game hasn't ended yet, you may choose any cards from your hand (possibly, all of them) and discard them. When a card is discarded, it is removed from the game;\nfinally, you draw cards from the deck, until you have\n5\ncards or the deck becomes empty.\nYour goal is to find a strategy that allows you to win in the minimum expected number of turns. Note that the turn when the game ends is not counted (for example, if the\n5\ncards you draw initially already form a Royal Flush, you win in\n0\nturns).\nCalculate the minimum possible expected number of turns required to win the game.\nInput\nThe only line contains one integer\nn\n(\n1≤n≤4\n) — the number of suits used in the game.\nOutput\nPrint the minimum expected number of turns.\nYour answer will be considered correct if its absolute or relative error does not exceed\n10\n−6\n. Formally, let your answer be\na\n, and the jury's answer be\nb\n. Your answer will be accepted if and only if\n|a−b|\nmax(1,|b|)\n≤\n10\n−6\n.\nExamples\ninput\nCopy\n1\noutput\nCopy\n3.598290598\ninput\nCopy\n2\noutput\nCopy\n8.067171309",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*2800"
        ]
    },
    {
        "title": "L. Bridge Renovation",
        "description": "Recently, Monocarp started working as a director of a park located near his house. The park is quite large, so it even has a small river splitting it into several zones. Several bridges are built across this river. Three of these bridges are especially old and need to be repaired.\nAll three bridges have the same length but differ in width. Their widths are\n18\n,\n21\nand\n25\nunits, respectively.\nDuring the park renovation process, Monocarp has to replace the old planks that served as the surface of the bridges with the new ones.\nPlanks are sold with a standard length of\n60\nunits. Monocarp already knows that he needs\nn\nplanks for each bridge. But since the bridges have different widths, he needs\nn\nplanks of length\n18\nfor the first bridge,\nn\nplanks of length\n21\nfor the second one, and\nn\nplanks of length\n25\nfor the last one.\nWorkers in charge of renovation have no problem with cutting planks into parts but refuse to join planks, since it creates weak spots and looks ugly.\nMonocarp wants to buy as few planks as possible but struggles to calculate the required number of planks. Can you help him?\nInput\nThe first and only line contains a single integer\nn\n(\n1≤n≤1000\n) — the number of planks required for each of the three bridges.\nOutput\nPrint a single integer — the minimum number of planks of standard length (\n60\nunits) Monocarp needs to cover all three bridges if the planks can be cut into parts.\nExamples\ninput\nCopy\n1\noutput\nCopy\n2\ninput\nCopy\n3\noutput\nCopy\n4\ninput\nCopy\n1000\noutput\nCopy\n1167\nNote\nIn the first example, it is possible to cut one plank of length\n60\ninto three planks with lengths\n25\n,\n18\nand\n17\n, and cut another plank of length\n60\ninto two planks with lengths\n39\nand\n21\n. That way, Monocarp will have all the required planks.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "K. Grid Walk",
        "description": "You have an\nn×n\ngrid and two integers\na\nand\nb\n. Both the rows and the columns are numbered from\n1\nto\nn\n. Let's denote the cell at the intersection of the\ni\n-th row and the\nj\n-th column as\n(i,j)\n.\nYou are standing in the cell\n(1,1)\nand want to move into the cell\n(n,n)\n.\nSuppose you are in the cell\n(i,j)\n; in one step, you can move either into the cell\n(i,j+1)\nor into the cell\n(i+1,j)\nif the corresponding cells exist.\nLet's define the cost of the cell\n(i,j)\nas\nc(i,j)=gcd(i,a)+gcd(j,b)\n(here,\ngcd(x,y)\ndenotes the greatest common divisor of\nx\nand\ny\n). The cost of the route from\n(1,1)\nto\n(n,n)\nis the sum of costs of the visited cells (including the starting cell and the finishing cell).\nFind the route with minimum possible cost and print its cost.\nInput\nThe only line contains three integers\nn\n,\na\n, and\nb\n(\n2≤n≤\n10\n6\n;\n1≤a,b≤\n10\n6\n).\nOutput\nPrint one integer — the cost of the cheapest route from\n(1,1)\nto\n(n,n)\n.\nExamples\ninput\nCopy\n4 2 4\noutput\nCopy\n21\ninput\nCopy\n10 210 420\noutput\nCopy\n125\nNote\nThe first example is described in the picture above.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "number theory",
            "*2100"
        ]
    },
    {
        "title": "J. Waiting for...",
        "description": "Monocarp is waiting for a bus at the bus stop. Unfortunately, there are many people who want to ride a bus too.\nYou are given a list of events of two types:\nB\nb\ni\n — a bus with\nb\ni\nfree seats arrives at the stop;\nP\np\ni\n —\np\ni\npeople arrive at the stop.\nThese events are listed in a chronological order.\nWhen a bus arrives, the following happens. All people at the bus stop (except for Monocarp) try to enter the bus. If there are enough free seats for all of them, then they all enter the bus. Otherwise, some people remain at the bus stop (the number of people who enter the bus is equal to the number of free seats).\nIf there is still at least one free seat after all people (except for Monocarp) enter the bus, then Monocarp can decide to enter this bus as well (but he might choose to wait for another bus). For each bus, you have to determine if it is possible for Monocarp to take that bus.\nInput\nThe first line contains one integer\nn\n(1≤n≤\n10\n3\n)\n — the number of events.\nThen,\nn\nlines follow. The\ni\n-th of them contains the description of the\ni\n-th event in one of the two following formats:\nB\nb\ni\n(\n1≤\nb\ni\n≤\n10\n6\n) — a bus with\nb\ni\nfree seats arrives at the stop;\nP\np\ni\n(\n1≤\np\ni\n≤\n10\n6\n) —\np\ni\npeople arrive at the stop.\nAdditional constraint on the input: there is at least one event of type B.\nOutput\nFor each event of type B, print YES if it is possible for Monocarp to take the corresponding bus, or NO otherwise (case-insensitive).\nExample\ninput\nCopy\n10\nP 2\nP 5\nB 8\nP 14\nB 5\nB 9\nB 3\nP 2\nB 1\nB 2\noutput\nCopy\nYES\nNO\nNO\nYES\nNO\nYES",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "I. Polyathlon",
        "description": "Berland is this year's host country of the International Collegiate Polyathlon Competition! Similar to biathlon being a competition of two sports, polyathlon is a competition of many sports. This year, there are\nm\nsports. Also, there are\nn\nparticipants in the event. The sports are numbered from\n1\nto\nm\n, and the participants are numbered from\n1\nto\nn\n.\nSome participants are skilled in multiple sports. You are given a binary matrix\nn×m\nsuch that the\nj\n-th character of the\ni\n-th row is 1 if the\ni\n-th participant is skilled in the\nj\n-th sport, and 0, otherwise. It's also known that, for each pair of participants, there exists at least one sport such that one of them is skilled in that sport and the other one isn't.\nThe order of sports in the competition is determined at the opening ceremony. Historically, it's done by the almighty Random Number Generator. A random number\nx\nfrom\n1\nto\nm\nis rolled. The competition then starts with the sport\nx\n, then the sport\n(xmodm+1)\nis played, then the sport\n((x+1)modm+1)\n, and so on.\nEach sport is played as follows. If all remaining participants (all participants which are not eliminated yet) are not skilled in that sport, everyone goes through to the next sport. Otherwise, all skilled participants go through to the next sport, and all unskilled participants are eliminated from the competition. Once there is a single participant remaining in the competition, the competition ends, and that participant is declared the winner.\nAs an organizer of the competition, you are curious of the possible outcomes of the competition beforehand (not that you are going to rig the random roll, how could you possibly think that...). For each sport\nx\n, print the index of the winner if the competition starts with the sport\nx\n.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n2≤n,m≤\n10\n6\n;\nn≤\n2\nm\n;\nnm≤2⋅\n10\n6\n) — the number of participants and the number of sports, respectively.\nThe\ni\n-th of the next\nn\nlines contains a binary string consisting of exactly\nm\ncharacters 0 or 1 — the skillset of the\ni\n-th participant. If the\nj\n-th character is 1, the\ni\n-th participant is skilled in the\nj\n-th sport. If it's 0, the\ni\n-th participant is not skilled in the\nj\n-th sport.\nAdditional constraint on the input: for each pair of participants, there exists at least one sport such that one of them is skilled in that sport and the other one isn't. In other words, all\nn\nbinary strings are pairwise distinct.\nOutput\nPrint\nm\nintegers. For each\nx\nfrom\n1\nto\nm\n, print the index of the winner if the competition starts with the sport\nx\n.\nExample\ninput\nCopy\n3 5\n10010\n01100\n10101\noutput\nCopy\n3 2 3 1 3 ",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "hashing",
            "string suffix structures",
            "strings",
            "*2500"
        ]
    },
    {
        "title": "H. Galactic Council",
        "description": "Monocarp plays a computer game. In this game, he maintains a space empire. The empire is governed by\nn\npolitical parties. Initially, every party has political power equal to\n0\n, and there is no ruling party.\nDuring each of the next\nm\nturns, the following happens:\ninitially, Monocarp has to choose which party he supports. He can support any party, except for the ruling party. When Monocarp supports a party, its political power is increased by\n1\n. If Monocarp supports the\ni\n-th party during the\nj\n-th turn, his score increases by\na\ni,j\npoints;\nthen, the elections happen, and the party with the maximum political power is chosen as the ruling party (if there are multiple such parties, the party with the lowest index among them is chosen). The former ruling party is replaced, unless it is chosen again;\nfinally, an event happens. At the end of the\nj\n-th turn, the party\np\nj\nmust be the ruling party to prevent a bad outcome of the event, otherwise Monocarp loses the game.\nDetermine which party Monocarp has to support during each turn so that he doesn't lose the game due to the events, and the score he achieves is the maximum possible. Initially, Monocarp's score is\n0\n.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n2≤n,m≤50\n) — the number of political parties and the number of turns, respectively.\nThe second line contains\nm\nintegers\np\n1\n,\np\n2\n,…,\np\nm\n(\n1≤\np\nj\n≤n\n), where\np\nj\nis the index of the party which should be the ruling party at the end of the\nj\n-th turn.\nThen\nn\nlines follow. The\ni\n-th of them contains\nm\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n1≤\na\ni,j\n≤\n10\n5\n), where\na\ni,j\nis the amount of points Monocarp gets if he supports the\ni\n-th party during the\nj\n-th turn.\nOutput\nIf Monocarp loses the game no matter how he acts, print one integer\n−1\n.\nOtherwise, print\nm\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nm\n(\n1≤\nc\nj\n≤n\n), where\nc\nj\nis the index of the party Monocarp should support during the\nj\n-th turn. If there are multiple answers, print any of them.\nExamples\ninput\nCopy\n2 3\n2 1 2\n1 2 3\n4 5 6\noutput\nCopy\n2 1 2 \ninput\nCopy\n3 5\n1 1 1 2 1\n1 1 1 1 1\n10 5 7 8 15\n7 10 9 8 15\noutput\nCopy\n1 3 2 2 1 \ninput\nCopy\n3 5\n1 1 1 1 1\n1 1 1 1 1\n10 5 7 8 15\n7 10 9 8 15\noutput\nCopy\n-1",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "flows",
            "*3000"
        ]
    },
    {
        "title": "G. Guess One Character",
        "description": "This is an interactive problem. You have to use flush operation right after printing each line. For example, in C++ you should use the function fflush(stdout) or cout.flush(), in Java or Kotlin — System.out.flush(), and in Python — sys.stdout.flush().\nThe jury has a string\ns\nconsisting of characters 0 and/or 1. The length of this string is\nn\n.\nYou can ask the following queries:\n1\nt\n— \"how many times does\nt\nappear in\ns\nas a contiguous substring?\" Here,\nt\nshould be a string consisting of characters 0 and/or 1; its length should be at least\n1\nand at most\nn\n. For example, if the string\ns\nis 111011 and the string\nt\nis 11, the response to the query is\n3\n.\nYou have to guess at least one character in the string\ns\nby asking no more than\n3\nqueries. Note that giving the answer does not count as a query.\nIn every test and in every test case, the string\ns\nis fixed beforehand.\nInteraction\nInitially, the jury program sends one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nAt the start of each test case, the jury program sends one integer\nn\n(\n2≤n≤50\n) — the length of the string.\nAfter that, your program can submit queries to the jury program by printing the following line (do not forget to flush the output after printing a line!):\n1\nt\nmeans asking a query \"how many times does\nt\nappear in\ns\nas a contiguous substring?\"\nFor every query, the jury prints one integer on a separate line. It is either:\nthe answer to your query, if the query is correct, and you haven't exceeded the query limit;\nor the integer\n−1\n, if your query is incorrect (for example, the constraint\n1≤|t|≤n\nis not met or the string\nt\ncontains characters other than 0 and 1) or if you have asked too many queries while processing the current test case.\nTo submit the answer, your program should send a line in the following format (do not forget to flush the output after printing a line!):\n0\ni\nc\n, where\n1≤i≤n\nand\nc\nis either 0 or 1, meaning that\ns\ni\n=c\n.\nIf your guess is correct, the jury program will print one integer\n1\non a separate line, indicating that you may proceed to the next test case (or terminate the program, if it was the last test case) and that the number of queries you have asked is reset. If it is not correct, the jury program will print one integer\n−1\non a separate line.\nAfter your program receives\n−1\nas the response, it should immediately terminate. This will lead to your submission receiving the verdict \"Wrong Answer\". If your program does not terminate, the verdict of your submission is undefined.\nExample\ninput\nCopy\n3     // 3 test cases\n3     // the length of the string is 3\n\n1     // 101 occurs once\n\n1     // guessed correctly\n2     // the length of the string is 2\n\n0     // 00 occurs zero times\n\n0     // 0 occurs zero times\n\n1     // guessed correctly\n2     // the length of the string is 2\n\n1     // 1 occurs once\n\n0     // 01 occurs zero times\n\n1     // guessed correctly\noutput\nCopy\n1 101 // how many times 101 occurs\n\n0 2 0 // guess: s[2] is 0\n\n\n1 00  // how many times 00 occurs\n\n1 0   // how many times 0 occurs\n\n0 1 1 // guess: s[1] is 1\n\n\n1 1   // how many times 1 occurs\n\n1 01  // how many times 01 occurs\n\n0 2 0 // guess: s[2] is 0\nNote\nIn the example, there are\n3\ntest cases: 101, 11 and 10. Note that everything after the // sign is a comment that explains which line means what in the interaction. The jury program won't print these comments in the actual problem, and you shouldn't print them. The empty lines are also added for your convenience, the jury program won't print them, and your solution should not print any empty lines.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "interactive",
            "*1900"
        ]
    },
    {
        "title": "F. Alternative Platforms",
        "description": "Suppose you are working in the Ministry of Digital Development of Berland, and your task is to monitor the industry of video blogging.\nThere are\nn\nbloggers in Berland. Recently, due to the poor state of the main video platform in Berland, two alternative platforms were introduced. That's why bloggers started to reupload their videos to these alternative platforms. You've got the statistics that the\ni\n-th blogger uploaded\nv\ni\nvideos to the first alternative platform and\nr\ni\nvideos to the second alternative platform.\nYou think that a potential user will be upset if even at least one of his favorite bloggers doesn't upload anything. However, if a blogger uploads videos to both platforms, the user will watch that blogger on the platform where more videos are available. So, you've come up with the following function to estimate user experience. Suppose a user watches\nk\nbloggers\nb\n1\n,\nb\n2\n,…,\nb\nk\n; then, let user experience be\nE(\nb\n1\n,…,\nb\nk\n)=max(\nmin\ni=1..k\nv[\nb\ni\n],\nmin\ni=1..k\nr[\nb\ni\n]).\n(\n)\nIn order to get some statistics, you want to calculate the value\navg\nk\nthat is equal to an average experience among all subsets of bloggers of size\nk\n. Also, you have to calculate\navg\nk\nfor each\nk\nfrom\n1\nto\nn\n.\nSince answers may be too large, print them modulo\n998244353\n.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of bloggers.\nThe second line contains\nn\nintegers\nv\n1\n,\nv\n2\n,…,\nv\nn\n(\n0≤\nv\ni\n≤\n10\n6\n), where\nv\ni\nis the number of videos of the\ni\n-th blogger on the first alternative platform.\nThe third line contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\n0≤\nr\ni\n≤\n10\n6\n), where\nr\ni\nis the number of videos of the\ni\n-th blogger on the second alternative platform.\nOutput\nPrint\nn\nintegers\navg\n1\n,\navg\n2\n,…,\navg\nn\n.\nIt can be proven that\navg\nk\nmay be represented as an irreducible fraction\nx\ny\nwhere\ny≢0(mod998244353)\n. So, print\navg\nk\nin a form\nx⋅\ny\n−1\nmod998244353\n.\nExamples\ninput\nCopy\n3\n2 1 2\n1 2 1\noutput\nCopy\n2 332748119 1 \ninput\nCopy\n4\n5 5 5 5\n0 0 0 0\noutput\nCopy\n5 5 5 5 \ninput\nCopy\n5\n1 9 3 7 5\n2 4 6 8 5\noutput\nCopy\n6 4 3 199648873 2 \nNote\nIn the first example,\n332748119\nis\n4\n3\n. In the third example,\n199648873\nis\n12\n5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "fft",
            "math",
            "sortings",
            "*2500"
        ]
    },
    {
        "title": "E. Barrels",
        "description": "Suppose you have\nn\nwater barrels standing in a row, numbered from\n1\nto\nn\n.\nAll barrels are equal and have a bottom area equal to one unit, so the volume of the water inside a barrel is equal to the height of the water column. Initially, the\ni\n-th barrel has\nv\ni\nunits of water.\nAdjacent barrels are connected by pipes. In other words, for each\ni\nfrom\n1\nto\nn−1\n, barrels\ni\nand\ni+1\nare connected by a single horizontal pipe at height\nh\ni\n. The widths of the pipes are negligible. These pipes allow water to flow between barrels.\nNow you want to play with barrels. Your plan is to maximize the volume of the water in the first barrel by throwing clay into barrels. In one step, you can choose any barrel and throw one unit of clay into it. One unit of clay has the same volume as one unit of water. Clay is heavier than water and doesn't mix with it, so it falls to the bottom of the barrel, distributing evenly.\nClay has a sticky structure, so it seals pipes if the clay column is high enough. More formally, suppose the pipe is at height\nh\n. If the height of the clay column is also\nh\n(or lower), the pipe is working. But the moment you add more clay into the barrel, the pipe becomes sealed instantly, preventing any water from moving between barrels.\nYou have a mountain of clay, so you can repeat the step described above any number of times. However, between the steps, you have to wait until the water reaches the new equilibrium.\nWhat is the maximum water volume you can collect in the first barrel?\nAssume that the barrels are high enough, so the water doesn't overflow, and the pipe widths are negligible.\nInput\nThe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of barrels.\nThe second line contains\nn\nintegers\nv\n1\n,\nv\n2\n,…,\nv\nn\n(\n0≤\nv\ni\n≤\n10\n6\n), where\nv\ni\nis the initial water volume in the\ni\n-th barrel.\nThe third line contains\nn−1\nintegers\nh\n1\n,\nh\n2\n,…,\nh\nn−1\n(\n1≤\nh\ni\n≤\n10\n6\n), where\nh\ni\nis the height of the pipe between the\ni\n-th and the\n(i+1)\n-st barrel.\nAdditional constraint on the input: the given water heights are in an equilibrium.\nOutput\nPrint a single number — the maximum volume of water in the first barrel. Your answer is considered correct if its absolute or relative error does not exceed\n10\n−6\n.\nFormally, let your answer be\na\n, and the jury's answer be\nb\n. Your answer is accepted if and only if\n|a−b|\nmax(1,|b|)\n≤\n10\n−6\n.\nExamples\ninput\nCopy\n2\n1 2\n2\noutput\nCopy\n2.500000000000000\ninput\nCopy\n3\n3 0 0\n6 9\noutput\nCopy\n3.000000000000000\ninput\nCopy\n5\n10 0 0 0 5\n11 1 2 5\noutput\nCopy\n11.916666666666667\nNote\nAn optimal strategy for the first example is shown in the picture below:",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "*2900"
        ]
    },
    {
        "title": "D. Divide OR Conquer",
        "description": "You are given an array\n[\na\n1\n,\na\n2\n,…\na\nn\n]\nconsisting of integers between\n0\nand\n10\n9\n. You have to split this array into several segments (possibly one) in such a way that each element belongs to exactly one segment.\nLet the first segment be the array\n[\na\nl\n1\n,\na\nl\n1\n+1\n,…,\na\nr\n1\n]\n, the second segment be\n[\na\nl\n2\n,\na\nl\n2\n+1\n,…,\na\nr\n2\n]\n, ..., the last segment be\n[\na\nl\nk\n,\na\nl\nk\n+1\n,…,\na\nr\nk\n]\n. Since every element should belong to exactly one array,\nl\n1\n=1\n,\nr\nk\n=n\n, and\nr\ni\n+1=\nl\ni+1\nfor each\ni\nfrom\n1\nto\nk−1\n. The split should meet the following condition:\nf([\na\nl\n1\n,\na\nl\n1\n+1\n,…,\na\nr\n1\n])≤f([\na\nl\n2\n,\na\nl\n2\n+1\n,…,\na\nr\n2\n])≤⋯≤f([\na\nl\nk\n,\na\nl\nk\n+1\n,…,\na\nr\nk\n])\n, where\nf(a)\nis the bitwise OR of all elements of the array\na\n.\nCalculate the number of ways to split the array, and print it modulo\n998244353\n. Two ways are considered different if the sequences\n[\nl\n1\n,\nr\n1\n,\nl\n2\n,\nr\n2\n,…,\nl\nk\n,\nr\nk\n]\ndenoting the splits are different.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the elements of the given array.\nOutput\nPrint one integer — the number of ways to split the array, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 2 3\noutput\nCopy\n4\ninput\nCopy\n5\n1000 1000 1000 1000 1000\noutput\nCopy\n16\ninput\nCopy\n3\n3 4 6\noutput\nCopy\n3\nNote\nIn the first two examples, every way to split the array is valid.\nIn the third example, there are three valid ways to split the array:\nk=3\n;\nl\n1\n=1,\nr\n1\n=1,\nl\n2\n=2,\nr\n2\n=2,\nl\n3\n=3,\nr\n3\n=3\n; the resulting arrays are\n[3]\n,\n[4]\n,\n[6]\n, and\n3≤4≤6\n;\nk=2\n;\nl\n1\n=1,\nr\n1\n=1,\nl\n2\n=2,\nr\n2\n=3\n; the resulting arrays are\n[3]\nand\n[4,6]\n, and\n3≤6\n;\nk=1\n;\nl\n1\n=1,\nr\n1\n=3\n; there will be only one array:\n[3,4,6]\n.\nIf you split the array into two arrays\n[3,4]\nand\n[6]\n, the bitwise OR of the first array is\n7\n, and the bitwise OR of the second array is\n6\n;\n7>6\n, so this way to split the array is invalid.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "data structures",
            "dp",
            "implementation",
            "*2400"
        ]
    },
    {
        "title": "C. DIY",
        "description": "You are given a list of\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n. You need to pick\n8\nelements from the list and use them as coordinates of four points. These four points should be corners of a rectangle which has its sides parallel to the coordinate axes. Your task is to pick coordinates in such a way that the resulting rectangle has the maximum possible area. The rectangle can be degenerate, i. e. its area can be\n0\n. Each integer can be used as many times as it occurs in the list (or less).\nInput\nThe first line contains one integer\nt\n(\n1≤t≤25000\n) — the number of test cases.\nThe first line of each test case contains one integer\nn\n(\n8≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print the answer as follows:\nif it is impossible to construct a rectangle which meets the constraints from the statement, print a single line containing the word NO (case-insensitive);\notherwise, in the first line, print YES (case-insensitive). In the second line, print\n8\nintegers\nx\n1\n,\ny\n1\n,\nx\n2\n,\ny\n2\n,\nx\n3\n,\ny\n3\n,\nx\n4\n,\ny\n4\n— the coordinates of the corners of the rectangle. You can print the corners in any order.\nExample\ninput\nCopy\n3\n16\n-5 1 1 2 2 3 3 4 4 5 5 6 6 7 7 10\n8\n0 0 -1 2 2 1 1 3\n8\n0 0 0 0 0 5 0 5\noutput\nCopy\nYES\n1 2 1 7 6 2 6 7\nNO\nYES\n0 0 0 5 0 0 0 5",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "geometry",
            "greedy",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "B. Make It Equal",
        "description": "You are given an integer array\na\nof size\nn\n. The elements of the array are numbered from\n1\nto\nn\n.\nYou can perform the following operation any number of times (possibly, zero): choose an index\ni\nfrom\n1\nto\nn\n; decrease\na\ni\nby\n2\nand increase\na\n(imodn)+1\nby\n1\n.\nAfter you perform the operations, all elements of the array should be non-negative equal integers.\nYour task is to calculate the minimum number of operations you have to perform.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum number of operations you have to perform. If it is impossible to make all elements of the array equal, print -1.\nExample\ninput\nCopy\n3\n2\n1 1\n3\n1 3 2\n4\n2 1 2 6\noutput\nCopy\n0\n-1\n3",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "*2100"
        ]
    },
    {
        "title": "A. Bonus Project",
        "description": "There is a team of\nn\nsoftware engineers numbered from\n1\nto\nn\n. Their boss promises to give them a bonus if they complete an additional project. The project requires\nk\nunits of work in total. The bonus promised to the\ni\n-th engineer is\na\ni\nburles. The boss doesn't assign specific tasks to engineers; it is expected that every engineer will voluntarily complete some integer amount of work units. The bonus will be paid to the entire team only if the project is completed; in other words, if the total amount of voluntary work units on the project is greater than or equal to\nk\n.\nThe amount of work that can be performed by each engineer is not limited. However, all engineers value their labour. The\ni\n-th engineer estimates one unit of their work as\nb\ni\nburles. If the bonus is paid, the benefit\ns\ni\nof the\ni\n-th engineer for completing\nc\nunits of work is defined as\ns\ni\n=\na\ni\n−c⋅\nb\ni\n. If the bonus is not paid, the engineer will not volunteer to do any work.\nEngineers work together for many years, so they know how the bonus is going to be distributed and how much their colleagues value the labour. That is, all\na\ni\nand all\nb\ni\nare known to every engineer in the team.\nEngineers are eager to get the bonus, so they agreed on the following process of work distribution between them:\nthe first engineer says: \"I will complete\nc\n1\nunits of work\", where\nc\n1\nis a non-negative integer;\nthen, the second engineer says: \"I will complete\nc\n2\nunits of work\", where\nc\n2\nis a non-negative integer;\n... and so on;\nfinally, the\nn\n-th engineer says: \"I will complete\nc\nn\nunits of work\", where\nc\nn\nis a non-negative integer.\nEvery engineer voices\nc\ni\nin a way to maximize their own benefit\ns\ni\n. If the expected benefit is going to be zero, an engineer will still agree to work to get the experience and to help their colleagues obtain the bonus. However, if the benefit is expected to be negative for some reason (an engineer needs to perform an excessive amount of work or the project is not going to be completed), that engineer will not work at all (completes zero amount of work units).\nGiven that every engineer acts perfectly, your task is to find out the numbers\nc\ni\nvoiced by every engineer.\nInput\nThe first line contains two integers\nn\nand\nk\n(\n1≤n≤1000\n;\n1≤k≤\n10\n6\n) — the number of engineers in the company and the number of work units the project requires, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the bonus which will be paid to the\ni\n-th engineer if the project is completed.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤1000\n), where\nb\ni\nis the work unit cost for the\ni\n-th engineer.\nOutput\nPrint\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n0≤\nc\ni\n≤k\n) — the amount of work completed by each engineer given that every engineer behaves optimally. Note that the answer is unique.\nExamples\ninput\nCopy\n3 6\n4 7 6\n1 2 3\noutput\nCopy\n1 3 2\ninput\nCopy\n3 12\n4 7 6\n1 2 3\noutput\nCopy\n0 0 0\ninput\nCopy\n3 11\n6 7 8\n1 2 3\noutput\nCopy\n6 3 2\nNote\nIn the first example, engineers distributed the work across them and got the bonus, even though the benefit for the third engineer is zero.\nIn the second example, the bonus project requires too many work units to complete, so it's more beneficial for engineers not to work at all.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "games",
            "greedy",
            "*1400"
        ]
    },
    {
        "title": "G. Natlan Exploring",
        "description": "You are exploring the stunning region of Natlan! This region consists of\nn\ncities, and each city is rated with an attractiveness\na\ni\n. A directed edge exists from City\ni\nto City\nj\nif and only if\ni<j\nand\ngcd(\na\ni\n,\na\nj\n)≠1\n, where\ngcd(x,y)\ndenotes the greatest common divisor (GCD) of integers\nx\nand\ny\n.\nStarting from City\n1\n, your task is to determine the total number of distinct paths you can take to reach City\nn\n, modulo\n998244353\n. Two paths are different if and only if the set of cities visited is different.\nInput\nThe first line contains an integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of cities.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n2≤\na\ni\n≤\n10\n6\n) — the attractiveness of each city.\nOutput\nOutput the total number of distinct paths you can take to reach City\nn\n, modulo\n998244353\n.\nExamples\ninput\nCopy\n5\n2 6 3 4 6\noutput\nCopy\n5\ninput\nCopy\n5\n4 196 2662 2197 121\noutput\nCopy\n2\ninput\nCopy\n7\n3 6 8 9 11 12 20\noutput\nCopy\n7\ninput\nCopy\n2\n2 3\noutput\nCopy\n0\nNote\nIn the first example, the five paths are the following:\nCity\n1→\nCity\n5\nCity\n1→\nCity\n2→\nCity\n5\nCity\n1→\nCity\n2→\nCity\n3→\nCity\n5\nCity\n1→\nCity\n2→\nCity\n4→\nCity\n5\nCity\n1→\nCity\n4→\nCity\n5\nIn the second example, the two paths are the following:\nCity\n1→\nCity\n3→\nCity\n5\nCity\n1→\nCity\n2→\nCity\n3→\nCity\n5",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "data structures",
            "dp",
            "math",
            "number theory",
            "*2000"
        ]
    },
    {
        "title": "F. Ardent Flames",
        "description": "You have obtained the new limited event character Xilonen. You decide to use her in combat.\nThere are\nn\nenemies in a line. The\ni\n'th enemy from the left has health\nh\ni\nand is currently at position\nx\ni\n. Xilonen has an attack damage of\nm\n, and you are ready to defeat the enemies with her.\nXilonen has a powerful \"ground stomp\" attack. Before you perform any attacks, you select an integer\np\nand position Xilonen there (\np\ncan be any integer position, including a position with an enemy currently). Afterwards, for each attack, she deals\nm\ndamage to an enemy at position\np\n(if there are any),\nm−1\ndamage to enemies at positions\np−1\nand\np+1\n,\nm−2\ndamage to enemies at positions\np−2\nand\np+2\n, and so on. Enemies that are at least a distance of\nm\naway from Xilonen take no damage from attacks.\nFormally, if there is an enemy at position\nx\n, she will deal\nmax(0,m−|p−x|)\ndamage to that enemy each hit. Note that you may not choose a different\np\nfor different attacks.\nOver all possible\np\n, output the minimum number of attacks Xilonen must perform to defeat at least\nk\nenemies. If it is impossible to find a\np\nsuch that eventually at least\nk\nenemies will be defeated, output\n−1\ninstead. Note that an enemy is considered to be defeated if its health reaches\n0\nor below.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) – the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤k≤n≤\n10\n5\n,\n1≤m≤\n10\n9\n).\nThe following line contains\nn\nintegers\nh\n1\n,\nh\n2\n,...,\nh\nn\n(\n1≤\nh\ni\n≤\n10\n9\n).\nThe last line of each testcase contains\nn\nintegers\nx\n1\n,\nx\n2\n,...,\nx\nn\n(\n1≤\nx\ni\n≤\n10\n9\n,\nx\ni\n<\nx\ni+1\nfor all\n1≤i<n\n)\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output an integer on a new line, the minimum number of attacks that must be performed to defeat at least\nk\nenemies. If it is impossible to find a\np\nsuch that eventually at least\nk\nenemies will be defeated, output\n−1\ninstead.\nExample\ninput\nCopy\n6\n5 5 3\n7 7 7 7 7\n1 2 3 4 5\n9 5 9\n2 4 6 8 10 8 6 4 2\n1 2 3 4 5 6 7 8 9\n2 10 2\n1 1\n1 20\n2 10 1\n69696969 420420420\n1 20\n2 10 2\n10 15\n1 19\n2 2 2\n1000000000 1\n1 3\noutput\nCopy\n2\n2\n-1\n6969697\n15\n1000000000\nNote\nIn the first testcase, it is optimal to select\np=2\n. Each attack, the first enemy takes\n5−|2−1|=4\ndamage, the second enemy takes\n5\ndamage, the third enemy takes\n4\ndamage, the fourth enemy takes\n3\ndamage, and the fifth enemy takes\n2\ndamage. After\n2\nattacks, the first three enemies will be defeated. It can be shown that it is impossible to defeat\n3\nenemies in less than\n2\nattacks, no matter which\np\nis selected.\nIn the second testcase, we must kill all\n9\nenemies. By selecting\np=5\n, all nine enemies will be defeated in\n2\nattacks.\nIn the third testcase, we must kill both enemies. However, it can be shown that no\np\nselected will damage both enemies at the same time, so the answer is\n−1\n.\nIn the fourth testcase, selecting\np=1\nwill enable us to defeat the first enemy in\n6969697\nattacks.\nIn the fifth testcase, selecting\np=10\nwill make each enemy take\n1\ndamage per attack. Both enemies will be defeated in\n15\nattacks.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "math",
            "sortings",
            "two pointers",
            "*2100"
        ]
    },
    {
        "title": "E. Kachina's Favorite Binary String",
        "description": "This is an interactive problem.\nKachina challenges you to guess her favorite binary string\n∗\ns\nof length\nn\n. She defines\nf(l,r)\nas the number of subsequences\n†\n†\nof\n01\nin\ns\nl\ns\nl+1\n…\ns\nr\n. Two subsequences are considered different if they are formed by deleting characters from different positions in the original string, even if the resulting subsequences consist of the same characters.\nTo determine\ns\n, you can ask her some questions. In each question, you can choose two indices\nl\nand\nr\n(\n1≤l<r≤n\n) and ask her for the value of\nf(l,r)\n.\nDetermine and output\ns\nafter asking Kachina no more than\nn\nquestions. However, it may be the case that\ns\nis impossible to be determined. In this case, you would need to report\nIMPOSSIBLE\ninstead.\nFormally,\ns\nis impossible to be determined if after asking\nn\nquestions, there are always multiple possible strings for\ns\n, regardless of what questions are asked. Note that if you report\nIMPOSSIBLE\nwhen there exists a sequence of at most\nn\nqueries that will uniquely determine the binary string, you will get the Wrong Answer verdict.\n∗\nA binary string only contains characters\n0\nand\n1\n.\n†\n†\nA sequence\na\nis a subsequence of a sequence\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements. For example, subsequences of\n1011101\nare\n0\n,\n1\n,\n11111\n,\n0111\n, but not\n000\nnor\n11100\n.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n4\n) — the length of\ns\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n4\n.\nInteraction\nTo ask a question, output a line in the following format (do not include quotes)\n\"\n? l r\n\" (\n1≤l<r≤n\n)\nThe jury will return an integer\nf(l,r)\n.\nWhen you are ready to print the answer, output a single line in the following format\nIf\ns\nis impossible to be determined, output \"\n! IMPOSSIBLE\n\"\nOtherwise, output \"\n! s\n\"\nAfter that, proceed to process the next test case or terminate the program if it was the last test case. Printing the answer does not count as a query.\nThe interactor is not adaptive, meaning that the answer is known before the participant asks the queries and doesn't depend on the queries asked by the participant.\nIf your program makes more than\nn\nqueries for one test case, your program should immediately terminate to receive the verdict Wrong Answer. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query do not forget to output the end of line and flush the output. Otherwise, you may get Idleness limit exceeded verdict. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo make a hack, use the following format.\nThe first line should contain a single integer\nt\n(\n1≤t≤\n10\n3\n) – the number of test cases.\nThe first line of each test case should contain an integer\nn\n(\n2≤n≤\n10\n4\n) — the length of\ns\n.\nThe following line should contain\ns\n, a binary string of length\nn\n.\nThe sum of\nn\nover all test cases should not exceed\n10\n4\n.\nExample\ninput\nCopy\n2\n5\n\n4\n\n0\n\n1\n\n2\n\n2\n\n0\noutput\nCopy\n? 1 5\n\n? 2 4\n\n? 4 5\n\n? 3 5\n\n! 01001\n\n? 1 2\n\n! IMPOSSIBLE\nNote\nIn the first test case:\nIn the first query, you ask Kachina for the value of\nf(1,5)\n, and she responds with\n4\nin the input stream.\nIn the second query, you ask Kachina for the value of\nf(2,4)\n. Because there are no subsequences of\n01\nin the string\n100\n, she responds with\n0\nin the input stream.\nAfter asking\n4\nquestions, you report\n01001\nas\ns\n, and it is correct.\nIn the second test case:\nIn the first query, you ask Kachina for the value of\nf(1,2)\n, and she responds with\n0\nin the input stream. Notice that this is the only distinct question you can ask.\nHowever, notice that the strings\n00\nand\n11\nboth have an answer of\n0\n, and it is impossible to differentiate between the two. Therefore, we report IMPOSSIBLE.\nPlease note that this example only serves to demonstrate the interaction format. It is not guaranteed the queries provided are optimal or uniquely determine the answer. However, it can be shown there exists a sequence of at most\n5\nqueries that does uniquely determine sample test case\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "interactive",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "D. Sharky Surfing",
        "description": "Mualani loves surfing on her sharky surfboard!\nMualani's surf path can be modeled by a number line. She starts at position\n1\n, and the path ends at position\nL\n. When she is at position\nx\nwith a jump power of\nk\n, she can jump to any integer position in the interval\n[x,x+k]\n. Initially, her jump power is\n1\n.\nHowever, her surf path isn't completely smooth. There are\nn\nhurdles on her path. Each hurdle is represented by an interval\n[l,r]\n, meaning she cannot jump to any position in the interval\n[l,r]\n.\nThere are also\nm\npower-ups at certain positions on the path. Power-up\ni\nis located at position\nx\ni\nand has a value of\nv\ni\n. When Mualani is at position\nx\ni\n, she has the option to collect the power-up to increase her jump power by\nv\ni\n. There may be multiple power-ups at the same position. When she is at a position with some power-ups, she may choose to take or ignore each individual power-up. No power-up is in the interval of any hurdle.\nWhat is the minimum number of power-ups she must collect to reach position\nL\nto finish the path? If it is not possible to finish the surf path, output\n−1\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nL\n(\n1≤n,m≤2⋅\n10\n5\n,3≤L≤\n10\n9\n) — the number of hurdles, the number of power-ups, and the position of the end.\nThe following\nn\nlines contain two integers\nl\ni\nand\nr\ni\n(\n2≤\nl\ni\n≤\nr\ni\n≤L−1\n) — the bounds of the interval for the\ni\n'th hurdle. It is guaranteed that\nr\ni\n+1<\nl\ni+1\nfor all\n1≤i<n\n(i.e. all hurdles are non-overlapping, sorted by increasing positions, and the end point of a previous hurdle is not consecutive with the start point of the next hurdle).\nThe following\nm\nlines contain two integers\nx\ni\nand\nv\ni\n(\n1≤\nx\ni\n,\nv\ni\n≤L\n) — the position and the value for the\ni\n'th power-up. There may be multiple power-ups with the same\nx\n. It is guaranteed that\nx\ni\n≤\nx\ni+1\nfor all\n1≤i<m\n(i.e. the power-ups are sorted by non-decreasing position) and no power-up is in the interval of any hurdle.\nIt is guaranteed the sum of\nn\nand the sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum number of power-ups she must collect to reach position\nL\n. If it is not possible, output\n−1\n.\nExample\ninput\nCopy\n4\n2 5 50\n7 14\n30 40\n2 2\n3 1\n3 5\n18 2\n22 32\n4 3 50\n4 6\n15 18\n20 26\n34 38\n1 2\n8 2\n10 2\n1 4 17\n10 14\n1 6\n1 2\n1 2\n16 9\n1 2 10\n5 9\n2 3\n2 2\noutput\nCopy\n4\n-1\n1\n2\nNote\nIn the first test case, she can collect power-ups\n1\n,\n2\n,\n3\n, and\n5\nto clear all hurdles.\nIn the second test case, she cannot jump over the first hurdle.\nIn the fourth test case, by collecting both power-ups, she can jump over the hurdle.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "two pointers",
            "*1300"
        ]
    },
    {
        "title": "C. Superultra's Favorite Permutation",
        "description": "Superultra, a little red panda, desperately wants primogems. In his dreams, a voice tells him that he must solve the following task to obtain a lifetime supply of primogems. Help Superultra!\nConstruct a permutation\n∗\np\nof length\nn\nsuch that\np\ni\n+\np\ni+1\nis composite\n†\n†\nover all\n1≤i≤n−1\n. If it's not possible, output\n−1\n.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\n†\n†\nAn integer\nx\nis composite if it has at least one other divisor besides\n1\nand\nx\n. For example,\n4\nis composite because\n2\nis a divisor.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains an integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if it's not possible to construct\np\n, output\n−1\non a new line. Otherwise, output\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\non a new line.\nExample\ninput\nCopy\n2\n3\n8\noutput\nCopy\n-1\n1 8 7 3 6 2 4 5\nNote\nIn the first example, it can be shown that all permutation of size\n3\ncontain two adjacent elements whose sum is prime. For example, in the permutation\n[2,3,1]\nthe sum\n2+3=5\nis prime.\nIn the second example, we can verify that the sample output is correct because\n1+8\n,\n8+7\n,\n7+3\n,\n3+6\n,\n6+2\n,\n2+4\n, and\n4+5\nare all composite. There may be other constructions that are correct.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ]
    },
    {
        "title": "B. Intercepted Inputs",
        "description": "To help you prepare for your upcoming Codeforces contest, Citlali set a grid problem and is trying to give you a\nn\nby\nm\ngrid through your input stream. Specifically, your input stream should contain the following:\nThe first line contains two integers\nn\nand\nm\n— the dimensions of the grid.\nThe following\nn\nlines contain\nm\nintegers each — the values of the grid.\nHowever, someone has intercepted your input stream, shuffled all given integers, and put them all on one line! Now, there are\nk\nintegers all on one line, and you don't know where each integer originally belongs. Instead of asking Citlali to resend the input, you decide to determine the values of\nn\nand\nm\nyourself.\nOutput any possible value of\nn\nand\nm\nthat Citlali could have provided.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nk\n(\n3≤k≤2⋅\n10\n5\n) — the total number of inputs in your input stream.\nThe following line of each test case contains\nk\nintegers\na\n1\n,\na\n2\n,…,\na\nk\n(\n1≤\na\ni\n≤k\n) — the shuffled inputs of your input stream. It is guaranteed that\nn\nand\nm\nare contained within the\nk\nintegers.\nIt is guaranteed that the sum of\nk\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two integers, one possible value of\nn\nand\nm\n. If multiple possible answers exist, output any.\nExample\ninput\nCopy\n5\n3\n1 1 2\n11\n3 3 4 5 6 7 8 9 9 10 11\n8\n8 4 8 3 8 2 8 1\n6\n2 1 4 5 3 3\n8\n1 2 6 3 8 5 5 3\noutput\nCopy\n1 1\n3 3\n2 3\n4 1\n1 6\nNote\nIn the first test case, the initial input could have been the following:\n1 1\n2\nIn the second test case, the initial input could have been the following:\n3 3\n4 5 6\n7 8 9\n9 10 11",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Twice",
        "description": "Kinich wakes up to the start of a new day. He turns on his phone, checks his mailbox, and finds a mysterious present. He decides to unbox the present.\nKinich unboxes an array\na\nwith\nn\nintegers. Initially, Kinich's score is\n0\n. He will perform the following operation any number of times:\nSelect two indices\ni\nand\nj\n(1≤i<j≤n)\nsuch that neither\ni\nnor\nj\nhas been chosen in any previous operation and\na\ni\n=\na\nj\n. Then, add\n1\nto his score.\nOutput the maximum score Kinich can achieve after performing the aforementioned operation any number of times.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤500\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤20\n) — the length of\na\n.\nThe following line of each test case contains\nn\nspace-separated integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nOutput\nFor each test case, output the maximum score achievable on a new line.\nExample\ninput\nCopy\n5\n1\n1\n2\n2 2\n2\n1 2\n4\n1 2 3 1\n6\n1 2 3 1 2 3\noutput\nCopy\n0\n1\n0\n1\n3\nNote\nIn the first and third testcases, Kinich cannot perform any operations.\nIn the second testcase, Kinich can perform one operation with\ni=1\nand\nj=2\n.\nIn the fourth testcase, Kinich can perform one operation with\ni=1\nand\nj=4\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "G. Library of Magic",
        "description": "This is an interactive problem.\nThe Department of Supernatural Phenomena at the Oxenfurt Academy has opened the Library of Magic, which contains the works of the greatest sorcerers of Redania —\nn\n(\n3≤n≤\n10\n18\n) types of books, numbered from\n1\nto\nn\n. Each book's type number is indicated on its spine. Moreover, each type of book is stored in the library in exactly two copies! And you have been appointed as the librarian.\nOne night, you wake up to a strange noise and see a creature leaving the building through a window. Three thick tomes of different colors were sticking out of the mysterious thief's backpack. Before you start searching for them, you decide to compute the numbers\na\n,\nb\n, and\nc\nwritten on the spines of these books. All three numbers are distinct.\nSo, you have an unordered set of tomes, which includes one tome with each of the pairwise distinct numbers\na\n,\nb\n, and\nc\n, and two tomes for all numbers from\n1\nto\nn\n, except for\na\n,\nb\n, and\nc\n. You want to find these values\na\n,\nb\n, and\nc\n.\nSince you are not working in a simple library, but in the Library of Magic, you can only use one spell in the form of a query to check the presence of books in their place:\n\"xor l r\" — Bitwise XOR query with parameters\nl\nand\nr\n. Let\nk\nbe the number of such tomes in the library whose numbers are greater than or equal to\nl\nand less than or equal to\nr\n. You will receive the result of the computation\nv\n1\n⊕\nv\n2\n⊕...⊕\nv\nk\n, where\nv\n1\n...\nv\nk\nare the numbers on the spines of these tomes, and\n⊕\ndenotes the operation of bitwise exclusive OR.\nSince your magical abilities as a librarian are severely limited, you can make no more than\n150\nqueries.\nInput\nThe first line of input contains an integer\nt\n(\n1≤t≤300\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n18\n) — the number of types of tomes.\nInteraction\nThe interaction for each test case begins with reading the integer\nn\n.\nThen you can make up to\n150\nqueries.\nTo make a query, output a string in the format \"xor l r\" (without quotes) (\n1≤l≤r≤n\n). After each query, read an integer — the answer to your query.\nTo report the answer, output a string in the format \"ans a b c\" (without quotes), where\na\n,\nb\n, and\nc\nare the numbers you found as the answer to the problem. You can output them in any order.\nThe interactor is not adaptive, which means that the answer is known before the participant makes queries and does not depend on the queries made by the participant.\nAfter making\n150\nqueries, the answer to any other query will be\n−1\n. Upon receiving such an answer, terminate the program to receive a verdict of \"WA\" (Wrong answer).\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive a verdict of \"IL\" (Idleness limit exceeded). To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nrefer to the documentation for other languages.\nHacks\nTo make a hack, use the following format.\nThe first line should contain a single integer\nt\n(\n1≤t≤300\n) — the number of test cases.\nThe only line of each test case should contain four integers\nn\n,\na\n,\nb\n, and\nc\n(\n3≤n≤\n10\n18\n,\n1≤a,b,c≤n\n) — the number of books in the library and the numbers of the stolen tomes. The numbers\na\n,\nb\n, and\nc\nmust be distinct.\nExample\ninput\nCopy\n2\n6\n\n0\n\n2\n\n3\n\n5\n\n3\noutput\nCopy\nxor 1 1\n\nxor 2 2\n\nxor 3 3\n\nxor 4 6\n\nans 2 3 5\n\nans 1 2 3\nNote\nIn the first test case, the books in the library after the theft look like this:\nNow consider the answers to the queries:\nFor the query \"xor 1 1\", you receive the result\n1⊕1=0\n. Two tomes satisfy the condition specified in the query — both with the number\n1\n.\nFor the query \"xor 2 2\", you receive the result\n2\n, as only one tome satisfies the specified condition.\nFor the query \"xor 3 3\", you receive the result\n3\n.\nFor the query \"xor 4 6\", you receive the result\n4⊕6⊕4⊕5⊕6=5\n.\nIn the second test case, there are only\n3\ntypes of books, and it is easy to guess that the missing ones have the numbers\n1\n,\n2\n, and\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "divide and conquer",
            "interactive",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "F. XORificator 3000",
        "description": "Alice has been giving gifts to Bob for many years, and she knows that what he enjoys the most is performing bitwise XOR of interesting integers. Bob considers a positive integer\nx\nto be interesting if it satisfies\nx≢k(mod\n2\ni\n)\n. Therefore, this year for his birthday, she gifted him a super-powerful \"XORificator 3000\", the latest model.\nBob was very pleased with the gift, as it allowed him to instantly compute the XOR of all interesting integers in any range from\nl\nto\nr\n, inclusive. After all, what else does a person need for happiness? Unfortunately, the device was so powerful that at one point it performed XOR with itself and disappeared. Bob was very upset, and to cheer him up, Alice asked you to write your version of the \"XORificator\".\nInput\nThe first line of input contains a single integer\nt\n(1≤t≤\n10\n4\n)\n— the number of XOR queries on the segment. The following\nt\nlines contain the queries, each consisting of the integers\nl\n,\nr\n,\ni\n,\nk\n(1≤l≤r≤\n10\n18\n,\n0≤i≤30\n,\n0≤k<\n2\ni\n)\n.\nOutput\nFor each query, output a single integer — the XOR of all integers\nx\nin the range\n[l,r]\nsuch that\nx≢kmod\n2\ni\n.\nExample\ninput\nCopy\n6\n1 3 1 0\n2 28 3 7\n15 43 1 0\n57 2007 1 0\n1010 1993 2 2\n1 1000000000 30 1543\noutput\nCopy\n2\n2\n13\n0\n4\n1000000519\nNote\nIn the first query, the interesting integers in the range\n[1,3]\nare\n1\nand\n3\n, so the answer will be\n1⊕3=2\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "number theory",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "E. Reverse the Rivers",
        "description": "A conspiracy of ancient sages, who decided to redirect rivers for their own convenience, has put the world on the brink. But before implementing their grand plan, they decided to carefully think through their strategy — that's what sages do.\nThere are\nn\ncountries, each with exactly\nk\nregions. For the\nj\n-th region of the\ni\n-th country, they calculated the value\na\ni,j\n, which reflects the amount of water in it.\nThe sages intend to create channels between the\nj\n-th region of the\ni\n-th country and the\nj\n-th region of the\n(i+1)\n-th country for all\n1≤i≤(n−1)\nand for all\n1≤j≤k\n.\nSince all\nn\ncountries are on a large slope, water flows towards the country with the highest number. According to the sages' predictions, after the channel system is created, the new value of the\nj\n-th region of the\ni\n-th country will be\nb\ni,j\n=\na\n1,j\n|\na\n2,j\n|...|\na\ni,j\n, where\n|\ndenotes the bitwise \"OR\" operation.\nAfter the redistribution of water, the sages aim to choose the most suitable country for living, so they will send you\nq\nqueries for consideration.\nEach query will contain\nm\nrequirements.\nEach requirement contains three parameters: the region number\nr\n, the sign\no\n(either \"\n<\n\" or \"\n>\n\"), and the value\nc\n. If\no\n= \"\n<\n\", then in the\nr\n-th region of the country you choose, the new value must be strictly less than the limit\nc\n, and if\no\n= \"\n>\n\", it must be strictly greater.\nIn other words, the chosen country\ni\nmust satisfy all\nm\nrequirements. If in the current requirement\no\n= \"\n<\n\", then it must hold that\nb\ni,r\n<c\n, and if\no\n= \"\n>\n\", then\nb\ni,r\n>c\n.\nIn response to each query, you should output a single integer — the number of the suitable country. If there are multiple such countries, output the smallest one. If no such country exists, output\n−1\n.\nInput\nThe first line contains three integers\nn\n,\nk\n, and\nq\n(\n1≤n,k,q≤\n10\n5\n) — the number of countries, regions, and queries, respectively.\nNext, there are\nn\nlines, where the\ni\n-th line contains\nk\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,k\n(\n1≤\na\ni,j\n≤\n10\n9\n), where\na\ni,j\nis the value of the\nj\n-th region of the\ni\n-th country.\nThen,\nq\nqueries are described.\nThe first line of each query contains a single integer\nm\n(\n1≤m≤\n10\n5\n) — the number of requirements.\nThen follow\nm\nlines, each containing an integer\nr\n, a character\no\n, and an integer\nc\n(\n1≤r≤k\n,\n0≤c≤2⋅\n10\n9\n), where\nr\nand\nc\nare the region number and the value, and\no\nis either \"\n<\n\" or \"\n>\n\" — the sign.\nIt is guaranteed that\nn⋅k\ndoes not exceed\n10\n5\nand that the sum of\nm\nacross all queries also does not exceed\n10\n5\n.\nOutput\nFor each query, output a single integer on a new line — the smallest number of the suitable country, or\n−1\nif no such country exists.\nExample\ninput\nCopy\n3 4 4\n1 3 5 9\n4 6 5 3\n2 1 2 7\n3\n1 > 4\n2 < 8\n1 < 6\n2\n1 < 8\n2 > 8\n1\n3 > 5\n2\n4 > 8\n1 < 8\noutput\nCopy\n2\n-1\n3\n1\nNote\nIn the example, the initial values of the regions are as follows:\n1\n3\n5\n9\n4\n6\n5\n3\n2\n1\n2\n7\nAfter creating the channels, the new values will look like this:\n1\n3\n5\n9\n1|4\n3|6\n5|5\n9|3\n1|4|2\n3|6|1\n5|5|2\n9|3|7\n↓\n1\n3\n5\n9\n5\n7\n5\n11\n7\n7\n7\n15\nIn the first query, it is necessary to output the minimum country number (i.e., row) where, after the redistribution of water in the first region (i.e., column), the new value will be greater than four and less than six, and in the second region it will be less than eight. Only the country with number\n2\nmeets these requirements.\nIn the second query, there are no countries that meet the specified requirements.\nIn the third query, only the country with number\n3\nis suitable.\nIn the fourth query, all three countries meet the conditions, so the answer is the smallest number\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1600"
        ]
    },
    {
        "title": "D. I Love 1543",
        "description": "One morning, Polycarp woke up and realized that\n1543\nis the most favorite number in his life.\nThe first thing that Polycarp saw that day as soon as he opened his eyes was a large wall carpet of size\nn\nby\nm\ncells;\nn\nand\nm\nare even integers. Each cell contains one of the digits from\n0\nto\n9\n.\nPolycarp became curious about how many times the number\n1543\nwould appear in all layers\n∗\nof the carpet when traversed clockwise.\n∗\nThe first layer of a carpet of size\nn×m\nis defined as a closed strip of length\n2⋅(n+m−2)\nand thickness of\n1\nelement, surrounding its outer part. Each subsequent layer is defined as the first layer of the carpet obtained by removing all previous layers from the original carpet.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The following lines describe the test cases.\nThe first line of each test case contains a pair of numbers\nn\nand\nm\n(\n2≤n,m≤\n10\n3\n,\nn,m\n — even integers).\nThis is followed by\nn\nlines of length\nm\n, consisting of digits from\n0\nto\n9\n— the description of the carpet.\nIt is guaranteed that the sum of\nn⋅m\nacross all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single number — the total number of times\n1543\nappears in all layers of the carpet in the order of traversal clockwise.\nExample\ninput\nCopy\n8\n2 4\n1543\n7777\n2 4\n7154\n8903\n2 4\n3451\n8888\n2 2\n54\n13\n2 2\n51\n43\n2 6\n432015\n512034\n4 4\n5431\n1435\n5518\n7634\n6 4\n5432\n1152\n4542\n2432\n2302\n5942\noutput\nCopy\n1\n1\n0\n1\n0\n2\n2\n2\nNote\nOccurrences of\n1543\nin the seventh example. Different layers are colored in different colors.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "matrices",
            "*1300"
        ]
    },
    {
        "title": "C. Anya and 1100",
        "description": "While rummaging through things in a distant drawer, Anya found a beautiful string\ns\nconsisting only of zeros and ones.\nNow she wants to make it even more beautiful by performing\nq\noperations on it.\nEach operation is described by two integers\ni\n(\n1≤i≤|s|\n) and\nv\n(\nv∈{0,1}\n) and means that the\ni\n-th character of the string is assigned the value\nv\n(that is, the assignment\nsi=v\nis performed).\nBut Anya loves the number\n1100\n, so after each query, she asks you to tell her whether the substring \"1100\" is present in her string (i.e. there exist such\n1≤i≤|s|−3\nthat\nsisi+1si+2si+3=1100\n).\nInput\nThe first line contains one integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of the test case contains the string\ns\n(\n1≤|s|≤2⋅105\n), consisting only of the characters \"0\" and \"1\". Here\n|s|\ndenotes the length of the string\ns\n.\nThe next line contains an integer\nq\n(\n1≤q≤2⋅105\n) — the number of queries.\nThe following\nq\nlines contain two integers\ni\n(\n1≤i≤|s|\n) and\nv\n(\nv∈{0,1}\n), describing the query.\nIt is guaranteed that the sum of\n|s|\nacross all test cases does not exceed\n2⋅105\n. It is also guaranteed that the sum of\nq\nacross all test cases does not exceed\n2⋅105\n.\nOutput\nFor each query, output \"YES\", if \"1100\" is present in Anya's string; otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n4\n100\n4\n1 1\n2 0\n2 0\n3 1\n1100000\n3\n6 1\n7 1\n4 1\n111010\n4\n1 1\n5 0\n4 1\n5 0\n0100\n4\n3 1\n1 1\n2 0\n2 1\noutput\nCopy\nNO\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nNO\nNO\nNO",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "B. Startup",
        "description": "Arseniy came up with another business plan — to sell soda from a vending machine! For this, he purchased a machine with\nn\nshelves, as well as\nk\nbottles, where the\ni\n-th bottle is characterized by the brand index\nb\ni\nand the cost\nc\ni\n.\nYou can place any number of bottles on each shelf, but all bottles on the same shelf must be of the same brand.\nArseniy knows that all the bottles he puts on the shelves of the machine will be sold. Therefore, he asked you to calculate the maximum amount he can earn.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤2⋅\n10\n5\n), where\nn\nis the number of shelves in the machine, and\nk\nis the number of bottles available to Arseniy.\nThe next\nk\nlines contain two integers\nb\ni\nand\nc\ni\n(\n1≤\nb\ni\n≤k,1≤\nc\ni\n≤1000\n) — the brand and cost of the\ni\n-th bottle.\nIt is also guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\nand that the sum of\nk\nacross all test cases also does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the maximum amount that Arseniy can earn.\nExample\ninput\nCopy\n4\n3 3\n2 6\n2 7\n1 15\n1 3\n2 6\n2 7\n1 15\n6 2\n1 7\n2 5\n190000 1\n1 1000\noutput\nCopy\n28\n15\n12\n1000\nNote\nIn the first test case, Arseniy has\n3\nshelves in the vending machine. He can place, for example, two bottles of the brand\n2\non the first shelf and a bottle of the brand\n1\non the second shelf. Then the total cost of the bottles would be\n6+7+15=28\n.\nIn the second test case, he has only one shelf. It is not difficult to show that the optimal option is to place a bottle of the brand\n1\non it. Then the total cost will be\n15\n.\nIn the third test case, he has as many as\n6\nshelves, so he can place all available bottles with a total cost of\n7+5=12\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "A. Quintomania",
        "description": "Boris Notkin composes melodies. He represents them as a sequence of notes, where each note is encoded as an integer from\n0\nto\n127\ninclusive. The interval between two notes\na\nand\nb\nis equal to\n|a−b|\nsemitones.\nBoris considers a melody perfect if the interval between each two adjacent notes is either\n5\nsemitones or\n7\nsemitones.\nAfter composing his latest melodies, he enthusiastically shows you his collection of works. Help Boris Notkin understand whether his melodies are perfect.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of melodies.\nEach melody is described by two lines.\nThe first line contains an integer\nn\n(\n2≤n≤50\n) — the number of notes in the melody.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤127\n) — the notes of the melody.\nOutput\nFor each melody, output \"YES\", if it is perfect; otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n8\n2\n114 109\n2\n17 10\n3\n76 83 88\n8\n38 45 38 80 85 92 99 106\n5\n63 58 65 58 65\n8\n117 124 48 53 48 43 54 49\n5\n95 102 107 114 121\n10\n72 77 82 75 70 75 68 75 68 75\noutput\nCopy\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nYES",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "H. Peak Productivity Forces",
        "description": "I'm peakly productive and this is deep.\nYou are given two permutations\n∗\na\nand\nb\n, both of length\nn\n.\nYou can perform the following three-step operation on permutation\na\n:\nChoose an index\ni\n(\n1≤i≤n\n).\nCyclic shift\na\n1\n,\na\n2\n,…,\na\ni−1\nby\n1\nto the right. If you had chosen\ni=1\n, then this range doesn't exist, and you cyclic shift nothing.\nCyclic shift\na\ni+1\n,\na\ni+2\n,…,\na\nn\nby\n1\nto the right. If you had chosen\ni=n\n, then this range doesn't exist, and you cyclic shift nothing.\nAfter the operation,\na\n1\n,\na\n2\n,…,\na\ni−2\n,\na\ni−1\n,\na\ni\n,\na\ni+1\n,\na\ni+2\n,…,\na\nn−1\n,\na\nn\nis transformed into\na\ni−1\n,\na\n1\n,…,\na\ni−3\n,\na\ni−2\n,\na\ni\n,\na\nn\n,\na\ni+1\n,…,\na\nn−2\n,\na\nn−1\n.\nHere are some examples of operations done on the identity permutation\n[1,2,3,4,5,6,7]\nof length\n7\n:\nIf we choose\ni=3\n, it will become\n[2,1,3,7,4,5,6]\n.\nIf we choose\ni=1\n, it will become\n[1,7,2,3,4,5,6]\n.\nIf we choose\ni=7\n, it will become\n[6,1,2,3,4,5,7]\n.\nNotably, position\ni\nis not shifted.\nFind a construction using at most\n2n\noperations to make\na\nequal to\nb\nor print\n−1\nif it is impossible. The number of operations does not need to be minimized. It can be shown that if it is possible to make\na\nequal to\nb\n, it is possible to do this within\n2n\noperations.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5⋅\n10\n5\n) — the lengths of permutations\na\nand\nb\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the values of permutation\na\n.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n) — the values of permutation\nb\n.\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case:\nIf there is a sequence of operations to transform\na\ninto\nb\n, output a single integer\nq\n(\n0≤q≤2n\n) — the number of operations in the first line and\nq\nintegers with the\ni\n-th number representing the index of the\ni\n-th operation in the second line.\nIf there is no sequence of operations, output\n−1\nin the only line.\nExample\ninput\nCopy\n4\n1\n1\n1\n2\n1 2\n2 1\n3\n2 1 3\n3 2 1\n8\n7 8 3 5 4 6 1 2\n2 1 6 4 5 3 8 7\noutput\nCopy\n0\n\n-1\n2\n1 3\n7\n3 4 5 1 2 1 1\nNote\nIn the first case, you can do no operation since\na=b\n.\nIn the second case, it can be proved\na\ncan not be transformed into\nb\n.\nIn the third case,\na\nis transformed into\n[2,3,1]\nafter the first operation and into\nb\nafter the second operation.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*3500"
        ]
    },
    {
        "title": "G2. Go Learn! (Hard Version)",
        "description": "The differences between the easy and hard versions are the constraints on\nn\nand the sum of\nn\n. In this version,\nn≤3⋅\n10\n5\nand the sum of\nn\ndoes not exceed\n10\n6\n. You can only make hacks if both versions are solved.\nWell, well, well, let's see how Bessie is managing her finances. She seems to be in the trenches! Fortunately, she is applying for a job at Moogle to resolve this issue. Moogle interviews require intensive knowledge of obscure algorithms and complex data structures, but Bessie received a tip-off from an LGM on exactly what she has to go learn.\nBessie wrote the following code to binary search for a certain element\nk\nin a possibly unsorted array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\nn\nelements.\nlet l = 1\nlet h = n\n\nwhile l < h:\n  let m = floor((l + h) / 2)\n\n  if a[m] < k:\n    l = m + 1\n  else:\n    h = m\n\nreturn l\nBessie submitted her code to Farmer John's problem with\nm\n(\n1≤m≤n\n) tests. The\ni\n-th test is of the form\n(\nx\ni\n,\nk\ni\n)\n(\n1≤x,k≤n\n). It is guaranteed all the\nx\ni\nare distinct and all the\nk\ni\nare distinct.\nTest\ni\nis correct if the following hold:\nThe\nx\ni\n-th element in the array is\nk\ni\n.\nIf Bessie calls the binary search as shown in the above code for\nk\ni\n, it will return\nx\ni\n.\nIt might not be possible for all\nm\ntests to be correct on the same array, so Farmer John will remove some of them so Bessie can AC. Let\nr\nbe the minimum of tests removed so that there exists an array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\n1≤\na\ni\n≤n\nso that all remaining tests are correct.\nIn addition to finding\nr\n, Farmer John wants you to count the number of arrays\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\n1≤\na\ni\n≤n\nsuch that there exists a way to remove exactly\nr\ntests so that all the remaining tests are correct. Since this number may be very large, please find it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤m≤n≤3⋅\n10\n5\n) denoting the number of the array and the number of tests.\nThe following\nm\nlines each contain two integers, describing the tests. The\ni\n-th line contains two integers\nx\ni\nand\nk\ni\n(\n1≤\nx\ni\n,\nk\ni\n≤n\n) denoting the index and value of the test. It is guaranteed all\nx\ni\nare distinct and all\nk\ni\nare distinct.\nIt is guaranteed the sum of\nn\nacross all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output two integers,\nr\n — the minimum of tests removed so that there exists an array so that all remaining tests are correct, and the number of arrays such that it is possible to remove\nr\ntests to make all remaining tests correct modulo\n998244353\n.\nExamples\ninput\nCopy\n2\n5 4\n1 1\n2 2\n4 3\n5 4\n5 4\n5 4\n2 5\n1 2\n3 3\noutput\nCopy\n0 1\n1 3\ninput\nCopy\n3\n6 6\n1 3\n2 5\n3 1\n4 2\n5 4\n6 6\n30 8\n19 22\n6 12\n12 1\n28 27\n3 4\n14 25\n29 14\n11 15\n300000 1\n5 10\noutput\nCopy\n3 78\n3 839271911\n0 702730519\nNote\nConsider the first example.\nIn the first test case, the array\n[1,2,2,3,4]\nsatisfies all\nm\ntests, so the minimum number of tests Bessie has to remove is\n0\n. Note that this is also the only array that satisfies all\nm\ntests.\nIn the second test case, the minimum number of tests Bessie has to remove is\n1\n. The only test Bessie can remove is\n(2,5)\n. If Bessie removes test\n(2,5)\n, then the arrays satisfying the remaining\nm−1\ntests are\n[2,2,3,1,4]\n,\n[2,2,3,2,4]\n,\n[2,2,3,3,4]\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "divide and conquer",
            "dp",
            "*3500"
        ]
    },
    {
        "title": "G1. Go Learn! (Easy Version)",
        "description": "The differences between the easy and hard versions are the constraints on\nn\nand the sum of\nn\n. In this version,\nn≤3000\nand the sum of\nn\ndoes not exceed\n10\n4\n. You can only make hacks if both versions are solved.\nWell, well, well, let's see how Bessie is managing her finances. She seems to be in the trenches! Fortunately, she is applying for a job at Moogle to resolve this issue. Moogle interviews require intensive knowledge of obscure algorithms and complex data structures, but Bessie received a tip-off from an LGM on exactly what she has to go learn.\nBessie wrote the following code to binary search for a certain element\nk\nin a possibly unsorted array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\nn\nelements.\nlet l = 1\nlet h = n\n\nwhile l < h:\n  let m = floor((l + h) / 2)\n\n  if a[m] < k:\n    l = m + 1\n  else:\n    h = m\n\nreturn l\nBessie submitted her code to Farmer John's problem with\nm\n(\n1≤m≤n\n) tests. The\ni\n-th test is of the form\n(\nx\ni\n,\nk\ni\n)\n(\n1≤x,k≤n\n). It is guaranteed all the\nx\ni\nare distinct and all the\nk\ni\nare distinct.\nTest\ni\nis correct if the following hold:\nThe\nx\ni\n-th element in the array is\nk\ni\n.\nIf Bessie calls the binary search as shown in the above code for\nk\ni\n, it will return\nx\ni\n.\nIt might not be possible for all\nm\ntests to be correct on the same array, so Farmer John will remove some of them so Bessie can AC. Let\nr\nbe the minimum of tests removed so that there exists an array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\n1≤\na\ni\n≤n\nso that all remaining tests are correct.\nIn addition to finding\nr\n, Farmer John wants you to count the number of arrays\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nwith\n1≤\na\ni\n≤n\nsuch that there exists a way to remove exactly\nr\ntests so that all the remaining tests are correct. Since this number may be very large, please find it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤m≤n≤3000\n) denoting the number of the array and the number of tests.\nThe following\nm\nlines each contain two integers, describing the tests. The\ni\n-th line contains two integers\nx\ni\nand\nk\ni\n(\n1≤\nx\ni\n,\nk\ni\n≤n\n) denoting the index and value of the test. It is guaranteed all\nx\ni\nare distinct and all\nk\ni\nare distinct.\nIt is guaranteed the sum of\nn\nacross all test cases does not exceed\n10\n4\n.\nOutput\nFor each test case, output two integers,\nr\n — the minimum of tests removed so that there exists an array so that all remaining tests are correct, and the number of arrays such that it is possible to remove\nr\ntests to make all remaining tests correct modulo\n998244353\n.\nExamples\ninput\nCopy\n2\n5 4\n1 1\n2 2\n4 3\n5 4\n5 4\n5 4\n2 5\n1 2\n3 3\noutput\nCopy\n0 1\n1 3\ninput\nCopy\n2\n6 6\n1 3\n2 5\n3 1\n4 2\n5 4\n6 6\n30 8\n19 22\n6 12\n12 1\n28 27\n3 4\n14 25\n29 14\n11 15\noutput\nCopy\n3 78\n3 839271911\nNote\nConsider the first example.\nIn the first test case, the array\n[1,2,2,3,4]\nsatisfies all\nm\ntests, so the minimum number of tests Bessie has to remove is\n0\n. Note that this is also the only array that satisfies all\nm\ntests.\nIn the second test case, the minimum number of tests Bessie has to remove is\n1\n. The only test Bessie can remove is\n(2,5)\n. If Bessie removes test\n(2,5)\n, then the arrays satisfying the remaining\nm−1\ntests are\n[2,2,3,1,4]\n,\n[2,2,3,2,4]\n,\n[2,2,3,3,4]\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "trees",
            "*3300"
        ]
    },
    {
        "title": "F. Tree Operations",
        "description": "This really says a lot about our society.\nOne day, a turtle gives you a tree with\nn\nnodes rooted at node\nx\n. Each node has an initial nonnegative value; the\ni\n-th node has starting value\na\ni\n.\nYou want to make the values of all nodes equal to\n0\n. To do so, you will perform a series of operations on the tree, where each operation will be performed on a certain node. Define an operation on node\nu\nas choosing a single node in\nu\n's subtree\n∗\nand incrementing or decrementing its value by\n1\n. The order in which operations are performed on nodes is as follows:\nFor\n1≤i≤n\n, the\ni\n-th operation will be performed on node\ni\n.\nFor\ni>n\n, the\ni\n-th operation will be performed on the same node as operation\ni−n\n.\nMore formally, the\ni\n-th operation will be performed on the\n(((i−1)modn)+1)\n-th node.\n†\n†\nNote that you cannot skip over operations; that is, you cannot perform the\ni\n-th operation without first performing operations\n1,2,…,i−1\n.\nFind the minimum number of operations you must perform before you can make the values of all nodes equal to\n0\n, assuming you pick operations optimally. If it's impossible to make the values of all nodes equal to\n0\nafter finite operations, output\n−1\n.\n∗\nThe subtree of a node\nu\nis the set of nodes for which\nu\nlies on the shortest path from this node to the root, including\nu\nitself.\n†\n†\nHere,\namodb\ndenotes the remainder from dividing\na\nby\nb\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤2000\n,\n1≤x≤n\n) — the number of nodes and the root of the tree.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the starting value of each node.\nEach of the next\nn−1\nlines of each test case contains two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) representing an undirected edge from\nu\nto\nv\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output a single integer denoting the minimum amount of operations needed to make all nodes\n0\n. If it's impossible to make all nodes\n0\n, output\n−1\n.\nExample\ninput\nCopy\n5\n2 1\n1 2\n1 2\n3 2\n2 1 3\n2 1\n3 2\n4 1\n1 1 0 1\n1 2\n2 3\n1 4\n12 6\n14 4 5 6 12 9 5 11 6 2 1 12\n3 9\n10 6\n6 12\n4 3\n3 1\n5 11\n9 7\n5 6\n1 8\n2 8\n5 1\n1 1\n0\noutput\nCopy\n3\n6\n5\n145\n0\nNote\nIn the first test case, you can make the following valid sequence of operations:\nFor operation\n1\n, decrease the value of node\n1\n. This is valid because\n(((1−1)modn)+1)=1\n, and node\n1\nis in the subtree of node\n1\n.\nFor operation\n2\n, decrease the value of node\n2\n. This is valid because\n(((2−1)modn)+1)=2\n, and node\n2\nis in the subtree of node\n2\n.\nFor operation\n3\n, decrease the value of node\n2\n. This is valid because\n(((3−1)modn)+1)=1\n, and node\n2\nis in the subtree of node\n1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dfs and similar",
            "dp",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E. Monster",
        "description": "Man, this Genshin boss is so hard. Good thing they have a top-up of\n6\ncoins for only\n$4.99\n. I should be careful and spend no more than I need to, lest my mom catches me...\nYou are fighting a monster with\nz\nhealth using a weapon with\nd\ndamage. Initially,\nd=0\n. You can perform the following operations.\nIncrease\nd\n — the damage of your weapon by\n1\n, costing\nx\ncoins.\nAttack the monster, dealing\nd\ndamage and costing\ny\ncoins.\nYou cannot perform the first operation for more than\nk\ntimes in a row.\nFind the minimum number of coins needed to defeat the monster by dealing at least\nz\ndamage.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe only line of each test case contains 4 integers\nx\n,\ny\n,\nz\n, and\nk\n(\n1≤x,y,z,k≤\n10\n8\n) — the first operation's cost, the second operation's cost, the monster's health, and the limitation on the first operation.\nOutput\nFor each test case, output the minimum number of coins needed to defeat the monster.\nExample\ninput\nCopy\n4\n2 3 5 5\n10 20 40 5\n1 60 100 10\n60 1 100 10\noutput\nCopy\n12\n190\n280\n160\nNote\nIn the first test case,\nx=2\n,\ny=3\n,\nz=5\n, and\nk=5\n. Here's a strategy that achieves the lowest possible cost of\n12\ncoins:\nIncrease damage by\n1\n, costing\n2\ncoins.\nIncrease damage by\n1\n, costing\n2\ncoins.\nIncrease damage by\n1\n, costing\n2\ncoins.\nAttack the monster, dealing\n3\ndamage, costing\n3\ncoins.\nAttack the monster, dealing\n3\ndamage, costing\n3\ncoins.\nYou deal a total of\n3+3=6\ndamage, defeating the monster who has\n5\nhealth. The total number of coins you use is\n2+2+2+3+3=12\ncoins.\nIn the second test case,\nx=10\n,\ny=20\n,\nz=40\n, and\nk=5\n. Here's a strategy that achieves the lowest possible cost of\n190\ncoins:\nIncrease damage by\n5\n, costing\n5⋅x\n=\n50\ncoins.\nAttack the monster once, dealing\n5\ndamage, costing\n20\ncoins.\nIncrease damage by\n2\n, costing\n2⋅x\n=\n20\ncoins.\nAttack the monster\n5\ntimes, dealing\n5⋅7=35\ndamage, costing\n5⋅y\n=\n100\ncoins.\nYou deal a total of\n5+35=40\ndamage, defeating the monster who has exactly\n40\nhealth. The total number of coins you use is\n50+20+20+100=190\ncoins.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "ternary search",
            "*2300"
        ]
    },
    {
        "title": "D. Yet Another Real Number Problem",
        "description": "Three r there are's in strawberry.\nYou are given an array\nb\nof length\nm\n. You can perform the following operation any number of times (possibly zero):\nChoose two distinct indices\ni\nand\nj\nwhere\n1≤i<j≤m\nand\nb\ni\nis even, divide\nb\ni\nby\n2\nand multiply\nb\nj\nby\n2\n.\nYour task is to maximize the sum of the array after performing any number of such operations. Since it could be large, output this sum modulo\n10\n9\n+7\n.\nSince this problem is too easy, you are given an array\na\nof length\nn\nand need to solve the problem for each prefix of\na\n.\nIn other words, denoting the maximum sum of\nb\nafter performing any number of such operations as\nf(b)\n, you need to output\nf([\na\n1\n])\n,\nf([\na\n1\n,\na\n2\n])\n,\n…\n,\nf([\na\n1\n,\na\n2\n,…,\na\nn\n])\nmodulo\n10\n9\n+7\nrespectively.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the starting values of array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers representing the answer for each prefix of\na\nmodulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3\n10\n1 2 3 4 5 6 7 8 9 10\n11\n1 6 9 4 7 4 4 10 3 2 3\n4\n527792568 502211460 850237282 374773208\noutput\nCopy\n1 3 8 13 46 59 126 149 1174 1311 \n1 7 22 26 70 74 150 1303 1306 1308 1568 \n527792568 83665723 399119771 773892979 \nNote\nFor each prefix in the first example, a possible array after operations is:\n[1]\nand the sum is\n1\n;\n[1,2]\nand the sum is\n3\n;\n[1,1,6]\nand the sum is\n8\n;\n[1,1,3,8]\nand the sum is\n13\n;\n[1,1,3,1,40]\nand the sum is\n46\n;\n[1,1,3,1,5,48]\nand the sum is\n59\n;\n[1,1,3,1,5,3,112]\nand the sum is\n126\n;\n[1,1,3,1,5,3,7,128]\nand the sum is\n149\n;\n[1,1,3,1,5,3,7,1,1152]\nand the sum is\n1174\n;\n[1,1,3,1,5,3,7,1,9,1280]\nand the sum is\n1311\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "greedy",
            "implementation",
            "math",
            "*1800"
        ]
    },
    {
        "title": "C. Alya and Permutation",
        "description": "Alya has been given a hard problem. Unfortunately, she is too busy running for student council. Please solve this problem for her.\nGiven an integer\nn\n, construct a permutation\np\nof integers\n1,2,…,n\nthat maximizes the value of\nk\n(which is initially\n0\n) after the following process.\nPerform\nn\noperations, on the\ni\n-th operation (\ni=1,2,…,n\n),\nIf\ni\nis odd,\nk=k&\np\ni\n, where\n&\ndenotes the bitwise AND operation.\nIf\ni\nis even,\nk=k|\np\ni\n, where\n|\ndenotes the bitwise OR operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n5≤n≤2⋅\n10\n5\n) — the length of the permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum value of\nk\nin the first line and output the permutation\np\n1\n,\np\n2\n,…,\np\nn\nin the second line.\nIf there are multiple such permutations, output any.\nExample\ninput\nCopy\n6\n5\n6\n7\n8\n9\n10\noutput\nCopy\n5\n2 1 3 4 5 \n7\n1 2 4 6 5 3 \n7\n2 4 5 1 3 6 7 \n15\n2 4 5 1 3 6 7 8 \n9\n2 4 5 6 7 1 3 8 9 \n15\n1 2 3 4 5 6 8 10 9 7 \nNote\nFor the first test case, the value of\nk\nis determined as follows:\nk=0\ninitially.\nOn the\n1\nst operation,\n1\nis odd, so Alya sets\nk\nto be\nk&\np\n1\n=0&2=0\n.\nOn the\n2\nnd operation,\n2\nis even, so Alya sets\nk\nto be\nk|\np\n2\n=0|1=1\n.\nOn the\n3\nrd operation,\n3\nis odd, so Alya sets\nk\nto be\nk&\np\n3\n=1&3=1\n.\nOn the\n4\nth operation,\n4\nis even, so Alya sets\nk\nto be\nk|\np\n4\n=1|4=5\n.\nOn the\n5\nth operation,\n5\nis odd, so Alya sets\nk\nto be\nk&\np\n5\n=5&5=5\n.\nThe final value of\nk\nis\n5\n. It can be shown that the final value of\nk\nis at most\n5\nfor all permutations of length\n5\n. Another valid output is\n[2,3,1,4,5]\n.\nFor the second test case, the final value of\nk\nis\n7\n. It can be shown that the final value of\nk\nis at most\n7\nfor all permutations of length\n6\n. Other valid outputs include\n[2,4,1,6,3,5]\nand\n[5,2,6,1,3,4]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "*1400"
        ]
    },
    {
        "title": "B. Everyone Loves Tres",
        "description": "There are 3 heroes and 3 villains, so 6 people in total.\nGiven a positive integer\nn\n. Find the smallest integer whose decimal representation has length\nn\nand consists only of\n3\ns and\n6\ns such that it is divisible by both\n33\nand\n66\n. If no such integer exists, print\n−1\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤500\n) — the length of the decimal representation.\nOutput\nFor each test case, output the smallest required integer if such an integer exists and\n−1\notherwise.\nExample\ninput\nCopy\n6\n1\n2\n3\n4\n5\n7\noutput\nCopy\n-1\n66\n-1\n3366\n36366\n3336366\nNote\nFor\nn=1\n, no such integer exists as neither\n3\nnor\n6\nis divisible by\n33\n.\nFor\nn=2\n,\n66\nconsists only of\n6\ns and it is divisible by both\n33\nand\n66\n.\nFor\nn=3\n, no such integer exists. Only\n363\nis divisible by\n33\n, but it is not divisible by\n66\n.\nFor\nn=4\n,\n3366\nand\n6666\nare divisible by both\n33\nand\n66\n, and\n3366\nis the smallest.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*900"
        ]
    },
    {
        "title": "A. Sliding",
        "description": "Red was ejected. They were not the imposter.\nThere are\nn\nrows of\nm\npeople. Let the position in the\nr\n-th row and the\nc\n-th column be denoted by\n(r,c)\n. Number each person starting from\n1\nin row-major order, i.e., the person numbered\n(r−1)⋅m+c\nis initially at\n(r,c)\n.\nThe person at\n(r,c)\ndecides to leave. To fill the gap, let the person who left be numbered\ni\n. Each person numbered\nj>i\nwill move to the position where the person numbered\nj−1\nis initially at. The following diagram illustrates the case where\nn=2\n,\nm=3\n,\nr=1\n, and\nc=2\n.\nCalculate the sum of the Manhattan distances of each person's movement. If a person was initially at\n(\nr\n0\n,\nc\n0\n)\nand then moved to\n(\nr\n1\n,\nc\n1\n)\n, the Manhattan distance is\n|\nr\n0\n−\nr\n1\n|+|\nc\n0\n−\nc\n1\n|\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each testcase contains\n4\nintegers\nn\n,\nm\n,\nr\n, and\nc\n(\n1≤r≤n≤\n10\n6\n,\n1≤c≤m≤\n10\n6\n), where\nn\nis the number of rows,\nm\nis the number of columns, and\n(r,c)\nis the position where the person who left is initially at.\nOutput\nFor each test case, output a single integer denoting the sum of the Manhattan distances.\nExample\ninput\nCopy\n4\n2 3 1 2\n2 2 2 1\n1 1 1 1\n1000000 1000000 1 1\noutput\nCopy\n6\n1\n0\n1999998000000\nNote\nFor the first test case, the person numbered\n2\nleaves, and the distances of the movements of the person numbered\n3\n,\n4\n,\n5\n, and\n6\nare\n1\n,\n3\n,\n1\n, and\n1\n, respectively. So the answer is\n1+3+1+1=6\n.\nFor the second test case, the person numbered\n3\nleaves, and the person numbered\n4\nmoves. The answer is\n1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "H. Rayan vs. Rayaneh",
        "description": "Rayan makes his final efforts to win Reyhaneh's heart by claiming he is stronger than Rayaneh (i.e., computer in Persian). To test this, Reyhaneh asks Khwarizmi for help. Khwarizmi explains that a set is integer linearly independent if no element in the set can be written as an integer linear combination of the others. Rayan is given a set of integers each time and must identify one of the largest possible integer linearly independent subsets.\nNote that a single element is always considered an integer linearly independent subset.\nAn integer linearly combination of\na\n1\n,…,\na\nk\nis any sum of the form\nc\n1\n⋅\na\n1\n+\nc\n2\n⋅\na\n2\n+…+\nc\nk\n⋅\na\nk\nwhere\nc\n1\n,\nc\n2\n,…,\nc\nk\nare integers (which may be zero, positive, or negative).\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n), the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤\n10\n5\n), the size of the set. The second line contains\nn\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n).\nThe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n6\n.\nOutput\nIn the first line of each test case print the size of the largest integer linearly independent subset.\nIn the next line, print one such subset in any order. If there are multiple valid subsets, print any one of them.\nExample\ninput\nCopy\n3\n5\n2 4 6 8 10\n5\n12 15 21 30 35\n3\n2 3 6\noutput\nCopy\n2\n4 6\n3\n35 21 30\n2\n2 3\nNote\nIn example 1,\n{4,6}\nis an integer linearly independent subset. It can be proven that there is no integer linearly independent subset with at least\n3\nelements.\nIn example 2,\n{35,21,30}\nis an integer linearly independent subset because no integer linear combination of any two elements can create the third. There is no integer linearly independent subset with at least\n4\nelements.\nIn example 3,\n{2,3,6}\nis not an integer linearly independent subset since\n6\ncan be written as\n6⋅2+(−2)⋅3\n, which is an integer linear combination of\n{2,3}\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "number theory",
            "*3300"
        ]
    },
    {
        "title": "G2. Simurgh's Watch (Hard Version)",
        "description": "The only difference between the two versions of the problem is whether overlaps are considered at all points or only at integer points.\nThe legendary Simurgh, a mythical bird, is responsible for keeping watch over vast lands, and for this purpose, she has enlisted\nn\nvigilant warriors. Each warrior is alert during a specific time segment\n[\nl\ni\n,\nr\ni\n]\n, where\nl\ni\nis the start time (included) and\nr\ni\nis the end time (included), both positive integers.\nOne of Simurgh's trusted advisors, Zal, is concerned that if multiple warriors are stationed at the same time and all wear the same color, the distinction between them might be lost, causing confusion in the watch. To prevent this, whenever multiple warriors are on guard at the same integer moment, there must be at least one color which is worn by exactly one warrior.\nSo the task is to determine the minimum number of colors required and assign a color\nc\ni\nto each warrior's segment\n[\nl\ni\n,\nr\ni\n]\nsuch that, for every (integer) time\nt\ncontained in at least one segment, there exists one color which belongs to exactly one segment containing\nt\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of warriors stationed by Simurgh.\nThe next\nn\nlines each contain two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤\n10\n9\n) — the start and end times of the warrior's watch segment.\nThe sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case:\nOutput the minimum number of colors\nk\nneeded.\nThen, output a line of\nn\nintegers\nc\ni\n(\n1≤\nc\ni\n≤k\n), where each\nc\ni\nis the color assigned to the\ni\n-th warrior.\nExample\ninput\nCopy\n3\n5\n1 4\n2 8\n3 7\n5 10\n6 9\n5\n1 5\n2 6\n3 7\n4 7\n6 7\n5\n4 9\n8 17\n2 15\n12 19\n6 13\noutput\nCopy\n2\n1 2 2 1 2\n2\n1 2 2 2 1\n3\n1 1 2 3 1\nNote\nWe can represent each warrior's watch segment as an interval on the X-axis;\nIn test case 1, the intervals can be colored as shown below (intervals are colored with the selected color; areas are colored if this color occurs exactly once at this point in time):\nIn test case 2, the intervals can be colored as shown below:\nIn test case 3, the intervals can be colored as shown below:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*3500"
        ]
    },
    {
        "title": "G1. Simurgh's Watch (Easy Version)",
        "description": "The only difference between the two versions of the problem is whether overlaps are considered at all points or only at integer points.\nThe legendary Simurgh, a mythical bird, is responsible for keeping watch over vast lands, and for this purpose, she has enlisted\nn\nvigilant warriors. Each warrior is alert during a specific time segment\n[\nl\ni\n,\nr\ni\n]\n, where\nl\ni\nis the start time (included) and\nr\ni\nis the end time (included), both positive integers.\nOne of Simurgh's trusted advisors, Zal, is concerned that if multiple warriors are stationed at the same time and all wear the same color, the distinction between them might be lost, causing confusion in the watch. To prevent this, whenever multiple warriors are on guard at the same moment (which can be non-integer), there must be at least one color which is worn by exactly one warrior.\nSo the task is to determine the minimum number of colors required and assign a color\nc\ni\nto each warrior's segment\n[\nl\ni\n,\nr\ni\n]\nsuch that, for every (real) time\nt\ncontained in at least one segment, there exists one color which belongs to exactly one segment containing\nt\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of warriors stationed by Simurgh.\nThe next\nn\nlines each contain two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤\n10\n9\n) — the start and end times of the warrior's watch segment.\nThe sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case:\nOutput the minimum number of colors\nk\nneeded.\nThen, output a line of\nn\nintegers\nc\ni\n(\n1≤\nc\ni\n≤k\n), where each\nc\ni\nis the color assigned to the\ni\n-th warrior.\nExample\ninput\nCopy\n5\n2\n1 2\n3 4\n2\n1 2\n2 3\n3\n1 4\n2 5\n3 6\n5\n1 4\n2 8\n3 7\n5 10\n6 9\n5\n1 5\n2 6\n3 7\n4 7\n6 7\noutput\nCopy\n1\n1 1\n2\n1 2\n2\n1 2 1\n3\n2 3 1 2 1\n3\n2 1 3 1 1\nNote\nWe can represent each warrior's watch segment as an interval on the X-axis;\nIn test case 1, we have two independent intervals, which can be colored with the same color.\nIn test case 2, point 2 is common to two intervals, meaning we cannot color them with the same color.\nIn test case 3, the intervals can be colored as shown below (intervals are colored with the selected color; areas are colored if this color occurs exactly once at this point in time):\nIn test case 4, the intervals can be colored as shown below:\nIn test case 5, the intervals can be colored as shown below. The image on the right demonstrates an example of incorrect coloring for this test case; there is no unique color at the moment\n5.5\n:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "sortings",
            "*3500"
        ]
    },
    {
        "title": "F2. Khayyam's Royal Decree (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions are the constraints on\nk\nand the sum of\nk\n.\nIn ancient Persia, Khayyam, a clever merchant and mathematician, is playing a game with his prized treasure chest containing\nn\nred rubies worth\n2\ndinars each and\nm\nblue sapphires worth\n1\ndinar each. He also has a satchel, which starts empty, and\nk\nscrolls with pairs\n(\nr\n1\n,\nb\n1\n),(\nr\n2\n,\nb\n2\n),…,(\nr\nk\n,\nb\nk\n)\nthat describe special conditions.\nThe game proceeds for\nn+m\nturns as follows:\nKhayyam draws a gem uniformly at random from the chest.\nHe removes the gem from the chest and places it in his satchel.\nIf there exists a scroll\ni\n(\n1≤i≤k\n) such that the chest contains exactly\nr\ni\nred rubies and\nb\ni\nblue sapphires, Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration.\nNote that the value of some gems might be affected by multiple decrees, and in that case the gems' value is doubled multiple times.\nDetermine the expected value of Khayyam's satchel at the end of the game, modulo\n998,244,353\n.\nFormally, let\nM=998,244,353\n. It can be shown that the exact answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤2⋅\n10\n5\n,\n0≤k≤5000\n) — the number of red rubies, the number of blue sapphires, and the number of scrolls describing special conditions, respectively.\nEach of the next\nk\nlines contains two integers\nr\ni\n,\nb\ni\n(\n0≤\nr\ni\n≤n\n,\n0≤\nb\ni\n≤m\n,\n1≤\nr\ni\n+\nb\ni\n≤n+m−1\n). It is guaranteed that the pairs\n(\nr\ni\n,\nb\ni\n)\nare distinct.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n2⋅\n10\n5\n, and the sum of\nk\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, print a single integer: the expected value of Khayyam's satchel at the end of the process, modulo\n998,244,353\n.\nExample\ninput\nCopy\n5\n3 4 0\n1 1 1\n1 0\n3 3 2\n1 1\n2 2\n3 3 2\n2 1\n1 2\n10 4 5\n1 0\n8 0\n6 4\n0 2\n7 4\noutput\nCopy\n10\n499122180\n798595498\n149736666\n414854846\nNote\nIn the first test case, at the end of the process, there will always be\n3\nred rubies and\n4\nblue sapphires. None of the special conditions described in the scrolls are met, so the value of Khayyam's satchel remains unchanged. The total value of the satchel at the end is always\n2⋅3+1⋅4=10\n.\nIn the second test case, consider the following two cases:\nWith probability\n1/2\n, Khayyam draws a red ruby, and the value of his satchel becomes\n2\n. Then with probability\n1\n, he draws a blue sapphire, and the value of his satchel becomes\n3\n.\nWith probability\n1/2\n, Khayyam draws a blue sapphire, and the value of his satchel becomes\n1\n. At this point, the chest contains\nr\n1\n=1\nred rubies and\nb\n1\n=0\nblue sapphires, which match the special condition described in a scroll. As a result, the value of the satchel is doubled to\n2⋅1=2\n. Then with probability\n1\n, he draws a red ruby, and the value of his satchel becomes\n4\n.\nThus, the expected value at the end is\n1\n2\n⋅3+\n1\n2\n⋅4=\n7\n2\n, which is\n499,122,180\nmodulo\n998,244,353\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "sortings",
            "*2800"
        ]
    },
    {
        "title": "F1. Khayyam's Royal Decree (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions are the constraints on\nk\nand the sum of\nk\n.\nIn ancient Persia, Khayyam, a clever merchant and mathematician, is playing a game with his prized treasure chest containing\nn\nred rubies worth\n2\ndinars each and\nm\nblue sapphires worth\n1\ndinar each. He also has a satchel, which starts empty, and\nk\nscrolls with pairs\n(\nr\n1\n,\nb\n1\n),(\nr\n2\n,\nb\n2\n),…,(\nr\nk\n,\nb\nk\n)\nthat describe special conditions.\nThe game proceeds for\nn+m\nturns as follows:\nKhayyam draws a gem uniformly at random from the chest.\nHe removes the gem from the chest and places it in his satchel.\nIf there exists a scroll\ni\n(\n1≤i≤k\n) such that the chest contains exactly\nr\ni\nred rubies and\nb\ni\nblue sapphires, Khayyam receives a royal decree that doubles the value of all the gems in his satchel as a reward for achieving a special configuration.\nNote that the value of some gems might be affected by multiple decrees, and in that case the gems' value is doubled multiple times.\nDetermine the expected value of Khayyam's satchel at the end of the game, modulo\n998,244,353\n.\nFormally, let\nM=998,244,353\n. It can be shown that the exact answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤2⋅\n10\n5\n,\n0≤k≤500\n) — the number of red rubies, the number of blue sapphires, and the number of scrolls describing special conditions, respectively.\nEach of the next\nk\nlines contains two integers\nr\ni\n,\nb\ni\n(\n0≤\nr\ni\n≤n\n,\n0≤\nb\ni\n≤m\n,\n1≤\nr\ni\n+\nb\ni\n≤n+m−1\n). It is guaranteed that the pairs\n(\nr\ni\n,\nb\ni\n)\nare distinct.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n2⋅\n10\n5\n, and the sum of\nk\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, print a single integer: the expected value of Khayyam's satchel at the end of the process, modulo\n998,244,353\n.\nExample\ninput\nCopy\n5\n3 4 0\n1 1 1\n1 0\n3 3 2\n1 1\n2 2\n3 3 2\n2 1\n1 2\n10 4 5\n1 0\n8 0\n6 4\n0 2\n7 4\noutput\nCopy\n10\n499122180\n798595498\n149736666\n414854846\nNote\nIn the first test case, at the end of the process, there will always be\n3\nred rubies and\n4\nblue sapphires. None of the special conditions described in the scrolls are met, so the value of Khayyam's satchel remains unchanged. The total value of the satchel at the end is always\n2⋅3+1⋅4=10\n.\nIn the second test case, consider the following two cases:\nWith probability\n1/2\n, Khayyam draws a red ruby, and the value of his satchel becomes\n2\n. Then with probability\n1\n, he draws a blue sapphire, and the value of his satchel becomes\n3\n.\nWith probability\n1/2\n, Khayyam draws a blue sapphire, and the value of his satchel becomes\n1\n. At this point, the chest contains\nr\n1\n=1\nred rubies and\nb\n1\n=0\nblue sapphires, which match the special condition described in a scroll. As a result, the value of the satchel is doubled to\n2⋅1=2\n. Then with probability\n1\n, he draws a red ruby, and the value of his satchel becomes\n4\n.\nThus, the expected value at the end is\n1\n2\n⋅3+\n1\n2\n⋅4=\n7\n2\n, which is\n499,122,180\nmodulo\n998,244,353\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "sortings",
            "*2500"
        ]
    },
    {
        "title": "E. Permutations Harmony",
        "description": "Rayan wants to present a gift to Reyhaneh to win her heart. However, Reyhaneh is particular and will only accept a k-harmonic set of permutations.\nWe define a k-harmonic set of permutations as a set of\nk\npairwise distinct permutations\np\n1\n,\np\n2\n,…,\np\nk\nof size\nn\nsuch that for every pair of indices\ni\nand\nj\n(where\n1≤i,j≤n\n), the following condition holds:\np\n1\n[i]+\np\n2\n[i]+…+\np\nk\n[i]=\np\n1\n[j]+\np\n2\n[j]+…+\np\nk\n[j]\n[\ni\n]\n[\ni\n]\n[\ni\n]\n[\nj\n]\n[\nj\n]\n[\nj\n]\nYour task is to help Rayan by either providing a valid k-harmonic set of permutations for given values of\nn\nand\nk\nor by determining that such a set does not exist.\nWe call a sequence of length\nn\na permutation if it contains every integer from\n1\nto\nn\nexactly once.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n), the number of test cases.\nEach test case consists of two integers\nn\nand\nk\n(\n1≤n,k≤\n10\n5\n). The sum of\nn⋅k\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, if a k-harmonic set of permutations exists, print YES on the first line. Then, print\nk\nlines, each containing a distinct permutation of the integers from\n1\nto\nn\n.\nIf no such set exists, print NO on the first line.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nIf multiple answers are possible, you can output any of them.\nExample\ninput\nCopy\n4\n3 3\n4 2\n5 1\n3 2\noutput\nCopy\nYES\n1 2 3\n2 3 1\n3 1 2\nYES\n1 2 3 4\n4 3 2 1\nNO\nYES\n1 2 3\n3 2 1\nNote\nIn example 1, we have\np\n1\n=[1,2,3]\n,\np\n2\n=[2,3,1]\n, and\np\n3\n=[3,1,2]\n. It's easy to see that\np\n1\n[1]+\np\n2\n[1]+\np\n3\n[1]=\np\n1\n[2]+\np\n2\n[2]+\np\n3\n[2]=\np\n1\n[3]+\np\n2\n[3]+\np\n3\n[3]=6\n.\nIn example 2, we have\np\n1\n=[1,2,3,4]\nand\np\n2\n=[4,3,2,1]\n. It's easy to see that\np\n1\n[1]+\np\n2\n[1]=\np\n1\n[2]+\np\n2\n[2]=\np\n1\n[3]+\np\n2\n[3]=\np\n1\n[4]+\np\n2\n[4]=5\n.\nIn example 3, as there are five distinct elements in\np\n1\n, it's obvious that the answer is \"No\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "greedy",
            "hashing",
            "math",
            "*2200"
        ]
    },
    {
        "title": "D. Darius' Wisdom",
        "description": "Darius the Great is constructing\nn\nstone columns, each consisting of a base and between\n0\n,\n1\n, or\n2\ninscription pieces stacked on top.\nIn each move, Darius can choose two columns\nu\nand\nv\nsuch that the difference in the number of inscriptions between these columns is exactly\n1\n, and transfer one inscription from the column with more inscriptions to the other one. It is guaranteed that at least one column contains exactly\n1\ninscription.\nSince beauty is the main pillar of historical buildings, Darius wants the columns to have ascending heights. To avoid excessive workers' efforts, he asks you to plan a sequence of at most\nn\nmoves to arrange the columns in non-decreasing order based on the number of inscriptions. Minimizing the number of moves is not required.\nInput\nThe first line contains an integer\nt\n— the number of test cases. (\n1≤t≤3000\n)\nThe first line of each test case contains an integer\nn\n— the number of stone columns. (\n1≤n≤2⋅\n10\n5\n)\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n, where\na\ni\n∈{0,1,2}\nrepresents the initial number of inscriptions in the\ni\n-th column. It is guaranteed that at least one column has exactly\n1\ninscription.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer\nk\n— the number of moves used to sort the columns. (\n0≤k≤n\n)\nThen, output\nk\nlines, each containing two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n), representing the indices of the columns involved in the\ni\n-th move. During each move, it must hold that\n|\na\nu\ni\n−\na\nv\ni\n|=1\n, and one inscription is transferred from the column with more inscriptions to the other.\nIt can be proven that a valid solution always exists under the given constraints.\nExample\ninput\nCopy\n3\n4\n0 2 0 1\n3\n1 2 0\n6\n0 1 1 2 2 2\noutput\nCopy\n2\n2 4\n2 3\n2\n3 1\n2 3\n0\nNote\nColumns state in the first test case:\nInitial:\n0,2,0,1\nAfter the first move:\n0,1,0,2\nAfter the second move:\n0,0,1,2\nColumns state in the second test case:\nInitial:\n1,2,0\nAfter the first move:\n0,2,1\nAfter the second move:\n0,1,2\nIn the third test case, the column heights are already sorted in ascending order.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "sortings",
            "*1600"
        ]
    },
    {
        "title": "C. Trapped in the Witch's Labyrinth",
        "description": "In the fourth labor of Rostam, the legendary hero from the Shahnameh, an old witch has created a magical maze to trap him. The maze is a rectangular grid consisting of\nn\nrows and\nm\ncolumns. Each cell in the maze points in a specific direction: up, down, left, or right. The witch has enchanted Rostam so that whenever he is in a cell, he will move to the next cell in the direction indicated by that cell.\nIf Rostam eventually exits the maze, he will be freed from the witch's enchantment and will defeat her. However, if he remains trapped within the maze forever, he will never escape.\nThe witch has not yet determined the directions for all the cells. She wants to assign directions to the unspecified cells in such a way that the number of starting cells from which Rostam will be trapped forever is maximized. Your task is to find the maximum number of starting cells which make Rostam trapped.\nInput\nThe first line of the input contains an integer\nt\n(\n1≤t≤\n10\n4\n), the number of test cases.\nFor each test case:\nThe first line contains two integers\nn\nand\nm\n(\n1≤n,m≤1000\n), representing the number of rows and columns in the maze.\nEach of the next\nn\nlines contains a string of\nm\ncharacters representing the directions in the maze. Each character is one of the following:\nU (up)\nD (down)\nL (left)\nR (right)\n? (unspecified direction)\nIt's guaranteed that the sum of\nn⋅m\nover all test cases is at most\n10\n6\n.\nOutput\nFor each test case, print a single integer, the maximum number of starting cells from which Rostam will be trapped forever after assigning directions to the unspecified cells optimally.\nExample\ninput\nCopy\n3\n3 3\nUUU\nL?R\nDDD\n2 3\n???\n???\n3 3\n?U?\nR?L\nRDL\noutput\nCopy\n0\n6\n5\nNote\nIn the first test case, all of the cells will be good no matter what you do.\nIn the second test case, if you assign the ?s like the picture below, all of the cells will be bad:\nIn the third test case, if you assign the ?s like the picture below, you will have\n5\nbad cells (red-shaded cells):",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "implementation",
            "*1400"
        ]
    },
    {
        "title": "B. Rakhsh's Revival",
        "description": "Rostam's loyal horse, Rakhsh, has seen better days. Once powerful and fast, Rakhsh has grown weaker over time, struggling to even move. Rostam worries that if too many parts of Rakhsh's body lose strength at once, Rakhsh might stop entirely. To keep his companion going, Rostam decides to strengthen Rakhsh, bit by bit, so no part of his body is too frail for too long.\nImagine Rakhsh's body as a line of spots represented by a binary string\ns\nof length\nn\n, where each\n0\nmeans a weak spot and each\n1\nmeans a strong one. Rostam's goal is to make sure that no interval of\nm\nconsecutive spots is entirely weak (all\n0\ns).\nLuckily, Rostam has a special ability called Timar, inherited from his mother Rudabeh at birth. With Timar, he can select any segment of length\nk\nand instantly strengthen all of it (changing every character in that segment to\n1\n). The challenge is to figure out the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length\nm\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n), the number of test cases.\nThe first line of each test case contains three numbers\nn\n,\nm\n,\nk\n(\n1≤m,k≤n≤2⋅\n10\n5\n). The second line of each test case contains a binary string\ns\nof\nn\ncharacters\ns\n1\ns\n2\n…\ns\nn\n. (\ns\ni\n∈{\n0,1\n}\nfor\n1≤i≤n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length\nm\n.\nExample\ninput\nCopy\n3\n5 1 1\n10101\n5 2 1\n10101\n6 3 2\n000000\noutput\nCopy\n2\n0\n1\nNote\nIn the first test case, we should apply an operation on each 0.\nIn the second test case,\ns\nis already ok.\nIn the third test case, we can perform an operation on interval\n[3,4]\nto get 001100.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ]
    },
    {
        "title": "A. King Keykhosrow's Mystery",
        "description": "There is a tale about the wise King Keykhosrow who owned a grand treasury filled with treasures from across the Persian Empire. However, to prevent theft and ensure the safety of his wealth, King Keykhosrow's vault was sealed with a magical lock that could only be opened by solving a riddle.\nThe riddle involves two sacred numbers\na\nand\nb\n. To unlock the vault, the challenger must determine the smallest key number\nm\nthat satisfies two conditions:\nm\nmust be greater than or equal to at least one of\na\nand\nb\n.\nThe remainder when\nm\nis divided by\na\nmust be equal to the remainder when\nm\nis divided by\nb\n.\nOnly by finding the smallest correct value of\nm\ncan one unlock the vault and access the legendary treasures!\nInput\nThe first line of the input contains an integer\nt\n(\n1≤t≤100\n), the number of test cases.\nEach test case consists of a single line containing two integers\na\nand\nb\n(\n1≤a,b≤1000\n).\nOutput\nFor each test case, print the smallest integer\nm\nthat satisfies the conditions above.\nExample\ninput\nCopy\n2\n4 6\n472 896\noutput\nCopy\n12\n52864\nNote\nIn the first test case, you can see that:\n4mod4=0\nbut\n4mod6=4\n5mod4=1\nbut\n5mod6=5\n6mod4=2\nbut\n6mod6=0\n7mod4=3\nbut\n7mod6=1\n8mod4=0\nbut\n8mod6=2\n9mod4=1\nbut\n9mod6=3\n10mod4=2\nbut\n10mod6=4\n11mod4=3\nbut\n11mod6=5\nso no integer less than\n12\nsatisfies the desired properties.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "chinese remainder theorem",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "G. Sakurako and Chefir",
        "description": "Given a tree with\nn\nvertices rooted at vertex\n1\n. While walking through it with her cat Chefir, Sakurako got distracted, and Chefir ran away.\nTo help Sakurako, Kosuke recorded his\nq\nguesses. In the\ni\n-th guess, he assumes that Chefir got lost at vertex\nv\ni\nand had\nk\ni\nstamina.\nAlso, for each guess, Kosuke assumes that Chefir could move along the edges an arbitrary number of times:\nfrom vertex\na\nto vertex\nb\n, if\na\nis an ancestor\n∗\nof\nb\n, the stamina will not change;\nfrom vertex\na\nto vertex\nb\n, if\na\nis not an ancestor of\nb\n, then Chefir's stamina decreases by\n1\n.\nIf Chefir's stamina is\n0\n, he cannot make a move of the second type.\nFor each assumption, your task is to find the distance to the farthest vertex that Chefir could reach from vertex\nv\ni\n, having\nk\ni\nstamina.\n∗\nVertex\na\nis an ancestor of vertex\nb\nif the shortest path from\nb\nto the root passes through\na\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case is described as follows:\nThe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nThe next\nn−1\nlines contain the edges of the tree. It is guaranteed that the given edges form a tree.\nThe next line consists of a single integer\nq\n(1≤q≤2⋅\n10\n5\n)\n, which denotes the number of guesses made by Kosuke.\nThe next\nq\nlines describe the guesses made by Kosuke, with two integers\nv\ni\n,\nk\ni\n(1≤\nv\ni\n≤n,0≤\nk\ni\n≤n)\n.\nIt is guaranteed that the sum of\nn\nand the sum of\nq\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case and for each guess, output the maximum distance to the farthest vertex that Chefir could reach from the starting point\nv\ni\nhaving\nk\ni\nstamina.\nExample\ninput\nCopy\n3\n5\n1 2\n2 3\n3 4\n3 5\n3\n5 1\n3 1\n2 0\n9\n8 1\n1 7\n1 4\n7 3\n4 9\n3 2\n1 5\n3 6\n7\n6 0\n2 3\n6 2\n8 2\n2 4\n9 2\n6 3\n6\n2 1\n2 5\n2 4\n5 6\n4 3\n3\n3 1\n1 3\n6 5\noutput\nCopy\n2 1 2 \n0 5 2 4 5 5 5 \n1 3 4 \nNote\nIn the first example:\nIn the first query, you can go from vertex\n5\nto vertex\n3\n(after which your stamina will decrease by\n1\nand become\n0\n), and then you can go to vertex\n4\n;\nIn the second query, from vertex\n3\nwith\n1\nstamina, you can only reach vertices\n2\n,\n3\n,\n4\n, and\n5\n;\nIn the third query, from vertex\n2\nwith\n0\nstamina, you can only reach vertices\n2\n,\n3\n,\n4\n, and\n5\n;",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "greedy",
            "trees",
            "*2200"
        ]
    },
    {
        "title": "F. Kosuke's Sloth",
        "description": "Kosuke is too lazy. He will not give you any legend, just the task:\nFibonacci numbers are defined as follows:\nf(1)=f(2)=1\n.\nf(n)=f(n−1)+f(n−2)\n(3≤n)\nWe denote\nG(n,k)\nas an index of the\nn\n-th Fibonacci number that is divisible by\nk\n. For given\nn\nand\nk\n, compute\nG(n,k)\n.\nAs this number can be too big, output it by modulo\n10\n9\n+7\n.\nFor example:\nG(3,2)=9\nbecause the\n3\n-rd Fibonacci number that is divisible by\n2\nis\n34\n.\n[1,1,2,3,5,8,13,21,34]\n.\nInput\nThe first line of the input data contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line contains two integers\nn\nand\nk\n(\n1≤n≤\n10\n18\n,\n1≤k≤\n10\n5\n).\nIt is guaranteed that the sum of\nk\nacross all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output the only number: the value\nG(n,k)\ntaken by modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3\n3 2\n100 1\n1000000000000 1377\noutput\nCopy\n9\n100\n999244007",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1800"
        ]
    },
    {
        "title": "E. Sakurako, Kosuke, and the Permutation",
        "description": "Sakurako's exams are over, and she did excellently. As a reward, she received a permutation\np\n. Kosuke was not entirely satisfied because he failed one exam and did not receive a gift. He decided to sneak into her room (thanks to the code for her lock) and spoil the permutation so that it becomes simple.\nA permutation\np\nis considered simple if for every\ni\n(1≤i≤n)\none of the following conditions holds:\np\ni\n=i\np\np\ni\n=i\nFor example, the permutations\n[1,2,3,4]\n,\n[5,2,4,3,1]\n, and\n[2,1]\nare simple, while\n[2,3,1]\nand\n[5,2,1,4,3]\nare not.\nIn one operation, Kosuke can choose indices\ni,j\n(1≤i,j≤n)\nand swap the elements\np\ni\nand\np\nj\n.\nSakurako is about to return home. Your task is to calculate the minimum number of operations that Kosuke needs to perform to make the permutation simple.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case is described by two lines.\nThe first line contains one integer\nn\n(\n1≤n≤\n10\n6\n) — the length of the permutation\np\n.\nThe second line contains\nn\nintegers\np\ni\n(\n1≤\np\ni\n≤n\n) — the elements of the permutation\np\n.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n10\n6\n.\nIt is guaranteed that\np\nis a permutation.\nOutput\nFor each test case, output the minimum number of operations that Kosuke needs to perform to make the permutation simple.\nExample\ninput\nCopy\n6\n5\n1 2 3 4 5\n5\n5 4 3 2 1\n5\n2 3 4 5 1\n4\n2 3 4 1\n3\n1 3 2\n7\n2 3 1 5 6 7 4\noutput\nCopy\n0\n0\n2\n1\n0\n2\nNote\nIn the first and second examples, the permutations are already simple.\nIn the fourth example, it is sufficient to swap\np\n2\nand\np\n4\n. Thus, the permutation will become\n[2,1,4,3]\nin\n1\noperation.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "greedy",
            "math",
            "*1400"
        ]
    },
    {
        "title": "D. Kousuke's Assignment",
        "description": "After a trip with Sakurako, Kousuke was very scared because he forgot about his programming assignment. In this assignment, the teacher gave him an array\na\nof\nn\nintegers and asked him to calculate the number of non-overlapping segments of the array\na\n, such that each segment is considered beautiful.\nA segment\n[l,r]\nis considered beautiful if\na\nl\n+\na\nl+1\n+⋯+\na\nr−1\n+\na\nr\n=0\n.\nFor a fixed array\na\n, your task is to compute the maximum number of non-overlapping beautiful segments.\nInput\nThe first line of input contains the number\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Each test case consists of\n2\nlines.\nThe first line contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array.\nThe second line contains\nn\nintegers\na\ni\n(\n−\n10\n5\n≤\na\ni\n≤\n10\n5\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum number of non-overlapping beautiful segments.\nExample\ninput\nCopy\n3\n5\n2 1 -3 2 1\n7\n12 -4 4 43 -3 -5 8\n6\n0 -4 0 3 0 1\noutput\nCopy\n1\n2\n3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "dsu",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "C. Sakurako's Field Trip",
        "description": "Even in university, students need to relax. That is why Sakurakos teacher decided to go on a field trip. It is known that all of the students will be walking in one line. The student with index\ni\nhas some topic of interest which is described as\na\ni\n. As a teacher, you want to minimise the disturbance of the line of students.\nThe disturbance of the line is defined as the number of neighbouring people with the same topic of interest. In other words, disturbance is the number of indices\nj\n(\n1≤j<n\n) such that\na\nj\n=\na\nj+1\n.\nIn order to do this, you can choose index\ni\n(\n1≤i≤n\n) and swap students at positions\ni\nand\nn−i+1\n. You can perform any number of swaps.\nYour task is to determine the minimal amount of disturbance that you can achieve by doing the operation described above any number of times.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case is described by two lines.\nThe first line contains one integer\nn\n(\n2≤n≤\n10\n5\n) — the length of the line of students.\nThe second line contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤n\n) — the topics of interest of students in line.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the minimal possible disturbance of the line that you can achieve.\nExample\ninput\nCopy\n9\n5\n1 1 1 2 3\n6\n2 1 2 2 1 1\n4\n1 2 1 1\n6\n2 1 1 2 2 4\n4\n2 1 2 3\n6\n1 2 2 1 2 1\n5\n4 5 5 1 5\n7\n1 4 3 5 1 1 3\n7\n3 1 3 2 2 3 3\noutput\nCopy\n1\n2\n1\n0\n0\n1\n1\n0\n2\nNote\nIn the first example, it is necessary to apply the operation to\ni=2\n, thus the array will become\n[1,2,1,1,3]\n, with the bold elements indicating those that have swapped places. The disturbance of this array is equal to\n1\n.\nIn the fourth example, it is sufficient to apply the operation to\ni=3\n, thus the array will become\n[2,1,2,1,2,4]\n. The disturbance of this array is equal to\n0\n.\nIn the eighth example, it is sufficient to apply the operation to\ni=3\n, thus the array will become\n[1,4,1,5,3,1,3]\n. The disturbance of this array is equal to\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "B. Sakurako and Water",
        "description": "During her journey with Kosuke, Sakurako and Kosuke found a valley that can be represented as a matrix of size\nn×n\n, where at the intersection of the\ni\n-th row and the\nj\n-th column is a mountain with a height of\na\ni,j\n. If\na\ni,j\n<0\n, then there is a lake there.\nKosuke is very afraid of water, so Sakurako needs to help him:\nWith her magic, she can select a square area of mountains and increase the height of each mountain on the main diagonal of that area by exactly one.\nMore formally, she can choose a submatrix with the upper left corner located at\n(i,j)\nand the lower right corner at\n(p,q)\n, such that\np−i=q−j\n. She can then add one to each element at the intersection of the\n(i+k)\n-th row and the\n(j+k)\n-th column, for all\nk\nsuch that\n0≤k≤p−i\n.\nDetermine the minimum number of times Sakurako must use her magic so that there are no lakes.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases.\nEach test case is described as follows:\nThe first line of each test case consists of a single number\nn\n(\n1≤n≤500\n).\nEach of the following\nn\nlines consists of\nn\nintegers separated by spaces, which correspond to the heights of the mountains in the valley\na\n(\n−\n10\n5\n≤\na\ni,j\n≤\n10\n5\n).\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output the minimum number of times Sakurako will have to use her magic so that all lakes disappear.\nExample\ninput\nCopy\n4\n1\n1\n2\n-1 2\n3 0\n3\n1 2 3\n-2 1 -1\n0 0 -1\n5\n1 1 -1 -1 3\n-3 1 4 4 -4\n-1 -1 3 0 -5\n4 5 3 -3 -1\n3 1 -3 -1 5\noutput\nCopy\n0\n1\n4\n19",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "*900"
        ]
    },
    {
        "title": "A. Sakurako and Kosuke",
        "description": "Sakurako and Kosuke decided to play some games with a dot on a coordinate line. The dot is currently located in position\nx=0\n. They will be taking turns, and Sakurako will be the one to start.\nOn the\ni\n-th move, the current player will move the dot in some direction by\n2⋅i−1\nunits. Sakurako will always be moving the dot in the negative direction, whereas Kosuke will always move it in the positive direction.\nIn other words, the following will happen:\nSakurako will change the position of the dot by\n−1\n,\nx=−1\nnow\nKosuke will change the position of the dot by\n3\n,\nx=2\nnow\nSakurako will change the position of the dot by\n−5\n,\nx=−3\nnow\n⋯\nThey will keep on playing while the absolute value of the coordinate of the dot does not exceed\nn\n. More formally, the game continues while\n−n≤x≤n\n. It can be proven that the game will always end.\nYour task is to determine who will be the one who makes the last turn.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤100\n) — the number of games that Sakurako and Kosuke played.\nEach game is described by one number\nn\n(\n1≤n≤100\n) — the number that defines the condition when the game ends.\nOutput\nFor each of the\nt\ngames, output a line with the result of that game. If Sakurako makes the last turn, output \"Sakurako\" (without quotes); else output \"Kosuke\".\nExample\ninput\nCopy\n4\n1\n6\n3\n98\noutput\nCopy\nKosuke\nSakurako\nKosuke\nSakurako",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Peanuts",
        "description": "Having the magical beanstalk, Jack has been gathering a lot of peanuts lately. Eventually, he has obtained\nn\npockets of peanuts, conveniently numbered\n1\nto\nn\nfrom left to right. The\ni\n-th pocket has\na\ni\npeanuts.\nJack and his childhood friend Alice decide to play a game around the peanuts. First, Alice divides the pockets into some boxes; each box will have a non-zero number of consecutive pockets, and each pocket will, obviously, belong to exactly one box. At the same time, Alice does not change the order of the boxes, that is, the boxes are numbered in ascending order of the indices of the pockets in them.\nAfter that, Alice and Jack will take turns alternately, with Alice going first.\nAt each turn, the current player will remove a positive number of peanuts from exactly one pocket which belongs to the leftmost non-empty box (i.e., the leftmost box containing at least one non-empty pocket). In other words, if we number the boxes from left to right, then each player can only pick peanuts from the pocket in the\nj\n-th box (\nj≥2\n) only if the\n(j−1)\n-th box has no peanuts left. The player who cannot make a valid move loses.\nAlice is sure she will win since she has the advantage of dividing the pockets into boxes herself. Thus, she wanted to know how many ways there are for her to divide the peanuts into boxes at the start of the game so that she will win, assuming both players play optimally. Can you help her with the calculation?\nAs the result can be very large, output it modulo\n998244353\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the number of pockets.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of peanuts in each pocket.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the number of ways for Alice to divide the pockets into boxes at the start of the game to guarantee her win, assuming both players play optimally, modulo\n998244353\n.\nExample\ninput\nCopy\n5\n3\n1 2 3\n4\n1 2 3 1\n5\n1 1 1 1 1\n2\n1 1\n10\n1 2 3 4 5 6 7 8 9 10\noutput\nCopy\n1\n4\n16\n0\n205\nNote\nIn the first test case, the only way for Alice to win is to divide the pockets into two boxes as follows:\n([1,2],[3])\n(the first box contains the first two pockets and the second box contains the third pocket). Alice wins by taking both peanuts from the second pocket, leaving Jack with\n([1],[3])\n. Jack is forced to take the only peanut left in the first box, which allows Alice to take the remaining ones in the second box.\nIn the second test case, the winning divisions for Alice are\n([1],[2,3,1])\n,\n([1,2,3,1])\n,\n([1,2],[3],[1])\n, and\n([1,2],[3,1])\n.\nIn the third test case, Alice always wins no matter how she divides the pockets into boxes.\nIn the fourth test case, Alice always loses no matter how she divides the pockets into boxes.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "games",
            "math",
            "*2700"
        ]
    },
    {
        "title": "E. Balanced",
        "description": "You are given a cyclic array\na\nwith\nn\nelements, where\nn\nis odd. In each operation, you can do the following:\nChoose an index\n1≤i≤n\nand increase\na\ni−1\nby\n1\n,\na\ni\nby\n2\n, and\na\ni+1\nby\n1\n. The element before the first element is the last element because this is a cyclic array.\nA cyclic array is called balanced if all its elements are equal to each other.\nFind any sequence of operations to make this cyclic array balanced or determine that it is impossible. Please note that you do not have to minimize the number of operations.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n<2⋅\n10\n5\n,\nn\nis odd) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case:\nIf it is impossible to make the cyclic array balanced, output\n−1\n.\nOtherwise, output\nn\nintegers\nv\n1\n,\nv\n2\n,…,\nv\nn\n(\n0≤\nv\ni\n≤\n10\n18\n) — where\nv\ni\ndenotes the number of operations applied to index\ni\n. It can be proved that if any solution exists, then there exists a solution under the given constraints. If there are several solutions under the given constraints, output any of them.\nExample\ninput\nCopy\n6\n3\n2 1 2\n3\n1 2 3\n5\n1 2 1 2 1\n7\n1 2 1 2 1 3 1\n9\n10000 10000 10000 10000 10000 10001 10002 10001 10000\n1\n10\noutput\nCopy\n0 1 0 \n2 1 0 \n2 0 3 0 2 \n4 2 7 0 8 0 6 \n1 1 1 1 1 1 0 1 1 \n0 \nNote\nIn the first test case:\nAfter\n1\noperation applied to index\ni=2\n, the array\na=[3,3,3]\n.\nIn the second test case:\nAfter\n2\noperations applied to index\ni=1\n, the array\na=[5,4,5]\n.\nAfter\n1\noperation applied to index\ni=2\n, the array\na=[6,6,6]\n.\nIn the third test case:\nAfter\n2\noperations applied to index\ni=1\n, the array\na=[5,4,1,2,3]\n.\nAfter\n3\noperations applied to index\ni=3\n, the array\na=[5,7,7,5,3]\n.\nAfter\n2\noperations applied to index\ni=5\n, the array\na=[7,7,7,7,7]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "*2400"
        ]
    },
    {
        "title": "D. Genokraken",
        "description": "This is an interactive problem.\nUpon clearing the Waterside Area, Gretel has found a monster named Genokraken, and she's keeping it contained for her scientific studies.\nThe monster's nerve system can be structured as a tree\n†\n†\nof\nn\nnodes (really, everything should stop resembling trees all the time\n…\n), numbered from\n0\nto\nn−1\n, with node\n0\nas the root.\nGretel's objective is to learn the exact structure of the monster's nerve system — more specifically, she wants to know the values\np\n1\n,\np\n2\n,…,\np\nn−1\nof the tree, where\np\ni\n(\n0≤\np\ni\n<i\n) is the direct parent node of node\ni\n(\n1≤i≤n−1\n).\nShe doesn't know exactly how the nodes are placed, but she knows a few convenient facts:\nIf we remove root node\n0\nand all adjacent edges, this tree will turn into a forest consisting of only paths\n‡\n‡\n. Each node that was initially adjacent to the node\n0\nwill be the end of some path.\nThe nodes are indexed in a way that if\n1≤x≤y≤n−1\n, then\np\nx\n≤\np\ny\n.\nNode\n1\nhas exactly two adjacent nodes (including the node\n0\n).\nThe tree in this picture does not satisfy the condition, because if we remove node\n0\n, then node\n2\n(which was initially adjacent to the node\n0\n) will not be the end of the path\n4−2−5\n. The tree in this picture does not satisfy the condition, because\np\n3\n≤\np\n4\nmust hold. The tree in this picture does not satisfy the condition, because node\n1\nhas only one adjacent node.\nGretel can make queries to the containment cell:\n\"? a b\" (\n1≤a,b<n\n,\na≠b\n) — the cell will check if the simple path between nodes\na\nand\nb\ncontains the node\n0\n.\nHowever, to avoid unexpected consequences by overstimulating the creature, Gretel wants to query at most\n2n−6\ntimes. Though Gretel is gifted, she can't do everything all at once, so can you give her a helping hand?\n†\n†\nA tree is a connected graph where every pair of distinct nodes has exactly one simple path connecting them.\n‡\n‡\nA path is a tree whose vertices can be listed in the order\nv\n1\n,\nv\n2\n,…,\nv\nk\nsuch that the edges are\n(\nv\ni\n,\nv\ni+1\n)\n(\n1≤i<k\n).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n4≤n≤\n10\n4\n) — the number of nodes in Genokraken's nerve system.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n4\n.\nInteraction\nFor each test case, interaction starts by reading the integer\nn\n.\nThen you can make queries of the following type:\n\"? a b\" (without quotes) (\n1≤a,b<n\n,\na≠b\n).\nAfter the query, read an integer\nr\n — the answer to your query. You are allowed to use at most\n2n−6\nqueries of this type.\nIf the simple path between nodes\na\nand\nb\ndoes not contain node\n0\n, you will get\nr=0\n.\nIf the simple path between nodes\na\nand\nb\ncontains node\n0\n, you will get\nr=1\n.\nIn case you make more than\n2n−6\nqueries or make an invalid query, you will get\nr=−1\n. You will need to terminate after this to get the \"Wrong answer\" verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nWhen you find out the structure, output a line in the format \"!\np\n1\n p\n2\n…\np\nn−1\n\" (without quotes), where\np\ni\n(\n0≤\np\ni\n<i\n) denotes the index of the direct parent of node\ni\n. This query is not counted towards the\n2n−6\nqueries limit.\nAfter solving one test case, the program should immediately move on to the next one. After solving all test cases, the program should be terminated immediately.\nAfter printing any query do not forget to output an end of line and flush the output buffer. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nThe interactor is non-adaptive. The tree does not change during the interaction.\nHacks\nFor hack, use the following format:\nThe first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n4≤n≤\n10\n4\n) — the number of nodes in Genokraken's nerve system.\nThe second line of each test case contains\nn−1\nintegers\np\n1\n,\np\n2\n,…,\np\nn−1\n(\n0≤\np\n1\n≤\np\n2\n≤…≤\np\nn−1\n≤n−2\n,\n0≤\np\ni\n<i\n) — the direct parents of node\n1\n,\n2\n, ...,\nn−1\nin the system, respectively.\nIn each test case, the values\np\n1\n,\np\n2\n,…,\np\nn−1\nmust ensure the following in the tree:\nIf we remove root node\n0\nand all adjacent edges, this tree will turn into a forest consisting of only paths. Each node that was initially adjacent to the node\n0\nwill be the end of some path.\nNode\n1\nhas exactly two adjacent nodes (including the node\n0\n).\nThe sum of\nn\nover all test cases must not exceed\n10\n4\n.\nExample\ninput\nCopy\n3\n4\n\n1\n\n5\n\n1\n\n0\n\n9\noutput\nCopy\n? 2 3\n\n! 0 0 1\n\n? 2 3\n\n? 2 4\n\n! 0 0 1 2\n\n! 0 0 0 1 3 5 6 7\nNote\nIn the first test case, Genokraken's nerve system forms the following tree:\nThe answer to \"? 2 3\" is\n1\n. This means that the simple path between nodes\n2\nand\n3\ncontains node\n0\n.\nIn the second test case, Genokraken's nerve system forms the following tree:\nThe answer to \"? 2 3\" is\n1\n. This means that the simple path between nodes\n2\nand\n3\ncontains node\n0\n.\nThe answer to \"? 2 4\" is\n0\n. This means that the simple path between nodes\n2\nand\n4\ndoesn't contain node\n0\n.\nIn the third test case, Genokraken's nerve system forms the following tree:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "graphs",
            "greedy",
            "implementation",
            "interactive",
            "trees",
            "two pointers",
            "*1800"
        ]
    },
    {
        "title": "C. Trinity",
        "description": "You are given an array\na\nof\nn\nelements\na\n1\n,\na\n2\n,…,\na\nn\n.\nYou can perform the following operation any number (possibly\n0\n) of times:\nChoose two integers\ni\nand\nj\n, where\n1≤i,j≤n\n, and assign\na\ni\n:=\na\nj\n.\nFind the minimum number of operations required to make the array\na\nsatisfy the condition:\nFor every pairwise distinct triplet of indices\n(x,y,z)\n(\n1≤x,y,z≤n\n,\nx≠y\n,\ny≠z\n,\nx≠z\n), there exists a non-degenerate triangle with side lengths\na\nx\n,\na\ny\nand\na\nz\n, i.e.\na\nx\n+\na\ny\n>\na\nz\n,\na\ny\n+\na\nz\n>\na\nx\nand\na\nz\n+\na\nx\n>\na\ny\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤2⋅\n10\n5\n) — the number of elements in the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required.\nExample\ninput\nCopy\n4\n7\n1 2 3 4 5 6 7\n3\n1 3 2\n3\n4 5 3\n15\n9 3 8 1 6 5 3 8 2 1 4 2 9 4 7\noutput\nCopy\n3\n1\n0\n8\nNote\nIn the first test case, one of the possible series of operations would be:\nAssign\na\n1\n:=\na\n4\n=4\n. The array will become\n[4,2,3,4,5,6,7]\n.\nAssign\na\n2\n:=\na\n5\n=5\n. The array will become\n[4,5,3,4,5,6,7]\n.\nAssign\na\n7\n:=\na\n1\n=4\n. The array will become\n[4,5,3,4,5,6,4]\n.\nIt can be proven that any triplet of elements with pairwise distinct indices in the final array forms a non-degenerate triangle, and there is no possible answer using less than\n3\noperations.\nIn the second test case, we can assign\na\n1\n:=\na\n2\n=3\nto make the array\na=[3,3,2]\n.\nIn the third test case, since\n3\n,\n4\nand\n5\nare valid side lengths of a triangle, we don't need to perform any operation to the array.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math",
            "sortings",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "B. Medians",
        "description": "You are given an array\na=[1,2,…,n]\n, where\nn\nis odd, and an integer\nk\n.\nYour task is to choose an odd positive integer\nm\nand to split\na\ninto\nm\nsubarrays\n†\n†\nb\n1\n,\nb\n2\n,…,\nb\nm\nsuch that:\nEach element of the array\na\nbelongs to exactly one subarray.\nFor all\n1≤i≤m\n,\n|\nb\ni\n|\nis odd, i.e., the length of each subarray is odd.\nmedian([median(\nb\n1\n),median(\nb\n2\n),…,median(\nb\nm\n)])=k\n, i.e., the median\n‡\n‡\nof the array of medians of all subarrays must equal\nk\n.\nmedian(c)\ndenotes the median of the array\nc\n.\n†\n†\nA subarray of the array\na\nof length\nn\nis the array\n[\na\nl\n,\na\nl+1\n,…,\na\nr\n]\nfor some integers\n1≤l≤r≤n\n.\n‡\n‡\nA median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example:\nmedian([1,2,5,4,3])=3\n,\nmedian([3,2,1])=2\n,\nmedian([2,1,2,1,2,2,2])=2\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n<2⋅\n10\n5\n,\nn\nis odd) — the length of array\na\nand the desired median of the array of medians of all subarrays.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case:\nIf there is no suitable partition, output\n−1\nin a single line.\nOtherwise, in the first line, output an odd integer\nm\n(\n1≤m≤n\n), and in the second line, output\nm\ndistinct integers\np\n1\n,\np\n2\n,\np\n3\n,…,\np\nm\n(\n1=\np\n1\n<\np\n2\n<\np\n3\n<…<\np\nm\n≤n\n) — denoting the left borders of each subarray.\nIn detail, for a valid answer\n[\np\n1\n,\np\n2\n,…,\np\nm\n]\n:\nb\n1\n=[\na\np\n1\n,\na\np\n1\n+1\n,…,\na\np\n2\n−1\n]\nb\n2\n=[\na\np\n2\n,\na\np\n2\n+1\n,…,\na\np\n3\n−1\n]\n…\nb\nm\n=[\na\np\nm\n,\na\np\nm\n+1\n,…,\na\nn\n]\n.\nIf there are multiple solutions, you can output any of them.\nExample\ninput\nCopy\n4\n1 1\n3 2\n3 3\n15 8\noutput\nCopy\n1\n1\n3\n1 2 3\n-1\n5\n1 4 7 10 13\nNote\nIn the first test case, the given partition has\nm=1\nand\nb\n1\n=[1]\n. It is obvious that\nmedian([median([1])])=median([1])=1\n.\nIn the second test case, the given partition has\nm=3\nand:\nb\n1\n=[1]\nb\n2\n=[2]\nb\n3\n=[3]\nTherefore,\nmedian([median([1]),median([2]),median([3])])=median([1,2,3])=2\n.\nIn the third test case, there is no valid partition for\nk=3\n.\nIn the fourth test case, the given partition has\nm=5\nand:\nb\n1\n=[1,2,3]\nb\n2\n=[4,5,6]\nb\n3\n=[7,8,9]\nb\n4\n=[10,11,12]\nb\n5\n=[13,14,15]\nTherefore,\nmedian([median([1,2,3]),median([4,5,6]),median([7,8,9]),median([10,11,12]),median([13,14,15])])=median([2,5,8,11,14])=8\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Circuit",
        "description": "Alice has just crafted a circuit with\nn\nlights and\n2n\nswitches. Each component (a light or a switch) has two states: on or off. The lights and switches are arranged in a way that:\nEach light is connected to exactly two switches.\nEach switch is connected to exactly one light. It's unknown which light each switch is connected to.\nWhen all switches are off, all lights are also off.\nIf a switch is toggled (from on to off, or vice versa), the state of the light connected to it will also toggle.\nAlice brings the circuit, which shows only the states of the\n2n\nswitches, to her sister Iris and gives her a riddle: what is the minimum and maximum number of lights that can be turned on?\nKnowing her little sister's antics too well, Iris takes no more than a second to give Alice a correct answer. Can you do the same?\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the number of lights in the circuit.\nThe second line of each test case contains\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n0≤\na\ni\n≤1\n) — the states of the switches in the circuit.\na\ni\n=0\nmeans the\ni\n-th switch is off, and\na\ni\n=1\nmeans the\ni\n-th switch is on.\nOutput\nFor each test case, output two integers — the minimum and maximum number of lights, respectively, that can be turned on.\nExample\ninput\nCopy\n5\n1\n0 0\n1\n0 1\n1\n1 1\n3\n0 0 1 0 1 0\n3\n0 1 1 1 0 0\noutput\nCopy\n0 0\n1 1\n0 0\n0 2\n1 3\nNote\nIn the first test case, there is only one light in the circuit, and no switch is on, so the light is certainly off.\nIn the second test case, there is only one light in the circuit, but one switch connected to it is on, so the light is on.\nIn the third test case, there is only one light in the circuit, and both switches are on, so the light is off as it was toggled twice.\nIn the fourth test case, to have no lights on, the switches can be arranged in this way:\nSwitch\n1\nand switch\n4\nare connected to light\n1\n. Since both switches are off, light\n1\nis also off.\nSwitch\n2\nand switch\n6\nare connected to light\n2\n. Since both switches are off, light\n2\nis also off.\nSwitch\n3\nand switch\n5\nare connected to light\n3\n. Both switches are on, so light\n3\nis toggled twice from its initial off state, and thus also stays off.\nAnd to have\n2\nlights on, the switches can be arranged in this way:\nSwitch\n1\nand switch\n2\nare connected to light\n1\n. Since both switches are off, light\n1\nis also off.\nSwitch\n3\nand switch\n4\nare connected to light\n2\n. Since switch\n3\nis on and switch\n4\nis off, light\n2\nis toggled once from its initial off state, so it is on.\nSwitch\n5\nand switch\n6\nare connected to light\n3\n. Since switch\n5\nis on and switch\n6\nis off, light\n3\nis toggled once from its initial off state, so it is on.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "F. Penchick and Even Medians",
        "description": "This is an interactive problem.\nReturning from a restful vacation on Australia's Gold Coast, Penchick forgot to bring home gifts for his pet duck Duong Canh! But perhaps a beautiful problem crafted through deep thought on the scenic beaches could be the perfect souvenir.\nThere is a hidden permutation\n∗\np\nof length\nn\n, where\nn\nis even. You are allowed to make the following query:\nChoose a subsequence\n†\nof the permutation\np\nwith even length\n4≤k≤n\n. The interactor will return the value of the two medians\n‡\nin the chosen subsequence.\nFind the index of the two medians in permutation\np\nusing at most\n80\nqueries.\nNote that the interactor is non-adaptive. This means that the permutation\np\nis fixed at the beginning and will not change based on your queries.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\n†\nA sequence\na\nis a subsequence of a sequence\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) element from arbitrary positions.\n‡\nThe two medians of an array\na\nwith even length\nk\nare defined as the\nk\n2\n-th and\n(\nk\n2\n+1)\n-th smallest element in the array (\n1\n-indexed).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe only line of each test case contains a single integer\nn\n(\n6≤n≤100\n,\nn\nis even) — the length of the hidden permutation\np\n.\nFor each test case, after reading the integer\nn\n, you should begin the interaction and find the answer before reading\nn\nfor the next test case.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n104\n.\nInteraction\nTo make a query, print a single line in the following format:\n?kx1x2…xk−1xk\n(\n4≤k≤n\n,\nk\nis even,\n1≤xi≤n\n,\nxi\nis pairwise distinct) — the length of the chosen subsequence followed by the indices of the chosen subsequence.\nAfter each query, you should read a line containing two integers\nm1\nand\nm2\n(\n1≤m1<m2≤n\n) — the value of the two medians in array\n[px1,px2,…,pxk−1,pxk]\n.\nYou can make at most\n80\nsuch queries in each test case.\nTo give the final answer, print a single line in the following format:\n!i1i2\n(\n1≤i1,i2≤n\n) — the index of the two medians.\nNote that the order in which\ni1\nand\ni2\nis printed does not matter. In other words, your solution is valid as long as\npi1=\nn\n2\nand\npi2=\nn\n2\n+1\n, or\npi1=\nn\n2\n+1\nand\npi2=\nn\n2\n.\nAfter printing each query do not forget to output the end of line and flush\n∗\nthe output. Otherwise, you will get Idleness limit exceeded verdict.\nIf, at any interaction step, you read\n−1\ninstead of valid data, your solution must exit immediately. This means that your solution will receive Wrong answer because of an invalid query or any other mistake. Failing to exit can result in an arbitrary verdict because your solution will continue to read from a closed stream.\nHack format\nFor hacks, use the following format.\nThe first line should contain\nt\n — the number of test cases.\nThe first line of each test case should contain a single even integer\nn\n.\nThe second line of each test case should contain a permutation\np1,p2,…,pn\nof length\nn\n.\nAs an example, the hack format for the example input is:\n\n2\n6\n6 2 3 5 1 4\n10\n10 9 8 7 6 5 4 3 2 1\n∗\nTo flush, use:\nfflush(stdout) or cout.flush() in C++;\nsys.stdout.flush() in Python;\nsee the documentation for other languages.\nExample\ninput\nCopy\n2\n6\n\n3 4\n\n3 4\n\n2 3\n\n10\n\n3 4\n\n6 7\noutput\nCopy\n? 6 1 2 3 4 5 6\n\n? 4 3 6 1 5\n\n? 4 3 6 2 5\n\n! 3 6\n\n? 6 1 3 7 8 9 10\n\n? 8 1 2 3 4 5 6 7 8\n\n! 6 5\nNote\nIn the first test case, the hidden permutation is\np=[6,2,3,5,1,4]\n.\nThe entire permutation was chosen for the first query. The two medians of the entire permutation\np\nare\n3\nand\n4\n.\nThe indices of the chosen subsequence in the second query are\n3\n,\n6\n,\n1\n, and\n5\n. The interactor returns the two medians of the subsequence\n[p3,p6,p1,p5]=[3,4,6,1]\n, which are\n3\nand\n4\n.\nThe indices of the chosen subsequence in the second query are\n3\n,\n6\n,\n2\n, and\n5\n. The interactor returns the two medians of the subsequence\n[p3,p6,p2,p5]=[3,4,2,1]\n, which are\n2\nand\n3\n.\nThe answer \"! 3 6\" is valid as\np3=3\nand\np6=4\n.\nIn the second test case, the hidden permutation is\np=[10,9,8,7,6,5,4,3,2,1]\n.\nThe indices of the chosen subsequence in the second query are\n1\n,\n3\n,\n7\n,\n8\n,\n9\n, and\n10\n. The interactor returns the two medians of the subsequence\n[p1,p3,p7,p8,p9,p10]=[10,8,4,3,2,1]\n, which are\n3\nand\n4\n.\nThe indices of the chosen subsequence in the second query are\n1\n,\n2\n,\n3\n,\n4\n,\n5\n,\n6\n,\n7\n, and\n8\n. The interactor returns the two medians of the subsequence\n[p1,p2,p3,p4,p5,p6,p7,p8]=[10,9,8,7,6,5,4,3]\n, which are\n6\nand\n7\n.\nThe answer \"! 5 6\" is valid as\np5=6\nand\np6=5\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "interactive",
            "probabilities",
            "*2800"
        ]
    },
    {
        "title": "E. Penchick and Chloe's Trees",
        "description": "With just a few hours left until Penchick and Chloe leave for Singapore, they could hardly wait to see the towering trees at the Singapore Botanic Gardens! Attempting to contain their excitement, Penchick crafted a rooted tree to keep Chloe and himself busy.\nPenchick has a rooted tree\n∗\nconsisting of\nn\nvertices, numbered from\n1\nto\nn\n, with vertex\n1\nas the root, and Chloe can select a non-negative integer\nd\nto create a perfect binary tree\n†\n†\nof depth\nd\n.\nSince Penchick and Chloe are good friends, Chloe wants her tree to be isomorphic\n‡\n‡\nto Penchick's tree. To meet this condition, Chloe can perform the following operation on her own tree any number of times:\nSelect an edge\n(u,v)\n, where\nu\nis the parent of\nv\n.\nRemove vertex\nv\nand all the edges connected to\nv\n, then connect all of\nv\n's previous children directly to\nu\n.\nIn particular, doing an operation on an edge\n(u,v)\nwhere\nv\nis a leaf will delete vertex\nv\nwithout adding any new edges.\nSince constructing a perfect binary tree can be time-consuming, Chloe wants to choose the minimum\nd\nsuch that a perfect binary tree of depth\nd\ncan be made isomorphic to Penchick's tree using the above operation. Note that she can't change the roots of the trees.\n∗\nA tree is a connected graph without cycles. A rooted tree is a tree where one vertex is special and called the root. The parent of vertex\nv\nis the first vertex on the simple path from\nv\nto the root. The root has no parent. A child of vertex\nv\nis any vertex\nu\nfor which\nv\nis the parent. A leaf is any vertex without children.\n†\n†\nA full binary tree is rooted tree, in which each node has\n0\nor\n2\nchildren. A perfect binary tree is a full binary tree in which every leaf is at the same distance from the root. The depth of such a tree is the distance from the root to a leaf.\n‡\n‡\nTwo rooted trees, rooted at\nr\n1\nand\nr\n2\nrespectively, are considered isomorphic if there exists a permutation\np\nof the vertices such that an edge\n(u,v)\nexists in the first tree if and only if the edge\n(\np\nu\n,\np\nv\n)\nexists in the second tree, and\np\nr\n1\n=\nr\n2\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n6\n) — the number of vertices in Penchick's tree.\nThe second line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n≤i−1\n) — the parent of vertex\ni\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer on each line: the minimum depth of Chloe's perfect binary tree.\nExample\ninput\nCopy\n5\n6\n1 2 2 1 1\n15\n1 1 2 2 3 3 4 4 5 5 6 6 7 7\n5\n1 2 2 2\n7\n1 1 2 1 1 2\n10\n1 1 1 2 2 2 4 3 3\noutput\nCopy\n2\n3\n3\n3\n3\nNote\nFor the first test case, create a perfect binary tree with depth\n2\n.\nConsider carrying out the operation on edge\nAC\n. Then the edges\nAC\n,\nCF\n, and\nCG\nare removed, and edges\nAF\nand\nAG\nare added.\nThe resulting tree is isomorphic to the tree given in the input. It can be proven that no sequence of operations carried out on a binary tree of depth less than\n2\ncan lead to a tree isomorphic to the tree given in the input.\nIn the second test case, the tree is already isomorphic to a perfect binary tree of depth\n3\n.",
        "time_limit": "3.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "D. Penchick and Desert Rabbit",
        "description": "Dedicated to pushing himself to his limits, Penchick challenged himself to survive the midday sun in the Arabian Desert!\nWhile trekking along a linear oasis, Penchick spots a desert rabbit preparing to jump along a line of palm trees. There are\nn\ntrees, each with a height denoted by\na\ni\n.\nThe rabbit can jump from the\ni\n-th tree to the\nj\n-th tree if exactly one of the following conditions is true:\nj<i\nand\na\nj\n>\na\ni\n: the rabbit can jump backward to a taller tree.\nj>i\nand\na\nj\n<\na\ni\n: the rabbit can jump forward to a shorter tree.\nFor each\ni\nfrom\n1\nto\nn\n, determine the maximum height among all trees that the rabbit can reach if it starts from the\ni\n-th tree.\nInput\nThe first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5⋅\n10\n5\n) — the number of trees.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the height of the trees.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers. The\ni\n-th integer should contain the maximum height among all trees that the rabbit can reach if it starts from the\ni\n-th tree.\nExample\ninput\nCopy\n5\n4\n2 3 1 4\n5\n5 4 3 2 1\n4\n2 1 1 3\n4\n1 1 3 1\n8\n2 4 1 6 3 8 5 7\noutput\nCopy\n3 3 3 4 \n5 5 5 5 5 \n2 2 2 3 \n1 1 3 3 \n8 8 8 8 8 8 8 8 \nNote\nIn the first test case, the initial heights of trees are\na=[2,3,1,4]\n.\nIf the rabbit starts from the first tree, it can jump to the third tree as\n3>1\nand\n1<2\n. Then, the rabbit can jump to the second tree as\n2<3\nand\n3>1\n. It can be proved that the rabbit cannot reach the fourth tree; hence, the maximum height of the tree that the rabbit can reach is\na\n2\n=3\n.\nIf the rabbit starts from the fourth tree, it does not need to jump anywhere as it is already at the highest tree.\nIn the second test case, the rabbit can jump to the first tree regardless of which tree it starts from.\nIn the fifth test case, if the rabbit starts from the fifth tree, it can jump to the fourth tree. Then the rabbit can jump to the seventh tree and finally reach the sixth tree. Therefore, the maximum height of the tree that the rabbit can reach is\n8\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "greedy",
            "implementation",
            "two pointers",
            "*1700"
        ]
    },
    {
        "title": "C. Penchick and BBQ Buns",
        "description": "Penchick loves two things: square numbers and Hong Kong-style BBQ buns! For his birthday, Kohane wants to combine them with a gift:\nn\nBBQ buns arranged from left to right. There are\n10\n6\navailable fillings of BBQ buns, numbered from\n1\nto\n10\n6\n. To ensure that Penchick would love this gift, Kohane has a few goals:\nNo filling is used exactly once; that is, each filling must either not appear at all or appear at least twice.\nFor any two buns\ni\nand\nj\nthat have the same filling, the distance between them, which is\n|i−j|\n, must be a perfect square\n∗\n.\nHelp Kohane find a valid way to choose the filling of the buns, or determine if it is impossible to satisfy her goals! If there are multiple solutions, print any of them.\n∗\nA positive integer\nx\nis a perfect square if there exists a positive integer\ny\nsuch that\nx=\ny\n2\n. For example,\n49\nand\n1\nare perfect squares because\n49=\n7\n2\nand\n1=\n1\n2\nrespectively. On the other hand,\n5\nis not a perfect square as no integer squared equals\n5\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n5\n). The description of the test cases follows.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of BBQ buns.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if no valid choice of fillings exists, output\n−1\n. Otherwise, output\nn\nintegers, where the\ni\n-th integer represents the filling of the\ni\n-th BBQ bun. If there are multiple solutions, print any of them.\nExample\ninput\nCopy\n2\n3\n12\noutput\nCopy\n-1\n1 2 3 6 10 2 7 6 10 1 7 3\nNote\nIn the first test case, the choice of fillings \"1 1 1\" is not allowed because buns\n1\nand\n3\nhave the same filling, but are distance\n2\napart, which is not a perfect square. The choice of fillings \"1 1 2\" is also not allowed as filling\n2\nis only used once.\nIn the second test case, the solution is valid because no filling is used exactly once, and any two buns with the same filling are spaced at a distance equal to a perfect square. For example, buns\n1\nand\n10\nboth have filling\n1\nand are spaced at a distance of\n9=\n3\n2\n. Similarly, buns\n5\nand\n9\nboth have filling\n10\nand are spaced at a distance of\n4=\n2\n2\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1300"
        ]
    },
    {
        "title": "B. Penchick and Satay Sticks",
        "description": "Penchick and his friend Kohane are touring Indonesia, and their next stop is in Surabaya!\nIn the bustling food stalls of Surabaya, Kohane bought\nn\nsatay sticks and arranged them in a line, with the\ni\n-th satay stick having length\np\ni\n. It is given that\np\nis a permutation\n∗\nof length\nn\n.\nPenchick wants to sort the satay sticks in increasing order of length, so that\np\ni\n=i\nfor each\n1≤i≤n\n. For fun, they created a rule: they can only swap neighboring satay sticks whose lengths differ by exactly\n1\n. Formally, they can perform the following operation any number of times (including zero):\nSelect an index\ni\n(\n1≤i≤n−1\n) such that\n|\np\ni+1\n−\np\ni\n|=1\n;\nSwap\np\ni\nand\np\ni+1\n.\nDetermine whether it is possible to sort the permutation\np\n, thus the satay sticks, by performing the above operation.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of satay sticks.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the permutation\np\nrepresenting the length of the satay sticks.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if it is possible to sort permutation\np\nby performing the operation. Otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n2\n4\n2 1 3 4\n4\n4 2 3 1\noutput\nCopy\nYES\nNO\nNote\nIn the first test case, we can sort permutation\np=[2,1,3,4]\nby performing an operation on index\n1\n(\n|\np\n2\n−\np\n1\n|=|1−2|=1\n), resulting in\np=[1,2,3,4]\n.\nIn the second test case, it can be proven that it is impossible to sort permutation\np=[4,2,3,1]\nby performing the operation. Here is an example of a sequence of operations that can be performed on the permutation:\nSelect\ni=2\n(\n|\np\n3\n−\np\n2\n|=|3−2|=1\n). This results in\np=[4,3,2,1]\n.\nSelect\ni=1\n(\n|\np\n2\n−\np\n1\n|=|3−4|=1\n). This results in\np=[3,4,2,1]\n.\nSelect\ni=3\n(\n|\np\n4\n−\np\n3\n|=|1−2|=1\n). This results in\np=[3,4,1,2]\n.\nUnfortunately, permutation\np\nremains unsorted after performing the operations.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*900"
        ]
    },
    {
        "title": "A. Penchick and Modern Monument",
        "description": "Amidst skyscrapers in the bustling metropolis of Metro Manila, the newest Noiph mall in the Philippines has just been completed! The construction manager, Penchick, ordered a state-of-the-art monument to be built with\nn\npillars.\nThe heights of the monument's pillars can be represented as an array\nh\nof\nn\npositive integers, where\nh\ni\nrepresents the height of the\ni\n-th pillar for all\ni\nbetween\n1\nand\nn\n.\nPenchick wants the heights of the pillars to be in non-decreasing order, i.e.\nh\ni\n≤\nh\ni+1\nfor all\ni\nbetween\n1\nand\nn−1\n. However, due to confusion, the monument was built such that the heights of the pillars are in non-increasing order instead, i.e.\nh\ni\n≥\nh\ni+1\nfor all\ni\nbetween\n1\nand\nn−1\n.\nLuckily, Penchick can modify the monument and do the following operation on the pillars as many times as necessary:\nModify the height of a pillar to any positive integer. Formally, choose an index\n1≤i≤n\nand a positive integer\nx\n. Then, assign\nh\ni\n:=x\n.\nHelp Penchick determine the minimum number of operations needed to make the heights of the monument's pillars non-decreasing.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the number of pillars.\nThe second line of each test case contains\nn\nintegers\nh\n1\n,\nh\n2\n,…,\nh\nn\n(\n1≤\nh\ni\n≤n\nand\nh\ni\n≥\nh\ni+1\n) — the height of the pillars.\nPlease take note that the given array\nh\nis non-increasing.\nNote that there are no constraints on the sum of\nn\nover all test cases.\nOutput\nFor each test case, output a single integer representing the minimum number of operations needed to make the heights of the pillars non-decreasing.\nExample\ninput\nCopy\n3\n5\n5 4 3 2 1\n3\n2 2 1\n1\n1\noutput\nCopy\n4\n1\n0\nNote\nIn the first test case, the initial heights of pillars are\nh=[5,4,3,2,1]\n.\nIn the first operation, Penchick changes the height of pillar\n1\nto\nh\n1\n:=2\n.\nIn the second operation, he changes the height of pillar\n2\nto\nh\n2\n:=2\n.\nIn the third operation, he changes the height of pillar\n4\nto\nh\n4\n:=4\n.\nIn the fourth operation, he changes the height of pillar\n5\nto\nh\n5\n:=4\n.\nAfter the operation, the heights of the pillars are\nh=[2,2,3,4,4]\n, which is non-decreasing. It can be proven that it is not possible for Penchick to make the heights of the pillars non-decreasing in fewer than\n4\noperations.\nIn the second test case, Penchick can make the heights of the pillars non-decreasing by modifying the height of pillar\n3\nto\nh\n3\n:=2\n.\nIn the third test case, the heights of pillars are already non-decreasing, so no operations are required.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "G2. The Destruction of the Universe (Hard Version)",
        "description": "This is the hard version of the problem. In this version,\nn≤\n10\n6\n. You can only make hacks if both versions of the problem are solved.\nOrangutans are powerful beings—so powerful that they only need\n1\nunit of time to destroy every vulnerable planet in the universe!\nThere are\nn\nplanets in the universe. Each planet has an interval of vulnerability\n[l,r]\n, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by\n1\nunit.\nSpecifically, suppose the expansion is performed on planet\np\nwith interval of vulnerability\n[\nl\np\n,\nr\np\n]\n. Then, the resulting interval of vulnerability may be either\n[\nl\np\n−1,\nr\np\n]\nor\n[\nl\np\n,\nr\np\n+1]\n.\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo\n998244353\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤\n10\n6\n) — the number of planets in the universe.\nThe following\nn\nlines contain two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the initial interval of vulnerability of the\ni\n-th planet.\nIt is guaranteed that the sum of\nn\ndoes not exceed\n10\n6\nover all test cases.\nOutput\nFor each test case, output an integer — the sum of scores to destroy all non-empty subsets of the planets in the universe, modulo\n998244353\n.\nExample\ninput\nCopy\n3\n3\n1 1\n2 3\n3 3\n4\n1 4\n2 3\n2 4\n1 1\n5\n1 2\n2 3\n3 4\n4 5\n1 5\noutput\nCopy\n5\n6\n24\nNote\nIn the first testcase, there are seven non-empty subsets of planets we must consider:\nFor each of the subsets\n{[1,1]},{[2,3]},{[3,3]}\n, the score is\n0\n.\nFor the subset\n{[2,3],[3,3]}\n, the score is\n0\n, because the point\n3\nis already contained in both planets' interval of vulnerability.\nFor the subset\n{[1,1],[2,3]}\n, the score is\n1\n. By using one operation on changing the interval of vulnerability of the second planet to be\n[1,3]\n, the two planets now both have the point\n1\nin their interval.\nFor the subset\n{[1,1],[3,3]}\n, the score is\n2\n. By using two operations on changing the interval of vulnerability of the first planet to be\n[1,3]\n, the two planets now both have the point\n3\nin their interval.\nFor the subset\n{[1,1],[2,3],[3,3]}\n, the score is\n2\n. By using one operation on changing the interval of vulnerability of the first planet to be\n[1,2]\nand one operation on changing the interval of vulnerability of the third planet to\n[2,3]\n, all three planets will have the point\n2\nin their interval.\nThe sum of scores of all non-empty subsets of the first testcase is\n0⋅4+1⋅1+2⋅2=5\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "*3100"
        ]
    },
    {
        "title": "G1. The Destruction of the Universe (Easy Version)",
        "description": "This is the easy version of the problem. In this version,\nn≤5000\n. You can only make hacks if both versions of the problem are solved.\nOrangutans are powerful beings—so powerful that they only need\n1\nunit of time to destroy every vulnerable planet in the universe!\nThere are\nn\nplanets in the universe. Each planet has an interval of vulnerability\n[l,r]\n, during which it will be exposed to destruction by orangutans. Orangutans can also expand the interval of vulnerability of any planet by\n1\nunit.\nSpecifically, suppose the expansion is performed on planet\np\nwith interval of vulnerability\n[\nl\np\n,\nr\np\n]\n. Then, the resulting interval of vulnerability may be either\n[\nl\np\n−1,\nr\np\n]\nor\n[\nl\np\n,\nr\np\n+1]\n.\nGiven a set of planets, orangutans can destroy all planets if the intervals of vulnerability of all planets in the set intersect at least one common point. Let the score of such a set denote the minimum number of expansions that must be performed.\nOrangutans are interested in the sum of scores of all non-empty subsets of the planets in the universe. As the answer can be large, output it modulo\n998244353\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤5000\n) — the number of planets in the universe.\nThe following\nn\nlines contain two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the initial interval of vulnerability of the\ni\n-th planet.\nIt is guaranteed that the sum of\nn\ndoes not exceed\n5000\nover all test cases.\nOutput\nFor each test case, output an integer — the sum of scores to destroy all non-empty subsets of the planets in the universe, modulo\n998244353\n.\nExample\ninput\nCopy\n3\n3\n1 1\n2 3\n3 3\n4\n1 4\n2 3\n2 4\n1 1\n5\n1 2\n2 3\n3 4\n4 5\n1 5\noutput\nCopy\n5\n6\n24\nNote\nIn the first testcase, there are seven non-empty subsets of planets we must consider:\nFor each of the subsets\n{[1,1]},{[2,3]},{[3,3]}\n, the score is\n0\n.\nFor the subset\n{[2,3],[3,3]}\n, the score is\n0\n, because the point\n3\nis already contained in both planets' interval of vulnerability.\nFor the subset\n{[1,1],[2,3]}\n, the score is\n1\n. By using one operation on changing the interval of vulnerability of the second planet to be\n[1,3]\n, the two planets now both have the point\n1\nin their interval.\nFor the subset\n{[1,1],[3,3]}\n, the score is\n2\n. By using two operations on changing the interval of vulnerability of the first planet to be\n[1,3]\n, the two planets now both have the point\n3\nin their interval.\nFor the subset\n{[1,1],[2,3],[3,3]}\n, the score is\n2\n. By using one operation on changing the interval of vulnerability of the first planet to be\n[1,2]\nand one operation on changing the interval of vulnerability of the third planet to\n[2,3]\n, all three planets will have the point\n2\nin their interval.\nThe sum of scores of all non-empty subsets of the first testcase is\n0⋅4+1⋅1+2⋅2=5\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "greedy",
            "math",
            "*2900"
        ]
    },
    {
        "title": "F. Orangutan Approved Subarrays",
        "description": "Suppose you have an array\nb\n. Initially, you also have a set\nS\nthat contains all distinct elements of\nb\n. The array\nb\nis called orangutan-approved if it can be emptied by repeatedly performing the following operation:\nIn one operation, select indices\nl\nand\nr\n(\n1≤l≤r≤|b|\n) such that\nv=\nb\nl\n=\nb\nl+1\n=…=\nb\nr\nand\nv\nis present in\nS\n. Remove\nv\nfrom\nS\n, and simultaneously remove all\nb\ni\nsuch that\nl≤i≤r\n. Then, reindex the elements\nb\nr+1\n,\nb\nr+2\n,…\nas\nb\nl\n,\nb\nl+1\n,…\naccordingly.\nYou are given an array\na\nof length\nn\nand\nq\nqueries.\nEach query consists of two indices\nl\nand\nr\n(\n1≤l≤r≤n\n), and you need to determine whether or not the subarray\na\nl\n,\na\nl+1\n,…,\na\nr\nis orangutan-approved.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the size of\na\nand the number of queries, respectively.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array\na\n.\nThe following\nq\nlines contain two integers\nl\nand\nr\n — the endpoints of the subarray for each query (\n1≤l≤r≤n\n).\nIt is guaranteed that the sum of\nn\nand\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output \"YES\" (without quotes) if the subarray from\nl\nto\nr\nis orangutan-approved, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n3\n4 2\n1 2 2 1\n1 4\n1 3\n5 3\n1 2 1 2 1\n2 5\n3 5\n1 3\n8 4\n1 2 3 2 1 3 2 3\n1 5\n2 8\n3 5\n6 8\noutput\nCopy\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nNote\nIn the first query of the first testcase, the answer is YES.\nInitially,\nS={1,2}\nand\nb=[1,2,2,1]\nSelect\nl=2\nand\nr=3\n. Since\nb\n2\n=\nb\n3\n=2\nis in\nS\n, we may erase\nb\n2\nand\nb\n3\nfrom the array, as well as erasing\n2\nfrom\nS\n. The set\nS\nbecomes\n{1}\nand the array becomes\n[1,1]\n.\nSelect\nl=1\nand\nr=2\n. Since\nb\n1\n=\nb\n2\n=1\nis in\nS\n, we may erase\nb\n1\nand\nb\n2\nfrom the array, as well as erasing\n1\nfrom\nS\n. The set\nS\nbecomes\n{}\nand the array becomes\n[]\n.\nSince the array is now empty, we can say the original array is orangutan-approved.\nIn the first query of the second testcase, the answer is NO, because it can be shown that the subarray\n[2,1,2,1]\ncannot become empty through any sequence of valid operations.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "two pointers",
            "*2400"
        ]
    },
    {
        "title": "E. MEXimize the Score",
        "description": "Suppose we partition the elements of an array\nb\ninto any number\nk\nof non-empty multisets\nS\n1\n,\nS\n2\n,…,\nS\nk\n, where\nk\nis an arbitrary positive integer. Define the score of\nb\nas the maximum value of\nMEX(\nS\n1\n)\n∗\n+MEX(\nS\n2\n)+…+MEX(\nS\nk\n)\nover all possible partitions of\nb\nfor any integer\nk\n.\nEnvy is given an array\na\nof size\nn\n. Since he knows that calculating the score of\na\nis too easy for you, he instead asks you to calculate the sum of scores of all\n2\nn\n−1\nnon-empty subsequences of\na\n.\n†\n†\nSince this answer may be large, please output it modulo\n998244353\n.\n∗\nMEX\nof a collection of integers\nc\n1\n,\nc\n2\n,…,\nc\nk\nis defined as the smallest non-negative integer\nx\nthat does not occur in the collection\nc\n. For example,\nMEX([0,1,2,2])=3\nand\nMEX([1,2,2])=0\n†\n†\nA sequence\nx\nis a subsequence of a sequence\ny\nif\nx\ncan be obtained from\ny\nby deleting several (possibly, zero or all) elements.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the answer, modulo\n998244353\n.\nExample\ninput\nCopy\n4\n3\n0 0 1\n4\n0 0 1 1\n5\n0 0 1 2 2\n4\n1 1 1 1\noutput\nCopy\n11\n26\n53\n0\nNote\nIn the first testcase, we must consider seven subsequences:\n[0]\n: The score is\n1\n.\n[0]\n: The score is\n1\n.\n[1]\n: The score is\n0\n.\n[0,0]\n: The score is\n2\n.\n[0,1]\n: The score is\n2\n.\n[0,1]\n: The score is\n2\n.\n[0,0,1]\n: The score is\n3\n.\nThe answer for the first testcase is\n1+1+2+2+2+3=11\n.\nIn the last testcase, all subsequences have a score of\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "math",
            "*2200"
        ]
    },
    {
        "title": "D. QED's Favorite Permutation",
        "description": "QED is given a permutation\n∗\np\nof length\nn\n. He also has a string\ns\nof length\nn\ncontaining only characters\nL\nand\nR\n. QED only likes permutations that are sorted in non-decreasing order. To sort\np\n, he can select any of the following operations and perform them any number of times:\nChoose an index\ni\nsuch that\ns\ni\n=L\n. Then, swap\np\ni\nand\np\ni−1\n. It is guaranteed that\ns\n1\n≠L\n.\nChoose an index\ni\nsuch that\ns\ni\n=R\n. Then, swap\np\ni\nand\np\ni+1\n. It is guaranteed that\ns\nn\n≠R\n.\nHe is also given\nq\nqueries. In each query, he selects an index\ni\nand changes\ns\ni\nfrom\nL\nto\nR\n(or from\nR\nto\nL\n). Note that the changes are persistent.\nAfter each query, he asks you if it is possible to sort\np\nin non-decreasing order by performing the aforementioned operations any number of times. Note that before answering each query, the permutation\np\nis reset to its original form.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n3≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) – the length of the permutation and the number of queries.\nThe following line contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n,\np\nis a permutation).\nThe following line contains\nn\ncharacters\ns\n1\ns\n2\n…\ns\nn\n. It is guaranteed that\ns\ni\nis either\nL\nor\nR\n,\ns\n1\n=R\n, and\ns\nn\n=L\n.\nThe following\nq\nlines contain an integer\ni\n(\n2≤i≤n−1\n), denoting that\ns\ni\nis changed from\nL\nto\nR\n(or from\nR\nto\nL\n).\nIt is guaranteed that the sum of\nn\nand\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output \"YES\" (without quotes) if it is possible, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n3\n5 3\n1 4 2 5 3\nRLRLL\n2\n4\n3\n8 5\n1 5 2 4 8 3 6 7\nRRLLRRRL\n4\n3\n5\n3\n4\n6 2\n1 2 3 4 5 6\nRLRLRL\n4\n5\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nYES\nYES\nNote\nIn the first testcase,\ns=RRRLL\nafter the first query. QED may sort\np\nusing the following operations:\nInitially,\np=[1,4,2,5,3]\n.\nSelect\ni=2\nand swap\np\n2\nwith\np\n3\n. Now,\np=[1,2,4,5,3]\n.\nSelect\ni=5\nand swap\np\n5\nwith\np\n4\n. Now,\np=[1,2,4,3,5]\n.\nSelect\ni=4\nand swap\np\n4\nwith\np\n3\n. Now,\np=[1,2,3,4,5]\n, which is in non-decreasing order.\nIt can be shown that it is impossible to sort the array after all three updates of the first testcase.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "C. A TRUE Battle",
        "description": "Alice and Bob are playing a game. There is a list of\nn\nbooleans, each of which is either true or false, given as a binary string\n∗\nof length\nn\n(where\n1\nrepresents true, and\n0\nrepresents false). Initially, there are no operators between the booleans.\nAlice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of\nn−1\nturns since there are\nn\nbooleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.\nTo evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false:\nIf the statement contains an and operator, choose any one and replace the subexpression surrounding it with its evaluation.\nOtherwise, the statement contains an or operator. Choose any one and replace the subexpression surrounding the or with its evaluation.\nFor example, the expression true or false and false is evaluated as true or (false and false)\n=\ntrue or false\n=\ntrue. It can be shown that the result of any compound statement is unique.\n∗\nA binary string is a string that only consists of characters\n0\nand\n1\nInput\nThe first line contains\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤2⋅105\n) — the length of the string.\nThe second line contains a binary string of length\nn\n, consisting of characters\n0\nand\n1\n — the list of boolean values.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each testcase, output \"YES\" (without quotes) if Alice wins, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n5\n2\n11\n3\n010\n12\n101111111100\n10\n0111111011\n8\n01000010\noutput\nCopy\nYES\nNO\nYES\nYES\nNO\nNote\nIn the first testcase, Alice can place and between the two booleans. The game ends as there are no other places to place operators, and Alice wins because true and true is true.\nIn the second testcase, Alice can place or between the middle true and the left false. Bob can place and between the middle true and the right false. The statement false or true and false is false.\nNote that these examples may not be the best strategies for either Alice or Bob.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "*1100"
        ]
    },
    {
        "title": "B. Minimise Oneness",
        "description": "For an arbitrary binary string\nt\n∗\n, let\nf(t)\nbe the number of non-empty subsequences\n†\n†\nof\nt\nthat contain only\n0\n, and let\ng(t)\nbe the number of non-empty subsequences of\nt\nthat contain at least one\n1\n.\nNote that for\nf(t)\nand for\ng(t)\n, each subsequence is counted as many times as it appears in\nt\n. E.g.,\nf(000)=7,g(100)=4\n.\nWe define the oneness of the binary string\nt\nto be\n|f(t)−g(t)|\n, where for an arbitrary integer\nz\n,\n|z|\nrepresents the absolute value of\nz\n.\nYou are given a positive integer\nn\n. Find a binary string\ns\nof length\nn\nsuch that its oneness is as small as possible. If there are multiple strings, you can print any of them.\n∗\nA binary string is a string that only consists of characters\n0\nand\n1\n.\n†\n†\nA sequence\na\nis a subsequence of a sequence\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements. For example, subsequences of\n1011101\nare\n0\n,\n1\n,\n11111\n,\n0111\n, but not\n000\nnor\n11100\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of\ns\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\ns\non a new line. If multiple answers exist, output any.\nExample\ninput\nCopy\n3\n1\n2\n3\noutput\nCopy\n0\n01\n010\nNote\nIn the first test case, for the example output,\nf(t)=1\nbecause there is one subsequence that contains only\n0\n(\n0\n), and\ng(t)=0\nbecause there are no subsequences that contain at least one\n1\n. The oneness is\n|1−0|=1\n. The output\n1\nis correct as well because its oneness is\n|0−1|=1\n.\nFor the example output of the second test case,\nf(t)=1\nbecause there is one non-empty subsequence that contains only\n0\n, and\ng(t)=2\nbecause there are two non-empty subsequences that contain at least one\n1\n(\n01\nand\n1\n). The oneness is thus\n|1−2|=1\n. It can be shown that\n1\nis the minimum possible value of its oneness over all possible binary strings of size\n2\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "games",
            "math",
            "*800"
        ]
    },
    {
        "title": "A. A Gift From Orangutan",
        "description": "While exploring the jungle, you have bumped into a rare orangutan with a bow tie! You shake hands with the orangutan and offer him some food and water. In return...\nThe orangutan has gifted you an array\na\nof length\nn\n. Using\na\n, you will construct two arrays\nb\nand\nc\n, both containing\nn\nelements, in the following manner:\nb\ni\n=min(\na\n1\n,\na\n2\n,…,\na\ni\n)\nfor each\n1≤i≤n\n.\nc\ni\n=max(\na\n1\n,\na\n2\n,…,\na\ni\n)\nfor each\n1≤i≤n\n.\nDefine the score of\na\nas\n∑\nn\ni=1\nc\ni\n−\nb\ni\n(i.e. the sum of\nc\ni\n−\nb\ni\nover all\n1≤i≤n\n). Before you calculate the score, you can shuffle the elements of\na\nhowever you want.\nFind the maximum score that you can get if you shuffle the elements of\na\noptimally.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤1000\n) — the number of elements in\na\n.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤1000\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output the maximum score that you can get.\nExample\ninput\nCopy\n3\n1\n69\n3\n7 6 5\n5\n1 1 1 2 2\noutput\nCopy\n0\n4\n4\nNote\nIn the first test case, there is no other way to rearrange\na\n. So,\nb=[69]\nand\nc=[69]\n. The only possible score is\n69−69=0\n.\nIn the second test case, you can rearrange\na\nas\n[7,5,6]\n. Here,\nb=[7,5,5]\nand\nc=[7,7,7]\n. The score in this case is\n(7−7)+(7−5)+(7−5)=4\n. It can be shown this is the maximum possible score.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "I. Variance Challenge",
        "description": "Kevin has recently learned the definition of variance. For an array\na\nof length\nn\n, the variance of\na\nis defined as follows:\nLet\nx=\n1\nn\n∑\ni=1\nn\na\ni\n, i.e.,\nx\nis the mean of the array\na\n;\nThen, the variance of\na\nis\nV(a)=\n1\nn\n∑\ni=1\nn\n(\na\ni\n−x\n)\n2\n.\nn\nNow, Kevin gives you an array\na\nconsisting of\nn\nintegers, as well as an integer\nk\n. You can perform the following operation on\na\n:\nSelect an interval\n[l,r]\n(\n1≤l≤r≤n\n), then for each\nl≤i≤r\n, increase\na\ni\nby\nk\n.\nFor each\n1≤p≤m\n, you have to find the minimum possible variance of\na\nafter exactly\np\noperations are performed, independently for each\np\n.\nFor simplicity, you only need to output the answers multiplied by\nn\n2\n. It can be proven that the results are always integers.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤5000\n,\nn⋅m≤2⋅\n10\n4\n,\n1≤k≤\n10\n5\n) — the length of the array\na\n, the maximum number of operations, and the number you add to\na\ni\neach time, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn⋅m\nover all tests does not exceed\n2⋅\n10\n4\n.\nOutput\nFor each test case, output\nm\nintegers in a single line, the\np\n-th integer denoting the minimum possible variance of\na\nwhen exactly\np\noperations are performed, multiplied by\nn\n2\n.\nExample\ninput\nCopy\n9\n3 2 1\n1 2 2\n3 2 2\n1 2 2\n10 2 1\n10 1 1 1 1 10 1 1 1 1\n6 8 2\n1 1 4 5 1 3\n8 8 7\n20 43 24 2 4 3 20 43\n8 8 3\n20 43 24 2 4 3 20 43\n10 12 1\n5 3 3 5 4 1 8 1 1 1\n13 10 100000\n1 2 3 4 5 6 7 8 9 10 11 5 4\n10 5 10000\n2308 9982 4435 3310 100000 9 7 8100 1919 100000\noutput\nCopy\n0 0\n2 2\n1161 1024\n53 21 21 5 5 5 5 5\n10608 6912 4448 3104 1991 1312 535 304\n13248 11184 9375 7815 6447 5319 4383 3687\n385 316 269 224 181 156 124 101 80 56 41 29\n1486 1486 1486 1486 1486 1486 1486 1486 1486 1486\n134618047140 119919447140 107020847140 93922247140 82623647140\nNote\nIn the first test case:\nFor\np=1\n, you can perform the operation on\n[1,1]\n, changing\na\nfrom\n[1,2,2]\nto\n[2,2,2]\n. Since all of the elements are equal, the variance is equal to\n0\n.\nFor\np=2\n, you can perform the operation on\n[1,3]\nand then\n[1,1]\n, changing\na\nfrom\n[1,2,2]\nto\n[2,3,3]\nto\n[3,3,3]\n. Since all of the elements are equal, the variance is equal to\n0\n.\nIn the second test case, some possible optimal choices are:\np=1\n:\n[\n1,\n–\n–\n2,2]→[3,2,2]\n;\np=2\n:\n[1,\n2,2\n–\n–\n–\n–\n]→[\n1,\n–\n–\n4,4]→[3,4,4]\n.\nIn the third test case, some possible optimal choices are:\np=1\n:\n[10,\n1,1,1,1,10,1,1,1,1\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n–\n]→[10,2,2,2,2,11,2,2,2,2]\n;\np=2\n:\n[10,1,1,1,1,10,\n1,1,1,1\n–\n–\n–\n–\n–\n–\n–\n–\n]→[10,\n1,1,1,1\n–\n–\n–\n–\n–\n–\n–\n–\n,10,2,2,2,2]→[10,2,2,2,2,10,2,2,2,2]\n.\nIn the eighth test case, the optimal choice for all\np\nis to perform the operation on the whole array\np\ntimes.",
        "time_limit": "6 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "flows",
            "graphs",
            "greedy",
            "*3400"
        ]
    },
    {
        "title": "H. Message Spread",
        "description": "Given is an undirected graph with\nn\nvertices and\nm\nedges. Each edge connects two vertices\n(u,v)\nand has a probability of\np\nq\nof appearing each day.\nInitially, vertex\n1\nhas a message. At the end of the day, a vertex has a message if and only if itself or at least one of the vertices adjacent to it had the message the day before. Note that each day, each edge chooses its appearance independently.\nCalculate the expected number of days before all the vertices have the message, modulo\n998244353\n.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n1≤n≤21\n,\nn−1≤m≤\nn(n−1)\n2\n).\nThen\nm\nlines follow, each containing four integers\nu\n,\nv\n,\np\n, and\nq\n(\n1≤u≠v≤n\n,\n1≤p<q<998244353\n,\ngcd(p,q)=1\n) — there is an undirected edge between\nu\nand\nv\n, and it has a probability of appearance of\np\nq\neach day.\nIt is guaranteed that there are no self-loops or multiple-edges in the graph and that the graph is connected if all of the edges appear.\nAdditional constraint in the input: Let\ngi,j\nbe the probability of appearance of the edge between\ni\nand\nj\n(\ngi,j=0\nif there is no edge between\ni\nand\nj\n). It is guaranteed that for any\nS⊆{1,2,…,n}\n(\n|S|≥1\n),\n∏\ni∈S\n(\n∏\nj∈{1,2,…,n}∖S\n(1−gi,j))≢1(mod998244353).\nOutput\nPrint a single integer in the only line of the output — the expected number of days, modulo\n998244353\n.\nFormally, let\nM=998244353\n. It can be shown that the exact answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅q−1modM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nExamples\ninput\nCopy\n2 1\n1 2 1 10\noutput\nCopy\n10\ninput\nCopy\n3 3\n1 2 1 2\n1 3 1 2\n2 3 1 2\noutput\nCopy\n887328316\ninput\nCopy\n1 0\noutput\nCopy\n0\ninput\nCopy\n5 8\n1 2 1 11\n1 3 2 11\n1 4 3 11\n1 5 4 11\n2 4 5 11\n2 5 6 11\n3 4 7 11\n4 5 8 11\noutput\nCopy\n469993557\ninput\nCopy\n21 22\n1 2 3 4\n2 3 4 5\n3 4 5 6\n5 6 7 8\n6 7 8 9\n7 8 9 10\n8 9 2 3\n9 10 3 4\n10 11 4 5\n11 12 5 6\n12 13 6 7\n13 14 7 8\n14 15 8 9\n15 16 9 10\n16 17 2 3\n17 18 3 4\n18 19 4 5\n19 20 5 6\n20 21 6 7\n1 10 100 1001\n15 4 147 220\n4 11 1 998244352\noutput\nCopy\n299529765\nNote\nIn the first test, the answer is equal to the expected number of days before the only edge in the graph first appears, and that is\n1\n0.1\n=10\n.\nIn the second test, the answer is equal to\n20\n9\nbefore it is taken modulo\n998244353\n.\nIn the third test, the only vertex already has the message, so the answer is\n0\n.",
        "time_limit": "12 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "dp",
            "*3500"
        ]
    },
    {
        "title": "G. Balanced Problem",
        "description": "There is an array\na\nconsisting of\nn\nintegers. Initially, all elements of\na\nare equal to\n0\n.\nKevin can perform several operations on the array. Each operation is one of the following two types:\nPrefix addition — Kevin first selects an index\nx\n(\n1≤x≤n\n), and then for each\n1≤j≤x\n, increases\na\nj\nby\n1\n;\nSuffix addition — Kevin first selects an index\nx\n(\n1≤x≤n\n), and then for each\nx≤j≤n\n, increases\na\nj\nby\n1\n.\nIn the country of KDOI, people think that the integer\nv\nis balanced. Thus, Iris gives Kevin an array\nc\nconsisting of\nn\nintegers and defines the beauty of the array\na\nas follows:\nInitially, set\nb=0\n;\nFor each\n1≤i≤n\n, if\na\ni\n=v\n, add\nc\ni\nto\nb\n;\nThe beauty of\na\nis the final value of\nb\n.\nKevin wants to maximize the beauty of\na\nafter all the operations. However, he had already performed\nm\noperations when he was sleepy. Now, he can perform an arbitrary number (possibly zero) of new operations.\nYou have to help Kevin find the maximum possible beauty if he optimally performs the new operations.\nHowever, to make sure that you are not just rolling the dice, Kevin gives you an integer\nV\n, and you need to solve the problem for each\n1≤v≤V\n.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nV\n(\n1≤n,m≤2⋅\n10\n5\n,\n1≤V≤2000\n) — the length of the array\na\n, the number of initial operations, and the number that Kevin gives you.\nThe second line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n) — the elements in the array\nc\n.\nThen\nm\nlines follow, the\ni\n-th line containing a character\nop\nand an integer\nx\n(\nop=L\nor\nR\n,\n1≤x≤n\n) — the type of the\ni\n-th operation and the selected index.\nIf\nop=L\n, this operation is a prefix addition on index\nx\n;\nIf\nop=R\n, this operation is a suffix addition on index\nx\n.\nIt is guaranteed that:\nthe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n;\nthe sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n;\nthe sum of\nV\n2\nover all test cases does not exceed\n4⋅\n10\n6\n.\nOutput\nFor each test case, output\nV\nintegers in a single line, the\ni\n-th integer denoting the maximum possible beauty after Kevin performs some new operations when\nv=i\n.\nExample\ninput\nCopy\n5\n3 3 2\n1 2 4\nL 3\nR 3\nL 1\n3 3 2\n5 1 4\nL 3\nR 3\nL 1\n5 4 5\n1 1 1 1 1\nL 3\nR 2\nL 5\nL 4\n10 12 9\n10 9 8 7 6 5 4 3 2 1\nL 2\nL 4\nR 4\nR 4\nL 6\nR 8\nL 3\nL 2\nR 1\nR 10\nL 8\nL 1\n1 1 4\n1000000000\nL 1\noutput\nCopy\n2 6\n1 9\n0 1 3 5 5\n0 0 0 6 25 32 35 44 51\n1000000000 1000000000 1000000000 1000000000\nNote\nIn the first test case, the array\na\nchanges as follows for the initial operations:\n[0,0,0]\n−\n→\nL 3\n[1,1,1]\n−\n→\nR 3\n[1,1,2]\n−\n→\nL 1\n[2,1,2]\n.\nFor\nv=1\n, it is optimal to not perform any new operations, and the beauty is\nb=\nc\n2\n=2\n;\nFor\nv=2\n, it is optimal to perform a prefix addition operation on index\n2\n. After that,\na\nbecomes\n[3,2,2]\n, and the beauty is\nb=\nc\n2\n+\nc\n3\n=6\n.\nIn the second test case, for both\nv=1\nand\nv=2\n, it is optimal to not perform any new operations.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "dp",
            "*3000"
        ]
    },
    {
        "title": "F. Palindrome Everywhere",
        "description": "You are given a cycle with\nn\nvertices numbered from\n0\nto\nn−1\n. For each\n0≤i≤n−1\n, there is an undirected edge between vertex\ni\nand vertex\n((i+1)modn)\nwith the color\nci\n(\nci=R\nor\nB\n).\nDetermine whether the following condition holds for every pair of vertices\n(i,j)\n(\n0≤i<j≤n−1\n):\nThere exists a palindrome route between vertex\ni\nand vertex\nj\n. Note that the route may not be simple. Formally, there must exist a sequence\np=[p0,p1,p2,…,pm]\nsuch that:\np0=i\n,\npm=j\n;\nFor each\n0≤x≤m−1\n, either\npx+1=(px+1)modn\nor\npx+1=(px−1)modn\n;\nFor each\n0≤x≤y≤m−1\nsatisfying\nx+y=m−1\n, the edge between\npx\nand\npx+1\nhas the same color as the edge between\npy\nand\npy+1\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤105\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n3≤n≤106\n) — the number of vertices in the cycle.\nThe second line contains a string\nc\nof length\nn\n(\nci=R\nor\nB\n) — the color of each edge.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n106\n.\nOutput\nFor each test case, print \"YES\" (without quotes) if there is a palindrome route between any pair of nodes, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n7\n5\nRRRRR\n5\nRRRRB\n5\nRBBRB\n6\nRBRBRB\n6\nRRBBRB\n5\nRBRBR\n12\nRRBRRBRRBRRB\noutput\nCopy\nYES\nYES\nYES\nNO\nNO\nYES\nNO\nNote\nIn the first test case, it is easy to show that there is a palindrome route between any two vertices.\nIn the second test case, for any two vertices, there exists a palindrome route with only red edges.\nIn the third test case, the cycle is as follows:\n0\nR\n⟷\n1\nB\n⟷\n2\nB\n⟷\n3\nR\n⟷\n4\nB\n⟷\n0\n. Take\n(i,j)=(0,3)\nas an example, then\n0\nR\n⟶\n1\nB\n⟶\n2\nB\n⟶\n3\nR\n⟶\n4\nB\n⟶\n0\nB\n⟶\n4\nR\n⟶\n3\nis a palindrome route. Thus, the condition holds for\n(i,j)=(0,3)\n.\nIn the fourth test case, when\n(i,j)=(0,2)\n, there does not exist a palindrome route.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "greedy",
            "*2500"
        ]
    },
    {
        "title": "E. Common Generator",
        "description": "For two integers\nx\nand\ny\n(\nx,y≥2\n), we will say that\nx\nis a generator of\ny\nif and only if\nx\ncan be transformed to\ny\nby performing the following operation some number of times (possibly zero):\nChoose a divisor\nd\n(\nd≥2\n) of\nx\n, then increase\nx\nby\nd\n.\nFor example,\n3\nis a generator of\n8\nsince we can perform the following operations:\n3\n−\n→\n−\nd=3\n6\n−\n→\n−\nd=2\n8\n;\n4\nis a generator of\n10\nsince we can perform the following operations:\n4\n−\n→\n−\nd=4\n8\n−\n→\n−\nd=2\n10\n;\n5\nis not a generator of\n6\nsince we cannot transform\n5\ninto\n6\nwith the operation above.\nNow, Kevin gives you an array\na\nconsisting of\nn\npairwise distinct integers (\na\ni\n≥2\n).\nYou have to find an integer\nx≥2\nsuch that for each\n1≤i≤n\n,\nx\nis a generator of\na\ni\n, or determine that such an integer does not exist.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n2≤\na\ni\n≤4⋅\n10\n5\n) — the elements in the array\na\n. It is guaranteed that the elements are pairwise distinct.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer\nx\n — the integer you found. Print\n−1\nif there does not exist a valid\nx\n.\nIf there are multiple answers, you may output any of them.\nExample\ninput\nCopy\n4\n3\n8 9 10\n4\n2 3 4 5\n2\n147 154\n5\n3 6 8 25 100000\noutput\nCopy\n2\n-1\n7\n3\nNote\nIn the first test case, for\nx=2\n:\n2\nis a generator of\n8\n, since we can perform the following operations:\n2\n−\n→\n−\nd=2\n4\n−\n→\n−\nd=4\n8\n;\n2\nis a generator of\n9\n, since we can perform the following operations:\n2\n−\n→\n−\nd=2\n4\n−\n→\n−\nd=2\n6\n−\n→\n−\nd=3\n9\n.\n2\nis a generator of\n10\n, since we can perform the following operations:\n2\n−\n→\n−\nd=2\n4\n−\n→\n−\nd=2\n6\n−\n→\n−\nd=2\n8\n−\n→\n−\nd=2\n10\n.\nIn the second test case, it can be proven that it is impossible to find a common generator of the four integers.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "math",
            "number theory",
            "*2100"
        ]
    },
    {
        "title": "D. Cool Graph",
        "description": "You are given an undirected graph with\nn\nvertices and\nm\nedges.\nYou can perform the following operation at most\n2⋅max(n,m)\ntimes:\nChoose three distinct vertices\na\n,\nb\n, and\nc\n, then for each of the edges\n(a,b)\n,\n(b,c)\n, and\n(c,a)\n, do the following:\nIf the edge does not exist, add it. On the contrary, if it exists, remove it.\nA graph is called cool if and only if one of the following holds:\nThe graph has no edges, or\nThe graph is a tree.\nYou have to make the graph cool by performing the above operations. Note that you can use at most\n2⋅max(n,m)\noperations.\nIt can be shown that there always exists at least one solution.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n3≤n≤\n10\n5\n,\n0≤m≤min(\nn(n−1)\n2\n,2⋅\n10\n5\n)\n) — the number of vertices and the number of edges.\nThen\nm\nlines follow, the\ni\n-th line contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n) — the two nodes that the\ni\n-th edge connects.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n, and the sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nIt is guaranteed that there are no self-loops or multiple-edges in the given graph.\nOutput\nFor each test case, in the first line output an integer\nk\n(\n0≤k≤2⋅max(n,m)\n) — the number of operations.\nThen output\nk\nlines, the\ni\n-th line containing three distinct integers\na\n,\nb\n, and\nc\n(\n1≤a,b,c≤n\n) — the three integers you choose in the\ni\n-th operation.\nIf there are multiple solutions, you can output any of them.\nExample\ninput\nCopy\n5\n3 0\n3 1\n1 2\n3 2\n1 2\n2 3\n3 3\n1 2\n2 3\n3 1\n6 6\n1 2\n1 6\n4 5\n3 4\n4 6\n3 6\noutput\nCopy\n0\n1\n1 2 3\n0\n1\n1 2 3\n3\n1 3 6\n2 4 5\n3 4 6\nNote\nIn the first test case, the graph is already cool because there are no edges.\nIn the second test case, after performing the only operation, the graph becomes a tree, so it is cool.\nIn the third test case, the graph is already cool because it is a tree.\nIn the fourth test case, after performing the only operation, the graph has no edges, so it is cool.\nIn the fifth test case:\nOperation Graph before the operation Graph after the operation\n1\n2\n3\nNote that after the first operation, the graph has already become cool, and there are two extra operations. As the graph is still cool after the two extra operations, this is a valid answer.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "greedy",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "C. New Rating",
        "description": "Hello, Codeforces Forcescode!\n Kevin used to be a participant of Codeforces. Recently, the KDOI Team has developed a new Online Judge called Forcescode.\nKevin has participated in\nn\ncontests on Forcescode. In the\ni\n-th contest, his performance rating is\nai\n.\nNow he has hacked into the backend of Forcescode and will select an interval\n[l,r]\n(\n1≤l≤r≤n\n), then skip all of the contests in this interval. After that, his rating will be recalculated in the following way:\nInitially, his rating is\nx=0\n;\nFor each\n1≤i≤n\n, after the\ni\n-th contest,\nIf\nl≤i≤r\n, this contest will be skipped, and the rating will remain unchanged;\nOtherwise, his rating will be updated according to the following rules:\nIf\nai>x\n, his rating\nx\nwill increase by\n1\n;\nIf\nai=x\n, his rating\nx\nwill remain unchanged;\nIf\nai<x\n, his rating\nx\nwill decrease by\n1\n.\nYou have to help Kevin to find his maximum possible rating after the recalculation if he chooses the interval\n[l,r]\noptimally. Note that Kevin has to skip at least one contest.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤5⋅104\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅105\n) — the number of contests.\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤n\n) — the performance ratings in the contests.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅105\n.\nOutput\nFor each test case, output a single integer — the maximum possible rating after the recalculation if Kevin chooses the interval optimally.\nExample\ninput\nCopy\n5\n6\n1 2 3 4 5 6\n7\n1 2 1 1 1 3 4\n1\n1\n9\n9 9 8 2 4 4 3 5 3\n10\n1 2 3 4 1 3 2 1 1 10\noutput\nCopy\n5\n4\n0\n4\n5\nNote\nIn the first test case, Kevin must skip at least one contest. If he chooses any interval of length\n1\n, his rating after the recalculation will be equal to\n5\n.\nIn the second test case, Kevin's optimal choice is to select the interval\n[3,5]\n. During the recalculation, his rating changes as follows:\n0\na1=1\n→\n1\na2=2\n→\n2\nskip\n→\n2\nskip\n→\n2\nskip\n→\n2\na6=3\n→\n3\na7=4\n→\n4\nIn the third test case, Kevin must skip the only contest, so his rating will remain at the initial value of\n0\n.\nIn the fourth test case, Kevin's optimal choice is to select the interval\n[7,9]\n. During the recalculation, his rating changes as follows:\n0\na1=9\n→\n1\na2=9\n→\n2\na3=8\n→\n3\na4=2\n→\n2\na5=4\n→\n3\na6=4\n→\n4\nskip\n→\n4\nskip\n→\n4\nskip\n→\n4\nIn the fifth test case, Kevin's optimal choice is to select the interval\n[5,9]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "*1700"
        ]
    },
    {
        "title": "B. Replacement",
        "description": "You have a binary string\n∗\ns\nof length\nn\n, and Iris gives you another binary string\nr\nof length\nn−1\n.\nIris is going to play a game with you. During the game, you will perform\nn−1\noperations on\ns\n. In the\ni\n-th operation (\n1≤i≤n−1\n):\nFirst, you choose an index\nk\nsuch that\n1≤k≤|s|−1\nand\ns\nk\n≠\ns\nk+1\n. If it is impossible to choose such an index, you lose;\nThen, you replace\ns\nk\ns\nk+1\nwith\nr\ni\n. Note that this decreases the length of\ns\nby\n1\n.\nIf all the\nn−1\noperations are performed successfully, you win.\nDetermine whether it is possible for you to win this game.\n∗\nA binary string is a string where each character is either\n0\nor\n1\n.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the length of\ns\n.\nThe second line contains the binary string\ns\nof length\nn\n(\ns\ni\n=0\nor\n1\n).\nThe third line contains the binary string\nr\nof length\nn−1\n(\nr\ni\n=0\nor\n1\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, print \"YES\" (without quotes) if you can win the game, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n6\n2\n11\n0\n2\n01\n1\n4\n1101\n001\n6\n111110\n10000\n6\n010010\n11010\n8\n10010010\n0010010\noutput\nCopy\nNO\nYES\nYES\nNO\nYES\nNO\nNote\nIn the first test case, you cannot perform the first operation. Thus, you lose the game.\nIn the second test case, you can choose\nk=1\nin the only operation, and after that,\ns\nbecomes equal to\n1\n. Thus, you win the game.\nIn the third test case, you can perform the following operations:\n1\n10\n–\n–\n–\n1\n−\n→\n−\n−\nr\n1\n=0\n1\n01\n–\n–\n–\n−\n→\n−\n−\nr\n2\n=0\n10\n–\n–\n–\n−\n→\n−\n−\nr\n3\n=1\n1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "strings",
            "*1100"
        ]
    },
    {
        "title": "A. Set",
        "description": "You are given a positive integer\nk\nand a set\nS\nof all integers from\nl\nto\nr\n(inclusive).\nYou can perform the following two-step operation any number of times (possibly zero):\nFirst, choose a number\nx\nfrom the set\nS\n, such that there are at least\nk\nmultiples of\nx\nin\nS\n(including\nx\nitself);\nThen, remove\nx\nfrom\nS\n(note that nothing else is removed).\nFind the maximum possible number of operations that can be performed.\nInput\nEach test contains multiple test cases. The first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe only line of each test case contains three integers\nl\n,\nr\n, and\nk\n(\n1≤l≤r≤\n10\n9\n,\n1≤k≤r−l+1\n) — the minimum integer in\nS\n, the maximum integer in\nS\n, and the parameter\nk\n.\nOutput\nFor each test case, output a single integer — the maximum possible number of operations that can be performed.\nExample\ninput\nCopy\n8\n3 9 2\n4 9 1\n7 9 2\n2 10 2\n154 220 2\n147 294 2\n998 24435 3\n1 1000000000 2\noutput\nCopy\n2\n6\n0\n4\n0\n1\n7148\n500000000\nNote\nIn the first test case, initially,\nS={3,4,5,6,7,8,9}\n. One possible optimal sequence of operations is:\nChoose\nx=4\nfor the first operation, since there are two multiples of\n4\nin\nS\n:\n4\nand\n8\n.\nS\nbecomes equal to\n{3,5,6,7,8,9}\n;\nChoose\nx=3\nfor the second operation, since there are three multiples of\n3\nin\nS\n:\n3\n,\n6\n, and\n9\n.\nS\nbecomes equal to\n{5,6,7,8,9}\n.\nIn the second test case, initially,\nS={4,5,6,7,8,9}\n. One possible optimal sequence of operations is:\nChoose\nx=5\n,\nS\nbecomes equal to\n{4,6,7,8,9}\n;\nChoose\nx=6\n,\nS\nbecomes equal to\n{4,7,8,9}\n;\nChoose\nx=4\n,\nS\nbecomes equal to\n{7,8,9}\n;\nChoose\nx=8\n,\nS\nbecomes equal to\n{7,9}\n;\nChoose\nx=7\n,\nS\nbecomes equal to\n{9}\n;\nChoose\nx=9\n,\nS\nbecomes equal to\n{}\n.\nIn the third test case, initially,\nS={7,8,9}\n. For each\nx\nin\nS\n, no multiple of\nx\nother than\nx\nitself can be found in\nS\n. Since\nk=2\n, you can perform no operations.\nIn the fourth test case, initially,\nS={2,3,4,5,6,7,8,9,10}\n. One possible optimal sequence of operations is:\nChoose\nx=2\n,\nS\nbecomes equal to\n{3,4,5,6,7,8,9,10}\n;\nChoose\nx=4\n,\nS\nbecomes equal to\n{3,5,6,7,8,9,10}\n;\nChoose\nx=3\n,\nS\nbecomes equal to\n{5,6,7,8,9,10}\n;\nChoose\nx=5\n,\nS\nbecomes equal to\n{6,7,8,9,10}\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Alice's Adventures in Addition",
        "description": "Note that the memory limit is unusual.\nThe Cheshire Cat has a riddle for Alice: given\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\nand a target\nm\n, is there a way to insert\n+\nand\n×\ninto the circles of the expression\na\n1\n∘\na\n2\n∘⋯∘\na\nn\n=m\na\n∘\na\n∘\n∘\na\nm\nto make it true? We follow the usual order of operations:\n×\nis done before\n+\n.\nAlthough Alice is excellent at chess, she is not good at math. Please help her so she can find a way out of Wonderland!\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n1≤n≤2⋅\n10\n5\n;\n1≤m≤\n10\n4\n) — the number of integers and the target, respectively.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n4\n) — the elements of the array\na\n.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" without quotes if it is possible to get the target by inserting\n+\nor\n×\nand \"NO\" otherwise.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n6\n5 4\n2 1 1 1 2\n5 5\n2 1 1 1 2\n5 6\n2 1 1 1 2\n5 7\n2 1 1 1 2\n5 8\n2 1 1 1 2\n5 6\n2 0 2 2 3\noutput\nCopy\nYES\nYES\nYES\nYES\nNO\nYES\nNote\nPossible solutions for the first four test cases are shown below.\n2×1+1×1×2\n2×1+1+1×2\n2×1+1+1+2\n2+1+1+1+2\n=4\n=5\n=6\n=7\nIt is impossible to get a result of\n8\nin the fifth test case.",
        "time_limit": "3 seconds",
        "memory_limit": "32 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "implementation",
            "*2700"
        ]
    },
    {
        "title": "E. Alice's Adventures in the Rabbit Hole",
        "description": "Alice is at the bottom of the rabbit hole! The rabbit hole can be modeled as a tree\n∗\nwhich has an exit at vertex\n1\n, and Alice starts at some vertex\nv\n. She wants to get out of the hole, but unfortunately, the Queen of Hearts has ordered her execution.\nEach minute, a fair coin is flipped. If it lands heads, Alice gets to move to an adjacent vertex of her current location, and otherwise, the Queen of Hearts gets to pull Alice to an adjacent vertex of the Queen's choosing. If Alice ever ends up on any of the non-root leaves\n†\nof the tree, Alice loses.\nAssuming both of them move optimally, compute the probability that Alice manages to escape for every single starting vertex\n1≤v≤n\n. Since these probabilities can be very small, output them modulo\n998244353\n.\nFormally, let\nM=998244353\n. It can be shown that the exact answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅q−1mod\n. In other words, output such an integer\nx\nthat\n0 \\le x < M\nand\nx \\cdot q \\equiv p \\pmod{M}\n.\n^{\\text{∗}}\nA tree is a connected simple graph which has\nn\nvertices and\nn-1\nedges.\n^{\\text{†}}\nA leaf is a vertex that is connected to exactly one edge.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1 \\le t \\le 10^4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2\\le n\\le 2\\cdot 10^5\n) — the number of vertices in the tree.\nThe\ni\n-th of the next\nn - 1\nlines contains two integers\nx_i\nand\ny_i\n(\n1 \\le x_i, y_i \\le n\nand\nx_i \\neq y_i\n) — the edges of the tree. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2\\cdot 10^5\n.\nOutput\nFor each test case, output\nn\nintegers on one line — the probabilities of Alice escaping starting from vertex\n1, 2, \\ldots, n\n. Since these probabilities can be very small, output them modulo\n998\\,244\\,353\n.\nExample\ninput\nCopy\n2\n5\n1 2\n1 3\n2 4\n3 5\n9\n1 2\n2 3\n4 5\n5 6\n7 8\n8 9\n2 4\n5 7\noutput\nCopy\n1 499122177 499122177 0 0 \n1 499122177 0 332748118 166374059 0 443664157 720954255 0 \nNote\nFor the first test case:\nAlice escapes from the root (vertex\n1\n) by definition with probability\n1\n.\nAlice immediately loses from vertices\n4\nand\n5\nsince they are leaves.\nFrom the other two vertices, Alice escapes with probability\n\\frac 12\nsince the Queen will pull her to the leaves.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "dp",
            "games",
            "greedy",
            "math",
            "probabilities",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "D. Alice's Adventures in Cards",
        "description": "Alice is playing cards with the Queen of Hearts, King of Hearts, and Jack of Hearts. There are\nn\ndifferent types of cards in their card game. Alice currently has a card of type\n1\nand needs a card of type\nn\nto escape Wonderland. The other players have one of each kind of card.\nIn this card game, Alice can trade cards with the three other players. Each player has different preferences for the\nn\ntypes of cards, which can be described by permutations\n∗\nq\n,\nk\n, and\nj\nfor the Queen, King, and Jack, respectively.\nA player values card\na\nmore than card\nb\nif for their permutation\np\n,\np\na\n>\np\nb\n. Then, this player is willing to trade card\nb\nto Alice in exchange for card\na\n. Alice's preferences are straightforward: she values card\na\nmore than card\nb\nif\na>b\n, and she will also only trade according to these preferences.\nDetermine if Alice can trade up from card\n1\nto card\nn\nsubject to these preferences, and if it is possible, give a possible set of trades to do it.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of card types.\nThe next three lines contain the preferences of the Queen, King, and Jack respectively. Each of these lines contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — a permutation corresponding to the player's preferences.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, on the first line output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice can trade up to card\nn\n.\nIf the first line was \"YES\", then on the next line output\nk\n— the number of trades Alice will make. On the next\nk\nlines output space separated a character\nc∈{q,k,j}\nand integer\nx\n, denoting that Alice trades with player\nc\nto get card\nx\n. It must be the case that on the\nk\n'th line,\nx=n\n. If there are multiple solutions, print any of them.\nYou can output this answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses. The same goes for the character\nc\ndenoting the player in the trade (\nQ,K,J\nwill all be accepted alongside their lowercase variants).\nExample\ninput\nCopy\n2\n3\n1 3 2\n2 1 3\n1 2 3\n4\n2 3 1 4\n1 2 3 4\n1 4 2 3\noutput\nCopy\nYES\n2\nk 2\nq 3\nNO\nNote\nIn the first testcase, Alice can trade with the King to get card\n2\n. She can then trade with the Queen to get card\n3\n.\nIn the second testcase, even though Alice can trade with the Queen to get card\n3\n, with the King to get card\n2\n, and then with the Jack to get card\n4\n, this is not a valid solution since it doesn't respect Alice's preferences. We can show that there is no way for Alice to get to card\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dp",
            "graphs",
            "greedy",
            "implementation",
            "ternary search",
            "*2000"
        ]
    },
    {
        "title": "C. Alice's Adventures in Cutting Cake",
        "description": "Alice is at the Mad Hatter's tea party! There is a long sheet cake made up of\nn\nsections with tastiness values\na\n1\n,\na\n2\n,…,\na\nn\n. There are\nm\ncreatures at the tea party, excluding Alice.\nAlice will cut the cake into\nm+1\npieces. Formally, she will partition the cake into\nm+1\nsubarrays, where each subarray consists of some number of adjacent sections. The tastiness of a piece is the sum of tastiness of its sections. Afterwards, she will divvy these\nm+1\npieces up among the\nm\ncreatures and herself (her piece can be empty). However, each of the\nm\ncreatures will only be happy when the tastiness of its piece is\nv\nor more.\nAlice wants to make sure every creature is happy. Limited by this condition, she also wants to maximize the tastiness of her own piece. Can you help Alice find the maximum tastiness her piece can have? If there is no way to make sure every creature is happy, output\n−1\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn,m,v\n(\n1≤m≤n≤2⋅\n10\n5\n;\n1≤v≤\n10\n9\n) — the number of sections, the number of creatures, and the creatures' minimum requirement for tastiness, respectively.\nThe next line contains\nn\nspace separated integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the tastinesses of the sections.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum tastiness Alice can achieve for her piece, or\n−1\nif there is no way to make sure every creature is happy.\nExample\ninput\nCopy\n7\n6 2 1\n1 1 10 1 1 10\n6 2 2\n1 1 10 1 1 10\n6 2 3\n1 1 10 1 1 10\n6 2 10\n1 1 10 1 1 10\n6 2 11\n1 1 10 1 1 10\n6 2 12\n1 1 10 1 1 10\n6 2 12\n1 1 1 1 10 10\noutput\nCopy\n22\n12\n2\n2\n2\n0\n-1\nNote\nFor the first test case, Alice can give the first and second section as their own pieces, and then take the remaining\n10+1+1+10=22\ntastiness for herself. We can show that she cannot do any better.\nFor the second test case, Alice could give the first and second section as one piece, and the sixth section as one piece. She can then take the remaining\n10+1+1=12\ntastiness for herself. We can show that she cannot do any better.\nFor the seventh test case, Alice cannot give each creature a piece of at least\n12\ntastiness.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "B. Alice's Adventures in Permuting",
        "description": "Alice mixed up the words transmutation and permutation! She has an array\na\nspecified via three integers\nn\n,\nb\n,\nc\n: the array\na\nhas length\nn\nand is given via\na\ni\n=b⋅(i−1)+c\nfor\n1≤i≤n\n. For example, if\nn=3\n,\nb=2\n, and\nc=1\n, then\na=[2⋅0+1,2⋅1+1,2⋅2+1]=[1,3,5]\n.\nNow, Alice really enjoys permutations of\n[0,…,n−1]\n∗\nand would like to transform\na\ninto a permutation. In one operation, Alice replaces the maximum element of\na\nwith the\nMEX\n†\n†\nof\na\n. If there are multiple maximum elements in\na\n, Alice chooses the leftmost one to replace.\nCan you help Alice figure out how many operations she has to do for\na\nto become a permutation for the first time? If it is impossible, you should report it.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n0\nto\nn−1\nin arbitrary order. Please note, this is slightly different from the usual definition of a permutation. For example,\n[1,2,0,4,3]\nis a permutation, but\n[0,1,1]\nis not a permutation (\n1\nappears twice in the array), and\n[0,2,3]\nis also not a permutation (\nn=3\nbut there is\n3\nin the array).\n†\n†\nThe\nMEX\nof an array is the smallest non-negative integer that does not belong to the array. For example, the\nMEX\nof\n[0,3,1,3]\nis\n2\nand the\nMEX\nof\n[5]\nis\n0\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe only line of each test case contains three integers\nn\n,\nb\n,\nc\n(\n1≤n≤\n10\n18\n;\n0≤b\n,\nc≤\n10\n18\n) — the parameters of the array.\nOutput\nFor each test case, if the array can never become a permutation, output\n−1\n. Otherwise, output the minimum number of operations for the array to become a permutation.\nExample\ninput\nCopy\n7\n10 1 0\n1 2 3\n100 2 1\n3 0 1\n3 0 0\n1000000000000000000 0 0\n1000000000000000000 1000000000000000000 1000000000000000000\noutput\nCopy\n0\n1\n50\n2\n-1\n-1\n1000000000000000000\nNote\nIn the first test case, the array is already\n[0,1,…,9]\n, so no operations are required.\nIn the third test case, the starting array is\n[1,3,5,…,199]\n. After the first operation, the\n199\ngets transformed into a\n0\n. In the second operation, the\n197\ngets transformed into a\n2\n. If we continue this, it will take exactly\n50\noperations to get the array\n[0,1,2,3,…,99]\n.\nIn the fourth test case, two operations are needed:\n[1,1,1]→[0,1,1]→[0,2,1]\n.\nIn the fifth test case, the process is\n[0,0,0]→[1,0,0]→[2,0,0]→[1,0,0]→[2,0,0]\n. This process repeats forever, so the array is never a permutation and the answer is\n−1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "math",
            "*1400"
        ]
    },
    {
        "title": "A. Alice's Adventures in \"Chess\"",
        "description": "Alice is trying to meet up with the Red Queen in the countryside! Right now, Alice is at position\n(0,0)\n, and the Red Queen is at position\n(a,b)\n. Alice can only move in the four cardinal directions (north, east, south, west).\nMore formally, if Alice is at the point\n(x,y)\n, she will do one of the following:\ngo north (represented by N), moving to\n(x,y+1)\n;\ngo east (represented by E), moving to\n(x+1,y)\n;\ngo south (represented by S), moving to\n(x,y−1)\n; or\ngo west (represented by W), moving to\n(x−1,y)\n.\nAlice's movements are predetermined. She has a string\ns\nrepresenting a sequence of moves that she performs from left to right. Once she reaches the end of the sequence, she repeats the same pattern of moves forever.\nCan you help Alice figure out if she will ever meet the Red Queen?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\na\n,\nb\n(\n1≤n\n,\na\n,\nb≤10\n) — the length of the string and the initial coordinates of the Red Queen.\nThe second line contains a string\ns\nof length\nn\nconsisting only of the characters N, E, S, or W.\nOutput\nFor each test case, output a single string \"YES\" or \"NO\" (without the quotes) denoting whether Alice will eventually meet the Red Queen.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n6\n2 2 2\nNE\n3 2 2\nNNE\n6 2 1\nNNEESW\n6 10 10\nNNEESW\n3 4 2\nNEE\n4 5 5\nNEWS\noutput\nCopy\nYES\nNO\nYES\nYES\nYES\nNO\nNote\nIn the first test case, Alice follows the path\n(0,0)\n→\nN\n(0,1)\n→\nE\n(1,1)\n→\nN\n(1,2)\n→\nE\n(2,2)\n.\nIn the second test case, Alice can never reach the Red Queen.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*900"
        ]
    },
    {
        "title": "E2. Bit Game (Hard Version)",
        "description": "This is the hard version of this problem. The only difference is that you need to output the number of choices of games where Bob wins in this version, where the number of stones in each pile are not fixed. You must solve both versions to be able to hack.\nAlice and Bob are playing a familiar game where they take turns removing stones from\nn\npiles. Initially, there are\nx\ni\nstones in the\ni\n-th pile, and it has an associated value\na\ni\n. A player can take\nd\nstones away from the\ni\n-th pile if and only if both of the following conditions are met:\n1≤d≤\na\ni\n, and\nx&d=d\n, where\nx\nis the current number of stones in the\ni\n-th pile and\n&\ndenotes the bitwise AND operation.\nThe player who cannot make a move loses, and Alice goes first.\nYou're given the\na\ni\nvalues of each pile, but the number of stones in the\ni\n-th pile has not been determined yet. For the\ni\n-th pile,\nx\ni\ncan be any integer between\n1\nand\nb\ni\n, inclusive. That is, you can choose an array\nx\n1\n,\nx\n2\n,…,\nx\nn\nsuch that the condition\n1≤\nx\ni\n≤\nb\ni\nis satisfied for all piles.\nYour task is to count the number of games where Bob wins if both players play optimally. Two games are considered different if the number of stones in any pile is different, i.e., the arrays of\nx\ndiffer in at least one position.\nSince the answer can be very large, please output the result modulo\n10\n9\n+7\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains\nn\n(\n1≤n≤\n10\n4\n) — the number of piles.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n<\n2\n30\n).\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n<\n2\n30\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n4\n.\nOutput\nOutput a single integer, the number of games where Bob wins, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n7\n3\n1 2 3\n3 2 2\n1\n13\n45\n5\n5 4 7 8 6\n4 4 5 5 5\n4\n6 4 8 8\n12 13 14 12\n3\n92856133 46637598 12345678\n29384774 73775896 87654321\n2\n65 12\n110 31\n4\n677810235 275091182 428565855 720629731\n74522416 889934149 3394714 230851724\noutput\nCopy\n4\n4\n0\n6552\n722019507\n541\n665443265\nNote\nIn the first test case, no matter which values of\nx\n2\nand\nx\n3\nwe choose, the second and third piles will always be chosen exactly once before no more stones can be taken from them. If\nx\n1\n=2\n, then no stones can be taken from it, so Bob will make the last move. If\nx\n1\n=1\nor\nx\n1\n=3\n, then exactly one move can be made on that pile, so Alice will make the last move. So Bob wins when\nx=[2,1,1]\nor\nx=[2,1,2]\nor\nx=[2,2,1]\nor\nx=[2,2,2]\n.\nIn the second test case, Bob wins when\nx\n1\n=14\nor\nx\n1\n=30\nby removing\n14−k\nstones, where\nk\nis the number of stones Alice removes on her turn. Bob also wins when\nx\n1\n=16\nor\nx\n1\n=32\nsince Alice does not have any moves to begin with.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "math",
            "*3100"
        ]
    },
    {
        "title": "E1. Bit Game (Easy Version)",
        "description": "This is the easy version of this problem. The only difference is that you need to output the winner of the game in this version, and the number of stones in each pile are fixed. You must solve both versions to be able to hack.\nAlice and Bob are playing a familiar game where they take turns removing stones from\nn\npiles. Initially, there are\nx\ni\nstones in the\ni\n-th pile, and it has an associated value\na\ni\n. A player can take\nd\nstones away from the\ni\n-th pile if and only if both of the following conditions are met:\n1≤d≤\na\ni\n, and\nx&d=d\n, where\nx\nis the current number of stones in the\ni\n-th pile and\n&\ndenotes the bitwise AND operation.\nThe player who cannot make a move loses, and Alice goes first.\nYou're given the\na\ni\nand\nx\ni\nvalues for each pile, please determine who will win the game if both players play optimally.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains\nn\n(\n1≤n≤\n10\n4\n) — the number of piles.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n<\n2\n30\n).\nThe third line of each test case contains\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n1≤\nx\ni\n<\n2\n30\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n4\n.\nOutput\nPrint a single line with the winner's name. If Alice wins, print \"Alice\", otherwise print \"Bob\" (without quotes).\nExample\ninput\nCopy\n7\n2\n1 6\n10 7\n3\n10 8 15\n25 4 14\n4\n8 32 65 64\n7 45 126 94\n3\n20 40 1\n23 55 1\n5\n12345 9876 86419 8641 1\n6789 54321 7532 97532 1\n2\n20 64\n44 61\n3\n57 109 55\n69 90 85\noutput\nCopy\nBob\nBob\nBob\nBob\nBob\nAlice\nAlice\nNote\nIn the first test case, neither player can take any stones from the first pile since there is no value of\nd\nsatisfying the conditions. For the second pile, to begin with, Alice can remove between\n1\nand\n6\nstones. No matter which move Alice performs, Bob can remove the rest of the stones on his turn. After Bob's move, there are no more moves that Alice can perform, so Bob wins.\nIn the second test case, here is one example of how the game might go. Alice moves first, and she decides to remove from the first pile. She cannot take\n17\nstones, because\n17>10\n, which fails the first condition. She cannot take\n10\nstones, because\n25&10=8\nwhich fails the second condition. One option is to take\n9\nstones; now the pile has\n16\nstones left. On Bob's turn he decides to take stones from the second pile; the only option here is to take all\n4\n. Now, no more stones can be taken from either of the first two piles, so Alice must take some stones from the last pile. She decides to take\n12\nstones, and Bob then follows by taking the last\n2\nstones on that pile. Since Alice now has no legal moves left, Bob wins. It can be shown that no matter which strategy Alice follows, Bob will always be able to win if he plays optimally.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "games",
            "math",
            "*2800"
        ]
    },
    {
        "title": "D2. The Endspeaker (Hard Version)",
        "description": "This is the hard version of this problem. The only difference is that you need to also output the number of optimal sequences in this version. You must solve both versions to be able to hack.\nYou're given an array\na\nof length\nn\n, and an array\nb\nof length\nm\n(\nbi>bi+1\nfor all\n1≤i<m\n). Initially, the value of\nk\nis\n1\n. Your aim is to make the array\na\nempty by performing one of these two operations repeatedly:\nType\n1\n — If the value of\nk\nis less than\nm\nand the array\na\nis not empty, you can increase the value of\nk\nby\n1\n. This does not incur any cost.\nType\n2\n — You remove a non-empty prefix of array\na\n, such that its sum does not exceed\nbk\n. This incurs a cost of\nm−k\n.\nYou need to minimize the total cost of the operations to make array\na\nempty. If it's impossible to do this through any sequence of operations, output\n−1\n. Otherwise, output the minimum total cost of the operations, and the number of sequences of operations which yield this minimum cost modulo\n109+7\n.\nTwo sequences of operations are considered different if you choose a different type of operation at any step, or the size of the removed prefix is different at any step.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤3⋅105\n,\n1≤n⋅m≤3⋅105\n).\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤109\n).\nThe third line of each test case contains\nm\nintegers\nb1,b2,…,bm\n(\n1≤bi≤109\n).\nIt is also guaranteed that\nbi>bi+1\nfor all\n1≤i<m\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n3⋅105\n.\nOutput\nFor each test case, if it's possible to make\na\nempty, then output two integers. The first should be the minimum total cost of the operations, and the second should be the number of sequences of operations which achieve this minimum cost, modulo\n109+7\n.\nIf there is no possible sequence of operations which makes\na\nempty, then output a single integer\n−1\n.\nExample\ninput\nCopy\n5\n4 2\n9 3 4 3\n11 7\n1 2\n20\n19 18\n10 2\n2 5 2 1 10 3 2 9 9 6\n17 9\n10 11\n2 2 2 2 2 2 2 2 2 2\n20 18 16 14 12 10 8 6 4 2 1\n1 6\n10\n32 16 8 4 2 1\noutput\nCopy\n1 3\n-1\n2 11\n10 42\n4 1\nNote\nIn the first test case, there are\n3\noptimal sequences of operations which yield a total cost of\n1\n:\nAll\n3\nsequences begin with a type\n2\noperation, removing the prefix\n[9]\nto make\na=[3,4,3]\n, incurring a cost of\n1\n. Then, we perform a type\n1\noperation to increase the value of\nk\nby\n1\n. All subsequent operations now incur a cost of\n0\n.\nOne sequence continues by removing the prefixes\n[3,4]\nthen\n[3]\n.\nAnother sequence continues by removing the prefixes\n[3]\nthen\n[4,3]\n.\nAnother sequence continues by removing the prefixes\n[3]\nthen\n[4]\nthen\n[3]\n.\nIn the second test case, it's impossible to remove any prefix of the array since\na1>b1\n, so array\na\ncannot be made empty by any sequence of operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "two pointers",
            "*2200"
        ]
    },
    {
        "title": "D1. The Endspeaker (Easy Version)",
        "description": "This is the easy version of this problem. The only difference is that you only need to output the minimum total cost of operations in this version. You must solve both versions to be able to hack.\nYou're given an array\na\nof length\nn\n, and an array\nb\nof length\nm\n(\nb\ni\n>\nb\ni+1\nfor all\n1≤i<m\n). Initially, the value of\nk\nis\n1\n. Your aim is to make the array\na\nempty by performing one of these two operations repeatedly:\nType\n1\n — If the value of\nk\nis less than\nm\nand the array\na\nis not empty, you can increase the value of\nk\nby\n1\n. This does not incur any cost.\nType\n2\n — You remove a non-empty prefix of array\na\n, such that its sum does not exceed\nb\nk\n. This incurs a cost of\nm−k\n.\nYou need to minimize the total cost of the operations to make array\na\nempty. If it's impossible to do this through any sequence of operations, output\n−1\n. Otherwise, output the minimum total cost of the operations.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤3⋅\n10\n5\n,\n1≤n⋅m≤3⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤\n10\n9\n).\nIt is also guaranteed that\nb\ni\n>\nb\ni+1\nfor all\n1≤i<m\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, if it's possible to make\na\nempty, then output the minimum total cost of the operations.\nIf there is no possible sequence of operations which makes\na\nempty, then output a single integer\n−1\n.\nExample\ninput\nCopy\n5\n4 2\n9 3 4 3\n11 7\n1 2\n20\n19 18\n10 2\n2 5 2 1 10 3 2 9 9 6\n17 9\n10 11\n2 2 2 2 2 2 2 2 2 2\n20 18 16 14 12 10 8 6 4 2 1\n1 6\n10\n32 16 8 4 2 1\noutput\nCopy\n1\n-1\n2\n10\n4\nNote\nIn the first test case, one optimal sequence of operations which yields a total cost of\n1\nis as follows:\nPerform an operation of type\n2\n. Choose the prefix to be\n[9]\n. This incurs a cost of\n1\n.\nPerform an operation of type\n1\n. The value of\nk\nis now\n2\n. This incurs no cost.\nPerform an operation of type\n2\n. Choose the prefix to be\n[3,4]\n. This incurs a cost of\n0\n.\nPerform an operation of type\n2\n. Choose the prefix to be\n[3]\n. This incurs a cost of\n0\n.\nThe array\na\nis now empty, and the total cost of all operations is\n1\n.\nIn the second test case, it's impossible to remove any prefix of the array since\na\n1\n>\nb\n1\n, so array\na\ncannot be made empty by any sequence of operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "graphs",
            "greedy",
            "implementation",
            "two pointers",
            "*1700"
        ]
    },
    {
        "title": "C. Add Zeros",
        "description": "You're given an array\na\ninitially containing\nn\nintegers. In one operation, you must do the following:\nChoose a position\ni\nsuch that\n1<i≤|a|\nand\na\ni\n=|a|+1−i\n, where\n|a|\nis the current size of the array.\nAppend\ni−1\nzeros onto the end of\na\n.\nAfter performing this operation as many times as you want, what is the maximum possible length of the array\na\n?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains\nn\n(\n1≤n≤3⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum possible length of\na\nafter performing some sequence of operations.\nExample\ninput\nCopy\n4\n5\n2 4 6 2 5\n5\n5 4 4 5 1\n4\n6 8 2 3\n1\n1\noutput\nCopy\n10\n11\n10\n1\nNote\nIn the first test case, we can first choose\ni=4\n, since\na\n4\n=5+1−4=2\n. After this, the array becomes\n[2,4,6,2,5,0,0,0]\n. We can then choose\ni=3\nsince\na\n3\n=8+1−3=6\n. After this, the array becomes\n[2,4,6,2,5,0,0,0,0,0]\n, which has a length of\n10\n. It can be shown that no sequence of operations will make the final array longer.\nIn the second test case, we can choose\ni=2\n, then\ni=3\n, then\ni=4\n. The final array will be\n[5,4,4,5,1,0,0,0,0,0,0]\n, with a length of\n11\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "graphs",
            "greedy",
            "*1500"
        ]
    },
    {
        "title": "B. Stalin Sort",
        "description": "Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an\nO(n)\ntime complexity.\nIt goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array\n[1,4,2,3,6,5,5,7,7]\nbecomes\n[1,4,6,7,7]\nafter a Stalin Sort.\nWe define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays\n∗\n, as many times as is needed.\nGiven an array\na\nof\nn\nintegers, determine the minimum number of integers which must be removed from the array to make it vulnerable.\n∗\nAn array\na\nis a subarray of an array\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2000\n) — the size of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output a single integer — the minimum number of integers which must be removed from the array to make it vulnerable.\nExample\ninput\nCopy\n6\n7\n3 6 4 9 2 5 2\n5\n5 4 4 2 2\n8\n2 2 4 4 6 6 10 10\n1\n1000\n9\n6 8 9 10 12 9 7 5 4\n7\n300000000 600000000 400000000 900000000 200000000 400000000 200000000\noutput\nCopy\n2\n0\n6\n0\n4\n2\nNote\nIn the first test case, the optimal answer is to remove the numbers\n3\nand\n9\n. Then we are left with\na=[6,4,2,5,2]\n. To show this array is vulnerable, we can first apply a Stalin Sort on the subarray\n[4,2,5]\nto get\na=[6,4,5,2]\nand then apply a Stalin Sort on the subarray\n[6,4,5]\nto get\na=[6,2]\n, which is non-increasing.\nIn the second test case, the array is already non-increasing, so we don't have to remove any integers.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ]
    },
    {
        "title": "A. Rectangle Arrangement",
        "description": "You are coloring an infinite square grid, in which all cells are initially white. To do this, you are given\nn\nstamps. Each stamp is a rectangle of width\nw\ni\nand height\nh\ni\n.\nYou will use each stamp exactly once to color a rectangle of the same size as the stamp on the grid in black. You cannot rotate the stamp, and for each cell, the stamp must either cover it fully or not cover it at all. You can use the stamp at any position on the grid, even if some or all of the cells covered by the stamping area are already black.\nWhat is the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n).\nThe\ni\n-th of the next\nn\nlines contains two integers\nw\ni\nand\nh\ni\n(\n1≤\nw\ni\n,\nh\ni\n≤100\n).\nOutput\nFor each test case, output a single integer — the minimum sum of the perimeters of the connected regions of black squares you can obtain after all the stamps have been used.\nExample\ninput\nCopy\n5\n5\n1 5\n2 4\n3 3\n4 2\n5 1\n3\n2 2\n1 1\n1 2\n1\n3 2\n3\n100 100\n100 100\n100 100\n4\n1 4\n2 3\n1 5\n3 2\noutput\nCopy\n20\n8\n10\n400\n16\nNote\nIn the first test case, the stamps can be used as shown on the left. Each stamp is highlighted in its own color for clarity.\nAfter all these stamps are used, there is one black region (as shown on the right), and its perimeter is\n20\n. It can be shown that there is no way of using the stamps that yields a lower total perimeter.\nIn the second test case, the second and third stamps can be used entirely inside the first one, so the minimum perimeter is equal to\n8\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Bermart Ice Cream",
        "description": "In the Bermart chain of stores, a variety of ice cream is sold. Each type of ice cream has two parameters: price and tastiness.\nInitially, there is one store numbered\n1\n, which sells nothing. You have to process\nq\nqueries of the following types:\n1 x\n — a new store opens, that sells the same types of ice cream as store\nx\n. It receives the minimum available positive index. The order of the types of ice cream in the new store is the same as in store\nx\n.\n2 x p t\n — a type of ice cream with price\np\nand tastiness\nt\nbecomes available in store\nx\n.\n3 x\n — a type of ice cream that was available the longest (appeared the earliest) in store\nx\nis removed.\n4 x p\n — for store\nx\n, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed\np\n(each type can be used in the subset no more than once).\nInput\nThe first line contains a single integer\nq\n(\n1≤q≤3⋅\n10\n4\n) — the number of queries.\nEach of the following\nq\nlines contains a query in the format described in the statement:\n1 x\n;\n2 x p t\n(\n1≤p,t≤2000\n);\n3 x\n;\n4 x p\n(\n1≤p≤2000\n).\nAdditional constraints on the input data:\nx\nin each query does not exceed the current number of stores (that is,\n1\nplus the number of type\n1\nqueries);\nquery type\n3\nis not applied to a store that has no types of ice cream;\nthere is at least one query of type\n4\n.\nOutput\nFor each query of type\n4\n, output a single integer — for store\nx\n, find the maximum total tastiness of a subset of types of ice cream that are sold there, such that the total price does not exceed\np\n(each type can be used in the subset no more than once).\nExample\ninput\nCopy\n12\n2 1 5 7\n2 1 3 4\n4 1 4\n4 1 8\n4 1 2\n1 1\n2 2 4 10\n4 1 9\n4 2 9\n3 1\n4 1 9\n4 2 9\noutput\nCopy\n4\n11\n0\n11\n17\n4\n17",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "dp",
            "implementation",
            "trees",
            "*2700"
        ]
    },
    {
        "title": "E. Best Subsequence",
        "description": "Given an integer array\na\nof size\nn\n.\nLet's define the value of the array as its size minus the number of set bits in the bitwise OR of all elements of the array.\nFor example, for the array\n[1,0,1,2]\n, the bitwise OR is\n3\n(which contains\n2\nset bits), and the value of the array is\n4−2=2\n.\nYour task is to calculate the maximum possible value of some subsequence of the given array.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<\n2\n60\n).\nOutput\nFor each test case, print the maximum possible value of some subsequence of the given array.\nExample\ninput\nCopy\n4\n3\n0 0 0\n4\n1 0 1 2\n1\n5\n8\n7 1 48 14 13 8 7 6\noutput\nCopy\n3\n2\n0\n3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dfs and similar",
            "flows",
            "graph matchings",
            "graphs",
            "*2500"
        ]
    },
    {
        "title": "D. Sums of Segments",
        "description": "You are given a sequence of integers\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\n. Let\ns(l,r)\nbe the sum of elements from\na\nl\nto\na\nr\n(i. e.\ns(l,r)=\n∑\ni=l\nr\na\ni\n).\nLet's construct another sequence\nb\nof size\nn(n+1)\n2\nas follows:\nb=[s(1,1),s(1,2),…,s(1,n),s(2,2),s(2,3),…,s(2,n),s(3,3),…,s(n,n)]\n.\nFor example, if\na=[1,2,5,10]\n, then\nb=[1,3,8,18,2,7,17,5,15,10]\n.\nYou are given\nq\nqueries. During the\ni\n-th query, you are given two integers\nl\ni\nand\nr\ni\n, and you have to calculate\n∑\nj=\nl\ni\nr\ni\nb\nj\n.\nInput\nThe first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−10≤\na\ni\n≤10\n).\nThe third line contains one integer\nq\n(\n1≤q≤3⋅\n10\n5\n).\nThen\nq\nlines follow, the\ni\n-th of them contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤\nn(n+1)\n2\n).\nOutput\nPrint\nq\nintegers, the\ni\n-th of which should be equal to\n∑\nj=\nl\ni\nr\ni\nb\nj\n.\nExample\ninput\nCopy\n4\n1 2 5 10\n15\n1 1\n1 2\n1 3\n1 4\n1 5\n1 10\n5 10\n6 10\n2 8\n3 4\n3 10\n3 8\n5 6\n5 5\n1 8\noutput\nCopy\n1\n4\n12\n30\n32\n86\n56\n54\n60\n26\n82\n57\n9\n2\n61",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "implementation",
            "math",
            "*1900"
        ]
    },
    {
        "title": "C. Action Figures",
        "description": "There is a shop that sells action figures near Monocarp's house. A new set of action figures will be released shortly; this set contains\nn\nfigures, the\ni\n-th figure costs\ni\ncoins and is available for purchase from day\ni\nto day\nn\n.\nFor each of the\nn\ndays, Monocarp knows whether he can visit the shop.\nEvery time Monocarp visits the shop, he can buy any number of action figures which are sold in the shop (of course, he cannot buy an action figure that is not yet available for purchase). If Monocarp buys at least two figures during the same day, he gets a discount equal to the cost of the most expensive figure he buys (in other words, he gets the most expensive of the figures he buys for free).\nMonocarp wants to buy exactly one\n1\n-st figure, one\n2\n-nd figure, ..., one\nn\n-th figure from the set. He cannot buy the same figure twice. What is the minimum amount of money he has to spend?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n1≤n≤4⋅\n10\n5\n) — the number of figures in the set (and the number of days);\nthe second line contains a string\ns\n(\n|s|=n\n, each\ns\ni\nis either 0 or 1). If Monocarp can visit the shop on the\ni\n-th day, then\ns\ni\nis 1; otherwise,\ns\ni\nis 0.\nAdditional constraints on the input:\nin each test case,\ns\nn\nis 1, so Monocarp is always able to buy all figures during the\nn\n-th day;\nthe sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the minimum amount of money Monocarp has to spend.\nExample\ninput\nCopy\n4\n1\n1\n6\n101101\n7\n1110001\n5\n11111\noutput\nCopy\n1\n8\n18\n6\nNote\nIn the first test case, Monocarp buys the\n1\n-st figure on the\n1\n-st day and spends\n1\ncoin.\nIn the second test case, Monocarp can buy the\n1\n-st and the\n3\n-rd figure on the\n3\n-rd day, the\n2\n-nd and the\n4\n-th figure on the\n4\n-th day, and the\n5\n-th and the\n6\n-th figure on the\n6\n-th day. Then, he will spend\n1+2+5=8\ncoins.\nIn the third test case, Monocarp can buy the\n2\n-nd and the\n3\n-rd figure on the\n3\n-rd day, and all other figures on the\n7\n-th day. Then, he will spend\n1+2+4+5+6=18\ncoins.",
        "time_limit": "2.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "*1500"
        ]
    },
    {
        "title": "B. Black Cells",
        "description": "You are given a strip divided into cells, numbered from left to right from\n0\nto\n10\n18\n. Initially, all cells are white.\nYou can perform the following operation: choose two white cells\ni\nand\nj\n, such that\ni≠j\nand\n|i−j|≤k\n, and paint them black.\nA list\na\nis given. All cells from this list must be painted black. Additionally, at most one cell that is not in this list can also be painted black. Your task is to determine the minimum value of\nk\nfor which this is possible.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2000\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0<\na\ni\n<\n10\n18\n;\na\ni\n<\na\ni+1\n).\nAdditional constraint on the input: the sum of\nn\nacross all test cases does not exceed\n2000\n.\nOutput\nFor each test case, print a single integer — the minimum value of\nk\nfor which it is possible to paint all the given cells black.\nExample\ninput\nCopy\n4\n2\n1 2\n1\n7\n3\n2 4 9\n5\n1 5 8 10 13\noutput\nCopy\n1\n1\n2\n3\nNote\nIn the first example, with\nk=1\n, it is possible to paint the cells\n(1,2)\n.\nIn the second example, with\nk=1\n, it is possible to paint the cells\n(7,8)\n.\nIn the third example, with\nk=2\n, it is possible to paint the cells\n(2,4)\nand\n(8,9)\n.\nIn the fourth example, with\nk=3\n, it is possible to paint the cells\n(0,1)\n,\n(5,8)\nand\n(10,13)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "A. Perpendicular Segments",
        "description": "You are given a coordinate plane and three integers\nX\n,\nY\n, and\nK\n. Find two line segments\nAB\nand\nCD\nsuch that\nthe coordinates of points\nA\n,\nB\n,\nC\n, and\nD\nare integers;\n0≤\nA\nx\n,\nB\nx\n,\nC\nx\n,\nD\nx\n≤X\nand\n0≤\nA\ny\n,\nB\ny\n,\nC\ny\n,\nD\ny\n≤Y\n;\nthe length of segment\nAB\nis at least\nK\n;\nthe length of segment\nCD\nis at least\nK\n;\nsegments\nAB\nand\nCD\nare perpendicular: if you draw lines that contain\nAB\nand\nCD\n, they will cross at a right angle.\nNote that it's not necessary for segments to intersect. Segments are perpendicular as long as the lines they induce are perpendicular.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. Next,\nt\ncases follow.\nThe first and only line of each test case contains three integers\nX\n,\nY\n, and\nK\n(\n1≤X,Y≤1000\n;\n1≤K≤1414\n).\nAdditional constraint on the input: the values of\nX\n,\nY\n, and\nK\nare chosen in such a way that the answer exists.\nOutput\nFor each test case, print two lines. The first line should contain\n4\nintegers\nA\nx\n,\nA\ny\n,\nB\nx\n, and\nB\ny\n — the coordinates of the first segment.\nThe second line should also contain\n4\nintegers\nC\nx\n,\nC\ny\n,\nD\nx\n, and\nD\ny\n — the coordinates of the second segment.\nIf there are multiple answers, print any of them.\nExample\ninput\nCopy\n4\n1 1 1\n3 4 1\n4 3 3\n3 4 4\noutput\nCopy\n0 0 1 0\n0 0 0 1\n2 4 2 2\n0 1 1 1\n0 0 1 3\n1 2 4 1\n0 1 3 4\n0 3 3 0\nNote\nThe answer for the first test case is shown below:\nThe answer for the second test case:\nThe answer for the third test case:\nThe answer for the fourth test case:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "geometry",
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "G. Variable Damage",
        "description": "Monocarp is gathering an army to fight a dragon in a videogame.\nThe army consists of two parts: the heroes and the defensive artifacts. Each hero has one parameter — his health. Each defensive artifact also has one parameter — its durability.\nBefore the battle begins, Monocarp distributes artifacts to the heroes so that each hero receives at most one artifact.\nThe battle consists of rounds that proceed as follows:\nfirst, the dragon deals damage equal to\n1\na+b\n(a real number without rounding) to each hero, where\na\nis the number of heroes alive and\nb\nis the number of active artifacts;\nafter that, all heroes with health\n0\nor less die;\nfinally, some artifacts are deactivated. An artifact with durability\nx\nis deactivated when one of the following occurs: the hero holding the artifact either dies or receives\nx\ntotal damage (from the start of the battle). If an artifact is not held by any hero, it is inactive from the beginning of the battle.\nThe battle ends when there are no heroes left alive.\nInitially, the army is empty. There are\nq\nqueries: add a hero with health\nx\nor an artifact with durability\ny\nto the army. After each query, determine the maximum number of rounds that Monocarp can survive if he distributes the artifacts optimally.\nInput\nThe first line contains one integer\nq\n(\n1≤q≤3⋅\n10\n5\n) — the number of queries.\nIn the\ni\n-th of the following\nq\nlines, there are two integers\nt\ni\nand\nv\ni\n(\nt\ni\n∈{1,2}\n;\n1≤\nv\ni\n≤\n10\n9\n) — the type of the query and the value of the query parameter. If the type is\n1\n, a hero with health\nv\ni\nis added. If the type is\n2\n, an artifact with durability\nv\ni\nis added.\nOutput\nPrint\nq\nintegers. After each query, output the maximum number of rounds that Monocarp can survive if he distributes the artifacts optimally.\nExamples\ninput\nCopy\n3\n2 5\n1 4\n1 10\noutput\nCopy\n0\n8\n19\ninput\nCopy\n10\n1 9\n1 6\n2 4\n1 8\n1 3\n2 10\n1 3\n1 6\n1 10\n2 6\noutput\nCopy\n9\n15\n19\n27\n30\n39\n42\n48\n59\n65\nNote\nLet's consider the first example.\nAn artifact with durability\n5\nis added. Since there are no heroes yet, the battle ends immediately.\nA hero with health\n4\nis added. Monocarp can give him an artifact with durability\n5\n. First, there are rounds in which the hero takes\n1\n1+1\n=\n1\n2\ndamage. After\n8\nsuch rounds, a total of\n4\ndamage will have been dealt, and the hero will die, while the artifact will deactivate. There are no more heroes alive, so the battle ends after\n8\nrounds.\nA hero with health\n10\nis added. Now let the artifact with durability\n5\nbe with this hero. Then, in the first\n12\nrounds, the heroes will take\n12⋅\n1\n2+1\n=4\ndamage, and the first hero will die. The second hero has\n6\nhealth left, and the artifact has\n1\ndurability. Now the damage is\n1\n2\n, so after another\n2\nrounds, the artifact will deactivate. The second hero has\n5\nhealth left. After another\n5\nrounds, the second hero will die. Therefore, the answer is\n12+2+5=19\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "flows",
            "*3000"
        ]
    },
    {
        "title": "F. Choose Your Queries",
        "description": "You are given an array\na\n, consisting of\nn\nintegers (numbered from\n1\nto\nn\n). Initially, they are all zeroes.\nYou have to process\nq\nqueries. The\ni\n-th query consists of two different integers\nx\ni\nand\ny\ni\n. During the\ni\n-th query, you have to choose an integer\np\n(which is either\nx\ni\nor\ny\ni\n) and an integer\nd\n(which is either\n1\nor\n−1\n), and assign\na\np\n=\na\np\n+d\n.\nAfter each query, every element of\na\nshould be a non-negative integer.\nProcess all queries in such a way that the sum of all elements of\na\nafter the last query is the minimum possible.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n2≤n≤3⋅\n10\n5\n;\n1≤q≤3⋅\n10\n5\n) — the number of elements in\na\nand the number of queries, respectively.\nThen\nq\nlines follow. The\ni\n-th of these lines contains two integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n;\nx\ni\n≠\ny\ni\n) — the description of the\ni\n-th query.\nOutput\nFor each query, print a line containing two characters:\nthe first character should be x if you choose\np=\nx\ni\n, or y if you choose\np=\ny\ni\n;\nthe second character should be + if you choose\nd=1\n, or - if you choose\nd=−1\n.\nIf there are multiple answers, print any of them.\nExamples\ninput\nCopy\n3 4\n1 2\n3 2\n3 1\n1 2\noutput\nCopy\ny+\nx+\nx-\ny-\ninput\nCopy\n4 4\n1 2\n2 3\n3 4\n3 2\noutput\nCopy\ny+\ny+\nx-\ny-\ninput\nCopy\n4 2\n2 1\n4 3\noutput\nCopy\ny+\nx+",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "graphs",
            "greedy",
            "trees",
            "*2700"
        ]
    },
    {
        "title": "E. Card Game",
        "description": "In the most popular card game in Berland, a deck of\nn×m\ncards is used. Each card has two parameters: suit and rank. Suits in the game are numbered from\n1\nto\nn\n, and ranks are numbered from\n1\nto\nm\n. There is exactly one card in the deck for each combination of suit and rank.\nA card with suit\na\nand rank\nb\ncan beat a card with suit\nc\nand rank\nd\nin one of two cases:\na=1\n,\nc≠1\n(a card of suit\n1\ncan beat a card of any other suit);\na=c\n,\nb>d\n(a card can beat any other card of the same suit but of a lower rank).\nTwo players play the game. Before the game starts, they receive exactly half of the deck each. The first player wins if for every card of the second player, he can choose his card that can beat it, and there is no card that is chosen twice (i. e. there exists a matching of the first player's cards with the second player's cards such that in each pair the first player's card beats the second player's card). Otherwise, the second player wins.\nYour task is to calculate the number of ways to distribute the cards so that the first player wins. Two ways are considered different if there exists a card such that in one way it belongs to the first player and in the other way it belongs to the second player. The number of ways can be very large, so print it modulo\n998244353\n.\nInput\nThe only line contains two integers\nn\nand\nm\n(\n1≤n,m≤500\n).\nAdditional constraint on the input:\nm\nis even.\nOutput\nPrint a single integer — the number of ways to distribute the cards so that the first player wins, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n1 4\noutput\nCopy\n2\ninput\nCopy\n2 2\noutput\nCopy\n2\ninput\nCopy\n3 6\noutput\nCopy\n1690\ninput\nCopy\n5 4\noutput\nCopy\n568\ninput\nCopy\n500 500\noutput\nCopy\n84693741",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "greedy",
            "math",
            "*2200"
        ]
    },
    {
        "title": "D. Attribute Checks",
        "description": "Imagine a game where you play as a character that has two attributes: \"Strength\" and \"Intelligence\", that are at zero level initially.\nDuring the game, you'll acquire\nm\nattribute points that allow you to increase your attribute levels — one point will increase one of the attributes by one level. But sometimes, you'll encounter a so-called \"Attribute Checks\": if your corresponding attribute is high enough, you'll pass it; otherwise, you'll fail it.\nSpending some time, you finally prepared a list which contains records of all points you got and all checks you've met. And now you're wondering: what is the maximum number of attribute checks you can pass in a single run if you'd spend points wisely?\nNote that you can't change the order of records.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n1≤m≤5000\n;\nm<n≤2⋅\n10\n6\n) — the number of records in the list and the total number of points you'll get during the game.\nThe second line contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\n−m≤\nr\ni\n≤m\n), where\nr\ni\nencodes the\ni\n-th record:\nIf\nr\ni\n=0\n, then the\ni\n-th record is an acquiring one attribute point. You can spend to level up either Strength or Intelligence;\nIf\nr\ni\n>0\n, then it's an Intelligence check: if your Intelligence level is greater than or equal to\n|\nr\ni\n|\n, you pass.\nIf\nr\ni\n<0\n, then it's a Strength check: if your Strength level is greater than or equal to\n|\nr\ni\n|\n, you pass.\nAdditional constraint on the input: the sequence\nr\n1\n,\nr\n2\n,…,\nr\nn\ncontains exactly\nm\nelements equal to\n0\n.\nOutput\nPrint one integer — the maximum number of checks you can pass.\nExamples\ninput\nCopy\n10 5\n0 1 0 2 0 -3 0 -4 0 -5\noutput\nCopy\n3\ninput\nCopy\n3 1\n1 -1 0\noutput\nCopy\n0\ninput\nCopy\n9 3\n0 0 1 0 2 -3 -2 -2 1\noutput\nCopy\n4\nNote\nIn the first test, it's optimal to spend each point in Strength, so you'll fail\n2\nIntelligence checks but pass\n3\nStrength checks.\nIn the second test, you'll fail both checks, since the first point you get comes after the checks.\nIn the third test, one of the optimal strategies is:\nspend the first point on Intelligence;\nspend the second point on Strength;\nspend the third point on Strength;\nAs a result, you'll pass\n2\nIntelligence checks\nr\n3\nand\nr\n9\nand\n2\nStrength checks\nr\n7\nand\nr\n8\n.",
        "time_limit": "2.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math",
            "two pointers",
            "*1800"
        ]
    },
    {
        "title": "C. New Game",
        "description": "There's a new game Monocarp wants to play. The game uses a deck of\nn\ncards, where the\ni\n-th card has exactly one integer\na\ni\nwritten on it.\nAt the beginning of the game, on the first turn, Monocarp can take any card from the deck. During each subsequent turn, Monocarp can take exactly one card that has either the same number as on the card taken on the previous turn or a number that is one greater than the number on the card taken on the previous turn.\nIn other words, if on the previous turn Monocarp took a card with the number\nx\n, then on the current turn he can take either a card with the number\nx\nor a card with the number\nx+1\n. Monocarp can take any card which meets that condition, regardless of its position in the deck.\nAfter Monocarp takes a card on the current turn, it is removed from the deck.\nAccording to the rules of the game, the number of distinct numbers written on the cards that Monocarp has taken must not exceed\nk\n.\nIf, after a turn, Monocarp cannot take a card without violating the described rules, the game ends.\nYour task is to determine the maximum number of cards that Monocarp can take from the deck during the game, given that on the first turn he can take any card from the deck.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤200000\n) — the number of cards in the deck and the maximum number of distinct numbers that can be written on the cards that Monocarp takes.\nThe second line contains a sequence of integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the number written on the\ni\n-th card.\nAdditional constraint of the input: the sum of\nn\nover all test cases doesn't exceed\n200000\n.\nOutput\nFor each test case, print the maximum number of cards that Monocarp can take from the deck during the game, given that on the first turn he can take any card from the deck.\nExample\ninput\nCopy\n4\n10 2\n5 2 4 3 4 3 4 5 3 2\n5 1\n10 11 10 11 10\n9 3\n4 5 4 4 6 5 4 4 6\n3 2\n1 3 1\noutput\nCopy\n6\n3\n9\n2\nNote\nIn the first example, Monocarp needs to take any of the cards with the number\n3\n. On the next two turns, he needs to take the two remaining cards with the number\n3\n. On the next three turns, he needs to take three cards with the number\n4\n. After that, Monocarp will not be able to take any more cards from the deck, and he will have\n6\ncards.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "two pointers",
            "*1300"
        ]
    },
    {
        "title": "B. Binomial Coefficients, Kind Of",
        "description": "Recently, akshiM met a task that needed binomial coefficients to solve. He wrote a code he usually does that looked like this:\n    for (int n = 0; n < N; n++) { // loop over n from 0 to N-1 (inclusive)\n        C[n][0] = 1;\n        C[n][n] = 1;\n        for (int k = 1; k < n; k++) // loop over k from 1 to n-1 (inclusive)\n            C[n][k] = C[n][k - 1] + C[n - 1][k - 1];\n    }\nUnfortunately, he made an error, since the right formula is the following:\n            C[n][k] = C[n - 1][k] + C[n - 1][k - 1]\nBut his team member keblidA is interested in values that were produced using the wrong formula. Please help him to calculate these coefficients for\nt\nvarious pairs\n(\nn\ni\n,\nk\ni\n)\n. Note that they should be calculated according to the first (wrong) formula.\nSince values\nC[\nn\ni\n][\nk\ni\n]\nmay be too large, print them modulo\n10\n9\n+7\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of pairs. Next,\nt\npairs are written in two lines.\nThe second line contains\nt\nintegers\nn\n1\n,\nn\n2\n,…,\nn\nt\n(\n2≤\nn\ni\n≤\n10\n5\n).\nThe third line contains\nt\nintegers\nk\n1\n,\nk\n2\n,…,\nk\nt\n(\n1≤\nk\ni\n<\nn\ni\n).\nOutput\nPrint\nt\nintegers\nC[\nn\ni\n][\nk\ni\n]\nmodulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n7\n2 5 5 100000 100000 100000 100000\n1 2 3 1 33333 66666 99999\noutput\nCopy\n2\n4\n8\n2\n326186014\n984426998\n303861760",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Two Screens",
        "description": "There are two screens which can display sequences of uppercase Latin letters. Initially, both screens display nothing.\nIn one second, you can do one of the following two actions:\nchoose a screen and an uppercase Latin letter, and append that letter to the end of the sequence displayed on that screen;\nchoose a screen and copy the sequence from it to the other screen, overwriting the sequence that was displayed on the other screen.\nYou have to calculate the minimum number of seconds you have to spend so that the first screen displays the sequence\ns\n, and the second screen displays the sequence\nt\n.\nInput\nThe first line contains one integer\nq\n(\n1≤q≤500\n) — the number of test cases.\nEach test case consists of two lines. The first line contains the string\ns\n, and the second line contains the string\nt\n(\n1≤|s|,|t|≤100\n). Both strings consist of uppercase Latin letters.\nOutput\nFor each test case, print one integer — the minimum possible number of seconds you have to spend so that the first screen displays the sequence\ns\n, and the second screen displays the sequence\nt\n.\nExample\ninput\nCopy\n3\nGARAGE\nGARAGEFORSALE\nABCDE\nAABCD\nTRAINING\nDRAINING\noutput\nCopy\n14\n10\n16\nNote\nIn the first test case, the following sequence of actions is possible:\nspend\n6\nseconds to write the sequence GARAGE on the first screen;\ncopy the sequence from the first screen to the second screen;\nspend\n7\nseconds to complete the sequence on the second screen by writing FORSALE.\nIn the second test case, the following sequence of actions is possible:\nspend\n1\nsecond to write the sequence A on the second screen;\ncopy the sequence from the second screen to the first screen;\nspend\n4\nseconds to complete the sequence on the first screen by writing BCDE;\nspend\n4\nseconds to complete the sequence on the second screen by writing ABCD.\nIn the third test case, the fastest way to display the sequences is to type both of them character by character without copying, and this requires\n16\nseconds.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "strings",
            "two pointers",
            "*800"
        ]
    },
    {
        "title": "B. Buying Lemonade",
        "description": "There is a vending machine that sells lemonade. The machine has a total of\nn\nslots. You know that initially, the\ni\n-th slot contains\na\ni\ncans of lemonade. There are also\nn\nbuttons on the machine, each button corresponds to a slot, with exactly one button corresponding to each slot. Unfortunately, the labels on the buttons have worn off, so you do not know which button corresponds to which slot.\nWhen you press the button corresponding to the\ni\n-th slot, one of two events occurs:\nIf there is a can of lemonade in the\ni\n-th slot, it will drop out and you will take it. At this point, the number of cans in the\ni\n-th slot decreases by\n1\n.\nIf there are no cans of lemonade left in the\ni\n-th slot, nothing will drop out.\nAfter pressing, the can drops out so quickly that it is impossible to track from which slot it fell. The contents of the slots are hidden from your view, so you cannot see how many cans are left in each slot. The only thing you know is the initial number of cans in the slots:\na\n1\n,\na\n2\n,…,\na\nn\n.\nDetermine the minimum number of button presses needed to guarantee that you receive at least\nk\ncans of lemonade.\nNote that you can adapt your strategy during the button presses based on whether you received a can or not. It is guaranteed that there are at least\nk\ncans of lemonade in total in the machine. In other words,\nk≤\na\n1\n+\na\n2\n+…+\na\nn\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,\n1≤k≤\n10\n9\n) — the number of slots in the machine and the required number of cans of lemonade.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of cans in the slots.\nIt is guaranteed that\nk≤\na\n1\n+\na\n2\n+…+\na\nn\n, meaning there are at least\nk\ncans of lemonade in the machine.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of button presses needed to guarantee that you receive at least\nk\ncans of lemonade.\nExample\ninput\nCopy\n5\n2 1\n1 1\n2 2\n1 2\n3 4\n2 1 3\n10 50\n1 1 3 8 8 9 12 13 27 27\n2 1000000000\n1000000000 500000000\noutput\nCopy\n1\n2\n5\n53\n1000000000\nNote\nIn the first test case, we can simply press the first button and receive one can of lemonade.\nIn the second test case, we can press each button once and guarantee that we receive\n2\ncans of lemonade. Note that if we simply press one button twice, we might not be lucky, and that button could correspond to the first slot, in which case we would only receive\n1\ncan of lemonade for two presses.\nIn the third test case, one of the optimal strategies is as follows:\nPress the first button twice. After the first press, a can of lemonade will definitely drop out. Then there are two options:\nIf no can of lemonade drops after the second press, we know that this button must correspond to the second slot, since\na\n2\n=1\nand\na\n1\n,\na\n3\n>1\n. Then we can press the second button twice and the third button once. Since\na\n1\n,\na\n3\n≥2\n, we will definitely receive three cans of lemonade for these three presses. Thus, after\n5\npresses, we will have\n4\ncans of lemonade.\nIf a can of lemonade drops after the second press, we can make one press on the second button and one press on the third button. After each of these presses, we will definitely receive a can of lemonade. Thus, after\n4\npresses, we will have\n4\ncans of lemonade.\nIt can be shown that it is impossible to guarantee receiving\n4\ncans of lemonade with only\n4\npresses, so the answer is\n5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "sortings",
            "*1100"
        ]
    },
    {
        "title": "A. Profitable Interest Rate",
        "description": "Alice has\na\ncoins. She can open a bank deposit called \"Profitable\", but the minimum amount required to open this deposit is\nb\ncoins.\nThere is also a deposit called \"Unprofitable\", which can be opened with any amount of coins. Alice noticed that if she opens the \"Unprofitable\" deposit with\nx\ncoins, the minimum amount required to open the \"Profitable\" deposit decreases by\n2x\ncoins. However, these coins cannot later be deposited into the \"Profitable\" deposit.\nHelp Alice determine the maximum number of coins she can deposit into the \"Profitable\" deposit if she first deposits some amount of coins (possibly\n0\n) into the \"Unprofitable\" deposit. If Alice can never open the \"Profitable\" deposit, output\n0\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nA single line of each test case contains two integers\na\nand\nb\n(\n1≤a,b≤\n10\n9\n) — the number of coins Alice has and the initial minimum amount required to open the \"Profitable\" deposit.\nOutput\nFor each test case, output a single integer — the maximum number of coins that Alice can deposit into the \"Profitable\" deposit. If Alice can never open the \"Profitable\" deposit, output\n0\n.\nExample\ninput\nCopy\n5\n10 5\n7 9\n5 100\n1 1\n1 2\noutput\nCopy\n10\n5\n0\n1\n0\nNote\nIn the first test case,\na≥b\n, so Alice can immediately open the \"Profitable\" deposit with all\n10\ncoins.\nIn the second test case, Alice can open the \"Unprofitable\" deposit with\n2\ncoins. Then she will have\n5\ncoins left, but the minimum amount required to open the \"Profitable\" deposit will decrease by\n4\ncoins, making it equal to\n5\ncoins. Thus, Alice will be able to open the \"Profitable\" deposit with\n5\ncoins.\nIn the third test case, Alice will not be able to open the \"Profitable\" deposit.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Hills and Pits",
        "description": "In a desert city with a hilly landscape, the city hall decided to level the road surface by purchasing a dump truck. The road is divided into\nn\nsections, numbered from\n1\nto\nn\nfrom left to right. The height of the surface in the\ni\n-th section is equal to\na\ni\n. If the height of the\ni\n-th section is greater than\n0\n, then the dump truck must take sand from the\ni\n-th section of the road, and if the height of the\ni\n-th section is less than\n0\n, the dump truck must fill the pit in the\ni\n-th section of the road with sand. It is guaranteed that the initial heights are not equal to\n0\n.\nWhen the dump truck is in the\ni\n-th section of the road, it can either take away\nx\nunits of sand, in which case the height of the surface in the\ni\n-th section will decrease by\nx\n, or it can fill in\nx\nunits of sand (provided that it currently has at least\nx\nunits of sand in its bed), in which case the height of the surface in the\ni\n-th section of the road will increase by\nx\n.\nThe dump truck can start its journey from any section of the road. Moving to an adjacent section on the left or right takes\n1\nminute, and the time for loading and unloading sand can be neglected. The dump truck has an infinite capacity and is initially empty.\nYou need to find the minimum time required for the dump truck to level the sand so that the height in each section becomes equal to\n0\n. Note that after all movements, the dump truck may still have sand left in its bed. You need to solve this problem independently for the segments numbered from\nl\ni\nto\nr\ni\n. Sand outside the segment cannot be used.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤3⋅\n10\n5\n) — the number of sections and the number of queries.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n,\na\ni\n≠0\n) — the initial height in each section.\nThe\ni\n-th of the following\nq\nlines contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the boundaries of the segment of sections for which the minimum time needs to be determined.\nIt is guaranteed that the sum of\nn\nover all test cases and the sum of\nq\nover all test cases do not exceed\n3⋅\n10\n5\n.\nOutput\nFor each query, output the minimum time required to level the sand in the segment\n[\nl\ni\n,\nr\ni\n]\n, or\n−1\nif it is impossible.\nExample\ninput\nCopy\n5\n1 1\n-179\n1 1\n5 3\n-2 2 -1 3 -1\n2 4\n1 5\n1 3\n7 1\n1 1 1 -4 1 1 1\n1 7\n7 2\n2 -2 2 -2 1 2 -1\n1 7\n2 7\n4 4\n1000000000 1000000000 999999999 -1000000000\n2 4\n3 4\n2 3\n1 3\noutput\nCopy\n-1\n2\n5\n-1\n8\n6\n6\n2\n-1\n1\n2\nNote\nIn the first test case,\n179\nunits of sand need to be added to the only section. However, there is nowhere to take it from, so this is impossible.\nIn the second test case:\nIn the first query, the dump truck can start its journey at the second section. It can take\n2\nunits of sand, after which the height in the second section will become\n0\n. Then the dump truck can move to the third section. It can pour\n1\nunit of sand there, after which the height in the third section will become\n0\n. Then the dump truck can move to the fourth section. There it can take\n3\nunits of sand, after which the height in the fourth section will become\n0\n. In total, the dump truck will spend\n2\nminutes on movements.\nIn the second query, the dump truck can start its journey at the fourth section. It can take\n3\nunits of sand, after which the height in the fourth section will become\n0\n. Then the dump truck can move to the fifth section. It can pour\n1\nunit of sand there, after which the height in the fifth section will become\n0\n. Then the dump truck can move back to the fourth section and then to the third. It can pour\n1\nunit of sand there, after which the height in the third section will become\n0\n. Then the dump truck can move to the second section. It can take\n2\nunits of sand. Then it can move to the first section. It can pour\n2\nunits of sand there, after which the height in the first section will become\n0\n. In total, the dump truck will spend\n5\nminutes on movements.\nIn the third query, the dump truck will not be able to make the height in each section equal to\n0\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "matrices",
            "*3500"
        ]
    },
    {
        "title": "E. Tree of Life",
        "description": "In the heart of an ancient kingdom grows the legendary Tree of Life — the only one of its kind and the source of magical power for the entire world. The tree consists of\nn\nnodes. Each node of this tree is a magical source, connected to other such sources through magical channels (edges). In total, there are\nn−1\nchannels in the tree, with the\ni\n-th channel connecting nodes\nv\ni\nand\nu\ni\n. Moreover, there exists a unique simple path through the channels between any two nodes in the tree.\nHowever, the magical energy flowing through these channels must be balanced; otherwise, the power of the Tree of Life may disrupt the natural order and cause catastrophic consequences. The sages of the kingdom discovered that when two magical channels converge at a single node, a dangerous \"magical resonance vibration\" occurs between them. To protect the Tree of Life and maintain its balance, it is necessary to select several paths and perform special rituals along them. A path is a sequence of distinct nodes\nv\n1\n,\nv\n2\n,…,\nv\nk\n, where each pair of adjacent nodes\nv\ni\nand\nv\ni+1\nis connected by a channel. When the sages perform a ritual along such a path, the resonance vibration between the channels\n(\nv\ni\n,\nv\ni+1\n)\nand\n(\nv\ni+1\n,\nv\ni+2\n)\nis blocked for each\n1≤i≤k−2\n.\nThe sages' task is to select the minimum number of paths and perform rituals along them to block all resonance vibrations. This means that for every pair of channels emanating from a single node, there must exist at least one selected path that contains both of these channels.\nHelp the sages find the minimum number of such paths so that the magical balance of the Tree of Life is preserved, and its power continues to nourish the entire world!\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤4⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤5⋅\n10\n5\n) — the number of nodes in the Tree of Life.\nThe\ni\n-th of the following\nn−1\nlines of each test case contains two integers\nv\ni\nand\nu\ni\n(\n1≤\nv\ni\n<\nu\ni\n≤n\n) — the channel connecting nodes\nv\ni\nand\nu\ni\n.\nIt is guaranteed that there exists a unique simple path through the channels between any two nodes.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of paths that the sages need to select to prevent a catastrophe.\nExample\ninput\nCopy\n5\n4\n1 2\n2 3\n3 4\n2\n1 2\n4\n1 2\n1 3\n1 4\n8\n3 7\n2 4\n1 2\n2 5\n3 6\n1 3\n3 8\n6\n2 3\n1 2\n3 6\n1 5\n1 4\noutput\nCopy\n1\n0\n3\n7\n3\nNote\nIn the first test case, there are two pairs of channels emanating from a single node:\n(1,2)\nand\n(2,3)\n,\n(2,3)\nand\n(3,4)\n. It is sufficient to perform the ritual along the path\n1−2−3−4\n. Thus, the answer is\n1\n.\nIn the second test case, there are no pairs of channels emanating from a single node, so the answer is\n0\n.\nIn the third test case, rituals can be performed along the paths\n2−1−3\n,\n2−1−4\n, and\n3−1−4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "greedy",
            "trees",
            "*3300"
        ]
    },
    {
        "title": "D. Many Games",
        "description": "Recently, you received a rare ticket to the only casino in the world where you can actually earn something, and you want to take full advantage of this opportunity.\nThe conditions in this casino are as follows:\nThere are a total of\nn\ngames in the casino.\nYou can play each game at most once.\nEach game is characterized by two parameters:\np\ni\n(\n1≤\np\ni\n≤100\n) and\nw\ni\n— the probability of winning the game in percentage and the winnings for a win.\nIf you lose in any game you decide to play, you will receive nothing at all (even for the games you won).\nYou need to choose a set of games in advance that you will play in such a way as to maximize the expected value of your winnings.\nIn this case, if you choose to play the games with indices\ni\n1\n<\ni\n2\n<…<\ni\nk\n, you will win in all of them with a probability of\n∏\nj=1\nk\np\ni\nj\n100\n, and in that case, your winnings will be equal to\n∑\nj=1\nk\nw\ni\nj\n.\nThat is, the expected value of your winnings will be\n(\n∏\nj=1\nk\np\ni\nj\n100\n)⋅(\n∑\nj=1\nk\nw\ni\nj\n)\n(\n.\nTo avoid going bankrupt, the casino owners have limited the expected value of winnings for each individual game. Thus, for all\ni\n(\n1≤i≤n\n), it holds that\nw\ni\n⋅\np\ni\n≤2⋅\n10\n5\n.\nYour task is to find the maximum expected value of winnings that can be obtained by choosing some set of games in the casino.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of games offered to play.\nThe\ni\n-th of the following\nn\nlines contains two integers\np\ni\nand\nw\ni\n(\n1≤\np\ni\n≤100\n,\n1≤\nw\ni\n,\np\ni\n⋅\nw\ni\n≤2⋅\n10\n5\n) — the probability of winning and the size of the winnings in the\ni\n-th game.\nOutput\nOutput a single number — the maximum expected value of winnings in the casino that can be obtained by choosing some subset of games.\nYour answer will be accepted if the relative or absolute error does not exceed\n10\n−6\n. Formally, if\na\nis your answer and\nb\nis the jury's answer, it will be accepted if\n|a−b|\nmax(b,1)\n≤\n10\n−6\n.\nExamples\ninput\nCopy\n3\n80 80\n70 100\n50 200\noutput\nCopy\n112.00000000\ninput\nCopy\n2\n100 1\n100 1\noutput\nCopy\n2.00000000\ninput\nCopy\n4\n1 100\n2 1000\n2 100\n3 1\noutput\nCopy\n20.00000000\ninput\nCopy\n5\n34 804\n78 209\n99 191\n61 439\n90 79\noutput\nCopy\n395.20423800\nNote\nIn the first example, you can choose the first and third games. In this case, the expected value of winnings will be\n(\np\n1\n100\n⋅\np\n3\n100\n)⋅(\nw\n1\n+\nw\n3\n)=(\n80\n100\n⋅\n50\n100\n)⋅(80+200)=112\n.\nIn the second example, you can choose the first and second games. In this case, the expected value of winnings will be\n(\np\n1\n100\n⋅\np\n2\n100\n)⋅(\nw\n1\n+\nw\n2\n)=(\n100\n100\n⋅\n100\n100\n)⋅(1+1)=2\n(\n.\nIn the third example, you can choose only the second game. In this case, the expected value of winnings will be\np\n2\n100\n⋅\nw\n2\n=\n2\n100\n⋅1000=20\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "probabilities",
            "*2900"
        ]
    },
    {
        "title": "C. C+K+S",
        "description": "You are given two strongly connected\n†\n†\ndirected graphs, each with exactly\nn\nvertices, but possibly different numbers of edges. Upon closer inspection, you noticed an important feature — the length of any cycle in these graphs is divisible by\nk\n.\nEach of the\n2n\nvertices belongs to exactly one of two types: incoming or outgoing. For each vertex, its type is known to you.\nYou need to determine whether it is possible to draw exactly\nn\ndirected edges between the source graphs such that the following four conditions are met:\nThe ends of any added edge lie in different graphs.\nFrom each outgoing vertex, exactly one added edge originates.\nInto each incoming vertex, exactly one added edge enters.\nIn the resulting graph, the length of any cycle is divisible by\nk\n.\n†\n†\nA strongly connected graph is a graph in which there is a path from every vertex to every other vertex.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n2≤k≤n≤2⋅\n10\n5\n) — the number of vertices in each graph and the value by which the length of each cycle is divisible.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\na\ni\n∈{0,1}\n). If\na\ni\n=0\n, then vertex\ni\nof the first graph is incoming. If\na\ni\n=1\n, then vertex\ni\nof the first graph is outgoing.\nThe third line of each test case contains a single integer\nm\n1\n(\n1≤\nm\n1\n≤5⋅\n10\n5\n) — the number of edges in the first graph.\nThe next\nm\n1\nlines contain descriptions of the edges of the first graph. The\ni\n-th of them contains two integers\nv\ni\nand\nu\ni\n(\n1≤\nv\ni\n,\nu\ni\n≤n\n) — an edge in the first graph leading from vertex\nv\ni\nto vertex\nu\ni\n.\nNext, in the same format, follows the description of the second graph.\nThe next line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\nb\ni\n∈{0,1}\n). If\nb\ni\n=0\n, then vertex\ni\nof the second graph is incoming. If\nb\ni\n=1\n, then vertex\ni\nof the second graph is outgoing.\nThe next line contains a single integer\nm\n2\n(\n1≤\nm\n2\n≤5⋅\n10\n5\n) — the number of edges in the second graph.\nThe next\nm\n2\nlines contain descriptions of the edges of the second graph. The\ni\n-th of them contains two integers\nv\ni\nand\nu\ni\n(\n1≤\nv\ni\n,\nu\ni\n≤n\n) — an edge in the second graph leading from vertex\nv\ni\nto vertex\nu\ni\n.\nIt is guaranteed that both graphs are strongly connected, and the lengths of all cycles are divisible by\nk\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. It is guaranteed that the sum of\nm\n1\nand the sum of\nm\n2\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" (without quotes) if it is possible to draw\nn\nnew edges such that all conditions are met, and \"NO\" (without quotes) otherwise.\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n3\n4 2\n1 0 0 1\n4\n1 2\n2 3\n3 4\n4 1\n1 0 0 1\n4\n1 3\n3 2\n2 4\n4 1\n3 3\n0 0 0\n3\n1 2\n2 3\n3 1\n1 1 0\n3\n1 2\n2 3\n3 1\n4 2\n1 1 1 1\n4\n1 2\n2 3\n3 4\n4 1\n0 0 0 0\n6\n1 2\n2 1\n1 3\n3 1\n1 4\n4 1\noutput\nCopy\nYES\nNO\nYES\nNote\nIn the first test case, it is possible to draw edges from the first graph to the second graph as\n(1,3)\nand\n(4,2)\n(the first number in the pair is the vertex number in the first graph, and the second number in the pair is the vertex number in the second graph), and from the second graph to the first graph as\n(1,2)\n,\n(4,3)\n(the first number in the pair is the vertex number in the second graph, and the second number in the pair is the vertex number in the first graph).\nIn the second test case, there are a total of\n4\nincoming vertices and\n2\noutgoing vertices, so it is not possible to draw\n3\nedges.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "greedy",
            "hashing",
            "implementation",
            "strings",
            "*2400"
        ]
    },
    {
        "title": "B. Skipping",
        "description": "It is already the year\n3024\n, ideas for problems have long run out, and the olympiad now takes place in a modified individual format. The olympiad consists of\nn\nproblems, numbered from\n1\nto\nn\n. The\ni\n-th problem has its own score\na\ni\nand a certain parameter\nb\ni\n(\n1≤\nb\ni\n≤n\n).\nInitially, the testing system gives the participant the first problem. When the participant is given the\ni\n-th problem, they have two options:\nThey can submit the problem and receive\na\ni\npoints;\nThey can skip the problem, in which case they will never be able to submit it.\nThen, the testing system selects the next problem for the participant from problems with indices\nj\n, such that:\nIf he submitted the\ni\n-th problem, it looks at problems with indices\nj<i\n;\nIf he skipped the\ni\n-th problem, it looks at problems with indices\nj≤\nb\ni\n.\nAmong these problems, it selects the problem with the maximum index that it has not previously given to the participant (he has neither submitted nor skipped it before). If there is no such problem, then the competition for the participant ends, and their result is equal to the sum of points for all submitted problems. In particular, if the participant submits the first problem, then the competition for them ends. Note that the participant receives each problem at most once.\nProkhor has prepared thoroughly for the olympiad, and now he can submit any problem. Help him determine the maximum number of points he can achieve.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤4⋅\n10\n5\n) — the number of problems in the olympiad.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the scores of the problems.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n) — the parameters of the problems.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum number of points that Prokhor can achieve.\nExample\ninput\nCopy\n4\n2\n15 16\n2 1\n5\n10 10 100 100 1000\n3 4 1 1 1\n3\n100 49 50\n3 2 2\n4\n100 200 300 1000\n2 3 4 1\noutput\nCopy\n16\n200\n100\n1000\nNote\nIn the first test case, Prokhor can skip the first problem; then he will receive the problem with index\nb\n1\n=2\n. Prokhor can submit it and receive\na\n2\n=16\npoints. After that, the competition will end because Prokhor has already received all problems. Note that if Prokhor submits the first problem, he will receive\na\n1\n=15\npoints, but the competition will end immediately.\nIn the second test case, Prokhor can skip the first problem; then he will receive the problem with index\nb\n1\n=3\n. Prokhor can submit it and receive\na\n3\n=100\npoints. After that, Prokhor will receive the second problem, which he can skip to receive the problem with index\nb\n2\n=4\n. Prokhor can submit the fourth problem and receive another\na\n4\n=100\npoints. After that, the competition ends because Prokhor has already received all problems with indices not exceeding\n4\n. Thus, Prokhor will receive a total of\n200\npoints.\nIn the third test case, Prokhor can submit the first problem and receive\n100\npoints, after which the competition will end immediately.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "graphs",
            "shortest paths",
            "*1700"
        ]
    },
    {
        "title": "A. Concatenation of Arrays",
        "description": "You are given\nn\narrays\na\n1\n,\n…\n,\na\nn\n. The length of each array is two. Thus,\na\ni\n=[\na\ni,1\n,\na\ni,2\n]\n. You need to concatenate the arrays into a single array of length\n2n\nsuch that the number of inversions\n†\n†\nin the resulting array is minimized. Note that you do not need to count the actual number of inversions.\nMore formally, you need to choose a permutation\n‡\n‡\np\nof length\nn\n, so that the array\nb=[\na\np\n1\n,1\n,\na\np\n1\n,2\n,\na\np\n2\n,1\n,\na\np\n2\n,2\n,…,\na\np\nn\n,1\n,\na\np\nn\n,2\n]\ncontains as few inversions as possible.\n†\n†\nThe number of inversions in an array\nc\nis the number of pairs of indices\ni\nand\nj\nsuch that\ni<j\nand\nc\ni\n>\nc\nj\n.\n‡\n‡\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of arrays.\nEach of the following\nn\nlines contains two integers\na\ni,1\nand\na\ni,2\n(\n1≤\na\ni,j\n≤\n10\n9\n) — the elements of the\ni\n-th array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output\n2n\nintegers — the elements of the array you obtained. If there are multiple solutions, output any of them.\nExample\ninput\nCopy\n4\n2\n1 4\n2 3\n3\n3 2\n4 3\n2 1\n5\n5 10\n2 3\n9 6\n4 1\n8 7\n1\n10 20\noutput\nCopy\n2 3 1 4\n2 1 3 2 4 3\n4 1 2 3 5 10 8 7 9 6\n10 20\nNote\nIn the first test case, we concatenated the arrays in the order\n2,1\n. Let's consider the inversions in the resulting array\nb=[2,3,1,4]\n:\ni=1\n,\nj=3\n, since\nb\n1\n=2>1=\nb\n3\n;\ni=2\n,\nj=3\n, since\nb\n2\n=3>1=\nb\n3\n.\nThus, the number of inversions is\n2\n. It can be proven that this is the minimum possible number of inversions.\nIn the second test case, we concatenated the arrays in the order\n3,1,2\n. Let's consider the inversions in the resulting array\nb=[2,1,3,2,4,3]\n:\ni=1\n,\nj=2\n, since\nb\n1\n=2>1=\nb\n2\n;\ni=3\n,\nj=4\n, since\nb\n3\n=3>2=\nb\n4\n;\ni=5\n,\nj=6\n, since\nb\n5\n=4>3=\nb\n6\n.\nThus, the number of inversions is\n3\n. It can be proven that this is the minimum possible number of inversions.\nIn the third test case, we concatenated the arrays in the order\n4,2,1,5,3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*1300"
        ]
    },
    {
        "title": "E2. Billetes MX (Hard Version)",
        "description": "This is the hard version of the problem. In this version, it is guaranteed that\nq≤\n10\n5\n. You can make hacks only if both versions of the problem are solved.\nAn integer grid\nA\nwith\np\nrows and\nq\ncolumns is called beautiful if:\nAll elements of the grid are integers between\n0\nand\n2\n30\n−1\n, and\nFor any subgrid, the XOR of the values at the corners is equal to\n0\n. Formally, for any four integers\ni\n1\n,\ni\n2\n,\nj\n1\n,\nj\n2\n(\n1≤\ni\n1\n<\ni\n2\n≤p\n;\n1≤\nj\n1\n<\nj\n2\n≤q\n),\nA\ni\n1\n,\nj\n1\n⊕\nA\ni\n1\n,\nj\n2\n⊕\nA\ni\n2\n,\nj\n1\n⊕\nA\ni\n2\n,\nj\n2\n=0\n, where\n⊕\ndenotes the bitwise XOR operation.\nThere is a partially filled integer grid\nG\nwith\nn\nrows and\nm\ncolumns where only\nk\ncells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform\nq\nupdates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\nFor each of the\nq+1\nstates of the grid, the initial state and after each of the\nq\nqueries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo\n10\n9\n+7\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains four integers\nn\n,\nm\n,\nk\nand\nq\n(\n2≤n,m≤\n10\n5\n;\n0≤k,q≤\n10\n5\n) — the number of rows, the number of columns, the number of fixed cells, and the number of updates.\nThe following\nk\nlines contain three integers\nr\n,\nc\nand\nv\n(\n1≤r≤n,1≤c≤m\n;\n0≤v<\n2\n30\n) indicating that\nG\nr,c\nis assigned the integer\nv\n.\nThe following\nq\nlines contain three integers\nr\n,\nc\nand\nv\n(\n1≤r≤n,1≤c≤m\n;\n0≤v<\n2\n30\n) indicating that\nG\nr,c\nis assigned the integer\nv\n.\nIt is guaranteed that the pairs\n(r,c)\nover all assignments are distinct.\nIt is guaranteed that the sum of\nn\n,\nm\n,\nk\nand\nq\nover all test cases does not exceed\n10\n5\nrespectively.\nOutput\nFor each test case, output\nq+1\nlines. The\ni\n-th line of output should contain the answer of the\ni\n-th state of the grid modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3\n3 3 8 1\n2 1 6\n3 2 12\n1 2 6\n2 2 0\n1 3 10\n1 1 0\n2 3 12\n3 1 10\n3 3 1\n2 5 2 0\n1 1 10\n1 2 30\n2 5 0 2\n1 1 10\n1 2 30\noutput\nCopy\n1\n0\n489373567\n651321892\n769740174\n489373567\nNote\nIn the first test case of the example, we initially have the following grid:\n0\n6\n10\n6\n0\n12\n10\n12\n?\nIt can be proven that the only valid value for tile\n(3,3)\nis\n0\n, so the first answer is\n1\n. For the second query, the grid does not satisfy the condition, and thus the answer is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "data structures",
            "dsu",
            "graphs",
            "*2600"
        ]
    },
    {
        "title": "E1. Billetes MX (Easy Version)",
        "description": "This is the easy version of the problem. In this version, it is guaranteed that\nq=0\n. You can make hacks only if both versions of the problem are solved.\nAn integer grid\nA\nwith\np\nrows and\nq\ncolumns is called beautiful if:\nAll elements of the grid are integers between\n0\nand\n2\n30\n−1\n, and\nFor any subgrid, the XOR of the values at the corners is equal to\n0\n. Formally, for any four integers\ni\n1\n,\ni\n2\n,\nj\n1\n,\nj\n2\n(\n1≤\ni\n1\n<\ni\n2\n≤p\n;\n1≤\nj\n1\n<\nj\n2\n≤q\n),\nA\ni\n1\n,\nj\n1\n⊕\nA\ni\n1\n,\nj\n2\n⊕\nA\ni\n2\n,\nj\n1\n⊕\nA\ni\n2\n,\nj\n2\n=0\n, where\n⊕\ndenotes the bitwise XOR operation.\nThere is a partially filled integer grid\nG\nwith\nn\nrows and\nm\ncolumns where only\nk\ncells are filled. Polycarp wants to know how many ways he can assign integers to the unfilled cells so that the grid is beautiful.\nHowever, Monocarp thinks that this problem is too easy. Therefore, he will perform\nq\nupdates on the grid. In each update, he will choose an unfilled cell and assign an integer to it. Note that these updates are persistent. That is, changes made to the grid will apply when processing future updates.\nFor each of the\nq+1\nstates of the grid, the initial state and after each of the\nq\nqueries, determine the number of ways Polycarp can assign integers to the unfilled cells so that the grid is beautiful. Since this number can be very large, you are only required to output their values modulo\n10\n9\n+7\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains four integers\nn\n,\nm\n,\nk\nand\nq\n(\n2≤n,m≤\n10\n5\n;\n0≤k≤\n10\n5\n;\nq=0\n) — the number of rows, the number of columns, the number of fixed cells, and the number of updates.\nThe following\nk\nlines contain three integers\nr\n,\nc\nand\nv\n(\n1≤r≤n,1≤c≤m\n;\n0≤v<\n2\n30\n) — indicating that\nG\nr,c\nis assigned the integer\nv\n.\nThe following\nq\nlines contain three integers\nr\n,\nc\nand\nv\n(\n1≤r≤n,1≤c≤m\n;\n0≤v<\n2\n30\n) — indicating that\nG\nr,c\nis assigned the integer\nv\n.\nIt is guaranteed that the pairs\n(r,c)\nover all assignments are distinct.\nIt is guaranteed that the sum of\nn\n,\nm\n,\nk\nand\nq\nover all test cases does not exceed\n10\n5\nrespectively.\nOutput\nFor each test case, output\nq+1\nlines. The\ni\n-th line of output should contain the answer of the\ni\n-th state of the grid modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n2\n3 3 8 0\n2 1 6\n3 2 12\n1 2 6\n2 2 0\n1 3 10\n1 1 0\n2 3 12\n3 1 10\n2 5 2 0\n1 1 10\n1 2 30\noutput\nCopy\n1\n489373567\nNote\nIn the first test case of the example, we have the following grid:\n0\n6\n10\n6\n0\n12\n10\n12\n?\nIt can be proven that the only valid value for tile\n(3,3)\nis\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "2-sat",
            "binary search",
            "combinatorics",
            "constructive algorithms",
            "dfs and similar",
            "dsu",
            "graphs",
            "*2500"
        ]
    },
    {
        "title": "D2. Asesino (Hard Version)",
        "description": "This is the hard version of the problem. In this version, you must use the minimum number of queries possible. You can make hacks only if both versions of the problem are solved.\nThis is an interactive problem.\nIt is a tradition in Mexico's national IOI trainings to play the game \"Asesino\", which is similar to \"Among Us\" or \"Mafia\".\nToday,\nn\nplayers, numbered from\n1\nto\nn\n, will play \"Asesino\" with the following three roles:\nKnight: a Knight is someone who always tells the truth.\nKnave: a Knave is someone who always lies.\nImpostor: an Impostor is someone everybody thinks is a Knight, but is secretly a Knave.\nEach player will be assigned a role in the game. There will be exactly one Impostor but there can be any (possible zero) number of Knights and Knaves.\nAs the game moderator, you have accidentally forgotten the roles of everyone, but you need to determine the player who is the Impostor.\nTo determine the Impostor, you will ask some questions. In each question, you will pick two players\ni\nand\nj\n(\n1≤i,j≤n\n;\ni≠j\n) and ask if player\ni\nthinks that player\nj\nis a Knight. The results of the question is shown in the table below.\nKnight Knave Impostor\nKnight Yes No Yes\nKnave No Yes No\nImpostor No Yes —\nThe response of the cell in row\na\nand column\nb\nis the result of asking a question when\ni\nhas role\na\nand\nj\nhas row\nb\n. For example, the \"Yes\" in the top right cell belongs to row \"Knight\" and column \"Impostor\", so it is the response when\ni\nis a Knight and\nj\nis an Impostor.\nFind the Impostor in the minimum number of queries possible. That is, let\nf(n)\nbe the minimum integer such that for\nn\nplayers, there exists a strategy that can determine the Impostor using at most\nf(n)\nquestions. Then, you should use at most\nf(n)\nquestions to determine the Impostor.\nNote: the grader is adaptive: the roles of the players are not fixed in the beginning and may change depending on your questions. However, it is guaranteed that there exists an assignment of roles that is consistent with all previously asked questions under the constraints of this problem.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n5\n) — the number of people playing the game.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nInteraction\nTo ask a question, output a line in the following format:\n\"? i j\" (\n1≤i,j≤n\n;\ni≠j\n) — to ask player\ni\nif they think player\nj\nis a Knight.\nThe jury will output a \"1\" if player\ni\nthinks player\nj\nis a Knight, and \"0\" otherwise.\nWhen you have determined which player the Impostor is, output a line in the following format:\n\"! i\" (\n1≤i≤n\n) — the Impostor is player\ni\n.\nNote that answering does not count to your limit of\nf(n)\nquestions.\nIf you have made an invalid output, used more than\nf(n)\nquestions or wrongly determined the Impostor, the jury will respond with \"-1\" and you will receive a Wrong Answer verdict. Upon receiving \"-1\", your program must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nAfter printing a query do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nsys.stdout.flush() in Python;\nstd::io::stdout().flush() in Rust;\nsee the documentation for other languages.\nHack format\nFor hacks, use the following format.\nThe first line should contain a single integer\nt\n — the number of test cases.\nThe first line of each test case should contain the integer\nn\nfollowed by the string \"manual\".\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−1≤\na\ni\n≤1\n) — the roles of each player.\n1\ndenotes a Knight,\n0\ndenotes a Knave, and\n−1\ndentoes an Impostor. There must be exactly one Impostor, that is there must be exactly one index\ni\nsuch that\na\ni\n=−1\n.\nAs an example, the hack format for the example input is:\n2\n7 manual\n0 1 0 -1 0 1 0\n4 manual\n0 1 -1 0\nExample\ninput\nCopy\n2\n7\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n4\n\n0\n\n1\n\n1\n\n1\noutput\nCopy\n? 1 3\n\n? 7 6\n\n? 2 5\n\n? 6 2\n\n? 4 5\n\n? 4 6\n\n? 1 4\n\n! 4\n\n? 1 2\n\n? 2 3\n\n? 3 4\n\n? 4 1\n\n! 3\nNote\nNote that the example test cases do not represent an optimal strategy for asking questions and are only shown for the sake of demonstrating the interaction format. Specifically, we cannot determine which player is the Impostor from the questions asked in the examples.\nIn the first test case of the example, players at indices\n2\nand\n6\nare Knights, players at indices\n1\n,\n3\n,\n5\n, and\n7\nare Knaves, and the Impostor is at index\n4\n. The following is an explanation of the questions asked:\nIn the first query, player\ni\nis a Knave and player\nj\nis a Knave. The answer is \"yes\" since Knaves always lie.\nIn the second query, player\ni\nis a Knave and player\nj\nis a Knight. The answer is \"no\" since Knaves always lie.\nIn the third query, player\ni\nis a Knight and player\nj\nis a Knave. The answer is \"no\" since Knights always tell the truth.\nIn the fourth query, player\ni\nis a Knight and player\nj\nis a Knight. The answer is \"yes\" since Knights always tell the truth.\nIn the fifth query, player\ni\nis a Impostor and player\nj\nis a Knave. The answer is \"yes\" since the Impostor always lies.\nIn the sixth query, player\ni\nis a Impostor and player\nj\nis a Knight. The answer is \"no\" since the Impostor always lies.\nIn the seventh query, player\ni\nis a Knave and player\nj\nis a Impostor. The answer is \"no\" since Knaves always lie and Knaves thinks that the Impostor is a Knight.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "interactive",
            "*2700"
        ]
    },
    {
        "title": "D1. Asesino (Easy Version)",
        "description": "This is the easy version of the problem. In this version, you can ask at most\nn+69\nquestions. You can make hacks only if both versions of the problem are solved.\nThis is an interactive problem.\nIt is a tradition in Mexico's national IOI trainings to play the game \"Asesino\", which is similar to \"Among Us\" or \"Mafia\".\nToday,\nn\nplayers, numbered from\n1\nto\nn\n, will play \"Asesino\" with the following three roles:\nKnight: a Knight is someone who always tells the truth.\nKnave: a Knave is someone who always lies.\nImpostor: an Impostor is someone everybody thinks is a Knight, but is secretly a Knave.\nEach player will be assigned a role in the game. There will be exactly one Impostor but there can be any (possible zero) number of Knights and Knaves.\nAs the game moderator, you have accidentally forgotten the roles of everyone, but you need to determine the player who is the Impostor.\nTo determine the Impostor, you will ask some questions. In each question, you will pick two players\ni\nand\nj\n(\n1≤i,j≤n\n;\ni≠j\n) and ask if player\ni\nthinks that player\nj\nis a Knight. The results of the question is shown in the table below.\nKnight Knave Impostor\nKnight Yes No Yes\nKnave No Yes No\nImpostor No Yes —\nThe response of the cell in row\na\nand column\nb\nis the result of asking a question when\ni\nhas role\na\nand\nj\nhas row\nb\n. For example, the \"Yes\" in the top right cell belongs to row \"Knight\" and column \"Impostor\", so it is the response when\ni\nis a Knight and\nj\nis an Impostor.\nFind the Impostor in at most\nn+69\nquestions.\nNote: the grader is adaptive: the roles of the players are not fixed in the beginning and may change depending on your questions. However, it is guaranteed that there exists an assignment of roles that is consistent with all previously asked questions under the constraints of this problem.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n5\n) — the number of people playing the game.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nInteraction\nTo ask a question, output a line in the following format:\n\"? i j\" (\n1≤i,j≤n\n;\ni≠j\n) — to ask player\ni\nif they think player\nj\nis a Knight.\nThe jury will output a \"1\" if player\ni\nthinks player\nj\nis a Knight, and \"0\" otherwise.\nWhen you have determined which player the Impostor is, output a line in the following format:\n\"! i\" (\n1≤i≤n\n) — the Impostor is player\ni\n.\nNote that answering does not count to your limit of\nn+69\nquestions.\nIf you have made an invalid output, used more than\nn+69\nquestions or wrongly determined the Impostor, the jury will respond with \"-1\" and you will receive a Wrong Answer verdict. Upon receiving \"-1\", your program must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nAfter printing a query do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nsys.stdout.flush() in Python;\nstd::io::stdout().flush() in Rust;\nsee the documentation for other languages.\nHack format\nFor hacks, use the following format.\nThe first line should contain a single integer\nt\n — the number of test cases.\nThe first line of each test case should contain the integer\nn\nfollowed by the string \"manual\".\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−1≤\na\ni\n≤1\n) — the roles of each player.\n1\ndenotes a Knight,\n0\ndenotes a Knave, and\n−1\ndentoes an Impostor. There must be exactly one Impostor, that is there must be exactly one index\ni\nsuch that\na\ni\n=−1\n.\nAs an example, the hack format for the example input is:\n2\n7 manual\n0 1 0 -1 0 1 0\n4 manual\n0 1 -1 0\nExample\ninput\nCopy\n2\n7\n\n1\n\n0\n\n0\n\n1\n\n1\n\n0\n\n0\n\n1\n\n4\n\n0\n\n1\n\n1\n\n1\noutput\nCopy\n? 1 3\n\n? 7 6\n\n? 2 5\n\n? 6 2\n\n? 4 5\n\n? 4 6\n\n? 1 4\n\n? 2 4\n\n! 4\n\n? 1 2\n\n? 2 3\n\n? 3 4\n\n? 4 1\n\n! 3\nNote\nNote that the example test cases do not represent an optimal strategy for asking questions and are only shown for the sake of demonstrating the interaction format. Specifically, we cannot determine which player is the Impostor from the questions asked in the examples.\nIn the first test case of the example, players at indices\n2\nand\n6\nare Knights, players at indices\n1\n,\n3\n,\n5\n, and\n7\nare Knaves, and the Impostor is at index\n4\n. The following is an explanation of the questions asked:\nIn the first query, player\ni\nis a Knave and player\nj\nis a Knave. The answer is \"yes\" since Knaves always lie.\nIn the second query, player\ni\nis a Knave and player\nj\nis a Knight. The answer is \"no\" since Knaves always lie.\nIn the third query, player\ni\nis a Knight and player\nj\nis a Knave. The answer is \"no\" since Knights always tell the truth.\nIn the fourth query, player\ni\nis a Knight and player\nj\nis a Knight. The answer is \"yes\" since Knights always tell the truth.\nIn the fifth query, player\ni\nis a Impostor and player\nj\nis a Knave. The answer is \"yes\" since the Impostor always lies.\nIn the sixth query, player\ni\nis a Impostor and player\nj\nis a Knight. The answer is \"no\" since the Impostor always lies.\nIn the seventh query, player\ni\nis a Knave and player\nj\nis a Impostor. The answer is \"no\" since Knaves always lie and Knaves thinks that the Impostor is a Knight.\nIn the eighth query, player\ni\nis a Knight and player\nj\nis a Impostor. The answer is \"yes\" since Knights always tell the truth and Knights think that the Impostor is a Knight.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "implementation",
            "interactive",
            "*1900"
        ]
    },
    {
        "title": "C. Gerrymandering",
        "description": "We all steal a little bit. But I have only one hand, while my adversaries have two.\nÁlvaro Obregón\nÁlvaro and José are the only candidates running for the presidency of Tepito, a rectangular grid of\n2\nrows and\nn\ncolumns, where each cell represents a house. It is guaranteed that\nn\nis a multiple of\n3\n.\nUnder the voting system of Tepito, the grid will be split into districts, which consist of any\n3\nhouses that are connected\n∗\n. Each house will belong to exactly one district.\nEach district will cast a single vote. The district will vote for Álvaro or José respectively if at least\n2\nhouses in that district select them. Therefore, a total of\n2n\n3\nvotes will be cast.\nAs Álvaro is the current president, he knows exactly which candidate each house will select. If Álvaro divides the houses into districts optimally, determine the maximum number of votes he can get.\n∗\nA set of cells is connected if there is a path between any\n2\ncells that requires moving only up, down, left and right through cells in the set.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains one integer\nn\n(\n3≤n≤\n10\n5\n;\nn\nis a multiple of\n3\n) — the number of columns of Tepito.\nThe following two lines each contain a string of length\nn\n. The\ni\n-th line contains the string\ns\ni\n, consisting of the characters\nA\nand\nJ\n. If\ns\ni,j\n=A\n, the house in the\ni\n-th row and\nj\n-th column will select Álvaro. Otherwise if\ns\ni,j\n=J\n, the house will select José.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum number of districts Álvaro can win by optimally dividing the houses into districts.\nExample\ninput\nCopy\n4\n3\nAAA\nAJJ\n6\nJAJAJJ\nJJAJAJ\n6\nAJJJAJ\nAJJAAA\n9\nAJJJJAJAJ\nJAAJJJJJA\noutput\nCopy\n2\n2\n3\n2\nNote\nThe image below showcases the optimal arrangement of districts Álvaro can use for each test case in the example.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*1800"
        ]
    },
    {
        "title": "B. Kar Salesman",
        "description": "Karel is a salesman in a car dealership. The dealership has\nn\ndifferent models of cars. There are\na\ni\ncars of the\ni\n-th model. Karel is an excellent salesperson and can convince customers to buy up to\nx\ncars (of Karel's choice), as long as the cars are from different models.\nDetermine the minimum number of customers Karel has to bring in to sell all the cars.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤5⋅\n10\n5\n;\n1≤x≤10\n) — the number of different models of cars and the maximum number of cars Karel can convince a customer to buy.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of cars of each model.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum possible number of customers needed to sell all the cars.\nExample\ninput\nCopy\n4\n3 2\n3 1 2\n3 3\n2 1 3\n5 3\n2 2 1 9 2\n7 4\n2 5 3 3 5 2 5\noutput\nCopy\n3\n3\n9\n7\nNote\nFor the first case, Karel only needs to lure in\n3\ncustomers. He will convince the customers to buy the following models of cars:\nCustomer\n1\nbuys\n2\ncars with model\n1\nand\n3\n.\nCustomer\n2\nbuys\n2\ncars with model\n1\nand\n2\n.\nCustomer\n3\nbuys\n2\ncars with model\n1\nand\n3\n.\nFor the second case, Karel only needs to lure in\n3\ncustomers. He will convince the customers to buy the following models of cars:\nCustomer\n1\nbuys\n2\ncars with model\n1\nand\n3\n.\nCustomer\n2\nbuys\n3\ncars with model\n1\n,\n2\nand\n3\n.\nCustomer\n3\nbuys\n1\ncar with model\n3\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "A. Bus to Pénjamo",
        "description": "Ya vamos llegando a Péeeenjamoo ♫♫♫\nThere are\nn\nfamilies travelling to Pénjamo to witness Mexico's largest-ever \"walking a chicken on a leash\" marathon. The\ni\n-th family has\na\ni\nfamily members. All families will travel using a single bus consisting of\nr\nrows with\n2\nseats each.\nA person is considered happy if:\nAnother family member is seated in the same row as them, or\nThey are sitting alone in their row (with an empty seat next to them).\nDetermine the maximum number of happy people in an optimal seating arrangement. Note that everyone must be seated in the bus.\nIt is guaranteed that all family members will fit on the bus. Formally, it is guaranteed that\n∑\ni=1\nn\na\ni\n≤2r\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nr\n(\n1≤n≤100\n;\n1≤r≤500\n) — the number of families and the number of rows in the bus.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤10\n) — the number of family members in each family.\nOutput\nFor each test case, output the maximum number of happy people in an optimal seating arrangement.\nExample\ninput\nCopy\n4\n3 3\n2 3 1\n3 3\n2 2 2\n4 5\n1 1 2 2\n4 5\n3 1 1 3\noutput\nCopy\n4\n6\n6\n6\nNote\nIn the first test case, the two members of the first family can sit together in the first row, while the two members of the second family can sit together in the second row. The remaining member of the second family can sit in the third row along with a member of the third family. This seating arrangement is shown below, where the\n4\nhappy people are colored green.\n1\n1\n2\n2\n2\n3\nIn the second test case, a possible seating arrangement with\n6\nhappy people is shown below.\n3\n3\n1\n1\n2\n2\nIn the third test case, a possible seating arrangement with\n6\nhappy people is shown below.\n4\n4\n2\n3\n3\n1",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "E3. Digital Village (Extreme Version)",
        "description": "This is the extreme version of the problem. In the three versions, the constraints on\nn\nand\nm\nare different. You can make hacks only if all the versions of the problem are solved.\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with\nn\nhouses and\nm\ninternet cables connecting house\nu\ni\nand house\nv\ni\n, each with a latency of\nw\ni\n.\nThere are\np\nhouses that require internet. Pak Chanek can install servers in at most\nk\nof the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house\ns\ni\nrequiring internet will be the maximum latency of the cables between that house and the server it is connected to.\nFor each\nk=1,2,…,n\n, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains 3 integers\nn\n,\nm\n,\np\n(\n2≤n≤2⋅\n10\n5\n;\nn−1≤m≤2⋅\n10\n5\n;\n1≤p≤n\n) — the number of houses, the number of cables, and the number of houses that need internet.\nThe second line of each test case contains\np\nintegers\ns\n1\n,\ns\n2\n,…,\ns\np\n(\n1≤\ns\ni\n≤n\n) — the houses that need internet. It is guaranteed that all elements of\ns\nare distinct.\nThe\ni\n-th of the next\nm\nlines of each test case contains three integers\nu\ni\n,\nv\ni\n, and\nw\ni\n(\n1≤\nu\ni\n<\nv\ni\n≤n\n;\n1≤\nw\ni\n≤\n10\n9\n) — the internet cable connecting house\nu\ni\nand house\nv\ni\nwith latency of\nw\ni\n. It is guaranteed that the given edges form a connected simple graph.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\ndo not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers: the minimum total latency that can be achieved for all the houses requiring internet for each\nk=1,2,…,n\n.\nExample\ninput\nCopy\n2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2\noutput\nCopy\n34 19 9 4 0 0 0 0 0\n2 0 0\nNote\nIn the first test case for\nk=3\n, a possible optimal solution is to install servers at vertices\n2\n,\n6\nand\n8\nand obtain the following latency:\nlatency(2)=0\nlatency(5)=max(3,5)=5\nlatency(6)=0\nlatency(8)=0\nlatency(9)=max(2,4)=4\nSo the total latency is\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "graphs",
            "greedy",
            "math",
            "trees",
            "*2800"
        ]
    },
    {
        "title": "E2. Digital Village (Hard Version)",
        "description": "This is the hard version of the problem. In the three versions, the constraints on\nn\nand\nm\nare different. You can make hacks only if all the versions of the problem are solved.\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with\nn\nhouses and\nm\ninternet cables connecting house\nu\ni\nand house\nv\ni\n, each with a latency of\nw\ni\n.\nThere are\np\nhouses that require internet. Pak Chanek can install servers in at most\nk\nof the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house\ns\ni\nrequiring internet will be the maximum latency of the cables between that house and the server it is connected to.\nFor each\nk=1,2,…,n\n, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2000\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n,\np\n(\n2≤n≤5000\n;\nn−1≤m≤5000\n;\n1≤p≤n\n) — the number of houses, the number of cables, and the number of houses that need internet.\nThe second line of each test case contains\np\nintegers\ns\n1\n,\ns\n2\n,…,\ns\np\n(\n1≤\ns\ni\n≤n\n) — the houses that need internet. It is guaranteed that all elements of\ns\nare distinct.\nThe\ni\n-th of the next\nm\nlines of each test case contains three integers\nu\ni\n,\nv\ni\n, and\nw\ni\n(\n1≤\nu\ni\n<\nv\ni\n≤n\n;\n1≤\nw\ni\n≤\n10\n9\n) — the internet cable connecting house\nu\ni\nand house\nv\ni\nwith latency of\nw\ni\n. It is guaranteed that the given edges form a connected simple graph.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\ndo not exceed\n5000\n.\nOutput\nFor each test case, output\nn\nintegers: the minimum total latency that can be achieved for all the houses requiring internet for each\nk=1,2,…,n\n.\nExample\ninput\nCopy\n2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2\noutput\nCopy\n34 19 9 4 0 0 0 0 0\n2 0 0\nNote\nIn the first test case for\nk=3\n, a possible optimal solution is to install servers at vertices\n2\n,\n6\nand\n8\nand obtain the following latency:\nlatency(2)=0\nlatency(5)=max(3,5)=5\nlatency(6)=0\nlatency(8)=0\nlatency(9)=max(2,4)=4\nSo the total latency is\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "dsu",
            "graphs",
            "math",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E1. Digital Village (Easy Version)",
        "description": "This is the easy version of the problem. In the three versions, the constraints on\nn\nand\nm\nare different. You can make hacks only if all the versions of the problem are solved.\nPak Chanek is setting up internet connections for the village of Khuntien. The village can be represented as a connected simple graph with\nn\nhouses and\nm\ninternet cables connecting house\nu\ni\nand house\nv\ni\n, each with a latency of\nw\ni\n.\nThere are\np\nhouses that require internet. Pak Chanek can install servers in at most\nk\nof the houses. The houses that need internet will then be connected to one of the servers. However, since each cable has its latency, the latency experienced by house\ns\ni\nrequiring internet will be the maximum latency of the cables between that house and the server it is connected to.\nFor each\nk=1,2,…,n\n, help Pak Chanek determine the minimum total latency that can be achieved for all the houses requiring internet.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n,\np\n(\n2≤n≤400\n;\nn−1≤m≤400\n;\n1≤p≤n\n) — the number of houses, the number of cables and the number of houses that need internet.\nThe second line of each test case contains\np\nintegers\ns\n1\n,\ns\n2\n,…,\ns\np\n(\n1≤\ns\ni\n≤n\n) — the houses that need internet. It is guaranteed that all elements of\ns\nare distinct.\nThe\ni\n-th of the next\nm\nlines of each test case contains three integers\nu\ni\n,\nv\ni\n, and\nw\ni\n(\n1≤\nu\ni\n<\nv\ni\n≤n\n;\n1≤\nw\ni\n≤\n10\n9\n) — the internet cable connecting house\nu\ni\nand house\nv\ni\nwith latency of\nw\ni\n. It is guaranteed that the given edges form a connected simple graph.\nIt is guaranteed that the sum of\nn\n3\nand the sum of\nm\n3\ndo not exceed\n10\n8\n.\nOutput\nFor each test case, output\nn\nintegers: the minimum total latency that can be achieved for all the houses requiring internet for each\nk=1,2,…,n\n.\nExample\ninput\nCopy\n2\n9 8 5\n2 5 6 8 9\n1 2 1\n1 3 2\n3 4 10\n4 5 3\n4 6 5\n1 7 10\n7 8 4\n7 9 2\n3 3 2\n3 1\n1 2 1\n2 3 3\n1 3 2\noutput\nCopy\n34 19 9 4 0 0 0 0 0\n2 0 0\nNote\nIn the first test case for\nk=3\n, a possible optimal solution is to install servers at vertices\n2\n,\n6\nand\n8\nand obtain the following latency:\nlatency(2)=0\nlatency(5)=max(3,5)=5\nlatency(6)=0\nlatency(8)=0\nlatency(9)=max(2,4)=4\nSo the total latency is\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "fft",
            "graphs",
            "greedy",
            "implementation",
            "math",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "D. Boss, Thirsty",
        "description": "Pak Chanek has a friend who runs a drink stall in a canteen. His friend will sell drinks for\nn\ndays, numbered from day\n1\nto day\nn\n. There are also\nm\ntypes of drinks, numbered from\n1\nto\nm\n.\nThe profit gained from selling a drink on a particular day can vary. On day\ni\n, the projected profit from selling drink of type\nj\nis\nA\ni,j\n. Note that\nA\ni,j\ncan be negative, meaning that selling the drink would actually incur a loss.\nPak Chanek wants to help his friend plan the sales over the\nn\ndays. On day\ni\n, Pak Chanek must choose to sell at least one type of drink. Furthermore, the types of drinks sold on a single day must form a subarray. In other words, in each day, Pak Chanek will select\ni\nand\nj\nsuch that\n1≤i≤j≤m\n. Then all types of drinks between\ni\nand\nj\n(inclusive) will be sold.\nHowever, to ensure that customers from the previous day keep returning, the selection of drink types sold on day\ni\n(\ni>1\n) must meet the following conditions:\nAt least one drink type sold on day\ni\nmust also have been sold on day\ni−1\n.\nAt least one drink type sold on day\ni\nmust not have been sold on day\ni−1\n.\nThe daily profit is the sum of the profits from all drink types sold on that day. The total profit from the sales plan is the sum of the profits over\nn\ndays. What is the maximum total profit that can be achieved if Pak Chanek plans the sales optimally?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤2⋅\n10\n5\n;\n3≤m≤2⋅\n10\n5\n;\nn⋅m≤2⋅\n10\n5\n) — the number of rows and columns in a grid.\nThe next\nn\nlines of each test case contain\nm\nintegers each, where the\ni\n-th line contains the integers\nA\ni,1\nA\ni,2\n,…,\nA\ni,m\n(\n−\n10\n9\n≤\nA\ni,j\n≤\n10\n9\n) — project profits of each drink type on the\ni\n-th day.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum profit that Pak Chanek can achieve.\nExample\ninput\nCopy\n1\n3 6\n79 20 49 5 -1000 500\n-105 9 109 24 -98 -499\n14 47 12 39 23 50\noutput\nCopy\n475\nNote\nHere is Pak Chanek's optimal plan:\nOn day\n1\n, Pak Chanek sells drink types\n1\nto\n3\n. Generating a profit of\n79+20+49=148\n.\nOn day\n2\n, Pak Chanek sells drink types\n2\nto\n4\n. Generating a profit of\n9+109+24=142\nOn day\n3\n, Pak Chanek sells drink types\n1\nto\n6\n. Generating a profit of\n185\n.\nSo, the total profit of Pak Chanek's plan is\n148+142+185=475\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*2500"
        ]
    },
    {
        "title": "C2. Adjust The Presentation (Hard Version)",
        "description": "This is the hard version of the problem. In the two versions, the constraints on\nq\nand the time limit are different. In this version,\n0≤q≤2⋅\n10\n5\n. You can make hacks only if all the versions of the problem are solved.\nA team consisting of\nn\nmembers, numbered from\n1\nto\nn\n, is set to present a slide show at a large meeting. The slide show contains\nm\nslides.\nThere is an array\na\nof length\nn\n. Initially, the members are standing in a line in the order of\na\n1\n,\na\n2\n,…,\na\nn\nfrom front to back. The slide show will be presented in order from slide\n1\nto slide\nm\n. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is\n[3,1,2,4]\n. After member\n3\npresents the current slide, you can change the line of members into either\n[3,1,2,4]\n,\n[1,3,2,4]\n,\n[1,2,3,4]\nor\n[1,2,4,3]\n.\nThere is also an array\nb\nof length\nm\n. The slide show is considered good if it is possible to make member\nb\ni\npresent slide\ni\nfor all\ni\nfrom\n1\nto\nm\nunder these constraints.\nHowever, your annoying boss wants to make\nq\nupdates to the array\nb\n. In the\ni\n-th update, he will choose a slide\ns\ni\nand a member\nt\ni\nand set\nb\ns\ni\n:=\nt\ni\n. Note that these updates are persistent, that is changes made to the array\nb\nwill apply when processing future updates.\nFor each of the\nq+1\nstates of array\nb\n, the initial state and after each of the\nq\nupdates, determine if the slideshow is good.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\nand\nq\n(\n1≤n,m≤2⋅\n10\n5\n;\n0≤q≤2⋅\n10\n5\n) — the number of members and the number of sections.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the initial order of the members from front to back. It is guaranteed that each integer from\n1\nto\nn\nappears exactly once in\na\n.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤n\n) — the members who should present each section.\nEach of the next\nq\nlines contains two integers\ns\ni\nand\nt\ni\n(\n1≤\ns\ni\n≤m\n,\n1≤\nt\ni\n≤n\n) — parameters of an update.\nIt is guaranteed that the sum of\nn\n, the sum of\nm\nand the sum of\nq\nover all test cases do not exceed\n2⋅\n10\n5\nrespectively.\nOutput\nFor each test case, output\nq+1\nlines corresponding to the\nq+1\nstates of the array\nb\n. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\nExample\ninput\nCopy\n3\n4 2 2\n1 2 3 4\n1 1\n1 2\n1 1\n3 6 2\n1 2 3\n1 1 2 3 3 2\n3 3\n2 2\n4 6 2\n3 1 4 2\n3 1 1 2 3 4\n3 4\n4 2\noutput\nCopy\nYA\nTIDAK\nYA\nYA\nTIDAK\nYA\nTIDAK\nYA\nYA\nNote\nFor the first test case, you do not need to move the members as both slides are presented by member\n1\n, who is already at the front of the line. After that, set\nb\n1\n:=2\n, now slide\n1\nmust be presented by member\n2\nwhich is impossible as member\n1\nwill present slide\n1\nfirst. Then, set\nb\n1\n=1\n, the\nb\nis the same as the initial\nb\n, making a good presentation possible.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "C1. Adjust The Presentation (Easy Version)",
        "description": "This is the easy version of the problem. In the two versions, the constraints on\nq\nand the time limit are different. In this version,\nq=0\n. You can make hacks only if all the versions of the problem are solved.\nA team consisting of\nn\nmembers, numbered from\n1\nto\nn\n, is set to present a slide show at a large meeting. The slide show contains\nm\nslides.\nThere is an array\na\nof length\nn\n. Initially, the members are standing in a line in the order of\na\n1\n,\na\n2\n,…,\na\nn\nfrom front to back. The slide show will be presented in order from slide\n1\nto slide\nm\n. Each section will be presented by the member at the front of the line. After each slide is presented, you can move the member at the front of the line to any position in the lineup (without changing the order of the rest of the members). For example, suppose the line of members is\n[3,1,2,4]\n. After member\n3\npresents the current slide, you can change the line of members into either\n[3,1,2,4]\n,\n[1,3,2,4]\n,\n[1,2,3,4]\nor\n[1,2,4,3]\n.\nThere is also an array\nb\nof length\nm\n. The slide show is considered good if it is possible to make member\nb\ni\npresent slide\ni\nfor all\ni\nfrom\n1\nto\nm\nunder these constraints.\nHowever, your annoying boss wants to make\nq\nupdates to the array\nb\n. In the\ni\n-th update, he will choose a slide\ns\ni\nand a member\nt\ni\nand set\nb\ns\ni\n:=\nt\ni\n. Note that these updates are persistent, that is changes made to the array\nb\nwill apply when processing future updates.\nFor each of the\nq+1\nstates of array\nb\n, the initial state and after each of the\nq\nupdates, determine if the slideshow is good.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\nand\nq\n(\n1≤n,m≤2⋅\n10\n5\n;\nq=0\n) — the number of members, the number of sections and the number of updates.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the initial order of the members from front to back. It is guaranteed that each integer from\n1\nto\nn\nappears exactly once in\na\n.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤n\n) — the members who should present each section.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n2⋅\n10\n5\nrespectively.\nOutput\nFor each test case, output\nq+1\nlines corresponding to the\nq+1\nstates of the array\nb\n. Output \"YA\" if the slide show is good, and \"TIDAK\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yA\", \"Ya\", \"ya\", and \"YA\" will be recognized as positive responses.\nExample\ninput\nCopy\n3\n4 2 0\n1 2 3 4\n1 1\n3 6 0\n1 2 3\n1 1 2 3 3 2\n4 6 0\n3 1 4 2\n3 1 1 2 3 4\noutput\nCopy\nYA\nYA\nTIDAK\nNote\nFor the first test case, you do not need to move the members as both slides are presented by member\n1\n, who is already at the front of the line.\nFor the second test case, the following is a possible way to move members so that the presentation is good:\n[1,2,3]\n, do not move member\n1\n.\n[1,2,3]\n, move member\n1\nafter member\n3\n.\n[2,3,1]\n, move member\n2\nafter member\n3\n.\n[3,2,1]\n, do not move member\n3\n.\n[3,2,1]\n, move member\n3\nafter member\n1\n.\n[2,1,3]\n, do not move member\n2\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "B. Maximize Mex",
        "description": "You are given an array\na\nof\nn\npositive integers and an integer\nx\n. You can do the following two-step operation any (possibly zero) number of times:\nChoose an index\ni\n(\n1≤i≤n\n).\nIncrease\na\ni\nby\nx\n, in other words\na\ni\n:=\na\ni\n+x\n.\nFind the maximum value of the\nMEX\nof\na\nif you perform the operations optimally.\nThe\nMEX\n(minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example:\nThe\nMEX\nof\n[2,2,1]\nis\n0\nbecause\n0\nis not in the array.\nThe\nMEX\nof\n[3,1,0,1]\nis\n2\nbecause\n0\nand\n1\nare in the array but\n2\nis not.\nThe\nMEX\nof\n[0,3,1,2]\nis\n4\nbecause\n0\n,\n1\n,\n2\nand\n3\nare in the array but\n4\nis not.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5000\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤2⋅\n10\n5\n;\n1≤x≤\n10\n9\n) — the length of the array and the integer to be used in the operation.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the given array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum\nMEX\nof\na\nif you perform the operations optimally.\nExample\ninput\nCopy\n3\n6 3\n0 3 2 1 5 2\n6 2\n1 3 4 1 0 2\n4 5\n2 5 10 3\noutput\nCopy\n4\n6\n0\nNote\nIn the first test case, the\nMEX\nof\na\nis\n4\nwithout performing any operations, which is the maximum.\nIn the second test case, the\nMEX\nof\na\nis\n5\nwithout performing any operations. If we perform two operations both with\ni=1\n, we will have the array\na=[5,3,4,1,0,2]\n. Then, the\nMEX\nof\na\nwill become\n6\n, which is the maximum.\nIn the third test case, the\nMEX\nof\na\nis\n0\nwithout performing any operations, which is the maximum.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "A. Meaning Mean",
        "description": "Pak Chanek has an array\na\nof\nn\npositive integers. Since he is currently learning how to calculate the floored average of two numbers, he wants to practice it on his array\na\n.\nWhile the array\na\nhas at least two elements, Pak Chanek will perform the following three-step operation:\nPick two different indices\ni\nand\nj\n(\n1≤i,j≤|a|\n;\ni≠j\n), note that\n|a|\ndenotes the current size of the array\na\n.\nAppend\n⌊\na\ni\n+\na\nj\n2\n⌋\n∗\nto the end of the array.\nRemove elements\na\ni\nand\na\nj\nfrom the array and concatenate the remaining parts of the array.\nFor example, suppose that\na=[5,4,3,2,1,1]\n. If we choose\ni=1\nand\nj=5\n, the resulting array will be\na=[4,3,2,1,3]\n. If we choose\ni=4\nand\nj=3\n, the resulting array will be\na=[5,4,1,1,2]\n.\nAfter all operations, the array will consist of a single element\nx\n. Find the maximum possible value of\nx\nif Pak Chanek performs the operations optimally.\n∗\n⌊x⌋\ndenotes the floor function of\nx\n, which is the greatest integer that is less than or equal to\nx\n. For example,\n⌊6⌋=6\n,\n⌊2.5⌋=2\n,\n⌊−3.6⌋=−4\nand\n⌊π⌋=3\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5000\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤50\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nDo note that the sum of\nn\nover all test cases is not bounded.\nOutput\nFor each test case, output a single integer: the maximum possible value of\nx\nafter all numbers have been picked.\nExample\ninput\nCopy\n3\n5\n1 7 8 4 5\n3\n2 6 5\n5\n5 5 5 5 5\noutput\nCopy\n6\n4\n5\nNote\nIn the first test case, the array is initially\na=[1,7,8,4,5]\n. Pak Chanek will perform the following operations:\nPick\ni=1\nand\nj=2\n, then\na=[8,4,5,4]\n.\nPick\ni=3\nand\nj=2\n, then\na=[8,4,4]\n.\nPick\ni=2\nand\nj=3\n, then\na=[8,4]\n.\nPick\ni=1\nand\nj=2\n, then\na=[6]\n.\nAfter all the operations, the array consists of a single element\nx=6\n. It can be proven that there is no series of operations that results in\nx\ngreater than\n6\nin the end.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "F. Count Leaves",
        "description": "Let\nn\nand\nd\nbe positive integers. We build the the divisor tree\nT\nn,d\nas follows:\nThe root of the tree is a node marked with number\nn\n. This is the\n0\n-th layer of the tree.\nFor each\ni\nfrom\n0\nto\nd−1\n, for each vertex of the\ni\n-th layer, do the following. If the current vertex is marked with\nx\n, create its children and mark them with all possible distinct divisors\n†\n†\nof\nx\n. These children will be in the\n(i+1)\n-st layer.\nThe vertices on the\nd\n-th layer are the leaves of the tree.\nFor example,\nT\n6,2\n(the divisor tree for\nn=6\nand\nd=2\n) looks like this:\nDefine\nf(n,d)\nas the number of leaves in\nT\nn,d\n.\nGiven integers\nn\n,\nk\n, and\nd\n, please compute\n∑\ni=1\nn\nf(\ni\nk\n,d)\n, modulo\n10\n9\n+7\n.\n†\n†\nIn this problem, we say that an integer\ny\nis a divisor of\nx\nif\ny≥1\nand there exists an integer\nz\nsuch that\nx=y⋅z\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains three integers\nn\n,\nk\n, and\nd\n(\n1≤n≤\n10\n9\n,\n1≤k,d≤\n10\n5\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n9\n.\nOutput\nFor each test case, output\n∑\ni=1\nn\nf(\ni\nk\n,d)\n, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3\n6 1 1\n1 3 3\n10 1 2\noutput\nCopy\n14\n1\n53\nNote\nIn the first test case,\nn=6\n,\nk=1\n, and\nd=1\n. Thus, we need to find the total number of leaves in the divisor trees\nT\n1,1\n,\nT\n2,1\n,\nT\n3,1\n,\nT\n4,1\n,\nT\n5,1\n,\nT\n6,1\n.\nT\n1,1\nhas only one leaf, which is marked with\n1\n.\nT\n2,1\nhas two leaves, marked with\n1\nand\n2\n.\nT\n3,1\nhas two leaves, marked with\n1\nand\n3\n.\nT\n4,1\nhas three leaves, marked with\n1\n,\n2\n, and\n4\n.\nT\n5,1\nhas two leaves, marked with\n1\nand\n5\n.\nT\n6,1\nhas four leaves, marked with\n1\n,\n2\n,\n3\n, and\n6\n.\nThe total number of leaves is\n1+2+2+3+2+4=14\n.\nIn the second test case,\nn=1\n,\nk=3\n,\nd=3\n. Thus, we need to find the number of leaves in\nT\n1,3\n, because\n1\n3\n=1\n. This tree has only one leaf, so the answer is\n1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "math",
            "number theory",
            "*2900"
        ]
    },
    {
        "title": "E. Expected Power",
        "description": "You are given an array of\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n. You are also given an array\np\n1\n,\np\n2\n,…,\np\nn\n.\nLet\nS\ndenote the random multiset (i. e., it may contain equal elements) constructed as follows:\nInitially,\nS\nis empty.\nFor each\ni\nfrom\n1\nto\nn\n, insert\na\ni\ninto\nS\nwith probability\np\ni\n10\n4\n. Note that each element is inserted independently.\nDenote\nf(S)\nas the bitwise XOR of all elements of\nS\n. Please calculate the expected value of\n(f(S)\n)\n2\n. Output the answer modulo\n10\n9\n+7\n.\nFormally, let\nM=\n10\n9\n+7\n. It can be shown that the answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤1023\n).\nThe third line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤\n10\n4\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the expected value of\n(f(S)\n)\n2\n, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n4\n2\n1 2\n5000 5000\n2\n1 1\n1000 2000\n6\n343 624 675 451 902 820\n6536 5326 7648 2165 9430 5428\n1\n1\n10000\noutput\nCopy\n500000007\n820000006\n280120536\n1\nNote\nIn the first test case,\na=[1,2]\nand each element is inserted into\nS\nwith probability\n1\n2\n, since\np\n1\n=\np\n2\n=5000\nand\np\ni\n10\n4\n=\n1\n2\n. Thus, there are\n4\noutcomes for\nS\n, each happening with the same probability of\n1\n4\n:\nS=∅\n. In this case,\nf(S)=0\n,\n(f(S)\n)\n2\n=0\n.\nS={1}\n. In this case,\nf(S)=1\n,\n(f(S)\n)\n2\n=1\n.\nS={2}\n. In this case,\nf(S)=2\n,\n(f(S)\n)\n2\n=4\n.\nS={1,2}\n. In this case,\nf(S)=1⊕2=3\n,\n(f(S)\n)\n2\n=9\n.\nHence, the answer is\n0⋅\n1\n4\n+1⋅\n1\n4\n+4⋅\n1\n4\n+9⋅\n1\n4\n=\n14\n4\n=\n7\n2\n≡500000007(mod\n10\n9\n+7)\n.\nIn the second test case,\na=[1,1]\n,\na\n1\nis inserted into\nS\nwith probability\n0.1\n, while\na\n2\nis inserted into\nS\nwith probability\n0.2\n. There are\n3\noutcomes for\nS\n:\nS=∅\n. In this case,\nf(S)=0\n,\n(f(S)\n)\n2\n=0\n. This happens with probability\n(1−0.1)⋅(1−0.2)=0.72\n.\nS={1}\n. In this case,\nf(S)=1\n,\n(f(S)\n)\n2\n=1\n. This happens with probability\n(1−0.1)⋅0.2+0.1⋅(1−0.2)=0.26\n.\nS={1,1}\n. In this case,\nf(S)=0\n,\n(f(S)\n)\n2\n=0\n. This happens with probability\n0.1⋅0.2=0.02\n.\nHence, the answer is\n0⋅0.72+1⋅0.26+0⋅0.02=0.26=\n26\n100\n≡820000006(mod\n10\n9\n+7)\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "math",
            "probabilities",
            "*2000"
        ]
    },
    {
        "title": "D. Connect the Dots",
        "description": "One fine evening, Alice sat down to play the classic game \"Connect the Dots\", but with a twist.\nTo play the game, Alice draws a straight line and marks\nn\npoints on it, indexed from\n1\nto\nn\n. Initially, there are no arcs between the points, so they are all disjoint. After that, Alice performs\nm\noperations of the following type:\nShe picks three integers\na\ni\n,\nd\ni\n(\n1≤\nd\ni\n≤10\n), and\nk\ni\n.\nShe selects points\na\ni\n,\na\ni\n+\nd\ni\n,\na\ni\n+2\nd\ni\n,\na\ni\n+3\nd\ni\n,…,\na\ni\n+\nk\ni\n⋅\nd\ni\nand connects each pair of these points with arcs.\nAfter performing all\nm\noperations, she wants to know the number of connected components\n†\n†\nthese points form. Please help her find this number.\n†\n†\nTwo points are said to be in one connected component if there is a path between them via several (possibly zero) arcs and other points.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤2⋅\n10\n5\n,\n1≤m≤2⋅\n10\n5\n).\nThe\ni\n-th of the following\nm\nlines contains three integers\na\ni\n,\nd\ni\n, and\nk\ni\n(\n1≤\na\ni\n≤\na\ni\n+\nk\ni\n⋅\nd\ni\n≤n\n,\n1≤\nd\ni\n≤10\n,\n0≤\nk\ni\n≤n\n).\nIt is guaranteed that both the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the number of connected components.\nExample\ninput\nCopy\n3\n10 2\n1 2 4\n2 2 4\n100 1\n19 2 4\n100 3\n1 2 5\n7 2 6\n17 2 31\noutput\nCopy\n2\n96\n61\nNote\nIn the first test case, there are\nn=10\npoints. The first operation joins the points\n1\n,\n3\n,\n5\n,\n7\n, and\n9\n. The second operation joins the points\n2\n,\n4\n,\n6\n,\n8\n, and\n10\n. There are thus two connected components:\n{1,3,5,7,9}\nand\n{2,4,6,8,10}\n.\nIn the second test case, there are\nn=100\npoints. The only operation joins the points\n19\n,\n21\n,\n23\n,\n25\n, and\n27\n. Now all of them form a single connected component of size\n5\n. The other\n95\npoints form single-point connected components. Thus, the answer is\n1+95=96\n.\nIn the third test case, there are\nn=100\npoints. After the operations, all odd points from\n1\nto\n79\nwill be in one connected component of size\n40\n. The other\n60\npoints form single-point connected components. Thus, the answer is\n1+60=61\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "dsu",
            "graphs",
            "math",
            "trees",
            "*1800"
        ]
    },
    {
        "title": "C. Bitwise Balancing",
        "description": "You are given three non-negative integers\nb\n,\nc\n, and\nd\n.\nPlease find a non-negative integer\na∈[0,\n2\n61\n]\nsuch that\n(a|b)−(a&c)=d\n, where\n|\nand\n&\ndenote the bitwise OR operation and the bitwise AND operation, respectively.\nIf such an\na\nexists, print its value. If there is no solution, print a single integer\n−1\n. If there are multiple solutions, print any of them.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe only line of each test case contains three positive integers\nb\n,\nc\n, and\nd\n(\n0≤b,c,d≤\n10\n18\n).\nOutput\nFor each test case, output the value of\na\n, or\n−1\nif there is no solution. Please note that\na\nmust be non-negative and cannot exceed\n2\n61\n.\nExample\ninput\nCopy\n3\n2 2 2\n4 2 6\n10 2 14\noutput\nCopy\n0\n-1\n12\nNote\nIn the first test case,\n(0|2)−(0&2)=2−0=2\n. So,\na=0\nis a correct answer.\nIn the second test case, no value of\na\nsatisfies the equation.\nIn the third test case,\n(12|10)−(12&2)=14−0=14\n. So,\na=12\nis a correct answer.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "hashing",
            "implementation",
            "math",
            "schedules",
            "ternary search",
            "*1400"
        ]
    },
    {
        "title": "B. Brightness Begins",
        "description": "Imagine you have\nn\nlight bulbs numbered\n1,2,…,n\n. Initially, all bulbs are on. To flip the state of a bulb means to turn it off if it used to be on, and to turn it on otherwise.\nNext, you do the following:\nfor each\ni=1,2,…,n\n, flip the state of all bulbs\nj\nsuch that\nj\nis divisible by\ni\n†\n.\nAfter performing all operations, there will be several bulbs that are still on. Your goal is to make this number exactly\nk\n.\nFind the smallest suitable\nn\nsuch that after performing the operations there will be exactly\nk\nbulbs on. We can show that an answer always exists.\n†\n†\nAn integer\nx\nis divisible by\ny\nif there exists an integer\nz\nsuch that\nx=y⋅z\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains a single integer\nk\n(\n1≤k≤\n10\n18\n).\nOutput\nFor each test case, output\nn\n — the minimum number of bulbs.\nExample\ninput\nCopy\n3\n1\n3\n8\noutput\nCopy\n2\n5\n11\nNote\nIn the first test case, the minimum number of bulbs is\n2\n. Let's denote the state of all bulbs with an array, where\n1\ncorresponds to a turned on bulb, and\n0\ncorresponds to a turned off bulb. Initially, the array is\n[1,1]\n.\nAfter performing the operation with\ni=1\n, the array becomes\n[\n0\n–\n,\n0\n–\n]\n.\nAfter performing the operation with\ni=2\n, the array becomes\n[0,\n1\n–\n]\n.\nIn the end, there are\nk=1\nbulbs on. We can also show that the answer cannot be less than\n2\n.\nIn the second test case, the minimum number of bulbs is\n5\n. Initially, the array is\n[1,1,1,1,1]\n.\nAfter performing the operation with\ni=1\n, the array becomes\n[\n0\n–\n,\n0\n–\n,\n0\n–\n,\n0\n–\n,\n0\n–\n]\n.\nAfter performing the operation with\ni=2\n, the array becomes\n[0,\n1\n–\n,0,\n1\n–\n,0]\n.\nAfter performing the operation with\ni=3\n, the array becomes\n[0,1,\n1\n–\n,1,0]\n.\nAfter performing the operation with\ni=4\n, the array becomes\n[0,1,1,\n0\n–\n,0]\n.\nAfter performing the operation with\ni=5\n, the array becomes\n[0,1,1,0,\n1\n–\n]\n.\nIn the end, there are\nk=3\nbulbs on. We can also show that the answer cannot be smaller than\n5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. Find Minimum Operations",
        "description": "You are given two integers\nn\nand\nk\n.\nIn one operation, you can subtract any power of\nk\nfrom\nn\n. Formally, in one operation, you can replace\nn\nby\n(n−\nk\nx\n)\nfor any non-negative integer\nx\n.\nFind the minimum number of operations required to make\nn\nequal to\n0\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤\n10\n9\n).\nOutput\nFor each test case, output the minimum number of operations on a new line.\nExample\ninput\nCopy\n6\n5 2\n3 5\n16 4\n100 3\n6492 10\n10 1\noutput\nCopy\n2\n3\n1\n4\n21\n10\nNote\nIn the first test case,\nn=5\nand\nk=2\n. We can perform the following sequence of operations:\nSubtract\n2\n0\n=1\nfrom\n5\n. The current value of\nn\nbecomes\n5−1=4\n.\nSubtract\n2\n2\n=4\nfrom\n4\n. The current value of\nn\nbecomes\n4−4=0\n.\nIt can be shown that there is no way to make\nn\nequal to\n0\nin less than\n2\noperations. Thus,\n2\nis the answer.\nIn the second test case,\nn=3\nand\nk=5\n. We can perform the following sequence of operations:\nSubtract\n5\n0\n=1\nfrom\n3\n. The current value of\nn\nbecomes\n3−1=2\n.\nSubtract\n5\n0\n=1\nfrom\n2\n. The current value of\nn\nbecomes\n2−1=1\n.\nSubtract\n5\n0\n=1\nfrom\n1\n. The current value of\nn\nbecomes\n1−1=0\n.\nIt can be shown that there is no way to make\nn\nequal to\n0\nin less than\n3\noperations. Thus,\n3\nis the answer.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "B. All Pairs Segments",
        "description": "Shirobon - FOX\n⠀\nYou are given\nn\npoints on the\nx\naxis, at increasing positive integer coordinates\nx\n1\n<\nx\n2\n<…<\nx\nn\n.\nFor each pair\n(i,j)\nwith\n1≤i<j≤n\n, you draw the segment\n[\nx\ni\n,\nx\nj\n]\n. The segments are closed, i.e., a segment\n[a,b]\ncontains the points\na,a+1,…,b\n.\nYou are given\nq\nqueries. In the\ni\n-th query, you are given a positive integer\nk\ni\n, and you have to determine how many points with integer coordinates are contained in exactly\nk\ni\nsegments.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nq\n(\n2≤n≤\n10\n5\n,\n1≤q≤\n10\n5\n) — the number of points and the number of queries.\nThe second line of each test case contains\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n1≤\nx\n1\n<\nx\n2\n<…<\nx\nn\n≤\n10\n9\n) — the coordinates of the\nn\npoints.\nThe third line of each test case contains\nq\nintegers\nk\n1\n,\nk\n2\n,…,\nk\nq\n(\n1≤\nk\ni\n≤\n10\n18\n) — the parameters of the\nq\nqueries.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n, and the sum of\nq\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single line with\nq\nintegers: the\ni\n-th integer is the answer to the\ni\n-th query.\nExample\ninput\nCopy\n3\n2 2\n101 200\n2 1\n6 15\n1 2 3 5 6 7\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\n5 8\n254618033 265675151 461318786 557391198 848083778\n6 9 15 10 6 9 4 4294967300\noutput\nCopy\n0 100 \n0 0 0 0 2 0 0 0 3 0 2 0 0 0 0 \n291716045 0 0 0 291716045 0 301749698 0 \nNote\nIn the first example, you only draw the segment\n[101,200]\n. No point is contained in exactly\n2\nsegments, and the\n100\npoints\n101,102,…,200\nare contained in exactly\n1\nsegment.\nIn the second example, you draw\n15\nsegments:\n[1,2],[1,3],[1,5],[1,6],[1,7],[2,3],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7],[5,6],[5,7],[6,7]\n. Points\n1,7\nare contained in exactly\n5\nsegments; points\n2,4,6\nare contained in exactly\n9\nsegments; points\n3,5\nare contained in exactly\n11\nsegments.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. Max Plus Size",
        "description": "EnV - Dynasty\n⠀\nYou are given an array\na\n1\n,\na\n2\n,…,\na\nn\nof positive integers.\nYou can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for\n1≤i≤n−1\n, at least one of\na\ni\nand\na\ni+1\nmust not be red).\nYour score is the maximum value of a red element plus the number of red elements. Find the maximum score you can get.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the length of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤1000\n) — the given array.\nOutput\nFor each test case, output a single integer: the maximum possible score you can get after coloring some elements red according to the statement.\nExample\ninput\nCopy\n4\n3\n5 4 5\n3\n4 5 4\n10\n3 3 3 3 4 1 2 3 4 5\n9\n17 89 92 42 29 92 14 70 45\noutput\nCopy\n7\n6\n10\n97\nNote\nIn the first test case, you can color the array as follows:\n[5,4,5]\n. Your score is\nmax([5,5])+size([5,5])=5+2=7\n. This is the maximum score you can get.\nIn the second test case, you can color the array as follows:\n[4,5,4]\n. Your score is\nmax([4,4])+size([4,4])=4+2=6\n. This is the maximum score you can get.\nIn the third test case, you can color the array as follows:\n[3,3,3,3,4,1,2,3,4,5]\n. Your score is\nmax([3,3,4,3,5])+size([3,3,4,3,5])=5+5=10\n. This is the maximum score you can get.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "*800"
        ]
    },
    {
        "title": "F3. Speedbreaker Counting (Hard Version)",
        "description": "NightHawk22 - Isolation\n⠀\nThis is the hard version of the problem. In the three versions, the constraints on\nn\nand the time limit are different. You can make hacks only if all the versions of the problem are solved.\nThis is the statement of Problem D1B:\nThere are\nn\ncities in a row, numbered\n1,2,…,n\nleft to right.\nAt time\n1\n, you conquer exactly one city, called the starting city.\nAt time\n2,3,…,n\n, you can choose a city adjacent to the ones conquered so far and conquer it.\nYou win if, for each\ni\n, you conquer city\ni\nat a time no later than\na\ni\n. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\nFor each\n0≤k≤n\n, count the number of arrays of positive integers\na\n1\n,\na\n2\n,…,\na\nn\nsuch that\n1≤\na\ni\n≤n\nfor each\n1≤i≤n\n;\nthe answer to Problem D1B is\nk\n.\nThe answer can be very large, so you have to calculate it modulo a given prime\np\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤3000\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\n,\np\n(\n1≤n≤3000\n,\n10\n8\n≤p≤\n10\n9\n,\np\nis prime) — the number of cities and the modulo.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3000\n.\nOutput\nFor each test case, output\nn+1\nintegers: the\ni\n-th integer should be the number of arrays that satisfy the conditions for\nk=i−1\n.\nExample\ninput\nCopy\n11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017\noutput\nCopy\n0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \nNote\nIn the first test case,\narrays with\n1\ngood starting city:\n[1]\n.\nIn the second test case,\narrays with\n0\ngood starting cities:\n[1,1]\n;\narrays with\n1\ngood starting city:\n[1,2]\n,\n[2,1]\n;\narrays with\n2\ngood starting cities:\n[2,2]\n.\nIn the third test case,\narrays with\n0\ngood starting cities:\n[1,1,1]\n,\n[1,1,2]\n,\n[1,1,3]\n,\n[1,2,1]\n,\n[1,2,2]\n,\n[1,3,1]\n,\n[1,3,2]\n,\n[2,1,1]\n,\n[2,1,2]\n,\n[2,2,1]\n,\n[2,2,2]\n,\n[2,3,1]\n,\n[2,3,2]\n,\n[3,1,1]\n;\narrays with\n1\ngood starting city:\n[1,2,3]\n,\n[1,3,3]\n,\n[2,1,3]\n,\n[3,1,2]\n,\n[3,1,3]\n,\n[3,2,1]\n,\n[3,3,1]\n;\narrays with\n2\ngood starting cities:\n[2,2,3]\n,\n[2,3,3]\n,\n[3,2,2]\n,\n[3,3,2]\n;\narrays with\n3\ngood starting cities:\n[3,2,3]\n,\n[3,3,3]\n.",
        "time_limit": "10 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*3100"
        ]
    },
    {
        "title": "F2. Speedbreaker Counting (Medium Version)",
        "description": "NightHawk22 - Isolation\n⠀\nThis is the medium version of the problem. In the three versions, the constraints on\nn\nand the time limit are different. You can make hacks only if all the versions of the problem are solved.\nThis is the statement of Problem D1B:\nThere are\nn\ncities in a row, numbered\n1,2,…,n\nleft to right.\nAt time\n1\n, you conquer exactly one city, called the starting city.\nAt time\n2,3,…,n\n, you can choose a city adjacent to the ones conquered so far and conquer it.\nYou win if, for each\ni\n, you conquer city\ni\nat a time no later than\na\ni\n. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\nFor each\n0≤k≤n\n, count the number of arrays of positive integers\na\n1\n,\na\n2\n,…,\na\nn\nsuch that\n1≤\na\ni\n≤n\nfor each\n1≤i≤n\n;\nthe answer to Problem D1B is\nk\n.\nThe answer can be very large, so you have to calculate it modulo a given prime\np\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\n,\np\n(\n1≤n≤500\n,\n10\n8\n≤p≤\n10\n9\n,\np\nis prime) — the number of cities and the modulo.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, output\nn+1\nintegers: the\ni\n-th integer should be the number of arrays that satisfy the conditions for\nk=i−1\n.\nExample\ninput\nCopy\n11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017\noutput\nCopy\n0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \nNote\nIn the first test case,\narrays with\n1\ngood starting city:\n[1]\n.\nIn the second test case,\narrays with\n0\ngood starting cities:\n[1,1]\n;\narrays with\n1\ngood starting city:\n[1,2]\n,\n[2,1]\n;\narrays with\n2\ngood starting cities:\n[2,2]\n.\nIn the third test case,\narrays with\n0\ngood starting cities:\n[1,1,1]\n,\n[1,1,2]\n,\n[1,1,3]\n,\n[1,2,1]\n,\n[1,2,2]\n,\n[1,3,1]\n,\n[1,3,2]\n,\n[2,1,1]\n,\n[2,1,2]\n,\n[2,2,1]\n,\n[2,2,2]\n,\n[2,3,1]\n,\n[2,3,2]\n,\n[3,1,1]\n;\narrays with\n1\ngood starting city:\n[1,2,3]\n,\n[1,3,3]\n,\n[2,1,3]\n,\n[3,1,2]\n,\n[3,1,3]\n,\n[3,2,1]\n,\n[3,3,1]\n;\narrays with\n2\ngood starting cities:\n[2,2,3]\n,\n[2,3,3]\n,\n[3,2,2]\n,\n[3,3,2]\n;\narrays with\n3\ngood starting cities:\n[3,2,3]\n,\n[3,3,3]\n.",
        "time_limit": "10 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*3000"
        ]
    },
    {
        "title": "F1. Speedbreaker Counting (Easy Version)",
        "description": "NightHawk22 - Isolation\n⠀\nThis is the easy version of the problem. In the three versions, the constraints on\nn\nand the time limit are different. You can make hacks only if all the versions of the problem are solved.\nThis is the statement of Problem D1B:\nThere are\nn\ncities in a row, numbered\n1,2,…,n\nleft to right.\nAt time\n1\n, you conquer exactly one city, called the starting city.\nAt time\n2,3,…,n\n, you can choose a city adjacent to the ones conquered so far and conquer it.\nYou win if, for each\ni\n, you conquer city\ni\nat a time no later than\na\ni\n. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\nFor each\n0≤k≤n\n, count the number of arrays of positive integers\na\n1\n,\na\n2\n,…,\na\nn\nsuch that\n1≤\na\ni\n≤n\nfor each\n1≤i≤n\n;\nthe answer to Problem D1B is\nk\n.\nThe answer can be very large, so you have to calculate it modulo a given prime\np\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤80\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\n,\np\n(\n1≤n≤80\n,\n10\n8\n≤p≤\n10\n9\n,\np\nis prime) — the number of cities and the modulo.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n80\n.\nOutput\nFor each test case, output\nn+1\nintegers: the\ni\n-th integer should be the number of arrays that satisfy the conditions for\nk=i−1\n.\nExample\ninput\nCopy\n11\n1 998244353\n2 998244353\n3 998244353\n4 998244353\n5 998244353\n6 998244353\n7 998244353\n8 998244353\n9 998244353\n10 102275857\n10 999662017\noutput\nCopy\n0 1 \n1 2 1 \n14 7 4 2 \n183 34 19 16 4 \n2624 209 112 120 48 12 \n42605 1546 793 992 468 216 36 \n785910 13327 6556 9190 4672 2880 864 144 \n16382863 130922 61939 94992 50100 36960 14256 4608 576 \n382823936 1441729 657784 1086596 583344 488700 216000 96480 23040 2880 \n20300780 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \n944100756 17572114 7751377 13641280 7376068 6810552 3269700 1785600 576000 144000 14400 \nNote\nIn the first test case,\narrays with\n1\ngood starting city:\n[1]\n.\nIn the second test case,\narrays with\n0\ngood starting cities:\n[1,1]\n;\narrays with\n1\ngood starting city:\n[1,2]\n,\n[2,1]\n;\narrays with\n2\ngood starting cities:\n[2,2]\n.\nIn the third test case,\narrays with\n0\ngood starting cities:\n[1,1,1]\n,\n[1,1,2]\n,\n[1,1,3]\n,\n[1,2,1]\n,\n[1,2,2]\n,\n[1,3,1]\n,\n[1,3,2]\n,\n[2,1,1]\n,\n[2,1,2]\n,\n[2,2,1]\n,\n[2,2,2]\n,\n[2,3,1]\n,\n[2,3,2]\n,\n[3,1,1]\n;\narrays with\n1\ngood starting city:\n[1,2,3]\n,\n[1,3,3]\n,\n[2,1,3]\n,\n[3,1,2]\n,\n[3,1,3]\n,\n[3,2,1]\n,\n[3,3,1]\n;\narrays with\n2\ngood starting cities:\n[2,2,3]\n,\n[2,3,3]\n,\n[3,2,2]\n,\n[3,3,2]\n;\narrays with\n3\ngood starting cities:\n[3,2,3]\n,\n[3,3,3]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "greedy",
            "math",
            "*2900"
        ]
    },
    {
        "title": "E2. Complex Segments (Hard Version)",
        "description": "Ken Arai - COMPLEX\n⠀\nThis is the hard version of the problem. In this version, the constraints on\nn\nand the time limit are higher. You can make hacks only if both versions of the problem are solved.\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\nall the subsets have the same size; and\na pair of segments intersects if and only if the two segments are in the same subset.\nYou are given\nn\nsegments\n[\nl\n1\n,\nr\n1\n],[\nl\n2\n,\nr\n2\n],…,[\nl\nn\n,\nr\nn\n]\n. Find the maximum size of a complex subset of these segments.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the number of segments.\nThe second line of each test case contains\nn\nintegers\nl\n1\n,\nl\n2\n,…,\nl\nn\n(\n1≤\nl\ni\n≤2n\n) — the left endpoints of the segments.\nThe third line of each test case contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\nl\ni\n≤\nr\ni\n≤2n\n) — the right endpoints of the segments.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\nExample\ninput\nCopy\n3\n3\n1 2 3\n5 4 6\n5\n1 2 3 6 8\n5 4 7 9 10\n5\n3 1 4 1 5\n7 2 6 5 10\noutput\nCopy\n3\n4\n4\nNote\nIn the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.\nIn the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following:\n{{[1,5],[2,4]},{[6,9],[8,10]}}\n.\nIn the third test case, it is optimal to make a single group containing all the segments except the second.",
        "time_limit": "13 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dsu",
            "greedy",
            "math",
            "sortings",
            "*3400"
        ]
    },
    {
        "title": "E1. Complex Segments (Easy Version)",
        "description": "Ken Arai - COMPLEX\n⠀\nThis is the easy version of the problem. In this version, the constraints on\nn\nand the time limit are lower. You can make hacks only if both versions of the problem are solved.\nA set of (closed) segments is complex if it can be partitioned into some subsets such that\nall the subsets have the same size; and\na pair of segments intersects if and only if the two segments are in the same subset.\nYou are given\nn\nsegments\n[l1,r1],[l2,r2],…,[ln,rn]\n. Find the maximum size of a complex subset of these segments.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤103\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅104\n) — the number of segments.\nThe second line of each test case contains\nn\nintegers\nl1,l2,…,ln\n(\n1≤li≤2n\n) — the left endpoints of the segments.\nThe third line of each test case contains\nn\nintegers\nr1,r2,…,rn\n(\nli≤ri≤2n\n) — the right endpoints of the segments.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅104\n.\nOutput\nFor each test case, output a single integer: the maximum size of a complex subset of the given segments.\nExample\ninput\nCopy\n3\n3\n1 2 3\n5 4 6\n5\n1 2 3 6 8\n5 4 7 9 10\n5\n3 1 4 1 5\n7 2 6 5 10\noutput\nCopy\n3\n4\n4\nNote\nIn the first test case, all pairs of segments intersect, therefore it is optimal to form a single group containing all of the three segments.\nIn the second test case, there is no valid partition for all of the five segments. A valid partition with four segments is the following:\n{{[1,5],[2,4]},{[6,9],[8,10]}}\n.\nIn the third test case, it is optimal to make a single group containing all the segments except the second.",
        "time_limit": "6 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dsu",
            "greedy",
            "math",
            "sortings",
            "*3300"
        ]
    },
    {
        "title": "D. Max Plus Min Plus Size",
        "description": "EnV - The Dusty Dragon Tavern\n⠀\nYou are given an array\na\n1\n,\na\n2\n,…,\na\nn\nof positive integers.\nYou can color some elements of the array red, but there cannot be two adjacent red elements (i.e., for\n1≤i≤n−1\n, at least one of\na\ni\nand\na\ni+1\nmust not be red).\nYour score is the maximum value of a red element, plus the minimum value of a red element, plus the number of red elements. Find the maximum score you can get.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the given array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum possible score you can get after coloring some elements red according to the statement.\nExample\ninput\nCopy\n4\n3\n5 4 5\n3\n4 5 4\n10\n3 3 3 3 4 1 2 3 5 4\n10\n17 89 92 42 29 41 92 14 70 45\noutput\nCopy\n12\n11\n12\n186\nNote\nIn the first test case, you can color the array as follows:\n[5,4,5]\n. Your score is\nmax([5,5])+min([5,5])+size([5,5])=5+5+2=12\n. This is the maximum score you can get.\nIn the second test case, you can color the array as follows:\n[4,5,4]\n. Your score is\nmax([5])+min([5])+size([5])=5+5+1=11\n. This is the maximum score you can get.\nIn the third test case, you can color the array as follows:\n[3,3,3,3,4,1,2,3,5,4]\n. Your score is\nmax([3,3,4,3,4])+min([3,3,4,3,4])+size([3,3,4,3,4])=4+3+5=12\n. This is the maximum score you can get.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "dsu",
            "greedy",
            "implementation",
            "matrices",
            "sortings",
            "*2200"
        ]
    },
    {
        "title": "C. Tree Pruning",
        "description": "t+pazolite, ginkiha, Hommarju - Paved Garden\n⠀\nYou are given a tree with\nn\nnodes, rooted at node\n1\n. In this problem, a leaf is a non-root node with degree\n1\n.\nIn one operation, you can remove a leaf and the edge adjacent to it (possibly, new leaves appear). What is the minimum number of operations that you have to perform to get a tree, also rooted at node\n1\n, where all the leaves are at the same distance from the root?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤5⋅\n10\n5\n) — the number of nodes.\nEach of the next\nn−1\nlines contains two integers\nu\n,\nv\n(\n1≤u,v≤n\n,\nu≠v\n), describing an edge that connects\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the minimum number of operations needed to achieve your goal.\nExample\ninput\nCopy\n3\n7\n1 2\n1 3\n2 4\n2 5\n4 6\n4 7\n7\n1 2\n1 3\n1 4\n2 5\n3 6\n5 7\n15\n12 9\n1 6\n6 14\n9 11\n8 7\n3 5\n13 5\n6 10\n13 15\n13 6\n14 12\n7 2\n8 1\n1 4\noutput\nCopy\n2\n2\n5\nNote\nIn the first two examples, the tree is as follows:\nIn the first example, by removing edges\n(1,3)\nand\n(2,5)\n, the resulting tree has all leaves (nodes\n6\nand\n7\n) at the same distance from the root (node\n1\n), which is\n3\n. The answer is\n2\n, as it is the minimum number of edges that need to be removed to achieve the goal.\nIn the second example, removing edges\n(1,4)\nand\n(5,7)\nresults in a tree where all leaves (nodes\n4\nand\n5\n) are at the same distance from the root (node\n1\n), which is\n2\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "greedy",
            "sortings",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "B. Speedbreaker",
        "description": "Djjaner - Speedbreaker\n⠀\nThere are\nn\ncities in a row, numbered\n1,2,…,n\nleft to right.\nAt time\n1\n, you conquer exactly one city, called the starting city.\nAt time\n2,3,…,n\n, you can choose a city adjacent to the ones conquered so far and conquer it.\nYou win if, for each\ni\n, you conquer city\ni\nat a time no later than\na\ni\n. A winning strategy may or may not exist, also depending on the starting city. How many starting cities allow you to win?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of cities.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the deadlines for conquering the cities.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the number of starting cities that allow you to win.\nExample\ninput\nCopy\n3\n6\n6 3 3 3 5 5\n6\n5 6 4 1 4 5\n9\n8 6 4 2 1 3 5 7 9\noutput\nCopy\n3\n0\n1\nNote\nIn the first test case, cities\n2\n,\n3\n, and\n4\nare good starting cities.\nIn the second test case, there are no good starting cities.\nIn the third test case, the only good starting city is city\n5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "A. Cards Partition",
        "description": "DJ Genki vs Gram - Einherjar Joker\n⠀\nYou have some cards. An integer between\n1\nand\nn\nis written on each card: specifically, for each\ni\nfrom\n1\nto\nn\n, you have\na\ni\ncards which have the number\ni\nwritten on them.\nThere is also a shop which contains unlimited cards of each type. You have\nk\ncoins, so you can buy at most\nk\nnew cards in total, and the cards you buy can contain any integer between\n1\nand\nn\n, inclusive.\nAfter buying the new cards, you must partition all your cards into decks, according to the following rules:\nall the decks must have the same size;\nthere are no pairs of cards with the same value in the same deck.\nFind the maximum possible size of a deck after buying cards and partitioning them optimally.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nk\n(\n1≤n≤2⋅\n10\n5\n,\n0≤k≤\n10\n16\n) — the number of distinct types of cards and the number of coins.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n10\n,\n∑\na\ni\n≥1\n) — the number of cards of type\ni\nyou have at the beginning, for each\n1≤i≤n\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum possible size of a deck if you operate optimally.\nExample\ninput\nCopy\n9\n3 1\n3 2 2\n5 4\n2 6 1 2 4\n2 100\n1410065408 10000000000\n10 8\n7 4 6 6 9 3 10 2 8 7\n2 12\n2 2\n2 70\n0 1\n1 0\n1\n3 0\n2 1 2\n3 1\n0 3 3\noutput\nCopy\n2\n3\n1\n7\n2\n2\n1\n1\n2\nNote\nIn the first test case, you can buy one card with the number\n1\n, and your cards become\n[1,1,1,1,2,2,3,3]\n. You can partition them into the decks\n[1,2],[1,2],[1,3],[1,3]\n: they all have size\n2\n, and they all contain distinct values. You can show that you cannot get a partition with decks of size greater than\n2\n, so the answer is\n2\n.\nIn the second test case, you can buy two cards with the number\n1\nand one card with the number\n3\n, and your cards become\n[1,1,1,1,2,2,2,2,2,2,3,3,4,4,5,5,5,5]\n, which can be partitioned into\n[1,2,3],[1,2,4],[1,2,5],[1,2,5],[2,3,5],[2,4,5]\n. You can show that you cannot get a partition with decks of size greater than\n3\n, so the answer is\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "2-sat",
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "H. Robin Hood Archery",
        "description": "At such times archery was always the main sport of the day, for the Nottinghamshire yeomen were the best hand at the longbow in all merry England, but this year the Sheriff hesitated...\nSheriff of Nottingham has organized a tournament in archery. It's the final round and Robin Hood is playing against Sheriff!\nThere are\nn\ntargets in a row numbered from\n1\nto\nn\n. When a player shoots target\ni\n, their score increases by\na\ni\nand the target\ni\nis destroyed. The game consists of turns and players alternate between whose turn it is. Robin Hood always starts the game, then Sheriff and so on. The game continues until all targets are destroyed. Both players start with score\n0\n.\nAt the end of the game, the player with most score wins and the other player loses. If both players have the same score, it's a tie and no one wins or loses. In each turn, the player can shoot any target that wasn't shot before. Both play optimally to get the most score possible.\nSheriff of Nottingham has a suspicion that he might lose the game! This cannot happen, you must help Sheriff. Sheriff will pose\nq\nqueries, each specifying\nl\nand\nr\n. This means that the game would be played only with targets\nl,l+1,…,r\n, as others would be removed by Sheriff before the game starts.\nFor each query\nl\n,\nr\n, determine whether the Sheriff can not lose the game when only considering the targets\nl,l+1,…,r\n.\nInput\nThe first line of input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\n,\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the number of targets and the queries Sheriff will pose.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the points for hitting each target.\nThen follow\nq\nlines, each with two integers\nl\nand\nr\n(\n1≤l≤r≤n\n) — the range of the targets that is considered for each query.\nIt is guaranteed that the sum of both\nn\nand\nq\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output \"YES\", if the Sheriff does not lose the game when only considering the targets\nl,l+1,…,r\n, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n2\n3 3\n1 2 2\n1 2\n1 3\n2 3\n5 3\n2 1 2 1 1\n1 2\n1 3\n4 5\noutput\nCopy\nNO\nNO\nYES\nNO\nNO\nYES",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "greedy",
            "hashing",
            "*1900"
        ]
    },
    {
        "title": "G. Milky Days",
        "description": "What is done is done, and the spoilt milk cannot be helped.\nLittle John is as little as night is day — he was known to be a giant, at possibly\n2.1\nmetres tall. It has everything to do with his love for milk.\nHis dairy diary has\nn\nentries, showing that he acquired\na\ni\npints of fresh milk on day\nd\ni\n. Milk declines in freshness with time and stays drinkable for a maximum of\nk\ndays. In other words, fresh milk acquired on day\nd\ni\nwill be drinkable between days\nd\ni\nand\nd\ni\n+k−1\ninclusive.\nEvery day, Little John drinks drinkable milk, up to a maximum of\nm\npints. In other words, if there are less than\nm\npints of milk, he will drink them all and not be satisfied; if there are at least\nm\npints of milk, he will drink exactly\nm\npints and be satisfied, and it's a milk satisfaction day.\nLittle John always drinks the freshest drinkable milk first.\nDetermine the number of milk satisfaction days for Little John.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n), the number of test cases.\nThe first line of each test case consists of three integers\nn\n,\nm\n,\nk\n(\n1≤n\n,\nm\n,\nk≤\n10\n5\n), the number of diary entries, the maximum pints needed for a milk satisfaction day, and the duration of milk's freshness.\nThen follow\nn\nlines of each test case, each with two integers\nd\ni\nand\na\ni\n(\n1≤\nd\ni\n,\na\ni\n≤\n10\n6\n), the day on which the milk was acquired and the number of pints acquired. They are sorted in increasing values of\nd\ni\n, and all values of\nd\ni\nare distinct.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer, the number of milk satisfaction days.\nExample\ninput\nCopy\n6\n1 1 3\n1 5\n2 3 3\n1 5\n2 7\n4 5 2\n1 9\n2 6\n4 9\n5 6\n5 2 4\n4 7\n5 3\n7 1\n11 2\n12 1\n4 1 3\n5 10\n9 4\n14 8\n15 3\n5 5 5\n8 9\n10 7\n16 10\n21 5\n28 9\noutput\nCopy\n3\n3\n4\n5\n10\n6\nNote\nIn the first test case,\n5\npints of milk are good for\n3\ndays before spoiling.\nIn the second test case, the following will happen:\nOn day\n1\n, he will receive\n5\npints of milk and drink\n3\nof them (leaving\n2\npints from day\n1\n);\nOn day\n2\n, he will receive\n7\npints of milk and drink\n3\nof them (leaving\n2\npints from day\n1\nand\n4\npints from day\n2\n);\nOn day\n3\n, he will drink\n3\npints from day\n2\n(leaving\n2\npints from day\n1\nand\n1\npint from day\n2\n);\nOn day\n4\n, the milk acquired on day\n1\nwill spoil, and he will drink\n1\npint from day\n2\n(no more milk is left).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "F. Sheriff's Defense",
        "description": "\"Why, master,\" quoth Little John, taking the bags and weighing them in his hand, \"here is the chink of gold.\"\nThe folk hero Robin Hood has been troubling Sheriff of Nottingham greatly. Sheriff knows that Robin Hood is about to attack his camps and he wants to be prepared.\nSheriff of Nottingham built the camps with strategy in mind and thus there are exactly\nn\ncamps numbered from\n1\nto\nn\nand\nn−1\ntrails, each connecting two camps. Any camp can be reached from any other camp. Each camp\ni\nhas initially\na\ni\ngold.\nAs it is now, all camps would be destroyed by Robin. Sheriff can strengthen a camp by subtracting exactly\nc\ngold from each of its neighboring camps and use it to build better defenses for that camp. Strengthening a camp doesn't change its gold, only its neighbors' gold. A camp can have negative gold.\nAfter Robin Hood's attack, all camps that have been strengthened survive the attack, all others are destroyed.\nWhat's the maximum gold Sheriff can keep in his surviving camps after Robin Hood's attack if he strengthens his camps optimally?\nCamp\na\nis neighboring camp\nb\nif and only if there exists a trail connecting\na\nand\nb\n. Only strengthened camps count towards the answer, as others are destroyed.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case begins with two integers\nn\n,\nc\n(\n1≤n≤2⋅\n10\n5\n,1≤c≤\n10\n9\n) — the number of camps and the gold taken from each neighboring camp for strengthening.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the initial gold of each camp.\nThen follow\nn−1\nlines, each with integers\nu\n,\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — meaning that there is a trail between\nu\nand\nv\n.\nThe sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nIt is guaranteed that any camp is reachable from any other camp.\nOutput\nOutput a single integer, the maximum gold Sheriff of Nottingham can keep in his surviving camps after Robin Hood's attack.\nExample\ninput\nCopy\n5\n3 1\n2 3 1\n1 2\n2 3\n3 1\n3 6 3\n1 2\n2 3\n3 1\n-2 -3 -1\n1 2\n2 3\n6 1\n5 -4 3 6 7 3\n4 1\n5 1\n3 5\n3 6\n1 2\n8 1\n3 5 2 7 8 5 -3 -4\n7 3\n1 8\n4 3\n3 5\n7 6\n8 7\n2 1\noutput\nCopy\n3\n8\n0\n17\n26\nNote\nIn the first test case, it is optimal to strengthen the second base. The final gold at each base is\n[1,3,0]\n.\nIn the second test case, it is optimal to strengthen all bases. The final gold at each base is\n[2,4,2]\n.\nIn the third test case, it is optimal to not strengthen any base.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "greedy",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "E. Rendez-vous de Marian et Robin",
        "description": "In the humble act of meeting, joy doth unfold like a flower in bloom.\nAbsence makes the heart grow fonder. Marian sold her last ware at the Market at the same time Robin finished training at the Major Oak. They couldn't wait to meet, so they both start without delay.\nThe travel network is represented as\nn\nvertices numbered from\n1\nto\nn\nand\nm\nedges. The\ni\n-th edge connects vertices\nu\ni\nand\nv\ni\n, and takes\nw\ni\nseconds to travel (all\nw\ni\nare even). Marian starts at vertex\n1\n(Market) and Robin starts at vertex\nn\n(Major Oak).\nIn addition,\nh\nof the\nn\nvertices each has a single horse available. Both Marian and Robin are capable riders, and could mount horses in no time (i.e. in\n0\nseconds). Travel times are halved when riding. Once mounted, a horse lasts the remainder of the travel. Meeting must take place on a vertex (i.e. not on an edge). Either could choose to wait on any vertex.\nOutput the earliest time Robin and Marian can meet. If vertices\n1\nand\nn\nare disconnected, output\n−1\nas the meeting is cancelled.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case consists of three integers\nn\n,\nm\n,\nh\n(\n2≤n≤2⋅\n10\n5\n,1≤m≤2⋅\n10\n5\n,1≤h≤n\n) — the number of vertices, the number of edges and the number of vertices that have a single horse.\nThe second line of each test case contains\nh\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nh\n(\n1≤\na\ni\n≤n\n) — the vertices that have a single horse available.\nThen follow\nm\nlines of each test case, each with three integers\nu\ni\n,\nv\ni\n,\nw\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n,2≤\nw\ni\n≤\n10\n6\n) — meaning that there is an edge between vertices\nu\ni\nand\nv\ni\nwith travel cost\nw\ni\nseconds without a horse.\nThere are no self loops or multiple edges. By good fortune, all\nw\ni\nare even integers.\nIt is guaranteed that the sums of both\nn\nand\nm\nover all test cases do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer, the earliest time Robin and Marian can meet. If it is impossible for them to meet, output\n−1\n.\nExample\ninput\nCopy\n6\n2 1 1\n1\n1 2 10\n3 1 2\n2 3\n1 2 10\n3 3 1\n2\n1 2 4\n1 3 10\n2 3 6\n4 3 2\n2 3\n1 2 10\n2 3 18\n3 4 16\n3 2 1\n2\n1 2 4\n1 3 16\n7 7 1\n3\n1 5 2\n2 6 12\n1 2 12\n6 4 8\n7 3 4\n6 3 4\n7 6 4\noutput\nCopy\n5\n-1\n6\n19\n14\n12\nNote\nIn the first test case, Marian rides from vertex\n1\nto vertex\n2\n, Robin waits.\nIn the second test case, vertices\n1\nand\n3\nare not connected.\nIn the third test case, both Marian and Robin travel to vertex\n2\nto meet.\nIn the fourth test case, Marian travels to vertex\n2\nwithout a horse, mounts the horse at vertex\n2\nand rides to vertex\n3\nto meet Robin.\nIn the fifth test case, Marian travels to vertex\n2\nwithout a horse, mounts the horse at vertex\n2\nand rides back to vertex\n1\nand then to vertex\n3\n. Robin waits.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "graphs",
            "shortest paths",
            "*1800"
        ]
    },
    {
        "title": "D. Robert Hood and Mrs Hood",
        "description": "Impress thy brother, yet fret not thy mother.\nRobin's brother and mother are visiting, and Robin gets to choose the start day for each visitor.\nAll days are numbered from\n1\nto\nn\n. Visitors stay for\nd\ncontinuous days, all of those\nd\ndays must be between day\n1\nand\nn\ninclusive.\nRobin has a total of\nk\nrisky 'jobs' planned. The\ni\n-th job takes place between days\nl\ni\nand\nr\ni\ninclusive, for\n1≤i≤k\n. If a job takes place on any of the\nd\ndays, the visit overlaps with this job (the length of overlap is unimportant).\nRobin wants his brother's visit to overlap with the maximum number of distinct jobs, and his mother's the minimum.\nFind suitable start days for the visits of Robin's brother and mother. If there are multiple suitable days, choose the earliest one.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case consists of three integers\nn\n,\nd\n,\nk\n(\n1≤n≤\n10\n5\n,1≤d,k≤n\n) — the number of total days, duration of the visits, and the number of jobs.\nThen follow\nk\nlines of each test case, each with two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the start and end day of each job.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two integers, the best starting days of Robin's brother and mother respectively. Both visits must fit between day\n1\nand\nn\ninclusive.\nExample\ninput\nCopy\n6\n2 1 1\n1 2\n4 1 2\n1 2\n2 4\n7 2 3\n1 2\n1 3\n6 7\n5 1 2\n1 2\n3 5\n9 2 1\n2 8\n9 2 4\n7 9\n4 8\n1 3\n2 3\noutput\nCopy\n1 1\n2 1\n1 4\n1 1\n1 1\n3 4\nNote\nIn the first test case, the only job fills all\n2\ndays, both should visit on day\n1\n.\nIn the second test case, day\n2\noverlaps with\n2\njobs and day\n1\noverlaps with only\n1\n.\nIn the third test case, Robert visits for days\n[1,2]\n, Mrs. Hood visits for days\n[4,5]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "C. Robin Hood in Town",
        "description": "In Sherwood, we judge a man not by his wealth, but by his merit.\nLook around, the rich are getting richer, and the poor are getting poorer. We need to take from the rich and give to the poor. We need Robin Hood!\nThere are\nn\npeople living in the town. Just now, the wealth of the\ni\n-th person was\na\ni\ngold. But guess what? The richest person has found an extra pot of gold!\nMore formally, find an\na\nj\n=max(\na\n1\n,\na\n2\n,…,\na\nn\n)\n, change\na\nj\nto\na\nj\n+x\n, where\nx\nis a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.\nA person is unhappy if their wealth is strictly less than half of the average wealth\n∗\n.\nIf strictly more than half of the total population\nn\nare unhappy, Robin Hood will appear by popular demand.\nDetermine the minimum value of\nx\nfor Robin Hood to appear, or output\n−1\nif it is impossible.\n∗\nThe average wealth is defined as the total wealth divided by the total population\nn\n, that is,\n∑\na\ni\nn\n, the result is a real number.\nInput\nThe first line of input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the total population.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the wealth of each person.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the minimum number of gold that the richest person must find for Robin Hood to appear. If it is impossible, output\n−1\ninstead.\nExample\ninput\nCopy\n6\n1\n2\n2\n2 19\n3\n1 3 20\n4\n1 2 3 4\n5\n1 2 3 4 5\n6\n1 2 1 1 1 25\noutput\nCopy\n-1\n-1\n0\n15\n16\n0\nNote\nIn the first test case, it is impossible for a single person to be unhappy.\nIn the second test case, there is always\n1\nhappy person (the richest).\nIn the third test case, no additional gold are required, so the answer is\n0\n.\nIn the fourth test case, after adding\n15\ngold, the average wealth becomes\n25\n4\n, and half of this average is\n25\n8\n, resulting in\n3\npeople being unhappy.\nIn the fifth test case, after adding\n16\ngold, the average wealth becomes\n31\n5\n, resulting in\n3\npeople being unhappy.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "B. Robin Hood and the Major Oak",
        "description": "In Sherwood, the trees are our shelter, and we are all children of the forest.\nThe Major Oak in Sherwood is known for its majestic foliage, which provided shelter to Robin Hood and his band of merry men and women.\nThe Major Oak grows\ni\ni\nnew leaves in the\ni\n-th year. It starts with\n1\nleaf in year\n1\n.\nLeaves last for\nk\nyears on the tree. In other words, leaves grown in year\ni\nlast between years\ni\nand\ni+k−1\ninclusive.\nRobin considers even numbers lucky. Help Robin determine whether the Major Oak will have an even number of leaves in year\nn\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two integers\nn\n,\nk\n(\n1≤n≤\n10\n9\n,\n1≤k≤n\n) — the requested year and the number of years during which the leaves remain.\nOutput\nFor each test case, output one line, \"YES\" if in year\nn\nthe Major Oak will have an even number of leaves and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n5\n1 1\n2 1\n2 2\n3 2\n4 4\noutput\nCopy\nNO\nYES\nNO\nNO\nYES\nNote\nIn the first test case, there is only\n1\nleaf.\nIn the second test case,\nk=1\n, so in the\n2\n-nd year there will be\n2\n2\n=4\nleaves.\nIn the third test case,\nk=2\n, so in the\n2\n-nd year there will be\n1+\n2\n2\n=5\nleaves.\nIn the fourth test case,\nk=2\n, so in the\n3\n-rd year there will be\n2\n2\n+\n3\n3\n=4+27=31\nleaves.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "*800"
        ]
    },
    {
        "title": "A. Robin Helps",
        "description": "There is a little bit of the outlaw in everyone, and a little bit of the hero too.\nThe heroic outlaw Robin Hood is famous for taking from the rich and giving to the poor.\nRobin encounters\nn\npeople starting from the\n1\n-st and ending with the\nn\n-th. The\ni\n-th person has\na\ni\ngold. If\na\ni\n≥k\n, Robin will take all\na\ni\ngold, and if\na\ni\n=0\n, Robin will give\n1\ngold if he has any. Robin starts with\n0\ngold.\nFind out how many people Robin gives gold to.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\n,\nk\n(\n1≤n≤50,1≤k≤100\n) — the number of people and the threshold at which Robin Hood takes the gold.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤100\n) — the gold of each person.\nOutput\nFor each test case, output a single integer, the number of people that will get gold from Robin Hood.\nExample\ninput\nCopy\n4\n2 2\n2 0\n3 2\n3 0 0\n6 2\n0 3 0 0 0 0\n2 5\n5 4\noutput\nCopy\n1\n2\n3\n0\nNote\nIn the first test case, Robin takes\n2\ngold from the first person and gives a gold to the second person.\nIn the second test case, Robin takes\n3\ngold and gives\n1\ngold to each of the next\n2\npeople.\nIn the third test case, Robin takes\n3\ngold and so only gives gold to\n3\nother people.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F2. Game in Tree (Hard Version)",
        "description": "This is the hard version of the problem. In this version, it is not guaranteed that\nu=v\n. You can make hacks only if both versions of the problem are solved.\nAlice and Bob are playing a fun game on a tree. This game is played on a tree with\nn\nvertices, numbered from\n1\nto\nn\n. Recall that a tree with\nn\nvertices is an undirected connected graph with\nn−1\nedges.\nAlice and Bob take turns, with Alice going first. Each player starts at some vertex.\nOn their turn, a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone. The first player who cannot make a move loses.\nYou are given two vertices\nu\nand\nv\n. Represent the simple path from vertex\nu\nto\nv\nas an array\np\n1\n,\np\n2\n,\np\n3\n,…,\np\nm\n, where\np\n1\n=u\n,\np\nm\n=v\n, and there is an edge between\np\ni\nand\np\ni+1\nfor all\ni\n(\n1≤i<m\n).\nYou need to determine the winner of the game if Alice starts at vertex\n1\nand Bob starts at vertex\np\nj\nfor each\nj\n(where\n1≤j≤m\n).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nEach of the following\nn−1\nlines contains two integers\na\nand\nb\n(\n1≤a,b≤n\n), denoting an undirected edge between vertices\na\nand\nb\n. It is guaranteed that these edges form a tree.\nThe last line of each test case contains two integers\nu\nand\nv\n(\n2≤u,v≤n\n).\nIt is guaranteed that the path from\nu\nto\nv\ndoes not pass through vertex\n1\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nm\nlines.\nIn the\ni\n-th line, print the winner of the game if Alice starts at vertex\n1\nand Bob starts at vertex\np\ni\n. Print \"Alice\" (without quotes) if Alice wins, or \"Bob\" (without quotes) otherwise.\nExample\ninput\nCopy\n3\n3\n1 2\n2 3\n2 3\n6\n1 2\n1 3\n2 4\n2 5\n1 6\n4 5\n4\n1 2\n1 3\n2 4\n2 4\noutput\nCopy\nBob\nAlice\nAlice\nBob\nAlice\nBob\nAlice\nNote\nTree from the first example.\nIn the first test case, the path will be (\n2,3\n). If Bob starts at vertex\n2\n, Alice will not be able to move anywhere on her first turn and will lose.\nHowever, if Bob starts at vertex\n3\n, Alice will move to vertex\n2\n, and Bob will have no remaining vertices to visit and will lose.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "trees",
            "*3500"
        ]
    },
    {
        "title": "F1. Game in Tree (Easy Version)",
        "description": "This is the easy version of the problem. In this version,\nu=v\n. You can make hacks only if both versions of the problem are solved.\nAlice and Bob are playing a fun game on a tree. This game is played on a tree with\nn\nvertices, numbered from\n1\nto\nn\n. Recall that a tree with\nn\nvertices is an undirected connected graph with\nn−1\nedges.\nAlice and Bob take turns, with Alice going first. Each player starts at some vertex.\nOn their turn, a player must move from the current vertex to a neighboring vertex that has not yet been visited by anyone. The first player who cannot make a move loses.\nYou are given two vertices\nu\nand\nv\n. Represent the simple path from vertex\nu\nto\nv\nas an array\np\n1\n,\np\n2\n,\np\n3\n,…,\np\nm\n, where\np\n1\n=u\n,\np\nm\n=v\n, and there is an edge between\np\ni\nand\np\ni+1\nfor all\ni\n(\n1≤i<m\n).\nYou need to determine the winner of the game if Alice starts at vertex\n1\nand Bob starts at vertex\np\nj\nfor each\nj\n(where\n1≤j≤m\n).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nEach of the following\nn−1\nlines contains two integers\na\nand\nb\n(\n1≤a,b≤n\n), denoting an undirected edge between vertices\na\nand\nb\n. It is guaranteed that these edges form a tree.\nThe last line of each test case contains two integers\nu\nand\nv\n(\n2≤u,v≤n\n,\nu=v\n).\nIt is guaranteed that the path from\nu\nto\nv\ndoes not pass through vertex\n1\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nm\nlines.\nIn the\ni\n-th line, print the winner of the game if Alice starts at vertex\n1\nand Bob starts at vertex\np\ni\n. Print \"Alice\" (without quotes) if Alice wins, or \"Bob\" (without quotes) otherwise.\nExample\ninput\nCopy\n3\n3\n1 2\n2 3\n2 2\n3\n1 2\n2 3\n3 3\n6\n1 2\n1 3\n2 4\n2 5\n1 6\n4 4\noutput\nCopy\nBob\nAlice\nAlice\nNote\nTree from the first and second examples.\nIn the first test case, the path will be (\n2,2\n). Bob starts at vertex\n2\n, Alice will not be able to move anywhere on her first turn and will lose.\nIn the second test case, the path will be (\n3,3\n). Bob starts at vertex\n3\n, Alice will move to vertex\n2\n, and Bob will have no remaining vertices to visit and will lose.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "games",
            "greedy",
            "implementation",
            "trees",
            "*2700"
        ]
    },
    {
        "title": "E. Prefix GCD",
        "description": "Since Mansur is tired of making legends, there will be no legends for this task.\nYou are given an array of positive integer numbers\na\n1\n,\na\n2\n,…,\na\nn\n. The elements of the array can be rearranged in any order. You need to find the smallest possible value of the expression\ngcd(\na\n1\n)+gcd(\na\n1\n,\na\n2\n)+…+gcd(\na\n1\n,\na\n2\n,…,\na\nn\n),\ngcd\n(\n)\ngcd\n(\n)\ngcd\n(\n)\nwhere\ngcd(\na\n1\n,\na\n2\n,…,\na\nn\n)\ndenotes the greatest common divisor (GCD) of\na\n1\n,\na\n2\n,…,\na\nn\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single number\nn\n(\n1≤n≤\n10\n5\n) — the size of the array.\nThe second line of each test case contains\nn\nnumbers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the initial array.\nThe sum of\nn\nover all test cases does not exceed\n10\n5\n.\nThe sum of\nmax(\na\n1\n,\na\n2\n,…,\na\nn\n)\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single number on a separate line — the answer to the problem.\nExample\ninput\nCopy\n5\n3\n4 2 2\n2\n6 3\n3\n10 15 6\n5\n6 42 12 52 20\n4\n42 154 231 66\noutput\nCopy\n6\n6\n9\n14\n51\nNote\nIn the first test case, the elements can be rearranged as follows:\n[2,4,2]\n. Then the answer will be\ngcd(2)+gcd(2,4)+gcd(2,4,2)=2+2+2=6\n.\nIn the third test case, the elements can be rearranged as follows:\n[6,10,15]\n. Then the answer will be\ngcd(6)+gcd(6,10)+gcd(6,10,15)=6+2+1=9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "D. Minimize the Difference",
        "description": "Zhan, tired after the contest, gave the only task that he did not solve during the contest to his friend, Sungat. However, he could not solve it either, so we ask you to try to solve this problem.\nYou are given an array\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\n. We can perform any number (possibly, zero) of operations on the array.\nIn one operation, we choose a position\ni\n(\n1≤i≤n−1\n) and perform the following action:\na\ni\n:=\na\ni\n−1\n, and\na\ni+1\n:=\na\ni+1\n+1\n.\nFind the minimum possible value of\nmax(\na\n1\n,\na\n2\n,…,\na\nn\n)−min(\na\n1\n,\na\n2\n,…,\na\nn\n)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n).\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the minimum possible value of\nmax(\na\n1\n,\na\n2\n,…,\na\nn\n)−min(\na\n1\n,\na\n2\n,…,\na\nn\n)\n.\nExample\ninput\nCopy\n5\n1\n1\n3\n1 2 3\n4\n4 1 2 3\n4\n4 2 3 1\n5\n5 14 4 10 2\noutput\nCopy\n0\n2\n1\n1\n3\nNote\nIn the third testcase, you can perform the operation twice with\ni=1\n.\nAfter that, the array is\na=[2,3,2,3]\n, and\nmax(2,3,2,3)−min(2,3,2,3)=3−2=1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "*1900"
        ]
    },
    {
        "title": "C. Password Cracking",
        "description": "Dimash learned that Mansur wrote something very unpleasant about him to a friend, so he decided to find out his password at all costs and discover what exactly he wrote.\nBelieving in the strength of his password, Mansur stated that his password — is a binary string of length\nn\n. He is also ready to answer Dimash's questions of the following type:\nDimash says a binary string\nt\n, and Mansur replies whether it is true that\nt\nis a substring of his password.\nHelp Dimash find out the password in no more than\n2n\noperations; otherwise, Mansur will understand the trick and stop communicating with him.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nInteraction\nAt the beginning of each test case, first read\nn\n(\n1≤n≤100\n) — the size of the binary string. Then proceed to guessing it.\nTo guess each string\ns\n, you can make no more than\n2n\nqueries of the following type:\n\"? t\", where\nt\nis a binary string such that (\n1≤|t|≤n\n).\nIn response to this query, you will receive\n1\nif\nt\nis a substring of\ns\n, and\n0\notherwise.\nOnce you receive the answer, output a single string in the following format:\n\"! s\", where\ns\nis a binary string of size\nn\n.\nAfter that, proceed to solve the next test case.\nIf you make an incorrect attempt or exceed the limit of\n2n\nattempts, you will receive\n−1\ninstead of an answer and get the verdict Wrong answer. In this case, your program should terminate immediately to avoid undefined verdicts.\nAfter outputting the queries, do not forget to output a newline character and flush the output buffer. Otherwise, you will receive the verdict Solution \"hung\". To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nrefer to the documentation for other languages.\nHacks:\nTo use hacks, use the following format of tests:\nThe first line should contain a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case should contain a single number\nn\n(\n1≤n≤100\n) — the length of the string. The second line should contain a binary string of size\nn\n.\nExample\ninput\nCopy\n4\n3\n\n0\n\n0\n\n1\n\n4\n\n4\n\n2\noutput\nCopy\n? 00\n\n? 000\n\n? 010\n\n! 010\n\n! 1100\n\n! 0110\n\n! 10\nNote\nIn the first example, the string\n010\nis given. Therefore, the answers to the queries are as follows:\n\"? 00\"\n00\nis not a substring of\n010\n, so the answer is\n0\n.\n\"? 000\"\n000\nis not a substring, so the answer is\n0\n.\n\"? 010\"\n010\nis a substring, so the answer is\n1\n.\nIn the second example, the string is\n1100\n, in the third\n0110\n, and in the fourth\n10\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "interactive",
            "strings",
            "*1400"
        ]
    },
    {
        "title": "B. Battle for Survive",
        "description": "Eralim, being the mafia boss, manages a group of\nn\nfighters. Fighter\ni\nhas a rating of\na\ni\n.\nEralim arranges a tournament of\nn−1\nbattles, in each of which two not yet eliminated fighters\ni\nand\nj\n(\n1≤i<j≤n\n) are chosen, and as a result of the battle, fighter\ni\nis eliminated from the tournament, and the rating of fighter\nj\nis reduced by the rating of fighter\ni\n. That is,\na\nj\nis decreased by\na\ni\n. Note that fighter\nj\n's rating can become negative. The fighters indexes do not change.\nEralim wants to know what maximum rating the last remaining fighter can preserve if he chooses the battles optimally.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of fighters.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the ratings of the fighters.\nThe sum of\nn\nover all testcases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, output a single integer — the maximum rating that the last remaining fighter can preserve.\nExample\ninput\nCopy\n5\n2\n2 1\n3\n2 2 8\n4\n1 2 4 3\n5\n1 2 3 4 5\n5\n3 2 4 5 4\noutput\nCopy\n-1\n8\n2\n7\n8\nNote\nIn the first example, you can arrange a fight between fighters with indices\n1\nand\n2\n, where the fighter with index\n2\nwill win. The rating of the last fighter, that is, the fighter with index\n2\n, will be\n1−2=−1\n.\nIn the second example, you can first conduct a fight between fighters with indices\n1\nand\n2\n, where the fighter with index\n2\nwill win, and then conduct a fight between fighters with indices\n2\nand\n3\n, where the fighter with index\n3\nwill win.\nThe rating of the fighter with index\n2\nafter the first fight will be\n2−2=0\n. The rating of the fighter with index\n3\nafter the second fight will be\n8−0=8\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "A. Zhan's Blender",
        "description": "Today, a club fair was held at \"NSPhM\". In order to advertise his pastry club, Zhan decided to demonstrate the power of his blender.\nTo demonstrate the power of his blender, Zhan has\nn\nfruits.\nThe blender can mix up to\nx\nfruits per second.\nIn each second, Zhan can put up to\ny\nfruits into the blender. After that, the blender will blend\nmin(x,c)\nfruits, where\nc\nis the number of fruits inside the blender. After blending, blended fruits are removed from the blender.\nHelp Zhan determine the minimum amount of time required for Zhan to blend all fruits.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains one integer\nn\n(\n0≤n≤\n10\n9\n) — the number of fruits Zhan has.\nThe second line of each test case contains two integers\nx\nand\ny\n(\n1≤x,y≤\n10\n9\n) — the number of fruits the blender can blend per second and the number of fruits Zhan can put into the blender per second.\nOutput\nFor each testcase, output a single integer — the minimum number of seconds to blend all fruits.\nExample\ninput\nCopy\n5\n5\n3 4\n3\n1 2\n6\n4 3\n100\n4 3\n9\n3 3\noutput\nCopy\n2\n3\n2\n34\n3\nNote\nIn the first example, you can first put\n2\nfruits in the blender. After that, the blender will mix these\n2\nfruits, and in the end, there will be\n0\nfruits left in the blender. Then you can put\n3\nfruits into the blender, after which the blender will mix these\n3\nfruits.\nIn the second example, you can put\n1\nfruit into the blender\n3\ntimes.\nIn the third example, you can first put\n3\nfruits into the blender, then add another\n3\nfruits.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "I. Stack and Queue",
        "description": "There are\n2\nqueues of patients at the doors of two doctors. The first doctor sees patients in the usual order of the queue — whoever arrived first will be seen first. The second doctor does the opposite — he sees those who arrived last first. Thus, there is a queue for the first doctor and a stack for the second doctor. A patient can be in both the queue and the stack. Each patient is characterized by the time their visit to the doctor will take (the time is the same for both doctors).\nWhen the appointments begin, the doctors will see patients in the order of the queue and stack, respectively. As soon as a doctor finishes with one patient, he will call the next one.\nBut there is one problem: if a patient is in both the queue and the stack, and he is called to one doctor first and then to the other, while he has not yet finished with the first one, confusion will arise. It is allowed for a patient to go to the second doctor at the exact moment he finishes with the first doctor.\nThe current configuration of the queue and stack is called good if the doctors can see all the patients without any confusion arising.\nInitially, both the queue and the stack are empty. There are three types of queries:\nadd patient\nx\nto the queue;\nadd patient\nx\nto the stack;\npatient\nx\n, who was in the queue, realizes he is in the wrong place and moves to the stack; however, he moves to the position in the stack as if he had entered the stack at the moment of the query when he entered the queue.\nIt is guaranteed that after each query, each patient is no more than once in the queue and no more than once in the stack.\nAfter each query, you need to determine if the current configuration is good.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of requests.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — for each patient, the time their visit to the doctor will take.\nEach of the following\nn\nlines contains two integers\nt\nand\nx\n(\n1≤t≤3\n;\n1≤x≤n\n) — the type of query and the patient's index. It is guaranteed that:\nif the query is of type\n1\n, then patient\nx\nis not in the queue yet;\nif the query is of type\n2\n, then patient\nx\nis not in the stack yet;\nif the query is of type\n3\n, then patient\nx\nis in the queue already and not in the stack yet.\nOutput\nAfter each query, print \"YES\", if the current configuration is good, and \"NO\" otherwise.\nExamples\ninput\nCopy\n3\n10 15 4\n1 1\n2 1\n2 2\noutput\nCopy\nYES\nNO\nYES\ninput\nCopy\n7\n2 5 1 5 5 4 8\n1 1\n2 5\n1 2\n2 3\n3 2\n1 2\n3 1\noutput\nCopy\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nNote\nIn the first test, there are the following configurations:\nqueue:\n[1]\n; stack:\n[]\n; patient\n1\nis seen by the first doctor for\n10\nminutes, starting at minute\n0\n.\nqueue:\n[1]\n; stack:\n[1]\n; patient\n1\nis seen by the first doctor during\n[0;10)\nand by the second during\n[0;10)\n. Since patient\n1\nmust be at both doctors at the same time, the answer is \"NO\".\nqueue:\n[1]\n; stack:\n[1,2]\n; patient\n1\nis seen by the first doctor during\n[0;10)\n, and by the second during\n[15;25)\n; patient\n2\nis seen by the second doctor during\n[0,15)\n. Now patient\n1\ncan make it to the second doctor after seeing the first.\nIn the second test, the configuration after query\n4\nis as follows:\nqueue:\n[1,2]\n;\nstack:\n[5,3]\n;\npatient\n1\n: first doctor\n[0,2)\n, second doctor is not seeing him;\npatient\n2\n: first doctor\n[2,7)\n, second doctor is not seeing him;\npatient\n3\n: first doctor is not seeing him, second doctor\n[0,1)\n;\npatient\n5\n: first doctor is not seeing him, second doctor\n[1,6)\n.\nAfter request\n5\n, the next configuration is:\nqueue:\n[1]\n;\nstack:\n[5,2,3]\n;\npatient\n1\n: first doctor\n[0,2)\n, second doctor is not seeing him;\npatient\n2\n: first doctor is not seeing him, second doctor\n[1,6)\n;\npatient\n3\n: first doctor is not seeing him, second doctor\n[0,1)\n;\npatient\n5\n: first doctor is not seeing him, second doctor\n[6,11)\n.\nAfter request\n6\n, the next configuration is:\nqueue:\n[1,2]\n;\nstack:\n[5,2,3]\n;\npatient\n1\n: first doctor\n[0,2)\n, second doctor is not seeing him;\npatient\n2\n: first doctor\n[2,7)\n, second doctor\n[1,6)\n;\npatient\n3\n: first doctor is not seeing him, second doctor\n[0,1)\n;\npatient\n5\n: first doctor is not seeing him, second doctor\n[6,11)\n.\nPatient\n2\nmust be at both doctors at the same time.\nAfter request\n7\n, the next configuration is:\nqueue:\n[2]\n;\nstack:\n[1,5,2,3]\n;\npatient\n1\n: first doctor is not seeing him, second doctor\n[11,13)\n;\npatient\n2\n: first doctor\n[0,5)\n, second doctor\n[1,6)\n;\npatient\n3\n: first doctor is not seeing him, second doctor\n[0,1)\n;\npatient\n5\n: first doctor is not seeing him, second doctor\n[6,11)\n.\nPatient\n2\nmust be at both doctors at the same time.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "data structures",
            "divide and conquer"
        ]
    },
    {
        "title": "H. Strange Matrix",
        "description": "You are given a matrix\na\nof size\nn×m\n, consisting of integers from\n0\nto\n31\ninclusive.\nLet's call the matrix strange if for every two distinct rows\ni\nand\nj\n, both of the following conditions hold:\nfor every set of\nk\nindices\n(\nx\n1\n,\nx\n2\n,…,\nx\nk\n)\n, where\n1≤\nx\n1\n<\nx\n2\n<⋯<\nx\nk\n≤m\n, the equality\na\ni,\nx\n1\n&\na\nj,\nx\n1\n&\na\ni,\nx\n2\n&\na\nj,\nx\n2\n&⋯&\na\ni,\nx\nk\n&\na\nj,\nx\nk\n=0\nholds (where\n&\n — bitwise AND of two numbers);\nfor every set of\nk\nindices\n(\nx\n1\n,\nx\n2\n,…,\nx\nk\n)\n, where\n1≤\nx\n1\n<\nx\n2\n<⋯<\nx\nk\n≤m\n, the equality\na\ni,\nx\n1\n|\na\nj,\nx\n1\n|\na\ni,\nx\n2\n|\na\nj,\nx\n2\n|⋯|\na\ni,\nx\nk\n|\na\nj,\nx\nk\n=31\nholds (where\n|\n — bitwise OR of two numbers).\nYou can perform the following operation any number of times: take any row of the matrix and a number\ny\nfrom\n0\nto\n31\ninclusive; then apply the bitwise XOR with the number\ny\nto all elements of the selected row. The cost of such an operation is equal to\ny\n.\nYour task is to calculate the minimum cost to make the matrix strange, or report that it is impossible.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤50\n;\n1≤k≤m\n).\nNext, there are\nn\nlines, the\ni\n-th of which contains\nm\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n0≤\na\ni,j\n≤31\n).\nOutput\nFor each test case, output one integer — the minimum cost to make the matrix strange, or -1 if it is impossible to make the matrix strange.\nExample\ninput\nCopy\n3\n2 3 1\n0 1 0\n1 0 1\n3 2 2\n0 1\n2 3\n4 5\n5 5 5\n0 5 17 4 22\n8 5 16 21 9\n7 25 31 30 8\n0 0 5 15 13\n1 2 3 4 5\noutput\nCopy\n30\n-1\n24",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "graphs",
            "greedy"
        ]
    },
    {
        "title": "G. Removal of a Permutation",
        "description": "You are given a permutation\np\nof length\nn\n.\nYou can perform operations of two types:\nmark all positions\ni\nsuch that\n1≤i<n\nand\np\ni\n<\np\ni+1\n, and simultaneously remove the elements at these positions;\nmark all positions\ni\nsuch that\n2≤i≤n\nand\np\ni−1\n>\np\ni\n, and simultaneously remove the elements at these positions.\nFor each integer from\n1\nto\n(n−1)\n, calculate the minimum number of operations required to remove that integer from the permutation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤250000\n).\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n). The array\np\nis a permutation.\nAdditional constraints on the input: the sum of\nn\nover all test cases does not exceed\n250000\n.\nOutput\nFor each test case, print\n(n−1)\nintegers. The\ni\n-th of them should be equal to the minimum number of operations required to remove\ni\nfrom the permutation.\nExample\ninput\nCopy\n5\n4\n4 2 1 3\n2\n1 2\n6\n5 4 1 3 2 6\n7\n5 6 1 3 7 2 4\n5\n3 1 2 5 4\noutput\nCopy\n1 1 2\n1\n1 1 2 1 3\n1 1 1 2 1 2\n1 1 2 1",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "F. Good Subarray",
        "description": "You are given an integer array\na\nof size\nn\n.\nLet's call an array good if it can be obtained using the following algorithm: create an array consisting of any single integer; and then perform the following operation an arbitrary number of times: choose an element from the already existing array (let's call it\nx\n) and add\nx\n,\n(x−1)\n, or\n(x+1)\nto the end of the array.\nFor example, the arrays\n[1,2,1]\n,\n[5]\nand\n[3,2,1,4]\nare good, while\n[2,4]\nand\n[3,1,2]\nare not.\nYour task is to count the number of good contiguous subarrays of the array\na\n. Two subarrays that have the same elements but are in different positions of the array\na\nare considered different.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n)\n.\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the number of good contiguous subarrays of the array\na\n.\nExample\ninput\nCopy\n4\n3\n1 1 3\n4\n3 2 3 1\n1\n1\n8\n4 5 6 5 3 2 3 1\noutput\nCopy\n4\n9\n1\n23\nNote\nIn the first example, the following four subarrays are good:\nfrom the\n1\n-st to the\n1\n-st element;\nfrom the\n1\n-st to the\n2\n-nd element;\nfrom the\n2\n-nd to the\n2\n-nd element;\nfrom the\n3\n-rd to the\n3\n-rd element.\nIn the second example, the only subarray which is not good is the subarray from the\n3\n-rd element to the\n4\n-th element.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "data structures",
            "greedy"
        ]
    },
    {
        "title": "E. Rock-Paper-Scissors Bot",
        "description": "Rock-Paper-Scissors is a game for two players. It is played in rounds. During each round, every player chooses one of three moves: Rock, Paper, or Scissors. Depending on the chosen moves, the following happens:\nif one player chooses Rock and the other player chooses Paper, the player who chooses Paper wins and gets a point;\nif one player chooses Scissors and the other player chooses Paper, the player who chooses Scissors wins and gets a point;\nif one player chooses Scissors and the other player chooses Rock, the player who chooses Rock wins and gets a point;\nand if both players choose the same move, nobody wins and nobody gets a point.\nMonocarp decided to play against a bot. During the game, Monocarp noticed that the bot's behavior is very predictable:\nin the first round, it chooses Rock;\nin every round except the first, it chooses the move that beats the opponent's move in the previous round (for example, if in the previous round its opponent played Scissors, then the bot chooses Rock now).\nMonocarp has a favorite string\ns\n, consisting of the characters R, P, and/or S. Monocarp decided to play a series of rounds against the bot. However, he wants both of the following conditions to be met:\nthe final score is in favor of Monocarp (i. e., the number of rounds he won is strictly greater than the number of rounds the bot won);\nthe string\ns\nappears as a contiguous substring in the sequence of the bot's moves (where R denotes Rock, P denotes Paper, and S denotes Scissors).\nHelp Monocarp and calculate the minimum number of rounds he needs to play against the bot to satisfy both of the aforementioned conditions.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a string\ns\n(\n1≤|s|≤2⋅\n10\n5\n), consisting of the characters R, P, and/or S.\nAdditional constraint on the input: the sum of the lengths of the strings\ns\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum number of rounds Monocarp needs to play against the bot to satisfy both of the aforementioned conditions.\nExample\ninput\nCopy\n7\nSS\nR\nRPS\nRPPP\nSPPRSP\nPPP\nPR\noutput\nCopy\n3\n1\n3\n6\n7\n5\n3\nNote\nIn the first example, Monocarp can play PPR, then the bot's moves are RSS, and the score is\n2:1\nin favor of Monocarp.\nIn the second example, Monocarp can play P, then the bot's moves are R, and the score is\n1:0\nin favor of Monocarp.\nIn the third example, Monocarp can play RPR, then the bot's moves are RPS, and the score is\n1:0\nin favor of Monocarp.\nIn the fourth example, Monocarp can play RRRSPR, then the bot's moves are RPPPRS, and the score is\n3:2\nin favor of Monocarp.\nIn the fifth example, Monocarp can play PRRSPRS, then the bot's moves are RSPPRSP, and the score is\n6:1\nin favor of Monocarp.\nIn the sixth example, Monocarp can play PRRRS, then the bot's moves are RSPPP, and the score is\n3:2\nin favor of Monocarp.\nIn the seventh example, Monocarp can play RSR, then the bot's moves are RPR, and the score is\n1:0\nin favor of Monocarp.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "greedy",
            "strings"
        ]
    },
    {
        "title": "D. Among Wolves",
        "description": "In a game you started playing recently, there is a field that can be represented as a rectangular grid. The field has\n2\nrows and\nn\ncolumns —\n2n\ncells in total.\nSome cells are empty, but some are occupied by wolves. In the beginning of the game, you have one sheep in some cell, and you'd like to save it from wolves.\nWolves will attack you at night, so you still have some time for preparation. You have two ways to deal with wolves:\nYou pay\nh\ncoins to hunters and choose a cell occupied by a wolf. Hunters will clear the cell, eradicating the wolf in it.\nYou pay\nb\ncoins to builders and choose an empty cell. Builders will dig a trench in the chosen cell that wolves can't cross.\nYou can use both methods mentioned above any number of times and in any order.\nLet's say that a wolf can reach the sheep if there is a path that starts at the wolf's cell and finishes at the sheep's cell. This path shouldn't contain any cells with trenches, and each two consecutive cells in the path should be neighbors (share a side).\nWhat is the minimum total amount of money you should pay to ensure that none of the wolves can reach the sheep?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1200\n) — the number of test cases. Next,\nt\nindependent cases follow.\nThe first line of each test case contains three integers\nn\n,\nh\n, and\nb\n(\n2≤n≤2⋅\n10\n5\n;\n1≤h,b≤\n10\n9\n) — the size of the grid and corresponding costs.\nThe next two lines contain a description of the grid. The\nj\n-th character in the\ni\n-th line is either '.', 'S' or 'W':\n'.' means that the cell is empty;\n'S' means that the cell is occupied by the sheep; there is exactly one such cell on the grid;\n'W' means that the cell is occupied by a wolf.\nAdditional constraints:\nthere are no wolves in cells neighboring the sheep cell;\nthe sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum total amount of money you should pay to save your sheep.\nExamples\ninput\nCopy\n4\n2 3 7\nS.\n..\n2 3 7\nS.\n.W\n2 7 3\nS.\n.W\n4 999999999 1000000000\nW.S.\nW..W\noutput\nCopy\n0\n3\n6\n2999999997\ninput\nCopy\n2\n6 6 7\nW....W\nW.S..W\n6 6 7\nW...WW\n..S..W\noutput\nCopy\n21\n20\nNote\nOne of the optimal strategies in the first test case of the second test can be shown like this:\nW....W\n⇒\nW.#..W\nW.S..W W#S#.W\nAnalogically, one of the answers for the second case is the following:\nW...WW\n⇒\nW..#WW\n..S..W ..S#.W\nHere, '#' means a trench and 'W' means an eradicated wolf.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "C. Split the Expression",
        "description": "You are given a string\ns\nof the form <block of digits>+<block of digits>+...+<block of digits>. Every block of digits consists of at least\n2\nand at most\n13\ndigits; every digit is from\n1\nto\n9\n.\nYou have to split this string into expressions of the form <integer>+<integer>. Every expression must be a contiguous part of the given string, and every character of the given string must belong to exactly one expression. For example, if you have a string 123+456+789+555, then:\nyou are allowed to split it into 123+4, 56+7 and 89+555;\nyou are not allowed to split it into 123+456 and +789+555, since the second part begins with a + sign;\nyou are not allowed to split it into 123+4, 56+7, 8 and 9+555, since the third part does not contain a + sign;\nyou are not allowed to split it into 123+456+78 and 9+555, since the first part contains two + signs.\nAmong all allowed ways to split the string, find one which maximizes the sum of results of all expressions you get, and print this sum.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nEach test case consists of one line containing the string\ns\n(\n5≤|s|≤1000\n) of the form <block of digits>+<block of digits>+...+<block of digits>. The string contains at least one '+' sign. Every block of digits consists of at least\n2\nand at most\n13\ndigits; every digit is from\n1\nto\n9\n.\nOutput\nFor each test case, print one integer — the maximum possible sum of results of all expressions you get after splitting the string.\nExample\ninput\nCopy\n3\n123+456+789+555\n13+37\n9999999999999+1111111111111+9999999999999\noutput\nCopy\n834\n50\n20111111111110\nNote\nIn the first test case of the example, you should split the string into expressions 123+4, 56+7 and 89+555. The sum of results of these expressions is\n834\n.\nIn the second test case of the example, the given string is already a valid expression and cannot be split any further.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "B. Shuffle",
        "description": "Yes, this is another one of those constructive permutation problems.\nYou are given an integer\nn\n. You have to construct a permutation\np\nof size\nn\n, i. e. an array of\nn\nintegers, where every integer from\n1\nto\nn\nappears exactly once.\nEvery pair of adjacent elements in the permutation (\np\ni\nand\np\ni+1\n) must meet the following condition:\nif one of them is divisible by the other, the condition\np\ni\n<\np\ni+1\nmust hold;\notherwise, the condition\np\ni\n>\np\ni+1\nmust hold.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤99\n) — the number of test cases.\nEach test case consists of one line, containing one integer\nn\n(\n2≤n≤100\n).\nOutput\nFor each test case, print the answer as follows:\nif no permutation of size\nn\nmeeting the conditions from the statement exists, print\n−1\n;\notherwise, print\nn\ndistinct integers from\n1\nto\nn\n— the required permutation. If there are mutliple answers, print any of them.\nExample\ninput\nCopy\n2\n5\n10\noutput\nCopy\n1 5 2 4 3\n1 2 10 9 7 4 8 3 6 5",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "A. Problem Solving",
        "description": "Jane has decided to solve a list of\nn\nproblems on Codeforces. The\ni\n-th problem in her list has difficulty\nd\ni\n, and the last problem in the list is the hardest one (for every problem\nj<n\n,\nd\nj\n<\nd\nn\n).\nJane's problem-solving skill is some integer\nx\n(unknown to you). If a problem's difficulty is greater than\nx\n, then Jane cannot solve it, otherwise she can solve it.\nJane has solved all problems form the list, except for the last one — she found out that it was too difficult for her. Can you uniquely determine the value of\nx\n— Jane's problem solving skill?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n2≤n≤50\n) — the number of problems;\nthe second line contains\nn\nintegers\nd\n1\n,\nd\n2\n,…,\nd\nn\n(\n1≤\nd\ni\n≤50\n).\nAdditional constraint on the input: in every test case, the last problem is more difficult than every other problem (i. e.\nd\nn\n>\nd\nj\nfor every\nj<n\n). This means that at least one possible value of\nx\nexists.\nOutput\nFor each test case, print one line:\nif you can determine the value of\nx\nuniquely, print\nx\n;\notherwise, print Ambiguous. The checking program is case-sensitive, so if you print ambiguous or AMBIGUOUS, your answer will be considered wrong.\nExample\ninput\nCopy\n3\n5\n1 2 3 4 5\n8\n8 8 5 3 4 6 8 12\n4\n3 3 3 4\noutput\nCopy\n4\nAmbiguous\n3\nNote\nIn the second test case of the example, the value of\nx\ncould be\n11\n, but it also could be\n10\n(other possible values for\nx\nalso exist).",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "C2. Message Transmission Error (hard version)",
        "description": "This is a more difficult version of the problem. It differs from the easy one only by the constraints.\nAt the Berland State University, the local network between servers does not always operate without errors. When transmitting two identical messages consecutively, an error may occur, resulting in the two messages merging into one. In this merging, the end of the first message coincides with the beginning of the second. Of course, the merging can only occur at identical characters. The length of the merging must be a positive number less than the length of the message text.\nFor example, when transmitting two messages \"abrakadabra\" consecutively, it is possible that it will be transmitted with the described type of error, resulting in a message like \"abrakadabrabrakadabra\" or \"abrakadabrakadabra' (in the first case, the merging occurred at one character, and in the second case, at four).\nGiven the received message t, determine if it is possible that this is the result of an error of the described type in the operation of the local network, and if so, determine a possible value of s.\nA situation where two messages completely overlap each other should not be considered an error. For example, if the received message is \"abcd\", it should be considered that there is no error in it. Similarly, simply appending one message after another is not a sign of an error. For instance, if the received message is \"abcabc\", it should also be considered that there is no error in it.\nInput\nThe input consists of a single non-empty string t, consisting of lowercase letters of the Latin alphabet. The length of the string t does not exceed 4·105 characters.\nOutput\nIf the message t cannot contain an error, output \"NO\" (without quotes) in a single line of output.\nOtherwise, in the first line, output \"YES\" (without quotes), and in the next line, output the string s — a possible message that could have led to the error. If there are multiple possible answers, any of them is acceptable.\nExamples\ninput\nCopy\nabrakadabrabrakadabra\noutput\nCopy\nYES\nabrakadabra\ninput\nCopy\nacacacaca\noutput\nCopy\nYES\nacacaca\ninput\nCopy\nabcabc\noutput\nCopy\nNO\ninput\nCopy\nabababab\noutput\nCopy\nYES\nababab\ninput\nCopy\ntatbt\noutput\nCopy\nNO\nNote\nIn the second example, a suitable answer could also be the string \"acacaca\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "hashing",
            "string suffix structures",
            "strings",
            "two pointers",
            "*1700"
        ]
    },
    {
        "title": "C1. Message Transmission Error (easy version)",
        "description": "This is a simplified version of the problem. It differs from the difficult one only in its constraints.\nAt the Berland State University, the local network between servers does not always operate without errors. When transmitting two identical messages consecutively, an error may occur, resulting in the two messages merging into one. In this merging, the end of the first message coincides with the beginning of the second. Of course, the merging can only occur at identical characters. The length of the merging must be a positive number less than the length of the message text.\nFor example, when transmitting two messages \"abrakadabra\" consecutively, it is possible that it will be transmitted with the described type of error, resulting in a message like \"abrakadabrabrakadabra\" or \"abrakadabrakadabra' (in the first case, the merging occurred at one character, and in the second case, at four).\nGiven the received message t, determine if it is possible that this is the result of an error of the described type in the operation of the local network, and if so, determine a possible value of s.\nA situation where two messages completely overlap each other should not be considered an error. For example, if the received message is \"abcd\", it should be considered that there is no error in it. Similarly, simply appending one message after another is not a sign of an error. For instance, if the received message is \"abcabc\", it should also be considered that there is no error in it.\nInput\nThe input consists of a single non-empty string t, consisting of lowercase letters of the Latin alphabet. The length of the string t does not exceed 100 characters.\nOutput\nIf the message t cannot contain an error, output \"NO\" (without quotes) in a single line of output.\nOtherwise, in the first line, output \"YES\" (without quotes), and in the next line, output the string s — a possible message that could have led to the error. If there are multiple possible answers, any of them is acceptable.\nExamples\ninput\nCopy\nabrakadabrabrakadabra\noutput\nCopy\nYES\nabrakadabra\ninput\nCopy\nacacacaca\noutput\nCopy\nYES\nacaca\ninput\nCopy\nabcabc\noutput\nCopy\nNO\ninput\nCopy\nabababab\noutput\nCopy\nYES\nababab\ninput\nCopy\ntatbt\noutput\nCopy\nNO\nNote\nIn the second example, a suitable answer could also be the string \"acacaca\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "*1400"
        ]
    },
    {
        "title": "B. Three Brothers",
        "description": "Three brothers agreed to meet. Let's number the brothers as follows: the oldest brother is number 1, the middle brother is number 2, and the youngest brother is number 3.\nWhen it was time for the meeting, one of the brothers was late. Given the numbers of the two brothers who arrived on time, you need to determine the number of the brother who was late.\nInput\nThe first line of input contains two different integers a and b (1 ≤ a, b ≤ 3, a ≠ b) — the numbers of the brothers who arrived on time. The numbers are given in arbitrary order.\nOutput\nOutput a single integer — the number of the brother who was late to the meeting.\nExample\ninput\nCopy\n3 1\noutput\nCopy\n2",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "A. Alternating Sum of Numbers",
        "description": "You are given a sequence of integers. Output the alternating sum of this sequence. In other words, output\na\n1\n−\na\n2\n+\na\n3\n−\na\n4\n+\na\n5\n−…\n. That is, the signs of plus and minus alternate, starting with a plus.\nInput\nThe first line of the test contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then follow\nt\ntest cases.\nThe first line of each test case contains one integer\nn\n(\n1≤n≤50\n) — the length of the sequence. The second line of the test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n).\nOutput\nOutput\nt\nlines. For each test case, output the required alternating sum of the numbers.\nExample\ninput\nCopy\n4\n4\n1 2 3 17\n1\n100\n2\n100 100\n5\n3 1 4 1 5\noutput\nCopy\n-15\n100\n0\n10",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "G3. Yunli's Subarray Queries (extreme version)",
        "description": "This is the extreme version of the problem. In this version, the output of each query is different from the easy and hard versions. It is also guaranteed that\nr≥l+k−1\nfor all queries.\nFor an arbitrary array\nb\n, Yunli can perform the following operation any number of times:\nSelect an index\ni\n. Set\nb\ni\n=x\nwhere\nx\nis any integer she desires (\nx\nis not limited to the interval\n[1,n]\n).\nDenote\nf(b)\nas the minimum number of operations she needs to perform until there exists a consecutive subarray\n∗\nof length at least\nk\nin\nb\n.\nYunli is given an array\na\nof size\nn\nand asks you\nq\nqueries. In each query, you must output\n∑\nr−k+1\ni=l\n∑\nr\nj=i+k−1\nf([\na\ni\n,\na\ni+1\n,…,\na\nj\n])\n.\n∗\nIf there exists a consecutive subarray of length\nk\nthat starts at index\ni\n(\n1≤i≤|b|−k+1\n), then\nb\nj\n=\nb\nj−1\n+1\nfor all\ni<j≤i+k−1\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nk\n, and\nq\n(\n1≤k≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) — the length of the array, the length of the consecutive subarray, and the number of queries.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,...,\na\nn\n(\n1≤\na\ni\n≤n\n).\nThe following\nq\nlines contain two integers\nl\nand\nr\n(\n1≤l≤r≤n\n,\nr≥l+k−1\n) — the bounds of the query.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nand the sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput\n∑\nr−k+1\ni=l\n∑\nr\nj=i+k−1\nf([\na\ni\n,\na\ni+1\n,…,\na\nj\n])\nfor each query on a new line.\nExample\ninput\nCopy\n5\n7 2 4\n1 2 3 2 1 2 3\n4 6\n1 7\n2 7\n3 7\n8 4 2\n4 3 1 1 2 4 3 2\n3 6\n1 5\n5 4 2\n4 5 1 2 3\n1 4\n1 5\n10 4 8\n2 3 6 5 8 9 8 10 10 1\n2 7\n6 10\n1 9\n1 6\n3 9\n4 10\n2 10\n1 8\n10 7 4\n3 4 5 3 4 5 9 10 8 9\n1 9\n2 10\n1 10\n2 9\noutput\nCopy\n1\n3\n3\n3\n2\n7\n2\n4\n8\n6\n28\n7\n16\n20\n32\n19\n18\n15\n26\n9\nNote\nIn the first query of the first testcase, we can calculate the answer for the query through the following:\ni=4\nand\nj=5\n:\nf([2,1])=1\nbecause Yunli can set\nb\n2\n=3\n, making a consecutive subarray of size\n2\nin\n1\nmove.\ni=4\nand\nj=6\n:\nf([2,1,2])=0\nbecause there is already a consecutive array of size\n2\n.\ni=5\nand\nj=6\n:\nf([1,2])=0\nbecause there is already a consecutive array of size\n2\n.\nThe answer to this query is\n1+0+0=1\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "*2700"
        ]
    },
    {
        "title": "G2. Yunli's Subarray Queries (hard version)",
        "description": "This is the hard version of the problem. In this version, it is guaranteed that\nr≥l+k−1\nfor all queries.\nFor an arbitrary array\nb\n, Yunli can perform the following operation any number of times:\nSelect an index\ni\n. Set\nb\ni\n=x\nwhere\nx\nis any integer she desires (\nx\nis not limited to the interval\n[1,n]\n).\nDenote\nf(b)\nas the minimum number of operations she needs to perform until there exists a consecutive subarray\n∗\nof length at least\nk\nin\nb\n.\nYunli is given an array\na\nof size\nn\nand asks you\nq\nqueries. In each query, you must output\n∑\nr\nj=l+k−1\nf([\na\nl\n,\na\nl+1\n,…,\na\nj\n])\n.\n∗\nIf there exists a consecutive subarray of length\nk\nthat starts at index\ni\n(\n1≤i≤|b|−k+1\n), then\nb\nj\n=\nb\nj−1\n+1\nfor all\ni<j≤i+k−1\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nk\n, and\nq\n(\n1≤k≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) — the length of the array, the length of the consecutive subarray, and the number of queries.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,...,\na\nn\n(\n1≤\na\ni\n≤n\n).\nThe following\nq\nlines contain two integers\nl\nand\nr\n(\n1≤l≤r≤n\n,\nr≥l+k−1\n) — the bounds of the query.\nIt is guaranteed the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nand the sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput\n∑\nr\nj=l+k−1\nf([\na\nl\n,\na\nl+1\n,…,\na\nj\n])\nfor each query on a new line.\nExample\ninput\nCopy\n3\n7 5 3\n1 2 3 2 1 2 3\n1 7\n2 7\n3 7\n8 4 2\n4 3 1 1 2 4 3 2\n3 6\n1 5\n5 4 2\n4 5 1 2 3\n1 4\n1 5\noutput\nCopy\n6\n5\n2\n2\n5\n2\n3\nNote\nIn the second query of the first testcase, we calculate the following function values:\nf([2,3,2,1,2])=3\nbecause Yunli can set\nb\n3\n=4\n,\nb\n4\n=5\n, and\nb\n5\n=6\n, making a consecutive subarray of size\n5\nin\n3\nmoves.\nf([2,3,2,1,2,3])=2\nbecause we can set\nb\n3\n=0\nand\nb\n2\n=−1\n, making a consecutive subarray of size\n5\nin\n2\nmoves (starting at position\n2\n)\nThe answer to this query is\n3+2=5\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "*2200"
        ]
    },
    {
        "title": "G1. Yunli's Subarray Queries (easy version)",
        "description": "This is the easy version of the problem. In this version, it is guaranteed that\nr=l+k−1\nfor all queries.\nFor an arbitrary array\nb\n, Yunli can perform the following operation any number of times:\nSelect an index\ni\n. Set\nb\ni\n=x\nwhere\nx\nis any integer she desires (\nx\nis not limited to the interval\n[1,n]\n).\nDenote\nf(b)\nas the minimum number of operations she needs to perform until there exists a consecutive subarray\n∗\nof length at least\nk\nin\nb\n.\nYunli is given an array\na\nof size\nn\nand asks you\nq\nqueries. In each query, you must output\n∑\nr\nj=l+k−1\nf([\na\nl\n,\na\nl+1\n,…,\na\nj\n])\n. Note that in this version, you are only required to output\nf([\na\nl\n,\na\nl+1\n,…,\na\nl+k−1\n])\n.\n∗\nIf there exists a consecutive subarray of length\nk\nthat starts at index\ni\n(\n1≤i≤|b|−k+1\n), then\nb\nj\n=\nb\nj−1\n+1\nfor all\ni<j≤i+k−1\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nk\n, and\nq\n(\n1≤k≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) — the length of the array, the length of the consecutive subarray, and the number of queries.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nThe following\nq\nlines contain two integers\nl\nand\nr\n(\n1≤l≤r≤n\n,\nr=l+k−1\n) — the bounds of the query.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nand the sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput\n∑\nr\nj=l+k−1\nf([\na\nl\n,\na\nl+1\n,…,\na\nj\n])\nfor each query on a new line.\nExample\ninput\nCopy\n3\n7 5 3\n1 2 3 2 1 2 3\n1 5\n2 6\n3 7\n8 4 2\n4 3 1 1 2 4 3 2\n3 6\n2 5\n5 4 2\n4 5 1 2 3\n1 4\n2 5\noutput\nCopy\n2\n3\n2\n2\n2\n2\n1\nNote\nIn the first query of the first testcase,\nb=[1,2,3,2,1]\n. Yunli can make a consecutive subarray of length\n5\nin\n2\nmoves:\nSet\nb\n4\n=4\nSet\nb\n5\n=5\nAfter operations\nb=[1,2,3,4,5]\n.\nIn the second query of the first testcase,\nb=[2,3,2,1,2]\n. Yunli can make a consecutive subarray of length\n5\nin\n3\nmoves:\nSet\nb\n3\n=0\nSet\nb\n2\n=−1\nSet\nb\n1\n=−2\nAfter operations\nb=[−2,−1,0,1,2]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "F. Firefly's Queries",
        "description": "Firefly is given an array\na\nof length\nn\n. Let\nc\ni\ndenote the\ni\n'th cyclic shift\n∗\nof\na\n. She creates a new array\nb\nsuch that\nb=\nc\n1\n+\nc\n2\n+⋯+\nc\nn\nwhere\n+\nrepresents concatenation\n†\n†\n.\nThen, she asks you\nq\nqueries. For each query, output the sum of all elements in the subarray of\nb\nthat starts from the\nl\n-th element and ends at the\nr\n-th element, inclusive of both ends.\n∗\nThe\nx\n-th (\n1≤x≤n\n) cyclic shift of the array\na\nis\na\nx\n,\na\nx+1\n…\na\nn\n,\na\n1\n,\na\n2\n…\na\nx−1\n. Note that the\n1\n-st shift is the initial\na\n.\n†\n†\nThe concatenation of two arrays\np\nand\nq\nof length\nn\n(in other words,\np+q\n) is\np\n1\n,\np\n2\n,...,\np\nn\n,\nq\n1\n,\nq\n2\n,...,\nq\nn\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the length of the array and the number of queries.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,...,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n).\nThe following\nq\nlines contain two integers\nl\nand\nr\n(\n1≤l≤r≤\nn\n2\n) — the left and right bounds of the query.\nNote that the large inputs may require the use of 64-bit integers.\nIt is guaranteed that the sum of\nn\ndoes not exceed\n2⋅\n10\n5\nand the sum of\nq\ndoes not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output the answer on a new line.\nExample\ninput\nCopy\n5\n3 3\n1 2 3\n1 9\n3 5\n8 8\n5 5\n4 8 3 2 4\n1 14\n3 7\n7 10\n2 11\n1 25\n1 1\n6\n1 1\n5 7\n3 1 6 10 4\n3 21\n6 17\n2 2\n1 5\n1 14\n9 15\n12 13\n5 3\n4 9 10 10 1\n20 25\n3 11\n20 22\noutput\nCopy\n18\n8\n1\n55\n20\n13\n41\n105\n6\n96\n62\n1\n24\n71\n31\n14\n44\n65\n15\nNote\nFor the first test case,\nb=[1,2,3,2,3,1,3,1,2]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "data structures",
            "flows",
            "math",
            "*1700"
        ]
    },
    {
        "title": "E. Klee's SUPER DUPER LARGE Array!!!",
        "description": "Klee has an array\na\nof length\nn\ncontaining integers\n[k,k+1,...,k+n−1]\nin that order. Klee wants to choose an index\ni\n(\n1≤i≤n\n) such that\nx=|\na\n1\n+\na\n2\n+⋯+\na\ni\n−\na\ni+1\n−⋯−\na\nn\n|\nis minimized. Note that for an arbitrary integer\nz\n,\n|z|\nrepresents the absolute value of\nz\n.\nOutput the minimum possible value of\nx\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains two integers\nn\nand\nk\n(\n2≤n,k≤\n10\n9\n) — the length of the array and the starting element of the array.\nOutput\nFor each test case, output the minimum value of\nx\non a new line.\nExample\ninput\nCopy\n4\n2 2\n7 2\n5 3\n1000000000 1000000000\noutput\nCopy\n1\n5\n1\n347369930\nNote\nIn the first sample,\na=[2,3]\n. When\ni=1\nis chosen,\nx=|2−3|=1\n. It can be shown this is the minimum possible value of\nx\n.\nIn the third sample,\na=[3,4,5,6,7]\n. When\ni=3\nis chosen,\nx=|3+4+5−6−7|=1\n. It can be shown this is the minimum possible value of\nx\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math",
            "ternary search",
            "*1400"
        ]
    },
    {
        "title": "D. Satyam and Counting",
        "description": "Satyam is given\nn\ndistinct points on the 2D coordinate plane. It is guaranteed that\n0≤\ny\ni\n≤1\nfor all given points\n(\nx\ni\n,\ny\ni\n)\n. How many different nondegenerate right triangles\n∗\ncan be formed from choosing three different points as its vertices?\nTwo triangles\na\nand\nb\nare different if there is a point\nv\nsuch that\nv\nis a vertex of\na\nbut not a vertex of\nb\n.\n∗\nA nondegenerate right triangle has positive area and an interior\n90\n∘\nangle.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n3≤n≤2⋅\n10\n5\n) — the number of points.\nThe following\nn\nlines contain two integers\nx\ni\nand\ny\ni\n(\n0≤\nx\ni\n≤n\n,\n0≤\ny\ni\n≤1\n) — the\ni\n'th point that Satyam can choose from. It is guaranteed that all\n(\nx\ni\n,\ny\ni\n)\nare pairwise distinct.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput an integer for each test case, the number of distinct nondegenerate right triangles that can be formed from choosing three points.\nExample\ninput\nCopy\n3\n5\n1 0\n1 1\n3 0\n5 0\n2 1\n3\n0 0\n1 0\n3 0\n9\n1 0\n2 0\n3 0\n4 0\n5 0\n2 1\n7 1\n8 1\n9 1\noutput\nCopy\n4\n0\n8\nNote\nThe four triangles in question for the first test case:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "math",
            "*1400"
        ]
    },
    {
        "title": "C. The Legend of Freya the Frog",
        "description": "Freya the Frog is traveling on the 2D coordinate plane. She is currently at point\n(0,0)\nand wants to go to point\n(x,y)\n. In one move, she chooses an integer\nd\nsuch that\n0≤d≤k\nand jumps\nd\nspots forward in the direction she is facing.\nInitially, she is facing the positive\nx\ndirection. After every move, she will alternate between facing the positive\nx\ndirection and the positive\ny\ndirection (i.e., she will face the positive\ny\ndirection on her second move, the positive\nx\ndirection on her third move, and so on).\nWhat is the minimum amount of moves she must perform to land on point\n(x,y)\n?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains three integers\nx\n,\ny\n, and\nk\n(\n0≤x,y≤\n10\n9\n,1≤k≤\n10\n9\n).\nOutput\nFor each test case, output the number of jumps Freya needs to make on a new line.\nExample\ninput\nCopy\n3\n9 11 3\n0 10 8\n1000000 100000 10\noutput\nCopy\n8\n4\n199999\nNote\nIn the first sample, one optimal set of moves is if Freya jumps in the following way: (\n0,0\n)\n→\n(\n2,0\n)\n→\n(\n2,2\n)\n→\n(\n3,2\n)\n→\n(\n3,5\n)\n→\n(\n6,5\n)\n→\n(\n6,8\n)\n→\n(\n9,8\n)\n→\n(\n9,11\n). This takes 8 jumps.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ]
    },
    {
        "title": "B. osu!mania",
        "description": "You are playing your favorite rhythm game, osu!mania. The layout of your beatmap consists of\nn\nrows and\n4\ncolumns. Because notes at the bottom are closer, you will process the bottommost row first and the topmost row last. Each row will contain exactly one note, represented as a '#'.\nFor each note\n1,2,…,n\n, in the order of processing, output the column in which the note appears.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n) — the number of test cases.\nFor each test case, the first line contains\nn\n(\n1≤n≤500\n) — the number of rows of the beatmap.\nThe following\nn\nlines contain\n4\ncharacters. The\ni\n-th line represents the\ni\n-th row of the beatmap from the top. It is guaranteed that the characters are either '.' or '#', and exactly one of the characters is '#'.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, output\nn\nintegers on a new line, the column that the\ni\n-th note appears in for all\ni\nfrom\n1\nto\nn\n.\nExample\ninput\nCopy\n3\n4\n#...\n.#..\n..#.\n...#\n2\n.#..\n.#..\n1\n...#\noutput\nCopy\n4 3 2 1 \n2 2 \n4 ",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Minimize!",
        "description": "You are given two integers\na\nand\nb\n(\na≤b\n). Over all possible integer values of\nc\n(\na≤c≤b\n), find the minimum value of\n(c−a)+(b−c)\n.\nInput\nThe first line contains\nt\n(\n1≤t≤55\n) — the number of test cases.\nEach test case contains two integers\na\nand\nb\n(\n1≤a≤b≤10\n).\nOutput\nFor each test case, output the minimum possible value of\n(c−a)+(b−c)\non a new line.\nExample\ninput\nCopy\n3\n1 2\n3 10\n5 5\noutput\nCopy\n1\n7\n0\nNote\nIn the first test case, you can choose\nc=1\nand obtain an answer of\n(1−1)+(2−1)=1\n. It can be shown this is the minimum value possible.\nIn the second test case, you can choose\nc=6\nand obtain an answer of\n(6−3)+(10−6)=7\n. It can be shown this is the minimum value possible.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*800"
        ]
    },
    {
        "title": "H. Sakurako's Test",
        "description": "Sakurako will soon take a test. The test can be described as an array of integers\nn\nand a task on it:\nGiven an integer\nx\n, Sakurako can perform the following operation any number of times:\nChoose an integer\ni\n(\n1≤i≤n\n) such that\na\ni\n≥x\n;\nChange the value of\na\ni\nto\na\ni\n−x\n.\nUsing this operation any number of times, she must find the minimum possible median\n∗\nof the array\na\n.\nSakurako knows the array but does not know the integer\nx\n. Someone let it slip that one of the\nq\nvalues of\nx\nwill be in the next test, so Sakurako is asking you what the answer is for each such\nx\n.\n∗\nThe median of an array of length\nn\nis the element that stands in the middle of the sorted array (at the\nn+2\n2\n-th position for even\nn\n, and at the\nn+1\n2\n-th for odd)\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤\n10\n5\n)  — the number of elements in the array and the number of queries.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n)  — the elements of the array.\nThe following\nq\nlines each contain one integer\nx\n(\n1≤x≤n\n).\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n10\n5\n. The same guarantee applies to the sum of\nq\nacross all test cases.\nOutput\nFor each test case, output\nq\nintegers  — the answer for each query.\nExample\ninput\nCopy\n2\n5 5\n1 2 3 4 5\n1\n2\n3\n4\n5\n6 3\n1 2 6 4 1 3\n2\n1\n5\noutput\nCopy\n0 1 1 1 2 \n1 0 2 ",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*2100"
        ]
    },
    {
        "title": "G. Sakurako's Task",
        "description": "Sakurako has prepared a task for you:\nShe gives you an array of\nn\nintegers and allows you to choose\ni\nand\nj\nsuch that\ni≠j\nand\na\ni\n≥\na\nj\n, and then assign\na\ni\n=\na\ni\n−\na\nj\nor\na\ni\n=\na\ni\n+\na\nj\n. You can perform this operation any number of times for any\ni\nand\nj\n, as long as they satisfy the conditions.\nSakurako asks you what is the maximum possible value of\nme\nx\nk\n∗\nof the array after any number of operations.\n∗\nme\nx\nk\nis the\nk\n-th non-negative integer that is absent in the array. For example,\nme\nx\n1\n({1,2,3})=0\n, since\n0\nis the first element that is not in the array, and\nme\nx\n2\n({0,2,4})=3\n, since\n3\nis the second element that is not in the array.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,1≤k≤\n10\n9\n)  — the number of elements in the array and the value\nk\nfor\nme\nx\nk\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n)  — the elements of the array.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum\nme\nx\nk\nthat can be achieved through the operations.\nExample\ninput\nCopy\n6\n1 3\n3\n2 10\n1 1\n3 1\n1 2 3\n3 2\n1 2 4\n4 5\n2 2 2 16\n4 5\n2 2 2 3\noutput\nCopy\n2\n11\n3\n4\n8\n8",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "number theory",
            "*1800"
        ]
    },
    {
        "title": "F. Sakurako's Box",
        "description": "Sakurako has a box with\nn\nballs. Each ball has it's value. She wants to bet with her friend that if the friend randomly picks two balls from the box (it could be two distinct balls, but they may have the same value), the product of their values will be the same as the number that Sakurako guessed.\nSince Sakurako has a PhD in probability, she knows that the best number to pick is the expected value, but she forgot how to calculate it. Help Sakurako and find the expected value of the product of two elements from the array.\nIt can be shown that the expected value has the form\nP\nQ\n, where\nP\nand\nQ\nare non-negative integers, and\nQ≠0\n. Report the value of\nP⋅Q−1(mod109+7)\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n)  — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅105\n)  — the number of elements in the array.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n0≤ai≤109\n)  — the elements of the array.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output the value of\nP⋅Q−1(mod109+7)\n.\nExample\ninput\nCopy\n3\n3\n3 2 3\n4\n2 2 2 4\n5\n1 2 3 4 5\noutput\nCopy\n7\n6\n500000012\nNote\nFor the first test, Sakurako's friend can pick these pairs of balls:\n(a1,a2)\n,\n(a1,a3)\n,\n(a2,a3)\n. Their products equal to\n3⋅2=6\n,\n3⋅3=9\n,\n3⋅2=6\nrespectively, so the expected value is\n6+9+6\n3\n=7\n.\nFor the second test, Sakurako's friend can pick these pairs of balls:\n(a1,a2)\n,\n(a1,a3)\n,\n(a1,a4)\n,\n(a2,a3)\n,\n(a2,a4)\n,\n(a3,a4)\n. Their products equal to\n2⋅2=4\n,\n2⋅2=4\n,\n2⋅4=8\n,\n2⋅2=4\n,\n2⋅4=8\n,\n2⋅4=8\nrespectively, so the expected value is\n4+4+8+4+8+8\n6\n=\n36\n6\n=6\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "number theory",
            "*1400"
        ]
    },
    {
        "title": "E. Alternating String",
        "description": "Sakurako really loves alternating strings. She calls a string\ns\nof lowercase Latin letters an alternating string if characters in the even positions are the same, if characters in the odd positions are the same, and the length of the string is even.\nFor example, the strings 'abab' and 'gg' are alternating, while the strings 'aba' and 'ggwp' are not.\nAs a good friend, you decided to gift such a string, but you couldn't find one. Luckily, you can perform two types of operations on the string:\nChoose an index\ni\nand delete the\ni\n-th character from the string, which will reduce the length of the string by\n1\n. This type of operation can be performed no more than\n1\ntime;\nChoose an index\ni\nand replace\ns\ni\nwith any other letter.\nSince you are in a hurry, you need to determine the minimum number of operations required to make the string an alternating one.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains a single number\nn\n(\n1≤n≤2⋅\n10\n5\n)  — the length of the string.\nThe second line of each test case contains a string\ns\n, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required to turn the string\ns\ninto an alternating one.\nExample\ninput\nCopy\n10\n1\na\n2\nca\n3\naab\n5\nababa\n6\nacdada\n9\nejibmyyju\n6\nbbccbc\n6\nabacba\n5\nbcbca\n5\ndcbdb\noutput\nCopy\n1\n0\n1\n1\n2\n6\n2\n3\n1\n1\nNote\nFor the string ababa, you can delete the first character to get baba, which is an alternating string.\nFor the string acdada, you can change the first two characters to get dadada, which is an alternating string.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "strings",
            "*1500"
        ]
    },
    {
        "title": "D. Sakurako's Hobby",
        "description": "For a certain permutation\np\n∗\nSakurako calls an integer\nj\nreachable from an integer\ni\nif it is possible to make\ni\nequal to\nj\nby assigning\ni=\np\ni\na certain number of times.\nIf\np=[3,5,6,1,2,4]\n, then, for example,\n4\nis reachable from\n1\n, because:\ni=1\n→\ni=\np\n1\n=3\n→\ni=\np\n3\n=6\n→\ni=\np\n6\n=4\n. Now\ni=4\n, so\n4\nis reachable from\n1\n.\nEach number in the permutation is colored either black or white.\nSakurako defines the function\nF(i)\nas the number of black integers that are reachable from\ni\n.\nSakurako is interested in\nF(i)\nfor each\n1≤i≤n\n, but calculating all values becomes very difficult, so she asks you, as her good friend, to compute this.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (the number\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\n, but the array contains\n4\n).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n)  — the number of elements in the array.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n)  — the elements of the permutation.\nThe third line of each test case contains a string\ns\nof length\nn\n, consisting of '0' and '1'. If\ns\ni\n=0\n, then the number\np\ni\nis colored black; if\ns\ni\n=1\n, then the number\np\ni\nis colored white.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers\nF(1),F(2),…,F(n)\n.\nExample\ninput\nCopy\n5\n1\n1\n0\n5\n1 2 4 5 3\n10101\n5\n5 4 1 3 2\n10011\n6\n3 5 6 1 2 4\n010000\n6\n1 2 3 4 5 6\n100110\noutput\nCopy\n1 \n0 1 1 1 1 \n2 2 2 2 2 \n4 1 4 4 1 4 \n0 1 1 0 0 1 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "dsu",
            "graphs",
            "math",
            "*1100"
        ]
    },
    {
        "title": "C. Longest Good Array",
        "description": "Today, Sakurako was studying arrays. An array\na\nof length\nn\nis considered good if and only if:\nthe array\na\nis increasing, meaning\na\ni−1\n<\na\ni\nfor all\n2≤i≤n\n;\nthe differences between adjacent elements are increasing, meaning\na\ni\n−\na\ni−1\n<\na\ni+1\n−\na\ni\nfor all\n2≤i<n\n.\nSakurako has come up with boundaries\nl\nand\nr\nand wants to construct a good array of maximum length, where\nl≤\na\ni\n≤r\nfor all\na\ni\n.\nHelp Sakurako find the maximum length of a good array for the given\nl\nand\nr\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe only line of each test case contains two integers\nl\nand\nr\n(\n1≤l≤r≤\n10\n9\n).\nOutput\nFor each test case, output a single integer  — the length of the longest good array Sakurako can form given\nl\nand\nr\n.\nExample\ninput\nCopy\n5\n1 2\n1 5\n2 2\n10 20\n1 1000000000\noutput\nCopy\n2\n3\n1\n5\n44721\nNote\nFor\nl=1\nand\nr=5\n, one possible array could be\n(1,2,5)\n. It can be proven that an array of length\n4\ndoes not exist for the given\nl\nand\nr\n.\nFor\nl=2\nand\nr=2\n, the only possible array is\n(2)\n.\nFor\nl=10\nand\nr=20\n, the only possible array is\n(10,11,13,16,20)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*800"
        ]
    },
    {
        "title": "B. Square or Not",
        "description": "A beautiful binary matrix is a matrix that has ones on its edges and zeros inside.\nExamples of four beautiful binary matrices.\nToday, Sakurako was playing with a beautiful binary matrix of size\nr×c\nand created a binary string\ns\nby writing down all the rows of the matrix, starting from the first and ending with the\nr\n-th. More formally, the element from the matrix in the\ni\n-th row and\nj\n-th column corresponds to the\n((i−1)∗c+j)\n-th element of the string.\nYou need to check whether the beautiful matrix from which the string\ns\nwas obtained could be squared. In other words, you need to check whether the string\ns\ncould have been build from a square beautiful binary matrix (i.e., one where\nr=c\n).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the string.\nThe second line of each test case contains the string\ns\nof length\nn\n. The string is always the result of writing out the strings of a beautiful matrix.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nPrint \"Yes\", if the original matrix could have been square, and \"No\" otherwise.\nExample\ninput\nCopy\n5\n2\n11\n4\n1111\n9\n111101111\n9\n111111111\n12\n111110011111\noutput\nCopy\nNo\nYes\nYes\nNo\nNo\nNote\nFor the second test case, string 1111 can be obtained from the matrix:\n1\n1\n1\n1\nFor the third test case, string 111101111 can be obtained from the matrix:\n1\n1\n1\n1\n0\n1\n1\n1\n1\nThere is no square matrix in the fourth case, such that the string can be obtained from it.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "strings",
            "*800"
        ]
    },
    {
        "title": "A. Sakurako's Exam",
        "description": "Today, Sakurako has a math exam. The teacher gave the array, consisting of\na\nones and\nb\ntwos.\nIn an array, Sakurako must place either a '+' or a '-' in front of each element so that the sum of all elements in the array equals\n0\n.\nSakurako is not sure if it is possible to solve this problem, so determine whether there is a way to assign signs such that the sum of all elements in the array equals\n0\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n)  — the number of test cases.\nThe only line of each test case contains two integers\na\nand\nb\n(\n0≤a,b<10\n)  — the number of '1's and the number of '2's in the array.\nOutput\nFor each test case, output \"Yes\" if you can make the sum of the entire array equal to\n0\n, and \"No\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n5\n0 1\n0 3\n2 0\n2 3\n3 1\noutput\nCopy\nNO\nNO\nYES\nYES\nNO\nNote\na=0\n,\nb=1\n: This means the array is\n[2]\n— it is impossible to add the signs '+' or '-' to get\n0\nas a result;\na=0\n,\nb=3\n: This means the array is\n[2,2,2]\n— it is impossible to add the signs '+' or '-' to get\n0\nas a result;\na=2\n,\nb=0\n: This means the array is\n[1,1]\n— it is possible to add the signs '+' or '-' to get\n0\nas a result (\n+1−1=0\n);\na=2\n,\nb=3\n: This means the array is\n[1,1,2,2,2]\n— it is possible to add the signs '+' or '-' to get\n0\nas a result (\n+1+1−2−2+2=0\n);",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "C. Dora and C++",
        "description": "Dora has just learned the programming language C++!\nHowever, she has completely misunderstood the meaning of C++. She considers it as two kinds of adding operations on the array\nc\nwith\nn\nelements. Dora has two integers\na\nand\nb\n. In one operation, she can choose one of the following things to do.\nChoose an integer\ni\nsuch that\n1≤i≤n\n, and increase\nc\ni\nby\na\n.\nChoose an integer\ni\nsuch that\n1≤i≤n\n, and increase\nc\ni\nby\nb\n.\nNote that\na\nand\nb\nare constants, and they can be the same.\nLet's define a range of array\nd\nas\nmax(\nd\ni\n)−min(\nd\ni\n)\n. For instance, the range of the array\n[1,2,3,4]\nis\n4−1=3\n, the range of the array\n[5,2,8,2,2,1]\nis\n8−1=7\n, and the range of the array\n[3,3,3]\nis\n3−3=0\n.\nAfter any number of operations (possibly,\n0\n), Dora calculates the range of the new array. You need to help Dora minimize this value, but since Dora loves exploring all by herself, you only need to tell her the minimized value.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains three integers\nn\n,\na\n, and\nb\n(\n1≤n≤\n10\n5\n,\n1≤a,b≤\n10\n9\n) — the length of the array\nc\nand the constant values, respectively.\nThe second line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n) — the initial elements of the array\nc\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum possible range of the array after any number of operations.\nExample\ninput\nCopy\n10\n4 5 5\n1 3 4 4\n4 2 3\n1 3 4 6\n4 7 7\n1 1 2 6\n3 15 9\n1 9 5\n3 18 12\n1 4 5\n7 27 36\n33 13 23 12 35 24 41\n10 6 9\n15 5 6 9 8 2 12 15 3 8\n2 1 1000000000\n1 1000000000\n6 336718728 709848696\n552806726 474775724 15129785 371139304 178408298 13106071\n6 335734893 671469786\n138885253 70095920 456876775 9345665 214704906 375508929\noutput\nCopy\n3\n0\n3\n2\n3\n5\n1\n0\n17\n205359241\nNote\nIn the first test case, we can increase\nc\n1\n=1\nby\na=5\n. The array\nc\nwill become\n[6,3,4,4]\n, and the range is\n3\n. Note that there is more than one way to reach the answer.\nIn the second test case, we can increase\nc\n1\n=1\nby\na=2\nand then increase\nc\n1\n=3\nby\nb=3\n. Also, we can increase\nc\n2\n=3\nby\nb=3\nand increase\nc\n3\n=4\nby\na=2\n. The array\nc\nwill become\n[6,6,6,6]\n, and the range is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1500"
        ]
    },
    {
        "title": "B. Index and Maximum Value",
        "description": "After receiving yet another integer array\na\n1\n,\na\n2\n,…,\na\nn\nat her birthday party, Index decides to perform some operations on it.\nFormally, there are\nm\noperations that she is going to perform in order. Each of them belongs to one of the two types:\n+ l r\n. Given two integers\nl\nand\nr\n, for all\n1≤i≤n\nsuch that\nl≤\na\ni\n≤r\n, set\na\ni\n:=\na\ni\n+1\n.\n- l r\n. Given two integers\nl\nand\nr\n, for all\n1≤i≤n\nsuch that\nl≤\na\ni\n≤r\n, set\na\ni\n:=\na\ni\n−1\n.\nFor example, if the initial array\na=[7,1,3,4,3]\n, after performing the operation\n+ 2 4\n, the array\na=[7,1,4,5,4]\n. Then, after performing the operation\n- 1 10\n, the array\na=[6,0,3,4,3]\n.\nIndex is curious about the maximum value in the array\na\n. Please help her find it after each of the\nm\noperations.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤\n10\n5\n,\n1≤m≤\n10\n5\n) — the length of the array and the number of operations.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the initial array\na\n.\nThen\nm\nlines follow, each line corresponds to the operation, in the following format:\nc l r\n(\nc∈{+,-}\n,\nl\nand\nr\nare integers,\n1≤l≤r≤\n10\n9\n) — the description of the operation.\nNote that the elements\na\ni\nmay not satisfy\n1≤\na\ni\n≤\n10\n9\nafter some operations, as it is shown in the example.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n, and the sum of\nm\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output one single line containing\nm\nintegers, with the\ni\n-th of them describing the maximum value of the array after the\ni\n-th operation.\nExample\ninput\nCopy\n5\n5 5\n1 2 3 2 1\n+ 1 3\n- 2 3\n+ 1 2\n+ 2 4\n- 6 8\n5 5\n1 3 3 4 5\n+ 1 4\n+ 2 3\n- 4 5\n- 3 3\n- 2 6\n5 5\n1 1 1 1 1\n+ 2 3\n- 4 5\n+ 1 6\n- 2 5\n+ 1 8\n1 1\n1\n- 1 1\n1 1\n1000000000\n+ 1000000000 1000000000\noutput\nCopy\n4 4 4 5 5\n5 5 4 4 3\n1 1 2 1 2\n0\n1000000001\nNote\nIn the first test case, the process of the operations is listed below:\nAfter the first operation, the array becomes equal\n[2,3,4,3,2]\n. The maximum value is\n4\n.\nAfter the second operation, the array becomes equal\n[1,2,4,2,1]\n. The maximum value is\n4\n.\nAfter the third operation, the array becomes equal\n[2,3,4,3,2]\n. The maximum value is\n4\n.\nAfter the fourth operation, the array becomes equal\n[3,4,5,4,3]\n. The maximum value is\n5\n.\nAfter the fifth operation, the array becomes equal\n[3,4,5,4,3]\n. The maximum value is\n5\n.\nIn the second test case, the process of the operations is listed below:\nAfter the first operation, the array becomes equal\n[2,4,4,5,5]\n. The maximum value is\n5\n.\nAfter the second operation, the array becomes equal\n[3,4,4,5,5]\n. The maximum value is\n5\n.\nAfter the third operation, the array becomes equal\n[3,3,3,4,4]\n. The maximum value is\n4\n.\nAfter the fourth operation, the array becomes equal\n[2,2,2,4,4]\n. The maximum value is\n4\n.\nAfter the fifth operation, the array becomes equal\n[1,1,1,3,3]\n. The maximum value is\n3\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*900"
        ]
    },
    {
        "title": "A. Dora's Set",
        "description": "Dora has a set\ns\ncontaining integers. In the beginning, she will put all integers in\n[l,r]\ninto the set\ns\n. That is, an integer\nx\nis initially contained in the set if and only if\nl≤x≤r\n. Then she allows you to perform the following operations:\nSelect three distinct integers\na\n,\nb\n, and\nc\nfrom the set\ns\n, such that\ngcd(a,b)=gcd(b,c)=gcd(a,c)=\n1\n†\n.\nThen, remove these three integers from the set\ns\n.\nWhat is the maximum number of operations you can perform?\n†\n†\nRecall that\ngcd(x,y)\nmeans the greatest common divisor of integers\nx\nand\ny\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nl\nand\nr\n(\n1≤l≤r≤1000\n) — the range of integers in the initial set.\nOutput\nFor each test case, output a single integer — the maximum number of operations you can perform.\nExample\ninput\nCopy\n8\n1 3\n3 7\n10 21\n2 8\n51 60\n2 15\n10 26\n1 1000\noutput\nCopy\n1\n1\n3\n1\n2\n3\n4\n250\nNote\nIn the first test case, you can choose\na=1\n,\nb=2\n,\nc=3\nin the only operation, since\ngcd(1,2)=gcd(2,3)=gcd(1,3)=1\n, and then there are no more integers in the set, so no more operations can be performed.\nIn the second test case, you can choose\na=3\n,\nb=5\n,\nc=7\nin the only operation.\nIn the third test case, you can choose\na=11\n,\nb=19\n,\nc=20\nin the first operation,\na=13\n,\nb=14\n,\nc=15\nin the second operation, and\na=10\n,\nb=17\n,\nc=21\nin the third operation. After the three operations, the set\ns\ncontains the following integers:\n12\n,\n16\n,\n18\n. It can be proven that it's impossible to perform more than\n3\noperations.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "F. Dora's Paint",
        "description": "Sadly, Dora poured the paint when painting the class mural. Dora considers the mural as the matrix\nb\nof size\nn×n\n. Initially,\nb\ni,j\n=0\nfor all\n1≤i,j≤n\n.\nDora has only two brushes which have two different colors. In one operation, she can paint the matrix with one of two brushes:\nThe first brush has color\n1\non it and can paint one column of the matrix. That is, Dora chooses\n1≤j≤n\nand makes\nb\ni,j\n:=1\nfor all\n1≤i≤n\n;\nThe second brush has color\n2\non it and can paint one row of the matrix. That is, Dora chooses\n1≤i≤n\nand makes\nb\ni,j\n:=2\nfor all\n1≤j≤n\n.\nDora paints the matrix so that the resulting matrix\nb\ncontains only\n1\nand\n2\n.\nFor a matrix\nb\n, let\nf(b)\ndenote the minimum number of operations needed to turn the initial matrix (containing only\n0\n) into\nb\n. The beauty of a matrix\nb\nis the number of ways to paint the initial matrix in exactly\nf(b)\noperations to turn it into\nb\n. If there's no way to turn the initial matrix into\nb\n, the beauty of\nb\nis\n0\n.\nHowever, Dora made a uniformly random mistake; there's exactly one element different in the matrix\na\ngiven to you from the real matrix\nb\n. That is, there is exactly one pair\n(i,j)\nsuch that\na\ni,j\n=3−\nb\ni,j\n.\nPlease help Dora compute the expected beauty of the real matrix\nb\nmodulo\n998244353\n(all possible\nn\n2\nmistakes have equal probability).\nSince the size of the matrix is too large, Dora will only tell you the positions of\nm\nelements of color\n1\n, and the remaining\nn\n2\n−m\nelements have color\n2\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤2⋅\n10\n5\n,\n0≤m≤min(\n10\n6\n,\nn\n2\n)\n) — the size of the matrix and the number of elements of color\n1\n.\nThen\nm\nlines follow, each containing two positive integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n) — denoting that\na\nx\ni\n,\ny\ni\n=1\n.\nIt is guaranteed that if\ni≠j\n, then\n(\nx\ni\n,\ny\ni\n)≠(\nx\nj\n,\ny\nj\n)\n.\nIt is also guaranteed that the sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n, and the sum of\nm\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the expected beauty of the real matrix\nb\n, modulo\n998244353\n.\nExample\ninput\nCopy\n7\n2 2\n1 1\n1 2\n2 1\n1 1\n3 2\n1 1\n3 3\n6 0\n5 10\n1 1\n1 2\n1 3\n2 1\n2 3\n5 1\n5 2\n5 3\n5 4\n5 5\n3 5\n1 1\n1 3\n2 2\n3 1\n3 3\n4 3\n1 1\n2 3\n2 4\noutput\nCopy\n1\n499122178\n665496236\n120\n79859554\n776412275\n1\nNote\nIn the first test case, the matrix\na=[\n1\n2\n1\n2\n]\n. Let's consider changing the element\n(1,1)\nto calculate the answer.\nIt can be proved that the minimum steps to paint the initial matrix into\n[\n2\n2\n1\n2\n]\nis\n3\n. We can first paint the first row into color\n2\n, then paint the second column into color\n1\n, and finally paint the second row into color\n2\n. The process is listed below:\n[\n0\n0\n0\n0\n]⇒[\n2\n0\n2\n0\n]⇒[\n2\n0\n1\n1\n]⇒[\n2\n2\n1\n2\n]\nIt can be proved that this is the only way to paint the matrix in\n3\nsteps. So the beauty of the matrix\n[\n2\n2\n1\n2\n]\nis\n1\n. Similarly, if any other element of the matrix is changed, the beauty is always\n1\n, so the expected beauty of the real matrix\nb\nis\n1\n.\nIn the second test case, the matrix\na=[\n1\n2\n2\n2\n]\n. Let's consider changing the element\n(2,2)\nto calculate the answer.\nIt can be proven that it's impossible to paint the initial matrix into\n[\n1\n2\n2\n1\n]\n, so its beauty is\n0\n. If any other element of the matrix is changed, the beauty is always\n2\n, so the expected beauty is\n0+2+2+2\n4\n=\n6\n4\n≡499122178(mod998244353)\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "constructive algorithms",
            "graphs",
            "implementation",
            "*3500"
        ]
    },
    {
        "title": "E. Iris's Full Binary Tree",
        "description": "Iris likes full binary trees.\nLet's define the depth of a rooted tree as the maximum number of vertices on the simple paths from some vertex to the root. A full binary tree of depth\nd\nis a binary tree of depth\nd\nwith exactly\n2\nd\n−1\nvertices.\nIris calls a tree a\nd\n-binary tree if some vertices and edges can be added to it to make it a full binary tree of depth\nd\n. Note that any vertex can be chosen as the root of a full binary tree.\nSince performing operations on large trees is difficult, she defines the binary depth of a tree as the minimum\nd\nsatisfying that the tree is\nd\n-binary. Specifically, if there is no integer\nd≥1\nsuch that the tree is\nd\n-binary, the binary depth of the tree is\n−1\n.\nIris now has a tree consisting of only vertex\n1\n. She wants to add\nn−1\nmore vertices to form a larger tree. She will add the vertices one by one. When she adds vertex\ni\n(\n2≤i≤n\n), she'll give you an integer\np\ni\n(\n1≤\np\ni\n<i\n), and add a new edge connecting vertices\ni\nand\np\ni\n.\nIris wants to ask you the binary depth of the tree formed by the first\ni\nvertices for each\n1≤i≤n\n. Can you tell her the answer?\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤5⋅\n10\n5\n) — the final size of the tree.\nThe second line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n<i\n) — descriptions of all edges of the tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case output\nn\nintegers,\ni\n-th of them representing the binary depth of the tree formed by the first\ni\nvertices.\nExample\ninput\nCopy\n7\n3\n1 1\n6\n1 2 3 4 5\n7\n1 1 3 2 5 1\n10\n1 1 2 1 4 2 4 5 8\n10\n1 1 3 1 3 2 2 2 6\n20\n1 1 2 2 4 4 5 5 7 6 8 6 11 14 11 8 13 13 12\n25\n1 1 3 3 1 5 4 4 6 8 11 12 8 7 11 13 7 13 15 6 19 14 10 23\noutput\nCopy\n1 2 2 \n1 2 2 3 3 4 \n1 2 2 3 3 4 4 \n1 2 2 3 3 3 4 4 5 5 \n1 2 2 3 3 4 4 4 -1 -1 \n1 2 2 3 3 4 4 4 4 5 5 5 5 6 6 6 6 6 6 7 \n1 2 2 3 3 4 4 4 4 5 5 6 6 6 6 6 7 7 7 7 7 8 8 8 8 \nNote\nIn the first test case, the final tree is shown below:\nThe tree consisting of the vertex\n1\nhas the binary depth\n1\n(the tree itself is a full binary tree of depth\n1\n).\nThe tree consisting of the vertices\n1\nand\n2\nhas the binary depth\n2\n(we can add the vertex\n3\nto make it a full binary tree of depth\n2\n).\nThe tree consisting of the vertices\n1\n,\n2\nand\n3\nhas the binary depth\n2\n(the tree itself is a full binary tree of depth\n2\n).\nIn the second test case, the formed full binary tree after adding some vertices to the tree consisting of\nn\nvertices is shown below (bolded vertices are added):\nThe depth of the formed full binary tree is\n4\n.\nIn the fifth test case, the final tree is shown below:\nIt can be proved that Iris can't form any full binary tree by adding vertices and edges, so the binary depth is\n−1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "trees",
            "*3100"
        ]
    },
    {
        "title": "D. Iris and Adjacent Products",
        "description": "Iris has just learned multiplication in her Maths lessons. However, since her brain is unable to withstand too complex calculations, she could not multiply two integers with the product greater than\nk\ntogether. Otherwise, her brain may explode!\nHer teacher sets a difficult task every day as her daily summer holiday homework. Now she is given an array\na\nconsisting of\nn\nelements, and she needs to calculate the product of each two adjacent elements (that is,\na\n1\n⋅\na\n2\n,\na\n2\n⋅\na\n3\n, and so on). Iris wants her brain to work safely, and in order to do that, she would like to modify the array\na\nin such a way that\na\ni\n⋅\na\ni+1\n≤k\nholds for every\n1≤i<n\n. There are two types of operations she can perform:\nShe can rearrange the elements of the array\na\nin an arbitrary way.\nShe can select an arbitrary element of the array\na\nand change its value to an arbitrary integer from\n1\nto\nk\n.\nIris wants to minimize the number of operations of type\n2\nthat she uses.\nHowever, that's completely not the end of the summer holiday! Summer holiday lasts for\nq\ndays, and on the\ni\n-th day, Iris is asked to solve the Math homework for the subarray\nb\nl\ni\n,\nb\nl\ni\n+1\n,…,\nb\nr\ni\n. Help Iris and tell her the minimum number of type\n2\noperations she needs to perform for each day. Note that the operations are independent for each day, i.e. the array\nb\nis not changed.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nq\nand\nk\n(\n2≤n≤\n10\n5\n,\n1≤q≤\n10\n5\n,\n1≤k≤\n10\n6\n) — the length of array\nb\n, the number of days, and the upper bound for the multiplication calculation.\nThe second line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤k\n) — the elements of the array\nb\n.\nThen\nq\nlines follow, the\ni\n-th of them contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n<\nr\ni\n≤n\n) — the boundaries of the subarray on the\ni\n-th day.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n, and the sum of\nq\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test, output a single line containing\nq\nintegers — the minimum number of operations of type\n2\nneeded for each day.\nExample\ninput\nCopy\n5\n3 1 1\n1 1 1\n1 3\n3 2 10\n1 10 9\n1 3\n2 3\n5 4 2\n2 2 2 2 2\n1 2\n2 4\n2 5\n1 5\n6 5 10\n3 2 5 10 10 1\n1 4\n3 6\n1 6\n2 5\n5 6\n10 10 10\n10 9 8 7 6 5 4 3 2 1\n1 10\n1 9\n1 8\n1 7\n2 10\n3 10\n4 10\n5 10\n3 9\n6 8\noutput\nCopy\n0 \n0 1 \n1 1 2 2 \n1 1 1 1 0 \n3 3 4 3 2 2 1 1 2 1 \nNote\nIn the first test case, as Iris can always multiply\n1\nand\n1\ntogether, no operations are needed, so the answer is\n0\n.\nIn the second test case, the first day's homework is\n[1,10,9]\n. Iris can rearrange its elements to get\n[9,1,10]\n, so no operations of type\n2\nare needed. The second day's homework is\n[10,9]\n, and she can change one element to get the array\n[1,9]\n, so one operation of type\n2\nis needed.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "implementation",
            "math",
            "*2600"
        ]
    },
    {
        "title": "C. Eri and Expanded Sets",
        "description": "Let there be a set that contains distinct positive integers. To expand the set to contain as many integers as possible, Eri can choose two integers\nx≠y\nfrom the set such that their average\nx+y\n2\nis still a positive integer and isn't contained in the set, and add it to the set. The integers\nx\nand\ny\nremain in the set.\nLet's call the set of integers consecutive if, after the elements are sorted, the difference between any pair of adjacent elements is\n1\n. For example, sets\n{2}\n,\n{2,5,4,3}\n,\n{5,6,8,7}\nare consecutive, while\n{2,4,5,6}\n,\n{9,7}\nare not.\nEri likes consecutive sets. Suppose there is an array\nb\n, then Eri puts all elements in\nb\ninto the set. If after a finite number of operations described above, the set can become consecutive, the array\nb\nwill be called brilliant.\nNote that if the same integer appears in the array multiple times, we only put it into the set once, as a set always contains distinct positive integers.\nEri has an array\na\nof\nn\npositive integers. Please help him to count the number of pairs of integers\n(l,r)\nsuch that\n1≤l≤r≤n\nand the subarray\na\nl\n,\na\nl+1\n,…,\na\nr\nis brilliant.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤4⋅\n10\n5\n) — length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of brilliant subarrays.\nExample\ninput\nCopy\n6\n2\n2 2\n6\n1 3 6 10 15 21\n5\n6 30 18 36 9\n1\n1000000000\n6\n1 1 4 5 1 4\n12\n70 130 90 90 90 108 612 500 451 171 193 193\noutput\nCopy\n3\n18\n5\n1\n18\n53\nNote\nIn the first test case, the array\na=[2,2]\nhas\n3\nsubarrays:\n[2]\n,\n[2]\n, and\n[2,2]\n. For all of them, the set only contains a single integer\n2\n, therefore it's always consecutive. All these subarrays are brilliant, so the answer is\n3\n.\nIn the second test case, let's consider the subarray\n[3,6,10]\n. We can do operations as follows:\n{3,6,10}\n−\n→\n−\n−\n−\n−\nx=6,y=10\n{3,6,8,10}\n−\n→\n−\n−\n−\n−\nx=6,y=8\n{3,6,7,8,10}\n−\n→\n−\n−\n−\n−\nx=3,y=7\n{3,5,6,7,8,10}\nx\n=\n6\ny\n=\n10\nx\n=\n6\ny\n=\n8\nx\n=\n3\ny\n=\n7\n−\n→\n−\n−\n−\n−\nx=3,y=5\n{3,4,5,6,7,8,10}\n−\n→\n−\n−\n−\n−\nx=8,y=10\n{3,4,5,6,7,8,9,10}\n3\n5\n8\n10\n{3,4,5,6,7,8,9,10}\nis a consecutive set, so the subarray\n[3,6,10]\nis brilliant.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "math",
            "number theory",
            "two pointers",
            "*2300"
        ]
    },
    {
        "title": "B. Iris and the Tree",
        "description": "Given a rooted tree with the root at vertex\n1\n. For any vertex\ni\n(\n1<i≤n\n) in the tree, there is an edge connecting vertices\ni\nand\np\ni\n(\n1≤\np\ni\n<i\n), with a weight equal to\nt\ni\n.\nIris does not know the values of\nt\ni\n, but she knows that\n∑\ni=2\nn\nt\ni\n=w\nand each of the\nt\ni\nis a non-negative integer.\nThe vertices of the tree are numbered in a special way: the numbers of the vertices in each subtree are consecutive integers. In other words, the vertices of the tree are numbered in the order of a depth-first search.\nThe tree in this picture satisfies the condition. For example, in the subtree of vertex\n2\n, the vertex numbers are\n2,3,4,5\n, which are consecutive integers.\nThe tree in this picture does not satisfy the condition, as in the subtree of vertex\n2\n, the vertex numbers\n2\nand\n4\nare not consecutive integers.\nWe define\ndist(u,v)\nas the length of the simple path between vertices\nu\nand\nv\nin the tree.\nNext, there will be\nn−1\nevents:\nIris is given integers\nx\nand\ny\n, indicating that\nt\nx\n=y\n.\nAfter each event, Iris wants to know the maximum possible value of\ndist(i,imodn+1)\nindependently for each\ni\n(\n1≤i≤n\n). She only needs to know the sum of these\nn\nvalues. Please help Iris quickly get the answers.\nNote that when calculating the maximum possible values of\ndist(i,imodn+1)\nand\ndist(j,jmodn+1)\nfor\ni≠j\n, the unknown edge weights may be different.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nw\n(\n2≤n≤2⋅\n10\n5\n,\n0≤w≤\n10\n12\n) — the number of vertices in the tree and the sum of the edge weights.\nThe second line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n<i\n) — the description of the edges of the tree.\nThen follow\nn−1\nlines indicating the events. Each line contains two integers\nx\nand\ny\n(\n2≤x≤n\n,\n0≤y≤w\n), indicating that\nt\nx\n=y\n.\nIt is guaranteed that all\nx\nin the events are distinct. It is also guaranteed that the sum of all\ny\nequals\nw\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one line containing\nn−1\nintegers, each representing the answer after each event.\nExample\ninput\nCopy\n4\n2 1000000000000\n1\n2 1000000000000\n4 9\n1 1 1\n2 2\n4 4\n3 3\n6 100\n1 2 3 2 1\n6 17\n3 32\n2 4\n4 26\n5 21\n10 511\n1 2 2 4 2 1 1 8 8\n3 2\n6 16\n10 256\n9 128\n2 1\n5 8\n8 64\n4 4\n7 32\noutput\nCopy\n2000000000000\n25 18 18\n449 302 247 200 200\n4585 4473 2681 1567 1454 1322 1094 1022 1022\nNote\nIn the first test case,\ndist(1,2)=dist(2,1)=\nt\n2\n=w=\n10\n12\n, so\ndist(1,2)+dist(2,1)=2⋅\n10\n12\n.\nIn the second test case, the tree after Iris found out all\nt\nx\nis shown below:\ndist(1,2)=\nt\n2\n,\ndist(2,3)=\nt\n2\n+\nt\n3\n,\ndist(3,4)=\nt\n3\n+\nt\n4\n,\ndist(4,1)=\nt\n4\n. After the first event, she found out that\nt\n2\n=2\n, so\ndist(1,2)=2\n. At the same time:\ndist(2,3)\nis maximized if\nt\n3\n=7\n,\nt\n4\n=0\n. Then\ndist(2,3)=9\n.\ndist(3,4)\nand\ndist(4,1)\nare maximized if\nt\n3\n=0\n,\nt\n4\n=7\n. Then\ndist(3,4)=dist(4,1)=7\n.\nThus, the answer is\n2+9+7+7=25\n.\nAfter the second event, she found out that\nt\n4\n=4\n, then\nt\n3\n=w−\nt\n2\n−\nt\n4\n=4\n.\ndist(1,2)=2\n,\ndist(2,3)=2+3=5\n,\ndist(3,4)=3+4=7\n,\ndist(4,1)=4\n. Thus, the answer is\n2+5+7+4=18\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dsu",
            "math",
            "trees",
            "*1800"
        ]
    },
    {
        "title": "A. Iris and Game on the Tree",
        "description": "Iris has a tree rooted at vertex\n1\n. Each vertex has a value of\n0\nor\n1\n.\nLet's consider a leaf of the tree (the vertex\n1\nis never considered a leaf) and define its weight. Construct a string formed by the values of the vertices on the path starting at the root and ending in this leaf. Then the weight of the leaf is the difference between the number of occurrences of\n10\nand\n01\nsubstrings in it.\nTake the following tree as an example. Green vertices have a value of\n1\nwhile white vertices have a value of\n0\n.\nLet's calculate the weight of the leaf\n5\n: the formed string is\n10110\n. The number of occurrences of substring\n10\nis\n2\n, the number of occurrences of substring\n01\nis\n1\n, so the difference is\n2−1=1\n.\nLet's calculate the weight of the leaf\n6\n: the formed string is\n101\n. The number of occurrences of substring\n10\nis\n1\n, the number of occurrences of substring\n01\nis\n1\n, so the difference is\n1−1=0\n.\nThe score of a tree is defined as the number of leaves with non-zero weight in the tree.\nBut the values of some vertices haven't been decided and will be given to you as\n?\n. Filling the blanks would be so boring, so Iris is going to invite Dora to play a game. On each turn, one of the girls chooses any of the remaining vertices with value\n?\nand changes its value to\n0\nor\n1\n, with Iris going first. The game continues until there are no vertices with value\n?\nleft in the tree. Iris aims to maximize the score of the tree, while Dora aims to minimize that.\nAssuming that both girls play optimally, please determine the final score of the tree.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the tree.\nThe following\nn−1\nlines each contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n) — denoting an edge between vertices\nu\nand\nv\n.\nIt's guaranteed that the given edges form a tree.\nThe last line contains a string\ns\nof length\nn\n. The\ni\n-th character of\ns\nrepresents the value of vertex\ni\n. It's guaranteed that\ns\nonly contains characters\n0\n,\n1\nand\n?\n.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the final score of the tree.\nExample\ninput\nCopy\n6\n4\n1 2\n1 3\n4 1\n0101\n4\n1 2\n3 2\n2 4\n???0\n5\n1 2\n1 3\n2 4\n2 5\n?1?01\n6\n1 2\n2 3\n3 4\n5 3\n3 6\n?0????\n5\n1 2\n1 3\n1 4\n1 5\n11?1?\n2\n2 1\n??\noutput\nCopy\n2\n1\n1\n2\n1\n0\nNote\nIn the first test case, all the values of the vertices have been determined. There are three different paths from the root to a leaf:\nFrom vertex\n1\nto vertex\n2\n. The string formed by the path is\n01\n, so the weight of the leaf is\n0−1=−1\n.\nFrom vertex\n1\nto vertex\n3\n. The string formed by the path is\n00\n, so the weight of the leaf is\n0−0=0\n.\nFrom vertex\n1\nto vertex\n4\n. The string formed by the path is\n01\n, so the weight of the leaf is\n0−1=−1\n.\nThus, there are two leaves with non-zero weight, so the score of the tree is\n2\n.\nIn the second test case, one of the sequences of optimal choices for the two players can be:\nIris chooses to change the value of the vertex\n3\nto\n1\n.\nDora chooses to change the value of the vertex\n1\nto\n0\n.\nIris chooses to change the value of the vertex\n2\nto\n0\n.\nThe final tree is as follows:\nThe only leaf with non-zero weight is\n3\n, so the score of the tree is\n1\n. Note that this may not be the only sequence of optimal choices for Iris and Dora.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "games",
            "graphs",
            "greedy",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "E2. Subtangle Game (Hard Version)",
        "description": "This is the hard version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\nTsovak and Narek are playing a game. They have an array\na\nand a matrix\nb\nof integers with\nn\nrows and\nm\ncolumns, numbered from\n1\n. The cell in the\ni\n-th row and the\nj\n-th column is\n(i,j)\n.\nThey are looking for the elements of\na\nin turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of\na\n(Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell\n(r,c)\n. The next player has to choose his cell in the submatrix starting at\n(r+1,c+1)\nand ending in\n(n,m)\n(the submatrix can be empty if\nr=n\nor\nc=m\n). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\nYour task is to determine the winner if the players play optimally.\nNote: since the input is large, you may need to optimize input/output for this problem.\nFor example, in C++, it is enough to use the following lines at the start of the main() function:\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n}\nInput\nThe first line of the input contains\nt\n(\n1≤t≤1500\n) – the number of test cases.\nThe first line of each test case contains three integers\nl\n,\nn\n, and\nm\n(\n1≤l,n,m≤1500\n) – the size of the array and the sizes of the matrix.\nThe second line contains\nl\nintegers\na\n1\n,\na\n2\n,\na\n3\n,…\na\nl\n(\n1≤\na\ni\n≤n⋅m\n) – the elements of the array\na\n.\nThe\ni\n-th of the last\nn\nlines contains\nm\nintegers\nb\ni,1\n,\nb\ni,2\n,\nb\ni,3\n,…\nb\ni,m\n(\n1≤\nb\ni,j\n≤n⋅m\n) – representing the\ni\n-th row of the matrix.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n3⋅\n10\n6\n.\nIt is guaranteed that the sum of\nl\nover all test cases does not exceed\n1500\n.\nOutput\nYou should output\nt\nlines, the\ni\n-th of them containing a character representing the answer of the\ni\n-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\nExample\ninput\nCopy\n3\n2 2 3\n1 2\n1 3 6\n4 6 2\n2 2 4\n1 2\n1 1 3 2\n4 2 5 1\n2 4 2\n1 2\n3 4\n5 6\n7 8\n8 8\noutput\nCopy\nN\nT\nN\nNote\nIn the first example, Tsovak starts by looking for\n1\n. There is only one occurrence of\n1\nat\n(1,1)\n, so he chooses it. Then Narek needs to look for\n2\nin the submatrix of\n(2,2)\n, which consists of just the last two elements:\n6\nand\n2\n. He chooses\n2\n, and then Tsovak loses since the array has ended.\nIn the second example, Tsovak needs to choose\n1\n. There is a\n1\nat the cell\n(n,m)\n, so he chooses that cell. Then, since the submatrix of\n(n+1,m+1)\nis empty, Narek cannot find\n2\n, so he loses.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "games",
            "greedy",
            "implementation",
            "*2500"
        ]
    },
    {
        "title": "E1. Subtangle Game (Easy Version)",
        "description": "This is the easy version of the problem. The differences between the two versions are the constraints on all the variables. You can make hacks only if both versions of the problem are solved.\nTsovak and Narek are playing a game. They have an array\na\nand a matrix\nb\nof integers with\nn\nrows and\nm\ncolumns, numbered from\n1\n. The cell in the\ni\n-th row and the\nj\n-th column is\n(i,j)\n.\nThey are looking for the elements of\na\nin turns; Tsovak starts first. Each time a player looks for a cell in the matrix containing the current element of\na\n(Tsovak looks for the first, then Narek looks for the second, etc.). Let's say a player has chosen the cell\n(r,c)\n. The next player has to choose his cell in the submatrix starting at\n(r+1,c+1)\nand ending in\n(n,m)\n(the submatrix can be empty if\nr=n\nor\nc=m\n). If a player cannot find such a cell (or the remaining submatrix is empty) or the array ends (the previous player has chosen the last element), then he loses.\nYour task is to determine the winner if the players play optimally.\nInput\nThe first line of the input contains\nt\n(\n1≤t≤300\n) – the number of test cases.\nThe first line of each test case contains three integers\nl\n,\nn\n, and\nm\n(\n1≤l,n,m≤300\n) – the size of the array and the sizes of the matrix.\nThe second line contains\nl\nintegers\na\n1\n,\na\n2\n,\na\n3\n,…\na\nl\n(\n1≤\na\ni\n≤min(7,n⋅m)\n) – the elements of the array\na\n.\nThe\ni\n-th of the last\nn\nlines contains\nm\nintegers\nb\ni,1\n,\nb\ni,2\n,\nb\ni,3\n,…\nb\ni,m\n(\n1≤\nb\ni,j\n≤min(7,n⋅m)\n) – representing the\ni\n-th row of the matrix.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n10\n5\n.\nIt is guaranteed that the sum of\nl\nover all test cases does not exceed\n300\n.\nOutput\nYou should output\nt\nlines, the\ni\n-th of them containing a character representing the answer of the\ni\n-th test case: \"T\" if Tsovak wins or \"N\", otherwise (without quotes).\nExample\ninput\nCopy\n3\n2 2 3\n1 2\n1 3 5\n4 5 2\n2 2 4\n1 2\n1 1 3 2\n4 2 5 1\n2 4 2\n1 2\n3 4\n5 5\n5 5\n5 5\noutput\nCopy\nN\nT\nN\nNote\nIn the first example, Tsovak starts by looking for\n1\n. There is only one occurrence of\n1\nat\n(1,1)\n, so he chooses it. Then Narek needs to look for\n2\nin the submatrix of\n(2,2)\n, which consists of just the last two elements:\n5\nand\n2\n. He chooses\n2\n, and then Tsovak loses since the array has ended.\nIn the second example, Tsovak needs to choose\n1\n. There is a\n1\nat the cell\n(n,m)\n, so he chooses that cell. Then, since the submatrix of\n(n+1,m+1)\nis empty, Narek cannot find\n2\n, so he loses.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "games",
            "greedy",
            "implementation",
            "*2100"
        ]
    },
    {
        "title": "D. Alter the GCD",
        "description": "You are given two arrays\na\n1\n,\na\n2\n,…,\na\nn\nand\nb\n1\n,\nb\n2\n,…,\nb\nn\n.\nYou must perform the following operation exactly once:\nchoose any indices\nl\nand\nr\nsuch that\n1≤l≤r≤n\n;\nswap\na\ni\nand\nb\ni\nfor all\ni\nsuch that\nl≤i≤r\n.\nFind the maximum possible value of\ngcd(\na\n1\n,\na\n2\n,…,\na\nn\n)+gcd(\nb\n1\n,\nb\n2\n,…,\nb\nn\n)\nafter performing the operation exactly once. Also find the number of distinct pairs\n(l,r)\nwhich achieve the maximum value.\nInput\nIn the first line of the input, you are given a single integer\nt\n(\n1≤t≤\n10\n5\n), the number of test cases. Then the description of each test case follows.\nIn the first line of each test case, you are given a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n), representing the number of integers in each array.\nIn the next line, you are given\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIn the last line, you are given\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n) — the elements of the array\nb\n.\nThe sum of values of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a line with two integers: the maximum value of\ngcd(\na\n1\n,\na\n2\n,…,\na\nn\n)+gcd(\nb\n1\n,\nb\n2\n,…,\nb\nn\n)\nafter performing the operation exactly once, and the number of ways.\nExample\ninput\nCopy\n5\n8\n11 4 16 17 3 24 25 8\n8 10 4 21 17 18 25 21\n4\n6 4 24 13\n15 3 1 14\n2\n13 14\n5 8\n8\n20 17 15 11 21 10 3 7\n9 9 4 20 14 9 13 1\n2\n18 13\n15 20\noutput\nCopy\n2 36\n3 2\n2 3\n2 36\n6 1\nNote\nIn the first, third, and fourth test cases, there's no way to achieve a higher GCD than\n1\nin any of the arrays, so the answer is\n1+1=2\n. Any pair\n(l,r)\nachieves the same result; for example, in the first test case there are\n36\nsuch pairs.\nIn the last test case, you must choose\nl=1\n,\nr=2\nto maximize the answer. In this case, the GCD of the first array is\n5\n, and the GCD of the second array is\n1\n, so the answer is\n5+1=6\n, and the number of ways is\n1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "implementation",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "C. Lazy Narek",
        "description": "Narek is too lazy to create the third problem of this contest. His friend Artur suggests that he should use ChatGPT. ChatGPT creates\nn\nproblems, each consisting of\nm\nletters, so Narek has\nn\nstrings. To make the problem harder, he combines the problems by selecting some of the\nn\nstrings possibly none and concatenating them without altering their order. His chance of solving the problem is defined as\nscor\ne\nn\n−scor\ne\nc\n, where\nscor\ne\nn\nis Narek's score and\nscor\ne\nc\nis ChatGPT's score.\nNarek calculates\nscor\ne\nn\nby examining the selected string (he moves from left to right). He initially searches for the letter\n\"n\"\n, followed by\n\"a\"\n,\n\"r\"\n,\n\"e\"\n, and\n\"k\"\n. Upon finding all occurrences of these letters, he increments\nscor\ne\nn\nby\n5\nand resumes searching for\n\"n\"\nagain (he doesn't go back, and he just continues from where he left off).\nAfter Narek finishes, ChatGPT scans through the array and increments\nscor\ne\nc\nby\n1\nfor each letter\n\"n\"\n,\n\"a\"\n,\n\"r\"\n,\n\"e\"\n, or\n\"k\"\nthat Narek fails to utilize (note that if Narek fails to complete the last occurrence by finding all of the\n5\nletters, then all of the letters he used are counted in ChatGPT's score\nscor\ne\nc\n, and Narek doesn't get any points if he doesn't finish finding all the 5 letters).\nNarek aims to maximize the value of\nscor\ne\nn\n−scor\ne\nc\nby selecting the most optimal subset of the initial strings.\nInput\nIn the first line of the input, you're given a single integer\nt\n(\n1≤t≤\n10\n5\n), the number of test cases. Then the description of each test case follows.\nIn the first line of each test case, you're given two integers\nn,m\n(\n1≤n,m≤\n10\n3\n), the number of strings and the length of each string.\nIn the next\nn\nlines, you're given\nn\nstrings, each having a length of\nm\n. The strings only contain lowercase letters of the English alphabet.\nThe sum of values of\nn⋅m\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer: the maximal possible value of\nscor\ne\nn\n−scor\ne\nc\n.\nExample\ninput\nCopy\n4\n5 2\nnn\naa\nrr\nee\nkk\n1 5\nnarek\n1 4\nnare\n5 7\nnrrarek\nnrnekan\nuuuuuuu\nppppppp\nnkarekz\noutput\nCopy\n0\n5\n0\n7\nNote\nIn the first test case, one of the optimal answers is when Narek doesn't choose any of the strings, so the answer is\n0\n. He can alternatively choose all the strings. In this case, the full string becomes \"nnaarreekk\". Narek can choose the first appearances of all letters and add\n5\nto the score. His opponent will add\n1\nfor all second appearances, which will be\n5\nin total. So the answer will be\n5−5=0\n.\nIn the third test case, the only optimal answer is when Narek doesn't choose the string. Note that if he were to choose the string, he wouldn't be able to find the last letter \"k\", so his score would stay at\n0\ninstead of becoming\n5\n. Then ChatGPT would add\n4\nfor all of the\n4\nletters, and the answer would become\n0−4=−4\n.\nIn the last test case, Narek needs to choose the first and the last strings. After putting these two next to each other, he gets \"\nnrrareknkarekz\n\". Narek can choose the letters marked with red and add\n10\nto his score. Since the black colored letters Narek left behind are eligible for the opponent to claim (they are used in the word \"narek\"), the opponent adds all other letters to the score and gets a score of\n3\n. Therefore, the answer is\n10−3=7\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "strings",
            "*1800"
        ]
    },
    {
        "title": "B2. The Strict Teacher (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions are the constraints on\nm\nand\nq\n. In this version,\nm,q≤\n10\n5\n. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now\nm\nteachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from\n1\nto\nn\n, inclusive.\nAt the start, all\nm\nteachers and David are in distinct cells. Then they make moves. During each move\nDavid goes to an adjacent cell or stays at the current one.\nThen, each of the\nm\nteachers simultaneously goes to an adjacent cell or stays at the current one.\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you\nq\nqueries on David's position.\nInput\nIn the first line of the input, you are given a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers\nn\n,\nm\n, and\nq\n(\n3≤n≤\n10\n9\n,\n1≤m,q≤\n10\n5\n) — the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given\nm\ndistinct integers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤n\n) — the cell numbers of the teachers.\nIn the third line of each test case, you are given\nq\nintegers\na\n1\n,\na\n2\n,…,\na\nq\n(\n1≤\na\ni\n≤n\n) — David's cell number for every query.\nIt is guaranteed that for any\ni\n,\nj\nsuch that\n1≤i≤m\nand\n1≤j≤q\n,\nb\ni\n≠\na\nj\n.\nIt is guaranteed that the sum of values of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nIt is guaranteed that the sum of values of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nq\nlines, the\ni\n-th of them containing the answer of the\ni\n-th query.\nExample\ninput\nCopy\n2\n8 1 1\n6\n3\n10 3 3\n1 4 8\n2 3 10\noutput\nCopy\n5\n1\n1\n2\nNote\nIn the only query of the first example, the student can run to cell\n1\n. It will take the teacher five moves to reach from cell\n6\nto cell\n1\n, so the answer is\n5\n.\nIn the second query of the second example, the student can just stay at cell\n3\n. The teacher, initially located in cell\n4\n, can reach cell\n3\nin one move. Therefore, the answer is\n1\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ]
    },
    {
        "title": "B1. The Strict Teacher (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions are the constraints on\nm\nand\nq\n. In this version,\nm=2\nand\nq=1\n. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now\nm\nteachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from\n1\nto\nn\n, inclusive.\nAt the start, all\nm\nteachers and David are in distinct cells. Then they make moves. During each move\nDavid goes to an adjacent cell or stays at the current one.\nThen, each of the\nm\nteachers simultaneously goes to an adjacent cell or stays at the current one.\nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you\nq\nqueries on David's position. Note: this is the easy version, and you are given only one query.\nInput\nIn the first line of the input, you are given a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers\nn\n,\nm\n, and\nq\n(\n3≤n≤\n10\n9\n,\nm=2\n,\nq=1\n) — the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given\nm\ndistinct integers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤n\n) — the cell numbers of the teachers.\nIn the third line of each test case, you are given\nq\nintegers\na\n1\n,\na\n2\n,…,\na\nq\n(\n1≤\na\ni\n≤n\n) — David's cell number for every query.\nIt is guaranteed that for any\ni\n,\nj\nsuch that\n1≤i≤m\nand\n1≤j≤q\n,\nb\ni\n≠\na\nj\n.\nOutput\nFor each test case, output\nq\nlines, the\ni\n-th of them containing the answer of the\ni\n-th query.\nExample\ninput\nCopy\n3\n10 2 1\n1 4\n2\n8 2 1\n3 6\n1\n8 2 1\n3 6\n8\noutput\nCopy\n1\n2\n2\nNote\nIn the first example, the student can just stay at cell\n2\n. The teacher, initially located in cell\n1\n, can reach cell\n2\nin one move. Therefore, the answer is\n1\n.\nIn the second example, the student should just stay at cell\n1\n. The teacher, initially located in cell\n3\n, can reach cell\n1\nin two moves. Therefore, the answer is\n2\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ]
    },
    {
        "title": "A. Simple Palindrome",
        "description": "Narek has to spend 2 hours with some 2-year-old kids at the kindergarten. He wants to teach them competitive programming, and their first lesson is about palindromes.\nNarek found out that the kids only know the vowels of the English alphabet (the letters\na\n,\ne\n,\ni\n,\no\n, and\nu\n), so Narek needs to make a string that consists of vowels only. After making the string, he'll ask the kids to count the number of subsequences that are palindromes. Narek wants to keep it simple, so he's looking for a string such that the amount of palindrome subsequences is minimal.\nHelp Narek find a string of length\nn\n, consisting of lowercase English vowels only (letters\na\n,\ne\n,\ni\n,\no\n, and\nu\n), which minimizes the amount of palindrome\n†\n†\nsubsequences\n‡\n‡\nin it.\n†\n†\nA string is called a palindrome if it reads the same from left to right and from right to left.\n‡\n‡\nString\nt\nis a subsequence of string\ns\nif\nt\ncan be obtained from\ns\nby removing several (possibly, zero or all) characters from\ns\nand concatenating the remaining ones, without changing their order. For example,\nodocs\nis a subsequence of\ncodeforces\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. Subsequently, the description of each test case follows.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the size of the string.\nOutput\nFor each test case, output any string of length\nn\nthat satisfies the above conditions.\nExample\ninput\nCopy\n3\n2\n3\n6\noutput\nCopy\nuo\niae\noeiiua\nNote\nIn the first example,\nuo\nhas only three palindrome subsequences:\nu\n,\no\n, and the empty string. It can be shown that there is no better answer.\nIn the third example,\noeiiua\nhas only eight palindrome subsequences:\no\n,\ne\n,\ni\n,\ni\n,\nu\n,\na\n,\nii\n, and the empty string. It can be shown that there is no better answer.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "G. Substring Compression",
        "description": "Let's define the operation of compressing a string\nt\n, consisting of at least\n2\ndigits from\n1\nto\n9\n, as follows:\nsplit it into an even number of non-empty substrings — let these substrings be\nt\n1\n,\nt\n2\n,…,\nt\nm\n(so,\nt=\nt\n1\n+\nt\n2\n+⋯+\nt\nm\n, where\n+\nis the concatenation operation);\nwrite the string\nt\n2\nt\n1\ntimes, then the string\nt\n4\nt\n3\ntimes, and so on.\nFor example, for a string \"12345\", one could do the following: split it into (\"1\", \"23\", \"4\", \"5\"), and write \"235555\".\nLet the function\nf(t)\nfor a string\nt\nreturn the minimum length of the string that can be obtained as a result of that process.\nYou are given a string\ns\n, consisting of\nn\ndigits from\n1\nto\n9\n, and an integer\nk\n. Calculate the value of the function\nf\nfor all contiguous substrings of\ns\nof length exactly\nk\n.\nInput\nThe first line contains two integers\nn\nand\nk\n(\n2≤k≤n≤2⋅\n10\n5\n).\nThe second line contains the string\ns\n(\n|s|=n\n), consisting only of digits from\n1\nto\n9\n.\nOutput\nOutput\nn−k+1\nintegers —\nf(\ns\n1,k\n),f(\ns\n2,k+1\n),…,f(\ns\nn−k+1,n\n)\n.\nExamples\ninput\nCopy\n4 4\n5999\noutput\nCopy\n14 \ninput\nCopy\n10 3\n1111111111\noutput\nCopy\n2 2 2 2 2 2 2 2 \ninput\nCopy\n11 4\n49998641312\noutput\nCopy\n12 18 17 15 12 7 7 2 ",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "dp",
            "matrices",
            "*3200"
        ]
    },
    {
        "title": "F. Make a Palindrome",
        "description": "You are given an array\na\nconsisting of\nn\nintegers.\nLet the function\nf(b)\nreturn the minimum number of operations needed to make an array\nb\na palindrome. The operations you can make are:\nchoose two adjacent elements\nbi\nand\nbi+1\n, remove them, and replace them with a single element equal to\n(bi+bi+1)\n;\nor choose an element\nbi>1\n, remove it, and replace it with two positive integers\nx\nand\ny\n(\nx>0\nand\ny>0\n) such that\nx+y=bi\n.\nFor example, from an array\nb=[2,1,3]\n, you can obtain the following arrays in one operation:\n[1,1,1,3]\n,\n[2,1,1,2]\n,\n[3,3]\n,\n[2,4]\n, or\n[2,1,2,1]\n.\nCalculate\n(\n∑\n1≤l≤r≤n\nf(a[l..r]))\n, where\na[l..r]\nis the subarray of\na\nfrom index\nl\nto index\nr\n, inclusive. In other words, find the sum of the values of the function\nf\nfor all subarrays of the array\na\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2000\n).\nThe second line contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤105\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, print a single integer — the sum of the values of the function\nf\nfor all subarrays of the array\na\n.\nExample\ninput\nCopy\n4\n3\n2 1 3\n4\n1 1 1 1\n5\n4 2 3 1 5\n4\n1 2 1 2\noutput\nCopy\n3\n0\n14\n5",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "greedy",
            "math",
            "*2600"
        ]
    },
    {
        "title": "E. Not a Nim Problem",
        "description": "Two players, Alice and Bob, are playing a game. They have\nn\npiles of stones, with the\ni\n-th pile initially containing\na\ni\nstones.\nOn their turn, a player can choose any pile of stones and take any positive number of stones from it, with one condition:\nlet the current number of stones in the pile be\nx\n. It is not allowed to take from the pile a number of stones\ny\nsuch that the greatest common divisor of\nx\nand\ny\nis not equal to\n1\n.\nThe player who cannot make a move loses. Both players play optimally (that is, if a player has a strategy that allows them to win, no matter how the opponent responds, they will win). Alice goes first.\nDetermine who will win.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n7\n).\nAdditional constraint on the input: the sum of\nn\nacross all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output Alice if Alice wins, or Bob if Bob wins.\nExample\ninput\nCopy\n3\n3\n3 2 9\n4\n3 3 6 1\n5\n1 2 3 4 5\noutput\nCopy\nBob\nAlice\nBob",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "games",
            "math",
            "number theory",
            "*2100"
        ]
    },
    {
        "title": "D. Colored Portals",
        "description": "There are\nn\ncities located on a straight line. The cities are numbered from\n1\nto\nn\n.\nPortals are used to move between cities. There are\n4\ncolors of portals: blue, green, red, and yellow. Each city has portals of two different colors. You can move from city\ni\nto city\nj\nif they have portals of the same color (for example, you can move between a \"blue-red\" city and a \"blue-green\" city). This movement costs\n|i−j|\ncoins.\nYour task is to answer\nq\nindependent queries: calculate the minimum cost to move from city\nx\nto city\ny\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the number of cities and the number of queries, respectively.\nThe second line contains\nn\nstrings of the following types: BG, BR, BY, GR, GY, or RY; the\ni\n-th of them describes the portals located in the\ni\n-th city; the symbol B indicates that there is a blue portal in the city, G — green, R — red, and Y — yellow.\nThe\nj\n-th of the next\nq\nlines contains two integers\nx\nj\nand\ny\nj\n(\n1≤\nx\nj\n,\ny\nj\n≤n\n) — the description of the\nj\n-th query.\nAdditional constraints on the input:\nthe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n;\nthe sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, print a single integer — the minimum cost to move from city\nx\nto city\ny\n(or\n−1\nif it is impossible).\nExample\ninput\nCopy\n2\n4 5\nBR BR GY GR\n1 2\n3 1\n4 4\n1 4\n4 2\n2 1\nBG RY\n1 2\noutput\nCopy\n1\n4\n0\n3\n2\n-1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "graphs",
            "greedy",
            "implementation",
            "shortest paths",
            "*1600"
        ]
    },
    {
        "title": "C. Splitting Items",
        "description": "Alice and Bob have\nn\nitems they'd like to split between them, so they decided to play a game. All items have a cost, and the\ni\n-th item costs\na\ni\n. Players move in turns starting from Alice.\nIn each turn, the player chooses one of the remaining items and takes it. The game goes on until no items are left.\nLet's say that\nA\nis the total cost of items taken by Alice and\nB\nis the total cost of Bob's items. The resulting score of the game then will be equal to\nA−B\n.\nAlice wants to maximize the score, while Bob wants to minimize it. Both Alice and Bob will play optimally.\nBut the game will take place tomorrow, so today Bob can modify the costs a little. He can increase the costs\na\ni\nof several (possibly none or all) items by an integer value (possibly, by the same value or by different values for each item). However, the total increase must be less than or equal to\nk\n. Otherwise, Alice may suspect something. Note that Bob can't decrease costs, only increase.\nWhat is the minimum possible score Bob can achieve?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. Then\nt\ncases follow.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n;\n0≤k≤\n10\n9\n) — the number of items and the maximum total increase Bob can make.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the initial costs of the items.\nIt's guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum possible score\nA−B\nafter Bob increases the costs of several (possibly none or all) items.\nExample\ninput\nCopy\n4\n2 5\n1 10\n3 0\n10 15 12\n4 6\n3 1 2 4\n2 4\n6 9\noutput\nCopy\n4\n13\n0\n0\nNote\nIn the first test case, Bob can increase\na\n1\nby\n5\n, making costs equal to\n[6,10]\n. Tomorrow, Alice will take\n10\nand Bob will take\n6\n. The total score will be equal to\n10−6=4\n, and it's the minimum possible.\nIn the second test case, Bob can't change costs. So the score will be equal to\n(15+10)−12=13\n, since Alice will take\n15\n, Bob will take\n12\n, and Alice —\n10\n.\nIn the third test case, Bob, for example, can increase\na\n1\nby\n1\n,\na\n2\nby\n3\n, and\na\n3\nby\n2\n. The total change is equal to\n1+3+2≤6\nand costs will be equal to\n[4,4,4,4]\n. Obviously, the score will be equal to\n(4+4)−(4+4)=0\n.\nIn the fourth test case, Bob can increase\na\n1\nby\n3\n, making costs equal to\n[9,9]\n. The score will be equal to\n9−9=0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "sortings",
            "*1100"
        ]
    },
    {
        "title": "B. Game with Doors",
        "description": "There are\n100\nrooms arranged in a row and\n99\ndoors between them; the\ni\n-th door connects rooms\ni\nand\ni+1\n. Each door can be either locked or unlocked. Initially, all doors are unlocked.\nWe say that room\nx\nis reachable from room\ny\nif all doors between them are unlocked.\nYou know that:\nAlice is in some room from the segment\n[l,r]\n;\nBob is in some room from the segment\n[L,R]\n;\nAlice and Bob are in different rooms.\nHowever, you don't know the exact rooms they are in.\nYou don't want Alice and Bob to be able to reach each other, so you are going to lock some doors to prevent that. What's the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nl\nand\nr\n(\n1≤l<r≤100\n) — the bounds of the segment of rooms where Alice is located.\nThe second line of each test case contains two integers\nL\nand\nR\n(\n1≤L<R≤100\n) — the bounds of the segment of rooms where Bob is located.\nOutput\nFor each test case, print a single integer — the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments.\nExample\ninput\nCopy\n4\n1 2\n3 4\n2 5\n2 5\n3 7\n6 7\n4 5\n2 8\noutput\nCopy\n1\n3\n2\n3\nNote\nIn the first test case, it is sufficient to lock the door between rooms\n2\nand\n3\n.\nIn the second test case, the following doors have to be locked:\n(2,3)\n,\n(3,4)\n,\n(4,5)\n.\nIn the third test case, the following doors have to be locked:\n(5,6)\nand\n(6,7)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ]
    },
    {
        "title": "A. Closest Point",
        "description": "Consider a set of points on a line. The distance between two points\ni\nand\nj\nis\n|i−j|\n.\nThe point\ni\nfrom the set is the closest to the point\nj\nfrom the set, if there is no other point\nk\nin the set such that the distance from\nj\nto\nk\nis strictly less than the distance from\nj\nto\ni\n. In other words, all other points from the set have distance to\nj\ngreater or equal to\n|i−j|\n.\nFor example, consider a set of points\n{1,3,5,8}\n:\nfor the point\n1\n, the closest point is\n3\n(other points have distance greater than\n|1−3|=2\n);\nfor the point\n3\n, there are two closest points:\n1\nand\n5\n;\nfor the point\n5\n, the closest point is\n3\n(but not\n8\n, since its distance is greater than\n|3−5|\n);\nfor the point\n8\n, the closest point is\n5\n.\nYou are given a set of points. You have to add an integer point into this set in such a way that it is different from every existing point in the set, and it becomes the closest point to every point in the set. Is it possible?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n2≤n≤40\n) — the number of points in the set;\nthe second line contains\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n1≤\nx\n1\n<\nx\n2\n<⋯<\nx\nn\n≤100\n) — the points from the set.\nOutput\nFor each test case, print YES if it is possible to add a new point according to the conditions from the statement. Otherwise, print NO.\nExample\ninput\nCopy\n3\n2\n3 8\n2\n5 6\n6\n1 2 3 4 5 10\noutput\nCopy\nYES\nNO\nNO\nNote\nIn the first example, the point\n7\nwill be the closest to both\n3\nand\n8\n.\nIn the second example, it is impossible to add an integer point so that it becomes the closest to both\n5\nand\n6\n, and is different from both of them.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Turtle and Three Sequences",
        "description": "Piggy gives Turtle three sequences\na\n1\n,\na\n2\n,…,\na\nn\n,\nb\n1\n,\nb\n2\n,…,\nb\nn\n, and\nc\n1\n,\nc\n2\n,…,\nc\nn\n.\nTurtle will choose a subsequence of\n1,2,…,n\nof length\nm\n, let it be\np\n1\n,\np\n2\n,…,\np\nm\n. The subsequence should satisfy the following conditions:\na\np\n1\n≤\na\np\n2\n≤⋯≤\na\np\nm\n;\nAll\nb\np\ni\nfor all indices\ni\nare pairwise distinct, i.e., there don't exist two different indices\ni\n,\nj\nsuch that\nb\np\ni\n=\nb\np\nj\n.\nHelp him find the maximum value of\n∑\ni=1\nm\nc\np\ni\n, or tell him that it is impossible to choose a subsequence of length\nm\nthat satisfies the conditions above.\nRecall that a sequence\na\nis a subsequence of a sequence\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n1≤n≤3000\n,\n1≤m≤5\n) — the lengths of the three sequences and the required length of the subsequence.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the sequence\na\n.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n) — the elements of the sequence\nb\n.\nThe fourth line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n4\n) — the elements of the sequence\nc\n.\nOutput\nOutput a single integer — the maximum value of\n∑\ni=1\nm\nc\np\ni\n. If it is impossible to choose a subsequence of length\nm\nthat satisfies the conditions above, output\n−1\n.\nExamples\ninput\nCopy\n4 2\n2 3 4 2\n1 3 3 2\n1 4 2 3\noutput\nCopy\n5\ninput\nCopy\n7 3\n1 4 5 2 3 6 7\n1 2 2 1 1 3 2\n1 5 6 7 3 2 4\noutput\nCopy\n13\ninput\nCopy\n5 3\n1 2 3 4 5\n1 1 2 1 2\n5 4 3 2 1\noutput\nCopy\n-1\nNote\nIn the first example, we can choose\np=[1,2]\n, then\nc\np\n1\n+\nc\np\n2\n=1+4=5\n. We can't choose\np=[2,4]\nsince\na\n2\n>\na\n4\n, violating the first condition. We can't choose\np=[2,3]\neither since\nb\n2\n=\nb\n3\n, violating the second condition. We can choose\np=[1,4]\n, but\nc\n1\n+\nc\n4\n=4\n, which isn't maximum.\nIn the second example, we can choose\np=[4,6,7]\n.\nIn the third example, it is impossible to choose a subsequence of length\n3\nthat satisfies both of the conditions.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "math",
            "probabilities",
            "two pointers",
            "*2800"
        ]
    },
    {
        "title": "E2. Turtle and Inversions (Hard Version)",
        "description": "This is a hard version of this problem. The differences between the versions are the constraint on\nm\nand\nr\ni\n<\nl\ni+1\nholds for each\ni\nfrom\n1\nto\nm−1\nin the easy version. You can make hacks only if both versions of the problem are solved.\nTurtle gives you\nm\nintervals\n[\nl\n1\n,\nr\n1\n],[\nl\n2\n,\nr\n2\n],…,[\nl\nm\n,\nr\nm\n]\n. He thinks that a permutation\np\nis interesting if there exists an integer\nk\ni\nfor every interval (\nl\ni\n≤\nk\ni\n<\nr\ni\n), and if he lets\na\ni\n=\nmax\nj=\nl\ni\nk\ni\np\nj\n,\nb\ni\n=\nmin\nj=\nk\ni\n+1\nr\ni\np\nj\nfor every integer\ni\nfrom\n1\nto\nm\n, the following condition holds:\nmax\ni=1\nm\na\ni\n<\nmin\ni=1\nm\nb\ni\nm\nTurtle wants you to calculate the maximum number of inversions of all interesting permutations of length\nn\n, or tell him if there is no interesting permutation.\nAn inversion of a permutation\np\nis a pair of integers\n(i,j)\n(\n1≤i<j≤n\n) such that\np\ni\n>\np\nj\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n2≤n≤5⋅\n10\n3\n,0≤m≤5⋅\n10\n3\n) — the length of the permutation and the number of intervals.\nThe\ni\n-th of the following\nm\nlines contains two integers\nl\ni\n,\nr\ni\n(\n1≤\nl\ni\n<\nr\ni\n≤n\n) — the\ni\n-th interval. Note that there may exist identical intervals (i.e., there may exist two different indices\ni,j\nsuch that\nl\ni\n=\nl\nj\nand\nr\ni\n=\nr\nj\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n3\nand the sum of\nm\nover all test cases does not exceed\n5⋅\n10\n3\n.\nOutput\nFor each test case, if there is no interesting permutation, output a single integer\n−1\n.\nOtherwise, output a single integer — the maximum number of inversions.\nExample\ninput\nCopy\n8\n2 0\n2 1\n1 2\n5 1\n2 4\n8 3\n1 4\n2 5\n7 8\n7 2\n1 4\n4 7\n7 3\n1 2\n1 7\n3 7\n7 4\n1 3\n4 7\n1 3\n4 7\n7 3\n1 2\n3 4\n5 6\noutput\nCopy\n1\n0\n8\n18\n-1\n-1\n15\n15\nNote\nIn the third test case, the interesting permutation with the maximum number of inversions is\n[5,2,4,3,1]\n.\nIn the fourth test case, the interesting permutation with the maximum number of inversions is\n[4,3,8,7,6,2,1,5]\n. In this case, we can let\n[\nk\n1\n,\nk\n2\n,\nk\n3\n]=[2,2,7]\n.\nIn the fifth and the sixth test case, it can be proven that there is no interesting permutation.\nIn the seventh test case, the interesting permutation with the maximum number of inversions is\n[4,7,6,3,2,1,5]\n. In this case, we can let\n[\nk\n1\n,\nk\n2\n,\nk\n3\n,\nk\n4\n]=[1,6,1,6]\n.\nIn the eighth test case, the interesting permutation with the maximum number of inversions is\n[4,7,3,6,2,5,1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "math",
            "two pointers",
            "*2700"
        ]
    },
    {
        "title": "E1. Turtle and Inversions (Easy Version)",
        "description": "This is an easy version of this problem. The differences between the versions are the constraint on\nm\nand\nr\ni\n<\nl\ni+1\nholds for each\ni\nfrom\n1\nto\nm−1\nin the easy version. You can make hacks only if both versions of the problem are solved.\nTurtle gives you\nm\nintervals\n[\nl\n1\n,\nr\n1\n],[\nl\n2\n,\nr\n2\n],…,[\nl\nm\n,\nr\nm\n]\n. He thinks that a permutation\np\nis interesting if there exists an integer\nk\ni\nfor every interval (\nl\ni\n≤\nk\ni\n<\nr\ni\n), and if he lets\na\ni\n=\nmax\nj=\nl\ni\nk\ni\np\nj\n,\nb\ni\n=\nmin\nj=\nk\ni\n+1\nr\ni\np\nj\nfor every integer\ni\nfrom\n1\nto\nm\n, the following condition holds:\nmax\ni=1\nm\na\ni\n<\nmin\ni=1\nm\nb\ni\nm\nTurtle wants you to calculate the maximum number of inversions of all interesting permutations of length\nn\n, or tell him if there is no interesting permutation.\nAn inversion of a permutation\np\nis a pair of integers\n(i,j)\n(\n1≤i<j≤n\n) such that\np\ni\n>\np\nj\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n2≤n≤5⋅\n10\n3\n,0≤m≤\nn\n2\n) — the length of the permutation and the number of intervals.\nThe\ni\n-th of the following\nm\nlines contains two integers\nl\ni\n,\nr\ni\n(\n1≤\nl\ni\n<\nr\ni\n≤n\n) — the\ni\n-th interval.\nAdditional constraint on the input in this version:\nr\ni\n<\nl\ni+1\nholds for each\ni\nfrom\n1\nto\nm−1\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n3\n.\nOutput\nFor each test case, if there is no interesting permutation, output a single integer\n−1\n.\nOtherwise, output a single integer — the maximum number of inversions.\nExample\ninput\nCopy\n6\n2 0\n2 1\n1 2\n5 1\n2 4\n8 2\n1 4\n6 8\n7 2\n1 3\n4 7\n7 3\n1 2\n3 4\n5 6\noutput\nCopy\n1\n0\n8\n21\n15\n15\nNote\nIn the third test case, the interesting permutation with the maximum number of inversions is\n[5,2,4,3,1]\n.\nIn the fourth test case, the interesting permutation with the maximum number of inversions is\n[4,8,7,6,3,2,1,5]\n. In this case, we can let\n[\nk\n1\n,\nk\n2\n]=[1,7]\n.\nIn the fifth test case, the interesting permutation with the maximum number of inversions is\n[4,7,6,3,2,1,5]\n.\nIn the sixth test case, the interesting permutation with the maximum number of inversions is\n[4,7,3,6,2,5,1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "divide and conquer",
            "dp",
            "greedy",
            "math",
            "*2600"
        ]
    },
    {
        "title": "D2. Turtle and a MEX Problem (Hard Version)",
        "description": "The two versions are different problems. In this version of the problem, you can't choose the same integer twice or more. You can make hacks only if both versions are solved.\nOne day, Turtle was playing with\nn\nsequences. Let the length of the\ni\n-th sequence be\nl\ni\n. Then the\ni\n-th sequence was\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n.\nPiggy gave Turtle a problem to solve when Turtle was playing. The statement of the problem was:\nThere was a non-negative integer\nx\nat first. Turtle would perform an arbitrary number (possibly zero) of operations on the integer.\nIn each operation, Turtle could choose an integer\ni\nsuch that\n1≤i≤n\nand\ni\nwasn't chosen before, and set\nx\nto\nmex\n†\n(x,\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n)\n.\nTurtle was asked to find the answer, which was the maximum value of\nx\nafter performing an arbitrary number of operations.\nTurtle solved the above problem without difficulty. He defined\nf(k)\nas the answer to the above problem when the initial value of\nx\nwas\nk\n.\nThen Piggy gave Turtle a non-negative integer\nm\nand asked Turtle to find the value of\n∑\ni=0\nm\nf(i)\n(i.e., the value of\nf(0)+f(1)+…+f(m)\n). Unfortunately, he couldn't solve this problem. Please help him!\n†\nmex(\nc\n1\n,\nc\n2\n,…,\nc\nk\n)\n†\nis defined as the smallest non-negative integer\nx\nwhich does not occur in the sequence\nc\n. For example,\nmex(2,2,0,3)\nis\n1\n,\nmex(1,2)\nis\n0\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n1≤n≤2⋅\n10\n5\n,0≤m≤\n10\n9\n).\nEach of the following\nn\nlines contains several integers. The first integer\nl\ni\n(\n1≤\nl\ni\n≤2⋅\n10\n5\n) represents the length of the\ni\n-th sequence, and the following\nl\ni\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n(\n0≤\na\ni,j\n≤\n10\n9\n) represent the elements of the\ni\n-th sequence.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nand the sum of\n∑\nl\ni\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the value of\n∑\ni=0\nm\nf(i)\n.\nExample\ninput\nCopy\n6\n3 4\n2 0 2\n3 2 3 3\n4 7 0 1 5\n3 4\n5 0 2 0 4 11\n1 1\n5 1 3 0 3 3\n2 50\n2 1 2\n2 1 2\n1 1\n7 1 2 4 1 4 9 5\n4 114514\n2 2 2\n5 7 3 6 0 3\n3 0 1 1\n5 0 9 2 1 5\n5 1919810\n1 2\n2 324003 0\n3 1416324 2 1460728\n4 1312631 2 0 1415195\n5 1223554 192248 2 1492515 725556\noutput\nCopy\n16\n18\n1281\n4\n6556785365\n1842836177961\nNote\nIn the first test case, when\nx\nis initially\n2\n, Turtle can choose\ni=3\nand set\nx\nto\nmex(x,\na\n3,1\n,\na\n3,2\n,\na\n3,3\n,\na\n3,4\n)=mex(2,7,0,1,5)=3\n. It can be proved that Turtle can't make the value of\nx\ngreater than\n3\n, so\nf(2)=3\n.\nIt can be seen that\nf(0)=3\n,\nf(1)=3\n,\nf(2)=3\n,\nf(3)=3\n, and\nf(4)=4\n. So\nf(0)+f(1)+f(2)+f(3)+f(4)=3+3+3+3+4=16\n.\nIn the second test case, when\nx\nis initially\n1\n, Turtle can choose\ni=1\nand set\nx\nto\nmex(x,\na\n1,1\n,\na\n1,2\n,\na\n1,3\n,\na\n1,4\n,\na\n1,5\n)=mex(1,0,2,0,4,11)=3\n. It can be proved that Turtle can't make the value of\nx\ngreater than\n3\n, so\nf(1)=3\n.\nIt can be seen that\nf(0)=4\n,\nf(1)=3\n,\nf(2)=4\n,\nf(3)=3\n, and\nf(4)=4\n. So\nf(0)+f(1)+f(2)+f(3)+f(4)=4+3+4+3+4=18\n.\nIn the fourth test case, it can be seen that\nf(0)=3\nand\nf(1)=1\n. So\nf(0)+f(1)=3+1=4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "graphs",
            "greedy",
            "implementation",
            "math",
            "*2100"
        ]
    },
    {
        "title": "D1. Turtle and a MEX Problem (Easy Version)",
        "description": "The two versions are different problems. In this version of the problem, you can choose the same integer twice or more. You can make hacks only if both versions are solved.\nOne day, Turtle was playing with\nn\nsequences. Let the length of the\ni\n-th sequence be\nl\ni\n. Then the\ni\n-th sequence was\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n.\nPiggy gave Turtle a problem to solve when Turtle was playing. The statement of the problem was:\nThere was a non-negative integer\nx\nat first. Turtle would perform an arbitrary number (possibly zero) of operations on the integer.\nIn each operation, Turtle could choose an integer\ni\nsuch that\n1≤i≤n\n, and set\nx\nto\nmex\n†\n(x,\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n)\n.\nTurtle was asked to find the answer, which was the maximum value of\nx\nafter performing an arbitrary number of operations.\nTurtle solved the above problem without difficulty. He defined\nf(k)\nas the answer to the above problem when the initial value of\nx\nwas\nk\n.\nThen Piggy gave Turtle a non-negative integer\nm\nand asked Turtle to find the value of\n∑\ni=0\nm\nf(i)\n(i.e., the value of\nf(0)+f(1)+…+f(m)\n). Unfortunately, he couldn't solve this problem. Please help him!\n†\nmex(\nc\n1\n,\nc\n2\n,…,\nc\nk\n)\n†\nis defined as the smallest non-negative integer\nx\nwhich does not occur in the sequence\nc\n. For example,\nmex(2,2,0,3)\nis\n1\n,\nmex(1,2)\nis\n0\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n1≤n≤2⋅\n10\n5\n,0≤m≤\n10\n9\n).\nEach of the following\nn\nlines contains several integers. The first integer\nl\ni\n(\n1≤\nl\ni\n≤2⋅\n10\n5\n) represents the length of the\ni\n-th sequence, and the following\nl\ni\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,\nl\ni\n(\n0≤\na\ni,j\n≤\n10\n9\n) represent the elements of the\ni\n-th sequence.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n, and the sum of\n∑\nl\ni\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the value of\n∑\ni=0\nm\nf(i)\n.\nExample\ninput\nCopy\n6\n3 4\n2 0 2\n3 2 3 3\n4 7 0 1 5\n3 4\n5 0 2 0 4 11\n1 1\n5 1 3 0 3 3\n2 50\n2 1 2\n2 1 2\n1 1\n7 1 2 4 1 4 9 5\n4 114514\n2 2 2\n5 7 3 6 0 3\n3 0 1 1\n5 0 9 2 1 5\n5 1919810\n1 2\n2 324003 0\n3 1416324 2 1460728\n4 1312631 2 0 1415195\n5 1223554 192248 2 1492515 725556\noutput\nCopy\n16\n20\n1281\n6\n6556785365\n1842836177961\nNote\nIn the first test case, when\nx\nis initially\n2\n, Turtle can choose\ni=3\nand set\nx\nto\nmex(x,\na\n3,1\n,\na\n3,2\n,\na\n3,3\n,\na\n3,4\n)=mex(2,7,0,1,5)=3\n. It can be proved that Turtle can't make the value of\nx\ngreater than\n3\n, so\nf(2)=3\n.\nIt can be seen that\nf(0)=3\n,\nf(1)=3\n,\nf(2)=3\n,\nf(3)=3\n, and\nf(4)=4\n. So\nf(0)+f(1)+f(2)+f(3)+f(4)=3+3+3+3+4=16\n.\nIn the second test case, when\nx\nis initially\n1\n, Turtle can choose\ni=3\nand set\nx\nto\nmex(x,\na\n3,1\n,\na\n3,2\n,\na\n3,3\n,\na\n3,4\n,\na\n3,5\n)=mex(1,1,3,0,3,3)=2\n, and choose\ni=3\nand set\nx\nto\nmex(x,\na\n3,1\n,\na\n3,2\n,\na\n3,3\n,\na\n3,4\n,\na\n3,5\n)=mex(2,1,3,0,3,3)=4\n. It can be proved that Turtle can't make the value of\nx\ngreater than\n4\n, so\nf(1)=4\n.\nIt can be seen that\nf(0)=4\n,\nf(1)=4\n,\nf(2)=4\n,\nf(3)=4\n, and\nf(4)=4\n. So\nf(0)+f(1)+f(2)+f(3)+f(4)=4+4+4+4+4=20\n.\nIn the fourth test case, it can be seen that\nf(0)=3\nand\nf(1)=3\n. So\nf(0)+f(1)=3+3=6\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1500"
        ]
    },
    {
        "title": "C. Turtle and Good Pairs",
        "description": "Turtle gives you a string\ns\n, consisting of lowercase Latin letters.\nTurtle considers a pair of integers\n(i,j)\n(\n1≤i<j≤n\n) to be a pleasant pair if and only if there exists an integer\nk\nsuch that\ni≤k<j\nand both of the following two conditions hold:\ns\nk\n≠\ns\nk+1\n;\ns\nk\n≠\ns\ni\nor\ns\nk+1\n≠\ns\nj\n.\nBesides, Turtle considers a pair of integers\n(i,j)\n(\n1≤i<j≤n\n) to be a good pair if and only if\ns\ni\n=\ns\nj\nor\n(i,j)\nis a pleasant pair.\nTurtle wants to reorder the string\ns\nso that the number of good pairs is maximized. Please help him!\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the string.\nThe second line of each test case contains a string\ns\nof length\nn\n, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the string\ns\nafter reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\nExample\ninput\nCopy\n5\n3\nabc\n5\nedddf\n6\nturtle\n8\npppppppp\n10\ncodeforces\noutput\nCopy\nacb\nddedf\nurtlet\npppppppp\ncodeforces\nNote\nIn the first test case,\n(1,3)\nis a good pair in the reordered string. It can be seen that we can't reorder the string so that the number of good pairs is greater than\n1\n. bac and cab can also be the answer.\nIn the second test case,\n(1,2)\n,\n(1,4)\n,\n(1,5)\n,\n(2,4)\n,\n(2,5)\n,\n(3,5)\nare good pairs in the reordered string. efddd can also be the answer.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ]
    },
    {
        "title": "B. Turtle and Piggy Are Playing a Game 2",
        "description": "Turtle and Piggy are playing a game on a sequence. They are given a sequence\na\n1\n,\na\n2\n,…,\na\nn\n, and Turtle goes first. Turtle and Piggy alternate in turns (so, Turtle does the first turn, Piggy does the second, Turtle does the third, etc.).\nThe game goes as follows:\nLet the current length of the sequence be\nm\n. If\nm=1\n, the game ends.\nIf the game does not end and it's Turtle's turn, then Turtle must choose an integer\ni\nsuch that\n1≤i≤m−1\n, set\na\ni\nto\nmax(\na\ni\n,\na\ni+1\n)\n, and remove\na\ni+1\n.\nIf the game does not end and it's Piggy's turn, then Piggy must choose an integer\ni\nsuch that\n1≤i≤m−1\n, set\na\ni\nto\nmin(\na\ni\n,\na\ni+1\n)\n, and remove\na\ni+1\n.\nTurtle wants to maximize the value of\na\n1\nin the end, while Piggy wants to minimize the value of\na\n1\nin the end. Find the value of\na\n1\nin the end if both players play optimally.\nYou can refer to notes for further clarification.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the length of the sequence.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the elements of the sequence\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the value of\na\n1\nin the end if both players play optimally.\nExample\ninput\nCopy\n5\n2\n1 2\n3\n1 1 2\n3\n1 2 3\n5\n3 1 2 2 3\n10\n10 2 5 2 7 9 2 5 10 7\noutput\nCopy\n2\n1\n2\n2\n7\nNote\nIn the first test case, initially\na=[1,2]\n. Turtle can only choose\ni=1\n. Then he will set\na\n1\nto\nmax(\na\n1\n,\na\n2\n)=2\nand remove\na\n2\n. The sequence\na\nbecomes\n[2]\n. Then the length of the sequence becomes\n1\n, and the game will end. The value of\na\n1\nis\n2\n, so you should output\n2\n.\nIn the second test case, one of the possible game processes is as follows:\nInitially\na=[1,1,2]\n.\nTurtle can choose\ni=2\n. Then he will set\na\n2\nto\nmax(\na\n2\n,\na\n3\n)=2\nand remove\na\n3\n. The sequence\na\nwill become\n[1,2]\n.\nPiggy can choose\ni=1\n. Then he will set\na\n1\nto\nmin(\na\n1\n,\na\n2\n)=1\nand remove\na\n2\n. The sequence\na\nwill become\n[1]\n.\nThe length of the sequence becomes\n1\n, so the game will end. The value of\na\n1\nwill be\n1\nin the end.\nIn the fourth test case, one of the possible game processes is as follows:\nInitially\na=[3,1,2,2,3]\n.\nTurtle can choose\ni=4\n. Then he will set\na\n4\nto\nmax(\na\n4\n,\na\n5\n)=3\nand remove\na\n5\n. The sequence\na\nwill become\n[3,1,2,3]\n.\nPiggy can choose\ni=3\n. Then he will set\na\n3\nto\nmin(\na\n3\n,\na\n4\n)=2\nand remove\na\n4\n. The sequence\na\nwill become\n[3,1,2]\n.\nTurtle can choose\ni=2\n. Then he will set\na\n2\nto\nmax(\na\n2\n,\na\n3\n)=2\nand remove\na\n3\n. The sequence\na\nwill become\n[3,2]\n.\nPiggy can choose\ni=1\n. Then he will set\na\n1\nto\nmin(\na\n1\n,\na\n2\n)=2\nand remove\na\n2\n. The sequence\na\nwill become\n[2]\n.\nThe length of the sequence becomes\n1\n, so the game will end. The value of\na\n1\nwill be\n2\nin the end.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "A. Turtle and Good Strings",
        "description": "Turtle thinks a string\ns\nis a good string if there exists a sequence of strings\nt\n1\n,\nt\n2\n,…,\nt\nk\n(\nk\nis an arbitrary integer) such that:\nk≥2\n.\ns=\nt\n1\n+\nt\n2\n+…+\nt\nk\n, where\n+\nrepresents the concatenation operation. For example,\nabc=a+bc\n.\nFor all\n1≤i<j≤k\n, the first character of\nt\ni\nisn't equal to the last character of\nt\nj\n.\nTurtle is given a string\ns\nconsisting of lowercase Latin letters. Please tell him whether the string\ns\nis a good string!\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤100\n) — the length of the string.\nThe second line of each test case contains a string\ns\nof length\nn\n, consisting of lowercase Latin letters.\nOutput\nFor each test case, output \"YES\" if the string\ns\nis a good string, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n4\n2\naa\n3\naba\n4\nabcb\n12\nabcabcabcabc\noutput\nCopy\nNo\nnO\nYes\nYES\nNote\nIn the first test case, the sequence of strings\na,a\nsatisfies the condition\ns=\nt\n1\n+\nt\n2\n+…+\nt\nk\n, but the first character of\nt\n1\nis equal to the last character of\nt\n2\n. It can be seen that there doesn't exist any sequence of strings which satisfies all of the conditions, so the answer is \"NO\".\nIn the third test case, the sequence of strings\nab,cb\nsatisfies all of the conditions.\nIn the fourth test case, the sequence of strings\nabca,bcab,cabc\nsatisfies all of the conditions.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*800"
        ]
    },
    {
        "title": "H. Counting 101",
        "description": "It's been a long summer's day, with the constant chirping of cicadas and the heat which never seemed to end. Finally, it has drawn to a close. The showdown has passed, the gates are open, and only a gentle breeze is left behind.\nYour predecessors had taken their final bow; it's your turn to take the stage.\nSorting through some notes that were left behind, you found a curious statement named Problem 101:\nGiven a positive integer sequence\na\n1\n,\na\n2\n,…,\na\nn\n, you can operate on it any number of times. In an operation, you choose three consecutive elements\na\ni\n,\na\ni+1\n,\na\ni+2\n, and merge them into one element\nmax(\na\ni\n+1,\na\ni+1\n,\na\ni+2\n+1)\n. Please calculate the maximum number of operations you can do without creating an element greater than\nm\n.\nAfter some thought, you decided to propose the following problem, named Counting 101:\nGiven\nn\nand\nm\n. For each\nk=0,1,…,⌊\nn−1\n2\n⌋\n, please find the number of integer sequences\na\n1\n,\na\n2\n,…,\na\nn\nwith elements in\n[1,m]\n, such that when used as input for Problem 101, the answer is\nk\n. As the answer can be very large, please print it modulo\n10\n9\n+7\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n3\n). The description of the test cases follows.\nThe only line of each test case contains two integers\nn\n,\nm\n(\n1≤n≤130\n,\n1≤m≤30\n).\nOutput\nFor each test case, output\n⌊\nn+1\n2\n⌋\n⌊\nnumbers. The\ni\n-th number is the number of valid sequences such that when used as input for Problem 101, the answer is\ni−1\n, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n2\n3 2\n10 10\noutput\nCopy\n6 2 \n1590121 23399118 382293180 213020758 379696760 \nNote\nIn the first test case, there are\n2\n3\n=8\ncandidate sequences. Among them, you can operate on\n[1,2,1]\nand\n[1,1,1]\nonce; you cannot operate on the other\n6\nsequences.",
        "time_limit": "10.1 seconds",
        "memory_limit": "1010 megabytes",
        "tags": [
            "greedy",
            "*3500"
        ]
    },
    {
        "title": "G. Lattice Optimizing",
        "description": "Consider a grid graph with\nn\nrows and\nn\ncolumns. Let the cell in row\nx\nand column\ny\nbe\n(x,y)\n. There exists a directed edge from\n(x,y)\nto\n(x+1,y)\n, with non-negative integer value\nd\nx,y\n, for all\n1≤x<n,1≤y≤n\n, and there also exists a directed edge from\n(x,y)\nto\n(x,y+1)\n, with non-negative integer value\nr\nx,y\n, for all\n1≤x≤n,1≤y<n\n.\nInitially, you are at\n(1,1)\n, with an empty set\nS\n. You need to walk along the edges and eventually reach\n(n,n)\n. Whenever you pass an edge, its value will be inserted into\nS\n. Please maximize the MEX\n∗\nof\nS\nwhen you reach\n(n,n)\n.\n∗\nThe MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:\nThe MEX of\n[2,2,1]\nis\n0\n, because\n0\ndoes not belong to the array.\nThe MEX of\n[3,1,0,1]\nis\n2\n, because\n0\nand\n1\nbelong to the array, but\n2\ndoes not.\nThe MEX of\n[0,3,1,2]\nis\n4\n, because\n0,1,2\n, and\n3\nbelong to the array, but\n4\ndoes not.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤20\n) — the number of rows and columns.\nEach of the next\nn−1\nlines contains\nn\nintegers separated by single spaces — the matrix\nd\n(\n0≤\nd\nx,y\n≤2n−2\n).\nEach of the next\nn\nlines contains\nn−1\nintegers separated by single spaces — the matrix\nr\n(\n0≤\nr\nx,y\n≤2n−2\n).\nIt is guaranteed that the sum of all\nn\n3\ndoes not exceed\n8000\n.\nOutput\nFor each test case, print a single integer — the maximum MEX of\nS\nwhen you reach\n(n,n)\n.\nExamples\ninput\nCopy\n2\n3\n1 0 2\n0 1 3\n2 1\n0 3\n3 0\n3\n1 2 0\n0 1 2\n2 0\n1 2\n0 1\noutput\nCopy\n3\n2\ninput\nCopy\n1\n10\n16 7 3 15 9 17 1 15 9 0\n4 3 1 12 13 10 10 14 6 12\n3 1 3 9 5 16 0 12 7 12\n11 4 8 7 13 7 15 13 9 2\n2 3 9 9 4 12 17 7 10 15\n10 6 15 17 13 6 15 9 4 9\n13 3 3 14 1 2 10 10 12 16\n8 2 9 13 18 7 1 6 2 6\n15 12 2 6 0 0 13 3 7 17\n7 3 17 17 10 15 12 14 15\n4 3 3 17 3 13 11 16 6\n16 17 7 7 12 5 2 4 10\n18 9 9 3 5 9 1 16 7\n1 0 4 2 10 10 12 2 1\n4 14 15 16 15 5 8 4 18\n7 18 10 11 2 0 14 8 18\n2 17 6 0 9 6 13 5 11\n5 15 7 11 6 3 17 14 5\n1 3 16 16 13 1 0 13 11\noutput\nCopy\n14\nNote\nIn the first test case, the grid graph and one of the optimal paths are as follows:\nIn the second test case, the grid graph and one of the optimal paths are as follows:",
        "time_limit": "7 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "hashing",
            "meet-in-the-middle",
            "*3400"
        ]
    },
    {
        "title": "F2. Court Blue (Hard Version)",
        "description": "This is the hard version of the problem. In this version, it is not guaranteed that\nn=m\n, and the time limit is higher. You can make hacks only if both versions of the problem are solved.\nIn the court of the Blue King, Lelle and Flamm are having a performance match. The match consists of several rounds. In each round, either Lelle or Flamm wins.\nLet\nW\nL\nand\nW\nF\ndenote the number of wins of Lelle and Flamm, respectively. The Blue King considers a match to be successful if and only if:\nafter every round,\ngcd(\nW\nL\n,\nW\nF\n)≤1\n;\nat the end of the match,\nW\nL\n≤n,\nW\nF\n≤m\n.\nNote that\ngcd(0,x)=gcd(x,0)=x\nfor every non-negative integer\nx\n.\nLelle and Flamm can decide to stop the match whenever they want, and the final score of the performance is\nl⋅\nW\nL\n+f⋅\nW\nF\n.\nPlease help Lelle and Flamm coordinate their wins and losses such that the performance is successful, and the total score of the performance is maximized.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe only line of each test case contains four integers\nn\n,\nm\n,\nl\n,\nf\n(\n2≤n≤m≤2⋅\n10\n7\n,\n1≤l,f≤\n10\n9\n):\nn\n,\nm\ngive the upper bound on the number of Lelle and Flamm's wins,\nl\nand\nf\ndetermine the final score of the performance.\nUnusual additional constraint: it is guaranteed that, for each test, there are no pairs of test cases with the same pair of\nn\n,\nm\n.\nOutput\nFor each test case, output a single integer — the maximum total score of a successful performance.\nExamples\ninput\nCopy\n8\n3 4 2 5\n4 4 1 4\n6 6 2 2\n7 9 2 3\n8 9 9 1\n2 7 1 4\n5 9 1 4\n5 6 6 7\noutput\nCopy\n22\n17\n18\n37\n77\n30\n41\n59\ninput\nCopy\n2\n3082823 20000000 1341 331\n20000000 20000000 3 5\noutput\nCopy\n10754065643\n159999991\ninput\nCopy\n1\n139 1293 193 412\noutput\nCopy\n559543\nNote\nIn the first test case, a possible performance is as follows:\nFlamm wins,\ngcd(0,1)=1\n.\nLelle wins,\ngcd(1,1)=1\n.\nFlamm wins,\ngcd(1,2)=1\n.\nFlamm wins,\ngcd(1,3)=1\n.\nFlamm wins,\ngcd(1,4)=1\n.\nLelle and Flamm agree to stop the match.\nThe final score is\n1⋅2+4⋅5=22\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "math",
            "number theory",
            "*2800"
        ]
    },
    {
        "title": "F1. Court Blue (Easy Version)",
        "description": "This is the easy version of the problem. In this version,\nn=m\nand the time limit is lower. You can make hacks only if both versions of the problem are solved.\nIn the court of the Blue King, Lelle and Flamm are having a performance match. The match consists of several rounds. In each round, either Lelle or Flamm wins.\nLet\nW\nL\nand\nW\nF\ndenote the number of wins of Lelle and Flamm, respectively. The Blue King considers a match to be successful if and only if:\nafter every round,\ngcd(\nW\nL\n,\nW\nF\n)≤1\n;\nat the end of the match,\nW\nL\n≤n,\nW\nF\n≤m\n.\nNote that\ngcd(0,x)=gcd(x,0)=x\nfor every non-negative integer\nx\n.\nLelle and Flamm can decide to stop the match whenever they want, and the final score of the performance is\nl⋅\nW\nL\n+f⋅\nW\nF\n.\nPlease help Lelle and Flamm coordinate their wins and losses such that the performance is successful, and the total score of the performance is maximized.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe only line of each test case contains four integers\nn\n,\nm\n,\nl\n,\nf\n(\n2≤n≤m≤2⋅\n10\n7\n,\n1≤l,f≤\n10\n9\n,\nn=m\n):\nn\n,\nm\ngives the upper bound on the number of Lelle and Flamm's wins,\nl\nand\nf\ndetermine the final score of the performance.\nUnusual additional constraint: it is guaranteed that, for each test, there are no pairs of test cases with the same pair of\nn\n,\nm\n.\nOutput\nFor each test case, output a single integer — the maximum total score of a successful performance.\nExamples\ninput\nCopy\n8\n3 3 2 5\n4 4 1 4\n6 6 2 2\n7 7 2 3\n9 9 9 1\n2 2 1 4\n5 5 1 4\n8 8 6 7\noutput\nCopy\n19\n17\n18\n33\n86\n9\n24\n86\ninput\nCopy\n1\n20000000 20000000 1341 331\noutput\nCopy\n33439999007\ninput\nCopy\n2\n1984 1984 19 84\n9982 9982 44 35\noutput\nCopy\n204143\n788403\nNote\nIn the first test case, a possible performance is as follows:\nFlamm wins,\ngcd(0,1)=1\n.\nLelle wins,\ngcd(1,1)=1\n.\nFlamm wins,\ngcd(1,2)=1\n.\nFlamm wins,\ngcd(1,3)=1\n.\nLelle wins,\ngcd(2,3)=1\n.\nLelle and Flamm agree to stop the match.\nThe final score is\n2⋅2+3⋅5=19\n.\nIn the third test case, a possible performance is as follows:\nFlamm wins,\ngcd(0,1)=1\n.\nLelle wins,\ngcd(1,1)=1\n.\nLelle wins,\ngcd(2,1)=1\n.\nLelle wins,\ngcd(3,1)=1\n.\nLelle wins,\ngcd(4,1)=1\n.\nLelle wins,\ngcd(5,1)=1\n.\nFlamm wins,\ngcd(5,2)=1\n.\nFlamm wins,\ngcd(5,3)=1\n.\nFlamm wins,\ngcd(5,4)=1\n.\nLelle and Flamm agree to stop the match.\nThe final score is\n5⋅2+4⋅2=18\n. Note that Lelle and Flamm can stop the match even if neither of them has\nn\nwins.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "math",
            "number theory",
            "*2600"
        ]
    },
    {
        "title": "E. Cosmic Rays",
        "description": "Given an array of integers\ns\n1\n,\ns\n2\n,…,\ns\nl\n, every second, cosmic rays will cause all\ns\ni\nsuch that\ni=1\nor\ns\ni\n≠\ns\ni−1\nto be deleted simultaneously, and the remaining parts will be concatenated together in order to form the new array\ns\n1\n,\ns\n2\n,…,\ns\nl\n′\n.\nDefine the strength of an array as the number of seconds it takes to become empty.\nYou are given an array of integers compressed in the form of\nn\npairs that describe the array left to right. Each pair\n(\na\ni\n,\nb\ni\n)\nrepresents\na\ni\ncopies of\nb\ni\n, i.e.\nb\ni\n,\nb\ni\n,⋯,\nb\ni\n\n\n\n\n\n\n\n\n\n\n\n\n\na\ni\n times\n.\nFor each\ni=1,2,…,n\n, please find the strength of the sequence described by the first\ni\npairs.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the length of sequence\na\n.\nThe next\nn\nlines contain two integers each\na\ni\n,\nb\ni\n(\n1≤\na\ni\n≤\n10\n9\n,0≤\nb\ni\n≤n\n) — the pairs which describe the sequence.\nIt is guaranteed that the sum of all\nn\ndoes not exceed\n3⋅\n10\n5\n.\nIt is guaranteed that for all\n1≤i<n\n,\nb\ni\n≠\nb\ni+1\nholds.\nOutput\nFor each test case, print one line containing\nn\nintegers — the answer for each prefix of pairs.\nExample\ninput\nCopy\n4\n4\n2 0\n1 1\n3 0\n5 1\n6\n4 6\n1 3\n4 6\n4 0\n7 6\n6 3\n7\n9 0\n7 1\n5 0\n7 1\n9 0\n1 1\n2 0\n10\n10 7\n4 9\n2 2\n7 9\n2 8\n8 5\n11 7\n15 5\n12 7\n4 0\noutput\nCopy\n2 2 4 5 \n4 4 7 7 10 10 \n9 9 9 9 9 9 10 \n10 10 10 10 10 10 12 15 15 15 \nNote\nIn the first test case, for the prefix of length\n4\n, the changes will be\n[0,0,1,0,0,0,1,1,1,1,1]→[0,0,0,1,1,1,1]→[0,0,1,1,1]→[0,1,1]→[1]→[]\n, so the array becomes empty after\n5\nseconds.\nIn the second test case, for the prefix of length\n4\n, the changes will be\n[6,6,6,6,3,6,6,6,6,0,0,0,0]→[6,6,6,6,6,6,0,0,0]→[6,6,6,6,6,0,0]→[6,6,6,6,0]→[6,6,6]→[6,6]→[6]→[]\n, so the array becomes empty after\n7\nseconds.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "*2300"
        ]
    },
    {
        "title": "D2. DFS Checker (Hard Version)",
        "description": "This is the hard version of the problem. In this version, you are given a generic tree and the constraints on\nn\nand\nq\nare higher. You can make hacks only if both versions of the problem are solved.\nYou are given a rooted tree consisting of\nn\nvertices. The vertices are numbered from\n1\nto\nn\n, and the root is the vertex\n1\n. You are also given a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\n.\nYou need to answer\nq\nqueries. For each query, you are given two integers\nx\n,\ny\n; you need to swap\np\nx\nand\np\ny\nand determine if\np\n1\n,\np\n2\n,…,\np\nn\nis a valid DFS order\n†\n†\nof the given tree.\nPlease note that the swaps are persistent through queries.\n†\n†\nA DFS order is found by calling the following\ndfs\nfunction on the given tree.\ndfs_order = []\n\nfunction dfs(v):\n    append v to the back of dfs_order\n    pick an arbitrary permutation s of children of v\n    for child in s:\n        dfs(child)\ndfs(1)\nNote that the DFS order is not unique.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nq\n(\n2≤n≤3⋅\n10\n5\n,\n2≤q≤\n10\n5\n) — the number of vertices in the tree and the number of queries.\nThe next line contains\nn−1\nintegers\na\n2\n,\na\n3\n,…,\na\nn\n(\n1≤\na\ni\n<i\n) — the parent of each vertex in the given tree.\nThe next line contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n, all\np\ni\nare distinct) — the initial permutation\np\n.\nThe next\nq\nlines each contain two integers\nx\n,\ny\n(\n1≤x,y≤n,x≠y\n) — the positions of the elements to swap in the permutation.\nIt is guaranteed that the sum of all\nn\ndoes not exceed\n3⋅\n10\n5\n, and the sum of all\nq\ndoes not exceed\n10\n5\n.\nOutput\nFor each test case, print\nq\nlines corresponding to the\nq\nqueries. For each query, output\nYES\nif there is a DFS order that exactly equals the current permutation, and output\nNO\notherwise.\nYou can output\nYes\nand\nNo\nin any case (for example, strings\nyEs\n,\nyes\n,\nYes\n, and\nYES\nwill be recognized as a positive response).\nExample\ninput\nCopy\n3\n3 3\n1 1\n1 2 3\n2 3\n3 2\n1 3\n7 4\n1 1 2 2 3 3\n1 2 3 4 5 6 7\n3 5\n2 5\n3 7\n4 6\n5 4\n1 1 3 4\n2 3 4 5 1\n5 1\n4 5\n3 4\n2 3\noutput\nCopy\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nNote\nIn the first test case, the permutation\np\n1\n,\np\n2\n,…,\np\nn\nafter each modification is\n[1,3,2],[1,2,3],[3,2,1]\n, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\nIn the second test case, the permutation\np\n1\n,\np\n2\n,…,\np\nn\nafter each modification is\n[1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]\n, respectively.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "graphs",
            "hashing",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "D1. DFS Checker (Easy Version)",
        "description": "This is the easy version of the problem. In this version, the given tree is a perfect binary tree and the constraints on\nn\nand\nq\nare lower. You can make hacks only if both versions of the problem are solved.\nYou are given a perfect binary tree\n†\n†\nconsisting of\nn\nvertices. The vertices are numbered from\n1\nto\nn\n, and the root is the vertex\n1\n. You are also given a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\n.\nYou need to answer\nq\nqueries. For each query, you are given two integers\nx\n,\ny\n; you need to swap\np\nx\nand\np\ny\nand determine if\np\n1\n,\np\n2\n,…,\np\nn\nis a valid DFS order\n‡\n‡\nof the given tree.\nPlease note that the swaps are persistent through queries.\n†\n†\nA perfect binary tree is a tree with vertex\n1\nas its root, with size\nn=\n2\nk\n−1\nfor a positive integer\nk\n, and where the parent of each vertex\ni\n(\n1<i≤n\n) is\n⌊\ni\n2\n⌋\n⌊\n. Thus, all leaves of this tree are at a distance\nk−1\nfrom the root.\n‡\n‡\nA DFS order is found by calling the following\ndfs\nfunction on the given tree.\ndfs_order = []\n\nfunction dfs(v):\n    append v to the back of dfs_order\n    pick an arbitrary permutation s of children of v\n    for child in s:\n        dfs(child)\ndfs(1)\nNote that the DFS order is not unique.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nq\n(\n3≤n≤65535\n,\n2≤q≤5⋅\n10\n4\n) — the number of vertices in the tree and the number of queries. It is guaranteed that\nn=\n2\nk\n−1\nfor a positive integer\nk\n.\nThe next line contains\nn−1\nintegers\na\n2\n,\na\n3\n,…,\na\nn\n(\n1≤\na\ni\n<i\n) — the parent of each vertex in the given tree. It is guaranteed that\na\ni\n=⌊\ni\n2\n⌋\n.\nThe next line contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n, all\np\ni\nare distinct) — the initial permutation\np\n.\nThe next\nq\nlines each contain two integers\nx\n,\ny\n(\n1≤x,y≤n,x≠y\n) — the positions of the elements to swap in the permutation.\nIt is guaranteed that the sum of all\nn\ndoes not exceed\n65535\n, and the sum of all\nq\ndoes not exceed\n5⋅\n10\n4\n.\nOutput\nFor each test case, print\nq\nlines corresponding to the\nq\nqueries. For each query, output\nYES\nif there is a DFS order that exactly equals the current permutation, and output\nNO\notherwise.\nYou can output\nYes\nand\nNo\nin any case (for example, strings\nyEs\n,\nyes\n,\nYes\nand\nYES\nwill be recognized as a positive response).\nExample\ninput\nCopy\n2\n3 3\n1 1\n1 2 3\n2 3\n3 2\n1 3\n7 4\n1 1 2 2 3 3\n1 2 3 4 5 6 7\n3 5\n2 5\n3 7\n4 6\noutput\nCopy\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nNote\nIn the first test case, the permutation\np\n1\n,\np\n2\n,…,\np\nn\nafter each modification is\n[1,3,2],[1,2,3],[3,2,1]\n, respectively. The first two permutations are valid DFS orders; the third is not a DFS order.\nIn the second test case, the permutation\np\n1\n,\np\n2\n,…,\np\nn\nafter each modification is\n[1,2,5,4,3,6,7],[1,3,5,4,2,6,7],[1,3,7,4,2,6,5],[1,3,7,6,2,4,5]\n, respectively.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "graphs",
            "hashing",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "C. Black Circles",
        "description": "There are\nn\ncircles on a two-dimensional plane. The\ni\n-th circle is centered at\n(\nx\ni\n,\ny\ni\n)\n. Initially, all circles have a radius of\n0\n.\nThe circles' radii increase at a rate of\n1\nunit per second.\nYou are currently at\n(\nx\ns\n,\ny\ns\n)\n; your goal is to reach\n(\nx\nt\n,\ny\nt\n)\nwithout touching the circumference of any circle (including the moment you reach\n(\nx\nt\n,\ny\nt\n)\n). You can move in any direction you want. However, your speed is limited to\n1\nunit per second.\nPlease determine whether this is possible.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of circles.\nThe next\nn\nlines each contain two integers\nx\ni\n,\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤\n10\n9\n) — the center of each circle.\nThe final line contains four integers\nx\ns\n,\ny\ns\n,\nx\nt\n,\ny\nt\n(\n1≤\nx\ns\n,\ny\ns\n,\nx\nt\n,\ny\nt\n≤\n10\n9\n) — the coordinates of the starting point and the goal, respectively.\nIt is guaranteed that these\nn+2\npoints are distinct.\nIt is guaranteed that the sum of\nn\nover all testcases does not exceed\n10\n5\n.\nOutput\nFor each test case, output\nYES\nif it is possible to reach the goal without touching the circle boundaries, and output\nNO\notherwise.\nYou can output\nYes\nand\nNo\nin any case (for example, strings\nyEs\n,\nyes\n,\nYes\n, and\nYES\nwill be recognized as a positive response).\nExample\ninput\nCopy\n7\n3\n2 5\n2 14\n10 13\n4 9 9 7\n3\n10 11\n6 9\n12 12\n14 13 4 8\n1\n5 7\n12 6 11 13\n2\n1000000000 2\n2 1000000000\n1 1 2 2\n1\n999999998 1000000000\n999999999 999999999 1 1\n1\n1000000000 1\n1 1000000000 1 1\n10\n989237121 2397081\n206669655 527238537\n522705783 380636165\n532545346 320061691\n207818728 199485303\n884520552 315781807\n992311437 802563521\n205138355 324818663\n223575704 395073023\n281560523 236279118\n216941610 572010615 323956540 794523071\noutput\nCopy\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nNote\nIn the first test case, a feasible way of movement is as follows.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "greedy",
            "math",
            "*1200"
        ]
    },
    {
        "title": "B. Removals Game",
        "description": "Alice got a permutation\na\n1\n,\na\n2\n,…,\na\nn\nof\n[1,2,…,n]\n, and Bob got another permutation\nb\n1\n,\nb\n2\n,…,\nb\nn\nof\n[1,2,…,n]\n. They are going to play a game with these arrays.\nIn each turn, the following events happen in order:\nAlice chooses either the first or the last element of her array and removes it from the array;\nBob chooses either the first or the last element of his array and removes it from the array.\nThe game continues for\nn−1\nturns, after which both arrays will have exactly one remaining element:\nx\nin the array\na\nand\ny\nin the array\nb\n.\nIf\nx=y\n, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe next line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n, all\na\ni\nare distinct) — the permutation of Alice.\nThe next line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n, all\nb\ni\nare distinct) — the permutation of Bob.\nIt is guaranteed that the sum of all\nn\ndoes not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print\nAlice\n; otherwise, print\nBob\n.\nExample\ninput\nCopy\n2\n2\n1 2\n1 2\n3\n1 2 3\n2 3 1\noutput\nCopy\nBob\nAlice\nNote\nIn the first test case, Bob can win the game by deleting the same element as Alice did.\nIn the second test case, Alice can delete\n3\nin the first turn, and then in the second turn, delete the element that is different from the one Bob deleted in the first turn to win the game.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*1000"
        ]
    },
    {
        "title": "A. Distanced Coloring",
        "description": "You received an\nn×m\ngrid from a mysterious source. The source also gave you a magic positive integer constant\nk\n.\nThe source told you to color the grid with some colors, satisfying the following condition:\nIf\n(\nx\n1\n,\ny\n1\n)\n,\n(\nx\n2\n,\ny\n2\n)\nare two distinct cells with the same color, then\nmax(|\nx\n1\n−\nx\n2\n|,|\ny\n1\n−\ny\n2\n|)≥k\n.\nYou don't like using too many colors. Please find the minimum number of colors needed to color the grid.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe only line of each test case consists of three positive integers\nn\n,\nm\n,\nk\n(\n1≤n,m,k≤\n10\n4\n) — the dimensions of the grid and the magic constant.\nOutput\nFor each test case, print a single integer — the minimum number of colors needed to color the grid.\nExample\ninput\nCopy\n6\n3 3 2\n5 1 10000\n7 3 4\n3 2 7\n8 9 6\n2 5 4\noutput\nCopy\n4\n5\n12\n6\n36\n8\nNote\nIn the first test case, one of the optimal constructions is:\nIn the second test case, the color of all cells must be pairwise different, so the answer is\n5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "E2. Deterministic Heap (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on\nn\nand\nt\n. You can make hacks only if both versions of the problem are solved.\nConsider a perfect binary tree with size\n2n−1\n, with nodes numbered from\n1\nto\n2n−1\nand rooted at\n1\n. For each vertex\nv\n(\n1≤v≤2n−1−1\n), vertex\n2v\nis its left child and vertex\n2v+1\nis its right child. Each node\nv\nalso has a value\nav\nassigned to it.\nDefine the operation\npop\nas follows:\ninitialize variable\nv\nas\n1\n;\nrepeat the following process until vertex\nv\nis a leaf (i.e. until\n2n−1≤v≤2n−1\n);\namong the children of\nv\n, choose the one with the larger value on it and denote such vertex as\nx\n; if the values on them are equal (i.e.\na2v=a2v+1\n), you can choose any of them;\nassign\nax\nto\nav\n(i.e.\nav:=ax\n);\nassign\nx\nto\nv\n(i.e.\nv:=x\n);\nassign\n−1\nto\nav\n(i.e.\nav:=−1\n).\nThen we say the\npop\noperation is deterministic if there is a unique way to do such operation. In other words,\na2v≠a2v+1\nwould hold whenever choosing between them.\nA binary tree is called a max-heap if for every vertex\nv\n(\n1≤v≤2n−1−1\n), both\nav≥a2v\nand\nav≥a2v+1\nhold.\nA max-heap is deterministic if the\npop\noperation is deterministic to the heap when we do it for the first and the second time.\nInitially,\nav:=0\nfor every vertex\nv\n(\n1≤v≤2n−1\n), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation\nadd\nexactly\nk\ntimes:\nChoose an integer\nv\n(\n1≤v≤2n−1\n) and, for every vertex\nx\non the path between\n1\nand\nv\n, add\n1\nto\nax\n.\nTwo heaps are considered different if there is a node which has different values in the heaps.\nSince the answer might be large, print it modulo\np\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤50\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn,k,p\n(\n2≤n≤100\n,\n1≤k≤500\n,\n108≤p≤109\n,\np\nis a prime).\nIt is guaranteed that the sum of\nn\ndoes not exceed\n100\nand the sum of\nk\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation\nadd\nexactly\nk\ntimes, modulo\np\n.\nExamples\ninput\nCopy\n6\n2 1 998244353\n3 2 998244853\n3 3 998244353\n3 4 100000037\n4 2 100000039\n4 3 100000037\noutput\nCopy\n2\n12\n40\n100\n32\n224\ninput\nCopy\n1\n100 500 100000037\noutput\nCopy\n66681128\ninput\nCopy\n2\n87 63 100000037\n13 437 100000039\noutput\nCopy\n83566569\n54517140\nNote\nFor the first testcase, if we choose\nv=1\nand do the operation, we would have\na=[1,0,0]\n, and since\na2=a3\n, we can choose either of them when doing the first\npop\noperation, so such heap is not a deterministic max-heap.\nAnd if we choose\nv=2\n, we would have\na=[1,1,0]\n, during the first\npop\n, the following would happen:\ninitialize\nv\nas\n1\nsince\na2v>a2v+1\n, choose\n2v\nas\nx\n, then\nx=2\nassign\nax\nto\nav\n, then\na=[1,1,0]\nassign\nx\nto\nv\n, then\nv=2\nsince\nv\nis a leaf, assign\n−1\nto\nav\n, then\na=[1,−1,0]\nAnd during the second\npop\n, the following would happen:\ninitialize\nv\nas\n1\nsince\na2v<a2v+1\n, choose\n2v+1\nas\nx\n, then\nx=3\nassign\nax\nto\nav\n, then\na=[0,−1,0]\nassign\nx\nto\nv\n, then\nv=3\nsince\nv\nis a leaf, assign\n−1\nto\nav\n, then\na=[0,−1,−1]\nSince both the first and the second\npop\noperation are deterministic, this is a deterministic max-heap. Also, if we choose\nv=3\n,\na\nwould be a deterministic max-heap, so the answer is\n2\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "trees",
            "*2900"
        ]
    },
    {
        "title": "E1. Deterministic Heap (Easy Version)",
        "description": "This is the easy version of the problem. The difference between the two versions is the definition of deterministic max-heap, time limit, and constraints on\nn\nand\nt\n. You can make hacks only if both versions of the problem are solved.\nConsider a perfect binary tree with size\n2\nn\n−1\n, with nodes numbered from\n1\nto\n2\nn\n−1\nand rooted at\n1\n. For each vertex\nv\n(\n1≤v≤\n2\nn−1\n−1\n), vertex\n2v\nis its left child and vertex\n2v+1\nis its right child. Each node\nv\nalso has a value\na\nv\nassigned to it.\nDefine the operation\npop\nas follows:\ninitialize variable\nv\nas\n1\n;\nrepeat the following process until vertex\nv\nis a leaf (i.e. until\n2\nn−1\n≤v≤\n2\nn\n−1\n);\namong the children of\nv\n, choose the one with the larger value on it and denote such vertex as\nx\n; if the values on them are equal (i.e.\na\n2v\n=\na\n2v+1\n), you can choose any of them;\nassign\na\nx\nto\na\nv\n(i.e.\na\nv\n:=\na\nx\n);\nassign\nx\nto\nv\n(i.e.\nv:=x\n);\nassign\n−1\nto\na\nv\n(i.e.\na\nv\n:=−1\n).\nThen we say the\npop\noperation is deterministic if there is a unique way to do such operation. In other words,\na\n2v\n≠\na\n2v+1\nwould hold whenever choosing between them.\nA binary tree is called a max-heap if for every vertex\nv\n(\n1≤v≤\n2\nn−1\n−1\n), both\na\nv\n≥\na\n2v\nand\na\nv\n≥\na\n2v+1\nhold.\nA max-heap is deterministic if the\npop\noperation is deterministic to the heap when we do it for the first time.\nInitially,\na\nv\n:=0\nfor every vertex\nv\n(\n1≤v≤\n2\nn\n−1\n), and your goal is to count the number of different deterministic max-heaps produced by applying the following operation\nadd\nexactly\nk\ntimes:\nChoose an integer\nv\n(\n1≤v≤\n2\nn\n−1\n) and, for every vertex\nx\non the path between\n1\nand\nv\n, add\n1\nto\na\nx\n.\nTwo heaps are considered different if there is a node which has different values in the heaps.\nSince the answer might be large, print it modulo\np\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains three integers\nn,k,p\n(\n1≤n,k≤500\n,\n10\n8\n≤p≤\n10\n9\n,\np\nis a prime).\nIt is guaranteed that the sum of\nn\nand the sum of\nk\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, output a single line containing an integer: the number of different deterministic max-heaps produced by applying the aforementioned operation\nadd\nexactly\nk\ntimes, modulo\np\n.\nExamples\ninput\nCopy\n7\n1 13 998244353\n2 1 998244353\n3 2 998244853\n3 3 998244353\n3 4 100000037\n4 2 100000039\n4 3 100000037\noutput\nCopy\n1\n2\n12\n52\n124\n32\n304\ninput\nCopy\n1\n500 500 100000007\noutput\nCopy\n76297230\ninput\nCopy\n6\n87 63 100000037\n77 77 100000039\n100 200 998244353\n200 100 998244353\n32 59 998244853\n1 1 998244353\noutput\nCopy\n26831232\n94573603\n37147649\n847564946\n727060898\n1\nNote\nFor the first testcase, there is only one way to generate\na\n, and such sequence is a deterministic max-heap, so the answer is\n1\n.\nFor the second testcase, if we choose\nv=1\nand do the operation, we would have\na=[1,0,0]\n, and since\na\n2\n=\na\n3\n, we can choose either of them when doing the first\npop\noperation, so such heap is not a deterministic max-heap.\nAnd if we choose\nv=2\n, we would have\na=[1,1,0]\n, during the first\npop\n, the following would happen:\ninitialize\nv\nas\n1\nsince\na\n2v\n>\na\n2v+1\n, choose\n2v\nas\nx\n, then\nx=2\nassign\na\nx\nto\na\nv\n, then\na=[1,1,0]\nassign\nx\nto\nv\n, then\nv=2\nsince\nv\nis a leaf, assign\n−1\nto\na\nv\n, then\na=[1,−1,0]\nSince the first\npop\noperation is deterministic, this is a deterministic max-heap. Also, if we choose\nv=3\n,\na\nwould be a deterministic max-heap, so the answer is\n2\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "D. Longest Max Min Subsequence",
        "description": "You are given an integer sequence\na\n1\n,\na\n2\n,…,\na\nn\n. Let\nS\nbe the set of all possible non-empty subsequences of\na\nwithout duplicate elements. Your goal is to find the longest sequence in\nS\n. If there are multiple of them, find the one that minimizes lexicographical order after multiplying terms at odd positions by\n−1\n.\nFor example, given\na=[3,2,3,1]\n,\nS={[1],[2],[3],[2,1],[2,3],[3,1],[3,2],[2,3,1],[3,2,1]}\n. Then\n[2,3,1]\nand\n[3,2,1]\nwould be the longest, and\n[3,2,1]\nwould be the answer since\n[−3,2,−1]\nis lexicographically smaller than\n[−2,3,−1]\n.\nA sequence\nc\nis a subsequence of a sequence\nd\nif\nc\ncan be obtained from\nd\nby the deletion of several (possibly, zero or all) elements.\nA sequence\nc\nis lexicographically smaller than a sequence\nd\nif and only if one of the following holds:\nc\nis a prefix of\nd\n, but\nc≠d\n;\nin the first position where\nc\nand\nd\ndiffer, the sequence\nc\nhas a smaller element than the corresponding element in\nd\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the length of\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the sequence\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output the answer in the following format:\nOutput an integer\nm\nin the first line — the length of\nb\n.\nThen output\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\nin the second line — the sequence\nb\n.\nExamples\ninput\nCopy\n4\n4\n3 2 1 3\n4\n1 1 1 1\n9\n3 2 1 3 2 1 3 2 1\n1\n1\noutput\nCopy\n3\n3 2 1\n1\n1\n3\n3 1 2\n1\n1\ninput\nCopy\n10\n2\n1 2\n10\n5 2 1 7 9 7 2 5 5 2\n2\n1 2\n10\n2 2 8 7 7 9 8 1 9 6\n9\n9 1 7 5 8 5 6 4 1\n3\n3 3 3\n6\n1 6 4 4 6 5\n6\n3 4 4 5 3 3\n10\n4 1 4 5 4 5 10 1 5 1\n7\n1 2 1 3 2 4 6\noutput\nCopy\n2\n1 2\n5\n5 1 9 7 2\n2\n1 2\n6\n2 7 9 8 1 6\n7\n9 1 7 5 8 6 4\n1\n3\n4\n1 4 6 5\n3\n4 5 3\n4\n5 4 10 1\n5\n2 1 3 4 6\nNote\nIn the first example,\nS={[1],[2],[3],[1,3],[2,1],[2,3],[3,1],[3,2],[2,1,3],[3,2,1]}\n. Among them,\n[2,1,3]\nand\n[3,2,1]\nare the longest and\n[−3,2,−1]\nis lexicographical smaller than\n[−2,1,−3]\n, so\n[3,2,1]\nis the answer.\nIn the second example,\nS={[1]}\n, so\n[1]\nis the answer.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "*1900"
        ]
    },
    {
        "title": "C. Guess The Tree",
        "description": "This is an interactive problem.\nMisuki has chosen a secret tree with\nn\nnodes, indexed from\n1\nto\nn\n, and asked you to guess it by using queries of the following type:\n\"? a b\" — Misuki will tell you which node\nx\nminimizes\n|d(a,x)−d(b,x)|\n, where\nd(x,y)\nis the distance between nodes\nx\nand\ny\n. If more than one such node exists, Misuki will tell you the one which minimizes\nd(a,x)\n.\nFind out the structure of Misuki's secret tree using at most\n15n\nqueries!\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases.\nEach test case consists of a single line with an integer\nn\n(\n2≤n≤1000\n), the number of nodes in the tree.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n1000\n.\nInteraction\nThe interaction begins by reading the integer\nn\n.\nThen you can make up to\n15n\nqueries.\nTo make a query, output a line in the format \"? a b\" (without quotes) (\n1≤a,b≤n\n). After each query, read an integer — the answer to your query.\nTo report the answer, output a line in the format \"!\na\n1\nb\n1\na\n2\nb\n2\n...\na\nn−1\nb\nn−1\n\" (without quotes), meaning that there is an edge between nodes\na\ni\nand\nb\ni\n, for each\n1≤i≤n−1\n. You can print the edges in any order.\nAfter\n15n\nqueries have been made, the response to any other query will be\n−1\n. Once you receive such a response, terminate the program to receive the Wrong Answer verdict.\nAfter printing each line, do not forget to output the end of line and flush the output buffer. Otherwise, you will receive the Idleness limit exceeded verdict. To flush, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nFor hacks, use the following format: The first line contains an integer\nt\n(\n1≤t≤200\n) — the number of test cases.\nThe first line of each test contains an integer\nn\n — the number of nodes in the hidden tree.\nThen\nn−1\nlines follow. The\ni\n-th of them contains two integers\na\ni\nand\nb\ni\n(\n1≤\na\ni\n,\nb\ni\n≤n\n), meaning that there is an edge between\na\ni\nand\nb\ni\nin the hidden tree.\nThe sum of\nn\nover all test cases must not exceed\n1000\n.\nExample\ninput\nCopy\n1\n4\n1\n1\n3\noutput\nCopy\n? 1 2\n\n? 1 3\n\n? 1 4\n\n! 1 2 1 3 3 4\nNote\nA tree is an undirected acyclic connected graph. A tree with\nn\nnodes will always have\nn−1\nedges.\nIn the example case, the answer to \"? 1 2\" is\n1\n. This means that there is an edge between nodes\n1\nand\n2\n.\nThe answer to \"? 1 3\" is\n1\n. This means that there is an edge between nodes\n1\nand\n3\n.\nThe answer to \"? 1 4\" is\n3\n. It can be proven that this can only happen if node\n3\nis connected to both node\n1\nand\n4\n.\nThe edges of the tree are hence\n(1,2)\n,\n(1,3)\nand\n(3,4)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dfs and similar",
            "divide and conquer",
            "dsu",
            "greedy",
            "interactive",
            "trees",
            "*1500"
        ]
    },
    {
        "title": "B. Generate Permutation",
        "description": "There is an integer sequence\na\nof length\nn\n, where each element is initially\n−1\n.\nMisuki has two typewriters where the first one writes letters from left to right, with a pointer initially pointing to\n1\n, and another writes letters from right to left with a pointer initially pointing to\nn\n.\nMisuki would choose one of the typewriters and use it to perform the following operations until\na\nbecomes a permutation of\n[1,2,…,n]\nwrite number: write the minimum positive integer that isn't present in the array\na\nto the element\na\ni\n,\ni\nis the position where the pointer points at. Such operation can be performed only when\na\ni\n=−1\n.\ncarriage return: return the pointer to its initial position (i.e.\n1\nfor the first typewriter,\nn\nfor the second)\nmove pointer: move the pointer to the next position, let\ni\nbe the position the pointer points at before this operation, if Misuki is using the first typewriter,\ni:=i+1\nwould happen, and\ni:=i−1\notherwise. Such operation can be performed only if after the operation,\n1≤i≤n\nholds.\nYour task is to construct any permutation\np\nof length\nn\n, such that the minimum number of carriage return operations needed to make\na=p\nis the same no matter which typewriter Misuki is using.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a line of\nn\nintegers, representing the permutation\np\nof length\nn\nsuch that the minimum number of carriage return operations needed to make\na=p\nis the same no matter which typewriter Misuki is using, or\n−1\nif it is impossible to do so.\nIf there are multiple valid permutations, you can output any of them.\nExample\ninput\nCopy\n3\n1\n2\n3\noutput\nCopy\n1\n-1\n3 1 2\nNote\nIn the first testcase, it's possible to make\na=p=[1]\nusing\n0\ncarriage return operations.\nIn the second testcase, it is possible to make\na=p=[1,2]\nwith the minimal number of carriage returns as follows:\nIf Misuki is using the first typewriter:\nWrite number: write\n1\nto\na\n1\n,\na\nbecomes\n[1,−1]\nMove pointer: move the pointer to the next position. (i.e.\n2\n)\nWrite number: write\n2\nto\na\n2\n,\na\nbecomes\n[1,2]\nIf Misuki is using the second typewriter:\nMove pointer: move the pointer to the next position. (i.e.\n1\n)\nWrite number: write\n1\nto\na\n1\n,\na\nbecomes\n[1,−1]\nCarriage return: return the pointer to\n2\n.\nWrite number: write\n2\nto\na\n2\n,\na\nbecomes\n[1,2]\nIt can be proven that the minimum number of carriage returns needed to transform\na\ninto\np\nwhen using the first typewriter is\n0\nand it is\n1\nwhen using the second one, so this permutation is not valid.\nSimilarly,\np=[2,1]\nis also not valid, so there is no solution for\nn=2\n.\nIn the third testcase, it is possibile to make\na=p=[3,1,2]\nwith\n1\ncarriage return with both the first and the second typewriter. It can be proven that, for both typewriters, it is impossible to write\np\nwith\n0\ncarriage returns.\nWith the first typewriter it is possible to:\nMove pointer: move the pointer to the next position. (i.e.\n2\n)\nWrite number: write\n1\nto\na\n2\n,\na\nbecomes\n[−1,1,−1]\nMove pointer: move the pointer to the next position. (i.e.\n3\n)\nWrite number: write\n2\nto\na\n3\n,\na\nbecomes\n[−1,1,2]\nCarriage return: return the pointer to\n1\n.\nWrite number: write\n3\nto\na\n1\n,\na\nbecomes\n[3,1,2]\nWith the second typewriter it is possible to:\nMove pointer: move the pointer to the next position. (i.e.\n2\n)\nWrite number: write\n1\nto\na\n2\n,\na\nbecomes\n[−1,1,−1]\nCarriage return: return the pointer to\n3\n.\nWrite number: write\n2\nto\na\n3\n,\na\nbecomes\n[−1,1,2]\nMove pointer: move the pointer to the next position. (i.e.\n2\n)\nMove pointer: move the pointer to the next position. (i.e.\n1\n)\nWrite number: write\n3\nto\na\n1\n,\na\nbecomes\n[3,1,2]",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*800"
        ]
    },
    {
        "title": "A. Make All Equal",
        "description": "You are given a cyclic array\na\n1\n,\na\n2\n,…,\na\nn\n.\nYou can perform the following operation on\na\nat most\nn−1\ntimes:\nLet\nm\nbe the current size of\na\n, you can choose any two adjacent elements where the previous one is no greater than the latter one (In particular,\na\nm\nand\na\n1\nare adjacent and\na\nm\nis the previous one), and delete exactly one of them. In other words, choose an integer\ni\n(\n1≤i≤m\n) where\na\ni\n≤\na\n(imodm)+1\nholds, and delete exactly one of\na\ni\nor\na\n(imodm)+1\nfrom\na\n.\nYour goal is to find the minimum number of operations needed to make all elements in\na\nequal.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of array\na\n.\nOutput\nFor each test case, output a single line containing an integer: the minimum number of operations needed to make all elements in\na\nequal.\nExample\ninput\nCopy\n7\n1\n1\n3\n1 2 3\n3\n1 2 2\n5\n5 4 3 2 1\n6\n1 1 2 2 3 3\n8\n8 7 6 3 8 7 6 3\n6\n1 1 4 5 1 4\noutput\nCopy\n0\n2\n1\n4\n4\n6\n3\nNote\nIn the first test case, there is only one element in\na\n, so we can't do any operation.\nIn the second test case, we can perform the following operations to make all elements in\na\nequal:\nchoose\ni=2\n, delete\na\n3\n, then\na\nwould become\n[1,2]\n.\nchoose\ni=1\n, delete\na\n1\n, then\na\nwould become\n[2]\n.\nIt can be proven that we can't make all elements in\na\nequal using fewer than\n2\noperations, so the answer is\n2\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "H. Ksyusha and the Loaded Set",
        "description": "Ksyusha decided to start a game development company. To stand out among competitors and achieve success, she decided to write her own game engine. The engine must support a set initially consisting of\nn\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nn\n.\nThe set will undergo\nm\noperations sequentially. The operations can be of the following types:\nInsert element\nx\ninto the set;\nRemove element\nx\nfrom the set;\nReport the\nk\n-load of the set.\nThe\nk\n-load of the set is defined as the minimum positive integer\nd\nsuch that the integers\nd,d+1,…,d+(k−1)\ndo not appear in this set. For example, the\n3\n-load of the set\n{3,4,6,11}\nis\n7\n, since the integers\n7,8,9\nare absent from the set, and no smaller value fits.\nKsyusha is busy with management tasks, so you will have to write the engine. Implement efficient support for the described operations.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe following lines describe the test cases.\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the initial size of the set.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\n1\n<\na\n2\n<…<\na\nn\n≤2⋅\n10\n6\n) — the initial state of the set.\nThe third line contains an integer\nm\n(\n1≤m≤2⋅\n10\n5\n) — the number of operations.\nThe next\nm\nlines contain the operations. The operations are given in the following format:\n+\nx\n(\n1≤x≤2⋅\n10\n6\n) — insert element\nx\ninto the set (it is guaranteed that\nx\nis not in the set);\n-\nx\n(\n1≤x≤2⋅\n10\n6\n) — remove element\nx\nfrom the set (it is guaranteed that\nx\nis in the set);\n?\nk\n(\n1≤k≤2⋅\n10\n6\n) — output the value of the\nk\n-load of the set.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n, and the same holds for\nm\n.\nOutput\nFor each test case, output the answers to the operations of type \"?\".\nExample\ninput\nCopy\n3\n5\n1 2 5 905 2000000\n15\n- 2\n? 2\n? 1\n- 1\n? 1\n+ 4\n+ 2\n? 2\n+ 6\n- 4\n+ 7\n? 2\n? 3\n? 4\n? 2000000\n5\n3 4 5 6 8\n9\n? 5\n- 5\n? 5\n+ 1\n? 2\n- 6\n- 8\n+ 6\n? 5\n5\n6 7 8 9 10\n10\n? 5\n- 6\n? 4\n- 10\n+ 5\n- 8\n+ 3\n+ 2\n- 3\n+ 10\noutput\nCopy\n2 2 1 6 3 8 8 2000001 \n9 9 9 7 \n1 1 ",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "G. Call During the Journey",
        "description": "You live in a city consisting of\nn\nintersections and\nm\nstreets connecting some pairs of intersections. You can travel in either direction on each street. No two streets connect the same pair of intersections, and no street connects an intersection to itself. You can reach any intersection from any other, possibly passing through some other intersections.\nEvery minute, you can board a bus at intersection\nu\ni\nand travel for\nl\ni1\nminutes to intersection\nv\ni\n. Conversely, you can travel from intersection\nv\ni\nto intersection\nu\ni\nin\nl\ni1\nminutes. You can only board and exit the bus at intersections. You can only board the bus at an intersection if you are currently there.\nYou can also walk along each street, which takes\nl\ni2\n>\nl\ni1\nminutes.\nYou can make stops at intersections.\nYou live at intersection number\n1\n. Today you woke up at time\n0\n, and you have an important event scheduled at intersection number\nn\n, which you must reach no later than time\nt\n0\n. You also have a phone call planned that will last from\nt\n1\nto\nt\n2\nminutes (\nt\n1\n<\nt\n2\n<\nt\n0\n).\nDuring the phone call, you cannot ride the bus, but you can walk along any streets, make stops, or stay at home. You can exit the bus at minute\nt\n1\nand board the bus again at minute\nt\n2\n.\nSince you want to get enough sleep, you became curious — how late can you leave home to have time to talk on the phone and still not be late for the event?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The following are the descriptions of the test cases.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n2≤n≤\n10\n5\n,1≤m≤\n10\n5\n) — the number of intersections and streets in the city.\nThe second line of each test case contains three integers\nt\n0\n,\nt\n1\n,\nt\n2\n(\n1≤\nt\n1\n<\nt\n2\n<\nt\n0\n≤\n10\n9\n) — the start time of the event, the start time of the phone call, and its end time, respectively.\nThe next\nm\nlines of each test case contain descriptions of the streets.\nThe\ni\n-th line contains four integers\nu\ni\n,\nv\ni\n,\nl\ni1\n,\nl\ni2\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n,\n1≤\nl\ni1\n<\nl\ni2\n≤\n10\n9\n) — the numbers of the intersections connected by the\ni\n-th street, as well as the travel time along the street by bus and on foot. It is guaranteed that no two streets connect the same pair of intersections and that it is possible to reach any intersection from any other.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases does not exceed\n10\n5\n. It is also guaranteed that the sum of the values of\nm\nacross all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the latest time you can leave home to have time to talk on the phone and not be late for the event. If you cannot reach the event on time, output -1.\nExample\ninput\nCopy\n7\n5 5\n100 20 80\n1 5 30 100\n1 2 20 50\n2 3 20 50\n3 4 20 50\n4 5 20 50\n2 1\n100 50 60\n1 2 55 110\n4 4\n100 40 60\n1 2 30 100\n2 4 30 100\n1 3 20 50\n3 4 20 50\n3 3\n100 80 90\n1 2 1 10\n2 3 10 50\n1 3 20 21\n3 2\n58 55 57\n2 1 1 3\n2 3 3 4\n2 1\n12 9 10\n2 1 6 10\n5 5\n8 5 6\n2 1 1 8\n2 3 4 8\n4 2 2 4\n5 3 3 4\n4 5 2 6\noutput\nCopy\n0\n-1\n60\n80\n53\n3\n2",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "graphs",
            "greedy",
            "shortest paths",
            "*2100"
        ]
    },
    {
        "title": "F. Color Rows and Columns",
        "description": "You have\nn\nrectangles, the\ni\n-th of which has a width of\na\ni\nand a height of\nb\ni\n.\nYou can perform the following operation an unlimited number of times: choose a rectangle and a cell in it, and then color it.\nEach time you completely color any row or column, you earn\n1\npoint. Your task is to score at least\nk\npoints with as few operations as possible.\nSuppose you have a rectangle with a width of\n6\nand a height of\n3\n. You can score\n4\npoints by coloring all the cells in any\n4\ncolumns, thus performing\n12\noperations.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases. The following are the descriptions of the test cases.\nThe first line of each test case description contains two integers\nn\nand\nk\n(\n1≤n≤1000,1≤k≤100\n) — the number of rectangles in the case and the required number of points.\nThe next\nn\nlines contain the descriptions of the rectangles. The\ni\n-th line contains two integers\na\ni\nand\nb\ni\n(\n1≤\na\ni\n,\nb\ni\n≤100\n) — the width and height of the\ni\n-th rectangle.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required to score at least\nk\npoints. If it is impossible to score at least\nk\npoints, output -1.\nExample\ninput\nCopy\n7\n1 4\n6 3\n1 5\n4 4\n5 10\n1 1\n1 1\n1 1\n1 1\n1 1\n2 100\n1 2\n5 6\n3 11\n2 2\n3 3\n4 4\n3 25\n9 2\n4 3\n8 10\n4 18\n5 4\n8 5\n8 3\n6 2\noutput\nCopy\n12\n14\n5\n-1\n17\n80\n35",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "math",
            "*1900"
        ]
    },
    {
        "title": "E. Photoshoot for Gorillas",
        "description": "You really love gorillas, so you decided to organize a photoshoot for them. Gorillas live in the jungle. The jungle is represented as a grid of\nn\nrows and\nm\ncolumns.\nw\ngorillas agreed to participate in the photoshoot, and the gorilla with index\ni\n(\n1≤i≤w\n) has a height of\na\ni\n. You want to place all the gorillas in the cells of the grid such that there is no more than one gorilla in each cell.\nThe spectacle of the arrangement is equal to the sum of the spectacles of all sub-squares of the grid with a side length of\nk\n.\nThe spectacle of a sub-square is equal to the sum of the heights of the gorillas in it.\nFrom all suitable arrangements, choose the arrangement with the maximum spectacle.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe descriptions of the test cases follow.\nThe first line contains integers\nn\n,\nm\n,\nk\n(\n1≤n,m≤2⋅\n10\n5\n,\n1≤n⋅m≤2⋅\n10\n5\n,\n1≤k≤min(n,m)\n) — the dimensions of the grid and the side length of the square.\nThe second line contains an integer\nw\n(\n1≤w≤n⋅m\n) — the number of gorillas.\nThe third line contains\nw\nintegers\na\n1\n,\na\n2\n,…,\na\nw\n(\n1≤\na\ni\n≤\n10\n9\n) — the heights of the gorillas.\nIt is guaranteed that the sum of\nn⋅m\nacross all test cases does not exceed\n2⋅\n10\n5\n. The same guarantee applies to\nw\n.\nOutput\nFor each test case, output a single integer — the maximum spectacle of a suitable arrangement.\nExample\ninput\nCopy\n5\n3 4 2\n9\n1 1 1 1 1 1 1 1 1\n2 1 1\n2\n5 7\n20 15 7\n9\n4 1 4 5 6 1 1000000000 898 777\n1984 1 1\n4\n5 4 1499 2004\n9 5 5\n6\n6 7 14 16 16 6\noutput\nCopy\n21\n12\n49000083104\n3512\n319\nNote\nIn the first test case of the first input set, the spectacle of the following sub-squares is summed:\nYellow color corresponds to the sub-squares, green — to the rest of the grid squares.\nThe picture shows the optimal arrangement of the gorillas. The spectacle of the arrangement is\n4+4+3+3+4+3=21\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "greedy",
            "math",
            "*1400"
        ]
    },
    {
        "title": "D. Right Left Wrong",
        "description": "Vlad found a strip of\nn\ncells, numbered from left to right from\n1\nto\nn\n. In the\ni\n-th cell, there is a positive integer\na\ni\nand a letter\ns\ni\n, where all\ns\ni\nare either 'L' or 'R'.\nVlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.\nIn one operation, you can choose two indices\nl\nand\nr\n(\n1≤l<r≤n\n) such that\ns\nl\n= 'L' and\ns\nr\n= 'R' and do the following:\nadd\na\nl\n+\na\nl+1\n+⋯+\na\nr−1\n+\na\nr\npoints to the current score;\nreplace\ns\ni\nwith '.' for all\nl≤i≤r\n, meaning you can no longer choose these indices.\nFor example, consider the following strip:\n3\n5\n1\n4\n3\n2\nL R L L L R\nYou can first choose\nl=1\n,\nr=2\nand add\n3+5=8\nto your score.\n3\n5\n1\n4\n3\n2\n. . L L L R\nThen choose\nl=3\n,\nr=6\nand add\n1+4+3+2=10\nto your score.\n3\n5\n1\n4\n3\n2\n. . . . . .\nAs a result, it is impossible to perform another operation, and the final score is\n18\n.\nWhat is the maximum score that can be achieved?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains one integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the strip.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the numbers written on the strip.\nThe third line of each test case contains a string\ns\nof\nn\ncharacters 'L' and 'R'.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the maximum possible number of points that can be scored.\nExample\ninput\nCopy\n4\n6\n3 5 1 4 3 2\nLRLLLR\n2\n2 8\nLR\n2\n3 9\nRL\n5\n1 2 3 4 5\nLRLRR\noutput\nCopy\n18\n10\n0\n22",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "two pointers",
            "*1200"
        ]
    },
    {
        "title": "C. Numeric String Template",
        "description": "Kristina has an array\na\n, called a template, consisting of\nn\nintegers. She also has\nm\nstrings, each consisting only of lowercase Latin letters. The strings are numbered from\n1\nto\nm\n. She wants to check which strings match the template.\nA string\ns\nis considered to match the template if all of the following conditions are simultaneously satisfied:\nThe length of the string\ns\nis equal to the number of elements in the array\na\n.\nThe same numbers from\na\ncorrespond to the same symbols from\ns\n. So, if\na\ni\n=\na\nj\n, then\ns\ni\n=\ns\nj\nfor (\n1≤i,j≤n\n).\nThe same symbols from\ns\ncorrespond to the same numbers from\na\n. So, if\ns\ni\n=\ns\nj\n, then\na\ni\n=\na\nj\nfor (\n1≤i,j≤n\n).\nIn other words, there must be a one-to-one correspondence between the characters of the string and the elements of the array.\nFor example, if\na\n= [\n3,5,2,1,3\n], then the string \"abfda\" matches the template, while the string \"afbfa\" does not, since the character \"f\" corresponds to both numbers\n1\nand\n5\n.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe following descriptions are for the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of elements in the array\na\n.\nThe second line of each test case contains exactly\nn\nintegers\na\ni\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nThe third line of each test case contains a single integer\nm\n(\n1≤m≤2⋅\n10\n5\n) — the number of strings to check for template matching.\nFollowing are\nm\nstrings, each containing a non-empty string\ns\nj\n(\n1≤|\ns\nj\n|≤2⋅\n10\n5\n), consisting of lowercase Latin letters.\nIt is guaranteed that the sum of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n, and that the sum of the lengths of all strings does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nm\nlines. On the\ni\n-th line (\n1≤i≤m\n) output:\n\"YES\", if the string with index\ni\nmatches the template;\n\"NO\" otherwise.\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n3\n5\n3 5 2 1 3\n2\nabfda\nafbfa\n2\n1 2\n3\nab\nabc\naa\n4\n5 -3 5 -3\n4\naaaa\nbcbc\naba\ncbcb\noutput\nCopy\nYES\nNO\nYES\nNO\nNO\nNO\nYES\nNO\nYES\nNote\nThe first test case is explained in the problem statement.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "strings",
            "*1000"
        ]
    },
    {
        "title": "B. Seating in a Bus",
        "description": "In Berland, a bus consists of a row of\nn\nseats numbered from\n1\nto\nn\n. Passengers are advised to always board the bus following these rules:\nIf there are no occupied seats in the bus, a passenger can sit in any free seat;\nOtherwise, a passenger should sit in any free seat that has at least one occupied neighboring seat. In other words, a passenger can sit in a seat with index\ni\n(\n1≤i≤n\n) only if at least one of the seats with indices\ni−1\nor\ni+1\nis occupied.\nToday,\nn\npassengers boarded the bus. The array\na\nchronologically records the seat numbers they occupied. That is,\na\n1\ncontains the seat number where the first passenger sat,\na\n2\n— the seat number where the second passenger sat, and so on.\nYou know the contents of the array\na\n. Determine whether all passengers followed the recommendations.\nFor example, if\nn=5\n, and\na\n= [\n5,4,2,1,3\n], then the recommendations were not followed, as the\n3\n-rd passenger sat in seat number\n2\n, while the neighboring seats with numbers\n1\nand\n3\nwere free.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe following describes the input test cases.\nThe first line of each test case contains exactly one integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of seats in the bus and the number of passengers who boarded the bus.\nThe second line of each test case contains\nn\ndistinct integers\na\ni\n(\n1≤\na\ni\n≤n\n) — the seats that the passengers occupied in chronological order.\nIt is guaranteed that the sum of\nn\nvalues across all test cases does not exceed\n2⋅\n10\n5\n, and that no passenger sits in an already occupied seat.\nOutput\nFor each test case, output on a separate line:\n\"YES\", if all passengers followed the recommendations;\n\"NO\" otherwise.\nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n4\n5\n5 4 2 1 3\n3\n2 3 1\n4\n2 3 1 4\n5\n1 2 3 5 4\noutput\nCopy\nNO\nYES\nYES\nNO\nNote\nThe first test case is explained in the problem statement.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "two pointers",
            "*800"
        ]
    },
    {
        "title": "A. Primary Task",
        "description": "Dmitry wrote down\nt\nintegers on the board, and that is good. He is sure that he lost an important integer\nn\namong them, and that is bad.\nThe integer\nn\nhad the form\n10^x\n(\nx≥2\n), where the symbol '\n^\n' denotes exponentiation.. Something went wrong, and Dmitry missed the symbol '\n^\n' when writing the important integer. For example, instead of the integer\n10\n5\n, he would have written\n105\n, and instead of\n10\n19\n, he would have written\n1019\n.\nDmitry wants to understand which of the integers on the board could have been the important integer and which could not.\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of integers on the board.\nThe next\nt\nlines each contain an integer\na\n(\n1≤a≤10000\n) — the next integer from the board.\nOutput\nFor each integer on the board, output \"YES\" if it could have been the important integer and \"NO\" otherwise.\nYou may output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n7\n100\n1010\n101\n105\n2033\n1019\n1002\noutput\nCopy\nNO\nYES\nNO\nYES\nNO\nYES\nNO",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "strings",
            "*800"
        ]
    },
    {
        "title": "G2. Ruler (hard version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is that in this version, you can make at most\n7\nqueries.\nThis is an interactive problem. If you are unsure how interactive problems work, then it is recommended to read the guide for participants.\nWe have a secret ruler that is missing one number\nx\n(\n2≤x≤999\n). When you measure an object of length\ny\n, the ruler reports the following values:\nIf\ny<x\n, the ruler (correctly) measures the object as having length\ny\n.\nIf\ny≥x\n, the ruler incorrectly measures the object as having length\ny+1\n.\nThe ruler above is missing the number\n4\n, so it correctly measures the first segment as length\n3\nbut incorrectly measures the second segment as length\n6\neven though it is actually\n5\n.\nYou need to find the value of\nx\n. To do that, you can make queries of the following form:\n? a b\n — in response, we will measure the side lengths of an\na×b\nrectangle with our ruler and multiply the results, reporting the measured area of the rectangle back to you. For example, if\nx=4\nand you query a\n3×5\nrectangle, we will measure its side lengths as\n3×6\nand report\n18\nback to you.\nFind the value of\nx\n. You can ask at most\n7\nqueries.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nInteraction\nThere is no initial input for each test case. You should begin the interaction by asking a query.\nTo make a query, output a single line of the form\n? a b\n(\n1≤a,b≤1000\n). In response, you will be told the measured area of the rectangle, according to our secret ruler.\nWhen you are ready to print the answer, output a single line of the form\n! x\n(\n2≤x≤999\n). After that, proceed to process the next test case or terminate the program if it was the last test case. Printing the answer does not count as a query.\nThe interactor is not adaptive, meaning that the answer is known before the participant asks the queries and doesn't depend on the queries asked by the participant.\nIf your program makes more than\n7\nqueries for one set of input data, makes an invalid query, or prints the wrong value of\nx\n, then the response to the query will be\n−1\n. After receiving such a response, your program should immediately terminate to receive the verdict Wrong Answer. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query do not forget to output the end of line and flush the output. Otherwise, you may get Idleness limit exceeded verdict. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo make a hack, use the following format.\nThe first line should contain a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case should contain a single integer\nx\n(\n2≤x≤999\n) — the missing number on the ruler.\nExample\ninput\nCopy\n2\n\n18\n\n25\n\n\n9999\noutput\nCopy\n? 3 5\n\n? 4 4\n\n! 4\n? 99 100\n\n! 100\nNote\nIn the first test, the interaction proceeds as follows.\nSolution Jury Explanation\n2\nThere are 2 test cases.\n? 3 5\n18\nSecretly, the jury picked\nx=4\n. The solution requests the\n3×5\nrectangle, and the jury responds with\n3×6=18\n, as described in the statement.\n? 4 4\n25\nThe solution requests the\n4×4\nrectangle, which the jury measures as\n5×5\nand responds with\n25\n.\n! 4\nThe solution has somehow determined that\nx=4\n, and outputs it. Since the output is correct, the jury continues to the next test case.\n? 99 100\n1\nSecretly, the jury picked\nx=100\n. The solution requests the\n99×100\nrectangle, which the jury measures as\n99×101\nand responds with\n9999\n.\n! 100\nThe solution has somehow determined that\nx=100\n, and outputs it. Since the output is correct and there are no more test cases, the jury and the solution exit.\nNote that the line breaks in the example input and output are for the sake of clarity, and do not occur in the real interaction.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "interactive",
            "ternary search",
            "*1700"
        ]
    },
    {
        "title": "G1. Ruler (easy version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is that in this version, you can make at most\n10\nqueries.\nThis is an interactive problem. If you are unsure how interactive problems work, then it is recommended to read the guide for participants.\nWe have a secret ruler that is missing one number\nx\n(\n2≤x≤999\n). When you measure an object of length\ny\n, the ruler reports the following values:\nIf\ny<x\n, the ruler (correctly) measures the object as having length\ny\n.\nIf\ny≥x\n, the ruler incorrectly measures the object as having length\ny+1\n.\nThe ruler above is missing the number\n4\n, so it correctly measures the first segment as length\n3\nbut incorrectly measures the second segment as length\n6\neven though it is actually\n5\n.\nYou need to find the value of\nx\n. To do that, you can make queries of the following form:\n? a b\n — in response, we will measure the side lengths of an\na×b\nrectangle with our ruler and multiply the results, reporting the measured area of the rectangle back to you. For example, if\nx=4\nand you query a\n3×5\nrectangle, we will measure its side lengths as\n3×6\nand report\n18\nback to you.\nFind the value of\nx\n. You can ask at most\n10\nqueries.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nInteraction\nThere is no initial input for each test case. You should begin the interaction by asking a query.\nTo make a query, output a single line of the form\n? a b\n(\n1≤a,b≤1000\n). In response, you will be told the measured area of the rectangle, according to our secret ruler.\nWhen you are ready to print the answer, output a single line of the form\n! x\n(\n2≤x≤999\n). After that, proceed to process the next test case or terminate the program if it was the last test case. Printing the answer does not count as a query.\nThe interactor is not adaptive, meaning that the answer is known before the participant asks the queries and doesn't depend on the queries asked by the participant.\nIf your program makes more than\n10\nqueries for one set of input data, makes an invalid query, or prints the wrong value of\nx\n, then the response to the query will be\n−1\n. After receiving such a response, your program should immediately terminate to receive the verdict Wrong Answer. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query do not forget to output the end of line and flush the output. Otherwise, you may get Idleness limit exceeded verdict. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo make a hack, use the following format.\nThe first line should contain a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case should contain a single integer\nx\n(\n2≤x≤999\n) — the missing number on the ruler.\nExample\ninput\nCopy\n2\n\n18\n\n25\n\n\n9999\noutput\nCopy\n? 3 5\n\n? 4 4\n\n! 4\n? 99 100\n\n! 100\nNote\nIn the first test, the interaction proceeds as follows.\nSolution Jury Explanation\n2\nThere are 2 test cases.\n? 3 5\n18\nSecretly, the jury picked\nx=4\n. The solution requests the\n3×5\nrectangle, and the jury responds with\n3×6=18\n, as described in the statement.\n? 4 4\n25\nThe solution requests the\n4×4\nrectangle, which the jury measures as\n5×5\nand responds with\n25\n.\n! 4\nThe solution has somehow determined that\nx=4\n, and outputs it. Since the output is correct, the jury continues to the next test case.\n? 99 100\n1\nSecretly, the jury picked\nx=100\n. The solution requests the\n99×100\nrectangle, which the jury measures as\n99×101\nand responds with\n9999\n.\n! 100\nThe solution has somehow determined that\nx=100\n, and outputs it. Since the output is correct and there are no more test cases, the jury and the solution exit.\nNote that the line breaks in the example input and output are for the sake of clarity, and do not occur in the real interaction.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "interactive",
            "*1500"
        ]
    },
    {
        "title": "F. Expected Median",
        "description": "Arul has a binary array\n∗\na\nof length\nn\n.\nHe will take all subsequences\n†\n†\nof length\nk\n(\nk\nis odd) of this array and find their median.\n‡\n‡\nWhat is the sum of all these values?\nAs this sum can be very large, output it modulo\n10\n9\n+7\n. In other words, print the remainder of this sum when divided by\n10\n9\n+7\n.\n∗\nA binary array is an array consisting only of zeros and ones.\n†\n†\nAn array\nb\nis a subsequence of an array\na\nif\nb\ncan be obtained from\na\nby the deletion of several (possibly, zero or all) elements. Subsequences don't have to be contiguous.\n‡\n‡\nThe median of an array of odd length\nk\nis the\nk+1\n2\n-th element when sorted.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤2⋅\n10\n5\n,\nk\nis odd) — the length of the array and the length of the subsequence, respectively.\nThe second line of each test case contains\nn\nintegers\na\ni\n(\n0≤\na\ni\n≤1\n) — the elements of the array.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print the sum modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n8\n4 3\n1 0 0 1\n5 1\n1 1 1 1 1\n5 5\n0 1 0 1 0\n6 3\n1 0 1 0 1 1\n4 3\n1 0 1 1\n5 3\n1 0 1 1 0\n2 1\n0 0\n34 17\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\noutput\nCopy\n2\n5\n0\n16\n4\n7\n0\n333606206\nNote\nIn the first test case, there are four subsequences of\n[1,0,0,1]\nwith length\nk=3\n:\n[1,0,0]\n: median\n=0\n.\n[1,0,1]\n: median\n=1\n.\n[1,0,1]\n: median\n=1\n.\n[0,0,1]\n: median\n=0\n.\nThe sum of the results is\n0+1+1+0=2\n.\nIn the second test case, all subsequences of length\n1\nhave median\n1\n, so the answer is\n5\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "*1500"
        ]
    },
    {
        "title": "E. Triple Operations",
        "description": "On the board Ivy wrote down all integers from\nl\nto\nr\n, inclusive.\nIn an operation, she does the following:\npick two numbers\nx\nand\ny\non the board, erase them, and in their place write the numbers\n3x\nand\n⌊\ny\n3\n⌋\n. (Here\n⌊∙⌋\ndenotes rounding down to the nearest integer).\nWhat is the minimum number of operations Ivy needs to make all numbers on the board equal\n0\n? We have a proof that this is always possible.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains two integers\nl\nand\nr\n(\n1≤l<r≤2⋅\n10\n5\n).\nOutput\nFor each test case, output a single integer — the minimum number of operations needed to make all numbers on the board equal\n0\n.\nExample\ninput\nCopy\n4\n1 3\n2 4\n199999 200000\n19 84\noutput\nCopy\n5\n6\n36\n263\nNote\nIn the first test case, we can perform\n5\noperations as follows:\n1,2,3\n−\n→\n−\n−\n−\n−\nx=1,y=2\n3,0,3\n−\n→\n−\n−\n−\n−\nx=0,y=3\n1,0,3\n−\n→\n−\n−\n−\n−\nx=0,y=3\n1,0,1\n−\n→\n−\n−\n−\n−\nx=0,y=1\n0,0,1\n−\n→\n−\n−\n−\n−\nx=0,y=1\n0,0,0.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "math",
            "*1300"
        ]
    },
    {
        "title": "D. Slavic's Exam",
        "description": "Slavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\nThere exists a string\ns\n, which consists of lowercase English letters and possibly zero or more \"?\".\nSlavic is asked to change each \"?\" to a lowercase English letter such that string\nt\nbecomes a subsequence (not necessarily continuous) of the string\ns\n.\nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\nInput\nThe first line contains a single integer\nT\n(\n1≤T≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single string\ns\n(\n1≤|s|≤2⋅\n10\n5\n, and\ns\nconsists only of lowercase English letters and \"?\"-s)  – the original string you have.\nThe second line of each test case contains a single string\nt\n(\n1≤|t|≤|s|\n, and\nt\nconsists only of lowercase English letters)  – the string that should be a subsequence of string\ns\n.\nThe sum of\n|s|\nover all test cases doesn't exceed\n2⋅\n10\n5\n, where\n|x|\ndenotes the length of the string\nx\n.\nOutput\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\nOtherwise, output \"YES\" (without quotes). Then, output one line — the string that respects all conditions.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nIf multiple answers are possible, you can output any of them.\nExample\ninput\nCopy\n5\n?????\nxbx\nab??e\nabcde\nayy?x\na\nab??e\ndac\npaiu\nmom\noutput\nCopy\nYES\nxabax\nYES\nabcde\nYES\nayyyx\nNO\nNO",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*1100"
        ]
    },
    {
        "title": "C. Showering",
        "description": "As a computer science student, Alex faces a hard challenge — showering. He tries to shower daily, but despite his best efforts there are always challenges. He takes\ns\nminutes to shower and a day only has\nm\nminutes!\nHe already has\nn\ntasks planned for the day. Task\ni\nis represented as an interval\n(\nl\ni\n,\nr\ni\n)\n, which means that Alex is busy and can not take a shower in that time interval (at any point in time strictly between\nl\ni\nand\nr\ni\n). No two tasks overlap.\nGiven all\nn\ntime intervals, will Alex be able to shower that day? In other words, will Alex have a free time interval of length at least\ns\n?\nIn the first test case, Alex can shower for the first\n3\nminutes of the day and not miss any of the tasks.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\ns\n, and\nm\n(\n1≤n≤2⋅\n10\n5\n;\n1≤s,m≤\n10\n9\n) — the number of time intervals Alex already has planned, the amount of time Alex takes to take a shower, and the amount of minutes a day has.\nThen\nn\nlines follow, the\ni\n-th of which contains two integers\nl\ni\nand\nr\ni\n(\n0≤\nl\ni\n<\nr\ni\n≤m\n) — the time interval of the\ni\n-th task. No two tasks overlap.\nAdditional constraint on the input:\nl\ni\n>\nr\ni−1\nfor every\ni>1\n.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case output \"YES\" (without quotes) if Alex can take a shower for that given test case, and \"NO\" (also without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n4\n3 3 10\n3 5\n6 8\n9 10\n3 3 10\n1 2\n3 5\n6 7\n3 3 10\n1 2\n3 5\n6 8\n3 4 10\n1 2\n6 7\n8 9\noutput\nCopy\nYES\nYES\nNO\nYES",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "B. Card Game",
        "description": "Suneet and Slavic play a card game. The rules of the game are as follows:\nEach card has an integer value between\n1\nand\n10\n.\nEach player receives\n2\ncards which are face-down (so a player doesn't know their cards).\nThe game is turn-based and consists exactly of two turns. In a round, both players pick a random unflipped card and flip it. The player who flipped a card with a strictly greater number wins the round. In case of equality, no one wins the round.\nA player wins a game if he wins the most number of rounds (i.e. strictly greater than the other player). In case of equality, no one wins the game.\nSince Suneet and Slavic aren't best friends, you need to calculate the number of ways the game could happen that Suneet would end up as the winner.\nFor a better understanding, please check the notes section.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains\n4\nintegers\na\n1\n,\na\n2\n,\nb\n1\n,\nb\n2\n(\n1≤\na\n1\n,\na\n2\n,\nb\n1\n,\nb\n2\n≤10\n) where\na\n1\nand\na\n2\nrepresent the cards Suneet has, and\nb\n1\nand\nb\n2\nrepresent the cards Slavic has, respectively.\nOutput\nFor each test case, output a single integer — the number of games Suneet would win considering all possible games.\nExample\ninput\nCopy\n5\n3 8 2 6\n1 1 1 1\n10 10 2 2\n1 1 10 10\n3 8 7 2\noutput\nCopy\n2\n0\n4\n0\n2\nNote\nConsider the first test case when Slavic starts with the cards that have the values\n2\nand\n6\n, and Suneet starts with cards that have the values\n3\nand\n8\n. The game could happen in\n4\ndifferent ways:\nSuneet flips\n3\nand Slavic flips\n2\n. Suneet wins the first round. Then, Suneet flips\n8\nand Slavic flips\n6\n. Suneet wins the second round as well. Since Suneet won\n2\nrounds, he wins the game.\nSuneet flips\n3\nand Slavic flips\n6\n. Slavic wins the first round. Then, Suneet flips\n8\nand Slavic flips\n2\n. Suneet wins the second round. Nobody wins since both players won an equal amount of rounds.\nSuneet flips\n8\nand Slavic flips\n6\n. Suneet wins the first round. Then, Suneet flips\n3\nand Slavic flips\n2\n. Suneet wins the second round as well. Since Suneet won\n2\nrounds, he wins the game.\nSuneet flips\n8\nand Slavic flips\n2\n. Suneet wins the first round. Then, Suneet flips\n3\nand Slavic flips\n6\n. Slavic wins the round. Nobody wins since both players won an equal amount of rounds.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "*1000"
        ]
    },
    {
        "title": "A. A+B Again?",
        "description": "Given a two-digit positive integer\nn\n, find the sum of its digits.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤90\n) — the number of test cases.\nThe only line of each test case contains a single two-digit positive integer\nn\n(\n10≤n≤99\n).\nOutput\nFor each test case, output a single integer — the sum of the digits of\nn\n.\nExample\ninput\nCopy\n8\n77\n21\n40\n34\n19\n84\n10\n99\noutput\nCopy\n14\n3\n4\n7\n10\n12\n1\n18",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "E2. Eliminating Balls With Merging (Hard Version)",
        "description": "Drink water.\n— Sun Tzu, The Art of Becoming a Healthy Programmer\nThis is the hard version of the problem. The only difference is that\nx=1\nin this version. You must solve both versions to be able to hack.\nYou are given two integers\nn\nand\nx\n(\nx=1\n). There are\nn\nballs lined up in a row, numbered from\n1\nto\nn\nfrom left to right. Initially, there is a value\na\ni\nwritten on the\ni\n-th ball.\nFor each integer\ni\nfrom\n1\nto\nn\n, we define a function\nf(i)\nas follows:\nSuppose you have a set\nS={1,2,…,i}\n.\nIn each operation, you have to select an integer\nl\n(\n1≤l<i\n) from\nS\nsuch that\nl\nis not the largest element of\nS\n. Suppose\nr\nis the smallest element in\nS\nwhich is greater than\nl\n.\nIf\na\nl\n>\na\nr\n, you set\na\nl\n=\na\nl\n+\na\nr\nand remove\nr\nfrom\nS\n.\nIf\na\nl\n<\na\nr\n, you set\na\nr\n=\na\nl\n+\na\nr\nand remove\nl\nfrom\nS\n.\nIf\na\nl\n=\na\nr\n, you choose either the integer\nl\nor\nr\nto remove from\nS\n:\nIf you choose to remove\nl\nfrom\nS\n, you set\na\nr\n=\na\nl\n+\na\nr\nand remove\nl\nfrom\nS\n.\nIf you choose to remove\nr\nfrom\nS\n, you set\na\nl\n=\na\nl\n+\na\nr\nand remove\nr\nfrom\nS\n.\nf(i)\ndenotes the number of integers\nj\n(\n1≤j≤i\n) such that it is possible to obtain\nS={j}\nafter performing the above operations exactly\ni−1\ntimes.\nFor each integer\ni\nfrom\nx\nto\nn\n, you need to find\nf(i)\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤2⋅\n10\n5\n;x=1\n) — the number of balls and the smallest index\ni\nfor which you need to find\nf(i)\n.\nThe second line of each test case contains\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the initial number written on each ball.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn−x+1\nspace separated integers on a new line, where the\nj\n-th integer should represent\nf(x+j−1)\n.\nExample\ninput\nCopy\n3\n5 1\n1 2 3 2 1\n7 1\n4 5 1 2 1 4 5\n11 1\n1 2 3 1 1 9 3 2 4 1 3\noutput\nCopy\n1 1 2 2 3\n1 1 1 1 1 3 4\n1 1 2 2 2 1 1 1 3 3 4\nNote\nIn the first test case, below are the possible values of\nj\nfor each\nf(i)\nfrom\n1\nto\nn\n.\nFor\nf(1)\n, the only possible value of\nj\nis\n1\n.\nFor\nf(2)\n, the only possible value of\nj\nis\n2\n.\nFor\nf(3)\n, the possible values of\nj\nare\n2\nand\n3\n.\nFor\nf(4)\n, the possible values of\nj\nare\n2\nand\n3\n.\nFor\nf(5)\n, the possible values of\nj\nare\n2\n,\n3\n, and\n4\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "greedy",
            "implementation",
            "*2500"
        ]
    },
    {
        "title": "E1. Eliminating Balls With Merging (Easy Version)",
        "description": "Drink water.\n— Sun Tzu, The Art of Becoming a Healthy Programmer\nThis is the easy version of the problem. The only difference is that\nx=n\nin this version. You must solve both versions to be able to hack.\nYou are given two integers\nn\nand\nx\n(\nx=n\n). There are\nn\nballs lined up in a row, numbered from\n1\nto\nn\nfrom left to right. Initially, there is a value\na\ni\nwritten on the\ni\n-th ball.\nFor each integer\ni\nfrom\n1\nto\nn\n, we define a function\nf(i)\nas follows:\nSuppose you have a set\nS={1,2,…,i}\n.\nIn each operation, you have to select an integer\nl\n(\n1≤l<i\n) from\nS\nsuch that\nl\nis not the largest element of\nS\n. Suppose\nr\nis the smallest element in\nS\nwhich is greater than\nl\n.\nIf\na\nl\n>\na\nr\n, you set\na\nl\n=\na\nl\n+\na\nr\nand remove\nr\nfrom\nS\n.\nIf\na\nl\n<\na\nr\n, you set\na\nr\n=\na\nl\n+\na\nr\nand remove\nl\nfrom\nS\n.\nIf\na\nl\n=\na\nr\n, you choose either the integer\nl\nor\nr\nto remove from\nS\n:\nIf you choose to remove\nl\nfrom\nS\n, you set\na\nr\n=\na\nl\n+\na\nr\nand remove\nl\nfrom\nS\n.\nIf you choose to remove\nr\nfrom\nS\n, you set\na\nl\n=\na\nl\n+\na\nr\nand remove\nr\nfrom\nS\n.\nf(i)\ndenotes the number of integers\nj\n(\n1≤j≤i\n) such that it is possible to obtain\nS={j}\nafter performing the above operations exactly\ni−1\ntimes.\nFor each integer\ni\nfrom\nx\nto\nn\n, you need to find\nf(i)\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤2⋅\n10\n5\n;x=n\n) — the number of balls and the smallest index\ni\nfor which you need to find\nf(i)\n.\nThe second line of each test case contains\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the initial number written on each ball.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn−x+1\nspace separated integers on a new line, where the\nj\n-th integer should represent\nf(x+j−1)\n.\nExample\ninput\nCopy\n3\n5 5\n1 2 3 2 1\n7 7\n4 5 1 2 1 4 5\n11 11\n1 2 3 1 1 9 3 2 4 1 3\noutput\nCopy\n3\n4\n4\nNote\nIn the first test case, you are required to calculate\nf(5)\n. It can be shown that after\n4\noperations,\nS\ncan contain\n2\n,\n3\n, or\n4\n. The following shows the operations required to make\nS={4}\n.\nInitially,\nS={1,2,3,4,5}\nand\na=[1,2,3,2,1]\n.\nChoose\nl=1\n. Naturally,\nr=2\n. Since\na\n1\n<\na\n2\n, we set\na\n2\n=1+2\nand remove\n1\nfrom\nS\n. Now,\nS={2,3,4,5}\nand\na=[1,3,3,2,1]\n.\nChoose\nl=4\n. Naturally,\nr=5\n. Since\na\n4\n>\na\n5\n, we set\na\n4\n=2+1\nand remove\n5\nfrom\nS\n. Now,\nS={2,3,4}\nand\na=[1,3,3,3,1]\n.\nChoose\nl=3\n. Naturally,\nr=4\n. Since\na\n3\n=\na\n4\n, we have a choice whether to remove\n3\nor\n4\n. Since we want to preserve\n4\n, let's remove\n3\n. So, set\na\n4\n=3+3\nand remove\n3\nfrom\nS\n. Now,\nS={2,4}\nand\na=[1,3,3,6,1]\n.\nChoose\nl=2\n. Naturally,\nr=4\n. Since\na\n2\n<\na\n4\n, we set\na\n4\n=3+6\nand remove\n2\nfrom\nS\n. Finally,\nS={4}\nand\na=[1,3,3,9,1]\n.\nIn the second test case, you are required to calculate\nf(7)\n. It can be shown that after\n6\noperations,\nS\ncan contain\n2\n,\n4\n,\n6\n, or\n7\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "greedy",
            "*2200"
        ]
    },
    {
        "title": "D. Determine Winning Islands in Race",
        "description": "MOOOOOOOOOOOOOOOOO\n— Bessie the Cow, The Art of Racing on Islands\nTwo of Farmer John's cows, Bessie and Elsie, are planning to race on\nn\nislands. There are\nn−1\nmain bridges, connecting island\ni\nto island\ni+1\nfor all\n1≤i≤n−1\n. Additionally, there are\nm\nalternative bridges. Elsie can use both main and alternative bridges, while Bessie can only use main bridges. All bridges are one way and can only be used to travel from an island with a lower index to an island with a higher index.\nInitially, Elsie starts on island\n1\n, and Bessie starts on island\ns\n. The cows alternate turns, with Bessie making the first turn. Suppose the cow is on island\ni\n. During a cow's turn, if there are any bridges connecting island\ni\nto island\nj\n, then the cow can move to island\nj\n. Then, island\ni\ncollapses, and all bridges connecting to island\ni\nalso collapse. Also, note the following:\nIf there are no bridges connecting island\ni\nto another island, then island\ni\ncollapses, and this cow is eliminated from the race.\nIf the other cow is also on island\ni\n, then after this cow moves to another island, the island collapses, and the other cow is eliminated from the race.\nAfter an island or bridge collapses, no cows may use them.\nIf a cow is eliminated, their turn is skipped for the rest of the race.\nThe race ends once either cow reaches island\nn\n. It can be shown that regardless of the cows' strategies, at least one cow reaches island\nn\n. Bessie wins if and only if she reaches island\nn\nfirst.\nFor each\n1≤s≤n−1\n, determine whether Bessie wins if she starts the race on island\ns\n. Assume both cows follow optimal strategies to ensure their own respective victories.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) – the number of test cases.\nThe first line of each test case contains\nn\nand\nm\n(\n2≤n≤2⋅\n10\n5\n,\n0≤m≤2⋅\n10\n5\n) – the number of islands and the number of alternative bridges.\nThe next\nm\nlines of each test case contain\nu\nand\nv\n(\n1≤u<v≤n\n) – the islands that the alternative bridge connects. It is guaranteed all alternative bridges are distinct, and they do not coincide with the main bridges.\nIt is guaranteed that neither the sum of\nn\nnor the sum of\nm\nover all test cases exceeds\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a binary string of length\nn−1\non a new line. The\ni\n'th character is\n1\nif it is possible for Bessie to win if she starts on island\ni\n. Otherwise, it is\n0\n.\nExample\ninput\nCopy\n5\n6 0\n6 1\n2 6\n6 1\n1 5\n10 4\n1 3\n1 6\n2 7\n3 8\n15 3\n2 8\n4 9\n8 15\noutput\nCopy\n11111\n11011\n10011\n100001111\n11000111000111\nNote\nIn the first test case, there are no alternative bridges for Elsie to overtake Bessie and reach island\nn\nfirst, so Bessie will win on all islands because she always moves first.\nIn the second case, Bessie will lose if she starts on island\n3\nbecause:\nBessie's Turn: Take a main bridge from island\n3\nto island\n4\n.\nElsie's Turn: Take a main bridge from island\n1\nto island\n2\n.\nBessie's Turn: Take a main bridge from island\n4\nto island\n5\n.\nElsie's Turn: Take an alternative bridge from island\n2\nto island\n6\n. Elsie reaches island\nn\nfirst.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "graphs",
            "greedy",
            "shortest paths",
            "*2100"
        ]
    },
    {
        "title": "C. Perform Operations to Maximize Score",
        "description": "I see satyam343. I'm shaking. Please more median problems this time. I love those. Please satyam343 we believe in you.\n— satyam343's biggest fan\nYou are given an array\na\nof length\nn\nand an integer\nk\n. You are also given a binary array\nb\nof length\nn\n.\nYou can perform the following operation at most\nk\ntimes:\nSelect an index\ni\n(\n1≤i≤n\n) such that\nb\ni\n=1\n. Set\na\ni\n=\na\ni\n+1\n(i.e., increase\na\ni\nby\n1\n).\nYour score is defined to be\nmax\ni=1\nn\n(\na\ni\n+median(\nc\ni\n))\n, where\nc\ni\ndenotes the array of length\nn−1\nthat you get by deleting\na\ni\nfrom\na\n. In other words, your score is the maximum value of\na\ni\n+median(\nc\ni\n)\nover all\ni\nfrom\n1\nto\nn\n.\nFind the maximum score that you can achieve if you perform the operations optimally.\nFor an arbitrary array\np\n,\nmedian(p)\nis defined as the\n⌊\n|p|+1\n2\n⌋\n⌊\n-th smallest element of\np\n. For example,\nmedian([3,2,1,3])=2\nand\nmedian([6,2,4,5,1])=4\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case begins with two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n,\n0≤k≤\n10\n9\n) — the length of the\na\nand the number of operations you can perform.\nThe following line contains\nn\nspace separated integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — denoting the array\na\n.\nThe following line contains\nn\nspace separated integers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\nb\ni\nis\n0\nor\n1\n) — denoting the array\nb\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum value of score you can get on a new line.\nExample\ninput\nCopy\n8\n2 10\n3 3\n1 1\n3 10\n3 3 3\n0 0 0\n4 4\n2 1 5 1\n0 1 0 1\n5 4\n7 5 2 5 4\n0 0 1 0 1\n5 1\n5 15 15 2 11\n1 0 0 1 1\n5 2\n10 11 4 10 15\n1 1 0 1 0\n4 4\n1 1 2 5\n1 1 0 0\n2 1000000000\n1000000000 1000000000\n1 1\noutput\nCopy\n16\n6\n8\n13\n21\n26\n8\n3000000000\nNote\nFor the first test case, it is optimal to perform\n5\noperations on both elements so\na=[8,8]\n. So, the maximum score we can achieve is\nmax(8+median[8],8+median[8])=16\n, as\nc\n1\n=[\na\n2\n]=[8]\n. It can be proven that you cannot get a better score.\nFor the second test case, you are not able to perform operations on any elements, so\na\nremains\n[3,3,3]\n. So, the maximum score we can achieve is\n3+median[3,3]=6\n, as\nc\n1\n=[\na\n2\n,\na\n3\n]=[3,3]\n. It can be proven that you cannot get a better score.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1900"
        ]
    },
    {
        "title": "B. Minimize Equal Sum Subarrays",
        "description": "It is known that Farmer John likes Permutations, but I like them too!\n— Sun Tzu, The Art of Constructing Permutations\nYou are given a permutation\n∗\np\nof length\nn\n.\nFind a permutation\nq\nof length\nn\nthat minimizes the number of pairs (\ni,j\n) (\n1≤i≤j≤n\n) such that\np\ni\n+\np\ni+1\n+…+\np\nj\n=\nq\ni\n+\nq\ni+1\n+…+\nq\nj\n.\n∗\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe following line contains\nn\nspace-separated integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — denoting the permutation\np\nof length\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one line containing any permutation of length\nn\n(the permutation\nq\n) such that\nq\nminimizes the number of pairs.\nExample\ninput\nCopy\n3\n2\n1 2\n5\n1 2 3 4 5\n7\n4 7 5 1 2 6 3\noutput\nCopy\n2 1\n3 5 4 2 1\n6 2 1 4 7 3 5\nNote\nFor the first test, there exists only one pair (\ni,j\n) (\n1≤i≤j≤n\n) such that\np\ni\n+\np\ni+1\n+…+\np\nj\n=\nq\ni\n+\nq\ni+1\n+…+\nq\nj\n, which is (\n1,2\n). It can be proven that no such\nq\nexists for which there are no pairs.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ]
    },
    {
        "title": "A. Find K Distinct Points with Fixed Center",
        "description": "I couldn't think of a good title for this problem, so I decided to learn from LeetCode.\n— Sun Tzu, The Art of War\nYou are given three integers\nx\nc\n,\ny\nc\n, and\nk\n(\n−100≤\nx\nc\n,\ny\nc\n≤100\n,\n1≤k≤1000\n).\nYou need to find\nk\ndistinct points (\nx\n1\n,\ny\n1\n), (\nx\n2\n,\ny\n2\n),\n…\n, (\nx\nk\n,\ny\nk\n), having integer coordinates, on the 2D coordinate plane such that:\ntheir center\n∗\nis (\nx\nc\n,\ny\nc\n)\n−\n10\n9\n≤\nx\ni\n,\ny\ni\n≤\n10\n9\nfor all\ni\nfrom\n1\nto\nk\nIt can be proven that at least one set of\nk\ndistinct points always exists that satisfies these conditions.\n∗\nThe center of\nk\npoints (\nx\n1\n,\ny\n1\n), (\nx\n2\n,\ny\n2\n),\n…\n, (\nx\nk\n,\ny\nk\n) is\n(\nx\n1\n+\nx\n2\n+…+\nx\nk\nk\n,\ny\n1\n+\ny\n2\n+…+\ny\nk\nk\n)\n(\n.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n) — the number of test cases.\nEach test case contains three integers\nx\nc\n,\ny\nc\n, and\nk\n(\n−100≤\nx\nc\n,\ny\nc\n≤100\n,\n1≤k≤1000\n) — the coordinates of the center and the number of distinct points you must output.\nIt is guaranteed that the sum of\nk\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output\nk\nlines, the\ni\n-th line containing two space separated integers,\nx\ni\nand\ny\ni\n, (\n−\n10\n9\n≤\nx\ni\n,\ny\ni\n≤\n10\n9\n) — denoting the position of the\ni\n-th point.\nIf there are multiple answers, print any of them. It can be shown that a solution always exists under the given constraints.\nExample\ninput\nCopy\n4\n10 10 1\n0 0 3\n-5 -8 8\n4 -5 3\noutput\nCopy\n10 10\n-1 -1\n5 -1\n-4 2\n-6 -7\n-5 -7\n-4 -7\n-4 -8\n-4 -9\n-5 -9\n-6 -9\n-6 -8\n1000 -1000\n-996 995\n8 -10\nNote\nFor the first test case,\n(\n10\n1\n,\n10\n1\n)=(10,10)\n(\n.\nFor the second test case,\n(\n−1+5−4\n3\n,\n−1−1+2\n3\n)=(0,0)\n(\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Chips on a Line",
        "description": "You have\nn\nchips, and you are going to place all of them in one of\nx\npoints, numbered from\n1\nto\nx\n. There can be multiple chips in each point.\nAfter placing the chips, you can perform the following four operations (in any order, any number of times):\nchoose a chip in point\ni≥3\n, remove it and place two chips: one in\ni−1\n, one in\ni−2\n;\nchoose two chips in adjacent points\ni\nand\ni+1\n, remove them and place a new chip in\ni+2\n;\nchoose a chip in point\n1\nand move it to\n2\n;\nchoose a chip in point\n2\nand move it to\n1\n.\nNote that the coordinates of the chips you place during the operations cannot be less than\n1\n, but can be greater than\nx\n.\nDenote the cost of chip placement as the minimum number of chips which can be present on the line after you perform these operations, starting from the placement you've chosen.\nFor example, the cost of placing two chips in points\n3\nand one chip in point\n5\nis\n2\n, because you can reduce the number of chips to\n2\nas follows:\nchoose a chip in point\n3\n, remove it, place a chip in\n1\nand another chip in\n2\n;\nchoose the chips in points\n2\nand\n3\n, remove them and place a chip in\n4\n;\nchoose the chips in points\n4\nand\n5\n, remove them and place a chip in\n6\n.\nYou are given three integers\nn\n,\nx\nand\nm\n. Calculate the number of placements of exactly\nn\nchips in points from\n1\nto\nx\nhaving cost equal to\nm\n, and print it modulo\n998244353\n. Two placements are considered different if the number of chips in some point differs between these placements.\nInput\nThe only line contains three integers\nn\n,\nx\nand\nm\n(\n1≤m≤n≤1000\n;\n2≤x≤10\n).\nOutput\nPrint one integer — the number of placements with cost equal to\nm\n, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n2 3 1\noutput\nCopy\n5\ninput\nCopy\n42 10 5\noutput\nCopy\n902673363\ninput\nCopy\n1000 10 8\noutput\nCopy\n187821763\nNote\nIn the first example, there are five ways to place\n2\nchips in points from\n1\nto\n3\nso that the cost is\n1\n:\n(1,1)\n;\n(1,2)\n;\n(1,3)\n;\n(2,2)\n;\n(2,3)\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "greedy",
            "math",
            "*2700"
        ]
    },
    {
        "title": "E. Level Up",
        "description": "Monocarp is playing a computer game. He starts the game being level\n1\n. He is about to fight\nn\nmonsters, in order from\n1\nto\nn\n. The level of the\ni\n-th monster is\na\ni\n.\nFor each monster in the given order, Monocarp's encounter goes as follows:\nif Monocarp's level is strictly higher than the monster's level, the monster flees (runs away);\notherwise, Monocarp fights the monster.\nAfter every\nk\n-th fight with a monster (fleeing monsters do not count), Monocarp's level increases by\n1\n. So, his level becomes\n2\nafter\nk\nmonsters he fights,\n3\nafter\n2k\nmonsters,\n4\nafter\n3k\nmonsters, and so on.\nYou need to process\nq\nqueries of the following form:\ni x\n: will Monocarp fight the\ni\n-th monster (or will this monster flee) if the parameter\nk\nis equal to\nx\n?\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the number of monsters and the number of queries.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n5\n) — the levels of the monsters.\nIn the\nj\n-th of the following\nq\nlines, two integers\ni\nand\nx\n(\n1≤i,x≤n\n) — the index of the monster and the number of fights required for a level up in the\nj\n-th query.\nOutput\nFor each query, output \"YES\", if Monocarp will fight the\ni\n-th monster in this query, and \"NO\", if the\ni\n-th monster flees.\nExamples\ninput\nCopy\n4 16\n2 1 2 1\n1 1\n2 1\n3 1\n4 1\n1 2\n2 2\n3 2\n4 2\n1 3\n2 3\n3 3\n4 3\n1 4\n2 4\n3 4\n4 4\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\ninput\nCopy\n7 15\n1 1 2 1 1 1 1\n5 3\n2 2\n2 2\n1 6\n5 1\n5 5\n7 7\n3 5\n7 4\n4 3\n2 5\n1 2\n5 6\n4 1\n6 1\noutput\nCopy\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nNO\nNO\nYES\nYES\nYES\nNO\nNO",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "D. Maximize the Root",
        "description": "You are given a rooted tree, consisting of\nn\nvertices. The vertices in the tree are numbered from\n1\nto\nn\n, and the root is the vertex\n1\n. The value\na\ni\nis written at the\ni\n-th vertex.\nYou can perform the following operation any number of times (possibly zero): choose a vertex\nv\nwhich has at least one child; increase\na\nv\nby\n1\n; and decrease\na\nu\nby\n1\nfor all vertices\nu\nthat are in the subtree of\nv\n(except\nv\nitself). However, after each operation, the values on all vertices should be non-negative.\nYour task is to calculate the maximum possible value written at the root using the aforementioned operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the initial values written at vertices.\nThe third line contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n), where\np\ni\nis the parent of the\ni\n-th vertex in the tree. Vertex\n1\nis the root.\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible value written at the root using the aforementioned operation.\nExample\ninput\nCopy\n3\n4\n0 1 0 2\n1 1 3\n2\n3 0\n1\n5\n2 5 3 9 6\n3 1 5 2\noutput\nCopy\n1\n3\n6\nNote\nIn the first test case, the following sequence of operations is possible:\nperform the operation on\nv=3\n, then the values on the vertices will be\n[0,1,1,1]\n;\nperform the operation on\nv=1\n, then the values on the vertices will be\n[1,0,0,0]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dfs and similar",
            "dp",
            "greedy",
            "trees",
            "*1500"
        ]
    },
    {
        "title": "C. Even Positions",
        "description": "Monocarp had a regular bracket sequence\ns\nof length\nn\n(\nn\nis even). He even came up with his own way to calculate its cost.\nHe knows that in a regular bracket sequence (RBS), each opening bracket is paired up with the corresponding closing bracket. So he decided to calculate the cost of RBS as the sum of distances between pairs of corresponding bracket pairs.\nFor example, let's look at RBS (())(). It has three pairs of brackets:\n(__)__: the distance between brackets at position\n1\nand at\n4\nis\n4−1=3\n;\n_()___: the distance is\n3−2=1\n;\n____(): the distance is\n6−5=1\n.\nSo the cost of (())() is\n3+1+1=5\n.\nUnfortunately, due to data corruption, Monocarp lost all characters on odd positions\ns\n1\n,\ns\n3\n,…,\ns\nn−1\n. Only characters on even positions (\ns\n2\n,\ns\n4\n,…,\ns\nn\n) remain. For example, (())() turned to _(_)_).\nMonocarp wants to restore his RBS by placing brackets on the odd positions. But since the restored RBS may not be unique, he wants to choose one with minimum cost. It's too hard to do for Monocarp alone, so can you help him?\nReminder: A regular bracket sequence is a string consisting of only brackets, such that this sequence, when inserted 1-s and +-s, gives a valid mathematical expression. For example, (), (()) or (()())() are RBS, while ), ()( or ())(() are not.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. Next\nt\ncases follow.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n;\nn\nis even) — the length of string\ns\n.\nThe second line of each test case contains a string\ns\nof length\nn\n, where all characters on the odd positions are '_' and all characters on the even positions are either '(' or ')'.\nAdditional constraints:\ns\ncan be restored to at least one regular bracket sequence;\nthe total sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the minimum cost of the regular bracket sequence that can be obtained from\ns\nby replacing '_'-s with brackets.\nExample\ninput\nCopy\n4\n6\n_(_)_)\n2\n_)\n8\n_)_)_)_)\n8\n_(_)_(_)\noutput\nCopy\n5\n1\n4\n8\nNote\nIn the first test case, it's optimal to make\ns\nequal to (())(). The cost of\ns\nwill be equal to\n3+1+1=5\n.\nIn the second test case, the only option is to make\ns\nequal to () with cost\n1\n.\nIn the third test case, the only possible RBS is ()()()() with cost\n1+1+1+1=4\n.\nIn the fourth test case, it's optimal to make\ns\nequal to (())(()) with cost\n3+1+3+1=8\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1100"
        ]
    },
    {
        "title": "B. Make Three Regions",
        "description": "There is a grid, consisting of\n2\nrows and\nn\ncolumns. Each cell of the grid is either free or blocked.\nA free cell\ny\nis reachable from a free cell\nx\nif at least one of these conditions holds:\nx\nand\ny\nshare a side;\nthere exists a free cell\nz\nsuch that\nz\nis reachable from\nx\nand\ny\nis reachable from\nz\n.\nA connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\nFor example, consider the following layout, where white cells are free, and dark grey cells are blocked:\nThere are\n3\nregions in it, denoted with red, green and blue color respectively:\nThe given grid contains at most\n1\nconnected region. Your task is to calculate the number of free cells meeting the following constraint:\nif this cell is blocked, the number of connected regions becomes exactly\n3\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of columns.\nThe\ni\n-th of the next two lines contains a description of the\ni\n-th row of the grid — the string\ns\ni\n, consisting of\nn\ncharacters. Each character is either . (denoting a free cell) or x (denoting a blocked cell).\nAdditional constraint on the input:\nthe given grid contains at most\n1\nconnected region;\nthe sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the number of cells such that the number of connected regions becomes\n3\nif this cell is blocked.\nExample\ninput\nCopy\n4\n8\n.......x\n.x.xx...\n2\n..\n..\n3\nxxx\nxxx\n9\n..x.x.x.x\nx.......x\noutput\nCopy\n1\n0\n0\n2\nNote\nIn the first test case, if the cell\n(1,3)\nis blocked, the number of connected regions becomes\n3\n(as shown in the picture from the statement).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "two pointers",
            "*1100"
        ]
    },
    {
        "title": "A. Strong Password",
        "description": "Monocarp's current password on Codeforces is a string\ns\n, consisting of lowercase Latin letters. Monocarp thinks that his current password is too weak, so he wants to insert exactly one lowercase Latin letter into the password to make it stronger. Monocarp can choose any letter and insert it anywhere, even before the first character or after the last character.\nMonocarp thinks that the password's strength is proportional to the time it takes him to type the password. The time it takes to type the password is calculated as follows:\nthe time to type the first character is\n2\nseconds;\nfor each character other than the first, the time it takes to type it is\n1\nsecond if it is the same as the previous character, or\n2\nseconds otherwise.\nFor example, the time it takes to type the password abacaba is\n14\n; the time it takes to type the password a is\n2\n; the time it takes to type the password aaabacc is\n11\n.\nYou have to help Monocarp — insert a lowercase Latin letter into his password so that the resulting password takes the maximum possible amount of time to type.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of one line containing the string\ns\n(\n1≤|s|≤10\n), consisting of lowercase Latin letters.\nOutput\nFor each test case, print one line containing the new password — a string which can be obtained from\ns\nby inserting one lowercase Latin letter. The string you print should have the maximum possible required time to type it. If there are multiple answers, print any of them.\nExample\ninput\nCopy\n4\na\naaa\nabb\npassword\noutput\nCopy\nwa\naada\nabcb\npastsword",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "G. Penacony",
        "description": "On Penacony, The Land of the Dreams, there exists\nn\nhouses and\nn\nroads. There exists a road between house\ni\nand\ni+1\nfor all\n1≤i≤n−1\nand a road between house\nn\nand house\n1\n. All roads are bidirectional. However, due to the crisis on Penacony, the overseeing family has gone into debt and may not be able to maintain all roads.\nThere are\nm\npairs of friendships between the residents of Penacony. If the resident living in house\na\nis friends with the resident living in house\nb\n, there must be a path between houses\na\nand\nb\nthrough maintained roads.\nWhat is the minimum number of roads that must be maintained?\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) – the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n3≤n≤2⋅\n10\n5\n,1≤m≤2⋅\n10\n5\n) – the number of houses and the number of friendships.\nThe next\nm\nlines contain two integers\na\nand\nb\n(\n1≤a<b≤n\n) – the resident in house\na\nis friends with the resident in house\nb\n. It is guaranteed all (\na,b\n) are distinct.\nIt is guaranteed the sum of\nn\nand\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer, the minimum number of roads that must be maintained.\nExample\ninput\nCopy\n7\n8 3\n1 8\n2 7\n4 5\n13 4\n1 13\n2 12\n3 11\n4 10\n10 2\n2 3\n3 4\n10 4\n3 8\n5 10\n2 10\n4 10\n4 1\n1 3\n5 2\n3 5\n1 4\n5 2\n2 5\n1 3\noutput\nCopy\n4\n7\n2\n7\n2\n3\n3\nNote\nFor the first test case, the following roads must be maintained:\n8←→1\n7←→8\n1←→2\n4←→5",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "graphs",
            "greedy",
            "hashing",
            "*2200"
        ]
    },
    {
        "title": "F. Bomb",
        "description": "Sparkle gives you two arrays\na\nand\nb\nof length\nn\n. Initially, your score is\n0\n. In one operation, you can choose an integer\ni\nand add\na\ni\nto your score. Then, you must set\na\ni\n=\nmax(0,\na\ni\n−\nb\ni\n)\n.\nYou only have time to perform\nk\noperations before Sparkle sets off a nuclear bomb! What is the maximum score you can acquire after\nk\noperations?\nInput\nThe first line contains\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,1≤k≤\n10\n9\n) — the length of the arrays and the number of operations you can perform.\nThe following line contains\nn\nintegers\na\n1\n,\na\n2\n,...\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe following line contains\nn\nintegers\nb\n1\n,\nb\n2\n,...\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer, the maximum score you can acquire after\nk\noperations.\nExample\ninput\nCopy\n5\n3 4\n5 6 7\n2 3 4\n5 9\n32 52 68 64 14\n18 14 53 24 8\n5 1000\n1 2 3 4 5\n5 4 3 2 1\n1 1000000\n1000000\n1\n10 6\n3 3 5 10 6 8 6 8 7 7\n6 1 7 4 1 1 8 9 3 1\noutput\nCopy\n21\n349\n27\n500000500000\n47",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1900"
        ]
    },
    {
        "title": "E. Decode",
        "description": "In a desperate attempt to obtain your waifu favorite character, you have hacked into the source code of the game. After days of struggling, you finally find the binary string that encodes the gacha system of the game. In order to decode it, you must first solve the following problem.\nYou are given a binary string\ns\nof length\nn\n. For each pair of integers\n(l,r)\n(1≤l≤r≤n)\n, count the number of pairs\n(x,y)\n(l≤x≤y≤r)\nsuch that the amount of\n0\nequals the amount of\n1\nin the substring\ns\nx\ns\nx+1\n...\ns\ny\n.\nOutput the sum of counts over all possible\n(l,r)\nmodulo\n10\n9\n+7\n.\nInput\nThe first line contains\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case contains a binary string\ns\n(\n1≤|s|≤2⋅\n10\n5\n). It is guaranteed\ns\nonly contains characters\n0\nand\n1\n.\nIt is guaranteed the sum of\n|s|\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer, the answer modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n4\n0000\n01010101\n1100111001\n11000000111\noutput\nCopy\n0\n130\n147\n70",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "E. Decode",
        "description": "In a desperate attempt to obtain your waifu favorite character, you have hacked into the source code of the game. After days of struggling, you finally find the binary string that encodes the gacha system of the game. In order to decode it, you must first solve the following problem.\nYou are given a binary string\ns\nof length\nn\n. For each pair of integers\n(l,r)\n(1≤l≤r≤n)\n, count the number of pairs\n(x,y)\n(l≤x≤y≤r)\nsuch that the amount of\n0\nequals the amount of\n1\nin the substring\ns\nx\ns\nx+1\n...\ns\ny\n.\nOutput the sum of counts over all possible\n(l,r)\nmodulo\n10\n9\n+7\n.\nInput\nThe first line contains\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case contains a binary string\ns\n(\n1≤|s|≤2⋅\n10\n5\n). It is guaranteed\ns\nonly contains characters\n0\nand\n1\n.\nIt is guaranteed the sum of\n|s|\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer, the answer modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n4\n0000\n01010101\n1100111001\n11000000111\noutput\nCopy\n0\n130\n147\n70",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "D. Fun",
        "description": "Counting is Fun!\n— satyam343\nGiven two integers\nn\nand\nx\n, find the number of triplets (\na,b,c\n) of positive integers such that\nab+ac+bc≤n\nand\na+b+c≤x\n.\nNote that order matters (e.g. (\n1,1,2\n) and (\n1,2,1\n) are treated as different) and\na\n,\nb\n,\nc\nmust be strictly greater than\n0\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nEach test case contains two integers\nn\nand\nx\n(\n1≤n,x≤\n10\n6\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\nand that the sum of\nx\nover all test cases does not exceed\n10\n6\n.\nOutput\nOutput a single integer — the number of triplets (\na,b,c\n) of positive integers such that\nab+ac+bc≤n\nand\na+b+c≤x\n.\nExample\ninput\nCopy\n4\n7 4\n10 5\n7 1000\n900000 400000\noutput\nCopy\n4\n10\n7\n1768016938\nNote\nIn the first test case, the triplets are (\n1,1,1\n), (\n1,1,2\n), (\n1,2,1\n), and (\n2,1,1\n).\nIn the second test case, the triplets are (\n1,1,1\n), (\n1,1,2\n), (\n1,1,3\n), (\n1,2,1\n), (\n1,2,2\n), (\n1,3,1\n), (\n2,1,1\n), (\n2,1,2\n), (\n2,2,1\n), and (\n3,1,1\n).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "combinatorics",
            "math",
            "number theory",
            "*1500"
        ]
    },
    {
        "title": "C. Sort",
        "description": "You are given two strings\na\nand\nb\nof length\nn\n. Then, you are (forced against your will) to answer\nq\nqueries.\nFor each query, you are given a range bounded by\nl\nand\nr\n. In one operation, you can choose an integer\ni\n(\nl≤i≤r\n) and set\na\ni\n=x\nwhere\nx\nis any character you desire. Output the minimum number of operations you must perform such that\nsorted(a[l..r])=sorted(b[l..r])\n. The operations you perform on one query does not affect other queries.\nFor an arbitrary string\nc\n,\nsorted(c[l..r])\ndenotes the substring consisting of characters\nc\nl\n,\nc\nl+1\n,...,\nc\nr\nsorted in lexicographical order.\nInput\nThe first line contains\nt\n(\n1≤t≤1000\n) – the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) – the length of both strings and the number of queries.\nThe following line contains\na\nof length\nn\n. It is guaranteed\na\nonly contains lowercase latin letters.\nThe following line contains\nb\nof length\nn\n. It is guaranteed\nb\nonly contains lowercase latin letters.\nThe following\nq\nlines contain two integers\nl\nand\nr\n(\n1≤l≤r≤n\n) – the range of the query.\nIt is guaranteed the sum of\nn\nand\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output an integer, the minimum number of operations you need to perform in a new line.\nExample\ninput\nCopy\n3\n5 3\nabcde\nedcba\n1 5\n1 4\n3 3\n4 2\nzzde\nazbe\n1 3\n1 4\n6 3\nuwuwuw\nwuwuwu\n2 4\n1 3\n1 6\noutput\nCopy\n0\n1\n0\n2\n2\n1\n1\n0\nNote\nFor the first query,\nsorted(a[1..5])=\nabcde and\nsorted(b[1..5])=\nabcde, so no operations are necessary.\nFor the second query, you need to set\na\n1\n=\ne. Then,\nsorted(a[1..4])=sorted(b[1..4])=\nbcde.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ]
    },
    {
        "title": "B. Scale",
        "description": "Tina has a square grid with\nn\nrows and\nn\ncolumns. Each cell in the grid is either\n0\nor\n1\n.\nTina wants to reduce the grid by a factor of\nk\n(\nk\nis a divisor of\nn\n). To do this, Tina splits the grid into\nk×k\nnonoverlapping blocks of cells such that every cell belongs to exactly one block.\nTina then replaces each block of cells with a single cell equal to the value of the cells in the block. It is guaranteed that every cell in the same block has the same value.\nFor example, the following demonstration shows a grid being reduced by factor of\n3\n.\nOriginal grid\n0\n0\n0\n1\n1\n1\n0\n0\n0\n1\n1\n1\n0\n0\n0\n1\n1\n1\n1\n1\n1\n0\n0\n0\n1\n1\n1\n0\n0\n0\n1\n1\n1\n0\n0\n0\nReduced grid\n0\n1\n1\n0\nHelp Tina reduce the grid by a factor of\nk\n.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n) – the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤1000\n,\n1≤k≤n\n,\nk\nis a divisor of\nn\n) — the number of rows and columns of the grid, and the factor that Tina wants to reduce the grid by.\nEach of the following\nn\nlines contain\nn\ncharacters describing the cells of the grid. Each character is either\n0\nor\n1\n. It is guaranteed every\nk\nby\nk\nblock has the same value.\nIt is guaranteed the sum of\nn\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output the grid reduced by a factor of\nk\non a new line.\nExample\ninput\nCopy\n4\n4 4\n0000\n0000\n0000\n0000\n6 3\n000111\n000111\n000111\n111000\n111000\n111000\n6 2\n001100\n001100\n111111\n111111\n110000\n110000\n8 1\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\noutput\nCopy\n0\n01\n10\n010\n111\n100\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111\n11111111",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Legs",
        "description": "It's another beautiful day on Farmer John's farm.\nAfter Farmer John arrived at his farm, he counted\nn\nlegs. It is known only chickens and cows live on the farm, and a chicken has\n2\nlegs while a cow has\n4\n.\nWhat is the minimum number of animals Farmer John can have on his farm assuming he counted the legs of all animals?\nInput\nThe first line contains single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nEach test case contains an integer\nn\n(\n2≤n≤2⋅\n10\n3\n,\nn\nis even).\nOutput\nFor each test case, output an integer, the minimum number of animals Farmer John can have on his farm.\nExample\ninput\nCopy\n3\n2\n6\n8\noutput\nCopy\n1\n2\n2",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math",
            "ternary search",
            "*800"
        ]
    },
    {
        "title": "E2. Let Me Teach You a Lesson (Hard Version)",
        "description": "This is the hard version of a problem. The only difference between an easy and a hard version is the constraints on\nt\nand\nn\n. You can make hacks only if both versions of the problem are solved.\nArthur is giving a lesson to his famous\n2n\nknights. Like any other students, they're sitting at the desks in pairs, but out of habit in a circle. The knight\n2i−1\nis sitting at the desk with the knight\n2i\n.\nEach knight has intelligence, which can be measured by an integer. Let's denote the intelligence of the\ni\n-th knight as\na\ni\n. Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible. More formally, he wants to minimize\nmax\n1≤i≤n\n(\na\n2i−1\n+\na\n2i\n)−\nmin\n1≤i≤n\n(\na\n2i−1\n+\na\n2i\n)\n.\nHowever, the Code of Chivalry only allows swapping the opposite knights in the circle, i.e., Arthur can simultaneously perform\na\ni\n:=\na\ni+n\n,\na\ni+n\n:=\na\ni\nfor any\n1≤i≤n\n. Arthur can make any number of such swaps. What is the best result he can achieve?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤10000\n) — the number of test cases. It is followed by descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100000\n) — the number of desks.\nThe second line consists of\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n1≤\na\ni\n≤\n10\n9\n) — the intelligence values of the knights.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n100000\n.\nOutput\nFor each test case, output a single line containing one integer — the minimal difference Arthur can achieve.\nExample\ninput\nCopy\n5\n2\n6 6 4 4\n1\n10 17\n3\n1 10 1 10 1 10\n3\n3 3 4 5 5 4\n5\n1 2 3 4 5 6 7 8 9 10\noutput\nCopy\n0\n0\n0\n2\n4\nNote\nIn the first test case, Arthur can swap the second and the fourth knights. Then the total intelligence at both desks will be\n10\n.\nIn the third test case, Arthur can make\n0\noperations, which will result in the total intelligence of\n11\nat each of the desks.\nIn the fourth test case, Arthur can swap knights with indices\n2\nand\n5\nand achieve the difference of\n2\n. It can be proven that he cannot improve his result any further.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "matrices",
            "two pointers",
            "*2900"
        ]
    },
    {
        "title": "E1. Let Me Teach You a Lesson (Easy Version)",
        "description": "This is the easy version of a problem. The only difference between an easy and a hard version is the constraints on\nt\nand\nn\n. You can make hacks only if both versions of the problem are solved.\nArthur is giving a lesson to his famous\n2n\nknights. Like any other students, they're sitting at the desks in pairs, but out of habit in a circle. The knight\n2i−1\nis sitting at the desk with the knight\n2i\n.\nEach knight has intelligence, which can be measured by an integer. Let's denote the intelligence of the\ni\n-th knight as\na\ni\n. Arthur wants the maximal difference in total intelligence over all pairs of desks to be as small as possible. More formally, he wants to minimize\nmax\n1≤i≤n\n(\na\n2i−1\n+\na\n2i\n)−\nmin\n1≤i≤n\n(\na\n2i−1\n+\na\n2i\n)\n.\nHowever, the Code of Chivalry only allows swapping the opposite knights in the circle, i.e., Arthur can simultaneously perform\na\ni\n:=\na\ni+n\n,\na\ni+n\n:=\na\ni\nfor any\n1≤i≤n\n. Arthur can make any number of such swaps. What is the best result he can achieve?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. It is followed by descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2000\n) — the number of desks.\nThe second line consists of\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n1≤\na\ni\n≤\n10\n9\n) — the intelligence values of the knights.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output a single line containing one integer — the minimal difference Arthur can achieve.\nExample\ninput\nCopy\n5\n2\n6 6 4 4\n1\n10 17\n3\n1 10 1 10 1 10\n3\n3 3 4 5 5 4\n5\n1 2 3 4 5 6 7 8 9 10\noutput\nCopy\n0\n0\n0\n2\n4\nNote\nIn the first test case, Arthur can swap the second and the fourth knights. Then the total intelligence at both desks will be\n10\n.\nIn the third test case, Arthur can make\n0\noperations, which will result in the total intelligence of\n11\nat each of the desks.\nIn the fourth test case, Arthur can swap knights with indices\n2\nand\n5\nand achieve the difference of\n2\n. It can be proven that he cannot improve his result any further.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "2-sat",
            "data structures",
            "dp",
            "matrices",
            "two pointers",
            "*2700"
        ]
    },
    {
        "title": "D. Cases",
        "description": "You're a linguist studying a mysterious ancient language. You know that\nIts words consist only of the first\nc\nletters of the Latin alphabet.\nEach word has a case which can be unambiguously determined by its last letter (different letters correspond to different cases). For example, words \"ABACABA\" and \"ABA\" (if they exist) have the same case in this language because they both have the same ending 'A', whereas \"ALICE\" and \"BOB\" have different cases. If the language does not have a case corresponding to some letter, it means that the word cannot end with this letter.\nThe length of each word is\nk\nor less.\nYou have a single text written in this language. Unfortunately, as the language is really ancient, spaces between words are missing and all letters are uppercase. You wonder what is the minimum number of cases the language can have. Can you find this out?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤10000\n) — the number of test cases. It is followed by descriptions of the test cases.\nThe first line of each test case contains three integers\nn\n,\nc\n,\nk\n(\n1≤k≤n≤\n2\n18\n,\n1≤c≤18\n) — the length of the text, the number of letters in the language, and the maximum length of the word.\nThe second line contains a string of\nn\ncharacters — the text itself. Each character is one of the first\nc\nuppercase letters of the Latin alphabet.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2\n18\nand the sum of\n2\nc\nover all test cases does not exceed\n2\n18\n.\nOutput\nFor each test case, output a single line consisting of a single integer — the minimum number of cases in the language.\nExample\ninput\nCopy\n7\n5 5 1\nABCDE\n3 1 2\nAAA\n3 2 2\nAAB\n10 2 2\nABABABABAB\n4 4 4\nDCBA\n1 17 1\nQ\n9 3 2\nABCABCABC\noutput\nCopy\n5\n1\n2\n1\n1\n1\n2\nNote\nIn the first test case, there must be five cases in the language (for each of the letters 'A', 'B', 'C', 'D', and 'E' there must be a case that has a corresponding ending).\nIn the fourth test case, one case with ending 'B' is sufficient.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "strings",
            "*2300"
        ]
    },
    {
        "title": "C. Squaring",
        "description": "ikrpprpp found an array\na\nconsisting of integers. He likes justice, so he wants to make\na\nfair — that is, make it non-decreasing. To do that, he can perform an act of justice on an index\n1≤i≤n\nof the array, which will replace\na\ni\nwith\na\n2\ni\n(the element at position\ni\nwith its square). For example, if\na=[2,4,3,3,5,3]\nand ikrpprpp chooses to perform an act of justice on\ni=4\n,\na\nbecomes\n[2,4,3,9,5,3]\n.\nWhat is the minimum number of acts of justice needed to make the array non-decreasing?\nInput\nFirst line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases. It is followed by the description of test cases.\nFor each test case, the first line contains an integer\nn\n — size of the array\na\n. The second line contains\nn\n(\n1≤n≤2⋅\n10\n5\n) integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n).\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print an integer — minimum number of acts of justice required to make the array\na\nnon-decreasing. If it is impossible to do that, print\n−1\n.\nExample\ninput\nCopy\n7\n3\n1 2 3\n2\n3 2\n3\n3 1 5\n4\n1 1 2 3\n3\n4 3 2\n9\n16 2 4 2 256 2 4 2 8\n11\n10010 10009 10008 10007 10006 10005 10004 10003 10002 10001 10000\noutput\nCopy\n0\n1\n-1\n0\n3\n15\n55\nNote\nIn the first test case, there's no need to perform acts of justice. The array is fair on its own!\nIn the third test case, it can be proven that the array cannot become non-decreasing.\nIn the fifth test case, ikrpprppp can perform an act of justice on index 3, then an act of justice on index 2, and finally yet another act of justice on index 3. After that,\na\nwill become\n[4,9,16]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*1800"
        ]
    },
    {
        "title": "B2. Bouquet (Hard Version)",
        "description": "This is the hard version of the problem. The only difference is that in this version, instead of listing the number of petals for each flower, the number of petals and the quantity of flowers in the store is set for all types of flowers.\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of\nn\ndifferent types of flowers in the store, each of which is characterized by the number of petals and the quantity of this type of flower. A flower with\nk\npetals costs\nk\ncoins. The girl has decided that the difference in the number of petals between any two flowers she will use to decorate her cake should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has\nm\ncoins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤10000\n) — the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n1≤n≤2⋅\n10\n5\n,1≤m≤\n10\n18\n) — the number of types of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains\nn\ndifferent integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the number of petals of the\ni\n-th flower type in the store (for different indexes\ni≠j\n, it must be\na\ni\n≠\na\nj\n). The third line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n), where\nc\ni\nis the quantity of the\ni\n-th flower type in the store.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the maximum possible number of petals in a bouquet that a girl can collect, observing all the conditions listed above.\nExample\ninput\nCopy\n7\n3 10\n1 2 3\n2 2 1\n3 1033\n206 207 1000\n3 4 1\n6 20\n4 2 7 5 6 1\n1 2 1 3 1 7\n8 100000\n239 30 610 122 24 40 8 2\n12 13123 112 1456 124 100 123 10982\n6 13\n2 4 11 1 3 5\n2 2 1 2 2 1\n8 10330\n206 210 200 201 198 199 222 1000\n9 10 11 12 13 14 15 16\n2 10000000000\n11 12\n87312315 753297050\noutput\nCopy\n7\n1033\n19\n99990\n13\n10000\n9999999999\nNote\nIn the first test case, some valid bouquets are\n(1,1,2,2),(2,2,3),(1,1),(2,2)\n. The maximum over all valid bouquets not greater than\n10\nis\n7\nfor\n(2,2,3)\n. In the second test case, you can assemble a valid bouquet with\n(206,206,207,207,207)\nwith a sum of\n1033\n, which is the maximum number of petals the girl can buy. In the third test case, you can assemble a valid bouquet with\n(5,5,5,4)\nwith a sum of\n19\n. It can be seen that no valid bouquet can have\n20\npetals.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "math",
            "sortings",
            "two pointers",
            "*1700"
        ]
    },
    {
        "title": "B1. Bouquet (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is that in this version, the flowers are specified by enumeration.\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of\nn\nflowers in the store, each of which is characterized by the number of petals, and a flower with\nk\npetals costs\nk\ncoins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has\nm\ncoins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤10000\n) — the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n1≤n≤2⋅\n10\n5\n,1≤m≤\n10\n18\n) — the number of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the number of petals of the\ni\n-th flower in the store.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum possible number of petals in the bouquet that the girl can assemble while meeting all the conditions listed above.\nExample\ninput\nCopy\n5\n5 10\n1 1 2 2 3\n8 20\n4 2 7 5 6 1 1 1\n8 100000\n239 30 610 122 24 40 8 2\n11 13\n2 4 11 1 1 2 3 5 4 3 2\n8 1033\n206 206 206 207 207 207 207 1000\noutput\nCopy\n7\n13\n610\n13\n1033\nNote\nIn the first test case, you can assemble a bouquet with\n(1,1,2,2),(2,2,3),(1,1),(2,2)\n. The maximum over all valid bouquets not greater than\n10\nis\n7\nfor\n(2,2,3)\n. In the third test case, you can assemble a bouquet with only one flower of any type, so the answer is\n610\n. In the fourth test case, you can assemble a bouquet with\n(4,4,5)\n, which gives you\n13\npetals, and it is the maximum amount of petals that the girl can buy.",
        "time_limit": "1.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ]
    },
    {
        "title": "A. Diagonals",
        "description": "Vitaly503 is given a checkered board with a side of\nn\nand\nk\nchips. He realized that all these\nk\nchips need to be placed on the cells of the board (no more than one chip can be placed on a single cell).\nLet's denote the cell in the\ni\n-th row and\nj\n-th column as\n(i,j)\n. A diagonal is the set of cells for which the value\ni+j\nis the same. For example, cells\n(3,1)\n,\n(2,2)\n, and\n(1,3)\nlie on the same diagonal, but\n(1,2)\nand\n(2,3)\ndo not. A diagonal is called occupied if it contains at least one chip.\nDetermine what is the minimum possible number of occupied diagonals among all placements of\nk\nchips.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of sets of input data. Then follow the descriptions of the sets of input data.\nThe only line of each set of input data contains two integers\nn\n,\nk\n(\n1≤n≤100,0≤k≤\nn\n2\n) — the side of the checkered board and the number of available chips, respectively.\nOutput\nFor each set of input data, output a single integer — the minimum number of occupied diagonals with at least one chip that he can get after placing all\nk\nchips.\nExample\ninput\nCopy\n7\n1 0\n2 2\n2 3\n2 4\n10 50\n100 239\n3 9\noutput\nCopy\n0\n1\n2\n3\n6\n3\n5\nNote\nIn the first test case, there are no chips, so 0 diagonals will be occupied. In the second test case, both chips can be placed on diagonal\n(2,1),(1,2)\n, so the answer is 1. In the third test case, 3 chips can't be placed on one diagonal, but placing them on\n(1,2),(2,1),(1,1)\nmakes 2 diagonals occupied. In the 7th test case, chips will occupy all 5 diagonals in any valid placing.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "H. Fortnite",
        "description": "This is an interactive problem!\nTimofey is writing a competition called Capture the Flag (or CTF for short). He has one task left, which involves hacking a security system. The entire system is based on polynomial hashes\n∗\n.\nTimofey can input a string consisting of lowercase Latin letters into the system, and the system will return its polynomial hash. To hack the system, Timofey needs to find the polynomial hash parameters (\np\nand\nm\n) that the system uses.\nTimofey doesn't have much time left, so he will only be able to make\n3\nqueries. Help him solve the task.\n∗\nThe polynomial hash of a string\ns\n, consisting of lowercase Latin letters of length\nn\n, based on\np\nand modulo\nm\nis\n(ord(s1)⋅p0+ord(s2)⋅p1+ord(s3)⋅p2+…+ord(sn)⋅pn−1)modm\n. Where\nsi\ndenotes the\ni\n-th character of the string\ns\n,\nord(chr)\ndenotes the ordinal number of the character\nchr\nin the English alphabet, and\nxmodm\nis the remainder of\nx\nwhen divided by\nm\n.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤103\n) — the number of test cases.\nIt is guaranteed that the\np\nand\nm\nused by the system satisfy the conditions:\n26<p≤50\nand\np+1<m≤2⋅109\n.\nInteraction\nTo make a query to the system, output ?\ns\n, where\ns\nis a string of no more than\n50\ncharacters in length, the hash of which you want to know. In response to this query, you will receive the polynomial hash of the string\ns\n.\nTo output the answer, output !\np\nm\n, where\np\nis the base of the hash, and\nm\nis the modulus. After that, immediately proceed to the next test case.\nYou have to make not more than\n3\nqueries ?, otherwise you will get verdict Wrong Answer.\nAfter outputting a query, do not forget to output a newline and flush the output buffer. Otherwise, you will receive the verdict Idleness limit exceeded. To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nExample\ninput\nCopy\n1\n\n32\n\n28\noutput\nCopy\n? aa\n\n? yb\n\n! 31 59\nNote\nAnswer for the first query is\n(ord(a)⋅310+ord(a)⋅311)mod59=(1+1⋅31)mod59=32\n.\nAnswer for the second query is\n(ord(y)⋅310+ord(b)⋅311)mod59=(25+2⋅31)mod59=28\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "games",
            "greedy",
            "hashing",
            "interactive",
            "math",
            "number theory",
            "strings",
            "*3500"
        ]
    },
    {
        "title": "G. Minecraft",
        "description": "After winning another Bed Wars game, Masha and Olya wanted to relax and decided to play a new game. Masha gives Olya an array\na\nof length\nn\nand a number\ns\n. Now Olya's task is to find a non-negative number\nx\nsuch that\n∑\ni=1\nn\na\ni\n⊕x=s\n. But she is very tired after a tight round, so please help her with this.\nBut this task seemed too simple to them, so they decided to make the numbers larger (up to\n2\nk\n) and provide you with their binary representation.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k,n⋅k≤2⋅\n10\n6\n) — the length of the array\na\nand the length of the binary representation of all numbers.\nThe second line contains a string of length\nk\n, consisting of zeros and ones — the binary representation of the number\ns\n, starting from the most significant bits.\nThe next\nn\nlines also contain strings of length\nk\n, consisting of zeros and ones, the\ni\n-th of these strings contains the binary representation of the number\na\ni\n, starting from the most significant bits.\nIt is guaranteed that the sum of the values\nn⋅k\nfor all test cases does not exceed\n2⋅\n10\n6\n.\nOutput\nFor each test case, output a string of length\nk\non a separate line, consisting of zeros or ones — the binary representation of any suitable number\nx\n(\nx≥0\n), starting from the most significant bits, or\n−1\nif such\nx\ndoes not exist.\nExample\ninput\nCopy\n4\n4 5\n01011\n01110\n00110\n01100\n01111\n2 8\n00101001\n10111111\n10011110\n5 4\n0101\n0010\n0000\n0000\n0010\n0011\n6 5\n00011\n10110\n11001\n01010\n11100\n10011\n10000\noutput\nCopy\n01110\n10011010\n0010\n-1\nNote\nIn the first test case,\ns=11,a=[14,6,12,15]\n, if\nx=14\n, then\n∑\ni=1\nn\na\ni\n⊕x=(14⊕14)+(6⊕14)+(12⊕14)+(15⊕14)=0+8+2+1=11=s\n.\nIn the second test case,\ns=41,a=[191,158]\n, if\nx=154\n, then\n∑\ni=1\nn\na\ni\n⊕x=(191⊕154)+(158⊕154)=37+4=41=s\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "graphs",
            "math",
            "*2600"
        ]
    },
    {
        "title": "F. Stardew Valley",
        "description": "Pelican Town represents\nn\nhouses connected by\nm\nbidirectional roads. Some roads have NPCs standing on them. Farmer Buba needs to walk on each road with an NPC and talk to them.\nHelp the farmer find a route satisfying the following properties:\nThe route starts at some house, follows the roads, and ends at the same house.\nThe route does not follow any road more than once (in both directions together).\nThe route follows each road with an NPC exactly once.\nNote that the route can follow roads without NPCs, and you do not need to minimize the length of the route.\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤5⋅\n10\n5\n,1≤m≤5⋅\n10\n5\n) — the number of houses and roads in Pelican Town respectively.\nIn each of the next\nm\nlines, three integers\nu\n,\nv\n, and\nc\n(\n1≤u,v≤n,c=0/1\n) are given — the ends of the road and whether an NPC is on this road. If\nc=1\n, then the road has an NPC. If\nc=0\n, then the road has no NPC.\nThe graph may contain multiple edges and loops, and if there are multiple edges with NPCs standing on them, the route must follow each of these roads.\nIt is guaranteed that you can reach any house from any other by walking on the roads with NPCs only.\nIt is guaranteed that the sum of\nn\nand\nm\nfor all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, if there is no solution, then output \"No\" (without quotes).\nOtherwise, output \"Yes\" (without quotes), and then output\nk\n — the number of roads in the route. In the next line, output\nk+1\nnumbers — the houses of the route in the order of traversal. Note that the first house should match the last one, as the route is cyclic.\nIf there are multiple answers, you can print any of them.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n3\n3 2\n1 2 1\n2 3 1\n3 3\n1 2 1\n1 3 1\n2 3 0\n5 9\n1 2 0\n5 2 1\n5 4 1\n5 1 1\n2 3 1\n5 2 1\n4 1 0\n4 3 0\n5 2 0\noutput\nCopy\nNO\nYES\n3\n1 2 3 1 \nYES\n7\n1 2 5 4 3 2 5 1 \nNote\nNote that in the third test case, there are multiple edges\n(5,2)\n. You must walk on two of them.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E. Wooden Game",
        "description": "You are given a forest of\nk\nrooted trees\n∗\n. Lumberjack Timofey wants to cut down the entire forest by applying the following operation:\nSelect a subtree\n†\n†\nof any vertex of one of the trees and remove it from the tree.\nTimofey loves bitwise operations, so he wants the bitwise OR of the sizes of the subtrees he removed to be maximum. Help him and find the maximum result he can obtain.\n∗\nA tree is a connected graph without cycles, loops, or multiple edges. In a rooted tree, a selected vertex is called a root. A forest is a collection of one or more trees.\n†\n†\nThe subtree of a vertex\nv\nis the set of vertices for which\nv\nlies on the shortest path from this vertex to the root, including\nv\nitself.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nk\n(\n1≤k≤\n10\n6\n) — the number of trees in the forest.\nThis is followed by a description of each of the\nk\ntrees:\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the size of the tree. The vertices of the tree are numbered with integers from\n1\nto\nn\n. The root of the tree is vertex number\n1\n.\nThe second line contains\nn−1\nintegers\np\n2\n,\np\n3\n,…\np\nn\n(\n1≤\np\ni\n<i\n), where\np\ni\n — the parent of vertex\ni\n.\nIt is guaranteed that the sum of\nk\nand\nn\nfor all sets of input data does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the maximum result that can be obtained.\nExample\ninput\nCopy\n3\n1\n1\n\n2\n4\n1 2 2\n6\n1 1 3 1 3\n1\n10\n1 2 2 1 1 5 7 6 4\noutput\nCopy\n1\n7\n10\nNote\nIn the second test case, the trees look like this:\nThe first operation removes the entire second tree.\nThe second operation removes vertex\n4\nfrom the first tree.\nThe third operation removes the first tree. The result is\n6|1|3=7\n(\n|\ndenotes bitwise OR).\nIn the third test case, the entire tree needs to be removed.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "D. Funny Game",
        "description": "Vanya has a graph with\nn\nvertices (numbered from\n1\nto\nn\n) and an array\na\nof\nn\nintegers; initially, there are no edges in the graph. Vanya got bored, and to have fun, he decided to perform\nn−1\noperations.\nOperation number\nx\n(operations are numbered in order starting from\n1\n) is as follows:\nChoose\n2\ndifferent numbers\n1≤u,v≤n\n, such that\n|\na\nu\n−\na\nv\n|\nis divisible by\nx\n.\nAdd an undirected edge between vertices\nu\nand\nv\nto the graph.\nHelp Vanya get a connected\n∗\ngraph using the\nn−1\noperations, or determine that it is impossible.\n∗\nA graph is called connected if it is possible to reach any vertex from any other by moving along the edges.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains the number\nn\n(\n1≤n≤2000\n) — the number of vertices in the graph.\nThe second line of each test case contains\nn\nnumbers\na\n1\n,\na\n2\n,⋯\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, if there is no solution, then output \"No\" (without quotes).\nOtherwise, output \"Yes\" (without quotes), and then output\nn−1\nlines, where in the\ni\n-th line, output the numbers\nu\nand\nv\nthat need to be chosen for operation\ni\n.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n8\n2\n1 4\n4\n99 7 1 13\n5\n10 2 31 44 73\n5\n87 6 81 44 32\n5\n62 35 33 79 16\n5\n6 51 31 69 42\n5\n52 63 25 21 5\n12\n33 40 3 11 31 43 37 8 50 5 12 22\noutput\nCopy\nYES\n2 1\nYES\n4 1\n2 1\n3 2\nYES\n5 1\n4 1\n3 1\n2 1\nYES\n4 1\n3 1\n2 1\n5 4\nYES\n3 1\n5 1\n2 1\n4 2\nYES\n4 1\n5 1\n2 1\n3 2\nYES\n2 1\n5 2\n3 1\n4 3\nYES\n9 1\n12 9\n11 1\n10 1\n6 1\n7 6\n2 1\n8 2\n5 2\n3 1\n4 1\nNote\nLet's consider the second test case.\nFirst operation\n(x=1)\n: we can connect vertices\n4\nand\n1\n, since\n|\na\n4\n−\na\n1\n|=|13−99|=|−86|=86\n, and\n86\nis divisible by\n1\n.\nSecond operation\n(x=2)\n: we can connect vertices\n2\nand\n1\n, since\n|\na\n2\n−\na\n1\n|=|7−99|=|−92|=92\n, and\n92\nis divisible by\n2\n.\nThird operation\n(x=3)\n: we can connect vertices\n3\nand\n2\n, since\n|\na\n3\n−\na\n2\n|=|1−7|=|−6|=6\n, and\n6\nis divisible by\n3\n.\nFrom the picture, it can be seen that a connected graph is obtained.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dsu",
            "graphs",
            "greedy",
            "math",
            "number theory",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "C. Hungry Games",
        "description": "Yaroslav is playing a computer game, and at one of the levels, he encountered\nn\nmushrooms arranged in a row. Each mushroom has its own level of toxicity; the\ni\n-th mushroom from the beginning has a toxicity level of\nai\n. Yaroslav can choose two integers\n1≤l≤r≤n\n, and then his character will take turns from left to right to eat mushrooms from this subsegment one by one, i.e., the mushrooms with numbers\nl,l+1,l+2,…,r\n.\nThe character has a toxicity level\ng\n, initially equal to\n0\n. The computer game is defined by the number\nx\n — the maximum toxicity level at any given time. When eating a mushroom with toxicity level\nk\n, the following happens:\nThe toxicity level of the character is increased by\nk\n.\nIf\ng≤x\n, the process continues; otherwise,\ng\nbecomes zero and the process continues.\nYaroslav became interested in how many ways there are to choose the values of\nl\nand\nr\nsuch that the final value of\ng\nis not zero. Help Yaroslav find this number!\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤104\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\n,\nx\n(\n1≤n≤2⋅105,1≤x≤109\n) — the number of mushrooms and the maximum toxicity level.\nThe second line of each test case contains\nn\nnumbers\na1,a2,…,an\n(\n1≤ai≤109\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output a single number — the number of subsegments such that the final value of\ng\nwill not be zero.\nExample\ninput\nCopy\n5\n4 2\n1 1 1 1\n3 2\n1 2 3\n1 6\n10\n6 3\n1 2 1 4 3 8\n5 999999999\n999999999 999999998 1000000000 1000000000 500000000\noutput\nCopy\n8\n2\n0\n10\n7\nNote\nIn the first test case, the subsegments\n(1,1)\n,\n(1,2)\n,\n(1,4)\n,\n(2,2)\n,\n(2,3)\n,\n(3,3)\n,\n(3,4)\nand\n(4,4)\nare suitable.\nIn the second test case, non-zero\ng\nwill remain only on the subsegments\n(1,1)\nand\n(2,2)\n.\nIn the third test case, on the only possible subsegment,\ng\nwill be zero.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "B. Fun Game",
        "description": "Vova really loves the XOR operation (denoted as\n⊕\n). Recently, when he was going to sleep, he came up with a fun game.\nAt the beginning of the game, Vova chooses two binary sequences\ns\nand\nt\nof length\nn\nand gives them to Vanya. A binary sequence is a sequence consisting only of the numbers\n0\nand\n1\n. Vanya can choose integers\nl,r\nsuch that\n1≤l≤r≤n\n, and for all\nl≤i≤r\nsimultaneously replace\ns\ni\nwith\ns\ni\n⊕\ns\ni−l+1\n, where\ns\ni\nis the\ni\n-th element of the sequence\ns\n.\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence\nt\nfrom the sequence\ns\n. Determine if the game will be interesting for the sequences\ns\nand\nt\n.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nq\n(\n1≤q≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the sequences\ns\nand\nt\n.\nThe second line of each test case contains a binary sequence\ns\nof length\nn\n.\nThe third line of each test case contains a binary sequence\nt\nof length\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n6\n1\n0\n1\n7\n0110100\n0110100\n9\n100101010\n101111110\n4\n0011\n1011\n4\n0100\n0001\n8\n10110111\n01100000\noutput\nCopy\nNO\nYES\nYES\nNO\nYES\nYES\nNote\nIn the first test case, Vanya will not be able to change the sequence\ns\nwith the only possible action of choosing\nl=r=1\n.\nIn the second test case, the sequences\ns\nand\nt\nare already equal.\nIn the third test case, Vanya can act as follows:\nChoose\nl=3\nand\nr=5\n, then\ns\nwill become\n101101010\n.\nChoose\nl=5\nand\nr=6\n, then\ns\nwill become\n101111010\n.\nChoose\nl=7\nand\nr=7\n, then\ns\nwill become\n101111110\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Diverse Game",
        "description": "Petr, watching Sergey's stream, came up with a matrix\na\n, consisting of\nn\nrows and\nm\ncolumns (the number in the\ni\n-th row and\nj\n-th column is denoted as\nai,j\n), which contains all integers from\n1\nto\nn⋅m\n. But he didn't like the arrangement of the numbers, and now he wants to come up with a new matrix\nb\n, consisting of\nn\nrows and\nm\ncolumns, which will also contain all integers from\n1\nto\nn⋅m\n, such that for any\n1≤i≤n,1≤j≤m\nit holds that\nai,j≠bi,j\n.\nYou are given the matrix\na\n, construct any matrix\nb\nthat meets Petr's requirements, or determine that it is impossible.\nHurry up! Otherwise, he will donate all his money to the stream in search of an answer to his question.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤103\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤10\n) — the number of rows and columns of matrix\na\n.\nThe next\nn\nlines contain\nm\nintegers each, describing matrix\na\n. The\ni\n-th of these lines contains the elements of matrix\nai,1,ai,2,…,ai,m\n.\nIt is guaranteed that all numbers in matrix\na\nare distinct and\n1≤ai,j≤n⋅m\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n5⋅104\n.\nOutput\nFor each test case, output\nn⋅m\nintegers — any suitable matrix\nb\n, or\n−1\nif such a matrix does not exist.\nExample\ninput\nCopy\n5\n1 1\n1\n2 1\n2\n1\n1 5\n2 4 5 3 1\n2 4\n1 2 3 4\n5 6 7 8\n3 3\n4 2 1\n9 8 3\n6 7 5\noutput\nCopy\n-1\n1 \n2 \n4 5 3 1 2 \n6 7 8 5 \n2 3 4 1 \n8 3 9 \n7 5 6 \n2 1 4 \nNote\nIn the first test case, there is only one element in the matrix, so matrix\nb\nis the only matrix and it does not fit.\nIn the second test case\na1,1=2≠1=b1,1\n,\na2,1=1≠2=b2,1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F2. Dyn-scripted Robot (Hard Version)",
        "description": "This is the hard version of the problem. The only difference is that in this version\nk≤\n10\n12\n. You can make hacks only if both versions of the problem are solved.\nGiven a\nw×h\nrectangle on the\nOxy\nplane, with points\n(0,0)\nat the bottom-left and\n(w,h)\nat the top-right of the rectangle.\nYou also have a robot initially at point\n(0,0)\nand a script\ns\nof\nn\ncharacters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\nThe robot can only move inside the rectangle; otherwise, it will change the script\ns\nas follows:\nIf it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\nIf it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\nThen, it will execute the changed script starting from the character which it couldn't execute.\nAn example of the robot's movement process,\ns=\"ULULURD\"\nThe script\ns\nwill be executed for\nk\ntimes continuously. All changes to the string\ns\nwill be retained even when it is repeated. During this process, how many times will the robot move to the point\n(0,0)\nin total? Note that the initial position does NOT count.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains four integers\nn\n,\nk\n,\nw\n, and\nh\n(\n1≤n,w,h≤\n10\n6\n;\n1≤k≤\n10\n12\n).\nThe second line contains a single string\ns\nof size\nn\n(\ns\ni\n∈{L,R,U,D}\n) — the script to be executed.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print a single integer — the number of times the robot reaches\n(0,0)\nwhen executing script\ns\nfor\nk\ntimes continuously.\nExample\ninput\nCopy\n6\n2 4 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 6 3 3\nRUURD\n7 5 3 4\nRRDLUUU\n7 123456789999 3 2\nULULURD\noutput\nCopy\n1\n4\n3\n1\n1\n41152263332\nNote\nIn the first test case, the robot only moves up and right for the first two executions. After that, it occupies the position\n(2,2)\n. For the next two executions, it moves down and left and finishes at\n(0,0)\n. So the answer is\n1\n.\nIn the second test case, each time executing the script the robot visits the origin twice. And since\nk=2\n, it visits the origin\n2⋅2=4\ntimes overall.\nIn the third test case, the visualization is shown as below:",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "chinese remainder theorem",
            "math",
            "number theory",
            "*2800"
        ]
    },
    {
        "title": "F1. Dyn-scripted Robot (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is that in this version\nk≤n\n. You can make hacks only if both versions of the problem are solved.\nGiven a\nw×h\nrectangle on the\nOxy\nplane, with points\n(0,0)\nat the bottom-left and\n(w,h)\nat the top-right of the rectangle.\nYou also have a robot initially at point\n(0,0)\nand a script\ns\nof\nn\ncharacters. Each character is either L, R, U, or D, which tells the robot to move left, right, up, or down respectively.\nThe robot can only move inside the rectangle; otherwise, it will change the script\ns\nas follows:\nIf it tries to move outside a vertical border, it changes all L characters to R's (and vice versa, all R's to L's).\nIf it tries to move outside a horizontal border, it changes all U characters to D's (and vice versa, all D's to U's).\nThen, it will execute the changed script starting from the character which it couldn't execute.\nAn example of the robot's movement process,\ns=\"ULULURD\"\nThe script\ns\nwill be executed for\nk\ntimes continuously. All changes to the string\ns\nwill be retained even when it is repeated. During this process, how many times will the robot move to the point\n(0,0)\nin total? Note that the initial position does NOT count.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nThe first line of each test case contains four integers\nn\n,\nk\n,\nw\n, and\nh\n(\n1≤n,w,h≤106\n;\n1≤k≤n\n).\nThe second line contains a single string\ns\nof size\nn\n(\nsi∈{L,R,U,D}\n) — the script to be executed.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n106\n.\nOutput\nFor each test case, print a single integer — the number of times the robot reaches\n(0,0)\nwhen executing script\ns\nfor\nk\ntimes continuously.\nExample\ninput\nCopy\n5\n2 2 2 2\nUR\n4 2 1 1\nLLDD\n6 3 3 1\nRLRRRL\n5 5 3 3\nRUURD\n7 5 3 4\nRRDLUUU\noutput\nCopy\n0\n4\n3\n0\n1\nNote\nIn the first test case, the robot only moves up and right. In the end, it occupies the position\n(2,2)\nbut never visits\n(0,0)\n. So the answer is\n0\n.\nIn the second test case, each time executing the script the robot visits the origin twice. And since\nk=2\n, it visits the origin\n2⋅2=4\ntimes overall.\nIn the third test case, the visualization is shown as below:",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "chinese remainder theorem",
            "constructive algorithms",
            "math",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "E. Xor-Grid Problem",
        "description": "Given a matrix\na\nof size\nn×m\n, each cell of which contains a non-negative integer. The integer lying at the intersection of the\ni\n-th row and the\nj\n-th column of the matrix is called\na\ni,j\n.\nLet's define\nf(i)\nand\ng(j)\nas the XOR of all integers in the\ni\n-th row and the\nj\n-th column, respectively. In one operation, you can either:\nSelect any row\ni\n, then assign\na\ni,j\n:=g(j)\nfor each\n1≤j≤m\n; or\nSelect any column\nj\n, then assign\na\ni,j\n:=f(i)\nfor each\n1≤i≤n\n.\nAn example of applying an operation on column\n2\nof the matrix.\nIn this example, as we apply an operation on column\n2\n, all elements in this column are changed:\na\n1,2\n:=f(1)=\na\n1,1\n⊕\na\n1,2\n⊕\na\n1,3\n⊕\na\n1,4\n=1⊕1⊕1⊕1=0\na\n2,2\n:=f(2)=\na\n2,1\n⊕\na\n2,2\n⊕\na\n2,3\n⊕\na\n2,4\n=2⊕3⊕5⊕7=3\na\n3,2\n:=f(3)=\na\n3,1\n⊕\na\n3,2\n⊕\na\n3,3\n⊕\na\n3,4\n=2⊕0⊕3⊕0=1\na\n4,2\n:=f(4)=\na\n4,1\n⊕\na\n4,2\n⊕\na\n4,3\n⊕\na\n4,4\n=10⊕11⊕12⊕16=29\nYou can apply the operations any number of times. Then, we calculate the\nbeauty\nof the final matrix by summing the absolute differences between all pairs of its adjacent cells.\nMore formally,\nbeauty(a)=∑|\na\nx,y\n−\na\nr,c\n|\nfor all cells\n(x,y)\nand\n(r,c)\nif they are adjacent. Two cells are considered adjacent if they share a side.\nFind the minimum\nbeauty\namong all obtainable matrices.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤250\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤15\n) — the number of rows and columns of\na\n, respectively.\nThe next\nn\nlines, each containing\nm\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n0≤\na\ni,j\n<\n2\n20\n) — description of the matrix\na\n.\nIt is guaranteed that the sum of\n(\nn\n2\n+\nm\n2\n)\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, print a single integer\nb\n — the smallest possible\nbeauty\nof the matrix.\nExample\ninput\nCopy\n4\n1 2\n1 3\n2 3\n0 1 0\n5 4 4\n2 3\n0 2 4\n4 5 1\n3 3\n1 2 3\n4 5 6\n7 8 9\noutput\nCopy\n1\n3\n13\n24\nNote\nLet's denote\nr(i)\nas the first type operation applied on the\ni\n-th row, and\nc(j)\nas the second type operation applied on the\nj\n-th column.\nIn the first test case, you can apply an operation\nc(1)\n, which assigns\na\n1,1\n:=1⊕3=2\n. Then, we'll receive this matrix:\n2 3\nIn the second test case, you can apply an operation\nr(1)\n, which assigns:\na\n1,1\n:=g(1)=0⊕5=5\na\n1,2\n:=g(2)=1⊕4=5\na\n1,3\n:=g(3)=0⊕4=4\nThe resulting matrix after performing the operation is:\n5 5 4\n5 4 4\nIn the third test case, the best way to achieve minimum\nbeauty\nis applying three operations:\nc(3)\n,\nr(2)\n, and\nc(2)\n. The resulting matrix is:\n0 4 6\n4 5 6",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "implementation",
            "*2700"
        ]
    },
    {
        "title": "D. Med-imize",
        "description": "Given two positive integers\nn\nand\nk\n, and another array\na\nof\nn\nintegers.\nIn one operation, you can select any subarray of size\nk\nof\na\n, then remove it from the array without changing the order of other elements. More formally, let\n(l,r)\nbe an operation on subarray\na\nl\n,\na\nl+1\n,…,\na\nr\nsuch that\nr−l+1=k\n, then performing this operation means replacing\na\nwith\n[\na\n1\n,…,\na\nl−1\n,\na\nr+1\n,…,\na\nn\n]\n.\nFor example, if\na=[1,2,3,4,5]\nand we perform operation\n(3,5)\non this array, it will become\na=[1,2]\n. Moreover, operation\n(2,4)\nresults in\na=[1,5]\n, and operation\n(1,3)\nresults in\na=[4,5]\n.\nYou have to repeat the operation while the length of\na\nis greater than\nk\n(which means\n|a|>k\n). What is the largest possible median\n†\n†\nof all remaining elements of the array\na\nafter the process?\n†\n†\nThe median of an array of length\nn\nis the element whose index is\n⌊(n+1)/2⌋\n⌊\nafter we sort the elements in non-decreasing order. For example:\nmedian([2,1,5,4,3])=3\n,\nmedian([5])=5\n, and\nmedian([6,8,2,4])=4\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤5⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the largest median possible after performing the operations.\nExample\ninput\nCopy\n5\n4 3\n3 9 9 2\n5 3\n3 2 5 6 4\n7 1\n5 9 2 6 5 4 6\n8 2\n7 1 2 6 8 3 4 5\n4 5\n3 4 5 6\noutput\nCopy\n3\n4\n9\n6\n4\nNote\nIn the first test case, you can select a subarray\n(l,r)\nwhich can be either\n(1,3)\nor\n(2,4)\n. Thus, two obtainable final arrays are\n[3]\nand\n[2]\n. The former one has the larger median (\n3>2\n) so the answer is\n3\n.\nIn the second test case, three obtainable final arrays are\n[6,4]\n,\n[3,4]\n, and\n[3,2]\n. Their medians are\n4\n,\n3\n, and\n2\nrespectively. The answer is\n4\n.\nIn the third test case, only one element is left in the final array and it can be any element of the initial array. The largest one among them is\n9\n, so the answer is\n9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "*2200"
        ]
    },
    {
        "title": "C. Light Switches",
        "description": "There is an apartment consisting of\nn\nrooms, each with its light initially turned off.\nTo control the lights in these rooms, the owner of the apartment decided to install chips in the rooms so that each room has exactly one chip, and the chips are installed at different times. Specifically, these times are represented by the array\na\n1\n,\na\n2\n,…,\na\nn\n, where\na\ni\nis the time (in minutes) at which a chip is installed in the\ni\n-th room.\nAs soon as a chip is installed, it changes the room's light status every\nk\nminutes — it turns on the light for\nk\nminutes, then turns it off for the next\nk\nminutes, then turns it back on for the next\nk\nminutes, and so on. In other words, the light status is changed by the chip at minute\na\ni\n,\na\ni\n+k\n,\na\ni\n+2k\n,\na\ni\n+3k\n,\n…\nfor the\ni\n-th room.\nWhat is the earliest moment when all rooms in the apartment have their lights turned on?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤2⋅\n10\n5\n) — the number of rooms in the apartment and the period of the chips.\nThe second line contains\nn\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the moments when the chips are installed.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the answer to the question (in minutes). If there is no such moment that the lights are turned on in all the rooms, print\n−1\ninstead.\nExample\ninput\nCopy\n9\n4 4\n2 3 4 5\n4 3\n2 3 4 5\n4 3\n3 4 8 9\n3 3\n6 2 1\n1 1\n1\n7 5\n14 34 6 25 46 7 17\n6 5\n40 80 99 60 90 50\n6 5\n64 40 50 68 70 10\n2 1\n1 1000000000\noutput\nCopy\n5\n-1\n10\n8\n1\n47\n100\n-1\n-1\nNote\nIn the first test case, all lights will be on by the minute\n5\nwithout any of them being turned off by the chips. The answer is\n5\n.\nIn the second test case, due to\nk=3\n, the\n1\n-st light will be on at minutes\n2,3,4,8,9,10,14,…\n; meanwhile, the\n4\n-th light will be on at minutes\n5,6,7,11,12,13,17,…\n. These two sequences don't have any number in common, so they will never be on at the same time.\nIn the third test case, it can be seen that the\n1\n-st and\n2\n-nd lights will be turned off at minutes\n6\nand\n7\n, but the chips will turn them back on at minutes\n9\nand\n10\n. The\n3\n-rd and\n4\n-th lights will also be on at minute\n10\n, so the answer is\n10\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1400"
        ]
    },
    {
        "title": "B. Parity and Sum",
        "description": "Given an array\na\nof\nn\npositive integers.\nIn one operation, you can pick any pair of indexes\n(i,j)\nsuch that\na\ni\nand\na\nj\nhave distinct parity, then replace the smaller one with the sum of them. More formally:\nIf\na\ni\n<\na\nj\n, replace\na\ni\nwith\na\ni\n+\na\nj\n;\nOtherwise, replace\na\nj\nwith\na\ni\n+\na\nj\n.\nFind the minimum number of operations needed to make all elements of the array have the same parity.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required.\nExample\ninput\nCopy\n7\n5\n1 3 5 7 9\n4\n4 4 4 4\n3\n2 3 4\n4\n3 2 2 8\n6\n4 3 6 1 2 1\n6\n3 6 1 2 1 2\n5\n999999996 999999997 999999998 999999999 1000000000\noutput\nCopy\n0\n0\n2\n4\n3\n3\n3\nNote\nIn the first test case, all integers already have the same parity. Therefore, no operation is needed.\nIn the third test case, we can perform two operations\n(1,2)\nand\n(1,3)\n. The array\na\ntransforms as follows:\na=[2,3,4]⟶[5,3,4]⟶[5,3,9]\n.\nIn the fourth test case, an example of an optimal sequence of operations is\n(1,2)\n,\n(1,3)\n,\n(1,4)\n, and\n(1,4)\n. The array\na\ntransforms as follows:\na=[3,2,2,8]⟶[3,5,2,8]⟶[3,5,5,8]⟶[11,5,5,8]⟶[11,5,5,19]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ]
    },
    {
        "title": "A. Question Marks",
        "description": "Tim is doing a test consisting of\n4n\nquestions; each question has\n4\noptions: 'A', 'B', 'C', and 'D'. For each option, there are exactly\nn\ncorrect answers corresponding to that option — meaning there are\nn\nquestions with the answer 'A',\nn\nquestions with the answer 'B',\nn\nquestions with the answer 'C', and\nn\nquestions with the answer 'D'.\nFor each question, Tim wrote his answer on the answer sheet. If he could not figure out the answer, he would leave a question mark '?' for that question.\nYou are given his answer sheet of\n4n\ncharacters. What is the maximum number of correct answers Tim can get?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤100\n).\nThe second line of each test case contains a string\ns\nof\n4n\ncharacters (\ns\ni\n∈{A,B,C,D,?}\n) — Tim's answers for the questions.\nOutput\nFor each test case, print a single integer — the maximum score that Tim can achieve.\nExample\ninput\nCopy\n6\n1\nABCD\n2\nAAAAAAAA\n2\nAAAABBBB\n2\n????????\n3\nABCABCABCABC\n5\nACADC??ACAC?DCAABC?C\noutput\nCopy\n4\n2\n4\n0\n9\n13\nNote\nIn the first test case, there is exactly one question with each answer 'A', 'B', 'C', and 'D'; so it's possible that Tim gets all his answers correct.\nIn the second test case, there are only two correct answers 'A' which makes him get exactly\n2\npoints in any case.\nIn the third test case, Tim can get at most\n2\ncorrect answers with option 'A' and\n2\ncorrect answers with option 'B'. For example, he would get\n4\npoints if the answers were 'AACCBBDD'.\nIn the fourth test case, he refuses to answer any question at all, which makes him get\n0\npoints.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "G. Ultra-Meow",
        "description": "K1o0n gave you an array\na\nof length\nn\n, consisting of numbers\n1,2,…,n\n. Accept it? Of course! But what to do with it? Of course, calculate\nMEOW(a)\n.\nLet\nMEX(S,k)\nbe the\nk\n-th positive (strictly greater than zero) integer in ascending order that is not present in the set\nS\n. Denote\nMEOW(a)\nas the sum of\nMEX(b,|b|+1)\n, over all distinct subsets\nb\nof the array\na\n.\nExamples of\nMEX(S,k)\nvalues for sets:\nMEX({3,2},1)=1\n, because\n1\nis the first positive integer not present in the set;\nMEX({4,2,1},2)=5\n, because the first two positive integers not present in the set are\n3\nand\n5\n;\nMEX({},4)=4\n, because there are no numbers in the empty set, so the first\n4\npositive integers not present in it are\n1,2,3,4\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nIn a single line of each test case, an integer\nn\n(\n1≤n≤5000\n) is entered, the size of the array of gifted numbers.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n25⋅\n10\n6\n.\nOutput\nFor each test case, output a single number —\nMEOW(a)\n. Since it may be very large, output it modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n5\n2\n3\n4999\n5\n1\noutput\nCopy\n12\n31\n354226409\n184\n4",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2000"
        ]
    },
    {
        "title": "F. Valuable Cards",
        "description": "In his favorite cafe Kmes once again wanted to try the herring under a fur coat. Previously, it would not have been difficult for him to do this, but the cafe recently introduced a new purchasing policy.\nNow, in order to make a purchase, Kmes needs to solve the following problem:\nn\ncards with prices for different positions are laid out in front of him, on the\ni\n-th card there is an integer\na\ni\n, among these prices there is no whole positive integer\nx\n.\nKmes is asked to divide these cards into the minimum number of bad segments (so that each card belongs to exactly one segment). A segment is considered bad if it is impossible to select a subset of cards with a product equal to\nx\n. All segments, in which Kmes will divide the cards, must be bad.\nFormally, the segment\n(l,r)\nis bad if there are no indices\ni\n1\n<\ni\n2\n<…<\ni\nk\nsuch that\nl≤\ni\n1\n,\ni\nk\n≤r\n, and\na\ni\n1\n⋅\na\ni\n2\n…⋅\na\ni\nk\n=x\n.\nHelp Kmes determine the minimum number of bad segments in order to enjoy his favorite dish.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each set of input data gives you\n2\nintegers\nn\nand\nx\n(\n1≤n≤\n10\n5\n,2≤x≤\n10\n5\n) — the number of cards and the integer, respectively.\nThe second line of each set of input data contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤2⋅\n10\n5\n,\na\ni\n≠x\n) — the prices on the cards.\nIt is guaranteed that the sum of\nn\nover all sets of test data does not exceed\n10\n5\n.\nOutput\nFor each set of input data, output the minimum number of bad segments.\nExample\ninput\nCopy\n8\n6 4\n2 3 6 2 1 2\n9 100000\n50000 25000 12500 6250 3125 2 4 8 16\n5 2\n1 1 1 1 1\n8 6\n4 3 4 3 4 3 4 3\n7 12\n6 11 1 3 11 10 2\n10 5\n2 4 4 2 4 4 4 3 1 1\n7 8\n4 6 5 1 2 4 1\n8 27\n3 9 17 26 2 20 9 3\noutput\nCopy\n3\n2\n1\n1\n2\n1\n3\n3",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "number theory",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "E. Novice's Mistake",
        "description": "One of the first programming problems by K1o0n looked like this: \"Noobish_Monk has\nn\n(1≤n≤100)\nfriends. Each of them gave him\na\n(1≤a≤10000)\napples for his birthday. Delighted with such a gift, Noobish_Monk returned\nb\n(1≤b≤min(10000,a⋅n))\napples to his friends. How many apples are left with Noobish_Monk?\"\nK1o0n wrote a solution, but accidentally considered the value of\nn\nas a string, so the value of\nn⋅a−b\nwas calculated differently. Specifically:\nwhen multiplying the string\nn\nby the integer\na\n, he will get the string\ns=\nn+n+⋯+n+n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\na times\nwhen subtracting the integer\nb\nfrom the string\ns\n, the last\nb\ncharacters will be removed from it. If\nb\nis greater than or equal to the length of the string\ns\n, it will become empty.\nLearning about this, ErnKor became interested in how many pairs\n(a,b)\nexist for a given\nn\n, satisfying the constraints of the problem, on which K1o0n's solution gives the correct answer.\n\"The solution gives the correct answer\" means that it outputs a non-empty string, and this string, when converted to an integer, equals the correct answer, i.e., the value of\nn⋅a−b\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n)  — the number of test cases.\nFor each test case, a single line of input contains an integer\nn\n(\n1≤n≤100\n).\nIt is guaranteed that in all test cases,\nn\nis distinct.\nOutput\nFor each test case, output the answer in the following format:\nIn the first line, output the integer\nx\n — the number of bad tests for the given\nn\n.\nIn the next\nx\nlines, output two integers\na\ni\nand\nb\ni\n — such integers that K1o0n's solution on the test \"\nn\na\ni\nb\ni\n\" gives the correct answer.\nExample\ninput\nCopy\n3\n2\n3\n10\noutput\nCopy\n3\n20 18 \n219 216 \n2218 2214 \n1\n165 162 \n1\n1262 2519 \nNote\nIn the first example,\na=20\n,\nb=18\nare suitable, as \"\n2\n\"\n⋅20−18=\n\"\n22222222222222222222\n\"\n−18=22=2⋅20−18",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "math",
            "strings",
            "*1700"
        ]
    },
    {
        "title": "D. Test of Love",
        "description": "ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of\n1\nmeter and a length of\nn\nmeters.\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from\n0\nto\nn+1\n) ErnKor can swim in the water for no more than\nk\nmeters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the\n0\nand\nn+1\nmeters respectively. The river can be represented as\nn\nsegments, each with a length of\n1\nmeter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows:\nIf he is on the surface (i.e., on the bank or on a log), he can jump forward for no more than\nm\n(\n1≤m≤10\n) meters (he can jump on the bank, on a log, or in the water).\nIf he is in the water, he can only swim to the next river segment (or to the bank if he is at the\nn\n-th meter).\nErnKor cannot land in a segment with a crocodile in any way.\nDetermine if ErnKor can reach the right bank.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains three numbers\nn,m,k\n(\n0≤k≤2⋅\n10\n5\n,\n1≤n≤2⋅\n10\n5\n,\n1≤m≤10\n) — the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\nThe second line of each test case contains a string\na\nof length\nn\n.\na\ni\ndenotes the object located at the\ni\n-th meter. (\na\ni\n∈{\n'W','C','L'\n}\n)\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n6\n6 2 0\nLWLLLW\n6 1 1\nLWLLLL\n6 1 1\nLWLLWL\n6 2 15\nLWLLCC\n6 10 0\nCCCCCC\n6 6 1\nWCCCCW\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nYES\nNote\nLet's consider examples:\nFirst example: We jump from the shore to the first log (\n0→1\n), from the first log to the second (\n1→3\n), from the second to the fourth (\n3→5\n), and from the last log to the shore (\n5→7\n). So, we have\n0→1→3→5→7\n. Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».\nSecond example:\n0→1\n, we jump into the water from the first log (\n1→2\n), swim a cell to the log (\n2⇝3\n),\n3→4→5→6→7\n. Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».\nIn the third example, ErnKor needs to swim two cells 'W', but can only swim one. Therefore, the answer is «NO».\nSixth example: We jump from the shore into the water (\n0→6\n) and swim one cell in the water (\n6⇝7\n). Since we did not encounter a crocodile and swam no more than k meters, the answer is «YES».",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1200"
        ]
    },
    {
        "title": "C. Gorilla and Permutation",
        "description": "Gorilla and Noobish_Monk found three numbers\nn\n,\nm\n, and\nk\n(\nm<k\n). They decided to construct a permutation\n†\n†\nof length\nn\n.\nFor the permutation, Noobish_Monk came up with the following function:\ng(i)\nis the sum of all the numbers in the permutation on a prefix of length\ni\nthat are not greater than\nm\n. Similarly, Gorilla came up with the function\nf\n, where\nf(i)\nis the sum of all the numbers in the permutation on a prefix of length\ni\nthat are not less than\nk\n. A prefix of length\ni\nis a subarray consisting of the first\ni\nelements of the original array.\nFor example, if\nn=5\n,\nm=2\n,\nk=5\n, and the permutation is\n[5,3,4,1,2]\n, then:\nf(1)=5\n, because\n5≥5\n;\ng(1)=0\n, because\n5>2\n;\nf(2)=5\n, because\n3<5\n;\ng(2)=0\n, because\n3>2\n;\nf(3)=5\n, because\n4<5\n;\ng(3)=0\n, because\n4>2\n;\nf(4)=5\n, because\n1<5\n;\ng(4)=1\n, because\n1≤2\n;\nf(5)=5\n, because\n2<5\n;\ng(5)=1+2=3\n, because\n2≤2\n.\nHelp them find a permutation for which the value of\n(\n∑\nn\ni=1\nf(i)−\n∑\nn\ni=1\ng(i))\n(\nis maximized.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin any order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (as\n2\nappears twice in the array) and\n[1,3,4]\nis also not a permutation (as\nn=3\n, but\n4\nappears in the array).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe only line of each case contains three integers\nn\n,\nm\n,\nk\n(\n2≤n≤\n10\n5\n;\n1≤m<k≤n\n) — the size of the permutation to be constructed and two integers.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the permutation  — a set of numbers that satisfies the conditions of the problem. If there are multiple solutions, output any of them.\nExample\ninput\nCopy\n3\n5 2 5\n3 1 3\n10 3 8\noutput\nCopy\n5 3 4 1 2\n3 2 1\n10 9 8 4 7 5 6 1 2 3\nNote\nIn the first example,\n(\n∑\nn\ni=1\nf(i)−\n∑\nn\ni=1\ng(i))=5⋅5−(0⋅3+1+3)=25−4=21\n(",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*900"
        ]
    },
    {
        "title": "B. Angry Monk",
        "description": "To celebrate his recovery, k1o0n has baked an enormous\nn\nmetres long potato casserole.\nTurns out, Noobish_Monk just can't stand potatoes, so he decided to ruin k1o0n's meal. He has cut it into\nk\npieces, of lengths\na\n1\n,\na\n2\n,…,\na\nk\nmeters.\nk1o0n wasn't keen on that. Luckily, everything can be fixed. In order to do that, k1o0n can do one of the following operations:\nPick a piece with length\na\ni\n≥2\nand divide it into two pieces with lengths\n1\nand\na\ni\n−1\n. As a result, the number of pieces will increase by\n1\n;\nPick a slice\na\ni\nand another slice with length\na\nj\n=1\n(\ni≠j\n) and merge them into one piece with length\na\ni\n+1\n. As a result, the number of pieces will decrease by\n1\n.\nHelp k1o0n to find the minimum number of operations he needs to do in order to merge the casserole into one piece with length\nn\n.\nFor example, if\nn=5\n,\nk=2\nand\na=[3,2]\n, it is optimal to do the following:\nDivide the piece with length\n2\ninto two pieces with lengths\n2−1=1\nand\n1\n, as a result\na=[3,1,1]\n.\nMerge the piece with length\n3\nand the piece with length\n1\n, as a result\na=[4,1]\n.\nMerge the piece with length\n4\nand the piece with length\n1\n, as a result\na=[5]\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n).\nDescription of each test case consists of two lines. The first line contains two integers\nn\nand\nk\n(\n2≤n≤\n10\n9\n,\n2≤k≤\n10\n5\n) — length of casserole and the number of pieces.\nThe second line contains\nk\nintegers\na\n1\n,\na\n2\n,…,\na\nk\n(\n1≤\na\ni\n≤n−1\n,\n∑\na\ni\n=n\n) — lengths of pieces of casserole, which Noobish_Monk has cut.\nIt is guaranteed that the sum of\nk\nover all\nt\ntest cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum number of operations K1o0n needs to restore his pie after the terror of Noobish_Monk.\nExample\ninput\nCopy\n4\n5 3\n3 1 1\n5 2\n3 2\n11 4\n2 3 1 5\n16 6\n1 6 1 1 1 6\noutput\nCopy\n2\n3\n9\n15",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "A. Only Pluses",
        "description": "Kmes has written three integers\na\n,\nb\nand\nc\nin order to remember that he has to give Noobish_Monk\na×b×c\nbananas.\nNoobish_Monk has found these integers and decided to do the following at most\n5\ntimes:\npick one of these integers;\nincrease it by\n1\n.\nFor example, if\na=2\n,\nb=3\nand\nc=4\n, then one can increase\na\nthree times by one and increase\nb\ntwo times. After that\na=5\n,\nb=5\n,\nc=4\n. Then the total number of bananas will be\n5×5×4=100\n.\nWhat is the maximum value of\na×b×c\nNoobish_Monk can achieve with these operations?\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains three integers\na\n,\nb\nand\nc\n(\n1≤a,b,c≤10\n) — Kmes's integers.\nOutput\nFor each test case, output a single integer — the maximum amount of bananas Noobish_Monk can get.\nExample\ninput\nCopy\n2\n2 3 4\n10 1 10\noutput\nCopy\n100\n600",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "I. Grid Game",
        "description": "This is an interactive problem.\nYou are given a grid with\nn\nrows and\nm\ncolumns. You need to fill each cell with a unique integer from\n1\nto\nn⋅m\n.\nAfter filling the grid, you will play a game on this grid against the interactor. Players take turns selecting one of the previously unselected cells from the grid, with the interactor going first.\nOn the first turn, the interactor can choose any cell from the grid. After that, any chosen cell must be orthogonally adjacent to at least one previously selected cell. Two cells are considered orthogonally adjacent if they share an edge. The game continues until all cells have been selected.\nYour goal is to let the sum of numbers in the cells selected by you be strictly less than the sum of numbers in the cells selected by the interactor.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of test cases follows.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n4≤n,m≤10\n) — the number of rows and columns in the grid.\nInteraction\nFirst, output\nn\nlines, each containing\nm\nintegers, representing the integers that you filled in the grid. Each integer from\n1\nto\nn⋅m\nshould appear exactly once.\nThen, the game begins. The interactor and you take turns outputting coordinates to select a cell for\nn×m\nturns, with the interactor starting first.\nOn each player's (either you or the interactor) turn, the player will output two integers\ni\nand\nj\n(\n1≤i≤n\n,\n1≤j≤m\n), denoting that the player has selected the cell on the\ni\n-th row and\nj\n-th column. This cell should not have been selected in a previous round. Additionally, if it is not the first turn, the cell must be orthogonally adjacent to at least one previously selected cell.\nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nAt the end of all\nn⋅m\nturns, if the sum of numbers in the cells selected by you is not strictly less than the sum of numbers in the cells selected by the interactor, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nIf your program has received a Wrong Answer verdict, it must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nAfter outputting, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nIn this problem, hacks are disabled.\nExample\ninput\nCopy\n1\n4 4\n\n\n\n\n3 4\n\n4 4\n\n4 2\n\n4 1\n\n1 4\n\n1 2\n\n2 2\n\n2 1\noutput\nCopy\n2 3 4 10\n12 6 11 15\n5 13 16 8\n9 7 1 14\n\n2 4\n\n4 3\n\n3 3\n\n3 1\n\n1 3\n\n1 1\n\n2 3\n\n3 2\nNote\nNote that this is an example game and does not necessarily represent the optimal strategy for both players.\nFirst, we fill a\n4×4\ngrid with unique integers from\n1\nto\n16\nin the following way:\n2\n3\n4\n10\n12\n6\n11\n15\n5\n13\n16\n8\n9\n7\n1\n14\nNext, the game begins.\nThe interactor first selects\n(3,4)\n, which is the number\n8\n. For this selection, the interactor could choose any number. From the next selection onwards, each chosen number has to be adjacent to any previously selected number.\nWe select\n(2,4)\n, which is the number\n15\n, adjacent to\n(3,4)\n.\nThe interactor selects\n(4,4)\n, which is the number\n14\n, adjacent to\n(3,4)\n.\nWe select\n(4,3)\n, which is the number\n1\n, adjacent to\n(4,4)\n.\n…\nThis is continued until all numbers are selected.\nIn the end, the numbers we selected were\n[15,1,16,5,4,2,11,13]\n, and the numbers selected by the interactor were\n[8,14,7,9,10,3,6,12]\n. The sum of the numbers we selected is\n67\n, which is less than the sum of the numbers selected by the interactor\n69\n. Therefore, we have won this game.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "graph matchings",
            "greedy",
            "interactive",
            "*3500"
        ]
    },
    {
        "title": "H. Prime Split Game",
        "description": "Alice and Bob are playing a game with\nn\npiles of stones, where the\ni\n-th pile has\na\ni\nstones. Players take turns making moves, with Alice going first.\nOn each move, the player does the following three-step process:\nChoose an integer\nk\n(\n1≤k≤\nn\n2\n). Note that the value of\nk\ncan be different for different moves.\nRemove\nk\npiles of stones.\nChoose another\nk\npiles of stones and split each pile into two piles. The number of stones in each new pile must be a prime number.\nThe player who is unable to make a move loses.\nDetermine who will win if both players play optimally.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of piles of stones.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n5\n) — the number of stones in the piles.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"Alice\" (without quotes) if Alice wins and \"Bob\" (without quotes) otherwise.\nYou can output each letter in any case (upper or lower). For example, the strings \"alIcE\", \"Alice\", and \"alice\" will all be considered identical.\nExample\ninput\nCopy\n4\n2\n2 1\n3\n3 5 7\n4\n4 6 8 10\n5\n8 8 8 8 8\noutput\nCopy\nBob\nAlice\nAlice\nBob\nNote\nIn the first test case, there are\n2\npiles of stones with\n2\nand\n1\nstones respectively. Since neither\n1\nnor\n2\ncan be split into two prime numbers, Alice cannot make a move, so Bob wins.\nIn the second test case, there are\n3\npiles of stones with\n3\n,\n5\n, and\n7\nstones respectively. Alice can choose\nk=1\n, remove the pile of\n7\nstones, and then split the pile of\n5\nstones into two piles of prime numbers of stones,\n2\nand\n3\n. Then, the piles consist of\n3\npiles of stones with\n3\n,\n2\n, and\n3\nstones respectively, leaving Bob with no valid moves, so Alice wins.\nIn the third test case, there are\n4\npiles of stones with\n4\n,\n6\n,\n8\n, and\n10\nstones respectively. Alice can choose\nk=2\n, removing two piles of\n8\nand\n10\nstones. She splits the pile of\n4\nstones into two piles of prime numbers of stones,\n2\nand\n2\n, and the pile of\n6\nstones into two piles of\n3\nand\n3\nstones. Then, Bob has no valid moves, so Alice wins.\nIn the fourth test case, there are\n5\npiles of stones, each containing\n8\nstones. It can be shown that if both players play optimally, Bob will win.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "fft",
            "games",
            "math",
            "number theory",
            "*3300"
        ]
    },
    {
        "title": "G. Grid Reset",
        "description": "You are given a grid consisting of\nn\nrows and\nm\ncolumns, where each cell is initially white. Additionally, you are given an integer\nk\n, where\n1≤k≤min(n,m)\n.\nYou will process\nq\noperations of two types:\nH\n(horizontal operation) — You choose a\n1×k\nrectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\nV\n(vertical operation) — You choose a\nk×1\nrectangle completely within the grid, where all cells in this rectangle are white. Then, all cells in this rectangle are changed to black.\nAfter each operation, if any rows or columns become completely black, all cells in these rows and columns are simultaneously reset to white. Specifically, if all cells in the row and column a cell is contained in become black, all cells in both the row and column will be reset to white.\nChoose the rectangles in a way that you can perform all given operations, or determine that it is impossible.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains four integers\nn\n,\nm\n,\nk\n, and\nq\n(\n1≤n,m≤100\n,\n1≤k≤min(n,m)\n,\n1≤q≤1000\n) — the number of rows and columns in the grid, the size of the operation rectangle, and the number of operations, respectively.\nThe second line of each test case contains a string\ns\nof length\nq\n, consisting only of characters\nH\nand\nV\n — the sequence of operation types.\nIt is guaranteed that the sum of\nq\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output a single integer\n−1\nif it is impossible to perform all the operations.\nOtherwise, output\nq\nlines. Each line contains two integers\ni\n,\nj\n(\n1≤i≤n\n,\n1≤j≤m\n) — the coordinates of the top-left cell of the operation rectangle.\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n1\n4 5 3 6\nHVVHHV\noutput\nCopy\n1 1\n2 1\n1 1\n2 3\n3 3\n2 2\nNote\nIllustration of example.\nThe first operation is horizontal. The operation rectangle starts at\n(1,1)\nand is a\n1×3\nrectangle. After the operation, cells\n(1,1)\n,\n(1,2)\n, and\n(1,3)\nbecome black.\nThe second operation is vertical. The operation rectangle starts at\n(2,1)\nand is a\n3×1\nrectangle. After the operation, cells\n(2,1)\n,\n(3,1)\n, and\n(4,1)\nbecome black. At this point, the first column becomes completely black, so all cells in the first column are reset to white.\nThe third operation is vertical. The operation rectangle starts at\n(1,1)\nand is a\n3×1\nrectangle. After the operation, cells\n(1,1)\n,\n(2,1)\n, and\n(3,1)\nbecome black.\nThe fourth operation is horizontal. The operation rectangle starts at\n(2,3)\nand is a\n1×3\nrectangle. After the operation, cells\n(2,3)\n,\n(2,4)\n, and\n(2,5)\nbecome black.\nThe fifth operation is horizontal. The operation rectangle starts at\n(3,3)\nand is a\n1×3\nrectangle. After the operation, cells\n(3,3)\n,\n(3,4)\n, and\n(3,5)\nbecome black.\nThe sixth operation is vertical. The operation rectangle starts at\n(2,2)\nand is a\n3×1\nrectangle. After the operation, cells\n(2,2)\n,\n(3,2)\n, and\n(4,2)\nbecome black. At this point, two rows and one column become completely black, so all cells in these rows and the column are reset to white.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*2700"
        ]
    },
    {
        "title": "F. Triangle Formation",
        "description": "You are given\nn\nsticks, numbered from\n1\nto\nn\n. The length of the\ni\n-th stick is\na\ni\n.\nYou need to answer\nq\nqueries. In each query, you are given two integers\nl\nand\nr\n(\n1≤l<r≤n\n,\nr−l+1≥6\n). Determine whether it is possible to choose\n6\ndistinct sticks from the sticks numbered\nl\nto\nr\n, to form\n2\nnon-degenerate triangles\n∗\n.\n∗\nA triangle with side lengths\na\n,\nb\n, and\nc\nis called non-degenerate if:\na<b+c\n,\nb<a+c\n, and\nc<a+b\n.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n6≤n≤\n10\n5\n,\n1≤q≤\n10\n5\n) — the number of sticks and the number of queries respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) —\na\ni\ndenotes the length of the\ni\n-th stick.\nEach of the following\nq\nlines contains two integers\nl\nand\nr\n(\n1≤l<r≤n\n,\nr−l+1≥6\n) — the parameters of each query.\nOutput\nFor each query, output \"YES\" (without quotes) if it is possible to form\n2\ntriangles, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n10 5\n5 2 2 10 4 10 6 1 5 3\n1 6\n2 7\n2 8\n5 10\n4 10\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first query, the lengths of the sticks are\n[5,2,2,10,4,10]\n. Two sets of sticks\n[2,4,5]\nand\n[2,10,10]\ncan be selected to form\n2\nnon-degenerate triangles.\nIn the second query, the lengths of the sticks are\n[2,2,10,4,10,6]\n. It can be shown that it is impossible to form\n2\nnon-degenerate triangles.\nIn the third query, the lengths of the sticks are\n[2,2,10,4,10,6,1]\n. Two sets of sticks\n[1,2,2]\nand\n[4,10,10]\ncan be selected to form\n2\nnon-degenerate triangles.\nIn the fourth query, the lengths of the sticks are\n[4,10,6,1,5,3]\n. It can be shown that it is impossible to form\n2\nnon-degenerate triangles.\nIn the fifth query, the lengths of the sticks are\n[10,4,10,6,1,5,3]\n. Two sets of sticks\n[1,10,10]\nand\n[3,4,5]\ncan be selected to form\n2\nnon-degenerate triangles.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*2200"
        ]
    },
    {
        "title": "E. Coloring Game",
        "description": "This is an interactive problem.\nConsider an undirected connected graph consisting of\nn\nvertices and\nm\nedges. Each vertex can be colored with one of three colors:\n1\n,\n2\n, or\n3\n. Initially, all vertices are uncolored.\nAlice and Bob are playing a game consisting of\nn\nrounds. In each round, the following two-step process happens:\nAlice chooses two different colors.\nBob chooses an uncolored vertex and colors it with one of the two colors chosen by Alice.\nAlice wins if there exists an edge connecting two vertices of the same color. Otherwise, Bob wins.\nYou are given the graph. Your task is to decide which player you wish to play as and win the game.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n1≤n≤\n10\n4\n,\nn−1≤m≤min(\nn⋅(n−1)\n2\n,\n10\n4\n)\n) — the number of vertices and the number of edges in the graph, respectively.\nEach of the next\nm\nlines of each test case contains two integers\nu\ni\n,\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n) — the edges of the graph. It is guaranteed that the graph is connected and there are no multiple edges or self-loops.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases does not exceed\n10\n4\n.\nInteraction\nFor each test case, you need to output a single line containing either \"Alice\" or \"Bob\", representing the player you choose.\nThen for each of the following\nn\nrounds, the following two-step process happens:\nAlice (either you or the interactor) will output two integers\na\nand\nb\n(\n1≤a,b≤3\n,\na≠b\n) — the colors chosen by Alice.\nBob (either you or the interactor) will output two integers\ni\nand\nc\n(\n1≤i≤n\n,\nc=a\nor\nc=b\n) — the vertex and the color chosen by Bob. Vertex\ni\nmust be a previously uncolored vertex.\nIf any of your outputs are invalid, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nAt the end of all\nn\nturns, if you have lost the game, the jury will output \"-1\" and you will receive a Wrong Answer verdict.\nIf your program has received a\n−1\ninstead of a valid value, it must terminate immediately. Otherwise, you may receive an arbitrary verdict because your solution might be reading from a closed stream.\nNote that if you are playing as Alice, and there already exists an edge connected two vertices of the same color, the interactor will not terminate early and you will keep playing all\nn\nrounds.\nAfter outputting, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nIn this problem, hacks are disabled.\nExample\ninput\nCopy\n2\n3 3\n1 2\n2 3\n3 1\n\n\n3 1\n\n2 2\n\n1 1\n4 4\n1 2\n2 3\n3 4\n4 1\n\n2 3\n\n1 2\n\n2 1\n\n3 1\noutput\nCopy\nAlice\n3 1\n\n1 2\n\n2 1\n\n\n\n\n\n\nBob\n\n1 2\n\n2 1\n\n4 1\n\n3 3\nNote\nNote that the sample test cases are example games and do not necessarily represent the optimal strategy for both players.\nIn the first test case, you choose to play as Alice.\nAlice chooses two colors:\n3\nand\n1\n. Bob chooses vertex\n3\nand colors it with color\n1\n.\nAlice chooses two colors:\n1\nand\n2\n. Bob chooses vertex\n2\nand colors it with color\n2\n.\nAlice chooses two colors:\n2\nand\n1\n. Bob chooses vertex\n1\nand colors it with color\n1\n.\nAlice wins because the edge\n(3,1)\nconnects two vertices of the same color.\nIn the second test case, you choose to play as Bob.\nAlice chooses two colors:\n2\nand\n3\n. Bob chooses vertex\n1\nand colors it with color\n2\n.\nAlice chooses two colors:\n1\nand\n2\n. Bob chooses vertex\n2\nand colors it with color\n1\n.\nAlice chooses two colors:\n2\nand\n1\n. Bob chooses vertex\n4\nand colors it with color\n1\n.\nAlice chooses two colors:\n3\nand\n1\n. Bob chooses vertex\n3\nand colors it with color\n3\n.\nBob wins because there are no edges with vertices of the same color.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "games",
            "graphs",
            "greedy",
            "interactive",
            "*1900"
        ]
    },
    {
        "title": "D. Prime XOR Coloring",
        "description": "You are given an undirected graph with\nn\nvertices, numbered from\n1\nto\nn\n. There is an edge between vertices\nu\nand\nv\nif and only if\nu⊕v\nis a prime number, where\n⊕\ndenotes the bitwise XOR operator.\nColor all vertices of the graph using the minimum number of colors, such that no two vertices directly connected by an edge have the same color.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of test cases follows.\nThe only line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of vertices in the graph.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two lines.\nThe first line should contain a single integer\nk\n(\n1≤k≤n\n) — the minimum number of colors required.\nThe second line should contain\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤k\n) — the color of each vertex.\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n6\n1\n2\n3\n4\n5\n6\noutput\nCopy\n1\n1\n2\n1 2\n2\n1 2 2\n3\n1 2 2 3\n3\n1 2 2 3 3\n4\n1 2 2 3 3 4\nNote\nIn the first test case, the minimum number of colors is\n1\n, because there is only one vertex.\nIn the second test case, the minimum number of colors is\n2\n, because there is an edge connecting\n1\nand\n2\n(\n1⊕2=3\n, which is a prime number).\nIn the third test case, the minimum number of colors is still\n2\n, because\n2\nand\n3\ncan be colored the same since there is no edge between\n2\nand\n3\n(\n2⊕3=1\n, which is not a prime number).\nIn the fourth test case, it can be shown that the minimum number of colors is\n3\n.\nIn the fifth test case, it can be shown that the minimum number of colors is\n3\n.\nIn the sixth test case, it can be shown that the minimum number of colors is\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "graphs",
            "greedy",
            "math",
            "number theory",
            "*1900"
        ]
    },
    {
        "title": "C. Absolute Zero",
        "description": "You are given an array\na\nof\nn\nintegers.\nIn one operation, you will perform the following two-step move:\nChoose an integer\nx\n(\n0≤x≤\n10\n9\n).\nReplace each\na\ni\nwith\n|\na\ni\n−x|\n, where\n|v|\ndenotes the absolute value of\nv\n.\nFor example, by choosing\nx=8\n, the array\n[5,7,10]\nwill be changed into\n[|5−8|,|7−8|,|10−8|]=[3,1,2]\n.\nConstruct a sequence of operations to make all elements of\na\nequal to\n0\nin at most\n40\noperations or determine that it is impossible. You do not need to minimize the number of operations.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer\n−1\nif it is impossible to make all array elements equal to\n0\nin at most\n40\noperations.\nOtherwise, output two lines. The first line of output should contain a single integer\nk\n(\n0≤k≤40\n) — the number of operations. The second line of output should contain\nk\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nk\n(\n0≤\nx\ni\n≤\n10\n9\n) — the sequence of operations, denoting that on the\ni\n-th operation, you chose\nx=\nx\ni\n.\nIf there are multiple solutions, output any of them.\nYou do not need to minimize the number of operations.\nExample\ninput\nCopy\n5\n1\n5\n2\n0 0\n3\n4 6 8\n4\n80 40 20 10\n5\n1 2 3 4 5\noutput\nCopy\n1\n5\n0\n\n3\n6 1 1\n7\n60 40 20 10 30 25 5\n-1\nNote\nIn the first test case, we can perform only one operation by choosing\nx=5\n, changing the array from\n[5]\nto\n[0]\n.\nIn the second test case, no operations are needed because all elements of the array are already\n0\n.\nIn the third test case, we can choose\nx=6\nto change the array from\n[4,6,8]\nto\n[2,0,2]\n, then choose\nx=1\nto change it to\n[1,1,1]\n, and finally choose\nx=1\nagain to change the array into\n[0,0,0]\n.\nIn the fourth test case, we can make all elements\n0\nby following the operation sequence\n(60,40,20,10,30,25,5)\n.\nIn the fifth test case, it can be shown that it is impossible to make all elements\n0\nin at most\n40\noperations. Therefore, the output is\n−1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. AND Reconstruction",
        "description": "You are given an array\nb\nof\nn−1\nintegers.\nAn array\na\nof\nn\nintegers is called good if\nb\ni\n=\na\ni\n&\na\ni+1\nfor\n1≤i≤n−1\n, where\n&\ndenotes the bitwise AND operator.\nConstruct a good array, or report that no good arrays exist.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn−1\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn−1\n(\n0≤\nb\ni\n<\n2\n30\n) — the elements of the array\nb\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer\n−1\nif no good arrays exist.\nOtherwise, output\nn\nspace-separated integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<\n2\n30\n) — the elements of a good array\na\n.\nIf there are multiple solutions, you may output any of them.\nExample\ninput\nCopy\n4\n2\n1\n3\n2 0\n4\n1 2 3\n5\n3 5 4 2\noutput\nCopy\n5 3\n3 2 1\n-1\n3 7 5 6 3\nNote\nIn the first test case,\nb=[1]\n. A possible good array is\na=[5,3]\n, because\na\n1\n&\na\n2\n=5&3=1=\nb\n1\n.\nIn the second test case,\nb=[2,0]\n. A possible good array is\na=[3,2,1]\n, because\na\n1\n&\na\n2\n=3&2=2=\nb\n1\nand\na\n2\n&\na\n3\n=2&1=0=\nb\n2\n.\nIn the third test case,\nb=[1,2,3]\n. It can be shown that no good arrays exist, so the output is\n−1\n.\nIn the fourth test case,\nb=[3,5,4,2]\n. A possible good array is\na=[3,7,5,6,3]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*1100"
        ]
    },
    {
        "title": "A. Maximize the Last Element",
        "description": "You are given an array\na\nof\nn\nintegers, where\nn\nis odd.\nIn one operation, you will remove two adjacent elements from the array\na\n, and then concatenate the remaining parts of the array. For example, given the array\n[4,7,4,2,9]\n, we can obtain the arrays\n[4,2,9]\nand\n[4,7,9]\nby the operations\n[\n4,7\n–\n–\n–\n–\n,4,2,9]→[4,2,9]\nand\n[4,7,\n4,2\n–\n–\n–\n–\n,9]→[4,7,9]\nrespectively. However, we cannot obtain the array\n[7,2,9]\nas it requires deleting non-adjacent elements\n[\n4\n–\n,7,\n4\n–\n,2,9]\n.\nYou will repeatedly perform this operation until exactly one element remains in\na\n.\nFind the maximum possible value of the remaining element in\na\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤99\n;\nn\nis odd) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n) — the elements of the array\na\n.\nNote that there is no bound on the sum of\nn\nover all test cases.\nOutput\nFor each test case, output a single integer — the maximum possible value of the remaining element in\na\n.\nExample\ninput\nCopy\n4\n1\n6\n3\n1 3 2\n5\n4 7 4 2 9\n7\n3 1 4 1 5 9 2\noutput\nCopy\n6\n2\n9\n5\nNote\nIn the first test case, the array\na\nis\n[6]\n. Since there is only one element, no operations are needed. The maximum possible value of the remaining element is\n6\n.\nIn the second test case, the array\na\nis\n[1,3,2]\n. We can remove the first two elements\n[\n1,3\n–\n–\n–\n–\n,2]→[2]\n, or remove the last two elements\n[1,\n3,2\n–\n–\n–\n–\n]→[1]\n. Therefore, the maximum possible value of the remaining element is\n2\n.\nIn the third test case, the array\na\nis\n[4,7,4,2,9]\n. One way to maximize the remaining element is\n[4,\n7,4\n–\n–\n–\n–\n,2,9]→[\n4,2\n–\n–\n–\n–\n,9]→[9]\n. Therefore, the maximum possible value of the remaining element is\n9\n.\nIn the fourth test case, the array\na\nis\n[3,1,4,1,5,9,2]\n. It can be shown that the maximum possible value of the remaining element is\n5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F. Polygonal Segments",
        "description": "You are given an array\na\nof size\nn\n.\nA segment\n[l,r](1≤l<r≤n)\nis called a polygonal segment only if the following conditions hold:\n(r−l+1)≥3\n;\nConsidering\na\nl\n,\na\nl+1\n,…,\na\nr\nas side lengths, these sides can form a polygon with\n(r−l+1)\nsides.\nProcess\nq\nqueries of two types:\n\"1 l r\": find the length of the longest segment among all polygonal segments\n[\nl\n0\n,\nr\n0\n]\nsatisfying\nl≤\nl\n0\n≤\nr\n0\n≤r\n. If there is no such polygonal segment, output\n−1\ninstead;\n\"2 i x\": assign\na\ni\n:=x\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case:\nThe first line of each testcase contains two integers\nn\n,\nq\n(\n4≤n≤2⋅\n10\n5\n,\n1≤q≤\n10\n5\n);\nThe second line of each testcase contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n);\nThe following\nq\nlines contain the description of queries. Each line is of one of two types:\n\"1 l r\" (\n1≤l<r≤n\n,\nr−l+1≥3\n);\n\"2 i x\" (\n1≤i≤n\n,\n1≤x≤\n10\n12\n).\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅\n10\n5\n, and the sum of\nq\nover all test cases will not exceed\n10\n5\n.\nOutput\nFor each query, if there is no suitable segment, output\n−1\nin a new line. Otherwise, output the length of the longest segment satisfying the condition above in a new line.\nExample\ninput\nCopy\n2\n5 6\n3 1 2 2 8\n1 1 3\n1 1 4\n1 1 5\n2 1 5\n1 1 4\n1 1 5\n4 10\n500000000000 500000000000 1000000000000 500000000000\n1 1 3\n1 2 4\n1 1 4\n2 1 499999999999\n2 3 999999999999\n1 1 3\n1 2 4\n1 1 4\n2 3 1000000000000\n1 1 3\noutput\nCopy\n-1\n4\n4\n3\n5\n-1\n-1\n4\n-1\n3\n4\n-1\nNote\nIn the first query of the first test case, there is no polygonal segment under the given condition. For example, considering segment\n[1,3]\n, you can not form a triangle with side lengths of\na\n1\n=3\n,\na\n2\n=1\n, and\na\n3\n=2\n.\nIn the second query of the first test case, the longest polygonal segment is\n[1,4]\n. You can form a quadrilateral with side lengths of\na\n1\n=3\n,\na\n2\n=1\n,\na\n3\n=2\n, and\na\n4\n=2\n.\nAn example of a quadrilateral with side lengths of\n3\n,\n1\n,\n2\n, and\n2\n.",
        "time_limit": "8 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "two pointers",
            "*2800"
        ]
    },
    {
        "title": "E2. Catch the Mole(Hard Version)",
        "description": "This is the hard version of the problem. The only difference is the limit on the number of queries.\nThis is an interactive problem.\nYou are given a tree of\nn\nnodes with node\n1\nas its root node.\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer\nx\n(\n1≤x≤n\n) to make an inquiry to the jury. Next, the jury will return\n1\nwhen the mole is in subtree\nx\n. Otherwise, the judge will return\n0\n. If the judge returns\n0\nand the mole is not in root node\n1\n, the mole will move to the parent node of the node it is currently on.\nUse at most\n160\noperations to find the current node where the mole is located.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nInteraction\nThe first line of each test case contains one integer\nn\n(\n2≤n≤5000\n).\nThe following\nn−1\nlines describe the edges of the tree. Each line contains two space-separated integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n), indicating an edge between nodes\nu\ni\nand\nv\ni\n.\nIt is guaranteed that the input data represents a tree.\nThe interactor in this task is not adaptive. In other words, the node where the mole is located at first is fixed in every test case and does not change during the interaction.\nTo ask a query, you need to pick a vertex\nx\n(\n1≤x≤n\n) and print the line of the following form:\n\"? x\"\nAfter that, you receive:\n0\nif the mole is not in subtree\nx\n;\n1\nif the mole is in subtree\nx\n.\nYou can make at most\n160\nqueries of this form for each test case.\nNext, if your program has found the current node where the mole is located, print the line of the following form:\n\"! x\"\nNote that this line is not considered a query and is not taken into account when counting the number of queries asked.\nAfter this, proceed to the next test case.\nIf you make more than\n160\nqueries during an interaction, your program must terminate immediately, and you will receive the Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict Idleness Limit Exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo hack, follow the test format below.\nThe first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains one integer\nn\nand\nx\n(\n2≤n≤5000\n,\n1≤x≤n\n) — the size of the tree and the initial position of the mole.\nThe following\nn−1\nlines describe the edges of the tree. Each line contains two space-separated integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n), indicating an edge between nodes\nu\ni\nand\nv\ni\n.\nThe input data must represent a tree.\nExample\ninput\nCopy\n2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1\noutput\nCopy\n? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4\nNote\nIn the first test case, the mole is in node\n2\ninitially.\nFor the query \"? 2\", the jury returns\n1\nbecause the mole is in subtree\n2\n. After this query, the mole does not move.\nThe answer\n2\nis the current node where the mole is located, so the answer is considered correct.\nIn the second test case, the mole is in node\n6\ninitially.\nFor the query \"? 2\", the jury returns\n0\nbecause the mole is not in subtree\n2\n. After this query, the mole moves from node\n6\nto node\n5\n.\nFor the query \"? 6\", the jury returns\n0\nbecause the mole is not in subtree\n6\n. After this query, the mole moves from node\n5\nto node\n4\n.\nFor the query \"? 4\", the jury returns\n1\nbecause the mole is in subtree\n4\n. After this query, the mole does not move.\nThe answer\n4\nis the current node where the mole is located, so the answer is considered correct.\nPlease note that the example is only for understanding the statement, and the queries in the example do not guarantee to determine the unique position of the mole.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "divide and conquer",
            "interactive",
            "trees",
            "*2600"
        ]
    },
    {
        "title": "E1. Catch the Mole(Easy Version)",
        "description": "This is the easy version of the problem. The only difference is the limit on the number of queries.\nThis is an interactive problem.\nYou are given a tree of\nn\nnodes with node\n1\nas its root node.\nThere is a hidden mole in one of the nodes. To find its position, you can pick an integer\nx\n(\n1≤x≤n\n) to make an inquiry to the jury. Next, the jury will return\n1\nwhen the mole is in subtree\nx\n. Otherwise, the judge will return\n0\n. If the judge returns\n0\nand the mole is not in root node\n1\n, the mole will move to the parent node of the node it is currently on.\nUse at most\n300\noperations to find the current node where the mole is located.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nInteraction\nThe first line of each test case contains one integer\nn\n(\n2≤n≤5000\n).\nThe following\nn−1\nlines describe the edges of the tree. Each line contains two space-separated integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n), indicating an edge between nodes\nu\ni\nand\nv\ni\n.\nIt is guaranteed that the input data represents a tree.\nThe interactor in this task is not adaptive. In other words, the node where the mole is located at first is fixed in every test case and does not change during the interaction.\nTo ask a query, you need to pick a vertex\nx\n(\n1≤x≤n\n) and print the line of the following form:\n\"? x\"\nAfter that, you receive:\n0\nif the mole is not in subtree\nx\n;\n1\nif the mole is in subtree\nx\n.\nYou can make at most\n300\nqueries of this form for each test case.\nNext, if your program has found the current node where the mole is located, print the line of the following form:\n\"! x\"\nNote that this line is not considered a query and is not taken into account when counting the number of queries asked.\nAfter this, proceed to the next test case.\nIf you make more than\n300\nqueries during an interaction, your program must terminate immediately, and you will receive the Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict Idleness Limit Exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks\nTo hack, follow the test format below.\nThe first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n2≤n≤5000\n,\n1≤x≤n\n) — the size of the tree and the initial position of the mole.\nThe following\nn−1\nlines describe the edges of the tree. Each line contains two space-separated integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n), indicating an edge between nodes\nu\ni\nand\nv\ni\n.\nThe input data must represent a tree.\nExample\ninput\nCopy\n2\n2\n1 2\n\n1\n\n6\n1 2\n1 3\n1 4\n4 5\n5 6\n\n0\n\n0\n\n1\noutput\nCopy\n? 2\n\n! 2\n\n\n\n\n\n\n? 2\n\n? 6\n\n? 4\n\n! 4\nNote\nIn the first test case, the mole is in node\n2\ninitially.\nFor the query \"? 2\", the jury returns\n1\nbecause the mole is in subtree\n2\n. After this query, the mole does not move.\nThe answer\n2\nis the current node where the mole is located, so the answer is considered correct.\nIn the second test case, the mole is in node\n6\ninitially.\nFor the query \"? 2\", the jury returns\n0\nbecause the mole is not in subtree\n2\n. After this query, the mole moves from node\n6\nto node\n5\n.\nFor the query \"? 6\", the jury returns\n0\nbecause the mole is not in subtree\n6\n. After this query, the mole moves from node\n5\nto node\n4\n.\nFor the query \"? 4\", the jury returns\n1\nbecause the mole is in subtree\n4\n. After this query, the mole does not move.\nThe answer\n4\nis the current node where the mole is located, so the answer is considered correct.\nPlease note that the example is only for understanding the statement, and the queries in the example do not guarantee to determine the unique position of the mole.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "interactive",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "D. Grid Puzzle",
        "description": "You are given an array\na\nof size\nn\n.\nThere is an\nn×n\ngrid. In the\ni\n-th row, the first\na\ni\ncells are black and the other cells are white. In other words, note\n(i,j)\nas the cell in the\ni\n-th row and\nj\n-th column, cells\n(i,1),(i,2),…,(i,\na\ni\n)\nare black, and cells\n(i,\na\ni\n+1),…,(i,n)\nare white.\nYou can do the following operations any number of times in any order:\nDye a\n2×2\nsubgrid white;\nDye a whole row white. Note you can not dye a whole column white.\nFind the minimum number of operations to dye all cells white.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n\n).\nIt's guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations to dye all cells white.\nExample\ninput\nCopy\n10\n1\n0\n4\n2 4 4 2\n4\n3 2 1 0\n3\n0 3 0\n3\n0 1 3\n3\n3 1 0\n4\n3 1 0 3\n4\n0 2 2 2\n6\n1 3 4 2 0 4\n8\n2 2 5 2 3 4 2 4\noutput\nCopy\n0\n3\n2\n1\n2\n2\n3\n2\n4\n6\nNote\nIn the first test case, you don't need to do any operation.\nIn the second test case, you can do:\nDye\n(1,1),(1,2),(2,1)\n, and\n(2,2)\nwhite;\nDye\n(2,3),(2,4),(3,3)\n, and\n(3,4)\nwhite;\nDye\n(3,1),(3,2),(4,1)\n, and\n(4,2)\nwhite.\nIt can be proven\n3\nis the minimum number of operations.\nIn the third test case, you can do:\nDye the first row white;\nDye\n(2,1),(2,2),(3,1)\n, and\n(3,2)\nwhite.\nIt can be proven\n2\nis the minimum number of operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1800"
        ]
    },
    {
        "title": "C. Mad MAD Sum",
        "description": "We define the\nMAD\n(Maximum Appearing Duplicate) in an array as the largest number that appears at least twice in the array. Specifically, if there is no number that appears at least twice, the\nMAD\nvalue is\n0\n.\nFor example,\nMAD([1,2,1])=1\n,\nMAD([2,2,3,3])=3\n,\nMAD([1,2,3,4])=0\n.\nYou are given an array\na\nof size\nn\n. Initially, a variable\nsum\nis set to\n0\n.\nThe following process will be executed in a sequential loop until all numbers in\na\nbecome\n0\n:\nSet\nsum:=sum+\n∑\nn\ni=1\na\ni\n;\nLet\nb\nbe an array of size\nn\n. Set\nb\ni\n:= MAD([\na\n1\n,\na\n2\n,…,\na\ni\n])\nfor all\n1≤i≤n\n, and then set\na\ni\n:=\nb\ni\nfor all\n1≤i≤n\n.\nFind the value of\nsum\nafter the process.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array\na\n;\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the value of\nsum\nin a new line.\nExample\ninput\nCopy\n4\n1\n1\n3\n2 2 3\n4\n2 1 1 2\n4\n4 4 4 4\noutput\nCopy\n1\n13\n9\n40\nNote\nIn the first test case,\na=[1]\ninitially.\nIn the first loop:\nSet\nsum:=sum+\na\n1\n=0+1=1\n;\nSet\nb\n1\n:= MAD([\na\n1\n])= MAD([1])=0\n, and then set\na\n1\n:=\nb\n1\n.\nAfter the first loop,\na=[0]\nand the process ends. The value of\nsum\nafter the process is\n1\n.\nIn the second test case,\na=[2,2,3]\ninitially.\nAfter the first loop,\na=[0,2,2]\nand\nsum=7\n.\nAfter the second loop,\na=[0,0,2]\nand\nsum=11\n.\nAfter the third loop,\na=[0,0,0]\nand\nsum=13\n. Then the process ends.\nThe value of\nsum\nafter the process is\n13\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1500"
        ]
    },
    {
        "title": "B. Array Craft",
        "description": "For an array\nb\nof size\nm\n, we define:\nthe maximum prefix position of\nb\nis the smallest index\ni\nthat satisfies\nb\n1\n+…+\nb\ni\n=\nmax\nm\nj=1\n(\nb\n1\n+…+\nb\nj\n)\n;\nthe maximum suffix position of\nb\nis the largest index\ni\nthat satisfies\nb\ni\n+…+\nb\nm\n=\nmax\nm\nj=1\n(\nb\nj\n+…+\nb\nm\n)\n.\nYou are given three integers\nn\n,\nx\n, and\ny\n(\nx>y\n). Construct an array\na\nof size\nn\nsatisfying:\na\ni\nis either\n1\nor\n−1\nfor all\n1≤i≤n\n;\nthe maximum prefix position of\na\nis\nx\n;\nthe maximum suffix position of\na\nis\ny\n.\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nFor each test case:\nThe only line contains three integers\nn\n,\nx\n, and\ny\n(\n2≤n≤\n10\n5\n,1≤y<x≤n)\n.\nIt is guaranteed that the sum of\nn\nover all test cases will not exceed\n10\n5\n.\nOutput\nFor each test case, output\nn\nspace-separated integers\na\n1\n,\na\n2\n,…,\na\nn\nin a new line.\nExample\ninput\nCopy\n3\n2 2 1\n4 4 3\n6 5 1\noutput\nCopy\n1 1\n1 -1 1 1\n1 1 -1 1 1 -1\nNote\nIn the second test case,\ni=x=4\nis the smallest index that satisfies\na\n1\n+…+\na\ni\n=\nmax\nn\nj=1\n(\na\n1\n+…+\na\nj\n)=2\n;\ni=y=3\nis the greatest index that satisfies\na\ni\n+…+\na\nn\n=\nmax\nn\nj=1\n(\na\nj\n+…+\na\nn\n)=2\n.\nThus, the array\na=[1,−1,1,1]\nis considered correct.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ]
    },
    {
        "title": "A. Submission Bait",
        "description": "Alice and Bob are playing a game in an array\na\nof size\nn\n.\nThey take turns to do operations, with Alice starting first. The player who can not operate will lose. At first, a variable\nmx\nis set to\n0\n.\nIn one operation, a player can do:\nChoose an index\ni\n(\n1≤i≤n\n) such that\na\ni\n≥mx\nand set\nmx\nto\na\ni\n. Then, set\na\ni\nto\n0\n.\nDetermine whether Alice has a winning strategy.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nFor each test case:\nThe first line contains an integer\nn\n(\n2≤n≤50\n) — the size of the array.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array.\nOutput\nFor each test case, if Alice has a winning strategy, output \"YES\". Otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n5\n2\n2 1\n2\n1 1\n3\n3 3 3\n4\n3 3 4 4\n4\n1 2 2 2\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first test case, Alice can choose\ni=1\nsince\na\n1\n=2≥mx=0\n.\nAfter Alice's operation,\na=[0,1]\nand\nmx=2\n. Bob can not do any operation. Alice wins.\nIn the second test case, Alice doesn't have a winning strategy.\nFor example, if Alice chooses\ni=1\n, after Alice's operation:\na=[0,1]\nand\nmx=1\n. Then, Bob can choose\ni=2\nsince\na\n2\n=1≥mx=1\n. After Bob's operation:\na=[0,0]\nand\nmx=1\n. Alice can not do any operation. Bob wins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "sortings",
            "*900"
        ]
    },
    {
        "title": "F. Simultaneous Coloring",
        "description": "You are given a matrix, consisting of\nn\nrows and\nm\ncolumns.\nYou can perform two types of actions on it:\npaint the entire column in blue;\npaint the entire row in red.\nNote that you cannot choose which color to paint the row or column.\nIn one second, you can perform either one action or multiple actions at the same time. If you perform one action, it will be free. If you perform\nk>1\nactions at the same time, it will cost\nk\n2\ncoins. When multiple actions are performed at the same time, for each cell affected by actions of both types, the color can be chosen independently.\nYou are asked to process\nq\nqueries. Before each query, all cells become colorless. Initially, there are no restrictions on the color of any cells. In the\ni\n-th query, a restriction of the following form is added:\nx\ni\n y\ni\n c\ni\n — the cell in row\nx\ni\nin column\ny\ni\nshould be painted in color\nc\ni\n.\nThus, after\ni\nqueries, there are\ni\nrestrictions on the required colors of the matrix cells. After each query, output the minimum cost of painting the matrix according to the restrictions.\nInput\nThe first line contains three integers\nn,m\nand\nq\n(\n1≤n,m,q≤2⋅\n10\n5\n) — the size of the matrix and the number of queries.\nIn the\ni\n-th of the next\nq\nlines, two integers\nx\ni\n,\ny\ni\nand a character\nc\ni\n(\n1≤\nx\ni\n≤n\n;\n1≤\ny\ni\n≤m\n;\nc\ni\n∈\n{'R', 'B'}, where 'R' means red, and 'B' means blue) — description of the\ni\n-th restriction. The cells in all queries are pairwise distinct.\nOutput\nPrint\nq\nintegers — after each query, output the minimum cost of painting the matrix according to the restrictions.\nExamples\ninput\nCopy\n2 2 4\n1 1 R\n2 2 R\n1 2 B\n2 1 B\noutput\nCopy\n0\n0\n0\n16\ninput\nCopy\n3 5 10\n1 1 B\n2 5 B\n2 2 B\n2 3 R\n2 1 B\n3 2 R\n3 3 B\n1 2 R\n1 3 B\n3 1 B\noutput\nCopy\n0\n0\n0\n0\n0\n0\n16\n16\n25\n25",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dfs and similar",
            "divide and conquer",
            "graphs",
            "*3000"
        ]
    },
    {
        "title": "E. Distance to Different",
        "description": "Consider an array\na\nof\nn\nintegers, where every element is from\n1\nto\nk\n, and every integer from\n1\nto\nk\nappears at least once.\nLet the array\nb\nbe constructed as follows: for the\ni\n-th element of\na\n,\nb\ni\nis the distance to the closest element in\na\nwhich is not equal to\na\ni\n. In other words,\nb\ni\n=\nmin\nj∈[1,n],\na\nj\n≠\na\ni\n|i−j|\n.\nFor example, if\na=[1,1,2,3,3,3,3,1]\n, then\nb=[2,1,1,1,2,2,1,1]\n.\nCalculate the number of different arrays\nb\nyou can obtain if you consider all possible arrays\na\n, and print it modulo\n998244353\n.\nInput\nThe only line of the input contains two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n;\n2≤k≤min(n,10)\n).\nOutput\nPrint one integer — the number of different arrays\nb\nyou can obtain, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n2 2\noutput\nCopy\n1\ninput\nCopy\n4 3\noutput\nCopy\n3\ninput\nCopy\n6 2\noutput\nCopy\n20\ninput\nCopy\n6 5\noutput\nCopy\n3\ninput\nCopy\n133 7\noutput\nCopy\n336975971",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2300"
        ]
    },
    {
        "title": "D. Smithing Skill",
        "description": "You are playing a famous computer game (that just works) where you have various skills you can level up. Today, you focused on the \"Smithing\" skill. Your tactic is obvious: forging weapons from ingots and then melting them back to return the materials partially. For simplicity, every time you create an item, you get\n1\nexperience point, and every time you melt an item, you also get\n1\nexperience point.\nThere are\nn\nclasses of weapons you can forge and\nm\ntypes of metal ingots.\nYou can create one weapon of the\ni\n-th class, spending\na\ni\ningots of metal of the same type. Melting a weapon of the\ni\n-th class (which you crafted earlier) returns you\nb\ni\ningots of the type of metal it was made of.\nYou have\nc\nj\nmetal ingots of the\nj\n-th type, and you know that you can craft a weapon of any class from any metal type. Each combination of a weapon class and a metal type can be used any number of times.\nWhat is the maximum total amount of experience you can earn by crafting and melting weapons?\nInput\nThe first line contains two integers\nn\nand\nm\n(\n1≤n,m≤\n10\n6\n) — the number of weapon classes and metal types.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n), where\na\ni\nis the number of ingots you need to forge one weapon of the\ni\n-th class.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n<\na\ni\n), where\nb\ni\nis the number of ingots you return by melting one weapon of the\ni\n-th class you forged earlier.\nThe fourth line contains\nm\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nm\n(\n1≤\nc\nj\n≤\n10\n9\n) — the number of ingots you have of the corresponding metal type.\nOutput\nPrint one integer — the maximum total experience points you can gain by repeatedly forging and melting weapons.\nExamples\ninput\nCopy\n5 3\n9 6 7 5 5\n8 4 5 1 2\n10 4 7\noutput\nCopy\n12\ninput\nCopy\n3 4\n10 20 20\n0 0 0\n9 10 19 20\noutput\nCopy\n8\ninput\nCopy\n1 5\n3\n1\n1000000000 1000000000 1000000000 1000000000 1000000000\noutput\nCopy\n4999999990\nNote\nIn the first example, you can do the following:\ncraft one weapon of the\n1\n-st class from the\n1\n-st type of metal, spending\n9\ningots;\nmelt that weapon, returning\n8\ningots of the\n1\n-st metal type;\nagain, craft and melt one weapon of the\n1\n-st class from the\n1\n-st metal type;\ncraft and melt one weapon of the\n3\n-rd class from the\n1\n-st metal type;\ncraft and melt one weapon of the\n3\n-rd class from the\n3\n-rd metal type;\ncraft and melt one weapon of the\n4\n-th class from the\n1\n-st metal type;\ncraft and melt one weapon of the\n5\n-th class from the\n3\n-rd metal type;\nIn the end you'll have\nc=[2,4,2]\ningots left. In total, you've crafted\n6\nweapons and melted\n6\nweapons, gaining\n12\nexperience points in total.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "math",
            "sortings",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "C. Two Movies",
        "description": "A movie company has released\n2\nmovies. These\n2\nmovies were watched by\nn\npeople. For each person, we know their attitude towards the first movie (liked it, neutral, or disliked it) and towards the second movie.\nIf a person is asked to leave a review for the movie, then:\nif that person liked the movie, they will leave a positive review, and the movie's rating will increase by\n1\n;\nif that person disliked the movie, they will leave a negative review, and the movie's rating will decrease by\n1\n;\notherwise, they will leave a neutral review, and the movie's rating will not change.\nEvery person will review exactly one movie — and for every person, you can choose which movie they will review.\nThe company's rating is the minimum of the ratings of the two movies. Your task is to calculate the maximum possible rating of the company.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−1≤\na\ni\n≤1\n), where\na\ni\nis equal to\n−1\nif the first movie was disliked by the\ni\n-th viewer; equal to\n1\nif the first movie was liked; and\n0\nif the attitude is neutral.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n−1≤\nb\ni\n≤1\n), where\nb\ni\nis equal to\n−1\nif the second movie was disliked by the\ni\n-th viewer; equal to\n1\nif the second movie was liked; and\n0\nif the attitude is neutral.\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible rating of the company, if for each person, choose which movie to leave a review on.\nExample\ninput\nCopy\n4\n2\n-1 1\n-1 -1\n1\n-1\n-1\n5\n0 -1 1 0 1\n-1 1 0 0 1\n4\n-1 -1 -1 1\n-1 1 1 1\noutput\nCopy\n0\n-1\n1\n1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1400"
        ]
    },
    {
        "title": "B. Substring and Subsequence",
        "description": "You are given two strings\na\nand\nb\n, both consisting of lowercase Latin letters.\nA subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string. A substring of a string is a contiguous subsequence of that string.\nFor example, consider the string abac:\na, b, c, ab, aa, ac, ba, bc, aba, abc, aac, bac and abac are its subsequences;\na, b, c, ab, ba, ac, aba, bac and abac are its substrings.\nYour task is to calculate the minimum possible length of the string that contains\na\nas a substring and\nb\nas a subsequence.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains a string\na\n(\n1≤|a|≤100\n), consisting of lowercase Latin letters.\nThe second line of each test case contains a string\nb\n(\n1≤|b|≤100\n), consisting of lowercase Latin letters.\nOutput\nFor each test case, print a single integer — the minimum possible length of the string that contains\na\nas a substring and\nb\nas a subsequence.\nExample\ninput\nCopy\n5\naba\ncb\ner\ncf\nmmm\nmmm\ncontest\ntest\ncde\nabcefg\noutput\nCopy\n4\n4\n3\n7\n7\nNote\nIn the examples below, the characters that correspond to the subsequence equal to\nb\nare bolded.\nIn the first example, one of the possible answers is caba.\nIn the second example, one of the possible answers is ercf.\nIn the third example, one of the possible answers is mmm.\nIn the fourth example, one of the possible answers is contest.\nIn the fifth example, one of the possible answers is abcdefg.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1200"
        ]
    },
    {
        "title": "A. Catch the Coin",
        "description": "Monocarp visited a retro arcade club with arcade cabinets. There got curious about the \"Catch the Coin\" cabinet.\nThe game is pretty simple. The screen represents a coordinate grid such that:\nthe X-axis is directed from left to right;\nthe Y-axis is directed from bottom to top;\nthe center of the screen has coordinates\n(0,0)\n.\nAt the beginning of the game, the character is located in the center, and\nn\ncoins appear on the screen — the\ni\n-th coin is at coordinates\n(\nx\ni\n,\ny\ni\n)\n. The coordinates of all coins are different and not equal to\n(0,0)\n.\nIn one second, Monocarp can move the character in one of eight directions. If the character is at coordinates\n(x,y)\n, then it can end up at any of the coordinates\n(x,y+1)\n,\n(x+1,y+1)\n,\n(x+1,y)\n,\n(x+1,y−1)\n,\n(x,y−1)\n,\n(x−1,y−1)\n,\n(x−1,y)\n,\n(x−1,y+1)\n.\nIf the character ends up at the coordinates with a coin, then Monocarp collects that coin.\nAfter Monocarp makes a move, all coins fall down by\n1\n, that is, they move from\n(x,y)\nto\n(x,y−1)\n. You can assume that the game field is infinite in all directions.\nMonocarp wants to collect at least one coin, but cannot decide which coin to go for. Help him determine, for each coin, whether he can collect it.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤500\n) — the number of coins.\nIn the\ni\n-th of the next\nn\nlines, two integers\nx\ni\nand\ny\ni\n(\n−50≤\nx\ni\n,\ny\ni\n≤50\n) are written — the coordinates of the\ni\n-th coin. The coordinates of all coins are different. No coin is located at\n(0,0)\n.\nOutput\nFor each coin, print \"YES\" if Monocarp can collect it. Otherwise, print \"NO\".\nExample\ninput\nCopy\n5\n24 42\n-2 -1\n-1 -2\n0 -50\n15 0\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nNote\nPay attention to the second coin in the example. Monocarp can first move from\n(0,0)\nto\n(−1,−1)\n. Then the coin falls\n1\ndown and ends up at\n(−2,−2)\n. Finally, Monocarp moves to\n(−2,−2)\nand collects the coin.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F. Heartbeat",
        "description": "For an array\nu\n1\n,\nu\n2\n,…,\nu\nn\n, define\na prefix maximum as an index\ni\nsuch that\nu\ni\n>\nu\nj\nfor all\nj<i\n;\na suffix maximum as an index\ni\nsuch that\nu\ni\n>\nu\nj\nfor all\nj>i\n;\nan ascent as an index\ni\n(\ni>1\n) such that\nu\ni\n>\nu\ni−1\n.\nYou are given three cost arrays:\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\n,\n[\nb\n1\n,\nb\n2\n,…,\nb\nn\n]\n, and\n[\nc\n0\n,\nc\n1\n,…,\nc\nn−1\n]\n.\nDefine the cost of an array that has\nx\nprefix maximums,\ny\nsuffix maximums, and\nz\nascents as\na\nx\n⋅\nb\ny\n⋅\nc\nz\n.\nLet the sum of costs of all permutations of\n1,2,…,n\nbe\nf(n)\n. Find\nf(1)\n,\nf(2)\n, ...,\nf(n)\nmodulo\n998244353\n.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤700\n).\nThe second line contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n0≤\na\ni\n<998244353\n).\nThe third line contains\nn\nintegers\nb\n1\n,…,\nb\nn\n(\n0≤\nb\ni\n<998244353\n).\nThe fourth line contains\nn\nintegers\nc\n0\n,…,\nc\nn−1\n(\n0≤\nc\ni\n<998244353\n).\nOutput\nPrint\nn\nintegers: the\ni\n-th one is\nf(i)\nmodulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 1 1\n1 1 1\n1 1 1\noutput\nCopy\n1 2 6 \ninput\nCopy\n3\n1 2 3\n2 3 1\n3 1 2\noutput\nCopy\n6 13 34 \ninput\nCopy\n5\n1 4 2 5 3\n2 5 1 3 4\n300000000 100000000 500000000 400000000 200000000\noutput\nCopy\n600000000 303511294 612289529 324650937 947905622 \nNote\nIn the second example:\nConsider permutation\n[1,2,3]\n. Indices\n1,2,3\nare prefix maximums. Index\n3\nis the only suffix maximum. Indices\n2,3\nare ascents. In conclusion, it has\n3\nprefix maximums,\n1\nsuffix maximums, and\n2\nascents. Therefore, its cost is\na\n3\nb\n1\nc\n2\n=12\n.\nPermutation\n[1,3,2]\nhas\n2\nprefix maximums,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n6\n.\nPermutation\n[2,1,3]\nhas\n2\nprefix maximums,\n1\nsuffix maximum, and\n1\nascent. Its cost is\n4\n.\nPermutation\n[2,3,1]\nhas\n2\nprefix maximums,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n6\n.\nPermutation\n[3,1,2]\nhas\n1\nprefix maximum,\n2\nsuffix maximums, and\n1\nascent. Its cost is\n3\n.\nPermutation\n[3,2,1]\nhas\n1\nprefix maximum,\n3\nsuffix maximums, and\n0\nascents. Its cost is\n3\n.\nThe sum of all permutations' costs is\n34\n, so\nf(3)=34\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math",
            "*3000"
        ]
    },
    {
        "title": "E. Range Minimum Sum",
        "description": "For an array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\nof length\nn\n, define\nf(a)\nas the sum of the minimum element over all subsegments. That is,\nf(a)=\n∑\nl=1\nn\n∑\nr=l\nn\nmin\nl≤i≤r\na\ni\n.\nn\nn\nA permutation is a sequence of integers from\n1\nto\nn\nof length\nn\ncontaining each number exactly once. You are given a permutation\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\n. For each\ni\n, solve the following problem independently:\nErase\na\ni\nfrom\na\n, concatenating the remaining parts, resulting in\nb=[\na\n1\n,\na\n2\n,…,\na\ni−1\n,\na\ni+1\n,…,\na\nn\n]\n.\nCalculate\nf(b)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). Description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤5⋅\n10\n5\n).\nThe second line of each test case contains\nn\ndistinct integers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print one line containing\nn\nintegers. The\ni\n-th integer should be the answer when erasing\na\ni\n.\nExample\ninput\nCopy\n4\n1\n1\n3\n3 1 2\n5\n4 2 1 5 3\n8\n8 1 4 6 7 3 5 2\noutput\nCopy\n0 \n4 7 5 \n19 21 27 17 19 \n79 100 72 68 67 80 73 80 \nNote\nIn the second test case,\na=[3,1,2]\n.\nWhen removing\na\n1\n,\nb=[1,2]\n.\nf(b)=1+2+min{1,2}=4\n.\nWhen removing\na\n2\n,\nb=[3,2]\n.\nf(b)=3+2+min{3,2}=7\n.\nWhen removing\na\n3\n,\nb=[3,1]\n.\nf(b)=3+1+min{3,1}=5\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "divide and conquer",
            "implementation",
            "*2300"
        ]
    },
    {
        "title": "D. The Omnipotent Monster Killer",
        "description": "You, the monster killer, want to kill a group of monsters. The monsters are on a tree with\nn\nvertices. On vertex with number\ni\n(\n1≤i≤n\n), there is a monster with\na\ni\nattack points. You want to battle with monsters for\n10\n100\nrounds.\nIn each round, the following happens in order:\nAll living monsters attack you. Your health decreases by the sum of attack points of all living monsters.\nYou select some (possibly all or none) monsters and kill them. After being killed, the monster will not be able to do any attacks in the future.\nThere is a restriction: in one round, you cannot kill two monsters that are directly connected by an edge.\nIf you choose what monsters to attack optimally, what is the smallest health decrement you can have after all rounds?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). Description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n).\nThe following\nn−1\nlines each contain two integers\nx,y\n(\n1≤x,y≤n\n), denoting an edge on the tree connecting vertex\nx\nand\ny\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer: the minimum possible health decrement.\nExample\ninput\nCopy\n3\n1\n1000000000000\n5\n47 15 32 29 23\n1 2\n1 3\n2 4\n2 5\n7\n8 10 2 3 5 7 4\n1 2\n1 4\n3 2\n5 3\n6 2\n7 5\noutput\nCopy\n1000000000000\n193\n57\nNote\nIn the first test case, an optimal sequence of operations would be:\nIn the first round: first, receive the attack from the monster on vertex\n1\n, so your health decreases by\n10\n12\n. Then kill the monster on vertex\n1\n.\nIn the second round to the\n10\n100\n-th round: all monsters have been killed, so nothing happens.\nThe total health decrement is\n10\n12\n.\nIn the second test case, an optimal sequence of operations would be:\nIn the first round: first, receive the attack from the monster on vertex\n1,2,3,4,5\n, so your health decreases by\n47+15+32+29+23=146\n. Then kill the monsters on vertex\n1,4,5\n.\nIn the second round: first, receive the attack from the monster on vertex\n2,3\n, so your health decreases by\n15+32=47\n. Then kill the monsters on vertex\n2,3\n.\nIn the third round to the\n10\n100\n-th round: all monsters have been killed, so nothing happens.\nThe total health decrement is\n193\n.\nIn the third test case, an optimal sequence of operations would be:\nIn the first round: first, receive the attack from the monster on vertex\n1,2,3,4,5,6,7\n, so your health decreases by\n8+10+2+3+5+7+4=39\n. Then kill the monsters on vertex\n1,3,6,7\n.\nIn the second round: first, receive the attack from the monster on vertex\n2,4,5\n, so your health decreases by\n10+3+5=18\n. Then kill the monsters on vertex\n2,4,5\n.\nIn the third round to the\n10\n100\n-th round: all monsters have been killed, so nothing happens.\nThe total health decrement is\n57\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "C. Increasing Sequence with Fixed OR",
        "description": "You are given a positive integer\nn\n. Find the longest sequence of positive integers\na=[\na\n1\n,\na\n2\n,…,\na\nk\n]\nthat satisfies the following conditions, and print the sequence:\na\ni\n≤n\nfor all\n1≤i≤k\n.\na\nis strictly increasing. That is,\na\ni\n>\na\ni−1\nfor all\n2≤i≤k\n.\na\ni\n|\na\ni−1\n=n\nfor all\n2≤i≤k\n, where\n|\ndenotes the bitwise OR operation.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). Description of the test cases follows.\nThe only line of each test case contains one integer\nn\n(\n1≤n≤\n10\n18\n).\nIt's guaranteed that the sum of lengths of the longest valid sequences does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each testcase, print two lines. In the first line, print the length of your constructed sequence,\nk\n. In the second line, print\nk\npositive integers, denoting the sequence. If there are multiple longest sequences, you can print any of them.\nExample\ninput\nCopy\n4\n1\n3\n14\n23\noutput\nCopy\n1\n1\n3\n1 2 3\n4\n4 10 12 14\n5\n7 18 21 22 23",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "B. Make Majority",
        "description": "You are given a sequence\n[\na\n1\n,…,\na\nn\n]\nwhere each element\na\ni\nis either\n0\nor\n1\n. You can apply several (possibly zero) operations to the sequence. In each operation, you select two integers\n1≤l≤r≤|a|\n(where\n|a|\nis the current length of\na\n) and replace\n[\na\nl\n,…,\na\nr\n]\nwith a single element\nx\n, where\nx\nis the majority of\n[\na\nl\n,…,\na\nr\n]\n.\nHere, the majority of a sequence consisting of\n0\nand\n1\nis defined as follows: suppose there are\nc\n0\nzeros and\nc\n1\nones in the sequence, respectively.\nIf\nc\n0\n≥\nc\n1\n, the majority is\n0\n.\nIf\nc\n0\n<\nc\n1\n, the majority is\n1\n.\nFor example, suppose\na=[1,0,0,0,1,1]\n. If we select\nl=1,r=2\n, the resulting sequence will be\n[0,0,0,1,1]\n. If we select\nl=4,r=6\n, the resulting sequence will be\n[1,0,0,1]\n.\nDetermine if you can make\na=[1]\nwith a finite number of operations.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤4⋅\n10\n4\n). Description of the test cases follows.\nThe first line of each testcase contains one integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line of each testcase contains a string consisting of\n0\nand\n1\n, describing the sequence\na\n.\nIt's guaranteed that the sum of\nn\nover all testcases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, if it's possible to make\na=[1]\n, print YES. Otherwise, print NO. You can output the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will be recognized as positive responses.\nExample\ninput\nCopy\n5\n1\n0\n1\n1\n2\n01\n9\n100000001\n9\n000011000\noutput\nCopy\nNo\nYes\nNo\nYes\nNo\nNote\nIn the fourth testcase of the example, initially\na=[1,0,0,0,0,0,0,0,1]\n. A valid sequence of operations is:\nSelect\nl=2,r=8\nand apply the operation.\na\nbecomes\n[1,0,1]\n.\nSelect\nl=1,r=3\nand apply the operation.\na\nbecomes\n[1]\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*900"
        ]
    },
    {
        "title": "A. Split the Multiset",
        "description": "A multiset is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. For example,\n{2,2,4}\nis a multiset.\nYou have a multiset\nS\n. Initially, the multiset contains only one positive integer\nn\n. That is,\nS={n}\n. Additionally, there is a given positive integer\nk\n.\nIn one operation, you can select any positive integer\nu\nin\nS\nand remove one copy of\nu\nfrom\nS\n. Then, insert no more than\nk\npositive integers into\nS\nso that the sum of all inserted integers is equal to\nu\n.\nFind the minimum number of operations to make\nS\ncontain\nn\nones.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). Description of the test cases follows.\nThe only line of each testcase contains two integers\nn,k\n(\n1≤n≤1000,2≤k≤1000\n).\nOutput\nFor each testcase, print one integer, which is the required answer.\nExample\ninput\nCopy\n4\n1 5\n5 2\n6 3\n16 4\noutput\nCopy\n0\n4\n3\n5\nNote\nFor the first test case, initially\nS={1}\n, already satisfying the requirement. Therefore, we need zero operations.\nFor the second test case, initially\nS={5}\n. We can apply the following operations:\nSelect\nu=5\n, remove\nu\nfrom\nS\n, and insert\n2,3\ninto\nS\n. Now,\nS={2,3}\n.\nSelect\nu=2\n, remove\nu\nfrom\nS\n, and insert\n1,1\ninto\nS\n. Now,\nS={1,1,3}\n.\nSelect\nu=3\n, remove\nu\nfrom\nS\n, and insert\n1,2\ninto\nS\n. Now,\nS={1,1,1,2}\n.\nSelect\nu=2\n, remove\nu\nfrom\nS\n, and insert\n1,1\ninto\nS\n. Now,\nS={1,1,1,1,1}\n.\nUsing\n4\noperations in total, we achieve the goal.\nFor the third test case, initially\nS={6}\n. We can apply the following operations:\nSelect\nu=6\n, remove\nu\nfrom\nS\n, and insert\n1,2,3\ninto\nS\n. Now,\nS={1,2,3}\n.\nSelect\nu=2\n, remove\nu\nfrom\nS\n, and insert\n1,1\ninto\nS\n. Now,\nS={1,1,1,3}\n.\nSelect\nu=3\n, remove\nu\nfrom\nS\n, and insert\n1,1,1\ninto\nS\n. Now,\nS={1,1,1,1,1,1}\n.\nUsing\n3\noperations in total, we achieve the goal.\nFor the fourth test case, initially\nS={16}\n. We can apply the following operations:\nSelect\nu=16\n, remove\nu\nfrom\nS\n, and insert\n4,4,4,4\ninto\nS\n. Now,\nS={4,4,4,4}\n.\nRepeat for\n4\ntimes: select\nu=4\n, remove\nu\nfrom\nS\n, and insert\n1,1,1,1\ninto\nS\n.\nUsing\n5\noperations in total, we achieve the goal.",
        "time_limit": "1 second",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*900"
        ]
    },
    {
        "title": "H. Fumo Temple",
        "description": "This temple only magnifies the mountain's power.\nBadeline\nThis is an interactive problem.\nYou are given two positive integers\nn\nand\nm\n(\nn≤m\n).\nThe jury has hidden from you a rectangular matrix\na\nwith\nn\nrows and\nm\ncolumns, where\na\ni,j\n∈{−1,0,1}\nfor all\n1≤i≤n\nand\n1≤j≤m\n. The jury has also selected a cell\n(\ni\n0\n,\nj\n0\n)\n. Your goal is to find\n(\ni\n0\n,\nj\n0\n)\n.\nIn one query, you give a cell\n(i,j)\n, then the jury will reply with an integer.\nIf\n(i,j)=(\ni\n0\n,\nj\n0\n)\n, the jury will reply with\n0\n.\nElse, let\nS\nbe the sum of\na\nx,y\nover all\nx\nand\ny\nsuch that\nmin(i,\ni\n0\n)≤x≤max(i,\ni\n0\n)\nand\nmin(j,\nj\n0\n)≤y≤max(j,\nj\n0\n)\n. Then, the jury will reply with\n|i−\ni\n0\n|+|j−\nj\n0\n|+|S|\n.\nFind\n(\ni\n0\n,\nj\n0\n)\nby making at most\nn+225\nqueries.\nNote: the grader is not adaptive:\na\nand\n(\ni\n0\n,\nj\n0\n)\nare fixed before any queries are made.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤50\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤m≤5000\n) — the numbers of rows and the number of columns of the hidden matrix\na\nrespectively.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n25⋅\n10\n6\n.\nInteraction\nThe interaction for each test case begins by reading the integers\nn\nand\nm\n.\nTo make a query, output \"? i j\" (\n1≤i≤n,1≤j≤m\n) without quotes. Afterwards, you should read one single integer — the answer to your query.\nIf you receive the integer\n−1\ninstead of an answer or a valid value of\nn\nor\nm\n, it means your program has made an invalid query, has exceeded the limit of queries, or has given an incorrect answer on the previous test case. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nWhen you are ready to give the final answer, output \"! i j\" (\n1≤i≤n,1≤j≤m\n) without quotes — the indices of the hidden cell. After solving a test case, your program should move to the next one immediately. After solving all test cases, your program should be terminated immediately.\nAfter printing a query do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nHacks\nTo hack, use the following format:\nThe first line contains an integer\nt\n(\n1≤t≤50\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤m≤5000\n) — the sizes of the hidden matrix.\nThe second line of each test case contains two integers\ni\n0\nand\nj\n0\n(\n1≤\ni\n0\n≤n,1≤\nj\n0\n≤m\n) — the hidden cell.\nThen\nn\nlines follow. The\ni\n-th of them contains the string\ns\ni\nof length\nn\n, consisting only of the characters -, 0, and +. Here,\na\nij\n=−1\nif\ns\nij\n=−\n,\na\nij\n=0\nif\ns\nij\n=0\n, and\na\nij\n=1\nif\ns\nij\n=+\n.\nThe sum of\nn⋅m\nover all test cases should not exceed\n25⋅\n10\n6\n.\nAs an example, the hack format for the example input is:\n2\n34\n14\n+0+0\n+00+\n0---\n11\n11\n0\nExample\ninput\nCopy\n2\n3 4\n\n5\n\n3\n\n5\n\n1 1\n\n0\noutput\nCopy\n? 1 1\n\n? 3 3\n\n? 3 2\n\n! 1 4\n\n? 1 1\n\n! 1 1\nNote\nThe hidden matrix in the first test case:\n1\n0\n1\n0\n1\n0\n0\n1\n0\n−1\n−1\n−1\nThe hidden matrix in the second test case:\n0\nNote that the line breaks in the example input and output are for the sake of clarity, and do not occur in the real interaction.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "interactive",
            "*3500"
        ]
    },
    {
        "title": "G2. Spinning Round (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions are the allowed characters in\ns\n. You can make hacks only if both versions of the problem are solved.\nYou are given a permutation\np\nof length\nn\n. You are also given a string\ns\nof length\nn\n, where each character is either L, R, or ?.\nFor each\ni\nfrom\n1\nto\nn\n:\nDefine\nl\ni\nas the largest index\nj<i\nsuch that\np\nj\n>\np\ni\n. If there is no such index,\nl\ni\n:=i\n.\nDefine\nr\ni\nas the smallest index\nj>i\nsuch that\np\nj\n>\np\ni\n. If there is no such index,\nr\ni\n:=i\n.\nInitially, you have an undirected graph with\nn\nvertices (numbered from\n1\nto\nn\n) and no edges. Then, for each\ni\nfrom\n1\nto\nn\n, add one edge to the graph:\nIf\ns\ni\n=\n L, add the edge\n(i,\nl\ni\n)\nto the graph.\nIf\ns\ni\n=\n R, add the edge\n(i,\nr\ni\n)\nto the graph.\nIf\ns\ni\n=\n ?, either add the edge\n(i,\nl\ni\n)\nor the edge\n(i,\nr\ni\n)\nto the graph at your choice.\nFind the maximum possible diameter over all connected\n∗\ngraphs that you can form. Output\n−1\nif it is not possible to form any connected graphs.\n∗\nLet\nd(s,t)\ndenote the smallest number of edges on any path between\ns\nand\nt\n.\nThe diameter of the graph is defined as the maximum value of\nd(s,t)\nover all pairs of vertices\ns\nand\nt\n.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤4⋅\n10\n5\n) — the length of the permutation\np\n.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the elements of\np\n, which are guaranteed to form a permutation.\nThe third line of each test case contains a string\ns\nof length\nn\n. It is guaranteed that it consists only of the characters L, R, and ?.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum possible diameter over all connected graphs that you form, or\n−1\nif it is not possible to form any connected graphs.\nExample\ninput\nCopy\n8\n5\n2 1 4 3 5\nR?RL?\n2\n1 2\nLR\n3\n3 1 2\nL?R\n7\n5 3 1 6 4 2 7\n?R?R?R?\n5\n5 2 1 3 4\n?????\n6\n6 2 3 4 5 1\n?LLRLL\n8\n1 7 5 6 2 8 4 3\n?R??????\n12\n6 10 7 1 8 5 12 2 11 3 4 9\n????????????\noutput\nCopy\n3\n-1\n-1\n4\n4\n3\n5\n8\nNote\nIn the first test case, there are two connected graphs (the labels are indices):\nThe graph on the left has a diameter of\n2\n, while the graph on the right has a diameter of\n3\n, so the answer is\n3\n.\nIn the second test case, there are no connected graphs, so the answer is\n−1\n.",
        "time_limit": "7 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "divide and conquer",
            "dp",
            "trees",
            "*3500"
        ]
    },
    {
        "title": "G1. Spinning Round (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions are the allowed characters in\ns\n. In the easy version,\ns\nonly contains the character ?. You can make hacks only if both versions of the problem are solved.\nYou are given a permutation\np\nof length\nn\n. You are also given a string\ns\nof length\nn\n, consisting only of the character ?.\nFor each\ni\nfrom\n1\nto\nn\n:\nDefine\nl\ni\nas the largest index\nj<i\nsuch that\np\nj\n>\np\ni\n. If there is no such index,\nl\ni\n:=i\n.\nDefine\nr\ni\nas the smallest index\nj>i\nsuch that\np\nj\n>\np\ni\n. If there is no such index,\nr\ni\n:=i\n.\nInitially, you have an undirected graph with\nn\nvertices (numbered from\n1\nto\nn\n) and no edges. Then, for each\ni\nfrom\n1\nto\nn\n, add one edge to the graph:\nIf\ns\ni\n=\n L, add the edge\n(i,\nl\ni\n)\nto the graph.\nIf\ns\ni\n=\n R, add the edge\n(i,\nr\ni\n)\nto the graph.\nIf\ns\ni\n=\n ?, either add the edge\n(i,\nl\ni\n)\nor the edge\n(i,\nr\ni\n)\nto the graph at your choice.\nFind the maximum possible diameter\n∗\nover all connected graphs that you can form. Output\n−1\nif it is not possible to form any connected graphs.\n∗\nLet\nd(s,t)\ndenote the smallest number of edges on any path between\ns\nand\nt\n.\nThe diameter of the graph is defined as the maximum value of\nd(s,t)\nover all pairs of vertices\ns\nand\nt\n.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤4⋅\n10\n5\n) — the length of the permutation\np\n.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the elements of\np\n, which are guaranteed to form a permutation.\nThe third line of each test case contains a string\ns\nof length\nn\n. It is guaranteed that it consists only of the character ?.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum possible diameter over all connected graphs that you form, or\n−1\nif it is not possible to form any connected graphs.\nExample\ninput\nCopy\n8\n5\n2 1 4 3 5\n?????\n2\n1 2\n??\n3\n3 1 2\n???\n7\n5 3 1 6 4 2 7\n???????\n5\n5 2 1 3 4\n?????\n6\n6 2 3 4 5 1\n??????\n8\n1 7 5 6 2 8 4 3\n????????\n12\n6 10 7 1 8 5 12 2 11 3 4 9\n????????????\noutput\nCopy\n4\n1\n2\n6\n4\n5\n5\n8\nNote\nIn the first test case, here are some possible connected graphs that you can form (the labels are indices):\nIn the second test case, the only connected graph has a diameter of\n1\n.",
        "time_limit": "7 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "divide and conquer",
            "dp",
            "trees",
            "*2900"
        ]
    },
    {
        "title": "F2. Interesting Problem (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is the constraint on\nn\n. You can make hacks only if both versions of the problem are solved.\nYou are given an array of integers\na\nof length\nn\n.\nIn one operation, you will perform the following two-step process:\nChoose an index\ni\nsuch that\n1≤i<|a|\nand\na\ni\n=i\n.\nRemove\na\ni\nand\na\ni+1\nfrom the array and concatenate the remaining parts.\nFind the maximum number of times that you can perform the operation above.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤800\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n800\n.\nOutput\nFor each test case, output a single integer — the maximum number of times that you can perform the operation.\nExample\ninput\nCopy\n6\n5\n1 5 3 2 4\n8\n2 1 3 4 5 6 7 8\n3\n1 2 3\n4\n1 2 4 4\n5\n4 4 1 3 5\n1\n1\noutput\nCopy\n2\n3\n1\n2\n0\n0\nNote\nIn the first test case, one possible optimal sequence of operations is\n[1,5,3,2,4]→[1,5,4]→[4]\n.\nIn the third test case, one possible optimal sequence of operations is\n[1,2,3]→[1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "*2600"
        ]
    },
    {
        "title": "F1. Interesting Problem (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is the constraint on\nn\n. You can make hacks only if both versions of the problem are solved.\nYou are given an array of integers\na\nof length\nn\n.\nIn one operation, you will perform the following two-step process:\nChoose an index\ni\nsuch that\n1≤i<|a|\nand\na\ni\n=i\n.\nRemove\na\ni\nand\na\ni+1\nfrom the array and concatenate the remaining parts.\nFind the maximum number of times that you can perform the operation above.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n100\n.\nOutput\nFor each test case, output a single integer — the maximum number of times that you can perform the operation.\nExample\ninput\nCopy\n6\n5\n1 5 3 2 4\n8\n2 1 3 4 5 6 7 8\n3\n1 2 3\n4\n1 2 4 4\n5\n4 4 1 3 5\n1\n1\noutput\nCopy\n2\n3\n1\n2\n0\n0\nNote\nIn the first test case, one possible optimal sequence of operations is\n[1,5,3,2,4]→[1,5,4]→[4]\n.\nIn the third test case, one possible optimal sequence of operations is\n[1,2,3]→[1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "*2500"
        ]
    },
    {
        "title": "E. Wonderful Tree!",
        "description": "God's Blessing on This ArrayForces!\nA Random Pebble\nYou are given a tree with\nn\nvertices, rooted at vertex\n1\n. The\ni\n-th vertex has an integer\na\ni\nwritten on it.\nLet\nL\nbe the set of all direct children\n∗\nof\nv\n. A tree is called wonderful, if for all vertices\nv\nwhere\nL\nis not empty,\na\nv\n≤\n∑\nu∈L\na\nu\n.\n∑\nIn one operation, you choose any vertex\nv\nand increase\na\nv\nby\n1\n.\nFind the minimum number of operations needed to make the given tree wonderful!\n∗\nVertex\nu\nis called a direct child of vertex\nv\nif:\nu\nand\nv\nare connected by an edge, and\nv\nis on the (unique) path from\nu\nto the root of the tree.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤5000\n) — the number of vertices in the tree.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the values initially written on the vertices.\nThe third line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n<i\n), indicating that there is an edge from vertex\np\ni\nto vertex\ni\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations needed to make the tree wonderful.\nExample\ninput\nCopy\n4\n5\n9 3 4 1 2\n1 1 3 3\n2\n5 3\n1\n2\n36 54\n1\n3\n0 0 0\n1 2\noutput\nCopy\n3\n2\n0\n0\nNote\nThe tree in the first test case:\nYou can apply the operation once on vertex\n5\nand twice on vertex\n2\nto get a wonderful tree.\nIn the second test case, you can apply the operation twice on vertex\n2\nto get a wonderful tree.\nIn the third and fourth test cases, the tree is already wonderful, so you don't need to apply any operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dsu",
            "greedy",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "D. World is Mine",
        "description": "Alice and Bob are playing a game. Initially, there are\nn\ncakes, with the\ni\n-th cake having a tastiness value of\nai\n.\nAlice and Bob take turns eating them, with Alice starting first:\nIn her turn, Alice chooses and eats any remaining cake whose tastiness is strictly greater than the maximum tastiness of any of the cakes she's eaten before that. Note that on the first turn, she can choose any cake.\nIn his turn, Bob chooses any remaining cake and eats it.\nThe game ends when the current player can't eat a suitable cake. Let\nx\nbe the number of cakes that Alice ate. Then, Alice wants to maximize\nx\n, while Bob wants to minimize\nx\n.\nFind out how many cakes Alice will eat if both players play optimally.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5000\n) — the number of cakes.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤n\n) — the tastiness values of the cakes.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, output a single integer — the number of cakes Alice will eat if both players play optimally.\nExample\ninput\nCopy\n9\n4\n1 4 2 3\n3\n1 1 1\n5\n1 4 2 3 4\n4\n3 4 1 4\n1\n1\n8\n4 3 2 5 6 8 3 4\n7\n6 1 1 3 5 3 1\n11\n6 11 6 8 7 5 3 11 2 3 5\n17\n2 6 5 3 9 1 6 2 5 6 3 2 3 9 6 1 6\noutput\nCopy\n2\n1\n3\n2\n1\n3\n2\n4\n4\nNote\nIn the first test case, one possible sequence of turns is:\nAlice eats a cake with a tastiness value of\n1\n. The remaining cakes are\n[4,2,3]\n.\nBob eats a cake with a tastiness value of\n2\n. The remaining cakes are\n[4,3]\n.\nAlice eats a cake with a tastiness of\n3\n. The remaining cakes are\n[4]\n.\nBob eats a cake with a tastiness value of\n4\n. The remaining cakes are\n[]\n.\nSince there are no more cakes left, the game ends.\nIn the second test case, one possible sequence of turns is:\nAlice eats a cake with a tastiness value of\n1\n. The remaining cakes are\n[1,1]\n.\nBob eats a cake with a tastiness value of\n1\n. The remaining cakes are\n[1]\n.\nSince Alice has already eaten a cake with a tastiness value of\n1\n, she cannot make a turn, so the game ends.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "games",
            "*1800"
        ]
    },
    {
        "title": "C. Basil's Garden",
        "description": "There are\nn\nflowers in a row, the\ni\n-th of them initially has a positive height of\nh\ni\nmeters.\nEvery second, the wind will blow from the left, causing the height of some flowers to decrease.\nSpecifically, every second, for each\ni\nfrom\n1\nto\nn\n, in this order, the following happens:\nIf\ni=n\nor\nh\ni\n>\nh\ni+1\n, the value of\nh\ni\nchanges to\nmax(0,\nh\ni\n−1)\n.\nHow many seconds will pass before\nh\ni\n=0\nfor all\n1≤i≤n\nfor the first time?\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of flowers.\nThe second line of each test case contains\nn\nintegers\nh\n1\n,\nh\n2\n,…,\nh\nn\n(\n1≤\nh\ni\n≤\n10\n9\n) — the heights of the flowers.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of seconds that will pass before\nh\ni\n=0\nfor all\n1≤i≤n\n.\nExample\ninput\nCopy\n4\n3\n1 1 2\n2\n3 1\n1\n9\n5\n7 4 4 3 2\noutput\nCopy\n4\n3\n9\n7\nNote\nIn the first test case, the flower heights change as follows:\n[1,1,2]→[1,1,1]→[1,1,0]→[1,0,0]→[0,0,0]\n.\nIn the second test case, the flower heights change as follows:\n[3,1]→[2,0]→[1,0]→[0,0]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1200"
        ]
    },
    {
        "title": "B. K-Sort",
        "description": "You are given an array of integers\na\nof length\nn\n.\nYou can apply the following operation any number of times (maybe, zero):\nFirst, choose an integer\nk\nsuch that\n1≤k≤n\nand pay\nk+1\ncoins.\nThen, choose exactly\nk\nindices such that\n1≤\ni\n1\n<\ni\n2\n<…<\ni\nk\n≤n\n.\nThen, for each\nx\nfrom\n1\nto\nk\n, increase\na\ni\nx\nby\n1\n.\nFind the minimum number of coins needed to make\na\nnon-decreasing. That is,\na\n1\n≤\na\n2\n≤…≤\na\nn\n.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of coins needed to make\na\nnon-decreasing.\nExample\ninput\nCopy\n5\n3\n1 7 9\n5\n2 1 4 7 6\n4\n1 3 2 4\n1\n179\n9\n344 12 37 60 311 613 365 328 675\noutput\nCopy\n0\n3\n2\n0\n1821\nNote\nIn the first test case,\na\nis already sorted, so you don't have to spend any coins.\nIn the second test case, the optimal sequence of operations is:\nChoose\nk=2\nand the indices\n2\nand\n5\n:\n[2,1,4,7,6]→[2,2,4,7,7]\n. This costs\n3\ncoins.\nIt can be proven that it is not possible to make\na\nnon-decreasing by spending less than\n3\ncoins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ]
    },
    {
        "title": "A. Upload More RAM",
        "description": "Oh no, the ForceCodes servers are running out of memory! Luckily, you can help them out by uploading some of your RAM!\nYou want to upload\nn\nGBs of RAM. Every second, you will upload either\n0\nor\n1\nGB of RAM. However, there is a restriction on your network speed: in any\nk\nconsecutive seconds, you can upload only at most\n1\nGB of RAM in total.\nFind the minimum number of seconds needed to upload\nn\nGBs of RAM!\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤100\n) — the number of GBs that you want to upload and the length of the time window respectively.\nOutput\nFor each test case, output a single integer — the minimum number of seconds needed to upload\nn\nGBs of RAM.\nExample\ninput\nCopy\n6\n5 1\n2 2\n2 3\n1 7\n11 5\n100 100\noutput\nCopy\n5\n3\n4\n1\n51\n9901\nNote\nIn the first test case, you can upload\n1\nGB of RAM per second, so to upload\n5\nGBs, you need\n5\nseconds.\nIn the second test case, you can upload\n1\nGB in the first second,\n0\nGBs in the second second, and\n1\nGB in the third second, which in total adds up to exactly\n2\nGBs of uploaded RAM.\nIn the third test case, you can upload\n1\nGB in the first second,\n0\nGBs in the second second,\n0\nGBs in the third second, and\n1\nGB in the fourth second, which in total adds up to exactly\n2\nGBs of uploaded RAM.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "G2. Permutation Problem (Hard Version)",
        "description": "This is the hard version of the problem. The only difference is that in this version\nn≤5⋅\n10\n5\nand the sum of\nn\nfor all sets of input data does not exceed\n5⋅\n10\n5\n.\nYou are given a permutation\np\nof length\nn\n. Calculate the number of index pairs\n1≤i<j≤n\nsuch that\np\ni\n⋅\np\nj\nis divisible by\ni⋅j\nwithout remainder.\nA permutation is a sequence of\nn\nintegers, in which each integer from\n1\nto\nn\noccurs exactly once. For example,\n[1]\n,\n[3,5,2,1,4]\n,\n[1,3,2]\nare permutations, while\n[2,3,2]\n,\n[4,3,1]\n,\n[0]\nare not.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains a single integer\nn\n(\n1≤n≤5⋅\n10\n5\n) — the length of the permutation\np\n.\nThe second line of each set of input data contains\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the permutation\np\n.\nIt is guaranteed that the sum of\nn\nfor all sets of input data does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each set of input data, output the number of index pairs\n1≤i<j≤n\nsuch that\np\ni\n⋅\np\nj\nis divisible by\ni⋅j\nwithout remainder.\nExample\ninput\nCopy\n6\n1\n1\n2\n1 2\n3\n2 3 1\n5\n2 4 1 3 5\n12\n8 9 7 12 1 10 6 3 2 4 11 5\n15\n1 2 4 6 8 10 12 14 3 9 15 5 7 11 13\noutput\nCopy\n0\n1\n1\n3\n9\n3\nNote\nIn the first set of input data, there are no index pairs, as the size of the permutation is\n1\n.\nIn the second set of input data, there is one index pair\n(1,2)\nand it is valid.\nIn the third set of input data, the index pair\n(1,2)\nis valid.\nIn the fourth set of input data, the index pairs\n(1,2)\n,\n(1,5)\n, and\n(2,5)\nare valid.",
        "time_limit": "3 seconds",
        "memory_limit": "128 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "hashing",
            "math",
            "number theory",
            "*2500"
        ]
    },
    {
        "title": "G1. Permutation Problem (Simple Version)",
        "description": "This is a simple version of the problem. The only difference is that in this version\nn≤\n10\n5\nand the sum of\nn\nfor all sets of input data does not exceed\n10\n5\n.\nYou are given a permutation\np\nof length\nn\n. Calculate the number of index pairs\n1≤i<j≤n\nsuch that\np\ni\n⋅\np\nj\nis divisible by\ni⋅j\nwithout remainder.\nA permutation is a sequence of\nn\nintegers, where each integer from\n1\nto\nn\noccurs exactly once. For example,\n[1]\n,\n[3,5,2,1,4]\n,\n[1,3,2]\nare permutations, while\n[2,3,2]\n,\n[4,3,1]\n,\n[0]\nare not.\nInput\nEach test consists of multiple sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the permutation\np\n.\nThe second line of each set of input data contains\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the permutation\np\n.\nIt is guaranteed that the sum of\nn\nfor all sets of input data does not exceed\n10\n5\n.\nOutput\nFor each set of input data, output the number of index pairs\n1≤i<j≤n\nsuch that\np\ni\n⋅\np\nj\nis divisible by\ni⋅j\nwithout remainder.\nExample\ninput\nCopy\n6\n1\n1\n2\n1 2\n3\n2 3 1\n5\n2 4 1 3 5\n12\n8 9 7 12 1 10 6 3 2 4 11 5\n15\n1 2 4 6 8 10 12 14 3 9 15 5 7 11 13\noutput\nCopy\n0\n1\n1\n3\n9\n3\nNote\nIn the first set of input data, there are no index pairs, as the size of the permutation is\n1\n.\nIn the second set of input data, there is one index pair\n(1,2)\nand it is valid.\nIn the third set of input data, the index pair\n(1,2)\nis valid.\nIn the fourth set of input data, the index pairs\n(1,2)\n,\n(1,5)\n, and\n(2,5)\nare valid.",
        "time_limit": "3 seconds",
        "memory_limit": "128 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "combinatorics",
            "data structures",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "F. Non-academic Problem",
        "description": "You are given a connected undirected graph, the vertices of which are numbered with integers from\n1\nto\nn\n. Your task is to minimize the number of pairs of vertices\n1≤u<v≤n\nbetween which there exists a path in this graph. To achieve this, you can remove exactly one edge from the graph.\nFind the smallest number of pairs of vertices!\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains two integers\nn\nand\nm\n(\n2≤n≤\n10\n5\n,\nn−1≤m≤min(\n10\n5\n,\nn⋅(n−1)\n2\n)\n) — the number of vertices in the graph and the number of edges.\nEach of the next\nm\nlines contains two integers\nu\nand\nv\n(\n1≤u,v≤n,u≠v\n), indicating that there is an undirected edge in the graph between vertices\nu\nand\nv\n.\nIt is guaranteed that the given graph is connected and without multiple edges.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all sets of input data does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each set of input data, output the smallest number of pairs of reachable vertices, if exactly one edge can be removed.\nExample\ninput\nCopy\n6\n2 1\n1 2\n3 3\n1 2\n2 3\n1 3\n5 5\n1 2\n1 3\n3 4\n4 5\n5 3\n6 7\n1 2\n1 3\n2 3\n3 4\n4 5\n4 6\n5 6\n5 5\n1 2\n1 3\n2 3\n2 4\n3 5\n10 12\n1 2\n1 3\n2 3\n2 4\n4 5\n5 6\n6 7\n7 4\n3 8\n8 9\n9 10\n10 8\noutput\nCopy\n0\n3\n4\n6\n6\n21\nNote\nIn the first set of input data, we will remove the single edge\n(1,2)\nand the only pair of vertices\n(1,2)\nwill become unreachable from each other.\nIn the second set of input data, no matter which edge we remove, all vertices will be reachable from each other.\nIn the fourth set of input data, the graph looks like this initially.\nWe will remove the edge\n(3,4)\nand then the only reachable pairs of vertices will be\n(1,2)\n,\n(1,3)\n,\n(2,3)\n,\n(4,5)\n,\n(4,6)\n,\n(5,6)\n.\nIn the sixth set of input data, the graph looks like this initially.\nAfter removing the edge\n(2,4)\n, the graph will look like this. Thus, there will be\n21\npairs of reachable vertices.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "graphs",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "E. Beautiful Array",
        "description": "You are given an array of integers\na\n1\n,\na\n2\n,…,\na\nn\nand an integer\nk\n. You need to make it beautiful with the least amount of operations.\nBefore applying operations, you can shuffle the array elements as you like. For one operation, you can do the following:\nChoose an index\n1≤i≤n\n,\nMake\na\ni\n=\na\ni\n+k\n.\nThe array\nb\n1\n,\nb\n2\n,…,\nb\nn\nis beautiful if\nb\ni\n=\nb\nn−i+1\nfor all\n1≤i≤n\n.\nFind the minimum number of operations needed to make the array beautiful, or report that it is impossible.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains two integers\nn\nand\nk\n(\n1≤n≤\n10\n5\n,\n1≤k≤\n10\n9\n) — the size of the array\na\nand the number\nk\nfrom the problem statement.\nThe second line of each set of input data contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all sets of input data does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each set of input data, output the minimum number of operations needed to make the array beautiful, or\n−1\nif it is impossible.\nExample\ninput\nCopy\n11\n1 1000000000\n1\n2 1\n624323799 708290323\n3 1\n3 2 1\n4 1\n7 1 5 3\n5 1\n11 2 15 7 10\n7 1\n1 8 2 16 8 16 31\n13 1\n2 1 1 3 3 11 12 22 45 777 777 1500 74\n10 2\n1 2 1 2 1 2 1 2 1 2\n11 2\n1 2 1 2 1 2 1 2 1 2 1\n13 3\n2 3 9 14 17 10 22 20 18 30 1 4 28\n5 1\n2 3 5 3 5\noutput\nCopy\n0\n83966524\n1\n4\n6\n1\n48\n-1\n0\n14\n0\nNote\nIn the first set of input data, the array is already beautiful.\nIn the second set of input data, you can shuffle the array before the operations and perform the operation with index\ni=1\nfor\n83966524\ntimes.\nIn the third set of input data, you can shuffle the array\na\nand make it equal to\n[2,3,1]\n. Then apply the operation with index\ni=3\nto get the array\n[2,3,2]\n, which is beautiful.\nIn the eighth set of input data, there is no set of operations and no way to shuffle the elements to make the array beautiful.\nIn the ninth set of input data, the array is already beautiful.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "D. Mathematical Problem",
        "description": "You are given a string\ns\nof length\nn>1\n, consisting of digits from\n0\nto\n9\n. You must insert exactly\nn−2\nsymbols\n+\n(addition) or\n×\n(multiplication) into this string to form a valid arithmetic expression.\nIn this problem, the symbols cannot be placed before the first or after the last character of the string\ns\n, and two symbols cannot be written consecutively. Also, note that the order of the digits in the string cannot be changed. Let's consider\ns=987009\n:\nFrom this string, the following arithmetic expressions can be obtained:\n9×8+70×0+9=81\n,\n98×7×0+0×9=0\n,\n9+8+7+0+09=9+8+7+0+9=33\n. Note that the number\n09\nis considered valid and is simply transformed into\n9\n.\nFrom this string, the following arithmetic expressions cannot be obtained:\n+9×8×70+09\n(symbols should only be placed between digits),\n98×70+0+9\n(since there are\n6\ndigits, there must be exactly\n4\nsymbols).\nThe result of the arithmetic expression is calculated according to the rules of mathematics — first all multiplication operations are performed, then addition. You need to find the minimum result that can be obtained by inserting exactly\nn−2\naddition or multiplication symbols into the given string\ns\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows their description.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤20\n) — the length of the string\ns\n.\nThe second line of each test case contains a string\ns\nof length\nn\n, consisting of digits from\n0\nto\n9\n.\nOutput\nFor each test case, output the minimum result of the arithmetic expression that can be obtained by inserting exactly\nn−2\naddition or multiplication symbols into the given string.\nExample\ninput\nCopy\n18\n2\n10\n2\n74\n2\n00\n2\n01\n3\n901\n3\n101\n5\n23311\n6\n987009\n7\n1111111\n20\n99999999999999999999\n20\n00000000000000000000\n4\n0212\n18\n057235283621345395\n4\n1112\n20\n19811678487321784121\n4\n1121\n4\n2221\n3\n011\noutput\nCopy\n10\n74\n0\n1\n9\n1\n19\n0\n11\n261\n0\n0\n0\n12\n93\n12\n24\n0\nNote\nIn the first four test cases, we cannot add symbols, so the answer will be the original number.\nIn the fifth test case, the optimal answer looks as follows:\n9×01=9×1=9\n.\nIn the sixth test case, the optimal answer looks as follows:\n1×01=1×1=1\n.\nIn the seventh test case, the optimal answer looks as follows:\n2+3+3+11=19\n.\nIn the eighth test case, one of the optimal answers looks as follows:\n98×7×0+0×9=0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "math",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "C. Update Queries",
        "description": "Let's consider the following simple problem. You are given a string\ns\nof length\nn\n, consisting of lowercase Latin letters, as well as an array of indices\nind\nof length\nm\n(\n1≤in\nd\ni\n≤n\n) and a string\nc\nof length\nm\n, consisting of lowercase Latin letters. Then, in order, you perform the update operations, namely, during the\ni\n-th operation, you set\ns\nin\nd\ni\n=\nc\ni\n. Note that you perform all\nm\noperations from the first to the last.\nOf course, if you change the order of indices in the array\nind\nand/or the order of letters in the string\nc\n, you can get different results. Find the lexicographically smallest string\ns\nthat can be obtained after\nm\nupdate operations, if you can rearrange the indices in the array\nind\nand the letters in the string\nc\nas you like.\nA string\na\nis lexicographically less than a string\nb\nif and only if one of the following conditions is met:\na\nis a prefix of\nb\n, but\na≠b\n;\nin the first position where\na\nand\nb\ndiffer, the symbol in string\na\nis earlier in the alphabet than the corresponding symbol in string\nb\n.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains two integers\nn\nand\nm\n(\n1≤n,m≤\n10\n5\n) — the length of the string\ns\nand the number of updates.\nThe second line of each set of input data contains a string\ns\nof length\nn\n, consisting of lowercase Latin letters.\nThe third line of each set of input data contains\nm\nintegers\nin\nd\n1\n,in\nd\n2\n,…,in\nd\nm\n(\n1≤in\nd\ni\n≤n\n) — the array of indices\nind\n.\nThe fourth line of each set of input data contains a string\nc\nof length\nm\n, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of\nn\nover all sets of input data does not exceed\n2⋅\n10\n5\n. Similarly, the sum of\nm\nover all sets of input data does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each set of input data, output the lexicographically smallest string\ns\nthat can be obtained by rearranging the indices in the array\nind\nand the letters in the string\nc\nas you like.\nExample\ninput\nCopy\n4\n1 2\na\n1 1\ncb\n4 4\nmeow\n1 2 1 4\nzcwz\n7 4\nabacaba\n1 3 5 7\ndamn\n7 10\ntraktor\n7 6 5 4 3 2 1 6 4 2\ncodeforces\noutput\nCopy\nb\ncwoz\nabdcmbn\nccdeefo\nNote\nIn the first set of input data, you can leave the array\nind\nand the string\nc\nunchanged and simply perform all operations in that order.\nIn the second set of input data, you can set the array\nind=[1,1,4,2]\nand\nc=\n\"zczw\". Then the string\ns\nwill change as follows:\nmeow→zeow→ceow→ceoz→cwoz\n.\nIn the third set of input data, you can leave the array\nind\nunchanged and set\nc=\n\"admn\". Then the string\ns\nwill change as follows:\nabacaba→abacaba→abdcaba→abdcmba→abdcmbn\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1100"
        ]
    },
    {
        "title": "B. Matrix Stabilization",
        "description": "You are given a matrix of size\nn×m\n, where the rows are numbered from\n1\nto\nn\nfrom top to bottom, and the columns are numbered from\n1\nto\nm\nfrom left to right. The element at the intersection of the\ni\n-th row and the\nj\n-th column is denoted by\na\nij\n.\nConsider the algorithm for stabilizing matrix\na\n:\nFind the cell\n(i,j)\nsuch that its value is strictly greater than the values of all its neighboring cells. If there is no such cell, terminate the algorithm. If there are multiple such cells, choose the cell with the smallest value of\ni\n, and if there are still multiple cells, choose the one with the smallest value of\nj\n.\nSet\na\nij\n=\na\nij\n−1\n.\nGo to step\n1\n.\nIn this problem, cells\n(a,b)\nand\n(c,d)\nare considered neighbors if they share a common side, i.e.,\n|a−c|+|b−d|=1\n.\nYour task is to output the matrix\na\nafter the stabilization algorithm has been executed. It can be shown that this algorithm cannot run for an infinite number of iterations.\nInput\nEach test consists of multiple sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. This is followed by their description.\nThe first line of each set of input data contains two integers\nn\nand\nm\n(\n1≤n,m≤100,n⋅m>1\n) — the number of rows and columns of matrix\na\n.\nThe next\nn\nlines describe the corresponding rows of the matrix. The\ni\n-th line contains\nm\nintegers\na\ni1\n,\na\ni2\n,…,\na\nim\n(\n1≤\na\nij\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn⋅m\nover all sets of input data does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each set of input data, output\nn\nlines with\nm\nnumbers in each line — the values of the cells of matrix\na\nafter the stabilization algorithm.\nExample\ninput\nCopy\n6\n1 2\n3 1\n2 1\n1\n1\n2 2\n1 2\n3 4\n2 3\n7 4 5\n1 8 10\n5 4\n92 74 31 74\n74 92 17 7\n31 17 92 3\n74 7 3 92\n7 31 1 1\n3 3\n1000000000 1 1000000000\n1 1000000000 1\n1000000000 1 1000000000\noutput\nCopy\n1 1 \n1 \n1 \n1 2 \n3 3 \n4 4 5 \n1 8 8 \n74 74 31 31 \n74 74 17 7 \n31 17 17 3 \n31 7 3 3 \n7 7 1 1 \n1 1 1 \n1 1 1 \n1 1 1 \nNote\nIn the first set of input data, the algorithm will select the cell\n(1,1)\ntwice in a row and then terminate.\nIn the second set of input data, there is no cell whose value is strictly greater than the values of all neighboring cells.\nIn the third set of input data, the algorithm will select the cell\n(2,2)\nand then terminate.\nIn the fourth set of input data, the algorithm will select the cell\n(1,1)\nthree times and then the cell\n(2,3)\ntwice.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "sortings",
            "*1000"
        ]
    },
    {
        "title": "A. X Axis",
        "description": "You are given three points with integer coordinates\nx\n1\n,\nx\n2\n, and\nx\n3\non the\nX\naxis (\n1≤\nx\ni\n≤10\n). You can choose any point with an integer coordinate\na\non the\nX\naxis. Note that the point\na\nmay coincide with\nx\n1\n,\nx\n2\n, or\nx\n3\n. Let\nf(a)\nbe the total distance from the given points to the point\na\n. Find the smallest value of\nf(a)\n.\nThe distance between points\na\nand\nb\nis equal to\n|a−b|\n. For example, the distance between points\na=5\nand\nb=2\nis\n3\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. Then follows their descriptions.\nThe single line of each test case contains three integers\nx\n1\n,\nx\n2\n, and\nx\n3\n(\n1≤\nx\ni\n≤10\n) — the coordinates of the points.\nOutput\nFor each test case, output the smallest value of\nf(a)\n.\nExample\ninput\nCopy\n8\n1 1 1\n1 5 9\n8 2 8\n10 9 3\n2 1 1\n2 4 1\n7 3 5\n1 9 4\noutput\nCopy\n0\n8\n6\n7\n1\n3\n4\n8\nNote\nIn the first test case, the smallest value of\nf(a)\nis achieved when\na=1\n:\nf(1)=|1−1|+|1−1|+|1−1|=0\n.\nIn the second test case, the smallest value of\nf(a)\nis achieved when\na=5\n:\nf(5)=|1−5|+|5−5|+|9−5|=8\n.\nIn the third test case, the smallest value of\nf(a)\nis achieved when\na=8\n:\nf(8)=|8−8|+|2−8|+|8−8|=6\n.\nIn the fourth test case, the smallest value of\nf(a)\nis achieved when\na=9\n:\nf(10)=|10−9|+|9−9|+|3−9|=7\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "H2. Maximize the Largest Component (Hard Version)",
        "description": "Easy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\nAlex has a grid with\nn\nrows and\nm\ncolumns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\nIn one operation, Alex selects any row\nr\n(\n1≤r≤n\n) and any column\nc\n(\n1≤c≤m\n), then sets every cell in row\nr\nand column\nc\nto be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n⋅m≤\n10\n6\n) — the number of rows and columns of the grid.\nThe next\nn\nlines each contain\nm\ncharacters. Each character is either '.' or '#'.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the maximum possible size of a connected component of '#' cells that Alex can achieve.\nExample\ninput\nCopy\n6\n1 1\n.\n4 2\n..\n#.\n#.\n.#\n3 5\n.#.#.\n..#..\n.#.#.\n5 5\n#...#\n....#\n#...#\n.....\n...##\n6 6\n.#..#.\n#..#..\n.#...#\n#.#.#.\n.#.##.\n###..#\n6 8\n..#....#\n.####.#.\n###.#..#\n.##.#.##\n.#.##.##\n#..##.#.\noutput\nCopy\n1\n7\n11\n16\n22\n36\nNote\nIn the fourth test case, it is optimal for Alex to set all cells in row\n4\nand column\n2\nto be '#'. Doing so will lead to the largest connected component of '#' having a size of\n16\n.\nIn the fifth test case, it is optimal for Alex to set all cells in row\n2\nand column\n4\nto be '#'. Doing so will lead to the largest connected component of '#' having a size of\n22\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "H1. Maximize the Largest Component (Easy Version)",
        "description": "Easy and hard versions are actually different problems, so read statements of both problems completely and carefully. The only difference between the two versions is the operation.\nAlex has a grid with\nn\nrows and\nm\ncolumns consisting of '.' and '#' characters. A set of '#' cells forms a connected component if from any cell in this set, it is possible to reach any other cell in this set by only moving to another cell in the set that shares a common side. The size of a connected component is the number of cells in the set.\nIn one operation, Alex selects any row\nr\n(\n1≤r≤n\n) or any column\nc\n(\n1≤c≤m\n), then sets every cell in row\nr\nor column\nc\nto be '#'. Help Alex find the maximum possible size of the largest connected component of '#' cells that he can achieve after performing the operation at most once.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n⋅m≤\n10\n6\n) — the number of rows and columns of the grid.\nThe next\nn\nlines each contain\nm\ncharacters. Each character is either '.' or '#'.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the maximum possible size of a connected component of '#' cells that Alex can achieve.\nExample\ninput\nCopy\n6\n1 1\n.\n4 2\n..\n#.\n#.\n.#\n3 5\n.#.#.\n..#..\n.#.#.\n5 5\n#...#\n....#\n#...#\n.....\n...##\n6 6\n.#..#.\n#..#..\n.#...#\n#.#.#.\n.#.##.\n###..#\n6 8\n..#....#\n.####.#.\n###.#..#\n.##.#.##\n.#.##.##\n#..##.#.\noutput\nCopy\n1\n6\n9\n11\n15\n30\nNote\nIn the second test case, it is optimal for Alex to set all cells in column\n2\nto be '#'. Doing so will lead to the largest connected component of '#' having a size of\n6\n.\nIn the third test case, it is optimal for Alex to set all cells in row\n2\nto be '#'. Doing so will lead to the largest connected component of '#' having a size of\n9\n.\nIn the fourth test case, it is optimal for Alex to set all cells in row\n4\nto be '#'. Doing so will lead to the largest connected component of '#' having a size of\n11\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "implementation",
            "*1700"
        ]
    },
    {
        "title": "G. D-Function",
        "description": "Let\nD(n)\nrepresent the sum of digits of\nn\n. For how many integers\nn\nwhere\n10\nl\n≤n<\n10\nr\nsatisfy\nD(k⋅n)=k⋅D(n)\n? Output the answer modulo\n10\n9\n+7\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) – the number of test cases.\nEach test case contains three integers\nl\n,\nr\n, and\nk\n(\n0≤l<r≤\n10\n9\n,\n1≤k≤\n10\n9\n).\nOutput\nFor each test case, output an integer, the answer, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n6\n0 1 4\n0 2 7\n1 2 1\n1 2 3\n582 74663 3\n0 3 1\noutput\nCopy\n2\n3\n90\n12\n974995667\n999\nNote\nFor the first test case, the only values of\nn\nthat satisfy the condition are\n1\nand\n2\n.\nFor the second test case, the only values of\nn\nthat satisfy the condition are\n1\n,\n10\n, and\n11\n.\nFor the third test case, all values of\nn\nbetween\n10\ninclusive and\n100\nexclusive satisfy the condition.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "number theory",
            "*1600"
        ]
    },
    {
        "title": "F. Final Boss",
        "description": "You are facing the final boss in your favorite video game. The boss enemy has\nh\nhealth. Your character has\nn\nattacks. The\ni\n'th attack deals\na\ni\ndamage to the boss but has a cooldown of\nc\ni\nturns, meaning the next time you can use this attack is turn\nx+\nc\ni\nif your current turn is\nx\n. Each turn, you can use all attacks that are not currently on cooldown, all at once. If all attacks are on cooldown, you do nothing for the turn and skip to the next turn.\nInitially, all attacks are not on cooldown. How many turns will you take to beat the boss? The boss is beaten when its health is\n0\nor less.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n)  – the number of test cases.\nThe first line of each test case contains two integers\nh\nand\nn\n(\n1≤h,n≤2⋅\n10\n5\n) – the health of the boss and the number of attacks you have.\nThe following line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,...,\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n5\n) – the damage of your attacks.\nThe following line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,...,\nc\nn\n(\n1≤\nc\ni\n≤2⋅\n10\n5\n) – the cooldown of your attacks.\nIt is guaranteed that the sum of\nh\nand\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer, the minimum number of turns required to beat the boss.\nExample\ninput\nCopy\n8\n3 2\n2 1\n2 1\n5 2\n2 1\n2 1\n50 3\n5 6 7\n5 6 7\n50 3\n2 2 2\n3 3 3\n90000 2\n200000 200000\n1 1\n100000 1\n1\n200000\n6 7\n3 2 3 2 3 1 2\n6 5 9 5 10 7 7\n21 6\n1 1 1 1 1 1\n5 5 8 10 7 6\noutput\nCopy\n1\n3\n15\n25\n1\n19999800001\n1\n21\nNote\nFor the first test case, you can use attacks\n1\nand\n2\non the first turn, dealing\n3\ndamage in total, and slaying the boss.\nFor the second case, you can beat the boss in\n3\nturns by using the following attacks:\nTurn\n1\n: Use attacks\n1\nand\n2\n, dealing\n3\ndamage to the boss. The boss now has\n2\nhealth left.\nTurn\n2\n: Use attack\n2\n, dealing\n1\ndamage to the boss. The boss now has\n1\nhealth left.\nTurn\n3\n: Use attack\n1\n, dealing\n2\ndamage to the boss. The boss now has\n−1\nhealth left. Since its health is less than or equal to\n0\n, you beat the boss.\nFor the sixth test case: remember to use 64-bit integers as the answer can get large.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "*1500"
        ]
    },
    {
        "title": "E. Secret Box",
        "description": "Ntarsis has a box\nB\nwith side lengths\nx\n,\ny\n, and\nz\n. It lies in the 3D coordinate plane, extending from\n(0,0,0)\nto\n(x,y,z)\n.\nNtarsis has a secret box\nS\n. He wants to choose its dimensions such that all side lengths are positive integers, and the volume of\nS\nis\nk\n. He can place\nS\nsomewhere within\nB\nsuch that:\nS\nis parallel to all axes.\nevery corner of\nS\nlies on an integer coordinate.\nS\nis magical, so when placed at an integer location inside\nB\n, it will not fall to the ground.\nAmong all possible ways to choose the dimensions of\nS\n, determine the maximum number of distinct locations he can choose to place his secret box\nS\ninside\nB\n. Ntarsis does not rotate\nS\nonce its side lengths are selected.\nInput\nThe first line consists of an integer\nt\n, the number of test cases (\n1≤t≤2000\n). The description of the test cases follows.\nThe first and only line of each test case contains four integers\nx,y,z\nand\nk\n(\n1≤x,y,z≤2000\n,\n1≤k≤x⋅y⋅z\n).\nIt is guaranteed the sum of all\nx\n, sum of all\ny\n, and sum of all\nz\ndo not exceed\n2000\nover all test cases.\nNote that\nk\nmay not fit in a standard 32-bit integer data type.\nOutput\nFor each test case, output the answer as an integer on a new line. If there is no way to select the dimensions of\nS\nso it fits in\nB\n, output\n0\n.\nExample\ninput\nCopy\n7\n3 3 3 8\n3 3 3 18\n5 1 1 1\n2 2 2 7\n3 4 2 12\n4 3 1 6\n1800 1800 1800 4913000000\noutput\nCopy\n8\n2\n5\n0\n4\n4\n1030301\nNote\nFor the first test case, it is optimal to choose\nS\nwith side lengths\n2\n,\n2\n, and\n2\n, which has a volume of\n2⋅2⋅2=8\n. It can be shown there are\n8\nways to put\nS\ninside\nB\n.\nThe coordinate with the least\nx\n,\ny\n, and\nz\nvalues for each possible arrangement of\nS\nare:\n(0,0,0)\n(1,0,0)\n(0,1,0)\n(0,0,1)\n(1,0,1)\n(1,1,0)\n(0,1,1)\n(1,1,1)\nThe arrangement of\nS\nwith a coordinate of\n(0,0,0)\nis depicted below:\nFor the second test case,\nS\nwith side lengths\n2\n,\n3\n, and\n3\nare optimal.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "math",
            "*1200"
        ]
    },
    {
        "title": "D. Manhattan Circle",
        "description": "Given a\nn\nby\nm\ngrid consisting of '.' and '#' characters, there exists a whole manhattan circle on the grid. The top left corner of the grid has coordinates\n(1,1)\n, and the bottom right corner has coordinates\n(n,m)\n.\nPoint (\na,b\n) belongs to the manhattan circle centered at (\nh,k\n) if\n|h−a|+|k−b|<r\n, where\nr\nis a positive constant.\nOn the grid, the set of points that are part of the manhattan circle is marked as '#'. Find the coordinates of the center of the circle.\nInput\nThe first line contains\nt\n(\n1≤t≤1000\n)  — the number of test cases.\nThe first line of each test case contains\nn\nand\nm\n(\n1≤n⋅m≤2⋅\n10\n5\n) — the height and width of the grid, respectively.\nThe next\nn\nlines contains\nm\ncharacters '.' or '#'. If the character is '#', then the point is part of the manhattan circle.\nIt is guaranteed the sum of\nn⋅m\nover all test cases does not exceed\n2⋅\n10\n5\n, and there is a whole manhattan circle on the grid.\nOutput\nFor each test case, output the two integers, the coordinates of the center of the circle.\nExample\ninput\nCopy\n6\n5 5\n.....\n.....\n..#..\n.....\n.....\n5 5\n..#..\n.###.\n#####\n.###.\n..#..\n5 6\n......\n......\n.#....\n###...\n.#....\n1 1\n#\n5 6\n...#..\n..###.\n.#####\n..###.\n...#..\n2 10\n..........\n...#......\noutput\nCopy\n3 3\n3 3\n4 2\n1 1\n3 4\n2 4",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*900"
        ]
    },
    {
        "title": "C. Good Prefixes",
        "description": "Alex thinks some array is good if there exists some element that can be represented as the sum of all other elements (the sum of all other elements is\n0\nif there are no other elements). For example, the array\n[1,6,3,2]\nis good since\n1+3+2=6\n. Furthermore, the array\n[0]\nis also good. However, the arrays\n[1,2,3,4]\nand\n[1]\nare not good.\nAlex has an array\na\n1\n,\na\n2\n,…,\na\nn\n. Help him count the number of good non-empty prefixes of the array\na\n. In other words, count the number of integers\ni\n(\n1≤i≤n\n) such that the length\ni\nprefix (i.e.\na\n1\n,\na\n2\n,…,\na\ni\n) is good.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of elements in the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of good non-empty prefixes of the array\na\n.\nExample\ninput\nCopy\n7\n1\n0\n1\n1\n4\n1 1 2 0\n5\n0 1 2 1 4\n7\n1 1 0 3 5 2 12\n7\n1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 294967296\n10\n0 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 589934592\noutput\nCopy\n1\n0\n3\n3\n4\n1\n2\nNote\nIn the fourth test case, the array has five prefixes:\nprefix\n[0]\nis a good array, as mentioned in the statement;\nprefix\n[0,1]\nis not a good array, since\n0≠1\n;\nprefix\n[0,1,2]\nis not a good array, since\n0≠1+2\n,\n1≠0+2\nand\n2≠0+1\n;\nprefix\n[0,1,2,1]\nis a good array, since\n2=0+1+1\n;\nprefix\n[0,1,2,1,4]\nis a good array, since\n4=0+1+2+1\n.\nAs you can see, three of them are good, so the answer is\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ]
    },
    {
        "title": "B. Maximum Multiple Sum",
        "description": "Given an integer\nn\n, find an integer\nx\nsuch that:\n2≤x≤n\n.\nThe sum of multiples of\nx\nthat are less than or equal to\nn\nis maximized. Formally,\nx+2x+3x+⋯+kx\nwhere\nkx≤n\nis maximized over all possible values of\nx\n.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n) — the number of test cases.\nEach test case contains a single integer\nn\n(\n2≤n≤100\n).\nOutput\nFor each test case, output an integer, the optimal value of\nx\n. It can be shown there is only one unique answer.\nExample\ninput\nCopy\n2\n3\n15\noutput\nCopy\n3\n2\nNote\nFor\nn=3\n, the possible values of\nx\nare\n2\nand\n3\n. The sum of all multiples of\n2\nless than or equal to\nn\nis just\n2\n, and the sum of all multiples of\n3\nless than or equal to\nn\nis\n3\n. Therefore,\n3\nis the optimal value of\nx\n.\nFor\nn=15\n, the optimal value of\nx\nis\n2\n. The sum of all multiples of\n2\nless than or equal to\nn\nis\n2+4+6+8+10+12+14=56\n, which can be proven to be the maximal over all other possible values of\nx\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "A. Creating Words",
        "description": "Matthew is given two strings\na\nand\nb\n, both of length\n3\n. He thinks it's particularly funny to create two new words by swapping the first character of\na\nwith the first character of\nb\n. He wants you to output\na\nand\nb\nafter the swap.\nNote that the new words may not necessarily be different.\nInput\nThe first line contains\nt\n(\n1≤t≤100\n)  — the number of test cases.\nThe first and only line of each test case contains two space-separated strings,\na\nand\nb\n, both of length\n3\n. The strings only contain lowercase Latin letters.\nOutput\nFor each test case, after the swap, output\na\nand\nb\n, separated by a space.\nExample\ninput\nCopy\n6\nbit set\ncat dog\nhot dog\nuwu owo\ncat cat\nzzz zzz\noutput\nCopy\nsit bet\ndat cog\ndot hog\nowu uwo\ncat cat\nzzz zzz",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "H. Tower Capturing",
        "description": "There are\nn\ntowers at\nn\ndistinct points\n(\nx\n1\n,\ny\n1\n),(\nx\n2\n,\ny\n2\n),…,(\nx\nn\n,\ny\nn\n)\n, such that no three are collinear and no four are concyclic. Initially, you own towers\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\n, and you want to capture all of them. To do this, you can do the following operation any number of times:\nPick two towers\nP\nand\nQ\nyou own and one tower\nR\nyou don't own, such that the circle through\nP\n,\nQ\n, and\nR\ncontains all\nn\ntowers inside of it.\nAfterwards, capture all towers in or on triangle\n△PQR\n, including\nR\nitself.\nAn attack plan is a series of choices of\nR\n(\nR\n1\n,\nR\n2\n,…,\nR\nk\n) using the above operations after which you capture all towers. Note that two attack plans are considered different only if they differ in their choice of\nR\nin some operation; in particular, two attack plans using the same choices of\nR\nbut different choices of\nP\nand\nQ\nare considered the same.\nCount the number of attack plans of minimal length. Note that it might not be possible to capture all towers, in which case the answer is\n0\n.\nSince the answer may be large, output it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤250\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n4≤n≤100\n) — the number of towers.\nThe\ni\n-th of the next\nn\nlines contains two integers\nx\ni\nand\ny\ni\n(\n−\n10\n4\n≤\nx\ni\n,\ny\ni\n≤\n10\n4\n) — the location of the\ni\n-th tower. Initially, you own towers\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\n.\nAll towers are at distinct locations, no three towers are collinear, and no four towers are concyclic.\nThe sum of\nn\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, output a single integer — the number of attack plans of minimal length after which you capture all towers, modulo\n998244353\n.\nExample\ninput\nCopy\n3\n5\n1 1\n2 5\n3 3\n4 2\n5 4\n6\n1 1\n3 3\n1 2\n2 1\n3 10000\n19 84\n7\n2 7\n-4 -3\n-3 6\n3 1\n-5 2\n1 -4\n-1 7\noutput\nCopy\n1\n0\n10\nNote\nIn the first test case, there is only one possible attack plan of shortest length, shown below.\nUse the operation with\nP=\ntower\n1\n,\nQ=\ntower\n2\n, and\nR=\ntower\n5\n. The circle through these three towers contains all towers inside of it, and as a result towers\n3\nand\n5\nare captured.\nUse the operation with\nP=\ntower\n5\n,\nQ=\ntower\n1\n, and\nR=\ntower\n4\n. The circle through these three towers contains all towers inside of it, and as a result tower\n4\nis captured.\nIn the second case, for example, you can never capture the tower at\n(3,10000)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "geometry",
            "*3300"
        ]
    },
    {
        "title": "G. Magic Trick II",
        "description": "The secret behind Oscar's first magic trick has been revealed! Because he still wants to impress Lura, he comes up with a new idea: he still wants to sort a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\n.\nThis time, he chooses an integer\nk\n. He wants to sort the permutation in non-decreasing order using the following operation several times:\nPick a continuous subarray of length\nk\nand remove it from\np\n.\nInsert the continuous subarray back into\np\nat any position (perhaps, in the very front or the very back).\nTo be as impressive as possible, Oscar would like to choose the maximal value of\nk\nsuch that he can sort his permutation. Please help him find the maximal\nk\nas well as a sequence of operations that will sort the permutation. You don't need to minimize the number of operations, but you are allowed to use at most\n5\nn\n2\noperations.\nWe have a proof that, for the maximal\nk\nsuch that you can sort the permutation in any number of operations, you can also sort it in at most\n5\nn\n2\noperations.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n5≤n≤\n10\n3\n) — the length of the permutation.\nThe second line of each test case contains a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\n.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n3\n.\nOutput\nFor each test case, first output the chosen value of\nk\non a new line (\n1≤k≤n\n).\nThen, output a single integer\nm\n — the number of operations used (\n0≤m≤5\nn\n2\n).\nThen, on each of the next\nm\nlines, output the operations denoted by two integers\ni\nand\nj\n(\n1≤i,j≤n−k+1\n), representing an operation where you remove the subarray starting from index\ni\nand replace it back into\np\nat index\nj\n.\nExample\ninput\nCopy\n3\n5\n5 1 2 3 4\n5\n2 3 5 4 1\n6\n1 2 3 4 5 6\noutput\nCopy\n4\n1\n2 1\n3\n2\n1 3\n2 1\n6\n0\nNote\nIn the first test case, it is enough to move the last four numbers to the front.\nIn the second test case, it can be shown that we cannot have\nk=4\nor\nk=5\n. With\nk=3\n, we can move the first three numbers to the end, and then the middle three to the front to sort the permutation.\nIn the third test case, the permutation is already sorted. We can have\nk=6\nand use no operations.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "sortings",
            "*3200"
        ]
    },
    {
        "title": "F. Reconstruction",
        "description": "There is a hidden array\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\nwhose elements are integers between\n−m\nand\nm\n, inclusive.\nYou are given an array\nb\n1\n,\nb\n2\n,…,\nb\nn\nof length\nn\nand a string\ns\nof length\nn\nconsisting of the characters\nP\n,\nS\n, and\n?\n.\nFor each\ni\nfrom\n1\nto\nn\ninclusive, we must have:\nIf\ns\ni\n=P\n,\nb\ni\nis the sum of\na\n1\nthrough\na\ni\n.\nIf\ns\ni\n=S\n,\nb\ni\nis the sum of\na\ni\nthrough\na\nn\n.\nOutput the number of ways to replace all\n?\nin\ns\nwith either\nP\nor\nS\nsuch that there exists an array\na\n1\n,\na\n2\n,…,\na\nn\nwith elements not exceeding\nm\nby absolute value satisfying the constraints given by the array\nb\n1\n,\nb\n2\n,…,\nb\nn\nand the string\ns\n.\nSince the answer may be large, output it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤2⋅\n10\n3\n,\n2≤m≤\n10\n9\n) — the length of the hidden array\na\n1\n,\na\n2\n,…,\na\nn\nand the maximum absolute value of an element\na\ni\n.\nThe second line of each test case contains a string\ns\nof length\nn\nconsisting of characters\nP\n,\nS\n, and\n?\n.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n|\nb\ni\n|≤m⋅n\n).\nThe sum of\nn\nover all test cases does not exceed\n5⋅\n10\n3\n.\nOutput\nFor each test case, output a single integer — the number of ways to replace all\n?\nin\ns\nwith either\nP\nor\nS\nthat result in the existence of a valid array\na\n1\n,\na\n2\n,…,\na\nn\n, modulo\n998244353\n.\nExample\ninput\nCopy\n6\n4 10\nPSPP\n1 9 8 10\n4 1000000000\n????\n1 1 1 4000000000\n8 1000000000\n?P?SSP?P\n-857095623 -1424391899 -851974476 673437144 471253851 -543483033 364945701 -178537332\n4 7\nPPSS\n4 2 1 3\n9 20\n?????????\n1 2 3 4 5 6 7 8 9\n3 1000000000\nP??\n-145463248 -974068460 -1287458396\noutput\nCopy\n1\n0\n2\n1\n14\n1\nNote\nIn the first test case, we can see that the following array satisfies all constraints, thus the answer is\n1\n:\nP\n —\n[1,3,4,2]\n: sum of\n1\n.\nS\n —\n[1,3,4,2]\n: sum of\n9\n.\nP\n —\n[1,3,4,2]\n: sum of\n8\n.\nP\n —\n[1,3,4,2]\n: sum of\n10\n.\nIn the second test case, it can be shown that no array\na\nwith all\n|\na\ni\n|≤m=\n10\n9\nsatisfies all constraints.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "math",
            "*2500"
        ]
    },
    {
        "title": "E. Shuffle",
        "description": "Two hungry red pandas, Oscar and Lura, have a tree\nT\nwith\nn\nnodes. They are willing to perform the following shuffle procedure on the whole tree\nT\nexactly once. With this shuffle procedure, they will create a new tree out of the nodes of the old tree.\nChoose any node\nV\nfrom the original tree\nT\n. Create a new tree\nT\n2\n, with\nV\nas the root.\nRemove\nV\nfrom\nT\n, such that the original tree is split into one or more subtrees (or zero subtrees, if\nV\nis the only node in\nT\n).\nShuffle each subtree with the same procedure (again choosing any node as the root), then connect all shuffled subtrees' roots back to\nV\nto finish constructing\nT\n2\n.\nAfter this, Oscar and Lura are left with a new tree\nT\n2\n. They can only eat leaves and are very hungry, so please find the maximum number of leaves over all trees that can be created in exactly one shuffle.\nNote that leaves are all nodes with degree\n1\n. Thus, the root may be considered as a leaf if it has only one child.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of every test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of nodes within the original tree\nT\n.\nThe next\nn−1\nlines each contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n) — an edge within the original tree\nT\n. The given edges form a tree.\nThe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum number of leaves achievable with exactly one shuffle procedure on the whole tree.\nExample\ninput\nCopy\n4\n5\n1 2\n1 3\n2 4\n2 5\n5\n1 2\n2 3\n3 4\n4 5\n6\n1 2\n1 3\n1 4\n1 5\n1 6\n10\n9 3\n8 1\n10 6\n8 5\n7 8\n4 6\n1 3\n10 1\n2 7\noutput\nCopy\n4\n3\n5\n6\nNote\nIn the first test case, it can be shown that the maximum number of leaves is\n4\n. To accomplish this, we can start our shuffle with selecting node\n3\nas the new root.\nNext, we are left only with one subtree, in which we can select node\n2\nto be the new root of that subtree.\nThis will force all\n3\nremaining nodes to be leaves, and once we connect them back to our new root, the shuffled subtree looks like this:\nWe connect the shuffled subtree back to our new root of our new tree. Our final tree has four leaves (including the root), and looks like this:\nIn our second test case, we have a line of five nodes. It can be shown that the maximum number of leaves after one shuffle is\n3\n. We can start off with node\n2\n, which forces node\n1\nto become a leaf. Then, if we select node\n4\non the right side, we will also have nodes\n3\nand\n5\nas leaves.\nThe third test case is a star graph with six nodes. The number of leaves cannot increase, thus our answer will be\n5\n(if we start the shuffling with the original root node).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "D. \"a\" String Problem",
        "description": "You are given a string\ns\nconsisting of lowercase Latin characters. Count the number of nonempty strings\nt≠\n\"\na\n\" such that it is possible to partition\n†\n†\ns\ninto some substrings satisfying the following conditions:\neach substring either equals\nt\nor \"\na\n\", and\nat least one substring equals\nt\n.\n†\n†\nA partition of a string\ns\nis an ordered sequence of some\nk\nstrings\nt\n1\n,\nt\n2\n,…,\nt\nk\n(called substrings) such that\nt\n1\n+\nt\n2\n+…+\nt\nk\n=s\n, where\n+\nrepresents the concatenation operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a string\ns\nconsisting of lowercase Latin characters (\n2≤|s|≤2⋅\n10\n5\n).\nThe sum of\n|s|\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of nonempty strings\nt≠\n\"\na\n\" that satisfy all constraints.\nExample\ninput\nCopy\n8\naaaaa\nbaba\ncabacb\naaabaaa\nbitset\nab\nabbaaaabbb\nyearnineteeneightyfour\noutput\nCopy\n4\n4\n1\n16\n1\n2\n3\n1\nNote\nIn the first test case,\nt\ncan be \"\naa\n\", \"\naaa\n\", \"\naaaa\n\", or the full string.\nIn the second test case,\nt\ncan be \"\nb\n\", \"\nbab\n\", \"\nba\n\", or the full string.\nIn the third test case, the only such\nt\nis the full string.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "hashing",
            "implementation",
            "math",
            "string suffix structures",
            "strings",
            "*2000"
        ]
    },
    {
        "title": "C2. Magnitude (Hard Version)",
        "description": "The two versions of the problem are different. You may want to read both versions. You can make hacks only if both versions are solved.\nYou are given an array\na\nof length\nn\n. Start with\nc=0\n. Then, for each\ni\nfrom\n1\nto\nn\n(in increasing order) do exactly one of the following:\nOption\n1\n: set\nc\nto\nc+\na\ni\n.\nOption\n2\n: set\nc\nto\n|c+\na\ni\n|\n, where\n|x|\nis the absolute value of\nx\n.\nLet the maximum final value of\nc\nafter the procedure described above be equal to\nk\n. Find the number of unique procedures that result in\nc=k\n. Two procedures are different if at any index\ni\n, one procedure chose option\n1\nand another chose option\n2\n, even if the value of\nc\nis equal for both procedures after that turn.\nSince the answer may be large, output it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nThe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of unique procedures that result in\nc=k\n, modulo\n998244353\n.\nExample\ninput\nCopy\n5\n4\n2 -5 3 -3\n8\n1 4 3 4 1 4 3 4\n3\n-1 -2 -3\n4\n-1000000000 1000000000 1000000000 1000000000\n4\n1 9 8 4\noutput\nCopy\n12\n256\n1\n8\n16\nNote\nIn the first test case, it can be shown that our maximal final value of\nc\nis\n3\n. There are\n12\nways to achieve this because in order to get\n3\n, we have to take absolute value at indices\n2\nor\n4\n, or both, resulting in\n3\nways. For the other two indices, it doesn't change the value whether we take absolute value or not, so we have\n2⋅2=4\nways for them. In total, we have\n3⋅4=12\nways.\nIn the second test case, taking the absolute value will never change anything, so we can either take absolute value or not, for every index. This gives us\n2\n8\n=256\npossible ways.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "greedy",
            "math",
            "*1700"
        ]
    },
    {
        "title": "C1. Magnitude (Easy Version)",
        "description": "The two versions of the problem are different. You may want to read both versions. You can make hacks only if both versions are solved.\nYou are given an array\na\nof length\nn\n. Start with\nc=0\n. Then, for each\ni\nfrom\n1\nto\nn\n(in increasing order) do exactly one of the following:\nOption\n1\n: set\nc\nto\nc+\na\ni\n.\nOption\n2\n: set\nc\nto\n|c+\na\ni\n|\n, where\n|x|\nis the absolute value of\nx\n.\nLet the maximum final value of\nc\nafter the procedure described above be equal to\nk\n. Find\nk\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line of each case contains\nn\nintegers\na\n1\n,\na\n2\n,\na\n3\n,\n…\n,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nThe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the value of\nk\n.\nExample\ninput\nCopy\n5\n4\n10 -9 -3 4\n8\n1 4 3 4 1 4 3 4\n3\n-1 -2 -3\n4\n-1000000000 1000000000 1000000000 1000000000\n4\n1 9 8 4\noutput\nCopy\n6\n24\n6\n4000000000\n22\nNote\nIn the first test case, if we set\nc\nto its absolute value every time we add to it, we end up with\n6\n. It can be shown that this is the maximum result.\nIn the second test case, taking the absolute value will never change anything, so we can just sum the array without doing anything to get\n24\n.\nIn the third test case, it is optimal to wait until the end to set\nc\nto its absolute value, resulting in an answer of\n6\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. Large Addition",
        "description": "A digit is large if it is between\n5\nand\n9\n, inclusive. A positive integer is large if all of its digits are large.\nYou are given an integer\nx\n. Can it be the sum of two large positive integers with the same number of digits?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a single integer\nx\n(\n10≤x≤\n10\n18\n).\nOutput\nFor each test case, output\nYES\nif\nx\nsatisfies the condition, and\nNO\notherwise.\nYou can output\nYES\nand\nNO\nin any case (for example, strings\nyES\n,\nyes\n, and\nYes\nwill be recognized as a positive response).\nExample\ninput\nCopy\n11\n1337\n200\n1393938\n1434\n98765432123456789\n11111111111111111\n420\n1984\n10\n69\n119\noutput\nCopy\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nNO\nNote\nIn the first test case, we can have\n658+679=1337\n.\nIn the second test case, it can be shown that no numbers of equal length and only consisting of large digits can add to\n200\n.\nIn the third test case, we can have\n696969+696969=1393938\n.\nIn the fourth test case, we can have\n777+657=1434\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Strange Splitting",
        "description": "Define the range of a non-empty array to be the maximum value minus the minimum value. For example, the range of\n[1,4,2]\nis\n4−1=3\n.\nYou are given an array\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn≥3\n. It is guaranteed\na\nis sorted.\nYou have to color each element of\na\nred or blue so that:\nthe range of the red elements does not equal the range of the blue elements, and\nthere is at least one element of each color.\nIf there does not exist any such coloring, you should report it. If there are multiple valid colorings, you can print any of them.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n3≤n≤50\n) — the length of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n). It is guaranteed\na\n1\n≤\na\n2\n≤…≤\na\nn−1\n≤\na\nn\n.\nOutput\nFor each test case, if it is impossible to color\na\nto satisfy all the constraints, output\nNO\n.\nOtherwise, first output\nYES\n.\nThen, output a string\ns\nof length\nn\n. For\n1≤i≤n\n, if you color\na\ni\nred,\ns\ni\nshould be\nR\n. For\n1≤i≤n\n, if you color\na\ni\nblue,\ns\ni\nshould be\nB\n.\nExample\ninput\nCopy\n7\n4\n1 1 2 2\n5\n1 2 3 4 5\n3\n3 3 3\n4\n1 2 2 2\n3\n1 2 2\n3\n1 1 2\n3\n1 9 84\noutput\nCopy\nYES\nRBRR\nYES\nBBRBB\nNO\nYES\nRBBR\nYES\nRRB\nYES\nBRR\nYES\nBRB\nNote\nIn the first test case, given the array\n[1,1,2,2]\n, we can color the second element blue and the remaining elements red; then the range of the red elements\n[1,2,2]\nis\n2−1=1\n, and the range of the blue elements\n[1]\nis\n1−1=0\n.\nIn the second test case, we can color the first, second, fourth and fifth elements\n[1,2,4,5]\nblue and the remaining elements\n[3]\nred.\nThe range of the red elements is\n3−3=0\nand the range of the blue elements is\n5−1=4\n, which are different.\nIn the third test case, it can be shown there is no way to color\na=[3,3,3]\nto satisfy the constraints.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*800"
        ]
    },
    {
        "title": "G. Your Loss",
        "description": "You are given a tree with\nn\nnodes numbered from\n1\nto\nn\n, along with an array of size\nn\n. The value of\ni\n-th node is\na\ni\n. There are\nq\nqueries. In each query, you are given 2 nodes numbered as\nx\nand\ny\n.\nConsider the path from the node numbered as\nx\nto the node numbered as\ny\n. Let the path be represented by\nx=\np\n0\n,\np\n1\n,\np\n2\n,…,\np\nr\n=y\n, where\np\ni\nare the intermediate nodes. Compute the sum of\na\np\ni\n⊕i\nfor each\ni\nsuch that\n0≤i≤r\nwhere\n⊕\nis the XOR operator.\nMore formally, compute\n∑\ni=0\nr\na\np\ni\n⊕i\nr\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Each test case contains several sets of input data.\nThe first line of each set of input data contains a single integer\nn\n(\n1≤n≤5⋅\n10\n5\n) — the number of nodes.\nThe next\nn−1\nlines of each set of input data contain\n2\nintegers,\nu\nand\nv\nrepresenting an edge between the node numbered\nu\nand the node numbered\nv\n. It is guaranteed that\nu≠v\nand that the edges form a tree.\nThe next line of each set of input data contains\nn\nintegers,\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤5⋅\n10\n5\n) — values of the nodes.\nThe next line contains a single integer\nq\n(\n1≤q≤\n10\n5\n) — the number of queries.\nThe next\nq\nlines describe the queries. The\ni\n-th query contains\n2\nintegers\nx\nand\ny\n(\n1≤x,y≤n\n) denoting the starting and the ending node of the path.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\nand sum of\nq\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each query, output a single number — the sum from the problem statement.\nExample\ninput\nCopy\n1\n4\n1 2\n2 3\n3 4\n2 3 6 5\n3\n1 4\n3 4\n1 1\noutput\nCopy\n14\n10\n2",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "trees",
            "*3000"
        ]
    },
    {
        "title": "F. array-value",
        "description": "You have an array of non-negative integers\na\n1\n,\na\n2\n,…,\na\nn\n.\nThe value of a sub-array of length\n≥2\n,\na[l,r]=[\na\nl\n,\na\nl+1\n,…,\na\nr\n]\nis the minimum value of\na\ni\n⊕\na\nj\nsuch that\nl≤i<j≤r\n, where\n⊕\nis the xor (exclusive-or) operator.\nYou have to find the\nk\n-th smallest value over all sub-arrays of length\n≥2\n.\nInput\nThe first line of the input contains multiple test cases\nt\n(\n1≤t≤2⋅\n10\n4\n).\nThe first line of each test case contains integer numbers\nn\nand\nk\n(\n2≤n≤\n10\n5\n,\n1≤k≤\nn⋅(n−1)\n2\n).\nThe second line of the input contains\nn\nnon-negative integer numbers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the array itself.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nPrint the\nk\n-th smallest value obtained over all subarrays of length at least\n2\n.\nExample\ninput\nCopy\n4\n5 2\n1 2 3 4 5\n2 1\n4 3\n4 6\n1 2 4 8\n5 9\n1 2 3 4 5\noutput\nCopy\n1\n7\n12\n3\nNote\nIn the first testcase, we have subarrays with their smallest exclusive-or pair as:\n[1,2]:3\n[2,3]:1\n[3,4]:7\n[4,5]:1\n[1,2,3]:1\n[2,3,4]:1\n[3,4,5]:1\n[1,2,3,4]:1\n[2,3,4,5]:1\n[1,2,3,4,5]:1\nThe sorted order would be:\n1,1,1,1,1,1,1,1,3,7\n. Therefore, the second smallest element would be\n1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "data structures",
            "greedy",
            "two pointers",
            "*2500"
        ]
    },
    {
        "title": "E. I Love Balls",
        "description": "Alice and Bob are playing a game. There are\nn\nballs, out of which\nk\nare special. Each ball has a value associated with it.\nThe players play turn by turn. In each turn, the player randomly picks a ball and adds the value of the ball to their score, which is\n0\nat the beginning of the game. The selected ball is removed from the game. If the ball was special, the same player takes the next turn if at least one ball is remaining. If the ball picked was not special, the next player plays their turn.\nThey play this game until no balls are remaining in the game. Alice plays first.\nFind the expected score that both the players have at the end of the game modulo\n10\n9\n+7\n.\nFormally, let\nM=\n10\n9\n+7\n. It can be shown that the answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅\nq\n−1\nmodM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nThere are multiple test cases. The first line of the input contains an integer\nt\n, the number of test cases (\n1≤t≤2⋅\n10\n5\n).\nEach test case description is on a new line. The first line of the test case contains two integers\nn\nand\nk\nin the respective order separated by a space (\n1≤k≤n≤4⋅\n10\n5\n).\nThe second line of the test case contains\nn\nintegers:\nv\n1\n,\nv\n2\n,…,\nv\nn\n, the value for each ball separated by spaces. The first\nk\nballs are special (\n1≤\nv\ni\n≤\n10\n7\n).\nThe sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nOutput two integers per test case in a new line, the expected score of Alice and the expected score of Bob modulo\n10\n9\n+7\n.\nExamples\ninput\nCopy\n1\n5 2\n10 20 5 15 25\noutput\nCopy\n45 30\ninput\nCopy\n5\n1 1\n732507\n2 2\n5817860 5398510\n5 1\n2122894 4951549 2750585 7821535 3214167\n8 4\n1405323 5069867 6883092 6972029 328406 2478975 7628890 9973340\n4 2\n9662050 3566134 3996473 9872255\noutput\nCopy\n732507 0\n11216370 0\n810642660 210218077\n722402997 318336932\n349086489 678010430\ninput\nCopy\n5\n3 3\n1095611 8219204 7773462\n2 1\n8176490 2774103\n3 1\n9178636 5138057 3367761\n12 9\n7597698 6843019 2298534 1522386 4969588 1340345 3967362 9152890 6689668 9986080 4745473 7407325\n10 5\n6986368 2397882 5804127 6980694 3740836 3215836 5195724 3179261 4136769 4544231\noutput\nCopy\n17088277 0\n6862348 4088245\n677038671 340645790\n36949997 29570371\n725118051 321063684\nNote\nIn the first test case, Alice's expected score is\n45\n, and Bob's is\n30\nat the end of the game.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "probabilities",
            "*2300"
        ]
    },
    {
        "title": "D. Swap Dilemma",
        "description": "Given two arrays of distinct positive integers\na\nand\nb\nof length\nn\n, we would like to make both the arrays the same. Two arrays\nx\nand\ny\nof length\nk\nare said to be the same when for all\n1≤i≤k\n,\nx\ni\n=\ny\ni\n.\nNow in one move, you can choose some index\nl\nand\nr\nin\na\n(\nl≤r\n) and swap\na\nl\nand\na\nr\n, then choose some\np\nand\nq\n(\np≤q\n) in\nb\nsuch that\nr−l=q−p\nand swap\nb\np\nand\nb\nq\n.\nIs it possible to make both arrays the same?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the arrays\na\nand\nb\n.\nThe second line of each test case contains\nn\ndistinct integers\na\n1\n,\na\n2\n,\na\n3\n,…,\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n5\n) — the integers in the array\na\n.\nThe third line of each test case contains\nn\ndistinct integers\nb\n1\n,\nb\n2\n,\nb\n3\n,…,\nb\nn\n(\n1≤\nb\ni\n≤2⋅\n10\n5\n) — the integers in the array\nb\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each testcase, print \"YES\" if the arrays\na\nand\nb\ncan be made the same. Otherwise, print \"NO\". can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n6\n4\n1 2 3 4\n1 2 3 4\n5\n1 3 4 2 5\n7 1 2 5 4\n4\n1 2 3 4\n4 3 2 1\n3\n1 2 3\n1 3 2\n5\n1 5 7 1000 4\n4 1 7 5 1000\n3\n1 4 2\n1 3 2\noutput\nCopy\nYES\nNO\nYES\nNO\nNO\nNO\nNote\nIn the first testcase, you don't need to perform any operations since the arrays are same.\nIn the second testcase, it can be proven there exists no way to make the arrays same.\nIn the third testcase, one of the ways to make the arrays same is to first choose\nl=1\n,\nr=3\n,\np=1\n,\nq=3\nthen choose\nl=1\n,\nr=2\n,\np=3\n,\nq=4\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "divide and conquer",
            "greedy",
            "math",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "C. Have Your Cake and Eat It Too",
        "description": "Alice, Bob and Charlie want to share a rectangular cake cut into\nn\npieces. Each person considers every piece to be worth a different value. The\ni\n-th piece is considered to be of value\nai\nby Alice,\nbi\nby Bob and\nci\nby Charlie.\nThe sum over all\nai\n, all\nbi\nand all\nci\nindividually is the same, equal to\ntot\n.\nGiven the values of each piece of the cake for each person, you need to give each person a contiguous slice of cake. In other words, the indices at the left and right ends of these subarrays (the slices given to each person) can be represented as\n(la,ra)\n,\n(lb,rb)\nand\n(lc,rc)\nrespectively for Alice, Bob and Charlie. The division needs to satisfy the following constraints:\nNo piece is assigned to more than one person, i.e., no two subarrays among\n[la,…,ra]\n,\n[lb,…,rb]\nand\n[lc,…,rc]\nintersect.\n∑\nra\ni=la\nai,∑\nrb\ni=lb\nbi,∑\nrc\ni=lc\nci≥⌈\ntot\n3\n⌉\n.\nHere, the notation\n⌈\na\nb\n⌉\nrepresents ceiling division. It is defined as the smallest integer greater than or equal to the exact division of\na\nby\nb\n. In other words, it rounds up the division result to the nearest integer. For instance\n⌈\n10\n3\n⌉=4\nand\n⌈\n15\n3\n⌉=5\n.\nInput\nThe first line contains an integer\nt\n, the number of testcases, (\n1≤t≤104\n)\nFor each testcase:\nThe first line contains the integer\nn\n(\n3≤n≤2⋅105\n).\nThe following three lines contain\nn\nintegers each:\nOne line with\nn\nintegers\na1,a2,…,an\nrepresents the values for Alice (\n1≤ai≤106\n).\nThe next line with\nn\nintegers\nb1,b2,…,bn\nrepresents the values for Bob (\n1≤bi≤106\n).\nThe next line with\nn\nintegers\nc1,c2,…,cn\nrepresents the values for Charlie (\n1≤ci≤106\n).\nIt is guaranteed that\n∑\nn\ni=1\nai=∑\nn\ni=1\nbi=∑\nn\ni=1\nci\n.\nThe sum of\nn\nover all testcases does not exceed\n2⋅105\n.\nOutput\nFor each testcase, output\n−1\nif the required condition is impossible.\nOtherwise, output six numbers –\nla,ra,lb,rb,lc,rc\n, the respective starting and ending indices (\n1\n-indexed) of the subarrays for Alice, Bob and Charlie, respectively.\nExample\ninput\nCopy\n10\n5\n5 1 1 1 1\n1 1 5 1 1\n1 1 1 1 5\n6\n1 2 3 4 5 6\n5 6 1 2 3 4\n3 4 5 6 1 2\n4\n4 4 4 4\n4 4 4 4\n4 4 4 4\n5\n5 10 5 2 10\n9 6 9 7 1\n10 7 10 2 3\n3\n4 5 2\n6 1 4\n1 8 2\n3\n10 4 10\n8 7 9\n10 4 10\n7\n57113 65383 19795 53580 74452 3879 23255\n12917 16782 89147 93107 27365 15044 43095\n33518 63581 33565 34112 46774 44151 41756\n6\n6 3 1 8 7 1\n10 2 6 2 2 4\n10 9 2 1 2 2\n5\n5 5 4 5 5\n1 6 3 8 6\n2 4 1 9 8\n10\n1 1 1 1 1001 1 1 1001 1 1\n1 1 1 1 1 1 2001 1 1 1\n1 1 1 1 1 1001 1 1 1 1001\noutput\nCopy\n1 1 2 3 4 5 \n5 6 1 2 3 4 \n-1\n-1\n1 1 3 3 2 2 \n-1\n1 2 3 4 5 7 \n3 6 1 1 2 2 \n1 2 3 4 5 5 \n1 5 6 7 8 10 \nNote\nIn the first testcase, the sum of either of the three arrays is\n9\n. Each person needs a cake slice corresponding to a subarray with a total value of at least\n⌈\n9\n3\n⌉=3\n.\nIf we assign the subarray (\n1\n,\n1\n) to Alice, its total value to her is\n5\n, which is\n≥3\n; the subarray (\n2\n,\n3\n) to Bob, its total value to him is\n1+5=6\n, which is\n≥3\n; and the subarray (\n4\n,\n5\n) to Charlie, its total value to him\n1+5=6\n, which is also\n≥3\n. Each person gets their own separate pieces of the cake, and no piece is common to two or more people.\nIt can be shown that for the third test case, it is not possible to give slices of the cake in a way that satisfies the given constraints.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "implementation",
            "*1400"
        ]
    },
    {
        "title": "B. Corner Twist",
        "description": "You are given two grids of numbers\na\nand\nb\n, with\nn\nrows and\nm\ncolumns. All the values in the grid are\n0\n,\n1\nor\n2\n.\nYou can perform the following operation on\na\nany number of times:\nPick any subrectangle in the grid with length and width\n≥2\n. You are allowed to choose the entire grid as a subrectangle.\nThe subrectangle has four corners. Take any pair of diagonally opposite corners of the chosen subrectangle and add\n1\nto their values modulo\n3\n.\nFor the pair of corners not picked, add\n2\nto their values modulo\n3\n.\nNote that the operation only changes the values of the corners of the picked subrectangle.\nIs it possible to convert the grid\na\ninto grid\nb\nby applying the above operation any number of times (possibly zero)?\nInput\nThe first line contains an integer\nt\n, the number of testcases (\n1≤t≤250\n).\nFor each testcase:\nThe first line contains two integers\nn\nand\nm\n, the number of rows and columns in the grid (\n2≤n,m≤500\n).\nEach of the next n lines contain m characters — the\nj\n-th character of the\ni\n-th line represents\na\ni,j\n.\nEach of the next n lines contain m characters — the\nj\n-th character of the\ni\n-th line represents\nb\ni,j\n(\n0≤\na\ni,j\n,\nb\ni,j\n≤2\n).\nIt is guaranteed that the sum of\nn\nover all test cases and the sum of\nm\nover all test cases do not exceed\n500\n.\nOutput\nFor each test case print \"YES\" (without quotes) if it is possible to convert grid\na\ninto grid\nb\nand \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n7\n3 3\n000\n000\n000\n111\n111\n111\n4 4\n0000\n0000\n0000\n0000\n2100\n1200\n0012\n0021\n4 4\n1020\n1200\n1210\n0000\n0000\n1200\n2200\n0000\n3 3\n012\n012\n012\n010\n111\n011\n8 8\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n00000000\n10000000\n00000000\n01200000\n02010000\n00102000\n00020100\n00001020\n00000210\n10000000\n2 7\n0000000\n0000000\n2220111\n0111222\n2 7\n0000000\n0100010\n2220111\n1210202\noutput\nCopy\nYES\nYES\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first testcase, grid\na\ncan be converted into\nb\nin the following manner:\n0\n0\n0\n0\n0\n0\n0\n0\n0\n⇒\n1\n0\n2\n0\n0\n0\n2\n0\n1\n⇒\n1\n0\n2\n0\n1\n2\n2\n2\n2\n⇒\n1\n1\n1\n0\n0\n0\n2\n2\n2\n⇒\n1\n1\n1\n1\n0\n2\n1\n2\n0\n⇒\n1\n1\n1\n1\n1\n1\n1\n1\n1\nHere, in each operation, the top-right and bottom-left corners highlighted by a box are incremented by\n2\nmodulo\n3\n, while the top-left and bottom-right corners are incremented by\n1\nmodulo\n3\n.\nIn the fourth testcase, it can be proven that it is not possible to convert grid\na\ninto grid\nb\nusing the above-mentioned operations any number of times.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. Array Divisibility",
        "description": "An array of integers\na\n1\n,\na\n2\n,⋯,\na\nn\nis beautiful subject to an integer\nk\nif it satisfies the following:\nThe sum of\na\nj\nover all\nj\nsuch that\nj\nis a multiple of\nk\nand\n1≤j≤n\n, itself, is a multiple of\nk\n.\nMore formally, if\n∑\nk|j\na\nj\nis divisible by\nk\nfor all\n1≤j≤n\nthen the array\na\nis beautiful subject to\nk\n. Here, the notation\nk|j\nmeans\nk\ndivides\nj\n, that is,\nj\nis a multiple of\nk\n.\nGiven\nn\n, find an array of positive nonzero integers, with each element less than or equal to\n10\n5\nthat is beautiful subject to all\n1≤k≤n\n.\nIt can be shown that an answer always exists.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first and only line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the size of the array.\nOutput\nFor each test case, print the required array as described in the problem statement.\nExample\ninput\nCopy\n3\n3\n6\n7\noutput\nCopy\n4 22 18\n10 6 15 32 125 54\n23 18 27 36 5 66 7\nNote\nIn the second test case, when\nn=6\n, for all integers\nk\nsuch that\n1≤k≤6\n, let\nS\nbe the set of all indices of the array that are divisible by\nk\n.\nWhen\nk=1\n,\nS={1,2,3,4,5,6}\nmeaning\na\n1\n+\na\n2\n+\na\n3\n+\na\n4\n+\na\n5\n+\na\n6\n=242\nmust be divisible by\n1\n.\nWhen\nk=2\n,\nS={2,4,6}\nmeaning\na\n2\n+\na\n4\n+\na\n6\n=92\nmust be divisible by\n2\n.\nWhen\nk=3\n,\nS={3,6}\nmeaning\na\n3\n+\na\n6\n=69\nmust divisible by\n3\n.\nWhen\nk=4\n,\nS={4}\nmeaning\na\n4\n=32\nmust divisible by\n4\n.\nWhen\nk=5\n,\nS={5}\nmeaning\na\n5\n=125\nmust divisible by\n5\n.\nWhen\nk=6\n,\nS={6}\nmeaning\na\n6\n=54\nmust divisible by\n6\n.\nThe array\na=[10,6,15,32,125,54]\nsatisfies all of the above conditions. Hence,\na\nis a valid array.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Sorting Problem Again",
        "description": "You have an array\na\nof\nn\nelements. There are also\nq\nmodifications of the array. Before the first modification and after each modification, you would like to know the following:\nWhat is the minimum length subarray that needs to be sorted in non-decreasing order in order for the array\na\nto be completely sorted in non-decreasing order?\nMore formally, you want to select a subarray of the array\n(l,r)\nwith the minimum value of\nr−l+1\n. After that, you will sort the elements\na\nl\n,\na\nl+1\n,…,\na\nr\nand want the condition\na\ni\n≤\na\ni+1\nto hold for all\n1≤i<n\n. If the array is already sorted in non-decreasing order, then\nl\nand\nr\nshould be considered as equal to\n−1\n.\nNote that finding such\n(l,r)\ndoes not change the array in any way. The modifications themselves take the form: assign\na\npos\n=x\nfor given\npos\nand\nx\n.\nInput\nEach test consists of several test cases. The first line contains an integer\nt\n(\n1≤t≤10\n) — the number of test cases. Then follows the description of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\ni\n(\n0≤|\na\ni\n|≤\n10\n9\n) — the initial elements of the array\na\n.\nThe third line of each test case contains a number\nq\n(\n0≤q≤5⋅\n10\n5\n) — the number of modifications to the array.\nThe following\nq\nlines of each test case contain two integers\npo\ns\ni\n(\n1≤po\ns\ni\n≤n\n) and\nva\nl\ni\n(\n0≤|va\nl\ni\n|≤\n10\n9\n) — this means that for the\ni\n-th modification,\na\npo\ns\ni\nis assigned the value\nva\nl\ni\n.\nIt is guaranteed that the sum of\nn\nand the sum of\nq\nfor all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output\nq+1\nlines. Each line should contain\n2\nintegers\nl,r\n — the boundaries of the minimum subarray, such that sorting it will make the array\na\ncompletely sorted. If\na\nis already sorted, then output\nl=−1\n,\nr=−1\n.\nExample\ninput\nCopy\n2\n5\n2 2 3 4 5\n3\n2 1\n4 1\n1 1\n5\n1 2 3 4 5\n9\n1 4\n2 3\n5 2\n3 1\n1 1\n5 1\n4 1\n3 1\n2 1\noutput\nCopy\n-1 -1\n1 2\n1 4\n3 4\n-1 -1\n1 3\n1 3\n1 5\n1 5\n2 5\n2 5\n2 5\n2 5\n-1 -1\nNote\nLet's consider the first test case:\nInitially, the array is sorted in non-decreasing order:\n[2,2,3,4,5]\nAfter the first query, the array looks like this:\n[2,1,3,4,5]\n.\nAfter the second query, the array looks like this:\n[2,1,3,1,5]\n.\nAfter the third query, the array looks like this:\n[1,1,3,1,5]\n.\nThe red segments indicate the subarrays that need to be sorted in order for the entire array to be sorted in non-decreasing order.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "sortings",
            "*2600"
        ]
    },
    {
        "title": "E. Number of k-good subarrays",
        "description": "Let\nbit(x)\ndenote the number of ones in the binary representation of a non-negative integer\nx\n.\nA subarray of an array is called\nk\n-good if it consists only of numbers with no more than\nk\nones in their binary representation, i.e., a subarray\n(l,r)\nof array\na\nis good if for any\ni\nsuch that\nl≤i≤r\ncondition\nbit(\na\ni\n)≤k\nis satisfied.\nYou are given an array\na\nof length\nn\n, consisting of consecutive non-negative integers starting from\n0\n, i.e.,\na\ni\n=i\nfor\n0≤i≤n−1\n(in\n0\n-based indexing). You need to count the number of\nk\n-good subarrays in this array.\nAs the answer can be very large, output it modulo\n10\n9\n+7\n.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The following lines describe the test cases.\nThe single line of each test case contains two integers\nn\n,\nk\n(\n1≤n≤\n10\n18\n,1≤k≤60\n).\nOutput\nFor each test case, output a single integer — the number of\nk\n-good subarrays modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n10\n6 1\n16 2\n1 1\n3 1\n31 3\n14 1\n1337 5\n100000 20\n795569939321040850 56\n576460752303423268 59\noutput\nCopy\n7\n35\n1\n6\n155\n8\n7323\n49965\n741136395\n66679884\nNote\nFor the first test case\na=[0,1,2,3,4,5]\n,\nk=1\n.\nTo find the answer, let's write all the numbers in binary representation:\na=[000,001,010,011,100,101]\n[\n000\n001\n010\n011\n100\n101\n]\nFrom this, it can be seen that the numbers\n3\nand\n5\nhave\n2≥(k=1)\nones in their binary representation, so the answer should include all subarrays that do not contain either\n3\nor\n5\n, which are the subarrays (in\n0\n-based indexing): (\n0\n,\n0\n), (\n0\n,\n1\n), (\n0\n,\n2\n), (\n1\n,\n1\n), (\n1\n,\n2\n), (\n2\n,\n2\n), (\n4\n,\n4\n).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "divide and conquer",
            "dp",
            "math",
            "meet-in-the-middle",
            "*2300"
        ]
    },
    {
        "title": "D. Beauty of the mountains",
        "description": "Nikita loves mountains and has finally decided to visit the Berlyand mountain range! The range was so beautiful that Nikita decided to capture it on a map. The map is a table of\nn\nrows and\nm\ncolumns, with each cell containing a non-negative integer representing the height of the mountain.\nHe also noticed that mountains come in two types:\nWith snowy caps.\nWithout snowy caps.\nNikita is a very pragmatic person. He wants the sum of the heights of the mountains with snowy caps to be equal to the sum of the heights of the mountains without them. He has arranged with the mayor of Berlyand, Polikarp Polikarpovich, to allow him to transform the landscape.\nNikita can perform transformations on submatrices of size\nk×k\nas follows: he can add an integer constant\nc\nto the heights of the mountains within this area, but the type of the mountain remains unchanged. Nikita can choose the constant\nc\nindependently for each transformation. Note that\nc\ncan be negative.\nBefore making the transformations, Nikita asks you to find out if it is possible to achieve equality of the sums, or if it is impossible. It doesn't matter at what cost, even if the mountains turn into canyons and have negative heights.\nIf only one type of mountain is represented on the map, then the sum of the heights of the other type of mountain is considered to be zero.\nInput\nEach test consists of several test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by a description of test cases.\nThe first line of each test case contains three integers\nn,m,k\n(\n1≤n,m≤500,1≤k≤min(n,m)\n).\nThe next\nn\nlines of each test case contain\nm\nintegers\na\nij\n(\n0≤\na\nij\n≤\n10\n9\n) — the initial heights of the mountains.\nThe next\nn\nbinary strings of length\nm\nfor each test case determine the type of mountain, '\n0\n' — with snowy caps, '\n1\n' — without them.\nIt is guaranteed that the sum of\nn⋅m\nfor all test cases does not exceed\n250000\n.\nOutput\nFor each test case, output \"YES\" without quotes if it is possible to equalize the sums of the mountain heights, otherwise output \"NO\" without quotes. You can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n8\n3 3 2\n7 11 3\n4 2 3\n0 1 15\n100\n010\n000\n4 4 3\n123 413 24 233\n123 42 0 216\n22 1 1 53\n427 763 22 6\n0101\n1111\n1010\n0101\n3 3 2\n2 1 1\n1 1 2\n1 5 4\n010\n101\n010\n3 3 2\n2 1 1\n1 1 2\n1 5 3\n010\n101\n010\n3 4 3\n46 49 50 1\n19 30 23 12\n30 25 1 46\n1000\n0100\n0010\n5 4 4\n39 30 0 17\n22 42 30 13\n10 44 46 35\n12 19 9 39\n21 0 45 40\n1000\n1111\n0011\n0111\n1100\n2 2 2\n3 4\n6 7\n00\n00\n2 2 2\n0 0\n2 0\n01\n00\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nYES\nNote\nThe mountain array from the first test case looks like this:\nInitially, the sum of the heights of the mountains with snowy caps is\n11+3+4+3+0+1+15=37\n, and without them is\n7+2=9\n.\nTo equalize these sums, we can perform two transformations:\nFirst transformation:\nNote that the constant\nc\ncan be negative.\nAfter the first transformation, the mountain array looks like this:\nSecond transformation:\nAs a result, the mountain array looks like this:\nThe sum of the heights of the mountains with snowy caps is\n17+9+9−16−20−19+15=−5\n, and without them is\n7−12=−5\n, thus the answer is YES.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "math",
            "number theory",
            "*1700"
        ]
    },
    {
        "title": "C. Boring Day",
        "description": "On another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.\nEgor has a deck of\nn\ncards, the\ni\n-th card from the top has a number\na\ni\nwritten on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between\nl\nand\nr\n, inclusive, the round is won; otherwise, it is lost.\nEgor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.\nInput\nEach test consists of several test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains three integers\nn\n,\nl\n, and\nr\n(\n1≤n≤\n10\n5\n,\n1≤l≤r≤\n10\n9\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the numbers on the cards from top to bottom.\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single number — the maximum number of rounds Egor can win.\nExample\ninput\nCopy\n8\n5 3 10\n2 1 11 3 7\n10 1 5\n17 8 12 11 7 11 21 13 10 8\n3 4 5\n3 4 2\n8 12 25\n10 7 5 13 8 9 12 7\n2 3 3\n5 2\n9 7 9\n2 10 5 1 3 7 6 2 3\n1 8 10\n9\n5 5 6\n1 4 2 6 4\noutput\nCopy\n3\n0\n1\n4\n0\n3\n1\n2\nNote\nIn the first test case, Egor can win\n3\nrounds:\nIn the first round, take the top\n2\ncards with values\n2\nand\n1\nand win, as their sum is\n3\n. After this, the deck will look like this:\n[11,3,7]\n.\nIn the second round, take the top card and lose, as its value\n11\nis greater than\nr=10\n. After this, the deck will look like this:\n[3,7]\n.\nIn the third round, take the top card with value\n3\nand win. After this, the deck will look like this:\n[7]\n.\nAfter this, in the fourth round, Egor only has to take the last card in the deck with value\n7\nand win again.\nIn the second test case, Egor cannot win any rounds, no matter how hard he tries.\nIn the third test case, you can take one card in each round, then the first and third rounds will be losing, and the second round will be winning.\nIn the fourth test case, you can take two cards in each round and always win.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "two pointers",
            "*1200"
        ]
    },
    {
        "title": "B. Collatz Conjecture",
        "description": "Recently, the first-year student Maxim learned about the Collatz conjecture, but he didn't pay much attention during the lecture, so he believes that the following process is mentioned in the conjecture:\nThere is a variable\nx\nand a constant\ny\n. The following operation is performed\nk\ntimes:\nincrease\nx\nby\n1\n, then\nwhile the number\nx\nis divisible by\ny\n, divide it by\ny\n.\nNote that both of these actions are performed sequentially within one operation.\nFor example, if the number\nx=16\n,\ny=3\n, and\nk=2\n, then after one operation\nx\nbecomes\n17\n, and after another operation\nx\nbecomes\n2\n, because after adding one,\nx=18\nis divisible by\n3\ntwice.\nGiven the initial values of\nx\n,\ny\n, and\nk\n, Maxim wants to know what is the final value of\nx\n.\nInput\nEach test consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe only line of each test case contains three integers\nx\n,\ny\n, and\nk\n(\n1≤x,k≤\n10\n9\n,\n2≤y≤\n10\n9\n) — the initial variable, constant and the number of operations.\nOutput\nFor each test case, output a single integer — the number obtained after applying\nk\noperations.\nExample\ninput\nCopy\n13\n1 3 1\n2 3 1\n24 5 5\n16 3 2\n2 2 1\n1337 18 1\n1 2 144133\n12345678 3 10\n998244353 2 998244353\n998244353 123456789 998244352\n998244354 998241111 998244352\n998244355 2 9982443\n1000000000 1000000000 1000000000\noutput\nCopy\n2\n1\n1\n2\n3\n1338\n1\n16936\n1\n21180097\n6486\n1\n2\nNote\nIn the first test case, there is only one operation applied to\nx=1\n, resulting in\nx\nbecoming\n2\n.\nIn the second test case, for\nx=2\n, within one operation, one is added to\nx\nand it's divided by\ny=3\n, resulting in\nx\nbecoming\n1\n.\nIn the third test case,\nx\nchanges as follows:\nAfter the first operation,\nx=1\n, because\n24+1=25\nand\n25\nis divisible by\ny=5\ntwice within one operation.\nAfter the second operation,\nx=2\n.\nAfter the third operation,\nx=3\n.\nAfter the fourth operation,\nx=4\n.\nAfter the fifth operation,\nx=1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "A. Soccer",
        "description": "Dima loves watching soccer. In such a game, the score on the scoreboard is represented as\nx\n:\ny\n, where\nx\nis the number of goals of the first team, and\ny\nis the number of goals of the second team. At any given time, only one team can score a goal, so the score\nx\n:\ny\ncan change to either\n(x+1)\n:\ny\n, or\nx\n:\n(y+1)\n.\nWhile watching a soccer game, Dima was distracted by very important matters, and after some time, he returned to watching the game. Dima remembers the score right before he was distracted, and the score right after he returned. Given these two scores, he wonders the following question. Is it possible that, while Dima was not watching the game, the teams never had an equal score?\nIt is guaranteed that at neither of the two time points Dima remembers the teams had equal scores. However, it is possible that the score did not change during his absence.\nHelp Dima and answer the question!\nInput\nEach test consists of several test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nx\n1\n,\ny\n1\n(\n0≤\nx\n1\n,\ny\n1\n≤\n10\n9\n,\nx\n1\n≠\ny\n1\n) — the score before Dima was distracted.\nThe second line of each test case contains two integers\nx\n2\n,\ny\n2\n(\nx\n1\n≤\nx\n2\n≤\n10\n9\n,\ny\n1\n≤\ny\n2\n≤\n10\n9\n,\nx\n2\n≠\ny\n2\n) — the score when Dima returned.\nOutput\nFor each test case, output \"YES\" without quotes if it is possible, that the teams never had a tie while Dima was away, otherwise output \"NO\" without quotes.\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n6\n1 0\n5 0\n1 2\n3 2\n1 2\n4 5\n1 2\n4 3\n1 2\n1 2\n998244353 0\n1000000000 999999999\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nYES\nNote\nIn the first test case, the score before Dima left was\n1\n:\n0\n. When he leaves, the first team scores several goals in a row until the score becomes\n5\n:\n0\n, so the answer is YES.\nIn the second test case, the score could only change as follows:\n1\n:\n2\n2\n:\n2\n3\n:\n2\nIn this scenario, there is a moment when the teams have an equal score, so the answer is NO.\nIn the third test case, one of the possible developments is:\n1\n:\n2\n1\n:\n3\n2\n:\n3\n2\n:\n4\n2\n:\n5\n3\n:\n5\n4\n:\n5\nIn this scenario, there was no time when the score was equal, so the answer is YES.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "F. Turtle and Paths on a Tree",
        "description": "Note the unusual definition of\nMEX\nin this problem.\nPiggy gave Turtle a binary tree\n†\n†\nwith\nn\nvertices and a sequence\na\n1\n,\na\n2\n,…,\na\nn\non his birthday. The binary tree is rooted at vertex\n1\n.\nIf a set of paths\nP={(\nx\ni\n,\ny\ni\n)}\nin the tree covers each edge exactly once, then Turtle will think that the set of paths is good. Note that a good set of paths can cover a vertex twice or more.\nTurtle defines the value of a set of paths as\n∑\n(x,y)∈P\nf(x,y)\n, where\nf(x,y)\ndenotes the\nMEX\n‡\nof all\na\nu\nsuch that vertex\nu\nis on the simple path from\nx\nto\ny\nin the tree (including the starting vertex\nx\nand the ending vertex\ny\n).\nTurtle wonders the minimum value over all good sets of paths. Please help him calculate the answer!\n†\n†\nA binary tree is a tree where every non-leaf vertex has at most\n2\nsons.\n‡\nMEX\n‡\nof a collection of integers\nc\n1\n,\nc\n2\n,…,\nc\nk\nis defined as the smallest positive integer\nx\nwhich does not occur in the collection\nc\n. For example,\nMEX\nof\n[3,3,1,4]\nis\n2\n,\nMEX\nof\n[2,3]\nis\n1\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2.5⋅\n10\n4\n) — the number of vertices in the tree.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the sequence\na\n.\nThe third line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n<i\n) — the parent of each vertex in the tree.\nAdditional constraint on the input: the given tree is a binary tree, that is, every non-leaf vertex has at most\n2\nsons.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum value over all good sets of paths.\nExample\ninput\nCopy\n5\n5\n3 2 2 1 1\n1 1 2 2\n5\n3 2 1 1 1\n1 1 2 2\n6\n1 2 1 2 1 3\n1 2 3 3 4\n7\n2 1 2 3 1 2 1\n1 1 2 2 3 3\n10\n1 2 2 1 4 2 3 1 2 1\n1 1 2 2 3 3 4 5 5\noutput\nCopy\n4\n6\n6\n6\n7\nNote\nIn the first test case, the tree is as follows. The number in brackets denotes the weight of the vertex:\nThe good set of paths with the minimum value is\n{(2,3),(4,5)}\n.\nNote that in this test case\n{(4,5)}\nand\n{(3,4),(4,5)}\nare not good sets of paths because each edge should be covered exactly once.\nIn the second test case, the tree is as follows:\nThe set of good paths with the minimum value is\n{(1,2),(1,3),(4,5)}\n.\nIn the third test case, the tree is as follows:\nThe set of good paths with the minimum value is\n{(1,6),(3,5)}\n.",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "dp",
            "trees",
            "*3000"
        ]
    },
    {
        "title": "E. Turtle and Intersected Segments",
        "description": "Turtle just received\nn\nsegments and a sequence\na\n1\n,\na\n2\n,…,\na\nn\n. The\ni\n-th segment is\n[\nl\ni\n,\nr\ni\n]\n.\nTurtle will create an undirected graph\nG\n. If segment\ni\nand segment\nj\nintersect, then Turtle will add an undirected edge between\ni\nand\nj\nwith a weight of\n|\na\ni\n−\na\nj\n|\n, for every\ni≠j\n.\nTurtle wants you to calculate the sum of the weights of the edges of the minimum spanning tree of the graph\nG\n, or report that the graph\nG\nhas no spanning tree.\nWe say two segments\n[\nl\n1\n,\nr\n1\n]\nand\n[\nl\n2\n,\nr\n2\n]\nintersect if and only if\nmax(\nl\n1\n,\nl\n2\n)≤min(\nr\n1\n,\nr\n2\n)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤5⋅\n10\n5\n) — the number of segments.\nThe\ni\n-th of the following\nn\nlines contains three integers\nl\ni\n,\nr\ni\n,\na\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤\n10\n9\n,1≤\na\ni\n≤\n10\n9\n) — the\ni\n-th segment and the\ni\n-th element of the sequence.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the sum of the weights of the edges of the minimum spanning tree of the graph\nG\n. If the graph\nG\nhas no spanning tree, output\n−1\n.\nExample\ninput\nCopy\n4\n5\n1 7 3\n2 4 6\n3 5 5\n6 7 9\n3 4 4\n5\n2 7 3\n1 3 6\n4 5 5\n6 7 9\n1 1 4\n4\n1 4 3\n1 2 1\n3 4 5\n1 4 4\n3\n1 3 1\n2 3 3\n4 5 8\noutput\nCopy\n9\n13\n4\n-1\nNote\nIn the first test case, the graph\nG\nis as follows:\nOne of the minimum spanning trees of\nG\nis as follows:\nThe sum of the weights of the edges of the minimum spanning tree is\n9\n.\nIn the second test case, the graph\nG\nis as follows:\nG\nis already a tree, and the sum of the weights of the tree is\n13\n.\nIn the third test case, the graph\nG\nis as follows:\nIn the fourth test case, the graph\nG\nis as follows:\nIt's easy to see that\nG\nis not connected, so\nG\nhas no spanning tree.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dsu",
            "graphs",
            "greedy",
            "*2600"
        ]
    },
    {
        "title": "D. Turtle and Multiplication",
        "description": "Turtle just learned how to multiply two integers in his math class, and he was very excited.\nThen Piggy gave him an integer\nn\n, and asked him to construct a sequence\na\n1\n,\na\n2\n,…,\na\nn\nconsisting of integers which satisfied the following conditions:\nFor all\n1≤i≤n\n,\n1≤\na\ni\n≤3⋅\n10\n5\n.\nFor all\n1≤i<j≤n−1\n,\na\ni\n⋅\na\ni+1\n≠\na\nj\n⋅\na\nj+1\n.\nOf all such sequences, Piggy asked Turtle to find the one with the minimum number of distinct elements.\nTurtle definitely could not solve the problem, so please help him!\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n6\n) — the length of the sequence\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n— the elements of the sequence\na\n.\nIf there are multiple answers, print any of them.\nExample\ninput\nCopy\n3\n2\n3\n4\noutput\nCopy\n114514 114514\n1 2 2\n3 3 4 4\nNote\nIn the third test case,\na=[3,4,2,6]\nviolates the second condition since\na\n1\n⋅\na\n2\n=\na\n3\n⋅\na\n4\n.\na=[2,3,4,4]\nsatisfy the conditions but its number of distinct elements isn't minimum.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "C. Turtle and an Incomplete Sequence",
        "description": "Turtle was playing with a sequence\na\n1\n,\na\n2\n,…,\na\nn\nconsisting of positive integers. Unfortunately, some of the integers went missing while playing.\nNow the sequence becomes incomplete. There may exist an arbitrary number of indices\ni\nsuch that\na\ni\nbecomes\n−1\n. Let the new sequence be\na\n′\n.\nTurtle is sad. But Turtle remembers that for every integer\ni\nfrom\n1\nto\nn−1\n, either\na\ni\n=⌊\na\ni+1\n2\n⌋\nor\na\ni+1\n=⌊\na\ni\n2\n⌋\nholds for the original sequence\na\n.\nTurtle wants you to help him complete the sequence. But sometimes Turtle makes mistakes, so you need to tell him if you can't complete the sequence.\nFormally, you need to find another sequence\nb\n1\n,\nb\n2\n,…,\nb\nn\nconsisting of positive integers such that:\nFor every integer\ni\nfrom\n1\nto\nn\n, if\na\n′\ni\n≠−1\n, then\nb\ni\n=\na\n′\ni\n.\nFor every integer\ni\nfrom\n1\nto\nn−1\n, either\nb\ni\n=⌊\nb\ni+1\n2\n⌋\nor\nb\ni+1\n=⌊\nb\ni\n2\n⌋\nholds.\nFor every integer\ni\nfrom\n1\nto\nn\n,\n1≤\nb\ni\n≤\n10\n9\n.\nIf there is no sequence\nb\n1\n,\nb\n2\n,…,\nb\nn\nthat satisfies all of the conditions above, you need to report\n−1\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the sequence.\nThe second line of each test case contains\nn\nintegers\na\n′\n1\n,\na\n′\n2\n,…,\na\n′\nn\n(\na\n′\ni\n=−1\nor\n1≤\na\n′\ni\n≤\n10\n8\n) — the elements of the sequence\na\n′\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if there is no sequence\nb\n1\n,\nb\n2\n,…,\nb\nn\nthat satisfies all of the conditions, output a single integer\n−1\n.\nOtherwise, output\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n— the elements of the sequence\nb\n1\n,\nb\n2\n,…,\nb\nn\nyou find. The sequence should satisfy that\n1≤\nb\ni\n≤\n10\n9\nfor every integer\ni\nfrom\n1\nto\nn\n. If there are multiple answers, print any of them.\nExample\ninput\nCopy\n9\n8\n-1 -1 -1 2 -1 -1 1 -1\n4\n-1 -1 -1 -1\n6\n3 -1 -1 -1 9 -1\n4\n-1 5 -1 6\n4\n2 -1 -1 3\n4\n1 2 3 4\n2\n4 2\n5\n-1 3 -1 3 6\n13\n-1 -1 3 -1 -1 -1 -1 7 -1 -1 3 -1 -1\noutput\nCopy\n4 9 4 2 4 2 1 2\n7 3 6 13\n3 1 2 4 9 18\n-1\n-1\n-1\n4 2\n6 3 1 3 6\n3 1 3 1 3 7 3 7 3 1 3 1 3\nNote\nIn the first test case,\n[4,2,1,2,1,2,1,3]\ncan also be the answer, while\n[4,2,5,10,5,2,1,3]\nand\n[4,2,1,2,1,2,1,4]\ncannot.\nIn the second test case,\n[1,2,5,2]\ncan also be the answer.\nFrom the fourth to the sixth test cases, it can be shown that there is no answer, so you should output\n−1\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1800"
        ]
    },
    {
        "title": "B. Turtle and an Infinite Sequence",
        "description": "There is a sequence\na\n0\n,\na\n1\n,\na\n2\n,…\nof infinite length. Initially\na\ni\n=i\nfor every non-negative integer\ni\n.\nAfter every second, each element of the sequence will simultaneously change.\na\ni\nwill change to\na\ni−1\n∣\na\ni\n∣\na\ni+1\nfor every positive integer\ni\n.\na\n0\nwill change to\na\n0\n∣\na\n1\n. Here,\n|\ndenotes bitwise OR.\nTurtle is asked to find the value of\na\nn\nafter\nm\nseconds. In particular, if\nm=0\n, then he needs to find the initial value of\na\nn\n. He is tired of calculating so many values, so please help him!\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn,m\n(\n0≤n,m≤\n10\n9\n).\nOutput\nFor each test case, output a single integer — the value of\na\nn\nafter\nm\nseconds.\nExample\ninput\nCopy\n9\n0 0\n0 1\n0 2\n1 0\n5 2\n10 1\n20 3\n1145 14\n19198 10\noutput\nCopy\n0\n1\n3\n1\n7\n11\n23\n1279\n19455\nNote\nAfter\n1\nsecond,\n[\na\n0\n,\na\n1\n,\na\n2\n,\na\n3\n,\na\n4\n,\na\n5\n]\nwill become\n[1,3,3,7,7,7]\n.\nAfter\n2\nseconds,\n[\na\n0\n,\na\n1\n,\na\n2\n,\na\n3\n,\na\n4\n,\na\n5\n]\nwill become\n[3,3,7,7,7,7]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "math",
            "*1300"
        ]
    },
    {
        "title": "A. Turtle and Piggy Are Playing a Game",
        "description": "Turtle and Piggy are playing a number game.\nFirst, Turtle will choose an integer\nx\n, such that\nl≤x≤r\n, where\nl,r\nare given. It's also guaranteed that\n2l≤r\n.\nThen, Piggy will keep doing the following operation until\nx\nbecomes\n1\n:\nChoose an integer\np\nsuch that\np≥2\nand\np∣x\n(i.e.\nx\nis a multiple of\np\n).\nSet\nx\nto\nx\np\n, and the score will increase by\n1\n.\nThe score is initially\n0\n. Both Turtle and Piggy want to maximize the score. Please help them to calculate the maximum score.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nl,r\n(\n1≤l≤r≤\n10\n9\n,2l≤r\n) — The range where Turtle can choose the integer from.\nOutput\nFor each test case, output a single integer — the maximum score.\nExample\ninput\nCopy\n5\n2 4\n3 6\n2 15\n6 22\n114514 1919810\noutput\nCopy\n2\n2\n3\n4\n20\nNote\nIn the first test case, Turtle can choose an integer\nx\n, such that\n2≤x≤4\n. He can choose\nx=4\n. Then Piggy can choose\np=2\nfor\n2\ntimes. After that,\nx\nwill become\n1\n, and the score will be\n2\n, which is maximized.\nIn the second test case, Turtle can choose an integer\n3≤x≤6\n. He can choose\nx=6\n. Then Piggy can choose\np=2\n, then choose\np=3\n. After that,\nx\nwill become\n1\n, and the score will be\n2\n, which is maximum.\nIn the third test case, Turtle can choose\nx=12\n.\nIn the fourth test case, Turtle can choose\nx=16\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Yasya and the Mysterious Tree",
        "description": "Yasya was walking in the forest and accidentally found a tree with\nn\nvertices. A tree is a connected undirected graph with no cycles.\nNext to the tree, the girl found an ancient manuscript with\nm\nqueries written on it. The queries can be of two types.\nThe first type of query is described by the integer\ny\n. The weight of each edge in the tree is replaced by the bitwise exclusive OR of the weight of that edge and the integer\ny\n.\nThe second type is described by the vertex\nv\nand the integer\nx\n. Yasya chooses a vertex\nu\n(\n1≤u≤n\n,\nu≠v\n) and mentally draws a bidirectional edge of weight\nx\nfrom\nv\nto\nu\nin the tree.\nThen Yasya finds a simple cycle in the resulting graph and calculates the bitwise exclusive OR of all the edges in it. She wants to choose a vertex\nu\nsuch that the calculated value is maximum. This calculated value will be the answer to the query. It can be shown that such a cycle exists and is unique under the given constraints (independent of the choice of\nu\n). If an edge between\nv\nand\nu\nalready existed, a simple cycle is the path\nv→u→v\n.\nNote that the second type of query is performed mentally, meaning the tree does not change in any way after it.\nHelp Yasya answer all the queries.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe descriptions of the test cases follow.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n2≤n≤2⋅\n10\n5\n,\n1≤m≤2⋅\n10\n5\n) — the number of vertices in the tree and the number of queries.\nThe next\nn−1\nlines of each test case contain three integers\nv\n,\nu\n,\nw\n(\n1≤v,u≤n\n,\n1≤w≤\n10\n9\n) — the ends of some edge in the tree and its weight.\nIt is guaranteed that the given set of edges forms a tree.\nThe next\nm\nlines of each test case describe the queries:\n^\ny\n(\n1≤y≤\n10\n9\n) — parameter of the first type query;\n?\nv\nx\n(\n1≤v≤n\n,\n1≤x≤\n10\n9\n) — parameters of the second type query.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. The same is guaranteed for\nm\n.\nOutput\nFor each test case, output the answers to the queries of the second type.\nExamples\ninput\nCopy\n2\n3 7\n1 2 1\n3 1 8\n^ 5\n? 2 9\n^ 1\n? 1 10\n^ 6\n? 3 1\n? 2 9\n5 6\n1 2 777\n3 2 2812\n4 1 16\n5 3 1000000000\n^ 4\n? 3 123\n? 5 1000000000\n^ 1000000000\n? 1 908070\n? 2 1\noutput\nCopy\n13 15 11 10 \n1000000127 2812 999756331 999999756 \ninput\nCopy\n3\n8 4\n8 6 3\n6 3 4\n2 5 4\n7 6 2\n7 1 10\n4 1 4\n5 1 2\n^ 4\n^ 7\n? 7 8\n? 4 10\n5 6\n3 1 4\n2 3 9\n4 3 6\n5 2 10\n? 5 7\n^ 1\n^ 8\n? 4 10\n? 1 9\n? 3 6\n4 2\n2 1 4\n4 3 5\n2 3 4\n^ 13\n? 1 10\noutput\nCopy\n14 13 \n13 8 11 11 \n10 ",
        "time_limit": "2.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "data structures",
            "dfs and similar",
            "graphs",
            "greedy",
            "strings",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "F2. Field Division (hard version)",
        "description": "This is a hard version of the problem; it differs from the easy version only by the question. The easy version only needs you to print whether some values are non-zero or not. The hard version needs you to print the exact values.\nAlice and Bob are dividing the field. The field is a rectangle of size\nn×m\n(\n2≤n,m≤\n10\n9\n); the rows are numbered from\n1\nto\nn\nfrom top to bottom, and the columns are numbered from\n1\nto\nm\nfrom left to right. The cell at the intersection of row\nr\nand column\nc\nis denoted as (\nr,c\n).\nBob has\nk\n(\n2≤k≤2⋅\n10\n5\n) fountains, all of them are located in different cells of the field. Alice is responsible for dividing the field, but she must meet several conditions:\nTo divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field.\nAlice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob.\nAlice will own the part that includes the cell (\nn,1\n).\nBob will own the part that includes the cell (\n1,m\n).\nAlice wants to divide the field in such a way as to get as many cells as possible.\nBob wants to keep ownership of all the fountains, but he can give one of them to Alice. First, output the integer\nα\n— the maximum possible size of Alice's plot, if Bob does not give her any fountain (i.e., all fountains will remain on Bob's plot).\nThen output\nk\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nk\n, where\na\ni\nis a value such that after Bob gives Alice the\ni\n-th fountain, the maximum size of her plot will be\nα+\na\ni\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n,m≤\n10\n9\n,\n2≤k≤2⋅\n10\n5\n) — the field sizes and the number of fountains, respectively.\nThen follow\nk\nlines, each containing two numbers\nr\ni\nand\nc\ni\n(\n1≤\nr\ni\n≤n\n,\n1≤\nc\ni\n≤m\n) — the coordinates of the cell with the\ni\n-th fountain. It is guaranteed that all cells are distinct and none of them is (\nn,1\n).\nIt is guaranteed that the sum of\nk\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, first output\nα\n — the maximum size of the plot that can belong to Alice if Bob does not give her any of the fountains. Then output\nk\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nk\n, where\na\ni\nis a value such that after Bob gives Alice the\ni\n-th fountain, the maximum size of her plot will be\nα+\na\ni\n.\nExample\ninput\nCopy\n5\n2 2 3\n1 1\n1 2\n2 2\n5 5 4\n1 2\n2 2\n3 4\n4 3\n2 5 9\n1 2\n1 5\n1 1\n2 2\n2 4\n2 5\n1 4\n2 3\n1 3\n6 4 4\n6 2\n1 3\n1 4\n1 2\n3 4 5\n2 1\n3 2\n1 4\n1 3\n2 4\noutput\nCopy\n1\n1 0 1 \n11\n0 1 0 4 \n1\n0 0 1 1 0 0 0 0 0 \n6\n15 0 0 0 \n1\n2 3 0 0 0 \nNote\nBelow are the images for the second example:\nThe indices of the fountains are labeled in green. The cells belonging to Alice are marked in blue.\nNote that if Bob gives Alice fountain\n1\nor fountain\n3\n, then that fountain cannot be on Alice's plot.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "sortings",
            "*2400"
        ]
    },
    {
        "title": "F1. Field Division (easy version)",
        "description": "This is an easy version of the problem; it differs from the hard version only by the question. The easy version only needs you to print whether some values are non-zero or not. The hard version needs you to print the exact values.\nAlice and Bob are dividing the field. The field is a rectangle of size\nn×m\n(\n2≤n,m≤\n10\n9\n), the rows are numbered from\n1\nto\nn\nfrom top to bottom, and the columns are numbered from\n1\nto\nm\nfrom left to right. The cell at the intersection of row\nr\nand column\nc\nis denoted as (\nr,c\n).\nBob has\nk\n(\n2≤k≤2⋅\n10\n5\n) fountains, all of them are located in different cells of the field. Alice is responsible for dividing the field, but she must meet several conditions:\nTo divide the field, Alice will start her path in any free (without a fountain) cell on the left or top side of the field and will move, each time moving to the adjacent cell down or right. Her path will end on the right or bottom side of the field.\nAlice's path will divide the field into two parts — one part will belong to Alice (this part includes the cells of her path), the other part — to Bob.\nAlice will own the part that includes the cell (\nn,1\n).\nBob will own the part that includes the cell (\n1,m\n).\nAlice wants to divide the field in such a way as to get as many cells as possible.\nBob wants to keep ownership of all the fountains, but he can give one of them to Alice. First, output the integer\nα\n— the maximum possible size of Alice's plot, if Bob does not give her any fountain (i.e., all fountains will remain on Bob's plot). Then output\nk\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nk\n, where:\na\ni\n=0\n, if after Bob gives Alice the\ni\n-th fountain, the maximum possible size of Alice's plot does not increase (i.e., remains equal to\nα\n);\na\ni\n=1\n, if after Bob gives Alice the\ni\n-th fountain, the maximum possible size of Alice's plot increases (i.e., becomes greater than\nα\n).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n,m≤\n10\n9\n,\n2≤k≤2⋅\n10\n5\n) — the field sizes and the number of fountains, respectively.\nThen follow\nk\nlines, each containing two numbers\nr\ni\nand\nc\ni\n(\n1≤\nr\ni\n≤n\n,\n1≤\nc\ni\n≤m\n) — the coordinates of the cell with the\ni\n-th fountain. It is guaranteed that all cells are distinct and none of them is (\nn,1\n).\nIt is guaranteed that the sum of\nk\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, first output\nα\n — the maximum size of the plot that can belong to Alice if Bob does not give her any of the fountains. Then output\nk\nnon-negative integers\na\n1\n,\na\n2\n,…,\na\nk\n, where:\na\ni\n=0\n, if after Bob gives Alice the\ni\n-th fountain, the maximum possible size of Alice's plot does not increase compared to the case when all\nk\nfountains belong to Bob;\na\ni\n=1\n, if after Bob gives Alice the\ni\n-th fountain, the maximum possible size of Alice's plot increases compared to the case when all\nk\nfountains belong to Bob.\nIf you output any other positive number instead of\n1\nthat fits into a 64-bit signed integer type, it will also be recognized as\n1\n. Thus, a solution to the hard version of this problem will also pass the tests for the easy version.\nExample\ninput\nCopy\n5\n2 2 3\n1 1\n1 2\n2 2\n5 5 4\n1 2\n2 2\n3 4\n4 3\n2 5 9\n1 2\n1 5\n1 1\n2 2\n2 4\n2 5\n1 4\n2 3\n1 3\n6 4 4\n6 2\n1 3\n1 4\n1 2\n3 4 5\n2 1\n3 2\n1 4\n1 3\n2 4\noutput\nCopy\n1\n1 0 1 \n11\n0 1 0 1 \n1\n0 0 1 1 0 0 0 0 0 \n6\n1 0 0 0 \n1\n1 1 0 0 0 \nNote\nBelow are the images for the second example:\nThe indices of the fountains are labeled in green. The cells belonging to Alice are marked in blue.\nNote that if Bob gives Alice fountain\n1\nor fountain\n3\n, then that fountain cannot be on Alice's plot.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "math",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "E. Permutation of Rows and Columns",
        "description": "You have been given a matrix\na\nof size\nn\nby\nm\n, containing a permutation of integers from\n1\nto\nn⋅m\n.\nA permutation of\nn\nintegers is an array containing all numbers from\n1\nto\nn\nexactly once. For example, the arrays\n[1]\n,\n[2,1,3]\n,\n[5,4,3,2,1]\nare permutations, while the arrays\n[1,1]\n,\n[100]\n,\n[1,2,4,5]\nare not.\nA matrix contains a permutation if, when all its elements are written out, the resulting array is a permutation. Matrices\n[[1,2],[3,4]]\n,\n[[1]]\n,\n[[1,5,3],[2,6,4]]\ncontain permutations, while matrices\n[[2]]\n,\n[[1,1],[2,2]]\n,\n[[1,2],[100,200]]\ndo not.\nYou can perform one of the following two actions in one operation:\nchoose columns\nc\nand\nd\n(\n1≤c,d≤m\n,\nc≠d\n) and swap these columns;\nchoose rows\nc\nand\nd\n(\n1≤c,d≤n\n,\nc≠d\n) and swap these rows.\nYou can perform any number of operations.\nYou are given the original matrix\na\nand the matrix\nb\n. Your task is to determine whether it is possible to transform matrix\na\ninto matrix\nb\nusing the given operations.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case description contains\n2\nintegers\nn\nand\nm\n(\n1≤n,m≤n⋅m≤2⋅\n10\n5\n) — the sizes of the matrix.\nThe next\nn\nlines contain\nm\nintegers\na\nij\neach (\n1≤\na\nij\n≤n⋅m\n). It is guaranteed that matrix\na\nis a permutation.\nThe next\nn\nlines contain\nm\nintegers\nb\nij\neach (\n1≤\nb\nij\n≤n⋅m\n). It is guaranteed that matrix\nb\nis a permutation.\nIt is guaranteed that the sum of the values\nn⋅m\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if the second matrix can be obtained from the first, and \"NO\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n7\n1 1\n1\n1\n2 2\n1 2\n3 4\n4 3\n2 1\n2 2\n1 2\n3 4\n4 3\n1 2\n3 4\n1 5 9 6\n12 10 4 8\n7 11 3 2\n1 5 9 6\n12 10 4 8\n7 11 3 2\n3 3\n1 5 9\n6 4 2\n3 8 7\n9 5 1\n2 4 6\n7 8 3\n2 3\n1 2 6\n5 4 3\n6 1 2\n3 4 5\n1 5\n5 1 2 3 4\n4 2 5 1 3\noutput\nCopy\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNote\nIn the second example, the original matrix looks like this:\n(\n1\n3\n2\n4\n)\n(\nBy swapping rows\n1\nand\n2\n, it becomes:\n(\n3\n1\n4\n2\n)\n(\nBy swapping columns\n1\nand\n2\n, it becomes equal to matrix\nb\n:\n(\n4\n2\n3\n1\n)\n(",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "hashing",
            "implementation",
            "math",
            "matrices",
            "sortings",
            "*1600"
        ]
    },
    {
        "title": "D. GCD-sequence",
        "description": "GCD (Greatest Common Divisor) of two integers\nx\nand\ny\nis the maximum integer\nz\nby which both\nx\nand\ny\nare divisible. For example,\nGCD(36,48)=12\n,\nGCD(5,10)=5\n, and\nGCD(7,11)=1\n.\nKristina has an array\na\nconsisting of exactly\nn\npositive integers. She wants to count the GCD of each neighbouring pair of numbers to get a new array\nb\n, called GCD-sequence.\nSo, the elements of the GCD-sequence\nb\nwill be calculated using the formula\nb\ni\n=GCD(\na\ni\n,\na\ni+1\n)\nfor\n1≤i≤n−1\n.\nDetermine whether it is possible to remove exactly one number from the array\na\nso that the GCD sequence\nb\nis non-decreasing (i.e.,\nb\ni\n≤\nb\ni+1\nis always true).\nFor example, let Khristina had an array\na\n= [\n20,6,12,3,48,36\n]. If she removes\na\n4\n=3\nfrom it and counts the GCD-sequence of\nb\n, she gets:\nb\n1\n=GCD(20,6)=2\nb\n2\n=GCD(6,12)=6\nb\n3\n=GCD(12,48)=12\nb\n4\n=GCD(48,36)=12\nThe resulting GCD sequence\nb\n= [\n2,6,12,12\n] is non-decreasing because\nb\n1\n≤\nb\n2\n≤\nb\n3\n≤\nb\n4\n.\nInput\nThe first line of input data contains a single number\nt\n(\n1≤t≤\n10\n4\n) — he number of test cases in the test.\nThis is followed by the descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤2⋅\n10\n5\n) — the number of elements in the array\na\n.\nThe second line of each test case contains exactly\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of array\na\n.\nIt is guaranteed that the sum of\nn\nover all test case does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line:\n\"YES\" if you can remove exactly one number from the array\na\nso that the GCD-sequence of\nb\nis non-decreasing;\n\"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as a positive answer).\nExample\ninput\nCopy\n12\n6\n20 6 12 3 48 36\n4\n12 6 3 4\n3\n10 12 3\n5\n32 16 8 4 2\n5\n100 50 2 10 20\n4\n2 4 8 1\n10\n7 4 6 2 4 5 1 4 2 8\n7\n5 9 6 8 5 9 2\n6\n11 14 8 12 9 3\n9\n5 7 3 10 6 3 12 6 3\n3\n4 2 4\n8\n1 6 11 12 6 12 3 6\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nYES\nNote\nThe first test case is explained in the problem statement.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*1400"
        ]
    },
    {
        "title": "C. Sofia and the Lost Operations",
        "description": "Sofia had an array of\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n. One day she got bored with it, so she decided to sequentially apply\nm\nmodification operations to it.\nEach modification operation is described by a pair of numbers\n⟨\nc\nj\n,\nd\nj\n⟩\nand means that the element of the array with index\nc\nj\nshould be assigned the value\nd\nj\n, i.e., perform the assignment\na\nc\nj\n=\nd\nj\n. After applying all modification operations sequentially, Sofia discarded the resulting array.\nRecently, you found an array of\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n. You are interested in whether this array is Sofia's array. You know the values of the original array, as well as the values\nd\n1\n,\nd\n2\n,…,\nd\nm\n. The values\nc\n1\n,\nc\n2\n,…,\nc\nm\nturned out to be lost.\nIs there a sequence\nc\n1\n,\nc\n2\n,…,\nc\nm\nsuch that the sequential application of modification operations\n⟨\nc\n1\n,\nd\n1\n,⟩,⟨\nc\n2\n,\nd\n2\n,⟩,…,⟨\nc\nm\n,\nd\nm\n⟩\nto the array\na\n1\n,\na\n2\n,…,\na\nn\ntransforms it into the array\nb\n1\n,\nb\n2\n,…,\nb\nn\n?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the original array.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n) — the elements of the found array.\nThe fourth line contains an integer\nm\n(\n1≤m≤2⋅\n10\n5\n) — the number of modification operations.\nThe fifth line contains\nm\nintegers\nd\n1\n,\nd\n2\n,…,\nd\nm\n(\n1≤\nd\nj\n≤\n10\n9\n) — the preserved value for each modification operation.\nIt is guaranteed that the sum of the values of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n, similarly the sum of the values of\nm\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput\nt\nlines, each of which is the answer to the corresponding test case. As an answer, output \"YES\" if there exists a suitable sequence\nc\n1\n,\nc\n2\n,…,\nc\nm\n, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n7\n3\n1 2 1\n1 3 2\n4\n1 3 1 2\n4\n1 2 3 5\n2 1 3 5\n2\n2 3\n5\n7 6 1 10 10\n3 6 1 11 11\n3\n4 3 11\n4\n3 1 7 8\n2 2 7 10\n5\n10 3 2 2 1\n5\n5 7 1 7 9\n4 10 1 2 9\n8\n1 1 9 8 7 2 10 4\n4\n1000000000 203 203 203\n203 1000000000 203 1000000000\n2\n203 1000000000\n1\n1\n1\n5\n1 3 4 5 1\noutput\nCopy\nYES\nNO\nNO\nNO\nYES\nNO\nYES",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "B. Choosing Cubes",
        "description": "Dmitry has\nn\ncubes, numbered from left to right from\n1\nto\nn\n. The cube with index\nf\nis his favorite.\nDmitry threw all the cubes on the table, and the\ni\n-th cube showed the value\na\ni\n(\n1≤\na\ni\n≤100\n). After that, he arranged the cubes in non-increasing order of their values, from largest to smallest. If two cubes show the same value, they can go in any order.\nAfter sorting, Dmitry removed the first\nk\ncubes. Then he became interested in whether he removed his favorite cube (note that its position could have changed after sorting).\nFor example, if\nn=5\n,\nf=2\n,\na=[4,3,3,2,3]\n(the favorite cube is highlighted in green), and\nk=2\n, the following could have happened:\nAfter sorting\na=[4,3,3,3,2]\n, since the favorite cube ended up in the second position, it will be removed.\nAfter sorting\na=[4,3,3,3,2]\n, since the favorite cube ended up in the third position, it will not be removed.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case description contains three integers\nn\n,\nf\n, and\nk\n(\n1≤f,k≤n≤100\n) — the number of cubes, the index of Dmitry's favorite cube, and the number of removed cubes, respectively.\nThe second line of each test case description contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤100\n) — the values shown on the cubes.\nOutput\nFor each test case, output one line — \"YES\" if the cube will be removed in all cases, \"NO\" if it will not be removed in any case, \"MAYBE\" if it may be either removed or left.\nYou can output the answer in any case. For example, the strings \"YES\", \"nO\", \"mAyBe\" will be accepted as answers.\nExample\ninput\nCopy\n12\n5 2 2\n4 3 3 2 3\n5 5 3\n4 2 1 3 5\n5 5 2\n5 2 4 1 3\n5 5 5\n1 2 5 4 3\n5 5 4\n3 1 2 4 5\n5 5 5\n4 3 2 1 5\n6 5 3\n1 2 3 1 2 3\n10 1 1\n1 1 1 1 1 1 1 1 1 1\n1 1 1\n42\n5 2 3\n2 2 1 1 2\n2 1 1\n2 1\n5 3 1\n3 3 2 3 2\noutput\nCopy\nMAYBE\nYES\nNO\nYES\nYES\nYES\nMAYBE\nMAYBE\nYES\nYES\nYES\nNO",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "sortings",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "A. Problem Generator",
        "description": "Vlad is planning to hold\nm\nrounds next month. Each round should contain one problem of difficulty levels 'A', 'B', 'C', 'D', 'E', 'F', and 'G'.\nVlad already has a bank of\nn\nproblems, where the\ni\n-th problem has a difficulty level of\na\ni\n. There may not be enough of these problems, so he may have to come up with a few more problems.\nVlad wants to come up with as few problems as possible, so he asks you to find the minimum number of problems he needs to come up with in order to hold\nm\nrounds.\nFor example, if\nm=1\n,\nn=10\n,\na=\n'BGECDCBDED', then he needs to come up with two problems: one of difficulty level 'A' and one of difficulty level 'F'.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤50\n,\n1≤m≤5\n) — the number of problems in the bank and the number of upcoming rounds, respectively.\nThe second line of each test case contains a string\na\nof\nn\ncharacters from 'A' to 'G' — the difficulties of the problems in the bank.\nOutput\nFor each test case, output a single integer — the minimum number of problems that need to come up with to hold\nm\nrounds.\nExample\ninput\nCopy\n3\n10 1\nBGECDCBDED\n10 2\nBGECDCBDED\n9 1\nBBCDEFFGG\noutput\nCopy\n2\n5\n1",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Kostyanych's Theorem",
        "description": "This is an interactive problem.\nKostyanych has chosen a complete undirected graph\n†\n†\nwith\nn\nvertices, and then removed exactly\n(n−2)\nedges from it. You can ask queries of the following type:\n\"?\nd\n\" — Kostyanych tells you the number of vertex\nv\nwith a degree at least\nd\n. Among all possible such vertices, he selects the vertex with the minimum degree, and if there are several such vertices, he selects the one with the minimum number. He also tells you the number of another vertex in the graph, with which\nv\nis not connected by an edge (if none is found, then\n0\nis reported). Among all possible such vertices, he selects the one with the minimum number. Then he removes the vertex\nv\nand all edges coming out of it. If the required vertex\nv\nis not found, then \"\n0 0\n\" is reported.\nFind a Hamiltonian path\n‡\n‡\nin the original graph in at most\nn\nqueries. It can be proven that under these constraints, a Hamiltonian path always exists.\n†\n†\nA complete undirected graph is a graph in which there is exactly one undirected edge between any pair of distinct vertices. Thus, a complete undirected graph with\nn\nvertices contains\nn(n−1)\n2\nedges.\n‡\n‡\nA Hamiltonian path in a graph is a path that passes through each vertex exactly once.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the graph.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nInteraction\nInteraction for each test case begins with reading the integer\nn\n.\nThen you can make no more than\nn\nqueries.\nTo make a query, output a line in the format \"?\nd\n\" (without quotes) (\n0≤d≤n−1\n). After each query, read two integers — the answer to your query.\nWhen you are ready to report the answer, output a line in the format \"!\nv\n1\n v\n2\n…\nv\nn\n\" (without quotes) — the vertices in the order of their occurrence in the Hamiltonian path. Outputting the answer does not count as one of the\nn\nqueries. After solving one test case, the program should immediately move on to the next one. After solving all test cases, the program should be terminated immediately.\nIf your program makes more than\nn\nqueries for one test case or makes an incorrect query, then the response to the query will be\n−1\n, and after receiving such a response, your program should immediately terminate to receive the verdict Wrong answer. Otherwise, it may receive any other verdict.\nAfter outputting a query, do not forget to output an end of line and flush the output buffer. Otherwise, you will receive the verdict Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nThe interactor is non-adaptive. The graph does not change during the interaction.\nHacks\nTo hack, use the following format:\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the graph.\nEach of the following\n(n−2)\nlines should contains two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — ends of the edge that was removed from the graph. Each edge must not occur more than once.\nThe sum of\nn\nover all test cases should not exceed\n10\n5\n.\nExample\ninput\nCopy\n3\n4\n\n0 0\n\n1 4\n\n2 3\n\n4\n\n1 0\n\n4 2\n\n2\n\n1 0\noutput\nCopy\n? 3\n\n? 2\n\n? 1\n\n! 4 3 1 2\n\n? 3\n\n? 0\n\n! 4 1 2 3\n\n? 0\n\n! 2 1\nNote\nIn the first test case, the original graph looks as follows:\nConsider the queries:\nThere are no vertices with a degree of at least\n3\nin the graph, so \"\n0 0\n\" is reported.\nThere are four vertices with a degree of at least\n2\n, and all of them have a degree of exactly\n2\n:\n1\n,\n2\n,\n3\n,\n4\n. Vertex\n1\nis reported, because it has the minimum number, and vertex\n4\nis reported, because it is the only one not connected to vertex\n1\n. After this, vertex\n1\nis removed from the graph.\nThere are three vertices with a degree of at least\n1\n, among them vertices\n2\nand\n3\nhave a minimum degree of\n1\n(vertex\n4\nhas a degree of\n2\n). Vertex\n2\nis reported, because it has the minimum number, and vertex\n3\nis reported, because it is the only one not connected to vertex\n2\n. After this, vertex\n2\nis removed from the graph.\nThe path\n4−3−1−2\nis a Hamiltonian path.\nIn the second test case, the original graph looks as follows:\nConsider the queries:\nVertex\n1\nhas a degree of at least\n3\n, but it is connected to all vertices, so \"\n1 0\n\" is reported. After this, vertex\n1\nis removed from the graph.\nThe remaining vertices\n2\n,\n3\n, and\n4\nhave a degree of at least\n0\n, but among them vertex\n4\nhas the minimum degree of\n0\n(vertices\n2\nand\n3\nhave a degree of\n1\n). Vertex\n4\nis not connected to both vertices\n2\nand\n3\n, so vertex\n2\nis reported (as it has the minimum number). After this, vertex\n4\nis removed from the graph.\nThe path\n4−1−2−3\nis a Hamiltonian path.\nIn the third test case, the graph consists of\n2\nvertices connected by an edge.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "graphs",
            "interactive",
            "*2900"
        ]
    },
    {
        "title": "E. Manhattan Triangle",
        "description": "The Manhattan distance between two points\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\nis defined as:\n|\nx\n1\n−\nx\n2\n|+|\ny\n1\n−\ny\n2\n|.\n|\n|\n|\n|\nWe call a Manhattan triangle three points on the plane, the Manhattan distances between each pair of which are equal.\nYou are given a set of pairwise distinct points and an even integer\nd\n. Your task is to find any Manhattan triangle, composed of three distinct points from the given set, where the Manhattan distance between any pair of vertices is equal to\nd\n.\nInput\nEach test consists of multiple test cases. The first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nd\n(\n3≤n≤2⋅\n10\n5\n,\n2≤d≤4⋅\n10\n5\n,\nd\nis even) — the number of points and the required Manhattan distance between the vertices of the triangle.\nThe\n(i+1)\n-th line of each test case contains two integers\nx\ni\nand\ny\ni\n(\n−\n10\n5\n≤\nx\ni\n,\ny\ni\n≤\n10\n5\n) — the coordinates of the\ni\n-th point. It is guaranteed that all points are pairwise distinct.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output three distinct integers\ni\n,\nj\n, and\nk\n(\n1≤i,j,k≤n\n) — the indices of the points forming the Manhattan triangle. If there is no solution, output \"\n0 0 0\n\" (without quotes).\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n6\n6 4\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n5 4\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n6 6\n3 1\n0 0\n0 -2\n5 -3\n3 -5\n2 -2\n4 4\n3 0\n0 3\n-3 0\n0 -3\n10 8\n2 1\n-5 -1\n-4 -1\n-5 -3\n0 1\n-2 5\n-4 4\n-4 2\n0 0\n-4 1\n4 400000\n100000 100000\n-100000 100000\n100000 -100000\n-100000 -100000\noutput\nCopy\n2 6 1\n4 3 5\n3 5 1\n0 0 0\n6 1 3\n0 0 0\nNote\nIn the first test case:\nPoints\nA\n,\nB\n, and\nF\nform a Manhattan triangle, the Manhattan distance between each pair of vertices is\n4\n. Points\nD\n,\nE\n, and\nF\ncan also be the answer.\nIn the third test case:\nPoints\nA\n,\nC\n, and\nE\nform a Manhattan triangle, the Manhattan distance between each pair of vertices is\n6\n.\nIn the fourth test case, there are no two points with a Manhattan distance of\n4\n, and therefore there is no suitable Manhattan triangle.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "geometry",
            "implementation",
            "two pointers",
            "*2400"
        ]
    },
    {
        "title": "D. Fixing a Binary String",
        "description": "You are given a binary string\ns\nof length\nn\n, consisting of zeros and ones. You can perform the following operation exactly once:\nChoose an integer\np\n(\n1≤p≤n\n).\nReverse the substring\ns\n1\ns\n2\n…\ns\np\n. After this step, the string\ns\n1\ns\n2\n…\ns\nn\nwill become\ns\np\ns\np−1\n…\ns\n1\ns\np+1\ns\np+2\n…\ns\nn\n.\nThen, perform a cyclic shift of the string\ns\nto the left\np\ntimes. After this step, the initial string\ns\n1\ns\n2\n…\ns\nn\nwill become\ns\np+1\ns\np+2\n…\ns\nn\ns\np\ns\np−1\n…\ns\n1\n.\nFor example, if you apply the operation to the string 110001100110 with\np=3\n, after the second step, the string will become 011001100110, and after the third step, it will become 001100110011.\nA string\ns\nis called\nk\n-proper if two conditions are met:\ns\n1\n=\ns\n2\n=…=\ns\nk\n;\ns\ni+k\n≠\ns\ni\nfor any\ni\n(\n1≤i≤n−k\n).\nFor example, with\nk=3\n, the strings 000, 111000111, and 111000 are\nk\n-proper, while the strings 000000, 001100, and 1110000 are not.\nYou are given an integer\nk\n, which is a divisor of\nn\n. Find an integer\np\n(\n1≤p≤n\n) such that after performing the operation, the string\ns\nbecomes\nk\n-proper, or determine that it is impossible. Note that if the string is initially\nk\n-proper, you still need to apply exactly one operation to it.\nInput\nEach test consists of multiple test cases. The first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n\n,\n2≤n≤\n10\n5\n) — the length of the string\ns\nand the value of\nk\n. It is guaranteed that\nk\nis a divisor of\nn\n.\nThe second line of each test case contains a binary string\ns\nof length\nn\n, consisting of the characters 0 and 1.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the value of\np\nto make the string\nk\n-proper, or\n−1\nif it is impossible.\nIf there are multiple solutions, output any of them.\nExample\ninput\nCopy\n7\n8 4\n11100001\n4 2\n1110\n12 3\n111000100011\n5 5\n00000\n6 1\n101001\n8 4\n01110001\n12 2\n110001100110\noutput\nCopy\n3\n-1\n7\n5\n4\n-1\n3\nNote\nIn the first test case, if you apply the operation with\np=3\n, after the second step of the operation, the string becomes 11100001, and after the third step, it becomes 00001111. This string is\n4\n-proper.\nIn the second test case, it can be shown that there is no operation after which the string becomes\n2\n-proper.\nIn the third test case, if you apply the operation with\np=7\n, after the second step of the operation, the string becomes 100011100011, and after the third step, it becomes 000111000111. This string is\n3\n-proper.\nIn the fourth test case, after the operation with any\np\n, the string becomes\n5\n-proper.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "dp",
            "greedy",
            "hashing",
            "strings",
            "*1800"
        ]
    },
    {
        "title": "C. Earning on Bets",
        "description": "You have been offered to play a game. In this game, there are\nn\npossible outcomes, and for each of them, you must bet a certain integer amount of coins. In the event that the\ni\n-th outcome turns out to be winning, you will receive back the amount of coins equal to your bet on that outcome, multiplied by\nk\ni\n. Note that exactly one of the\nn\noutcomes will be winning.\nYour task is to determine how to distribute the coins in such a way that you will come out ahead in the event of any winning outcome. More formally, the total amount of coins you bet on all outcomes must be strictly less than the number of coins received back for each possible winning outcome.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the number of outcomes.\nThe second line of each test case contains\nn\nintegers\nk\n1\n,\nk\n2\n,…,\nk\nn\n(\n2≤\nk\ni\n≤20\n) — the multiplier for the amount of coins if the\ni\n-th outcome turns out to be winning.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\n−1\nif there is no way to distribute the coins as required. Otherwise, output\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n1≤\nx\ni\n≤\n10\n9\n) — your bets on the outcomes.\nIt can be shown that if a solution exists, there is always a solution that satisfies these constraints.\nIf there are multiple suitable solutions, output any of them.\nExample\ninput\nCopy\n6\n3\n3 2 7\n2\n3 3\n5\n5 5 5 5 5\n6\n7 9 3 17 9 13\n3\n6 3 2\n5\n9 4 6 8 3\noutput\nCopy\n27 41 12 \n1 1 \n-1\n1989 1547 4641 819 1547 1071 \n-1\n8 18 12 9 24\nNote\nIn the first test case, the coins can be distributed as follows:\n27\ncoins on the first outcome,\n41\ncoins on the second outcome,\n12\ncoins on the third outcome. Then the total amount of coins bet on all outcomes is\n27+41+12=80\ncoins. If the first outcome turns out to be winning, you will receive back\n3⋅27=81\ncoins, if the second outcome turns out to be winning, you will receive back\n2⋅41=82\ncoins, if the third outcome turns out to be winning, you will receive back\n7⋅12=84\ncoins. All these values are strictly greater than\n80\n.\nIn the second test case, one way is to bet one coin on each of the outcomes.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "constructive algorithms",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "B. XOR Sequences",
        "description": "You are given two distinct non-negative integers\nx\nand\ny\n. Consider two infinite sequences\na\n1\n,\na\n2\n,\na\n3\n,…\nand\nb\n1\n,\nb\n2\n,\nb\n3\n,…\n, where\na\nn\n=n⊕x\n;\nb\nn\n=n⊕y\n.\nHere,\nx⊕y\ndenotes the bitwise XOR operation of integers\nx\nand\ny\n.\nFor example, with\nx=6\n, the first\n8\nelements of sequence\na\nwill look as follows:\n[7,4,5,2,3,0,1,14,…]\n. Note that the indices of elements start with\n1\n.\nYour task is to find the length of the longest common subsegment\n†\n†\nof sequences\na\nand\nb\n. In other words, find the maximum integer\nm\nsuch that\na\ni\n=\nb\nj\n,\na\ni+1\n=\nb\nj+1\n,…,\na\ni+m−1\n=\nb\nj+m−1\nfor some\ni,j≥1\n.\n†\n†\nA subsegment of sequence\np\nis a sequence\np\nl\n,\np\nl+1\n,…,\np\nr\n, where\n1≤l≤r\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nx\nand\ny\n(\n0≤x,y≤\n10\n9\n,x≠y\n) — the parameters of the sequences.\nOutput\nFor each test case, output a single integer — the length of the longest common subsegment.\nExample\ninput\nCopy\n4\n0 1\n12 4\n57 37\n316560849 14570961\noutput\nCopy\n1\n8\n4\n33554432\nNote\nIn the first test case, the first\n7\nelements of sequences\na\nand\nb\nare as follows:\na=[1,2,3,4,5,6,7,…]\nb=[0,3,2,5,4,7,6,…]\nIt can be shown that there isn't a positive integer\nk\nsuch that the sequence\n[k,k+1]\noccurs in\nb\nas a subsegment. So the answer is\n1\n.\nIn the third test case, the first\n20\nelements of sequences\na\nand\nb\nare as follows:\na=[56,59,58,61,60,63,62,49,48,51,50,53,52,55,54,41, 40, 43, 42,45,…]\nb=[36,39,38,33,32,35,34,45,44,47,46,41, 40, 43, 42,53,52,55,54,49,…]\nIt can be shown that one of the longest common subsegments is the subsegment\n[41,40,43,42]\nwith a length of\n4\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1000"
        ]
    },
    {
        "title": "A. Guess the Maximum",
        "description": "Alice and Bob came up with a rather strange game. They have an array of integers\na\n1\n,\na\n2\n,…,\na\nn\n. Alice chooses a certain integer\nk\nand tells it to Bob, then the following happens:\nBob chooses two integers\ni\nand\nj\n(\n1≤i<j≤n\n), and then finds the maximum among the integers\na\ni\n,\na\ni+1\n,…,\na\nj\n;\nIf the obtained maximum is strictly greater than\nk\n, Alice wins, otherwise Bob wins.\nHelp Alice find the maximum\nk\nat which she is guaranteed to win.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤5⋅\n10\n4\n) — the number of elements in the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n4\n.\nOutput\nFor each test case, output one integer — the maximum integer\nk\nat which Alice is guaranteed to win.\nExample\ninput\nCopy\n6\n4\n2 4 1 7\n5\n1 2 3 4 5\n2\n1 1\n3\n37 8 16\n5\n10 10 10 10 9\n10\n3 12 9 5 2 3 2 9 8 2\noutput\nCopy\n3\n1\n0\n15\n9\n2\nNote\nIn the first test case, all possible subsegments that Bob can choose look as follows:\n[2,4],[2,4,1],[2,4,1,7],[4,1],[4,1,7],[1,7]\n. The maximums on the subsegments are respectively equal to\n4,4,7,4,7,7\n. It can be shown that\n3\nis the largest integer such that any of the maximums will be strictly greater than it.\nIn the third test case, the only segment that Bob can choose is\n[1,1]\n. So the answer is\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F. Large Graph",
        "description": "Given an array\na\nof length\nn\n. Let's construct a square matrix\nb\nof size\nn×n\n, in which the\ni\n-th row contains the array\na\ncyclically shifted to the right by\n(i−1)\n. For example, for the array\na=[3,4,5]\n, the obtained matrix is\nb=\n⎡\n⎣\n⎢\n3\n5\n4\n4\n3\n5\n5\n4\n3\n⎤\n⎦\n⎥\n[\n]\nLet's construct the following graph:\nThe graph contains\nn\n2\nvertices, each of which corresponds to one of the elements of the matrix. Let's denote the vertex corresponding to the element\nb\ni,j\nas\n(i,j)\n.\nWe will draw an edge between vertices\n(\ni\n1\n,\nj\n1\n)\nand\n(\ni\n2\n,\nj\n2\n)\nif\n|\ni\n1\n−\ni\n2\n|+|\nj\n1\n−\nj\n2\n|≤k\nand\ngcd(\nb\ni\n1\n,\nj\n1\n,\nb\ni\n2\n,\nj\n2\n)>1\n, where\ngcd(x,y)\ndenotes the greatest common divisor of integers\nx\nand\ny\n.\nYour task is to calculate the number of connected components\n†\n†\nin the obtained graph.\n†\n†\nA connected component of a graph is a set of vertices in which any vertex is reachable from any other via edges, and adding any other vertex to the set violates this rule.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n2≤n≤\n10\n6\n,\n2≤k≤2⋅\n10\n6\n) — the length of the array and the parameter\nk\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the number of connected components in the obtained graph.\nExample\ninput\nCopy\n6\n3 3\n3 4 5\n3 3\n3 4 9\n3 2\n3 4 9\n2 2\n2 8\n5 3\n8 27 5 4 3\n4 10\n2 2 2 2\noutput\nCopy\n3\n2\n3\n1\n4\n1\nNote\nIn the first test case, the matrix\nb\nis given in the statement. The first connected component contains the vertices\n(1,1)\n,\n(2,2)\n, and\n(3,3)\n. The second connected component contains the vertices\n(1,2)\n,\n(2,3)\n, and\n(3,1)\n. The third connected component contains the vertices\n(1,3)\n,\n(2,1)\n, and\n(3,2)\n. Thus, the graph has\n3\nconnected components.\nIn the second test case, the following matrix is obtained:\nb=\n⎡\n⎣\n⎢\n3\n9\n4\n4\n3\n9\n9\n4\n3\n⎤\n⎦\n⎥\n[\n]\nThe first connected component contains all vertices corresponding to elements with values\n3\nand\n9\n. The second connected component contains all vertices corresponding to elements with the value\n4\n.\nIn the fourth test case, all vertices are in one connected component.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "number theory",
            "two pointers",
            "*2400"
        ]
    },
    {
        "title": "E. Computing Machine",
        "description": "Sasha has two binary strings\ns\nand\nt\nof the same length\nn\n, consisting of the characters 0 and 1.\nThere is also a computing machine that can perform two types of operations on binary strings\na\nand\nb\nof the same length\nk\n:\nIf\na\ni\n=\na\ni+2\n=\n0, then you can assign\nb\ni+1\n:=\n1 (\n1≤i≤k−2\n).\nIf\nb\ni\n=\nb\ni+2\n=\n1, then you can assign\na\ni+1\n:=\n1 (\n1≤i≤k−2\n).\nSasha became interested in the following: if we consider the string\na=\ns\nl\ns\nl+1\n…\ns\nr\nand the string\nb=\nt\nl\nt\nl+1\n…\nt\nr\n, what is the maximum number of 1 characters in the string\na\nthat can be obtained using the computing machine. Since Sasha is very curious but lazy, it is up to you to answer this question for several pairs\n(\nl\ni\n,\nr\ni\n)\nthat interest him.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the strings\ns\nand\nt\n.\nThe second line of each test case contains a binary string\ns\nof length\nn\n, consisting of the characters 0 and 1.\nThe third line of each test case contains a binary string\nt\nof length\nn\n, consisting of the characters 0 and 1.\nThe fourth line of each test case contains a single integer\nq\n(\n1≤q≤2⋅\n10\n5\n) — the number of queries.\nThe\ni\n-th of the following lines contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the boundaries of the\ni\n-th pair of substrings that interest Sasha.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nand the sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nq\nintegers — the answers to all queries.\nExample\ninput\nCopy\n3\n4\n1111\n0000\n2\n1 2\n2 4\n4\n1010\n1101\n2\n1 3\n1 4\n6\n010101\n011010\n5\n2 3\n1 6\n2 5\n4 4\n3 6\noutput\nCopy\n2\n3\n2\n3\n1\n4\n3\n1\n2\nNote\nIn the first test case:\nIn the first query,\na=\n11, so the maximum number of 1 characters is\n2\n.\nIn the second query,\na=\n111, so the maximum number of 1 characters is\n3\n.\nIn the second test case:\nIn the first query,\na=\n101 and\nb=\n110. No operations can be performed, so the maximum number of 1 characters is\n2\n.\nIn the second query,\na=\n1010 and\nb=\n1101. Since\na\n2\n=\na\n4\n=\n0, we can assign\nb\n3\n:=\n1. Now\nb\n1\n=\nb\n3\n=\n1, so we can assign\na\n2\n:=\n1. The string\na\nbecomes 1110, so the maximum number of 1 characters is\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "*2000"
        ]
    },
    {
        "title": "D. Elections",
        "description": "Elections are taking place in Berland. There are\nn\ncandidates participating in the elections, numbered from\n1\nto\nn\n. The\ni\n-th candidate has\na\ni\nfans who will vote for him. Additionally, there are\nc\npeople who are undecided about their favorite candidate, let's call them undecided. Undecided people will vote for the candidate with the lowest number.\nThe candidate who receives the maximum number of votes wins the elections, and if multiple candidates receive the same maximum number of votes, the candidate with the lowest number among them wins.\nYou found these elections too boring and predictable, so you decided to exclude some candidates from them. If you do not allow candidate number\ni\nto participate in the elections, all\na\ni\nof his fans will become undecided, and will vote for the candidate with the lowest number.\nYou are curious to find, for each\ni\nfrom\n1\nto\nn\n, the minimum number of candidates that need to be excluded from the elections for candidate number\ni\nto win the elections.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nc\n(\n1≤n≤2⋅\n10\n5\n,\n0≤c≤\n10\n9\n) — the number of candidates in the elections and the number of undecided people.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the number of fans for each candidate.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers, the\ni\n-th of which should be equal to the minimum number of candidates that need to be excluded from the elections for candidate number\ni\nto win.\nExample\ninput\nCopy\n5\n3 1\n2 0 3\n2 3\n0 10\n5 3\n5 4 3 2 1\n4 5\n3 10 7 1\n6 0\n2 2 2 3 3 3\noutput\nCopy\n0 1 2\n1 0\n0 1 2 3 4\n1 0 2 3\n1 1 2 0 4 5\nNote\nIn the first test case:\nIf all candidates are allowed, candidate number\n1\nwill receive\n3\nvotes (\n1\nundecided person will vote for him), candidate number\n2\nwill receive\n0\nvotes, and candidate number\n3\nwill receive\n3\nvotes. Therefore, candidate number\n1\nwins (he received the same number of votes as candidate\n3\n, but his number is lower), so the answer for him is\n0\n.\nIf candidate number\n1\nis not allowed, his\n2\nfans will become undecided. Then candidate number\n2\nwill receive\n3\nvotes (\n3\nundecided people will vote for him) and candidate number\n3\nwill receive\n3\nvotes. Therefore, candidate number\n2\nwins (he received the same number of votes as candidate\n3\n, but his number is lower), so the answer for him is\n1\n.\nIf candidates with numbers\n1\nand\n2\nare not allowed, candidate number\n3\nwins, so the answer for him is\n2\n.\nIn the second test case, candidate number\n1\nwill win if candidate number\n2\nis not allowed to participate.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "C. Manhattan Permutations",
        "description": "Let's call the Manhattan value of a permutation\n†\n†\np\nthe value of the expression\n|\np\n1\n−1|+|\np\n2\n−2|+…+|\np\nn\n−n|\n.\nFor example, for the permutation\n[1,2,3]\n, the Manhattan value is\n|1−1|+|2−2|+|3−3|=0\n, and for the permutation\n[3,1,2]\n, the Manhattan value is\n|3−1|+|1−2|+|2−3|=2+1+1=4\n.\nYou are given integers\nn\nand\nk\n. Find a permutation\np\nof length\nn\nsuch that its Manhattan value is equal to\nk\n, or determine that no such permutation exists.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,0≤k≤\n10\n12\n) — the length of the permutation and the required Manhattan value.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if there is no suitable permutation, output \"No\". Otherwise, in the first line, output \"Yes\", and in the second line, output\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — a suitable permutation.\nIf there are multiple solutions, output any of them.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n8\n3 4\n4 5\n7 0\n1 1000000000000\n8 14\n112 777\n5 12\n5 2\noutput\nCopy\nYes\n3 1 2\nNo\nYes\n1 2 3 4 5 6 7\nNo\nYes\n8 2 3 4 5 6 1 7\nNo\nYes\n5 4 3 1 2\nYes\n2 1 3 4 5\nNote\nIn the first test case, the permutation\n[3,1,2]\nis suitable, its Manhattan value is\n|3−1|+|1−2|+|2−3|=2+1+1=4\n.\nIn the second test case, it can be proven that there is no permutation of length\n4\nwith a Manhattan value of\n5\n.\nIn the third test case, the permutation\n[1,2,3,4,5,6,7]\nis suitable, its Manhattan value is\n|1−1|+|2−2|+|3−3|+|4−4|+|5−5|+|6−6|+|7−7|=0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. New Bakery",
        "description": "Bob decided to open a bakery. On the opening day, he baked\nn\nbuns that he can sell. The usual price of a bun is\na\ncoins, but to attract customers, Bob organized the following promotion:\nBob chooses some integer\nk\n(\n0≤k≤min(n,b)\n).\nBob sells the first\nk\nbuns at a modified price. In this case, the price of the\ni\n-th (\n1≤i≤k\n) sold bun is\n(b−i+1)\ncoins.\nThe remaining\n(n−k)\nbuns are sold at\na\ncoins each.\nNote that\nk\ncan be equal to\n0\n. In this case, Bob will sell all the buns at\na\ncoins each.\nHelp Bob determine the maximum profit he can obtain by selling all\nn\nbuns.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains three integers\nn\n,\na\n, and\nb\n(\n1≤n,a,b≤\n10\n9\n) — the number of buns, the usual price of a bun, and the price of the first bun to be sold at a modified price.\nOutput\nFor each test case, output a single integer — the maximum profit that Bob can obtain.\nExample\ninput\nCopy\n7\n4 4 5\n5 5 9\n10 10 5\n5 5 11\n1000000000 1000000000 1000000000\n1000000000 1000000000 1\n1000 1 1000\noutput\nCopy\n17\n35\n100\n45\n1000000000000000000\n1000000000000000000\n500500\nNote\nIn the first test case, it is optimal for Bob to choose\nk=1\n. Then he will sell one bun for\n5\ncoins, and three buns at the usual price for\n4\ncoins each. Then the profit will be\n5+4+4+4=17\ncoins.\nIn the second test case, it is optimal for Bob to choose\nk=5\n. Then he will sell all the buns at the modified price and obtain a profit of\n9+8+7+6+5=35\ncoins.\nIn the third test case, it is optimal for Bob to choose\nk=0\n. Then he will sell all the buns at the usual price and obtain a profit of\n10⋅10=100\ncoins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "ternary search",
            "*800"
        ]
    },
    {
        "title": "A. Alice and Books",
        "description": "Alice has\nn\nbooks. The\n1\n-st book contains\na\n1\npages, the\n2\n-nd book contains\na\n2\npages,\n…\n, the\nn\n-th book contains\na\nn\npages. Alice does the following:\nShe divides all the books into two non-empty piles. Thus, each book ends up in exactly one of the two piles.\nAlice reads one book with the highest number in each pile.\nAlice loves reading very much. Help her find the maximum total number of pages she can read by dividing the books into two piles.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤100\n) — the number of books Alice has.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of pages in each book.\nOutput\nFor each test case, output a single integer — the maximum number of pages Alice can read.\nExample\ninput\nCopy\n5\n2\n1 1\n4\n2 3 3 1\n5\n2 2 3 2 2\n2\n10 3\n3\n1 2 3\noutput\nCopy\n2\n4\n5\n13\n5\nNote\nIn the first test case, Alice can put book number\n1\nin the first pile, and book number\n2\nin the second pile. Then she will read\na\n1\n+\na\n2\n=1+1=2\npages.\nIn the second test case, Alice can put books with numbers\n2\nand\n3\nin the first pile, and books with numbers\n1\nand\n4\nin the second pile. Then she will read the book with the highest number\n3\nfrom the first pile, and the book with the highest number\n4\nfrom the second pile. Then she will read\na\n3\n+\na\n4\n=3+1=4\npages.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "E. Tensor",
        "description": "This is an interactive problem.\nYou are given an integer\nn\n.\nThe jury has hidden from you a directed graph with\nn\nvertices (numbered from\n1\nto\nn\n) and some number of edges. You additionally know that:\nThe graph only contains edges of the form\ni←j\n, where\n1≤i<j≤n\n.\nFor any three vertices\n1≤i<j<k≤n\n, at least one of the following holds\n†\n†\n:\nVertex\ni\nis reachable from vertex\nj\n, or\nVertex\ni\nis reachable from vertex\nk\n, or\nVertex\nj\nis reachable from vertex\nk\n.\nYou want to color each vertex in either black or white such that for any two vertices\ni\nand\nj\n(\n1≤i<j≤n\n) of the same color, vertex\ni\nis reachable from vertex\nj\n.\nTo do that, you can ask queries of the following type:\n? i j — is vertex\ni\nreachable from vertex\nj\n(\n1≤i<j≤n\n)?\nFind any valid vertex coloring of the hidden graph in at most\n2⋅n\nqueries. It can be proven that such a coloring always exists.\nNote that the grader is not adaptive: the graph is fixed before any queries are made.\n†\n†\nVertex\na\nis reachable from vertex\nb\nif there exists a path from vertex\nb\nto vertex\na\nin the graph.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single integer\nn\n(\n3≤n≤100\n) — the number of vertices in the hidden graph.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n1000\n.\nInteraction\nThe interaction for each test case begins by reading the integer\nn\n.\nTo make a query, output \"? i j\" without quotes (\n1≤i<j≤n\n). If vertex\ni\nis reachable from vertex\nj\n, you will get YES as an answer. Otherwise, you will get NO as an answer.\nIf you receive the integer\n−1\ninstead of an answer or a valid value of\nn\n, it means your program has made an invalid query, has exceeded the limit of queries, or has given an incorrect answer on the previous test case. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nWhen you are ready to give the final answer, output \"!\nc\n1\n c\n2\n … \nc\nn\n\" without quotes — the colors of the vertices, where\nc\ni\n=0\nif the vertex is black, and\nc\ni\n=1\nif the vertex is white. After solving all test cases, your program should be terminated immediately.\nAfter printing a query, do not forget to output an end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nHacks\nTo hack, use the following format:\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n3≤n≤100\n,\n0≤m≤\nn⋅(n−1)\n2\n) — the number of vertices and edges in the graph.\nEach of the following\nm\nlines should contain two integers\na\nand\nb\n(\n1≤b<a≤n\n), indicating that there is the edge\na→b\nin the graph. The graph should satisfy the conditions above.\nThe sum of\nn\nover all test cases should not exceed\n1000\n.\nExample\ninput\nCopy\n2\n4\n\nYES\n\nYES\n\nYES\n\nNO\n\nNO\n\nNO\n\n5\noutput\nCopy\n? 1 2\n\n? 2 3\n\n? 1 3\n\n? 1 4\n\n? 2 4\n\n? 3 4\n\n! 0 0 0 1\n\n! 1 1 0 1 0\nNote\nThe hidden graph in the first test case:\nThe hidden graph in the second test case:\nThe interaction happens as follows:\nSolution Jury Explanation\n2 There are\n2\ntest cases.\n4 In the first test case, the graph has\n4\nvertices.\n? 1 2 YES The solution asks if vertex\n1\nis reachable from vertex\n2\n, and the jury answers YES.\n? 2 3 YES The solution asks if vertex\n2\nis reachable from vertex\n3\n, and the jury answers YES.\n? 1 3 YES The solution asks if vertex\n1\nis reachable from vertex\n3\n, and the jury answers YES.\n? 1 4 NO The solution asks if vertex\n1\nis reachable from vertex\n4\n, and the jury answers NO.\n? 2 4 NO The solution asks if vertex\n2\nis reachable from vertex\n4\n, and the jury answers NO.\n? 3 4 NO The solution asks if vertex\n3\nis reachable from vertex\n4\n, and the jury answers NO.\n! 0 0 0 1 The solution has somehow determined a valid coloring and outputs it. Since the output is correct, the jury continues to the next test case.\n5 In the second test case, the graph has\n5\nvertices.\n! 1 1 0 1 0 The solution has somehow determined a valid coloring, and outputs it. Since the output is correct and there are no more test cases, the jury and the solution exit.\nNote that the line breaks in the example input and output are for the sake of clarity, and do not occur in the real interaction.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "interactive",
            "*2600"
        ]
    },
    {
        "title": "D. XORificator",
        "description": "You are given a binary (consisting only of 0s and 1s)\nn×m\nmatrix. You are also given a XORificator, using which you can invert all the values in a chosen row (i.e. replace 0 with 1 and 1 with 0).\nA column in the matrix is considered special if it contains exactly one 1. Your task is to find the maximum number of columns that can be made special at the same time, and the set of rows the XORificator should be used on to achieve that.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤3⋅\n10\n5\n,\nn⋅m≤3⋅\n10\n5\n).\nEach of the following\nn\nlines of the test case contains a binary string of length\nm\n.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output two lines.\nIn the first line, output the maximum number of special columns that is possible to get simultaneously.\nIn the second line, output a binary string of length\nn\n, where the\ni\n-th character is 0, if you don't use the XORificator on the\ni\n-th row, and 1, if you use the XORificator on the\ni\n-th row.\nIf there are multiple valid XORificator configurations that achieve the optimal answer, you can output any of them.\nExample\ninput\nCopy\n5\n3 4\n1010\n0110\n0100\n1 1\n1\n1 1\n0\n2 5\n00101\n10110\n3 3\n101\n111\n000\noutput\nCopy\n3\n010\n1\n0\n1\n1\n3\n00\n2\n010\nNote\nIn the first test case, you can use the XORificator on the second row to make the columns\n2\n,\n3\n, and\n4\nspecial.\nIn the second test case, the only column is already special, so you don't need to use the XORificator.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "hashing",
            "*2300"
        ]
    },
    {
        "title": "C. Nikita and LCM",
        "description": "Nikita is a student passionate about number theory and algorithms. He faces an interesting problem related to an array of numbers.\nSuppose Nikita has an array of integers\na\nof length\nn\n. He will call a subsequence\n†\n†\nof the array special if its least common multiple (LCM) is not contained in\na\n. The LCM of an empty subsequence is equal to\n0\n.\nNikita wonders: what is the length of the longest special subsequence of\na\n? Help him answer this question!\n†\n†\nA sequence\nb\nis a subsequence of\na\nif\nb\ncan be obtained from\na\nby the deletion of several (possibly, zero or all) elements, without changing the order of the remaining elements. For example,\n[5,2,3]\nis a subsequence of\n[1,5,7,8,2,4,3]\n.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤2000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2000\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output a single integer — the length of the longest special subsequence of\na\n.\nExample\ninput\nCopy\n6\n5\n1 2 4 8 16\n6\n3 2 10 20 60 1\n7\n2 3 4 6 12 100003 1200036\n9\n2 42 7 3 6 7 7 1 6\n8\n4 99 57 179 10203 2 11 40812\n1\n1\noutput\nCopy\n0\n4\n4\n5\n8\n0\nNote\nIn the first test case, the LCM of any non-empty subsequence is contained in\na\n, so the answer is\n0\n.\nIn the second test case, we can take the subsequence\n[3,2,10,1]\n, its LCM is equal to\n30\n, which is not contained in\na\n.\nIn the third test case, we can take the subsequence\n[2,3,6,100003]\n, its LCM is equal to\n600018\n, which is not contained in\na\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "math",
            "number theory",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "B. Binary Colouring",
        "description": "You are given a positive integer\nx\n. Find any array of integers\na\n0\n,\na\n1\n,…,\na\nn−1\nfor which the following holds:\n1≤n≤32\n,\na\ni\nis\n1\n,\n0\n, or\n−1\nfor all\n0≤i≤n−1\n,\nx=\n∑\ni=0\nn−1\na\ni\n⋅\n2\ni\n,\nThere does not exist an index\n0≤i≤n−2\nsuch that both\na\ni\n≠0\nand\na\ni+1\n≠0\n.\nIt can be proven that under the constraints of the problem, a valid array always exists.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single positive integer\nx\n(\n1≤x<\n2\n30\n).\nOutput\nFor each test case, output two lines.\nOn the first line, output an integer\nn\n(\n1≤n≤32\n) — the length of the array\na\n0\n,\na\n1\n,…,\na\nn−1\n.\nOn the second line, output the array\na\n0\n,\na\n1\n,…,\na\nn−1\n.\nIf there are multiple valid arrays, you can output any of them.\nExample\ninput\nCopy\n7\n1\n14\n24\n15\n27\n11\n19\noutput\nCopy\n1\n1\n5\n0 -1 0 0 1\n6\n0 0 0 -1 0 1\n5\n-1 0 0 0 1\n6\n-1 0 -1 0 0 1\n5\n-1 0 -1 0 1\n5\n-1 0 1 0 1\nNote\nIn the first test case, one valid array is\n[1]\n, since\n(1)⋅\n2\n0\n=1\n.\nIn the second test case, one possible valid array is\n[0,−1,0,0,1]\n, since\n(0)⋅\n2\n0\n+(−1)⋅\n2\n1\n+(0)⋅\n2\n2\n+(0)⋅\n2\n3\n+(1)⋅\n2\n4\n=−2+16=14\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Little Nikita",
        "description": "The little boy Nikita was given some cubes as a present. He decided to build a tower out of them.\nInitially, the tower doesn't have any cubes. In one move, Nikita either puts exactly\n1\ncube on top of the tower or removes exactly\n1\ncube from the top of the tower. Is it possible that after\nn\nmoves, the resulting tower has exactly\nm\ncubes?\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤100\n).\nOutput\nFor each test case, output \"Yes\" (without quotes) if Nikita can obtain a tower with\nm\ncubes, and \"No\" (without quotes) otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n3\n3 3\n2 4\n5 3\noutput\nCopy\nYes\nNo\nYes\nNote\nIn the first test case, Nikita can put\n1\ncube on top of the tower\n3\ntimes in a row, so the answer is \"Yes\".\nIn the second test case, Nikita can only end up with either a tower with no blocks or a tower with\n2\nblocks, so the answer is \"No\".",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Remove Bridges",
        "description": "You are given a rooted tree, consisting of\nn\nvertices, numbered from\n1\nto\nn\n. Vertex\n1\nis the root. Additionally, the root only has one child.\nYou are asked to add exactly\nk\nedges to the tree (possibly, multiple edges and/or edges already existing in the tree).\nRecall that a bridge is such an edge that, after you remove it, the number of connected components in the graph increases. So, initially, all edges of the tree are bridges.\nAfter\nk\nedges are added, some original edges of the tree are still bridges and some are not anymore. You want to satisfy two conditions:\nfor every bridge, all tree edges in the subtree of the lower vertex of that bridge should also be bridges;\nthe number of bridges is as small as possible.\nSolve the task for all values of\nk\nfrom\n1\nto\nn−1\nand output the smallest number of bridges.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n2≤n≤3⋅\n10\n5\n) — the number of vertices of the tree.\nEach of the next\nn−1\nlines contain two integers\nv\nand\nu\n(\n1≤v,u≤n\n) — the description of the edges of the tree. It's guaranteed that the given edges form a valid tree.\nAdditional constraint on the input: the root (vertex\n1\n) has exactly one child.\nThe sum of\nn\nover all testcases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each testcase, print\nn−1\nintegers. For each\nk\nfrom\n1\nto\nn−1\nprint the smallest number of bridges that can be left after you add\nk\nedges to the tree.\nExample\ninput\nCopy\n4\n2\n1 2\n12\n4 10\n5 12\n12 11\n3 6\n9 6\n1 6\n12 7\n11 6\n2 11\n10 9\n10 8\n8\n1 2\n2 3\n2 4\n3 5\n3 6\n4 7\n4 8\n5\n1 2\n2 3\n3 4\n4 5\noutput\nCopy\n0 \n7 3 1 0 0 0 0 0 0 0 0 \n4 1 0 0 0 0 0 \n0 0 0 0 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "greedy",
            "sortings",
            "trees",
            "*2800"
        ]
    },
    {
        "title": "E. Splittable Permutations",
        "description": "Initially, we had one array, which was a permutation of size\nn\n(an array of size\nn\nwhere each integer from\n1\nto\nn\nappears exactly once).\nWe performed\nq\noperations. During the\ni\n-th operation, we did the following:\nchoose any array we have with at least\n2\nelements;\nsplit it into two non-empty arrays (prefix and suffix);\nwrite two integers\nl\ni\nand\nr\ni\n, where\nl\ni\nis the maximum element in the left part which we get after the split, and\nr\ni\nis the maximum element in the right part;\nremove the array we've chosen from the pool of arrays we can use, and add the two resulting parts into the pool.\nFor example, suppose the initial array was\n[6,3,4,1,2,5]\n, and we performed the following operations:\nchoose the array\n[6,3,4,1,2,5]\nand split it into\n[6,3]\nand\n[4,1,2,5]\n. Then we write\nl\n1\n=6\nand\nr\n1\n=5\n, and the arrays we have are\n[6,3]\nand\n[4,1,2,5]\n;\nchoose the array\n[4,1,2,5]\nand split it into\n[4,1,2]\nand\n[5]\n. Then we write\nl\n2\n=4\nand\nr\n2\n=5\n, and the arrays we have are\n[6,3]\n,\n[4,1,2]\nand\n[5]\n;\nchoose the array\n[4,1,2]\nand split it into\n[4]\nand\n[1,2]\n. Then we write\nl\n3\n=4\nand\nr\n3\n=2\n, and the arrays we have are\n[6,3]\n,\n[4]\n,\n[1,2]\nand\n[5]\n.\nYou are given two integers\nn\nand\nq\n, and two sequences\n[\nl\n1\n,\nl\n2\n,…,\nl\nq\n]\nand\n[\nr\n1\n,\nr\n2\n,…,\nr\nq\n]\n. A permutation of size\nn\nis called valid if we can perform\nq\noperations and produce the given sequences\n[\nl\n1\n,\nl\n2\n,…,\nl\nq\n]\nand\n[\nr\n1\n,\nr\n2\n,…,\nr\nq\n]\n.\nCalculate the number of valid permutations.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤q<n≤3⋅\n10\n5\n).\nThe second line contains\nq\nintegers\nl\n1\n,\nl\n2\n,…,\nl\nq\n(\n1≤\nl\ni\n≤n\n).\nThe third line contains\nq\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nq\n(\n1≤\nr\ni\n≤n\n).\nAdditional constraint on the input: there exists at least one permutation which can produce the given sequences\n[\nl\n1\n,\nl\n2\n,…,\nl\nq\n]\nand\n[\nr\n1\n,\nr\n2\n,…,\nr\nq\n]\n.\nOutput\nPrint one integer — the number of valid permutations, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n6 3\n6 4 4\n5 5 2\noutput\nCopy\n30\ninput\nCopy\n10 1\n10\n9\noutput\nCopy\n1814400\ninput\nCopy\n4 1\n2\n4\noutput\nCopy\n8",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "dfs and similar",
            "greedy",
            "math",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "D. Invertible Bracket Sequences",
        "description": "A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters '1' and '+' between the original characters of the sequence. For example:\nbracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\");\nbracket sequences \")(\", \"(\" and \")\" are not.\nLet's define the inverse of the bracket sequence as follows: replace all brackets '(' with ')', and vice versa (all brackets ')' with '('). For example, strings \"()((\" and \")())\" are inverses of each other.\nYou are given a regular bracket sequence\ns\n. Calculate the number of pairs of integers\n(l,r)\n(\n1≤l≤r≤|s|\n) such that if you replace the substring of\ns\nfrom the\nl\n-th character to the\nr\n-th character (inclusive) with its inverse,\ns\nwill still be a regular bracket sequence.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a non-empty regular bracket sequence; it consists only of characters '(' and/or ')'.\nAdditional constraint on the input: the total length of the regular bracket sequences over all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the number of pairs\n(l,r)\nmeeting the conditions from the statement.\nExample\ninput\nCopy\n4\n(())\n()\n()()()\n(()())(())\noutput\nCopy\n1\n0\n3\n13\nNote\nIn the first example, there is only one pair:\n(2,3)\n: (())\n→\n()().\nIn the second example, there are no pairs.\nIn the third example, there are three pairs:\n(2,3)\n: ()()()\n→\n(())();\n(4,5)\n: ()()()\n→\n()(());\n(2,5)\n: ()()()\n→\n(()());",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "data structures",
            "divide and conquer",
            "implementation",
            "two pointers",
            "*2000"
        ]
    },
    {
        "title": "C. Job Interview",
        "description": "Monocarp is opening his own IT company. He wants to hire\nn\nprogrammers and\nm\ntesters.\nThere are\nn+m+1\ncandidates, numbered from\n1\nto\nn+m+1\nin chronological order of their arriving time. The\ni\n-th candidate has programming skill\na\ni\nand testing skill\nb\ni\n(a person's programming skill is different from their testing skill). The skill of the team is the sum of the programming skills of all candidates hired as programmers, and the sum of the testing skills of all candidates hired as testers.\nWhen a candidate arrives to interview, Monocarp tries to assign them to the most suitable position for them (if their programming skill is higher, then he hires them as a programmer, otherwise as a tester). If all slots for that position are filled, Monocarp assigns them to the other position.\nYour task is, for each candidate, calculate the skill of the team if everyone except them comes to interview. Note that it means that exactly\nn+m\ncandidates will arrive, so all\nn+m\npositions in the company will be filled.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains two integers\nn\nand\nm\n(\n0≤n,m≤2⋅\n10\n5\n;\n2≤n+m+1≤2⋅\n10\n5\n) — the number of programmers and the number of testers Monocarp wants to hire, respectively;\nthe second line contains\nn+m+1\nintegers\na\n1\n,\na\n2\n,…,\na\nn+m+1\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the programming skill of the\ni\n-th candidate;\nthe third line contains\nn+m+1\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn+m+1\n(\n1≤\nb\ni\n≤\n10\n9\n;\nb\ni\n≠\na\ni\n), where\nb\ni\nis the testing skill of the\ni\n-th candidate.\nAdditional constraint on the input: the sum of\n(n+m+1)\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print\nn+m+1\nintegers, where the\ni\n-th integer should be equal to the skill of the team if everyone except the\ni\n-th candidate comes to interview.\nExample\ninput\nCopy\n4\n1 0\n2 1\n1 2\n0 2\n4 5 5\n5 4 1\n1 2\n2 1 5 4\n5 2 3 1\n3 1\n4 3 3 4 1\n5 5 4 5 2\noutput\nCopy\n1 2 \n5 6 9 \n8 11 11 12 \n13 13 13 12 15 \nNote\nLet's consider the third test case of the example:\nif the\n1\n-st candidate does not arrive, the\n2\n-nd candidate gets hired as a tester, the\n3\n-rd candidate gets hired as a programmer, the\n4\n-th candidate gets hired as a tester. The total skill of the team will be\n2+5+1=8\n;\nif the\n2\n-nd candidate does not arrive, the\n1\n-st candidate gets hired as a tester, the\n3\n-rd candidate gets hired as a programmer, the\n4\n-th candidate gets hired as a tester. The total skill of the team will be\n5+5+1=11\n;\nif the\n3\n-rd candidate does not arrive, the\n1\n-st candidate gets hired as a tester, the\n2\n-nd candidate gets hired as a tester, the\n4\n-th candidate gets hired as a programmer. The total skill of the team will be\n5+2+4=11\n;\nif the\n4\n-th candidate does not arrive, the\n1\n-st candidate gets hired as a tester, the\n2\n-nd candidate gets hired as a tester, the\n3\n-rd candidate gets hired as a programmer. The total skill of the team will be\n5+2+5=12\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "implementation",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "B. Increase/Decrease/Copy",
        "description": "You are given two integer arrays: array\na\nof length\nn\nand array\nb\nof length\nn+1\n.\nYou can perform the following operations any number of times in any order:\nchoose any element of the array\na\nand increase it by\n1\n;\nchoose any element of the array\na\nand decrease it by\n1\n;\nchoose any element of the array\na\n, copy it and append the copy to the end of the array\na\n.\nYour task is to calculate the minimum number of aforementioned operations (possibly zero) required to transform the array\na\ninto the array\nb\n. It can be shown that under the constraints of the problem, it is always possible.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n);\nthe third line contains\nn+1\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn+1\n(\n1≤\nb\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum number of operations (possibly zero) required to transform the array\na\ninto the array\nb\n.\nExample\ninput\nCopy\n3\n1\n2\n1 3\n2\n3 3\n3 3 3\n4\n4 2 1 2\n2 1 5 2 3\noutput\nCopy\n3\n1\n8\nNote\nIn the first example, you can transform\na\ninto\nb\nas follows:\n[2]→[2,2]→[1,2]→[1,3]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "A. Verify Password",
        "description": "Monocarp is working on his new site, and the current challenge is to make the users pick strong passwords.\nMonocarp decided that strong passwords should satisfy the following conditions:\npassword should consist only of lowercase Latin letters and digits;\nthere should be no digit that comes after a letter (so, after each letter, there is either another letter or the string ends);\nall digits should be sorted in the non-decreasing order;\nall letters should be sorted in the non-decreasing order.\nNote that it's allowed for the password to have only letters or only digits.\nMonocarp managed to implement the first condition, but he struggles with the remaining ones. Can you help him to verify the passwords?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n1≤n≤20\n) — the length of the password.\nThe second line contains a string, consisting of exactly\nn\ncharacters. Each character is either a lowercase Latin letter or a digit.\nOutput\nFor each testcase, print \"YES\" if the given password is strong and \"NO\" otherwise.\nExample\ninput\nCopy\n5\n4\n12ac\n5\n123wa\n9\nallllmost\n5\nac123\n6\n011679\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the second testcase, the letters are not sorted in the non-decreasing order.\nIn the fourth testcase, there is a digit that comes after a letter — digit '1' after a letter 'c'.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "strings",
            "*800"
        ]
    },
    {
        "title": "I. Mind Bloom",
        "description": "This is the way it always was.\nThis is the way it always will be.\nAll will be forgotten again soon...\nJellyfish is playing a one-player card game called \"Slay the Spire\". There are\nn\ncards in total numbered from\n1\nto\nn\n. The\ni\n-th card has power\nci\n.\nThere is a binary string\ns\nof length\nn\n. If\nsi=0\n, the\ni\n-th card is initially in the draw pile. If\nsi=1\n, the\ni\n-th card is initially in Jellyfish's hand.\nJellyfish will repeat the following process until either her hand or the draw pile is empty.\nLet\nx\nbe the power of the card with the largest power in her hand.\nPlace a single card with power\nx\nback into the draw pile.\nRandomly draw\nx\ncards from the draw pile. All subsets of\nx\ncards from the draw pile have an equal chance of being drawn. If there are fewer than\nx\ncards in the draw pile, Jellyfish will draw all cards.\nAt the end of this process, find the probability that Jellyfish can empty the draw pile, modulo\n1000000007\n.\nFormally, let\nM=1000000007\n. It can be shown that the answer can be expressed as an irreducible fraction\np\nq\n, where\np\nand\nq\nare integers and\nq≢0(modM)\n. Output the integer equal to\np⋅q−1modM\n. In other words, output such an integer\nx\nthat\n0≤x<M\nand\nx⋅q≡p(modM)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤120\n) — the number of cards.\nThe second line of each test case contains\nn\nintegers\nc1,c2,…,cn\n(\n0≤ci≤n\n) — the powers of the cards. It is guaranteed that\nc1≤c2≤…≤cn\n.\nThe third line of each test case contains a binary string\ns\nof length\nn\n. If\nsi=0\n, the\ni\n-th card is initially in the draw pile. If\nsi=1\n, the\ni\n-th card is initially in Jellyfish's hand.\nIt is guaranteed that the sum of\nn2\nover all test cases does not exceed\n1202\n.\nOutput\nFor each test case, output the probability that Jellyfish can empty the draw pile modulo\n1000000007\n.\nExample\ninput\nCopy\n4\n5\n0 1 1 1 2\n00100\n3\n2 3 3\n000\n10\n0 0 0 0 0 0 0 1 1 1\n1111011111\n20\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 3 3 4\n00000000001000101010\noutput\nCopy\n500000004\n0\n0\n675898154\nNote\nIn the first test case, Jellyfish will keep playing cards with power\n1\nuntil Jellyfish draws a card with power\n0\nor power\n2\n. If Jellyfish draws a card with power\n0\n, she will eventually empty her hand. If Jellyfish draws a card with power\n2\n, she will eventually empty the draw pile. Since there is an equal chance of drawing\n0\nor\n2\n, the answer is\n1\n2\n, and\n2⋅500000004≡1(mod109+7)",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "dp",
            "*3500"
        ]
    },
    {
        "title": "H. 378QAQ and Core",
        "description": "378QAQ has a string\ns\nof length\nn\n. Define the core of a string as the substring\n†\n†\nwith maximum lexicographic\n‡\n‡\norder.\nFor example, the core of \"\nbazoka\n\" is \"\nzoka\n\", and the core of \"\naaa\n\" is \"\naaa\n\".\n378QAQ wants to rearrange the string\ns\nso that the core is lexicographically minimum. Find the lexicographically minimum possible core over all rearrangements of\ns\n.\n†\n†\nA substring of string\ns\nis a continuous segment of letters from\ns\n. For example, \"\ndefor\n\", \"\ncode\n\" and \"\no\n\" are all substrings of \"\ncodeforces\n\" while \"\ncodes\n\" and \"\naaa\n\" are not.\n‡\n‡\nA string\np\nis lexicographically smaller than a string\nq\nif and only if one of the following holds:\np\nis a prefix of\nq\n, but\np≠q\n; or\nin the first position where\np\nand\nq\ndiffer, the string\np\nhas a smaller element than the corresponding element in\nq\n(when compared by their ASCII code).\nFor example, \"\ncode\n\" and \"\ncoda\n\" are both lexicographically smaller than \"\ncodeforces\n\" while \"\ncodeforceston\n\" and \"\nz\n\" are not.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the length of string\ns\n.\nThe next line of each test case contains the string\ns\nof length\nn\n. The string\ns\nconsists of lowercase English letters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output the lexicographically minimum possible core over all rearrangements of\ns\n.\nExample\ninput\nCopy\n6\n3\nqaq\n4\ncccc\n6\nbazoka\n6\nzazzzz\n7\nababbbb\n7\nccbabcc\noutput\nCopy\nqaq\ncccc\nz\nzzz\nbbababb\ncbcacbc\nNote\nIn the first test case, all possible rearrangements and their corresponding cores are as follows:\n\"\nqaq\n\", its core is \"\nqaq\n\".\n\"\naqq\n\", its core is \"\nqq\n\".\n\"\nqqa\n\", its core is \"\nqqa\n\".\nSo the core with the minimum lexicographic order in all rearrangement plans is \"\nqaq\n\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*3500"
        ]
    },
    {
        "title": "G. Zimpha Fan Club",
        "description": "One day, Zimpha casually came up with a problem. As a member of \"Zimpha fan club\", you decided to solve that problem.\nYou are given two strings\ns\nand\nt\nof length\nn\nand\nm\n, respectively. Both strings only consist of lowercase English letters, - and *.\nYou need to replace all occurrences of * and -, observing the following rules:\nFor each -, you must replace it with any lowercase English letter.\nFor each *, you must replace it with a string of any (possibly, zero) length which only consists of lowercase English letters.\nNote that you can replace two different instances of - with different characters. You can also replace each two different instances of * with different strings.\nSuppose\ns\nand\nt\nhave been transformed into\ns′\nand\nt′\n. Now you're wondering if there's a replacement that makes\ns′=t′\n.\nInput\nThe first line of input contains two integers\nn\nand\nm\n(\n1≤n,m≤2⋅106\n) — the length of the strings\ns\nand\nt\n, respectively.\nThe second line contains the string\ns\nof length\nn\n. It is guaranteed that\ns\nonly consists of lowercase English letters, - and *.\nThe third line contains the string\nt\nof length\nm\n. It is guaranteed that\nt\nonly consists of lowercase English letters, - and *.\nOutput\nFor each test case, output \"Yes\" if there is a replacement that makes\ns′=t′\n, and output \"No\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nExamples\ninput\nCopy\n10 10\njustmonika\nj-stsayori\noutput\nCopy\nNo\ninput\nCopy\n7 8\nttk-wxx\n*tt-l-xx\noutput\nCopy\nYes\ninput\nCopy\n13 11\nasoulwangziji\n-soulg*z-y-\noutput\nCopy\nNo\ninput\nCopy\n7 3\nabc*cba\na*c\noutput\nCopy\nNo\ninput\nCopy\n20 18\nbulijiojio-dibuliduo\n*li*ji-*ox*i*-du*-\noutput\nCopy\nYes\nNote\nIn the second test case, we can transform both strings into ttklwxx. In\ns\n, - will be replaced with l. In\nt\n, * will be replaced by the empty string with the first and second - will be replaced with k and w respectively.\nIn the fifth test case, we can transform both strings into bulijiojioxdibuliduo.",
        "time_limit": "12 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "fft",
            "greedy",
            "math",
            "strings",
            "*3000"
        ]
    },
    {
        "title": "F. Set",
        "description": "Define the binary encoding of a finite set of natural numbers\nT⊆{0,1,2,…}\nas\nf(T)=\n∑\ni∈T\n2\ni\n. For example,\nf({0,2})=\n2\n0\n+\n2\n2\n=5\nand\nf({})=0\n. Notice that\nf\nis a bijection from all such sets to all non-negative integers. As such,\nf\n−1\nis also defined.\nYou are given an integer\nn\nalong with\n2\nn\n−1\nsets\nV\n1\n,\nV\n2\n,…,\nV\n2\nn\n−1\n.\nFind all sets\nS\nthat satisfy the following constraint:\nS⊆{0,1,…,n−1}\n. Note that\nS\ncan be empty.\nFor all non-empty subsets\nT⊆{0,1,…,n−1}\n,\n|S∩T|∈\nV\nf(T)\n.\nDue to the large input and output, both input and output will be given in terms of binary encodings of the sets.\nInput\nThe first line of input contains a single integer\nn\n(\n1≤n≤20\n).\nThe second line of input contains\n2\nn\n−1\nintegers\nv\n1\n,\nv\n2\n,…,\nv\n2\nn\n−1\n(\n0≤\nv\ni\n<\n2\nn+1\n) — the sets\nV\ni\ngiven in their binary encoding where\nV\ni\n=\nf\n−1\n(\nv\ni\n)\n.\nOutput\nThe first line of output should contain an integer\nk\nindicating the number of possible\nS\n.\nIn the following\nk\nlines, you should output\nf(S)\nfor all possible\nS\nin increasing order.\nExamples\ninput\nCopy\n3\n15 15 15 15 15 15 12\noutput\nCopy\n4\n3\n5\n6\n7\ninput\nCopy\n5\n63 63 63 63 6 63 63 63 63 63 63 5 63 63 63 63 63 63 8 63 63 63 63 2 63 63 63 63 63 63 63\noutput\nCopy\n1\n19\nNote\nIn the first test case, one possible\nS\nis\nf\n−1\n(3)={0,1}\n. All the non-empty subsets\nT⊆{0,1,2}\nand the corresponding\n|S∩T|\n,\nf(T)\nand\nV\nf\n(T)\nare as follows:\nT\n|S∩T|\nf(T)\nV\nf(T)\n{0}\n1\n1\n{0,1,2,3}\n{1}\n1\n2\n{0,1,2,3}\n{2}\n0\n4\n{0,1,2,3}\n{0,1}\n2\n3\n{0,1,2,3}\n{0,2}\n1\n5\n{0,1,2,3}\n{1,2}\n1\n6\n{0,1,2,3}\n{0,1,2}\n2\n7\n{2,3}",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "dfs and similar",
            "divide and conquer",
            "dp",
            "math",
            "*2600"
        ]
    },
    {
        "title": "E. Chain Queries",
        "description": "You are given a tree of\nn\nvertices numbered from\n1\nto\nn\n. Initially, all vertices are colored white or black.\nYou are asked to perform\nq\nqueries:\n\"u\" — toggle the color of vertex\nu\n(if it was white, change it to black and vice versa).\nAfter each query, you should answer whether all the black vertices form a chain. That is, there exist two black vertices such that the simple path between them passes through all the black vertices and only the black vertices. Specifically, if there is only one black vertex, they form a chain. If there are no black vertices, they do not form a chain.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\nc\ni\n∈{0,1}\n) — the initial color of the vertices.\nc\ni\ndenotes the color of vertex\ni\nwhere\n0\ndenotes the color white, and\n1\ndenotes the color black.\nThen\nn−1\nlines follow, each line contains two integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n), indicating an edge between vertices\nx\ni\nand\ny\ni\n. It is guaranteed that these edges form a tree.\nThe following\nq\nlines each contain an integer\nu\ni\n(\n1≤\nu\ni\n≤n\n), indicating the color of vertex\nu\ni\nneeds to be toggled.\nIt is guaranteed that the sum of\nn\nand\nq\nover all test cases respectively does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output \"Yes\" if the black vertices form a chain, and output \"No\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nExamples\ninput\nCopy\n2\n2 1\n1 0\n1 2\n1\n5 4\n1 0 0 0 0\n1 2\n1 3\n1 5\n3 4\n4\n3\n2\n5\noutput\nCopy\nNo\nNo\nYes\nYes\nNo\ninput\nCopy\n4\n5 3\n1 1 1 1 1\n3 5\n2 5\n3 4\n1 5\n1\n1\n1\n4 4\n0 0 0 0\n1 2\n2 3\n1 4\n1\n2\n3\n2\n1 1\n1\n1\n1 1\n0\n1\noutput\nCopy\nYes\nNo\nYes\nYes\nYes\nYes\nNo\nNo\nYes\nNote\nIn the second test case, the color of the vertices are as follows:\nThe initial tree:\nThe first query toggles the color of vertex\n4\n:\nThe second query toggles the color of vertex\n3\n:\nThe third query toggles the color of vertex\n2\n:\nThe fourth query toggles the color of vertex\n5\n:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "implementation",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "D. Paint the Tree",
        "description": "378QAQ has a tree with\nn\nvertices. Initially, all vertices are white.\nThere are two chess pieces called\nP\nA\nand\nP\nB\non the tree.\nP\nA\nand\nP\nB\nare initially located on vertices\na\nand\nb\nrespectively. In one step, 378QAQ will do the following in order:\nMove\nP\nA\nto a neighboring vertex. If the target vertex is white, this vertex will be painted red.\nMove\nP\nB\nto a neighboring vertex. If the target vertex is colored in red, this vertex will be painted blue.\nInitially, the vertex\na\nis painted red. If\na=b\n, the vertex\na\nis painted blue instead. Note that both the chess pieces must be moved in each step. Two pieces can be on the same vertex at any given time.\n378QAQ wants to know the minimum number of steps to paint all vertices blue.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains one integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains two integers\na\nand\nb\n(\n1≤a,b≤n\n).\nThen\nn−1\nlines follow, each line contains two integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n), indicating an edge between vertices\nx\ni\nand\ny\ni\n. It is guaranteed that these edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum number of steps to paint all vertices blue.\nExample\ninput\nCopy\n3\n2\n1 2\n1 2\n5\n1 2\n1 2\n1 3\n1 4\n1 5\n8\n5 4\n7 1\n1 5\n1 8\n8 3\n7 2\n8 6\n3 4\noutput\nCopy\n2\n8\n13\nNote\nIn the first test case, 378QAQ can paint all vertices blue in the following order:\nInitially,\nP\nA\nis located on the vertex\n1\n, and\nP\nB\nis located on the vertex\n2\n. The vertex\n1\nis painted red and the vertex\n2\nis white.\n378QAQ moves\nP\nA\nto the vertex\n2\nand paints it red. Then 378QAQ moves\nP\nB\nto the vertex\n1\nand paints it blue.\n378QAQ moves\nP\nA\nto the vertex\n1\n. Then 378QAQ moves\nP\nB\nto the vertex\n2\nand paints it blue.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "greedy",
            "shortest paths",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "C. Chamo and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, Chamo gave her an array\na\nconsisting of\nn\npositive integers as a gift.\nMocha doesn't like arrays containing different numbers, so Mocha decides to use magic to change the array. Mocha can perform the following three-step operation some (possibly, zero) times:\nChoose indices\nl\nand\nr\n(\n1≤l<r≤n\n)\nLet\nx\nbe the median\n†\n†\nof the subarray\n[\na\nl\n,\na\nl+1\n,…,\na\nr\n]\nSet all values\na\nl\n,\na\nl+1\n,…,\na\nr\nto\nx\nSuppose\na=[1,2,3,4,5]\ninitially:\nIf Mocha chooses\n(l,r)=(3,4)\nin the first operation, then\nx=3\n, the array will be changed into\na=[1,2,3,3,5]\n.\nIf Mocha chooses\n(l,r)=(1,3)\nin the first operation, then\nx=2\n, the array will be changed into\na=[2,2,2,4,5]\n.\nMocha will perform the operation until the array contains only the same number. Mocha wants to know what is the maximum possible value of this number.\n†\n†\nThe median in an array\nb\nof length\nm\nis an element that occupies position number\n⌊\nm+1\n2\n⌋\nafter we sort the elements in non-decreasing order. For example, the median of\n[3,1,4,1,5]\nis\n3\nand the median of\n[5,25,20,24]\nis\n20\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output the maximum value of the number.\nExample\ninput\nCopy\n2\n2\n1 2\n5\n1 2 3 4 5\noutput\nCopy\n1\n4\nNote\nIn the first test case,\na=[1,2]\n. Mocha can only choose the interval\n(l,r)=(1,2)\n. The array will be changed to\na=[1,1]\n. Therefore, the answer is\n1\n.\nIn the second test case, Mocha can perform the following operations:\nChoose the interval\n(l,r)=(4,5)\n, then\na=[1,2,3,4,4]\n.\nChoose the interval\n(l,r)=(3,5)\n, then\na=[1,2,4,4,4]\n.\nChoose the interval\n(l,r)=(1,5)\n, then\na=[4,4,4,4,4]\n.\nThe array contains only the same number, which is\n4\n. It can be proven that the maximum value of the final number cannot be greater than\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*1200"
        ]
    },
    {
        "title": "B. 378QAQ and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, 378QAQ gave her an array\na\nconsisting of\nn\npositive integers as a gift.\nMocha thinks that\na\nis beautiful if there exist two numbers\ni\nand\nj\n(\n1≤i,j≤n\n,\ni≠j\n) such that for all\nk\n(\n1≤k≤n\n),\na\nk\nis divisible\n†\n†\nby either\na\ni\nor\na\nj\n.\nDetermine whether\na\nis beautiful.\n†\n†\nx\nis divisible by\ny\nif there exists an integer\nz\nsuch that\nx=y⋅z\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output \"Yes\" if array\na\nis beautiful, and output \"No\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nExample\ninput\nCopy\n4\n3\n7 3 8\n5\n7 1 9 3 5\n5\n4 12 2 6 3\n5\n7 49 9 3 1000000000\noutput\nCopy\nNo\nYes\nYes\nNo\nNote\nIn the first test case, any two numbers in the array are coprime, so the answer is \"No\".\nIn the second test case, we can pick\ni=2\nand\nj=1\n. Since every number in the array is divisible by\na\ni\n=1\n, the answer is \"Yes\".\nIn the third test case, we can pick\ni=3\nand\nj=5\n.\n2\nand\n4\nis divisible by\na\ni\n=2\nwhile\n3\n,\n6\nand\n12\nis divisible by\na\nj\n=3\n, so the answer is \"Yes\".",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ]
    },
    {
        "title": "A. Bazoka and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, Bazoka gave her an array\na\nconsisting of\nn\npositive integers as a gift.\nNow Mocha wants to know whether array\na\ncould become sorted in non-decreasing order after performing the following operation some (possibly, zero) times:\nSplit the array into two parts — a prefix and a suffix, then swap these two parts. In other words, let\na=x+y\n. Then, we can set\na:=y+x\n. Here\n+\ndenotes the array concatenation operation.\nFor example, if\na=[3,1,4,1,5]\n, we can choose\nx=[3,1]\nand\ny=[4,1,5]\n, satisfying\na=x+y\n. Then, we can set\na:=y+x=[4,1,5,3,1]\n. We can also choose\nx=[3,1,4,1,5]\nand\ny=[]\n, satisfying\na=x+y\n. Then, we can set\na:=y+x=[3,1,4,1,5]\n. Note that we are not allowed to choose\nx=[3,1,1]\nand\ny=[4,5]\n, neither are we allowed to choose\nx=[1,3]\nand\ny=[5,1,4]\n, as both these choices do not satisfy\na=x+y\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤50\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n1≤ai≤106\n) — the elements of array\na\n.\nOutput\nFor each test case, output \"Yes\" if\na\ncould become non-decreasing after performing the operation any number of times, and output \"No\" if not.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nExample\ninput\nCopy\n3\n6\n1 1 4 5 1 4\n5\n7 9 2 2 3\n3\n1 2 3\noutput\nCopy\nNo\nYes\nYes\nNote\nIn the first test case, it can be proven that\na\ncannot become non-decreasing after performing the operation any number of times.\nIn the second test case, we can perform the following operations to make\na\nsorted in non-decreasing order:\nSplit the array into two parts:\nx=[7]\nand\ny=[9,2,2,3]\n, then swap these two parts. The array will become\ny+x=[9,2,2,3,7]\n.\nSplit the array into two parts:\nx=[9]\nand\ny=[2,2,3,7]\n, then swap these two parts. The array will become\ny+x=[2,2,3,7,9]\n, which is non-decreasing.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "G. Money Buys Less Happiness Now",
        "description": "You can never buy enough happiness, so here we go again! In this version, you can only buy\nh\ni\n=1\nunit of happiness each month, but the number of months is hugely increased. We are in the realm of quantum happiness and time dilation.\nBeing a physicist, Charlie likes to plan his life in simple and precise terms.\nFor the next\nm\nmonths, starting with no money, Charlie will work hard and earn\nx\npounds per month. For the\ni\n-th month\n(1≤i≤m)\n, there'll be a single opportunity of paying cost\nc\ni\npounds to obtain one unit of happiness. You cannot buy more than one unit each month.\nBorrowing is not allowed. Money earned in the\ni\n-th month can only be spent in a later\nj\n-th month (\nj>i\n).\nSince physicists don't code, help Charlie find the maximum reachable units of happiness.\nInput\nThe first line of the input contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers,\nm\nand\nx\n(\n1≤m≤2⋅\n10\n5\n,\n1≤x≤\n10\n3\n) — the total number of months and the monthly salary.\nThe second line of each test case contains\nm\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nm\n(\n1≤\nc\ni\n≤\n10\n3\n) — the cost of one unit of happiness for each month.\nIt is guaranteed that sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the maximal amount of happiness Charlie can get.\nExample\ninput\nCopy\n6\n3 3\n2 2 2\n6 5\n2 2 8 2 6 8\n6 4\n4 10 3 8 6 10\n2 1\n1 1\n4 1\n4 1 3 1\n4 2\n1 3 4 3\noutput\nCopy\n2\n4\n3\n1\n2\n1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*2000"
        ]
    },
    {
        "title": "F. Cutting Game",
        "description": "Alice and Bob were playing a game again. They have a grid of size\na×b\n(\n1≤a,b≤\n10\n9\n), on which there are\nn\nchips, with at most one chip in each cell. The cell at the intersection of the\nx\n-th row and the\ny\n-th column has coordinates\n(x,y)\n.\nAlice made the first move, and the players took turns. On each move, a player could cut several (but not all) rows or columns from the beginning or end of the remaining grid and earn a point for each chip that was on the cut part of the grid. Each move can be described by the character 'U', 'D', 'L', or 'R' and an integer\nk\n:\nIf the character is 'U', then the first\nk\nremaining rows will be cut;\nIf the character is 'D', then the last\nk\nremaining rows will be cut;\nIf the character is 'L', then the first\nk\nremaining columns will be cut;\nIf the character is 'R', then the last\nk\nremaining columns will be cut.\nBased on the initial state of the grid and the players' moves, determine the number of points earned by Alice and Bob, respectively.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains four integers\na\n,\nb\n,\nn\n, and\nm\n(\n2≤a,b≤\n10\n9\n,\n1≤n,m≤2⋅\n10\n5\n) — the dimensions of the grid, the number of chips, and the number of moves.\nEach of the next\nn\nlines contain two integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n≤a\n,\n1≤\ny\ni\n≤b\n) — the coordinates of the chips. All pairs of coordinates are distinct.\nEach of the next\nm\nlines contain a character\nc\nj\nand an integer\nk\nj\n — the description of the\nj\n-th move. It is guaranteed that\nk\nis less than the number of rows/columns in the current grid. In other words, a player cannot cut the entire remaining grid on their move.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases in the test does not exceed\n2⋅\n10\n5\n. It is guaranteed that the sum of the values of\nm\nacross all test cases in the test does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two integers — the number of points earned by Alice and Bob, respectively.\nExample\ninput\nCopy\n6\n4 4 3 2\n4 1\n3 3\n2 4\nD 2\nR 1\n4 4 3 3\n4 1\n3 2\n2 3\nD 1\nL 1\nU 2\n3 5 3 2\n1 3\n2 2\n3 3\nR 2\nR 2\n6 4 4 2\n1 4\n2 3\n5 3\n1 1\nR 1\nU 1\n9 3 2 1\n6 1\n3 3\nD 8\n10 10 2 5\n7 5\n9 1\nR 1\nL 2\nD 1\nU 4\nD 1\noutput\nCopy\n2 1\n2 0\n0 3\n1 1\n2 0\n0 1\nNote\nBelow is the game from the first example:\nOn her turn, Alice cut\n2\nrows from the bottom and scored\n2\npoints, then Bob cut\n1\ncolumn from the right and scored one point. Note that if Bob had cut\n1\nrow from the bottom, he would have also scored\n1\npoint.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "implementation",
            "sortings",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "E. Money Buys Happiness",
        "description": "Being a physicist, Charlie likes to plan his life in simple and precise terms.\nFor the next\nm\nmonths, starting with no money, Charlie will work hard and earn\nx\npounds per month. For the\ni\n-th month\n(1≤i≤m)\n, there'll be a single opportunity of paying cost\nc\ni\npounds to obtain happiness\nh\ni\n.\nBorrowing is not allowed. Money earned in the\ni\n-th month can only be spent in a later\nj\n-th month (\nj>i\n).\nSince physicists don't code, help Charlie find the maximum obtainable sum of happiness.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains two integers,\nm\nand\nx\n(\n1≤m≤50\n,\n1≤x≤\n10\n8\n) — the total number of months and the monthly salary.\nThe\ni\n-th of the following\nm\nlines contains two integers,\nc\ni\nand\nh\ni\n(\n0≤\nc\ni\n≤\n10\n8\n,\n1≤\nh\ni\n≤\n10\n3\n) — the cost and happiness on offer for the\ni\n-th month. Note that some happiness may be free (\nc\ni\n=0\nfor some\ni\n's).\nIt is guaranteed that the sum of\n∑\ni\nh\ni\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, print a single integer, the maximum sum of happiness Charlie could obtain.\nExample\ninput\nCopy\n7\n1 10\n1 5\n2 80\n0 10\n200 100\n3 100\n70 100\n100 200\n150 150\n5 8\n3 1\n5 3\n3 4\n1 5\n5 3\n2 5\n1 5\n2 1\n5 3\n2 5\n2 4\n4 1\n5 1\n3 4\n5 2\n2 1\n1 2\n3 5\n3 2\n3 2\noutput\nCopy\n0\n10\n200\n15\n1\n9\n9\nNote\nIn the first test case, Charlie only gets paid at the end of the month, so is unable to afford anything.\nIn the second test case, Charlie obtains the free happiness in the first month.\nIn the third test case, it's optimal for Charlie to buy happiness in the second month. Even with money left at the end, Charlie could not go back in time to obtain the happiness on offer in the first month.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "*1800"
        ]
    },
    {
        "title": "D. Ingenuity-2",
        "description": "Let's imagine the surface of Mars as an infinite coordinate plane. Initially, the rover Perseverance-2 and the helicopter Ingenuity-2 are located at the point with coordinates\n(0,0)\n. A set of instructions\ns\nconsisting of\nn\ninstructions of the following types was specially developed for them:\nN: move one meter north (from point\n(x,y)\nto\n(x,y+1)\n);\nS: move one meter south (from point\n(x,y)\nto\n(x,y−1)\n);\nE: move one meter east (from point\n(x,y)\nto\n(x+1,y)\n);\nW: move one meter west (from point\n(x,y)\nto\n(x−1,y)\n).\nEach instruction must be executed either by the rover or by the helicopter. Moreover, each device must execute at least one instruction. Your task is to distribute the instructions in such a way that after executing all\nn\ninstructions, the helicopter and the rover end up at the same point, or determine that this is impossible.\nInput\nThe first line of input contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of instructions.\nThe second line of each test case contains a string\ns\nof length\nn\nconsisting of the characters 'N', 'S', 'E', 'W' — the sequence of instructions.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if the required distribution of instructions exists, output a string\np\nof length\nn\nconsisting of the characters 'R', 'H'. If the\ni\n-th operation should be executed by the rover, then\np\ni\n=R\n, if the\ni\n-th operation should be executed by the helicopter, then\np\ni\n=H\n. If there are multiple solutions, output any of them.\nOtherwise, output NO.\nExample\ninput\nCopy\n10\n6\nNENSNE\n3\nWWW\n6\nNESSWS\n2\nSN\n2\nWE\n4\nSSNN\n4\nWESN\n2\nSS\n4\nEWNN\n4\nWEWE\noutput\nCopy\nRRHRRH\nNO\nHRRHRH\nNO\nNO\nRHRH\nRRHH\nRH\nRRRH\nRRHH\nNote\nLet's consider the first example: the string\nS=NENSNE\n. One of the possible solutions, shown in the figure below, is\np=RRHRRH\n, using which both the rover and the helicopter will end up one meter north and one meter east.\nFor WWW, the solution is impossible.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1400"
        ]
    },
    {
        "title": "C. Beautiful Triple Pairs",
        "description": "Polycarp was given an array\na\nof\nn\nintegers. He really likes triples of numbers, so for each\nj\n(\n1≤j≤n−2\n) he wrote down a triple of elements\n[\na\nj\n,\na\nj+1\n,\na\nj+2\n]\n.\nPolycarp considers a pair of triples\nb\nand\nc\nbeautiful if they differ in exactly one position, that is, one of the following conditions is satisfied:\nb\n1\n≠\nc\n1\nand\nb\n2\n=\nc\n2\nand\nb\n3\n=\nc\n3\n;\nb\n1\n=\nc\n1\nand\nb\n2\n≠\nc\n2\nand\nb\n3\n=\nc\n3\n;\nb\n1\n=\nc\n1\nand\nb\n2\n=\nc\n2\nand\nb\n3\n≠\nc\n3\n.\nFind the number of beautiful pairs of triples among the written triples\n[\na\nj\n,\na\nj+1\n,\na\nj+2\n]\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of the array.\nIt is guaranteed that the sum of the values of\nn\nfor all test cases in the test does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of beautiful pairs of triples among the pairs of the form\n[\na\nj\n,\na\nj+1\n,\na\nj+2\n]\n.\nNote that the answer may not fit into 32-bit data types.\nExample\ninput\nCopy\n8\n5\n3 2 2 2 3\n5\n1 2 1 2 1\n8\n1 2 3 2 2 3 4 2\n4\n2 1 1 1\n8\n2 1 1 2 1 1 1 1\n7\n2 1 1 1 1 1 1\n6\n2 1 1 1 1 1\n5\n2 1 1 1 1\noutput\nCopy\n2\n0\n3\n1\n8\n4\n3\n2\nNote\nIn the first example,\na=[3,2,2,2,3]\n, Polycarp will write the following triples:\n[3,2,2]\n;\n[2,2,2]\n;\n[2,2,3]\n.\nThe beautiful pairs are triple\n1\nwith triple\n2\nand triple\n2\nwith triple\n3\n.\nIn the third example,\na=[1,2,3,2,2,3,4,2]\n, Polycarp will write the following triples:\n[1,2,3]\n;\n[2,3,2]\n;\n[3,2,2]\n;\n[2,2,3]\n;\n[2,3,4]\n;\n[3,4,2]\n;\nThe beautiful pairs are triple\n1\nwith triple\n4\n, triple\n2\nwith triple\n5\n, and triple\n3\nwith triple\n6\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "*1400"
        ]
    },
    {
        "title": "B. Symmetric Encoding",
        "description": "Polycarp has a string\ns\n, which consists of lowercase Latin letters. He encodes this string using the following algorithm:\nfirst, he constructs a new auxiliary string\nr\n, which consists of all distinct letters of the string\ns\n, written in alphabetical order;\nthen the encoding happens as follows: each character in the string\ns\nis replaced by its symmetric character from the string\nr\n(the first character of the string\nr\nwill be replaced by the last, the second by the second from the end, and so on).\nFor example, encoding the string\ns\n=\"codeforces\" happens as follows:\nthe string\nr\nis obtained as \"cdefors\";\nthe first character\ns\n1\n='c' is replaced by 's';\nthe second character\ns\n2\n='o' is replaced by 'e';\nthe third character\ns\n3\n='d' is replaced by 'r';\n...\nthe last character\ns\n10\n='s' is replaced by 'c'.\nThe string\nr\nand replacements for\ns\n=\"codeforces\".\nThus, the result of encoding the string\ns\n=\"codeforces\" is the string \"serofedsoc\".\nWrite a program that performs decoding — that is, restores the original string\ns\nfrom the encoding result.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the string\nb\n.\nThe second line of each test case contains a string\nb\nof length\nn\n, consisting of lowercase Latin letters — the result of encoding the original string\ns\n.\nIt is guaranteed that the sum of the values of\nn\nover all test cases in the test does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the string\ns\nfrom which the encoding result\nb\nwas obtained.\nExample\ninput\nCopy\n5\n10\nserofedsoc\n3\nttf\n9\ntlrhgmaoi\n1\nw\n15\nhnndledmnhlttin\noutput\nCopy\ncodeforces\nfft\nalgorithm\nw\nmeetinthemiddle",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "strings",
            "*800"
        ]
    },
    {
        "title": "A. Phone Desktop",
        "description": "Little Rosie has a phone with a desktop (or launcher, as it is also called). The desktop can consist of several screens. Each screen is represented as a grid of size\n5×3\n, i.e., five rows and three columns.\nThere are\nx\napplications with an icon size of\n1×1\ncells; such an icon occupies only one cell of the screen. There are also\ny\napplications with an icon size of\n2×2\ncells; such an icon occupies a square of\n4\ncells on the screen. Each cell of each screen can be occupied by no more than one icon.\nRosie wants to place the application icons on the minimum number of screens. Help her find the minimum number of screens needed.\nInput\nThe first line of the input contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains two integers\nx\nand\ny\n(\n0≤x,y≤99\n) — the number of applications with a\n1×1\nicon and the number of applications with a\n2×2\nicon, respectively.\nOutput\nFor each test case, output the minimal number of required screens on a separate line.\nExample\ninput\nCopy\n11\n1 1\n7 2\n12 4\n0 3\n1 0\n8 1\n0 0\n2 0\n15 0\n8 2\n0 9\noutput\nCopy\n1\n1\n2\n2\n1\n1\n0\n1\n1\n2\n5\nNote\nThe solution for the first test case can look as follows:\nBlue squares represent empty spaces for icons, green squares represent\n1×1\nicons, red squares represent\n2×2\nicons\nThe solution for the third test case can look as follows:",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Maximum GCD Sum Queries",
        "description": "For\nk\npositive integers\nx\n1\n,\nx\n2\n,…,\nx\nk\n, the value\ngcd(\nx\n1\n,\nx\n2\n,…,\nx\nk\n)\nis the greatest common divisor of the integers\nx\n1\n,\nx\n2\n,…,\nx\nk\n — the largest integer\nz\nsuch that all the integers\nx\n1\n,\nx\n2\n,…,\nx\nk\nare divisible by\nz\n.\nYou are given three arrays\na\n1\n,\na\n2\n,…,\na\nn\n,\nb\n1\n,\nb\n2\n,…,\nb\nn\nand\nc\n1\n,\nc\n2\n,…,\nc\nn\nof length\nn\n, containing positive integers.\nYou also have a machine that allows you to swap\na\ni\nand\nb\ni\nfor any\ni\n(\n1≤i≤n\n). Each swap costs you\nc\ni\ncoins.\nFind the maximum possible value of\ngcd(\na\n1\n,\na\n2\n,…,\na\nn\n)+gcd(\nb\n1\n,\nb\n2\n,…,\nb\nn\n)\ngcd\n(\n)\ngcd\n(\nb\nb\nb\n)\nthat you can get by paying in total at most\nd\ncoins for swapping some elements. The amount of coins you have changes a lot, so find the answer to this question for each of the\nq\npossible values\nd\n1\n,\nd\n2\n,…,\nd\nq\n.\nInput\nThere are two integers on the first line — the numbers\nn\nand\nq\n(\n1≤n≤5⋅\n10\n5\n,\n1≤q≤5⋅\n10\n5\n).\nOn the second line, there are\nn\nintegers — the numbers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n8\n).\nOn the third line, there are\nn\nintegers — the numbers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n8\n).\nOn the fourth line, there are\nn\nintegers — the numbers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n).\nOn the fifth line, there are\nq\nintegers — the numbers\nd\n1\n,\nd\n2\n,…,\nd\nq\n(\n0≤\nd\ni\n≤\n10\n15\n).\nOutput\nPrint\nq\nintegers — the maximum value you can get for each of the\nq\npossible values\nd\n.\nExamples\ninput\nCopy\n3 4\n1 2 3\n4 5 6\n1 1 1\n0 1 2 3\noutput\nCopy\n2 3 3 3 \ninput\nCopy\n5 5\n3 4 6 8 4\n8 3 4 9 3\n10 20 30 40 50\n5 55 13 1000 113\noutput\nCopy\n2 7 3 7 7 \ninput\nCopy\n1 1\n3\n4\n5\n0\noutput\nCopy\n7 \nNote\nIn the first query of the first example, we are not allowed to do any swaps at all, so the answer is\ngcd(1,2,3)+gcd(4,5,6)=2\n. In the second query, one of the ways to achieve the optimal value is to swap\na\n2\nand\nb\n2\n, then the answer is\ngcd(1,5,3)+gcd(4,2,6)=3\n.\nIn the second query of the second example, it's optimal to perform swaps on positions\n1\nand\n3\n, then the answer is\ngcd(3,3,6,9,3)+gcd(8,4,4,8,4)=7\nand we have to pay\n40\ncoins in total.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "implementation",
            "number theory",
            "*3100"
        ]
    },
    {
        "title": "E. Cat, Fox and Swaps",
        "description": "Fox has found an array\np\n1\n,\np\n2\n,…,\np\nn\n, that is a permutation of length\nn\n†\nof the numbers\n1,2,…,n\n. She wants to sort the elements in increasing order. Cat wants to help her — he is able to swap any two numbers\nx\nand\ny\nin the array, but only if\nl≤x+y≤r\n(note that the constraint is imposed on the values of the elements, not their positions). He can make such swaps any number of times.\nThey don't know the numbers\nl\n,\nr\nyet, they only know that it's true that\n1≤l≤r≤2⋅n\n.\nYou are given the number\nn\nand the array\np\n1\n,\np\n2\n,…,\np\nn\n. Determine how many pairs\n(l,r)\nsatisfying the conditions are there such that you can sort the permutation if you can only swap two number\n(x,y)\nsuch that\nl≤x+y≤r\n(arbitrary number of times, possibly\n0\n).\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nDescription of each test case consists of two lines. The first line contains one integer\nn\n(\n1≤n≤\n10\n5\n).\nThe second line contains\nn\nintegers: the array\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n). It is guaranteed that this array is a permutation of length\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, print the number of pairs of integers\n(l,r)\nsuch that\n1≤l≤r≤2⋅n\n, and you can sort the array under the constraints.\nExample\ninput\nCopy\n7\n2\n2 1\n3\n3 1 2\n4\n3 2 1 4\n5\n5 3 1 2 4\n5\n1 2 3 4 5\n6\n3 2 1 5 4 6\n6\n1 3 2 4 5 6\noutput\nCopy\n6\n11\n23\n29\n55\n46\n58\nNote\nIn the first example, we need to be able to swap\n1\nand\n2\n, so we must be able to swap numbers with sum\n3\n. There are exactly\n6\npairs satisfying the condition:\n(1,3),(2,3),(3,3),(1,4),(2,4)\nand\n(3,4)\n, so the answer is\n6\n.\nIn the second example, the\n11\npairs satisfying the condition are\n(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6),(4,5)\nand\n(4,6)\n. For example, if we pick the pair\n(3,4)\nwe can first swap the numbers\n1\nand\n2\nand then the numbers\n1\nand\n3\n, after this, the permutation is sorted.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "graphs",
            "math",
            "sortings",
            "*2500"
        ]
    },
    {
        "title": "D. Cat, Fox and Maximum Array Split",
        "description": "This is an interactive problem.\nFox gave Cat two positive integers\nn\nand\nk\n. She has a hidden array\na\n1\n,…,\na\nn\nof length\nn\n, such that\n1≤\na\ni\n≤n\nfor every\ni\n. Now they are going to play the following game:\nFor any two integers\nl,r\nsuch that\n1≤l≤r≤n\n, define\nf(l,r)=(r−l+1)⋅\nmax\nx=l\nr\na\nx\n. In other words,\nf(l,r)\nis equal to the maximum of the subarray\na\nl\n,…,\na\nr\nmultiplied by its size.\nCat can ask Fox at most\n2n\nquestions about the array. He will tell her two integers\nl\nand\nx\n(\n1≤l≤n,1≤x≤\n10\n9\n), and she will tell him one integer\np\nas the answer — the smallest positive integer\nr\nsuch that\nf(l,r)=x\n, or\nn+1\nif no such\nr\nexists.\nNow, Cat needs to find the largest value\nm\nsuch that there exists a sequence\nc\n1\n,…,\nc\nk−1\nsuch that\n1≤\nc\n1\n<…<\nc\nk−1\n<n\nand\nf(1,\nc\n1\n)=f(\nc\n1\n+1,\nc\n2\n)=…=f(\nc\nk−1\n+1,n)=m\n. If no such\nm\nexists, he should indicate this and take\n−1\nas the answer. Note that for\nk=1\n,\nm\nis always equal to\nf(1,n)\n.\nIn other words, the goal is to find the largest\nm\nsuch that you can split the array into exactly\nk\nsubarrays (\nk\nis the constant given to you in the beginning of the interaction) so that all the subarrays have the product of their length and their maximum equal to\nm\n, or determine that no such\nm\nexists. Every element should belong in exactly one of the subarrays.\nCat doesn't know what he should do, so he asked you to play the game for him.\nInteraction\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two positive integers\nn\nand\nk\n(\n1≤k≤n≤\n10\n4\n) — the length of the hidden array and the number of subarrays in the desired split.\nNow you are allowed to make queries in the following way — print one line of the form \"\n? l x\n\" (it must hold that\n1≤l≤n\n,\n1≤x≤\n10\n9\n) and you will receive the smallest integer\nr\nsuch that\nl≤r≤n\nand\nf(l,r)=x\n, or\nn+1\nif no such\nr\nexists.\nIf you want to print the answer, output \"\n! m\n\" and you will recieve\n1\nif your answer is correct and\n−1\notherwise. In the first case, the interaction continues with the next test case. Note that printing the answer doesn't count towards the number of queries made. Please note that you don't receive the values for the next test case immediately, you will first have to read whether your answer to the last test case was correct.\nIf you receive the integer\n−1\nat any moment, it means your program has made an invalid query, exceeded the query limit, or gave an incorrect answer. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query, do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nIt is guaranteed that the total sum of\nn\nover the test cases won't exceed\n10\n4\n.\nHacks\nThe format of the hacks should be the following: the first line should contain one integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases should follow.\nThe first line of each test case should contain two integers\nn\nand\nk\n(\n1≤k≤n≤\n10\n4\n) — the length of the array\na\nand the number of subarrays you want to split it into.\nThe second line should contain\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nThe sum of\nn\nover all test cases should not exceed\n10\n4\n.\nExample\ninput\nCopy\n3\n1 1\n\n1\n2 2\n\n1\n\n3\n\n1\n6 3\n\n7\n\n2\n\n3\n\n6\n\n1\noutput\nCopy\n! 1\n\n\n? 1 1\n\n? 2 1\n\n! -1\n\n\n? 1 9\n\n? 1 6\n\n? 3 6\n\n? 4 6\n\n! 6\nNote\nThe hidden arrays in the three testcases are\n[1]\n,\n[1,2]\nand\n[1,3,6,1,2,1]\n. In the second testcase, no split satisfies the constraints, so the answer is\n−1\n.\nThe answer for the first query of the third testcase is\n7\nsince no valid\nr\nexists. For the second query of the third testcase, since\n2⋅max(1,3)=6\n, we will get\n2\nas the answer, since\nr=1\ndoesn't satisfy the constraint.\nThe sample interaction guessed all three answers (\n1,−1\nand\n6\n) correctly, so it received\n1\nafter each answer.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "interactive",
            "math",
            "*2400"
        ]
    },
    {
        "title": "C. Cat, Fox and Double Maximum",
        "description": "Fox loves permutations! She came up with the following problem and asked Cat to solve it:\nYou are given an even positive integer\nn\nand a permutation\n†\n†\np\nof length\nn\n.\nThe score of another permutation\nq\nof length\nn\nis the number of local maximums in the array\na\nof length\nn\n, where\na\ni\n=\np\ni\n+\nq\ni\nfor all\ni\n(\n1≤i≤n\n). In other words, the score of\nq\nis the number of\ni\nsuch that\n1<i<n\n(note the strict inequalities),\na\ni−1\n<\na\ni\n, and\na\ni\n>\na\ni+1\n(once again, note the strict inequalities).\nFind the permutation\nq\nthat achieves the maximum score for given\nn\nand\np\n. If there exist multiple such permutations, you can pick any of them.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nThe first line of input contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases in the input you will have to solve.\nThe first line of each test case contains one even integer\nn\n(\n4≤n≤\n10\n5\n,\nn\nis even) — the length of the permutation\np\n.\nThe second line of each test case contains the\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n). It is guaranteed that\np\nis a permutation of length\nn\n.\nIt is guaranteed that the sum of\nn\nacross all test cases doesn't exceed\n10\n5\n.\nOutput\nFor each test case, output one line containing any permutation of length\nn\n(the array\nq\n), such that\nq\nmaximizes the score under the given constraints.\nExample\ninput\nCopy\n4\n4\n1 2 3 4\n4\n4 3 1 2\n6\n6 5 1 4 2 3\n8\n1 2 4 5 7 6 8 3\noutput\nCopy\n2 4 1 3\n3 1 4 2\n2 5 1 4 3 6\n5 4 8 2 7 1 6 3\nNote\nIn the first example,\na=[3,6,4,7]\n. The array has just one local maximum (on the second position), so the score of the chosen permutation\nq\nis\n1\n. It can be proven that this score is optimal under the constraints.\nIn the last example, the resulting array\na=[6,6,12,7,14,7,14,6]\nhas\n3\nlocal maximums — on the third, fifth and seventh positions.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "B. Cat, Fox and the Lonely Array",
        "description": "Today, Cat and Fox found an array\na\nconsisting of\nn\nnon-negative integers.\nDefine the loneliness of\na\nas the smallest positive integer\nk\n(\n1≤k≤n\n) such that for any two positive integers\ni\nand\nj\n(\n1≤i,j≤n−k+1\n), the following holds:\na\ni\n|\na\ni+1\n|…|\na\ni+k−1\n=\na\nj\n|\na\nj+1\n|…|\na\nj+k−1\n,\n|\n|\n|\n|\n|\n|\nwhere\nx|y\ndenotes the bitwise OR of\nx\nand\ny\n. In other words, for every\nk\nconsecutive elements, their bitwise OR should be the same. Note that the loneliness of\na\nis well-defined, because for\nk=n\nthe condition is satisfied.\nCat and Fox want to know how lonely the array\na\nis. Help them calculate the loneliness of the found array.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<\n2\n20\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n10\n5\n.\nOutput\nFor each test case, print one integer  — the loneliness of the given array.\nExample\ninput\nCopy\n7\n1\n0\n3\n2 2 2\n3\n1 0 2\n5\n3 0 1 4 2\n5\n2 0 4 0 2\n7\n0 0 0 0 1 2 4\n8\n0 1 3 2 2 1 0 3\noutput\nCopy\n1\n1\n3\n4\n4\n7\n3\nNote\nIn the first example, the loneliness of an array with a single element is always\n1\n, so the answer is\n1\n.\nIn the second example, the OR of each subarray of length\nk=1\nis\n2\n, so the loneliness of the whole array is\n1\n.\nIn the seventh example, it's true that\n(0|1|3)=(1|3|2)=(3|2|2)=(2|2|1)=(2|1|0)=(1|0|3)=3\n, so the condition is satisfied for\nk=3\n. We can verify that the condition is not true for any smaller\nk\n, so the answer is indeed\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "data structures",
            "greedy",
            "math",
            "two pointers",
            "*1300"
        ]
    },
    {
        "title": "A. Chess For Three",
        "description": "Three friends gathered to play a few games of chess together.\nIn every game, two of them play against each other. The winner gets\n2\npoints while the loser gets\n0\n, and in case of a draw, both players get\n1\npoint each. Note that the same pair of players could have played any non-negative number of times (possibly zero). It is also possible that no games were played at all.\nYou've been told that their scores after all the games were played were\np\n1\n,\np\n2\nand\np\n3\n. Additionally, it is guaranteed that\np\n1\n≤\np\n2\n≤\np\n3\nholds.\nFind the maximum number of draws that could have happened and print it. If there isn't any way to obtain\np\n1\n,\np\n2\nand\np\n3\nas a result of a non-negative number of games between the three players, print\n−1\ninstead.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains three integers\np\n1\n,\np\n2\nand\np\n3\n(\n0≤\np\n1\n≤\np\n2\n≤\np\n3\n≤30\n) — the scores of the three players, sorted non-decreasingly.\nOutput\nFor each testcase, print one number — the maximum possible number of draws that could've happened, or\n−1\nif the scores aren't consistent with any valid set of games and results.\nExample\ninput\nCopy\n7\n0 0 0\n0 1 1\n1 1 1\n1 1 2\n3 3 3\n3 4 5\n1 1 10\noutput\nCopy\n0\n1\n-1\n2\n-1\n6\n2\nNote\nIn the first example, no games were played at all, so no draws could occur either.\nFor the second example, exactly one game occurred between the second and the third player and it ended in draw, so the answer is\n1\n.\nIt's easy to see that there's no set of games achieving the scores in third example, so the answer for it is\n−1\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "math",
            "*900"
        ]
    },
    {
        "title": "B. Coin Games",
        "description": "There are\nn\ncoins on the table forming a circle, and each coin is either facing up or facing down. Alice and Bob take turns to play the following game, and Alice goes first.\nIn each operation, the player chooses a facing-up coin, removes the coin, and flips the two coins that are adjacent to it. If (before the operation) there are only two coins left, then one will be removed and the other won't be flipped (as it would be flipped twice). If (before the operation) there is only one coin left, no coins will be flipped. If (before the operation) there are no facing-up coins, the player loses.\nDecide who will win the game if they both play optimally. It can be proved that the game will end in a finite number of operations, and one of them will win.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains only one positive integer\nn\n(\n1≤n≤100\n), representing the number of the coins.\nA string\ns\nof length\nn\nfollows on the second line of each test case, containing only \"U\" and \"D\", representing that each coin is facing up or facing down.\nOutput\nFor each test case, print \"YES\" if Alice will win the game, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n3\n5\nUUDUD\n5\nUDDUD\n2\nUU\noutput\nCopy\nYES\nNO\nNO\nNote\nIn the first test case, the game may go as follows.\nAlice chooses the first coin and\ns\nbecomes \"DDUU\".\nBob chooses the last coin and\ns\nbecomes \"UDD\".\nAlice chooses the first coin and\ns\nbecomes \"UU\".\nBob chooses the first coin and\ns\nbecomes \"U\".\nAlice chooses the only coin and\ns\nbecomes empty.\nBob can't choose any coin now, and he loses the game.\nIt can be proved that Bob will always lose if they both play optimally.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "*900"
        ]
    },
    {
        "title": "A. Contest Proposal",
        "description": "A contest contains\nn\nproblems and the difficulty of the\ni\n-th problem is expected to be at most\nb\ni\n. There are already\nn\nproblem proposals and the difficulty of the\ni\n-th problem is\na\ni\n. Initially, both\na\n1\n,\na\n2\n,…,\na\nn\nand\nb\n1\n,\nb\n2\n,…,\nb\nn\nare sorted in non-decreasing order.\nSome of the problems may be more difficult than expected, so the writers must propose more problems. When a new problem with difficulty\nw\nis proposed, the most difficult problem will be deleted from the contest, and the problems will be sorted in a way that the difficulties are non-decreasing.\nIn other words, in each operation, you choose an integer\nw\n, insert it into the array\na\n, sort array\na\nin non-decreasing order, and remove the last element from it.\nFind the minimum number of new problems to make\na\ni\n≤\nb\ni\nfor all\ni\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤100\n). The description of the test cases follows.\nThe first line of each test case contains only one positive integer\nn\n(\n1≤n≤100\n), representing the number of problems.\nThe second line of each test case contains an array\na\nof length\nn\n(\n1≤\na\n1\n≤\na\n2\n≤⋯≤\na\nn\n≤\n10\n9\n).\nThe third line of each test case contains an array\nb\nof length\nn\n(\n1≤\nb\n1\n≤\nb\n2\n≤⋯≤\nb\nn\n≤\n10\n9\n).\nOutput\nFor each test case, print an integer as your answer in a new line.\nExample\ninput\nCopy\n2\n6\n1000 1400 2000 2000 2200 2700\n800 1200 1500 1800 2200 3000\n6\n4 5 6 7 8 9\n1 2 3 4 5 6\noutput\nCopy\n2\n3\nNote\nIn the first test case:\nPropose a problem with difficulty\nw=800\nand\na\nbecomes\n[800,1000,1400,2000,2000,2200]\n.\nPropose a problem with difficulty\nw=1800\nand\na\nbecomes\n[800,1000,1400,1800,2000,2000]\n.\nIt can be proved that it's impossible to reach the goal by proposing fewer new problems.\nIn the second test case:\nPropose a problem with difficulty\nw=1\nand\na\nbecomes\n[1,4,5,6,7,8]\n.\nPropose a problem with difficulty\nw=2\nand\na\nbecomes\n[1,2,4,5,6,7]\n.\nPropose a problem with difficulty\nw=3\nand\na\nbecomes\n[1,2,3,4,5,6]\n.\nIt can be proved that it's impossible to reach the goal by proposing fewer new problems.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "two pointers",
            "*800"
        ]
    },
    {
        "title": "H. ±1",
        "description": "Bob has a grid with\n3\nrows and\nn\ncolumns, each of which contains either\na\ni\nor\n−\na\ni\nfor some integer\n1≤i≤n\n. For example, one possible grid for\nn=4\nis shown below:\n⎡\n⎣\n⎢\na\n1\n−\na\n4\na\n1\n−\na\n2\na\n4\na\n2\n−\na\n3\n−\na\n1\n−\na\n2\n−\na\n2\n−\na\n3\na\n4\n⎤\n⎦\n⎥\n[\n]\nAlice and Bob play a game as follows:\nBob shows Alice his grid.\nAlice gives Bob an array\na\n1\n,\na\n2\n,…,\na\nn\nof her choosing, whose elements are all\n−1\nor\n1\n.\nBob substitutes these values into his grid to make a grid of\n−1\ns and\n1\ns.\nBob sorts the elements of each column in non-decreasing order.\nAlice wins if all the elements in the middle row are\n1\n; otherwise, Bob wins.\nFor example, suppose Alice gives Bob the array\n[1,−1,−1,1]\nfor the grid above. Then the following will happen (colors are added for clarity):\n⎡\n⎣\n⎢\na\n1\n−\na\n4\na\n1\n−\na\n2\na\n4\na\n2\n−\na\n3\n−\na\n1\n−\na\n2\n−\na\n2\n−\na\n3\na\n4\n⎤\n⎦\n⎥\n−\n→\n−\n−\n−\n−\n−\n[1,−1,−1,1]\n⎡\n⎣\n⎢\n1\n−1\n1\n1\n1\n−1\n1\n−1\n1\n1\n1\n1\n⎤\n⎦\n⎥\n−\n→\n−\n−\n−\n−\n−\n−\n−\n−\nsort each column\n⎡\n⎣\n⎢\n−1\n1\n1\n−1\n1\n1\n−1\n1\n1\n1\n1\n1\n⎤\n⎦\n⎥\n.\n[\n]\n[\n]\n[\n]\nSince the middle row is all\n1\n, Alice wins.\nGiven Bob's grid, determine whether or not Alice can choose the array\na\nto win the game.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤500\n) — the number of columns of Bob's grid.\nThe next three lines each contain\nn\nintegers, the\ni\n-th of which contains\ng\ni,1\n,\ng\ni,2\n,…,\ng\ni,n\n(\n−n≤\ng\ni,j\n≤n\n,\ng\ni,j\n≠0\n), representing Bob's grid.\nIf cell\nx>0\nis in the input, that cell in Bob's grid should contain\na\nx\n; if\nx<0\nis in the input, that cell in Bob's grid should contain\n−\na\n−x\n. See the sample input and notes for a better understanding.\nOutput\nFor each test case, output \"YES\" (without quotes) if Alice can win, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n4\n4\n1 -2 -3 -2\n-4 4 -1 -3\n1 2 -2 4\n2\n1 2\n-1 -2\n2 -2\n5\n1 2 3 4 5\n-2 3 -4 -5 -1\n3 -5 1 2 2\n6\n1 3 -6 2 5 2\n1 3 -2 -3 -6 -5\n-2 -1 -3 2 3 1\noutput\nCopy\nYES\nNO\nYES\nNO\nNote\nThe first test case is described in the statement.\nIn the second test case, Bob's grid is as follows:\n⎡\n⎣\n⎢\na\n1\n−\na\n1\na\n2\na\n2\n−\na\n2\n−\na\n2\n⎤\n⎦\n⎥\n[\n]\nFor the last column to have\n1\nin the middle row when sorted, Alice must pick\na\n2\n=−1\n. However, it is then impossible to choose\na\n1\nsuch that the first column has\n1\nin the middle when sorted. Thus, Alice cannot win.\nIn the third test case, Alice can pick\na=[1,1,1,1,1]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "2-sat",
            "dfs and similar",
            "graphs",
            "*2100"
        ]
    },
    {
        "title": "G. XOUR",
        "description": "You are given an array\na\nconsisting of\nn\nnonnegative integers.\nYou can swap the elements at positions\ni\nand\nj\nif\na\ni\n XOR \na\nj\n<4\n, where\nXOR\nis the bitwise XOR operation.\nFind the lexicographically smallest array that can be made with any number of swaps.\nAn array\nx\nis lexicographically smaller than an array\ny\nif in the first position where\nx\nand\ny\ndiffer,\nx\ni\n<\ny\ni\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array.\nThe second line of each test case contains\nn\nintegers\na\ni\n(\n0≤\na\ni\n≤\n10\n9\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers — the lexicographically smallest array that can be made with any number of swaps.\nExample\ninput\nCopy\n4\n4\n1 0 3 2\n5\n2 7 1 5 6\n8\n1 2 1 2 1 2 1 2\n4\n16 4 1 64\noutput\nCopy\n0 1 2 3 \n1 5 2 6 7 \n1 1 1 1 2 2 2 2 \n16 4 1 64 \nNote\nFor the first test case, you can swap any two elements, so we can produce the sorted array.\nFor the second test case, you can swap\n2\nand\n1\n(their\nXOR\nis\n3\n),\n7\nand\n5\n(their\nXOR\nis\n2\n), and\n7\nand\n6\n(their\nXOR\nis\n1\n) to get the lexicographically smallest array.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dsu",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "F. Circle Perimeter",
        "description": "Given an integer\nr\n, find the number of lattice points that have a Euclidean distance from\n(0,0)\ngreater than or equal to\nr\nbut strictly less than\nr+1\n.\nA lattice point is a point with integer coordinates. The Euclidean distance from\n(0,0)\nto the point\n(x,y)\nis\nx\n2\n+\ny\n2\n−\n−\n−\n−\n−\n−\n√\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains a single integer\nr\n(\n1≤r≤\n10\n5\n).\nThe sum of\nr\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of lattice points that have an Euclidean distance\nd\nfrom\n(0,0)\nsuch that\nr≤d<r+1\n.\nExample\ninput\nCopy\n6\n1\n2\n3\n4\n5\n1984\noutput\nCopy\n8\n16\n20\n24\n40\n12504\nNote\nThe points for the first three test cases are shown below.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dfs and similar",
            "geometry",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "E. Find the Car",
        "description": "Timur is in a car traveling on the number line from point\n0\nto point\nn\n. The car starts moving from point\n0\nat minute\n0\n.\nThere are\nk+1\nsigns on the line at points\n0,\na\n1\n,\na\n2\n,…,\na\nk\n, and Timur knows that the car will arrive there at minutes\n0,\nb\n1\n,\nb\n2\n,…,\nb\nk\n, respectively. The sequences\na\nand\nb\nare strictly increasing with\na\nk\n=n\n.\nBetween any two adjacent signs, the car travels with a constant speed. Timur has\nq\nqueries: each query will be an integer\nd\n, and Timur wants you to output how many minutes it takes the car to reach point\nd\n, rounded down to the nearest integer.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nk\n, and\nq\n, (\nk≤n≤\n10\n9\n;\n1≤k,q≤\n10\n5\n) — the final destination, the number of points Timur knows the time for, and the number of queries respectively.\nThe second line of each test case contains\nk\nintegers\na\ni\n(\n1≤\na\ni\n≤n\n;\na\ni\n<\na\ni+1\nfor every\n1≤i≤k−1\n;\na\nk\n=n\n).\nThe third line of each test case contains\nk\nintegers\nb\ni\n(\n1≤\nb\ni\n≤\n10\n9\n;\nb\ni\n<\nb\ni+1\nfor every\n1≤i≤k−1\n).\nEach of the following\nq\nlines contains a single integer\nd\n(\n0≤d≤n\n) — the distance that Timur asks the minutes passed for.\nThe sum of\nk\nover all test cases doesn't exceed\n10\n5\n, and the sum of\nq\nover all test cases doesn't exceed\n10\n5\n.\nOutput\nFor each query, output a single integer — the number of minutes passed until the car reaches the point\nd\n, rounded down.\nExample\ninput\nCopy\n4\n10 1 3\n10\n10\n0\n6\n7\n10 2 4\n4 10\n4 7\n6\n4\n2\n7\n1000000000 1 1\n1000000000\n1000000000\n99999999\n6 1 3\n6\n5\n2\n6\n5\noutput\nCopy\n0 6 7 \n5 4 2 5 \n99999999 \n1 5 4 \nNote\nFor the first test case, the car goes from point\n0\nto point\n10\nin\n10\nminutes, so the speed is\n1\nunit per minute and:\nAt point\n0\n, the time will be\n0\nminutes.\nAt point\n6\n, the time will be\n6\nminutes.\nAt point\n7\n, the time will be\n7\nminutes.\nFor the second test case, between points\n0\nand\n4\n, the car travels at a speed of\n1\nunit per minute and between\n4\nand\n10\nwith a speed of\n2\nunits per minute and:\nAt point\n6\n, the time will be\n5\nminutes.\nAt point\n4\n, the time will be\n4\nminutes.\nAt point\n2\n, the time will be\n2\nminutes.\nAt point\n7\n, the time will be\n5.5\nminutes, so the answer is\n5\n.\nFor the fourth test case, the car travels with\n1.2\nunits per minute, so the answers to the queries are:\nAt point\n2\n, the time will be\n1.66…\nminutes, so the answer is\n1\n.\nAt point\n6\n, the time will be\n5\nminutes.\nAt point\n5\n, the time will be\n4.16…\nminutes, so the answer is\n4\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "math",
            "sortings",
            "*1500"
        ]
    },
    {
        "title": "D. Binary Cut",
        "description": "You are given a binary string\n†\n†\n. Please find the minimum number of pieces you need to cut it into, so that the resulting pieces can be rearranged into a sorted binary string.\nNote that:\neach character must lie in exactly one of the pieces;\nthe pieces must be contiguous substrings of the original string;\nyou must use all the pieces in the rearrangement.\n†\n†\nA binary string is a string consisting of characters\n0\nand\n1\n. A sorted binary string is a binary string such that all characters\n0\ncome before all characters\n1\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases.\nThe only line of each test case contains a single string\ns\n(\n1≤|s|≤500\n) consisting of characters\n0\nand\n1\n, where\n|s|\ndenotes the length of the string\ns\n.\nOutput\nFor each test case, output a single integer — the minimum number of pieces needed to be able to rearrange the string into a sorted binary string.\nExample\ninput\nCopy\n6\n11010\n00000000\n1\n10\n0001111\n0110\noutput\nCopy\n3\n1\n1\n2\n1\n2\nNote\nThe first test case is pictured in the statement. It can be proven that you can't use fewer than\n3\npieces.\nIn the second and third test cases, the binary string is already sorted, so only\n1\npiece is needed.\nIn the fourth test case, you need to make a single cut between the two characters and rearrange them to make the string\n01\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "strings",
            "*1100"
        ]
    },
    {
        "title": "C. Clock and Strings",
        "description": "There is a clock labeled with the numbers\n1\nthrough\n12\nin clockwise order, as shown below.\nIn this example,\n(a,b,c,d)=(2,9,10,6)\n, and the strings intersect.\nAlice and Bob have four distinct integers\na\n,\nb\n,\nc\n,\nd\nnot more than\n12\n. Alice ties a red string connecting\na\nand\nb\n, and Bob ties a blue string connecting\nc\nand\nd\n. Do the strings intersect? (The strings are straight line segments.)\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5940\n) — the number of test cases.\nThe only line of each test case contains four distinct integers\na\n,\nb\n,\nc\n,\nd\n(\n1≤a,b,c,d≤12\n).\nOutput\nFor each test case, output \"YES\" (without quotes) if the strings intersect, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n15\n2 9 10 6\n3 8 9 1\n1 2 3 4\n5 3 4 12\n1 8 2 10\n3 12 11 8\n9 10 12 1\n12 1 10 2\n3 12 6 9\n1 9 8 4\n6 7 9 12\n7 12 9 6\n10 12 11 1\n3 9 6 12\n1 4 3 5\noutput\nCopy\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNO\nNO\nNO\nNO\nYES\nYES\nYES\nYES\nNote\nThe first test case is pictured in the statement.\nIn the second test case, the strings do not intersect, as shown below.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*900"
        ]
    },
    {
        "title": "B. Different String",
        "description": "You are given a string\ns\nconsisting of lowercase English letters.\nRearrange the characters of\ns\nto form a new string\nr\nthat is not equal to\ns\n, or report that it's impossible.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains a string\ns\nof length at most\n10\nconsisting of lowercase English letters.\nOutput\nFor each test case, if no such string\nr\nexists as described in the statement, output \"NO\" (without quotes).\nOtherwise, output \"YES\" (without quotes). Then, output one line — the string\nr\n, consisting of letters of string\ns\n.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nIf multiple answers are possible, you can output any of them.\nExample\ninput\nCopy\n8\ncodeforces\naaaaa\nxxxxy\nco\nd\nnutdealer\nmwistht\nhhhhhhhhhh\noutput\nCopy\nYES\nforcodesec\nNO\nYES\nxxyxx\nYES\noc\nNO\nYES\nundertale\nYES\nthtsiwm\nNO\nNote\nIn the first test case, another possible answer is\nforcescode\n.\nIn the second test case, all rearrangements of\naaaaa\nare equal to\naaaaa\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "A. My First Sorting Problem",
        "description": "You are given two integers\nx\nand\ny\n.\nOutput two integers: the minimum of\nx\nand\ny\n, followed by the maximum of\nx\nand\ny\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe only line of each test case contains two space-separated integers\nx\nand\ny\n(\n0≤x,y≤9\n).\nOutput\nFor each test case, output two integers: the minimum of\nx\nand\ny\n, followed by the maximum of\nx\nand\ny\n.\nExample\ninput\nCopy\n10\n1 9\n8 4\n1 4\n3 4\n2 0\n2 4\n6 9\n3 3\n0 0\n9 9\noutput\nCopy\n1 9\n4 8\n1 4\n3 4\n0 2\n2 4\n6 9\n3 3\n0 0\n9 9",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "G3. Min-Fund Prison (Hard)",
        "description": "In the hard version,\n2≤∑n≤\n10\n5\nand\n1≤∑m≤5×\n10\n5\nAfter a worker's strike organized by the Dementors asking for equal rights, the prison of Azkaban has suffered some damage. After settling the spirits, the Ministry of Magic is looking to renovate the prison to ensure that the Dementors are kept in check. The prison consists of\nn\nprison cells and\nm\nbi-directional corridors. The\ni\nth\ncorridor is from cells\nu\ni\nto\nv\ni\n. A subset of these cells\nS\nis called a complex if any cell in\nS\nis reachable from any other cell in\nS\n. Formally, a subset of cells\nS\nis a complex if\nx\nand\ny\nare reachable from each other for all\nx,y∈S\n, using only cells from\nS\non the way. The funding required for a complex\nS\nconsisting of\nk\ncells is defined as\nk\n2\n.\nAs part of your Intro to Magical Interior Design course at Hogwarts, you have been tasked with designing the prison. The Ministry of Magic has asked that you divide the prison into\n2\ncomplexes with\nexactly one corridor\nconnecting them, so that the Dementors can't organize union meetings. For this purpose, you are allowed to build bi-directional corridors. The funding required to build a corridor between any\n2\ncells is\nc\n.\nDue to budget cuts and the ongoing fight against the Death Eaters, you must find the\nminimum total funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nNote: The total funding is the sum of the funding required for the\n2\ncomplexes and the corridors built. If after the division, the two complexes have\nx\nand\ny\ncells respectively and you have built a total of\na\ncorridors, the total funding will be\nx\n2\n+\ny\n2\n+c×a\n. Note that\nx+y=n\n.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. Then\nt\ntest cases follow.\nThe first line of each test case consists of three integers\nn,m\nand\nc\n(\n2≤n≤\n10\n5\n,\n1≤m≤5×\n10\n5\n,\n1≤c≤\n10\n9\n)\nm\nlines follow, each consisting of 2 integers —\nu\ni\n,\nv\ni\nindicating a corridor is present between cells\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n)\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nIt is guaranteed that the sum of\nm\nover all test cases does not exceed\n5×\n10\n5\n.\nIt is guaranteed that there exists at most one corridor between any two cells.\nOutput\nPrint the\nminimum funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nExample\ninput\nCopy\n4\n4 6 5\n4 3\n2 3\n2 4\n1 2\n4 1\n3 1\n6 6 2\n1 4\n2 5\n3 6\n1 5\n3 5\n6 5\n6 5 7\n1 4\n2 5\n3 6\n3 5\n6 5\n7 5 4\n1 4\n3 6\n3 5\n6 5\n2 7\noutput\nCopy\n-1\n20\n25\n33\nNote\nIn the first test case of the sample input, there is no way to divide the prison according to the Ministry's requirements.\nIn the second test case, consider the corridor between cells\n1\nand\n5\nas the connection between the\n2\ncomplexes consisting of\n{2,3,5,6}\nand\n{1,4}\ncells respectively. There are no new corridors built. The total funding is\n4\n2\n+\n2\n2\n=20\n. You can verify this is the minimum funding required.\nIn the third test case, build a corridor between\n2\nand\n4\n. Consider the corridor between cells\n1\nand\n5\nas the connection between the\n2\ncomplexes consisting of\n{3,5,6}\nand\n{1,2,4}\ncells respectively. The total funding is\n3\n2\n+\n3\n2\n+7×1=25\n. You can verify this is the minimum funding required.\nIn the fourth test case, build a corridor between\n2\nand\n4\nand between\n5\nand\n7\n. Consider the corridor between cells\n5\nand\n7\nas the connection between the\n2\ncomplexes consisting of\n{1,2,4,7}\nand\n{3,5,6}\ncells respectively. The total funding is\n4\n2\n+\n3\n2\n+4×2=33\n. You can verify this is the minimum funding required.\nNote for all test cases that there may be multiple ways to get the same funding but there is no other division which will have a more optimal minimum funding.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dfs and similar",
            "dp",
            "graphs",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "G2. Min-Fund Prison (Medium)",
        "description": "In the medium version,\n2≤∑n≤300\nand\n1≤∑m≤300\nAfter a worker's strike organized by the Dementors asking for equal rights, the prison of Azkaban has suffered some damage. After settling the spirits, the Ministry of Magic is looking to renovate the prison to ensure that the Dementors are kept in check. The prison consists of\nn\nprison cells and\nm\nbi-directional corridors. The\ni\nth\ncorridor is from cells\nu\ni\nto\nv\ni\n. A subset of these cells\nS\nis called a complex if any cell in\nS\nis reachable from any other cell in\nS\n. Formally, a subset of cells\nS\nis a complex if\nx\nand\ny\nare reachable from each other for all\nx,y∈S\n, using only cells from\nS\non the way. The funding required for a complex\nS\nconsisting of\nk\ncells is defined as\nk\n2\n.\nAs part of your Intro to Magical Interior Design course at Hogwarts, you have been tasked with designing the prison. The Ministry of Magic has asked that you divide the prison into\n2\ncomplexes with\nexactly one corridor\nconnecting them, so that the Dementors can't organize union meetings. For this purpose, you are allowed to build bi-directional corridors. The funding required to build a corridor between any\n2\ncells is\nc\n.\nDue to budget cuts and the ongoing fight against the Death Eaters, you must find the\nminimum total funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nNote: The total funding is the sum of the funding required for the\n2\ncomplexes and the corridors built. If after the division, the two complexes have\nx\nand\ny\ncells respectively and you have built a total of\na\ncorridors, the total funding will be\nx\n2\n+\ny\n2\n+c×a\n. Note that\nx+y=n\n.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤300\n) — the number of test cases. Then\nt\ntest cases follow.\nThe first line of each test case consists of three integers\nn,m\nand\nc\n(\n2≤n≤300\n,\n1≤m≤300\n,\n1≤c≤\n10\n9\n)\nm\nlines follow, each consisting of 2 integers —\nu\ni\n,\nv\ni\nindicating a corridor is present between cells\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n)\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n300\n.\nIt is guaranteed that the sum of\nm\nover all test cases does not exceed\n300\n.\nIt is guaranteed that there exists at most one corridor between any two cells.\nOutput\nPrint the\nminimum funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nExample\ninput\nCopy\n4\n4 6 5\n4 3\n2 3\n2 4\n1 2\n4 1\n3 1\n6 6 2\n1 4\n2 5\n3 6\n1 5\n3 5\n6 5\n6 5 7\n1 4\n2 5\n3 6\n3 5\n6 5\n7 5 4\n1 4\n3 6\n3 5\n6 5\n2 7\noutput\nCopy\n-1\n20\n25\n33\nNote\nIn the first test case of the sample input, there is no way to divide the prison according to the Ministry's requirements.\nIn the second test case, consider the corridor between cells\n1\nand\n5\nas the connection between the\n2\ncomplexes consisting of\n{2,3,5,6}\nand\n{1,4}\ncells respectively. There are no new corridors built. The total funding is\n4\n2\n+\n2\n2\n=20\n. You can verify this is the minimum funding required.\nIn the third test case, build a corridor between\n2\nand\n4\n. Consider the corridor between cells\n1\nand\n5\nas the connection between the\n2\ncomplexes consisting of\n{3,5,6}\nand\n{1,2,4}\ncells respectively. The total funding is\n3\n2\n+\n3\n2\n+7×1=25\n. You can verify this is the minimum funding required.\nIn the fourth test case, build a corridor between\n2\nand\n4\nand between\n5\nand\n7\n. Consider the corridor between cells\n5\nand\n7\nas the connection between the\n2\ncomplexes consisting of\n{1,2,4,7}\nand\n{3,5,6}\ncells respectively. The total funding is\n4\n2\n+\n3\n2\n+4×2=33\n. You can verify this is the minimum funding required.\nNote for all test cases that there may be multiple ways to get the same funding but there is no other division which will have a more optimal minimum funding.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "graphs",
            "trees",
            "*2200"
        ]
    },
    {
        "title": "G1. Min-Fund Prison (Easy)",
        "description": "In the easy version,\nm=n−1\nand there exists a path between\nu\nand\nv\nfor all\nu,v\n(\n1≤u,v≤n\n).\nAfter a worker's strike organized by the Dementors asking for equal rights, the prison of Azkaban has suffered some damage. After settling the spirits, the Ministry of Magic is looking to renovate the prison to ensure that the Dementors are kept in check. The prison consists of\nn\nprison cells and\nm\nbi-directional corridors. The\ni\nth\ncorridor is from cells\nu\ni\nto\nv\ni\n. A subset of these cells\nS\nis called a complex if any cell in\nS\nis reachable from any other cell in\nS\n. Formally, a subset of cells\nS\nis a complex if\nx\nand\ny\nare reachable from each other for all\nx,y∈S\n, using only cells from\nS\non the way. The funding required for a complex\nS\nconsisting of\nk\ncells is defined as\nk\n2\n.\nAs part of your Intro to Magical Interior Design course at Hogwarts, you have been tasked with designing the prison. The Ministry of Magic has asked that you divide the prison into\n2\ncomplexes with\nexactly one corridor\nconnecting them, so that the Dementors can't organize union meetings. For this purpose, you are allowed to build bi-directional corridors. The funding required to build a corridor between any\n2\ncells is\nc\n.\nDue to budget cuts and the ongoing fight against the Death Eaters, you must find the\nminimum total funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nNote: The total funding is the sum of the funding required for the\n2\ncomplexes and the corridors built. If after the division, the two complexes have\nx\nand\ny\ncells respectively and you have built a total of\na\ncorridors, the total funding will be\nx\n2\n+\ny\n2\n+c×a\n. Note that\nx+y=n\n.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. Then\nt\ntest cases follow.\nThe first line of each test case consists of three integers\nn,m\nand\nc\n(\n2≤n≤\n10\n5\n,\nm=n−1\n,\n1≤c≤\n10\n9\n)\nm\nlines follow, each consisting of 2 integers —\nu\ni\n,\nv\ni\nindicating a corridor is present between cells\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n)\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nIt is guaranteed that the sum of\nm\nover all test cases does not exceed\n5×\n10\n5\n.\nIt is guaranteed that there exists at most one corridor between any two cells.\nOutput\nPrint the\nminimum funding\nrequired to divide the prison as per the Ministry's requirements or\n−1\nif no division is possible.\nExample\ninput\nCopy\n2\n2 1 3\n1 2\n8 7 76\n3 1\n3 2\n2 4\n2 5\n4 6\n4 7\n7 8\noutput\nCopy\n2\n32",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "F3. Playing Quidditch (Hard)",
        "description": "This afternoon, you decided to enjoy the first days of Spring by taking a walk outside. As you come near the Quidditch field, you hear screams. Once again, there is a conflict about the score: the two teams are convinced that they won the game! To prevent this problem from happening one more time, you decide to get involved in the refereeing of the matches.\nNow, you will stay in the stadium to watch the game and count the score. At the end of the game, you will decide the winner.\nToday, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw (B) team. Each team is composed of\nP\nplayers (\n1≤P≤10\n).\nThe field is a rectangle of\nN\nlines and\nM\ncolumns (\n3≤N,M≤99\n,\nN\nand\nM\nare odd). All the positions are integers, and several entities are allowed to be at the same position in the field. At the beginning of the game, the field contains goals for the two teams (each team can own between one and five goals), the players, and exactly one Quaffle. In this version of the problem, one Bludger and a Golden Snitch can be present.\nA game is composed of\nT\nsteps (\n0≤T≤10000\n). At each step, one entity on the field (a player or a ball) performs one action. All entities can move. A player can also catch a ball or throw the Quaffle that it is carrying. To catch a ball, a player must be located on the same cell as it. The Quaffle does not perform any action while it is being carried; it only follows the movements of the player. If a player carrying the Quaffle decides to throw it, the Quaffle is simply put at the current position of the player. If a player is on the same cell as a Bludger (either after a movement from the player or the Bludger), the player is eliminated. If the player is eliminated while it is carrying the Quaffle, the Quaffle remains on the cell containing both the player and the Bludger after the move. It is guaranteed that this never occurs while the player is in a cell containing a goal.\nTo win a point, a player must leave the Quaffle at a goal of the other team. When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field (the cell at the\n(M+1)/2\n-th column of the\n(N+1)/2\n-th line of the field, starting from 1). There is no goal in the middle of the field. If a player puts the ball in its own goal, the other team wins the point. If a player catches the Golden Snitch, their team wins 10 points and the game is over.\nInput\nOn the first line, the integers\nN\nand\nM\n.\nThe description of the field follows:\nN\nlines of\nM\npairs of characters separated by spaces. Each pair of characters represents a position on the field. It can be either:\n.. to represent an empty cell\nR0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid.\nRG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG).\n.Q to represent the Quaffle, which is the ball that the players use to score goals.\n.B to represent the Bludger.\n.S to represent the Golden Snitch.\nThe next line contains\nT\n, the number of steps that compose the game.\nT\nlines follow, each describing one action. It contains several pieces of information separated by a space. First, a pair of characters representing the entity that must perform the action. Second, the description of the action:\nU, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time.\nC indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since several balls can be in the same cell.\nT indicates that the player throws the Quaffle that it is carrying.\nAll the actions performed by the entities are guaranteed to be valid: the players stay in the field, don't catch a ball if they are not in the same cell, don't release the Quaffle if they are not carrying it, ...\nOutput\nYou must output the description of the main events of the game, one event per line. More precisely:\nEach time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team.\nEach time a player is eliminated, you must print t p ELIMINATED, where t is the current time and p is the player who is eliminated. The format to print the player is the same as in the input.\nIf the Golden Snitch is caught, you must print t RED CATCH GOLDEN SNITCH or t BLUE CATCH GOLDEN SNITCH, depending on the team who caught the Golden Snitch, where t is the current time.\nThe events must be printed in ascending order of t. If several players are eliminated at the same time, the events must be written is alphabetical order: B0, ..., B9, R0, ... R9.\nAt the end of the game, you must print the final score as: FINAL SCORE: r b, where r is the score of the red team and b is the score of the blue team.\nExamples\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n12\nR0 D\nR0 C .Q\nR0 R\nR0 T\nR0 D\nB0 R\nB0 U\nB0 C .Q\nB0 L\nB0 L\nB0 L\nB0 T\noutput\nCopy\n11 BLUE GOAL\nFINAL SCORE: 0 1\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n5\nR0 D\nR0 C .Q\nR0 L\nR0 L\nR0 T\noutput\nCopy\n4 BLUE GOAL\nFINAL SCORE: 0 1\ninput\nCopy\n5 5\n.. .. .. .. ..\n.. .. .. .. ..\nRG R0 .Q B0 BG\n.. .. .. .. ..\n.. .. .B .. ..\n5\n.B L\n.B U\n.B U\nB0 L\nB0 L\noutput\nCopy\n2 R0 ELIMINATED\n4 B0 ELIMINATED\nFINAL SCORE: 0 0\ninput\nCopy\n5 5\n.. R0 .S B0 ..\n.. .. .. .. ..\nRG .. .Q .. BG\n.. .. .. .. ..\n.. R1 .B B1 ..\n4\n.S D\nR0 D\nR0 R\nR0 C .S\noutput\nCopy\n3 RED CATCH GOLDEN SNITCH\nFINAL SCORE: 10 0\nNote\nIn the first example, the red player takes the Quaffle, move it and throw it. The blue player catches the ball, goes to the red goal and scores.\nIn the second example, the red player takes the ball and scores in the goal of their own team: the blue team wins a point.\nIn the third example, the Bludger goes at the position of R0: R0 is eliminated. Then, B0 moves to the position of the Bludger: B0 is eliminated too.\nIn the fourth example, a red player catches the Golden Snitch. Their team wins 10 points, and the game ends.\nYou can find one more example in the easy version of the problem",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*2300"
        ]
    },
    {
        "title": "F2. Playing Quidditch (Medium)",
        "description": "This afternoon, you decided to enjoy the first days of Spring by taking a walk outside. As you come near the Quidditch field, you hear screams. Once again, there is a conflict about the score: the two teams are convinced that they won the game! To prevent this problem from happening one more time, you decide to get involved in the refereeing of the matches.\nNow, you will stay in the stadium to watch the game and count the score. At the end of the game, you will decide the winner.\nToday, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw (B) team. Each team is composed of\nP\nplayers (\n1≤P≤10\n).\nThe field is a rectangle of\nN\nlines and\nM\ncolumns (\n3≤N,M≤99\n,\nN\nand\nM\nare odd). All the positions are integers, and several entities are allowed to be at the same position in the field. At the beginning of the game, the field contains goals for the two teams (each team can own between one and five goals), the players, and exactly one Quaffle. In this version of the problem, one Bludger can be present. An other type of ball will be available in the harder version of the problem.\nA game is composed of\nT\nsteps (\n0≤T≤10000\n). At each step, one entity on the field (a player or a ball) performs one action. All entities can move. A player can also catch a ball or throw the Quaffle that it is carrying. To catch a ball, a player must be located on the same cell as it. The Quaffle does not perform any action while it is being carried; it only follows the movements of the player. If a player carrying the Quaffle decides to throw it, the Quaffle is simply put at the current position of the player. If a player is on the same cell as a Bludger (either after a movement from the player or the Bludger), the player is eliminated. If the player is eliminated while it is carrying the Quaffle, the Quaffle remains on the cell containing both the player and the Bludger after the move. It is guaranteed that this never occurs while the player is in a cell containing a goal.\nTo win a point, a player must leave the Quaffle at a goal of the other team. When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field (the cell at the\n(M+1)/2\n-th column of the\n(N+1)/2\n-th line of the field, starting from 1). There is no goal in the middle of the field. If a player puts the ball in its own goal, the other team wins the point.\nInput\nOn the first line, the integers\nN\nand\nM\n.\nThe description of the field follows:\nN\nlines of\nM\npairs of characters separated by spaces. Each pair of characters represents a position on the field. It can be either:\n.. to represent an empty cell\nR0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid.\nRG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG).\n.Q to represent the Quaffle, which is the ball that the players use to score goals.\n.B to represent a Bludger.\nThe next line contains\nT\n, the number of steps that compose the game.\nT\nlines follow, each describing one action. It contains several pieces of information separated by a space. First, a pair of characters representing the entity that must perform the action. Second, the description of the action:\nU, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time.\nC indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since several balls can be in the same cell.\nT indicates that the player throws the Quaffle that it is carrying.\nAll the actions performed by the entities are guaranteed to be valid: the players stay in the field, don't catch a ball if they are not in the same cell, don't release the Quaffle if they are not carrying it, ...\nOutput\nYou must output the description of the main events of the game, one event per line. More precisely:\nEach time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team.\nEach time a player is eliminated, you must print t p ELIMINATED, where t is the current time and p is the player who is eliminated. The format to print the player is the same as in the input.\nThe events must be printed in ascending order of t. If several players are eliminated at the same time, the events must be written in alphabetical order: B0, ..., B9, R0, ... R9.\nAt the end of the game, you must print the final score as: FINAL SCORE: r b, where r is the score of the red team and b is the score of the blue team.\nExamples\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n12\nR0 D\nR0 C .Q\nR0 R\nR0 T\nR0 D\nB0 R\nB0 U\nB0 C .Q\nB0 L\nB0 L\nB0 L\nB0 T\noutput\nCopy\n11 BLUE GOAL\nFINAL SCORE: 0 1\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n5\nR0 D\nR0 C .Q\nR0 L\nR0 L\nR0 T\noutput\nCopy\n4 BLUE GOAL\nFINAL SCORE: 0 1\ninput\nCopy\n5 5\n.. .. .. .. ..\n.. .. .. .. ..\nRG R0 .Q B0 BG\n.. .. .. .. ..\n.. .. .B .. ..\n5\n.B L\n.B U\n.B U\nB0 L\nB0 L\noutput\nCopy\n2 R0 ELIMINATED\n4 B0 ELIMINATED\nFINAL SCORE: 0 0\nNote\nIn the first example, the red player takes the Quaffle, move it and throw it. The blue player catches the ball, goes to the red goal and scores.\nIn the second example, the red player takes the ball and scores in the goal of their own team: the blue team wins a point.\nIn the third example, the Bludger goes at the position of R0: R0 is eliminated. Then, B0 moves to the position of the Bludger: B0 is eliminated too.\nYou can find one more example in the easy version of the problem",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*2300"
        ]
    },
    {
        "title": "F1. Playing Quidditch (Easy)",
        "description": "This afternoon, you decided to enjoy the first days of Spring by taking a walk outside. As you come near the Quidditch field, you hear screams. Once again, there is a conflict about the score: the two teams are convinced that they won the game! To prevent this problem from happening one more time, you decide to get involved in the refereeing of the matches.\nNow, you will stay in the stadium to watch the game and count the score. At the end of the game, you will decide the winner.\nToday, two teams are competing: the red Gryffindor (R) and the blue Ravenclaw (B) team. Each team is composed of\nP\nplayers (\n1≤P≤10\n).\nThe field is a rectangle of\nN\nlines and\nM\ncolumns (\n3≤N,M≤99\n,\nN\nand\nM\nare odd). All the positions are integers, and several entities are allowed to be at the same position in the field. At the beginning of the game, the field contains goals for the two teams (each team can own between one and five goals), the players, and exactly one Quaffle. Other types of balls will be available in the harder versions of the problem.\nA game is composed of\nT\nsteps (\n0≤T≤10000\n). At each step, one entity on the field (a player or a ball) performs one action. All entities can move. A player can also catch a ball or throw the Quaffle that it is carrying. To catch a ball, a player must be located on the same cell as it. The Quaffle does not perform any action while it is being carried; it only follows the movements of the player. If a player carrying the Quaffle decides to throw it, the Quaffle is simply put at the current position of the player.\nTo win a point, a player must leave the Quaffle at a goal of the other team. When it does, the team of the player wins one point, and the Quaffle instantly moves to the middle of the field (the cell at the\n(M+1)/2\n-th column of the\n(N+1)/2\n-th line of the field, starting from 1). There is no goal in the middle of the field. If a player puts the ball in its own goal, the other team wins the point.\nInput\nOn the first line, the integers\nN\nand\nM\n.\nThe description of the field follows:\nN\nlines of\nM\npairs of characters separated by spaces. Each pair of characters represents a position on the field. It can be either:\n.. to represent an empty cell\nR0, ..., R9, B0, ..., B9 to represent a player. The first character is the team of the player, and the second is the number of the player in the team. Each pair of characters is unique, but it is not guaranteed that all the pairs appear in the grid.\nRG or BG to represent a goal. The blue team tries to put the ball in a red goal (RG) while the red team tries to put the ball in a blue goal (BG).\n.Q to represent the Quaffle, which is the ball that the players use to score goals.\nThe next line contains\nT\n, the number of steps that compose the game.\nT\nlines follow, each describing one action. It contains several pieces of information separated by a space. First, a pair of characters representing the entity that must perform the action. Second, the description of the action:\nU, D, L, R indicate that the entity moves on the grid. It can move to the top of the grid (U), to the bottom (D), to the left (L), or to the right (R). Each entity moves by only one cell at a time.\nC indicates that the player catches the ball (only a player can catch a ball). Then, there is a space followed by a pair of characters: the description of the ball caught by the player. This information is needed since in the next versions of the problem, several balls may be in the same cell.\nT indicates that the player throws the Quaffle that it is carrying.\nAll the actions performed by the entities are guaranteed to be valid: the players stay in the field, don't catch a ball if they are not in the same cell, don't release the Quaffle if they are not carrying it, ...\nOutput\nYou must output the description of the main events of the game, one event per line. More precisely:\nEach time a team scores, you must print t RED GOAL or t BLUE GOAL, depending on the team who scored, where t is the current time (the position of the action in the list of actions, starting from 0). In the case where a player scores in the wrong goal (a red player scores in the red goal, or a blue player scores in the blue goal), you must print the name of the team who wins one point, that is, the other team.\nThe events must be printed in ascending order of t.\nAt the end of the game, you must print the final score as: FINAL SCORE: r b, where r is the score of the red team and b is the score of the blue team.\nExamples\ninput\nCopy\n5 5\n.. R1 .. B1 ..\nRG .. .. .. BG\nRG R0 .Q B0 BG\nRG .. .. .. BG\n.. R2 .. B2 ..\n13\nB2 U\nB2 U\nB2 L\nB2 C .Q\nB2 L\nB2 L\nB2 T\nR0 R\nR0 C .Q\nR0 D\nR0 R\nR0 R\nR0 T\noutput\nCopy\n6 BLUE GOAL\n12 RED GOAL\nFINAL SCORE: 1 1\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n12\nR0 D\nR0 C .Q\nR0 R\nR0 T\nR0 D\nB0 R\nB0 U\nB0 C .Q\nB0 L\nB0 L\nB0 L\nB0 T\noutput\nCopy\n11 BLUE GOAL\nFINAL SCORE: 0 1\ninput\nCopy\n3 5\n.. .. R0 .. ..\nRG .. .Q .. BG\n.. .. B0 .. ..\n5\nR0 D\nR0 C .Q\nR0 L\nR0 L\nR0 T\noutput\nCopy\n4 BLUE GOAL\nFINAL SCORE: 0 1\nNote\nIn the first example, a blue player goes to the middle of the grid, at the position of the Quaffle. He takes it, goes to the goal of the red team, and lets the ball there. He scores! The ball gets back to the middle of the field, a red player takes it and scores too.\nIn the second example, the red player takes the Quaffle, move it and throw it. The blue player catches the ball, goes to the red goal and scores.\nIn the third example, the red player takes the ball and scores in the goal of their own team: the blue team wins a point.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*2300"
        ]
    },
    {
        "title": "E3. Trails (Hard)",
        "description": "Harry Potter is hiking in the Alps surrounding Lake Geneva. In this area there are\nm\ncabins, numbered 1 to\nm\n. Each cabin is connected, with one or more trails, to a central meeting point next to the lake. Each trail is either short or long. Cabin\ni\nis connected with\ns\ni\nshort trails and\nl\ni\nlong trails to the lake.\nEach day, Harry walks a trail from the cabin where he currently is to Lake Geneva, and then from there he walks a trail to any of the\nm\ncabins (including the one he started in). However, as he has to finish the hike in a day, at least one of the two trails has to be short.\nHow many possible combinations of trails can Harry take if he starts in cabin 1 and walks for\nn\ndays?\nGive the answer modulo\n10\n9\n+7\n.\nInput\nThe first line contains the integers\nm\nand\nn\n.\nThe second line contains\nm\nintegers,\ns\n1\n,…,\ns\nm\n, where\ns\ni\nis the number of short trails between cabin\ni\nand Lake Geneva.\nThe third and last line contains\nm\nintegers,\nl\n1\n,…,\nl\nm\n, where\nl\ni\nis the number of long trails between cabin\ni\nand Lake Geneva.\nWe have the following constraints:\n0≤\ns\ni\n,\nl\ni\n≤\n10\n3\n.\n1≤m≤\n10\n5\n.\n1≤n≤\n10\n9\n.\nOutput\nThe number of possible combinations of trails, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3 2\n1 0 1\n0 1 1\noutput\nCopy\n18",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "matrices",
            "*2200"
        ]
    },
    {
        "title": "E2. Trails (Medium)",
        "description": "Harry Potter is hiking in the Alps surrounding Lake Geneva. In this area there are\nm\ncabins, numbered 1 to\nm\n. Each cabin is connected, with one or more trails, to a central meeting point next to the lake. Each trail is either short or long. Cabin\ni\nis connected with\ns\ni\nshort trails and\nl\ni\nlong trails to the lake.\nEach day, Harry walks a trail from the cabin where he currently is to Lake Geneva, and then from there he walks a trail to any of the\nm\ncabins (including the one he started in). However, as he has to finish the hike in a day, at least one of the two trails has to be short.\nHow many possible combinations of trails can Harry take if he starts in cabin 1 and walks for\nn\ndays?\nGive the answer modulo\n10\n9\n+7\n.\nInput\nThe first line contains the integers\nm\nand\nn\n.\nThe second line contains\nm\nintegers,\ns\n1\n,…,\ns\nm\n, where\ns\ni\nis the number of short trails between cabin\ni\nand Lake Geneva.\nThe third and last line contains\nm\nintegers,\nl\n1\n,…,\nl\nm\n, where\nl\ni\nis the number of long trails between cabin\ni\nand Lake Geneva.\nWe have the following constraints:\n0≤\ns\ni\n,\nl\ni\n≤\n10\n3\n.\n1≤m≤\n10\n2\n.\n1≤n≤\n10\n9\n.\nOutput\nThe number of possible combinations of trails, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3 2\n1 0 1\n0 1 1\noutput\nCopy\n18",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "matrices",
            "*2000"
        ]
    },
    {
        "title": "E1. Trails (Easy)",
        "description": "Harry Potter is hiking in the Alps surrounding Lake Geneva. In this area there are\nm\ncabins, numbered 1 to\nm\n. Each cabin is connected, with one or more trails, to a central meeting point next to the lake. Each trail is either short or long. Cabin\ni\nis connected with\ns\ni\nshort trails and\nl\ni\nlong trails to the lake.\nEach day, Harry walks a trail from the cabin where he currently is to Lake Geneva, and then from there he walks a trail to any of the\nm\ncabins (including the one he started in). However, as he has to finish the hike in a day, at least one of the two trails has to be short.\nHow many possible combinations of trails can Harry take if he starts in cabin 1 and walks for\nn\ndays?\nGive the answer modulo\n10\n9\n+7\n.\nInput\nThe first line contains the integers\nm\nand\nn\n.\nThe second line contains\nm\nintegers,\ns\n1\n,…,\ns\nm\n, where\ns\ni\nis the number of short trails between cabin\ni\nand Lake Geneva.\nThe third and last line contains\nm\nintegers,\nl\n1\n,…,\nl\nm\n, where\nl\ni\nis the number of long trails between cabin\ni\nand Lake Geneva.\nWe have the following constraints:\n0≤\ns\ni\n,\nl\ni\n≤\n10\n3\n.\n1≤m≤\n10\n2\n.\n1≤n≤\n10\n3\n.\nOutput\nThe number of possible combinations of trails, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3 2\n1 0 1\n0 1 1\noutput\nCopy\n18",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "*1800"
        ]
    },
    {
        "title": "D3. Arithmancy (Hard)",
        "description": "The only difference between the versions of this problem is the maximum value of\nn\n.\nProfessor Vector is preparing to teach her Arithmancy class. She needs to prepare\nn\ndistinct magic words for the class. Each magic word is a string consisting of characters X and O. A spell is a string created by concatenating two magic words together. The power of a spell is equal to the number of its different non-empty substrings. For example, the power of the spell XOXO is equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and XOXO.\nEach student will create their own spell by concatenating two magic words. Since the students are not very good at magic yet, they will choose each of the two words independently and uniformly at random from the\nn\nwords provided by Professor Vector. It is therefore also possible that the two words a student chooses are the same. Each student will then compute the power of their spell, and tell it to Professor Vector. In order to check their work, and of course to impress the students, Professor Vector needs to find out which two magic words and in which order were concatenated by each student.\nYour program needs to perform the role of Professor Vector: first, create\nn\ndistinct magic words, and then handle multiple requests where it is given the spell power and needs to determine the indices of the two magic words, in the correct order, that were used to create the corresponding spell.\nInteraction\nThis is an interactive problem.\nFirst, your program should read a single integer\nn\n(\n1≤n≤1000\n), the number of magic words to prepare. Then, it should print\nn\nmagic words it has created, one per line. The magic words must be distinct, each magic word must have at least 1 and at most\n30⋅n\ncharacters, and each character must be either X or O. We will denote the\ni\n-th magic word you printed as\nw\ni\n(\n1≤i≤n\n).\nThen, your program should read a single integer\nq\n(\n1≤q≤1000\n), the number of students in the class. Then, it should repeat the following process\nq\ntimes, one per student.\nFor the\nj\n-th student, it should first read a single integer\np\nj\n, the power of their spell. It is guaranteed that this number is computed by choosing two indices\nu\nj\nand\nv\nj\nindependently and uniformly at random between 1 and\nn\ninclusive, concatenating\nw\nu\nj\nand\nw\nv\nj\n, and finding the number of different non-empty substrings of the resulting string. Then, your program must print the numbers\nu\nj\nand\nv\nj\n, in this order (\n1≤\nu\nj\n,\nv\nj\n≤n\n).\nNote that it is not enough to find any two magic words that concatenate into a spell with the given power. You must find the exact words used by the student in the exact order.\nRemember to flush the output stream after printing all magic words and after printing\nu\nj\nand\nv\nj\nfor each student.\nExample\ninput\nCopy\n2\n\n\n2\n15\n\n11\noutput\nCopy\nXOXO\nX\n\n\n1 1\n\n2 1",
        "time_limit": "10 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "interactive",
            "*3100"
        ]
    },
    {
        "title": "D2. Arithmancy (Medium)",
        "description": "The only difference between the versions of this problem is the maximum value of\nn\n.\nProfessor Vector is preparing to teach her Arithmancy class. She needs to prepare\nn\ndistinct magic words for the class. Each magic word is a string consisting of characters X and O. A spell is a string created by concatenating two magic words together. The power of a spell is equal to the number of its different non-empty substrings. For example, the power of the spell XOXO is equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and XOXO.\nEach student will create their own spell by concatenating two magic words. Since the students are not very good at magic yet, they will choose each of the two words independently and uniformly at random from the\nn\nwords provided by Professor Vector. It is therefore also possible that the two words a student chooses are the same. Each student will then compute the power of their spell, and tell it to Professor Vector. In order to check their work, and of course to impress the students, Professor Vector needs to find out which two magic words and in which order were concatenated by each student.\nYour program needs to perform the role of Professor Vector: first, create\nn\ndistinct magic words, and then handle multiple requests where it is given the spell power and needs to determine the indices of the two magic words, in the correct order, that were used to create the corresponding spell.\nInteraction\nThis is an interactive problem.\nFirst, your program should read a single integer\nn\n(\n1≤n≤30\n), the number of magic words to prepare. Then, it should print\nn\nmagic words it has created, one per line. The magic words must be distinct, each magic word must have at least 1 and at most\n30⋅n\ncharacters, and each character must be either X or O. We will denote the\ni\n-th magic word you printed as\nwi\n(\n1≤i≤n\n).\nThen, your program should read a single integer\nq\n(\n1≤q≤1000\n), the number of students in the class. Then, it should repeat the following process\nq\ntimes, one per student.\nFor the\nj\n-th student, it should first read a single integer\npj\n, the power of their spell. It is guaranteed that this number is computed by choosing two indices\nuj\nand\nvj\nindependently and uniformly at random between 1 and\nn\ninclusive, concatenating\nwuj\nand\nwvj\n, and finding the number of different non-empty substrings of the resulting string. Then, your program must print the numbers\nuj\nand\nvj\n, in this order (\n1≤uj,vj≤n\n).\nNote that it is not enough to find any two magic words that concatenate into a spell with the given power. You must find the exact words used by the student in the exact order.\nRemember to flush the output stream after printing all magic words and after printing\nuj\nand\nvj\nfor each student.\nExample\ninput\nCopy\n2\n\n\n2\n15\n\n11\noutput\nCopy\nXOXO\nX\n\n\n1 1\n\n2 1",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "interactive",
            "probabilities",
            "strings",
            "*2600"
        ]
    },
    {
        "title": "D1. Arithmancy (Easy)",
        "description": "Professor Vector is preparing to teach her Arithmancy class. She needs to prepare\nn\ndistinct magic words for the class. Each magic word is a string consisting of characters X and O. A spell is a string created by concatenating two magic words together. The power of a spell is equal to the number of its different non-empty substrings. For example, the power of the spell XOXO is equal to 7, because it has 7 different substrings: X, O, XO, OX, XOX, OXO and XOXO.\nEach student will create their own spell by concatenating two magic words. Since the students are not very good at magic yet, they will choose each of the two words independently and uniformly at random from the\nn\nwords provided by Professor Vector. It is therefore also possible that the two words a student chooses are the same. Each student will then compute the power of their spell, and tell it to Professor Vector. In order to check their work, and of course to impress the students, Professor Vector needs to find out which two magic words and in which order were concatenated by each student.\nYour program needs to perform the role of Professor Vector: first, create\nn\ndistinct magic words, and then handle multiple requests where it is given the spell power and needs to determine the indices of the two magic words, in the correct order, that were used to create the corresponding spell.\nInteraction\nThis is an interactive problem.\nFirst, your program should read a single integer\nn\n(\n1≤n≤3\n), the number of magic words to prepare. Then, it should print\nn\nmagic words it has created, one per line. The magic words must be distinct, each magic word must have at least 1 and at most\n30⋅n\ncharacters, and each character must be either X or O. We will denote the\ni\n-th magic word you printed as\nwi\n(\n1≤i≤n\n).\nThen, your program should read a single integer\nq\n(\n1≤q≤1000\n), the number of students in the class. Then, it should repeat the following process\nq\ntimes, one per student.\nFor the\nj\n-th student, it should first read a single integer\npj\n, the power of their spell. It is guaranteed that this number is computed by choosing two indices\nuj\nand\nvj\nindependently and uniformly at random between 1 and\nn\ninclusive, concatenating\nwuj\nand\nwvj\n, and finding the number of different non-empty substrings of the resulting string. Then, your program must print the numbers\nuj\nand\nvj\n, in this order (\n1≤uj,vj≤n\n).\nNote that it is not enough to find any two magic words that concatenate into a spell with the given power. You must find the exact words used by the student in the exact order.\nRemember to flush the output stream after printing all magic words and after printing\nuj\nand\nvj\nfor each student.\nExample\ninput\nCopy\n2\n\n\n2\n15\n\n11\noutput\nCopy\nXOXO\nX\n\n\n1 1\n\n2 1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "interactive",
            "strings",
            "*2100"
        ]
    },
    {
        "title": "C3. Game on Tree (Hard)",
        "description": "This is the hard version of the problem. The only difference in this version is the constraint on\nt\n.\nRon and Hermione are playing a game on a tree of\nn\nnodes that are initially inactive. The game consists of\nt\nrounds, each of which starts with a stone on exactly one node, which is considered as activated. A move consists of picking an inactive neighbor of the node with a stone on it and moving the stone there (thus activating this neighbor). Ron makes the first move, after which he alternates with Hermione until no valid move is available. The player that cannot make a move loses the round. If both players play optimally, who wins each round of this game?\nNote that all the rounds are played with the same tree; only the starting node changes. Moreover, after each round, all active nodes are considered inactive again.\nInput\nThe first line contains integers\nn\n(\n2≤n≤2×\n10\n5\n),\nt\n(\n1≤t≤n\n), the number of nodes in the tree and the number of rounds, respectively.\nThe next\nn−1\nlines contain two integers\n1≤u,v≤n\neach, corresponding to an edge of the tree.\nThe next line contains\nt\nintegers\n1≤\nu\n1\n,…,\nu\nt\n≤n\n, corresponding to the node where the stone is initially put.\nOutput\nThe output consists of\nt\nlines, each line being either \"Ron\" or \"Hermione\".\nExamples\ninput\nCopy\n5 2\n1 2\n1 3\n3 4\n3 5\n1 2\noutput\nCopy\nRon\nRon\ninput\nCopy\n6 3\n1 2\n2 3\n1 4\n4 5\n4 6\n1 4 6\noutput\nCopy\nHermione\nRon\nHermione",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "games",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "C2. Game on Tree (Medium)",
        "description": "This is the medium version of the problem. The difference in this version is that\nt=1\nand we work on trees.\nRon and Hermione are playing a game on a tree of\nn\nnodes that are initially inactive. The game consists of\nt\nrounds, each of which starts with a stone on exactly one node, which is considered as activated. A move consists of picking an inactive neighbor of the node with a stone on it and moving the stone there (thus activating this neighbor). Ron makes the first move, after which he alternates with Hermione until no valid move is available. The player that cannot make a move loses the round. If both players play optimally, who wins each round of this game?\nNote that all the rounds are played with the same tree; only the starting node changes. Moreover, after each round, all active nodes are considered inactive again.\nInput\nThe first line contains integers\nn\n(\n2≤n≤2×\n10\n5\n),\nt\n(\nt=1\n), the number of nodes in the tree and the number of rounds, respectively.\nThe next\nn−1\nlines contain two integers\n1≤u,v≤n\neach, corresponding to an edge of the tree.\nThe next line contains\nt\nintegers\n1≤\nu\n1\n,…,\nu\nt\n≤n\n, corresponding to the node where the stone is initially put.\nOutput\nThe output consists of\nt=1\nline which is either \"Ron\" or \"Hermione\".\nExample\ninput\nCopy\n5 1\n1 2\n1 3\n3 4\n3 5\n1\noutput\nCopy\nRon",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "games",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "C1. Game on Tree (Easy)",
        "description": "This is the easy version of the problem. The difference in this version is that\nt=1\nand we work on an array-like tree.\nRon and Hermione are playing a game on a tree of\nn\nnodes that are initially inactive. This tree is special because it has exactly two leaves. It can thus be seen as an array. The game consists of\nt\nrounds, each of which starts with a stone on exactly one node, which is considered as activated. A move consists of picking an inactive neighbor of the node with a stone on it and moving the stone there (thus activating this neighbor). Ron makes the first move, after which he alternates with Hermione until no valid move is available. The player that cannot make a move loses the round. If both players play optimally, who wins each round of this game?\nNote that all the rounds are played with the same tree; only the starting node changes. Moreover, after each round, all active nodes are considered inactive again.\nInput\nThe first line contains integers\nn\n(\n2≤n≤2×\n10\n5\n),\nt\n(\nt=1\n), the number of nodes in the tree and the number of rounds, respectively.\nThe next\nn−1\nlines contain two integers\n1≤u,v≤n\neach, corresponding to an edge of the tree. It is guaranteed that the tree has exactly two leaves.\nThe next line contains\nt\nintegers\n1≤\nu\n1\n,…,\nu\nt\n≤n\n, corresponding to the node where the stone is initially put.\nOutput\nThe output consists of\nt=1\nline which is either \"Ron\" or \"Hermione\".\nExamples\ninput\nCopy\n3 1\n2 3\n3 1\n3\noutput\nCopy\nRon\ninput\nCopy\n5 1\n1 2\n2 3\n3 4\n4 5\n5\noutput\nCopy\nHermione",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "*1400"
        ]
    },
    {
        "title": "B3. Exact Neighbours (Hard)",
        "description": "After some recent attacks on Hogwarts Castle by the Death Eaters, the Order of the Phoenix has decided to station\nn\nmembers in Hogsmead Village. The houses will be situated on a picturesque\nn×n\nsquare field. Each wizard will have their own house, and every house will belong to some wizard. Each house will take up the space of one square.\nHowever, as you might know wizards are very superstitious. During the weekends, each wizard\ni\nwill want to visit the house that is exactly\na\ni\n(0≤\na\ni\n≤n)\naway from their own house. The roads in the village are built horizontally and vertically, so the distance between points\n(\nx\ni\n,\ny\ni\n)\nand\n(\nx\nj\n,\ny\nj\n)\non the\nn×n\nfield is\n|\nx\ni\n−\nx\nj\n|+|\ny\ni\n−\ny\nj\n|\n. The wizards know and trust each other, so one wizard can visit another wizard's house when the second wizard is away. The houses to be built will be big enough for all\nn\nwizards to simultaneously visit any house.\nApart from that, each wizard is mandated to have a view of the Hogwarts Castle in the north and the Forbidden Forest in the south, so the house of no other wizard should block the view. In terms of the village, it means that in each column of the\nn×n\nfield, there can be at most one house, i.e. if the\ni\n-th house has coordinates\n(\nx\ni\n,\ny\ni\n)\n, then\nx\ni\n≠\nx\nj\nfor all\ni≠j\n.\nThe Order of the Phoenix doesn't yet know if it is possible to place\nn\nhouses in such a way that will satisfy the visit and view requirements of all\nn\nwizards, so they are asking for your help in designing such a plan.\nIf it is possible to have a correct placement, where for the\ni\n-th wizard there is a house that is\na\ni\naway from it and the house of the\ni\n-th wizard is the only house in their column, output YES, the position of houses for each wizard, and to the house of which wizard should each wizard go during the weekends.\nIf it is impossible to have a correct placement, output NO.\nInput\nThe first line contains\nn\n(\n2≤n≤2⋅\n10\n5\n), the number of houses to be built.\nThe second line contains\nn\nintegers\na\n1\n,…,\na\nn\n(0≤\na\ni\n≤n)\nOutput\nIf there exists such a placement, output YES on the first line; otherwise, output NO.\nIf the answer is YES, output\nn+1\nmore lines describing the placement.\nThe next\nn\nlines should contain the positions of the houses\n1≤\nx\ni\n,\ny\ni\n≤n\nfor each wizard.\nThe\ni\n-th element of the last line should contain the index of the wizard, the house of which is exactly\na\ni\naway from the house of the\ni\n-th wizard. If there are multiple such wizards, you can output any.\nIf there are multiple house placement configurations, you can output any.\nExamples\ninput\nCopy\n4\n0 4 2 4\noutput\nCopy\nYES\n4 4\n1 3\n2 4\n3 1\n1 1 1 3\ninput\nCopy\n4\n1 3 0 1\noutput\nCopy\nYES\n2 1\n4 1\n1 1\n3 1\n3 3 3 1\nNote\nFor the sample, the house of the 1st wizard is located at\n(4,4)\n, of the 2nd at\n(1,3)\n, of the 3rd at\n(2,4)\n, of the 4th at\n(3,1)\n.\nThe distance from the house of the 1st wizard to the house of the 1st wizard is\n|4−4|+|4−4|=0\n.\nThe distance from the house of the 2nd wizard to the house of the 1st wizard is\n|1−4|+|3−4|=4\n.\nThe distance from the house of the 3rd wizard to the house of the 1st wizard is\n|2−4|+|4−4|=2\n.\nThe distance from the house of the 4th wizard to the house of the 3rd wizard is\n|3−2|+|1−4|=4\n.\nThe view and the distance conditions are satisfied for all houses, so the placement is correct.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*2300"
        ]
    },
    {
        "title": "B2. Exact Neighbours (Medium)",
        "description": "The only difference between this and the hard version is that\na\n1\n=0\n.\nAfter some recent attacks on Hogwarts Castle by the Death Eaters, the Order of the Phoenix has decided to station\nn\nmembers in Hogsmead Village. The houses will be situated on a picturesque\nn×n\nsquare field. Each wizard will have their own house, and every house will belong to some wizard. Each house will take up the space of one square.\nHowever, as you might know wizards are very superstitious. During the weekends, each wizard\ni\nwill want to visit the house that is exactly\na\ni\n(0≤\na\ni\n≤n)\naway from their own house. The roads in the village are built horizontally and vertically, so the distance between points\n(\nx\ni\n,\ny\ni\n)\nand\n(\nx\nj\n,\ny\nj\n)\non the\nn×n\nfield is\n|\nx\ni\n−\nx\nj\n|+|\ny\ni\n−\ny\nj\n|\n. The wizards know and trust each other, so one wizard can visit another wizard's house when the second wizard is away. The houses to be built will be big enough for all\nn\nwizards to simultaneously visit any house.\nApart from that, each wizard is mandated to have a view of the Hogwarts Castle in the north and the Forbidden Forest in the south, so the house of no other wizard should block the view. In terms of the village, it means that in each column of the\nn×n\nfield, there can be at most one house, i.e. if the\ni\n-th house has coordinates\n(\nx\ni\n,\ny\ni\n)\n, then\nx\ni\n≠\nx\nj\nfor all\ni≠j\n.\nThe Order of the Phoenix doesn't yet know if it is possible to place\nn\nhouses in such a way that will satisfy the visit and view requirements of all\nn\nwizards, so they are asking for your help in designing such a plan.\nIf it is possible to have a correct placement, where for the\ni\n-th wizard there is a house that is\na\ni\naway from it and the house of the\ni\n-th wizard is the only house in their column, output YES, the position of houses for each wizard, and to the house of which wizard should each wizard go during the weekends.\nIf it is impossible to have a correct placement, output NO.\nInput\nThe first line contains\nn\n(\n2≤n≤2⋅\n10\n5\n), the number of houses to be built.\nThe second line contains\nn\nintegers\na\n1\n,…,\na\nn\n(0≤\na\ni\n≤n)\n,\na\n1\n=0\n.\nOutput\nIf there exists such a placement, output YES on the first line; otherwise, output NO.\nIf the answer is YES, output\nn+1\nmore lines describing the placement.\nThe next\nn\nlines should contain the positions of the houses\n1≤\nx\ni\n,\ny\ni\n≤n\nfor each wizard.\nThe\ni\n-th element of the last line should contain the index of the wizard, the house of which is exactly\na\ni\naway from the house of the\ni\n-th wizard. If there are multiple such wizards, you can output any.\nIf there are multiple house placement configurations, you can output any.\nExamples\ninput\nCopy\n4\n0 4 2 4\noutput\nCopy\nYES\n4 4\n1 3\n2 4\n3 1\n1 1 1 3\ninput\nCopy\n4\n0 1 3 1\noutput\nCopy\nYES\n1 1\n2 1\n4 1\n3 1\n1 1 1 3\nNote\nFor the sample, the house of the 1st wizard is located at\n(4,4)\n, of the 2nd at\n(1,3)\n, of the 3rd at\n(2,4)\n, of the 4th at\n(3,1)\n.\nThe distance from the house of the 1st wizard to the house of the 1st wizard is\n|4−4|+|4−4|=0\n.\nThe distance from the house of the 2nd wizard to the house of the 1st wizard is\n|1−4|+|3−4|=4\n.\nThe distance from the house of the 3rd wizard to the house of the 1st wizard is\n|2−4|+|4−4|=2\n.\nThe distance from the house of the 4th wizard to the house of the 3rd wizard is\n|3−2|+|1−4|=4\n.\nThe view and the distance conditions are satisfied for all houses, so the placement is correct.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*2100"
        ]
    },
    {
        "title": "B1. Exact Neighbours (Easy)",
        "description": "The only difference between this and the hard version is that all\na\ni\nare even.\nAfter some recent attacks on Hogwarts Castle by the Death Eaters, the Order of the Phoenix has decided to station\nn\nmembers in Hogsmead Village. The houses will be situated on a picturesque\nn×n\nsquare field. Each wizard will have their own house, and every house will belong to some wizard. Each house will take up the space of one square.\nHowever, as you might know wizards are very superstitious. During the weekends, each wizard\ni\nwill want to visit the house that is exactly\na\ni\n(0≤\na\ni\n≤n)\naway from their own house. The roads in the village are built horizontally and vertically, so the distance between points\n(\nx\ni\n,\ny\ni\n)\nand\n(\nx\nj\n,\ny\nj\n)\non the\nn×n\nfield is\n|\nx\ni\n−\nx\nj\n|+|\ny\ni\n−\ny\nj\n|\n. The wizards know and trust each other, so one wizard can visit another wizard's house when the second wizard is away. The houses to be built will be big enough for all\nn\nwizards to simultaneously visit any house.\nApart from that, each wizard is mandated to have a view of the Hogwarts Castle in the north and the Forbidden Forest in the south, so the house of no other wizard should block the view. In terms of the village, it means that in each column of the\nn×n\nfield, there can be at most one house, i.e. if the\ni\n-th house has coordinates\n(\nx\ni\n,\ny\ni\n)\n, then\nx\ni\n≠\nx\nj\nfor all\ni≠j\n.\nThe Order of the Phoenix doesn't yet know if it is possible to place\nn\nhouses in such a way that will satisfy the visit and view requirements of all\nn\nwizards, so they are asking for your help in designing such a plan.\nIf it is possible to have a correct placement, where for the\ni\n-th wizard there is a house that is\na\ni\naway from it and the house of the\ni\n-th wizard is the only house in their column, output YES, the position of houses for each wizard, and to the house of which wizard should each wizard go during the weekends.\nIf it is impossible to have a correct placement, output NO.\nInput\nThe first line contains\nn\n(\n2≤n≤2⋅\n10\n5\n), the number of houses to be built.\nThe second line contains\nn\nintegers\na\n1\n,…,\na\nn\n(0≤\na\ni\n≤n)\n. All\na\ni\nare even.\nOutput\nIf there exists such a placement, output YES on the first line; otherwise, output NO.\nIf the answer is YES, output\nn+1\nmore lines describing the placement.\nThe next\nn\nlines should contain the positions of the houses\n1≤\nx\ni\n,\ny\ni\n≤n\nfor each wizard.\nThe\ni\n-th element of the last line should contain the index of the wizard, the house of which is exactly\na\ni\naway from the house of the\ni\n-th wizard. If there are multiple such wizards, you can output any.\nIf there are multiple house placement configurations, you can output any.\nExample\ninput\nCopy\n4\n0 4 2 4\noutput\nCopy\nYES\n4 4\n1 3\n2 4\n3 1\n1 1 1 3\nNote\nFor the sample, the house of the 1st wizard is located at\n(4,4)\n, of the 2nd at\n(1,3)\n, of the 3rd at\n(2,4)\n, of the 4th at\n(3,1)\n.\nThe distance from the house of the 1st wizard to the house of the 1st wizard is\n|4−4|+|4−4|=0\n.\nThe distance from the house of the 2nd wizard to the house of the 1st wizard is\n|1−4|+|3−4|=4\n.\nThe distance from the house of the 3rd wizard to the house of the 1st wizard is\n|2−4|+|4−4|=2\n.\nThe distance from the house of the 4th wizard to the house of the 3rd wizard is\n|3−2|+|1−4|=4\n.\nThe view and the distance conditions are satisfied for all houses, so the placement is correct.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1900"
        ]
    },
    {
        "title": "A3. Balanced Unshuffle (Hard)",
        "description": "The only difference with the medium version is the maximum length of the input.\nA parentheses sequence is a string consisting of characters \"(\" and \")\", for example \"(()((\".\nA balanced parentheses sequence is a parentheses sequence which can become a valid mathematical expression after inserting numbers and operations into it, for example \"(()(()))\".\nThe balance of a parentheses sequence is defined as the number of opening parentheses \"(\" minus the number of closing parentheses \")\". For example, the balance of the sequence \"(()((\" is 3.\nA balanced parentheses sequence can also be defined as a parentheses sequence with balance 0 such that each of its prefixes has a non-negative balance.\nWe define the balanced shuffle operation that takes a parentheses sequence and returns a parentheses sequence as follows: first, for every character of the input sequence, we compute the balance of the prefix of the sequence before that character and write those down in a table together with the positions of the characters in the input sequence, for example:\nPrefix balance 0 1 2 1 2 3 2 1\nPosition 1 2 3 4 5 6 7 8\nCharacter ( ( ) ( ( ) ) )\nThen, we sort the columns of this table in increasing order of prefix balance, breaking ties in decreasing order of position. In the above example, we get:\nPrefix balance 0 1 1 1 2 2 2 3\nPosition 1 8 4 2 7 5 3 6\nCharacter ( ) ( ( ) ( ) )\nThe last row of this table forms another parentheses sequence, in this case \"()(()())\". This sequence is called the result of applying the balanced shuffle operation to the input sequence, or in short just the balanced shuffle of the input sequence.\nSurprisingly, it turns out that the balanced shuffle of any balanced parentheses sequence is always another balanced parentheses sequence (we will omit the proof for brevity). Even more surprisingly, the balanced shuffles of two different balanced parentheses sequences are always different, therefore the balanced shuffle operation is a bijection on the set of balanced parentheses sequences of any given length (we will omit this proof, too).\nYou are given a balanced parentheses sequence. Find its preimage: the balanced parentheses sequence the balanced shuffle of which is equal to the given sequence.\nInput\nThe only line of input contains a string\ns\nconsisting only of characters \"(\" and \")\". This string is guaranteed to be a non-empty balanced parentheses sequence with its length not exceeding\n500000\n.\nOutput\nPrint the balanced parentheses sequence\nt\nsuch that the balanced shuffle of\nt\nis equal to\ns\n. It is guaranteed that the answer always exists and is unique.\nExample\ninput\nCopy\n()(()())\noutput\nCopy\n(()(()))",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "A2. Balanced Unshuffle (Medium)",
        "description": "The differences with the easy version of this problem are highlighted in bold.\nA parentheses sequence is a string consisting of characters \"(\" and \")\", for example \"(()((\".\nA balanced parentheses sequence is a parentheses sequence which can become a valid mathematical expression after inserting numbers and operations into it, for example \"(()(()))\".\nThe balance of a parentheses sequence is defined as the number of opening parentheses \"(\" minus the number of closing parentheses \")\". For example, the balance of the sequence \"(()((\" is 3.\nA balanced parentheses sequence can also be defined as a parentheses sequence with balance 0 such that each of its prefixes has a non-negative balance.\nWe define the balanced shuffle operation that takes a parentheses sequence and returns a parentheses sequence as follows: first, for every character of the input sequence, we compute the balance of the prefix of the sequence before that character and write those down in a table together with the positions of the characters in the input sequence, for example:\nPrefix balance 0 1 2 1 2 3 2 1\nPosition 1 2 3 4 5 6 7 8\nCharacter ( ( ) ( ( ) ) )\nThen, we sort the columns of this table in increasing order of prefix balance, breaking ties in decreasing order of position. In the above example, we get:\nPrefix balance 0 1 1 1 2 2 2 3\nPosition 1 8 4 2 7 5 3 6\nCharacter ( ) ( ( ) ( ) )\nThe last row of this table forms another parentheses sequence, in this case \"()(()())\". This sequence is called the result of applying the balanced shuffle operation to the input sequence, or in short just the balanced shuffle of the input sequence.\nSurprisingly, it turns out that the balanced shuffle of any balanced parentheses sequence is always another balanced parentheses sequence (we will omit the proof for brevity). Even more surprisingly, the balanced shuffles of two different balanced parentheses sequences are always different, therefore the balanced shuffle operation is a bijection on the set of balanced parentheses sequences of any given length (we will omit this proof, too).\nYou are given a balanced parentheses sequence. Find its preimage: the balanced parentheses sequence the balanced shuffle of which is equal to the given sequence.\nInput\nThe only line of input contains a string\ns\nconsisting only of characters \"(\" and \")\". This string is guaranteed to be a non-empty balanced parentheses sequence with its length not exceeding\n1000\n.\nOutput\nPrint the balanced parentheses sequence\nt\nsuch that the balanced shuffle of\nt\nis equal to\ns\n. It is guaranteed that the answer always exists and is unique.\nExample\ninput\nCopy\n()(()())\noutput\nCopy\n(()(()))",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "A1. Balanced Shuffle (Easy)",
        "description": "A parentheses sequence is a string consisting of characters \"(\" and \")\", for example \"(()((\".\nA balanced parentheses sequence is a parentheses sequence which can become a valid mathematical expression after inserting numbers and operations into it, for example \"(()(()))\".\nThe balance of a parentheses sequence is defined as the number of opening parentheses \"(\" minus the number of closing parentheses \")\". For example, the balance of the sequence \"(()((\" is 3.\nA balanced parentheses sequence can also be defined as a parentheses sequence with balance 0 such that each of its prefixes has a non-negative balance.\nWe define the balanced shuffle operation that takes a parentheses sequence and returns a parentheses sequence as follows: first, for every character of the input sequence, we compute the balance of the prefix of the sequence before that character and write those down in a table together with the positions of the characters in the input sequence, for example:\nPrefix balance 0 1 2 1 2 3 2 1\nPosition 1 2 3 4 5 6 7 8\nCharacter ( ( ) ( ( ) ) )\nThen, we sort the columns of this table in increasing order of prefix balance, breaking ties in decreasing order of position. In the above example, we get:\nPrefix balance 0 1 1 1 2 2 2 3\nPosition 1 8 4 2 7 5 3 6\nCharacter ( ) ( ( ) ( ) )\nThe last row of this table forms another parentheses sequence, in this case \"()(()())\". This sequence is called the result of applying the balanced shuffle operation to the input sequence, or in short just the balanced shuffle of the input sequence.\nYou are given a balanced parentheses sequence. Print its balanced shuffle.\nInput\nThe only line of input contains a string\ns\nconsisting only of characters \"(\" and \")\". This string is guaranteed to be a non-empty balanced parentheses sequence with its length not exceeding\n500000\n.\nOutput\nPrint the parentheses sequence\nt\n — the balanced shuffle of\ns\n.\nExample\ninput\nCopy\n(()(()))\noutput\nCopy\n()(()())",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1000"
        ]
    },
    {
        "title": "F. Card Pairing",
        "description": "There is a deck of\nn\ncards, each card has one of\nk\ntypes. You are given the sequence\na\n1\n,\na\n2\n,…,\na\nn\ndenoting the types of cards in the deck from top to bottom. Both\nn\nand\nk\nare even numbers.\nYou play a game with these cards. First, you draw\nk\ntopmost cards from the deck. Then, the following happens each turn of the game:\nyou choose exactly two cards from your hand and play them. If these cards have the same type, you earn a coin;\nthen, if the deck is not empty, you draw exactly two top cards from it;\nthen, if both your hand and your deck are empty, the game ends. Otherwise, the new turn begins.\nYou have to calculate the maximum number of coins you can earn during the game.\nInput\nThe first line of the input contains two integers\nn\nand\nk\n(\n2≤k≤n≤1000\n, both\nn\nand\nk\nare even).\nThe second line of the input contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤k\n).\nOutput\nPrint one integer — the maximum number of coins you can earn.\nExamples\ninput\nCopy\n4 2\n1 2 1 2\noutput\nCopy\n0\ninput\nCopy\n8 2\n2 1 2 2 1 2 1 2\noutput\nCopy\n1\ninput\nCopy\n4 4\n1 2 1 2\noutput\nCopy\n2\ninput\nCopy\n6 4\n3 2 3 1 2 1\noutput\nCopy\n3\ninput\nCopy\n6 4\n3 2 3 3 2 1\noutput\nCopy\n2\ninput\nCopy\n18 6\n5 6 1 1 6 5 4 1 5 1 1 6 2 6 2 2 6 3\noutput\nCopy\n6\ninput\nCopy\n8 4\n1 2 3 4 4 3 1 2\noutput\nCopy\n2\ninput\nCopy\n8 4\n1 2 3 4 4 3 3 2\noutput\nCopy\n3",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "greedy",
            "hashing",
            "implementation",
            "*3000"
        ]
    },
    {
        "title": "E. Unique Array",
        "description": "You are given an integer array\na\nof length\nn\n. A subarray of\na\nis one of its contiguous subsequences (i. e. an array\n[\na\nl\n,\na\nl+1\n,…,\na\nr\n]\nfor some integers\nl\nand\nr\nsuch that\n1≤l<r≤n\n). Let's call a subarray unique if there is an integer that occurs exactly once in the subarray.\nYou can perform the following operation any number of times (possibly zero): choose an element of the array and replace it with any integer.\nYour task is to calculate the minimum number of aforementioned operation in order for all the subarrays of the array\na\nto be unique.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum number of aforementioned operation in order for all the subarrays of the array\na\nto be unique.\nExample\ninput\nCopy\n4\n3\n2 1 2\n4\n4 4 4 4\n5\n3 1 2 1 2\n5\n1 3 2 1 2\noutput\nCopy\n0\n2\n1\n0\nNote\nIn the second test case, you can replace the\n1\n-st and the\n3\n-rd element, for example, like this:\n[3,4,1,4]\n.\nIn the third test case, you can replace the\n4\n-th element, for example, like this:\n[3,1,2,3,2]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "dp",
            "greedy",
            "*2400"
        ]
    },
    {
        "title": "D. Shop Game",
        "description": "Alice and Bob are playing a game in the shop. There are\nn\nitems in the shop; each item has two parameters:\na\ni\n(item price for Alice) and\nb\ni\n(item price for Bob).\nAlice wants to choose a subset (possibly empty) of items and buy them. After that, Bob does the following:\nif Alice bought less than\nk\nitems, Bob can take all of them for free;\notherwise, he will take\nk\nitems for free that Alice bought (Bob chooses which\nk\nitems it will be), and for the rest of the chosen items, Bob will buy them from Alice and pay\nb\ni\nfor the\ni\n-th item.\nAlice's profit is equal to\n∑\ni∈S\nb\ni\n−\n∑\nj∈T\na\nj\n, where\nS\nis the set of items Bob buys from Alice, and\nT\nis the set of items Alice buys from the shop. In other words, Alice's profit is the difference between the amount Bob pays her and the amount she spends buying the items.\nAlice wants to maximize her profit, Bob wants to minimize Alice's profit. Your task is to calculate Alice's profit if both Alice and Bob act optimally.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n;\n0≤k≤n\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — Alice's profit if both Alice and Bob act optimally.\nExample\ninput\nCopy\n4\n2 0\n2 1\n1 2\n4 1\n1 2 1 4\n3 3 2 3\n4 2\n2 1 1 1\n4 2 3 2\n6 2\n1 3 4 9 1 3\n7 6 8 10 6 8\noutput\nCopy\n1\n1\n0\n7\nNote\nIn the first test case, Alice should buy the\n2\n-nd item and sell it to Bob, so her profit is\n2−1=1\n.\nIn the second test case, Alice should buy the\n1\n-st, the\n2\n-nd and the\n3\n-rd item; then Bob takes the\n1\n-st item for free and pays for the\n2\n-nd and the\n3\n-rd item. Alice's profit is\n(3+2)−(1+2+1)=1\n. Bob could take\n2\n-nd item for free instead; this does not change Alice's profit. Bob won't take the\n3\n-rd item for free, since this would lead to a profit of\n2\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "C. Minimizing the Sum",
        "description": "You are given an integer array\na\nof length\nn\n.\nYou can perform the following operation: choose an element of the array and replace it with any of its neighbor's value.\nFor example, if\na=[3,1,2]\n, you can get one of the arrays\n[3,3,2]\n,\n[3,2,2]\nand\n[1,1,2]\nusing one operation, but not\n[2,1,2\n] or\n[3,4,2]\n.\nYour task is to calculate the minimum possible total sum of the array if you can perform the aforementioned operation at most\nk\ntimes.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤3⋅\n10\n5\n;\n0≤k≤10\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the minimum possible total sum of the array if you can perform the aforementioned operation at most\nk\ntimes.\nExample\ninput\nCopy\n4\n3 1\n3 1 2\n1 3\n5\n4 2\n2 2 1 3\n6 3\n4 1 2 2 4 3\noutput\nCopy\n4\n5\n5\n10\nNote\nIn the first example, one of the possible sequences of operations is the following:\n[3,1,2]→[1,1,2\n].\nIn the second example, you do not need to apply the operation.\nIn the third example, one of the possible sequences of operations is the following:\n[2,2,1,3]→[2,1,1,3]→[2,1,1,1]\n.\nIn the fourth example, one of the possible sequences of operations is the following:\n[4,1,2,2,4,3]→[1,1,2,2,4,3]→[1,1,1,2,4,3]→[1,1,1,2,2,3]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*1700"
        ]
    },
    {
        "title": "B. Shifts and Sorting",
        "description": "Let's define a cyclic shift of some string\ns\nas a transformation from\ns\n1\ns\n2\n…\ns\nn−1\ns\nn\ninto\ns\nn\ns\n1\ns\n2\n…\ns\nn−1\n. In other words, you take one last character\ns\nn\nand place it before the first character while moving all other characters to the right.\nYou are given a binary string\ns\n(a string consisting of only 0-s and/or 1-s).\nIn one operation, you can choose any substring\ns\nl\ns\nl+1\n…\ns\nr\n(\n1≤l<r≤|s|\n) and cyclically shift it. The cost of such operation is equal to\nr−l+1\n(or the length of the chosen substring).\nYou can perform the given operation any number of times. What is the minimum total cost to make\ns\nsorted in non-descending order?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains a binary string\ns\n(\n2≤|s|≤2⋅\n10\n5\n;\ns\ni\n∈\n{0, 1}) — the string you need to sort.\nAdditional constraint on the input: the sum of lengths of strings over all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print the single integer — the minimum total cost to make string sorted using operation above any number of times.\nExample\ninput\nCopy\n5\n10\n0000\n11000\n101011\n01101001\noutput\nCopy\n2\n0\n9\n5\n11\nNote\nIn the first test case, you can choose the whole string and perform a cyclic shift: 10\n→\n01. The length of the substring is\n2\n, so the cost is\n2\n.\nIn the second test case, the string is already sorted, so you don't need to perform any operations.\nIn the third test case, one of the optimal strategies is the next:\nchoose substring\n[1,3]\n: 11000\n→\n01100;\nchoose substring\n[2,4]\n: 01100\n→\n00110;\nchoose substring\n[3,5]\n: 00110\n→\n00011.\nThe total cost is\n3+3+3=9\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ]
    },
    {
        "title": "A. Two Friends",
        "description": "Monocarp wants to throw a party. He has\nn\nfriends, and he wants to have at least\n2\nof them at his party.\nThe\ni\n-th friend's best friend is\np\ni\n. All\np\ni\nare distinct, and for every\ni∈[1,n]\n,\np\ni\n≠i\n.\nMonocarp can send invitations to friends. The\ni\n-th friend comes to the party if both the\ni\n-th friend and the\np\ni\n-th friend receive an invitation (note that the\np\ni\n-th friend doesn't have to actually come to the party). Each invitation is sent to exactly one of the friends.\nFor example, if\np=[3,1,2,5,4]\n, and Monocarp sends invitations to the friends\n[1,2,4,5]\n, then the friends\n[2,4,5]\nwill come to the party. The friend\n1\nwon't come since his best friend didn't receive an invitation; the friend\n3\nwon't come since he didn't receive an invitation.\nCalculate the minimum number of invitations Monocarp has to send so that at least\n2\nfriends come to the party.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤5000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n2≤n≤50\n) — the number of friends;\nthe second line contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n;\np\ni\n≠i\n; all\np\ni\nare distinct).\nOutput\nPrint one integer — the minimum number of invitations Monocarp has to send.\nExample\ninput\nCopy\n3\n5\n3 1 2 5 4\n4\n2 3 4 1\n2\n2 1\noutput\nCopy\n2\n3\n2\nNote\nIn the first testcase, Monocarp can send invitations to friends\n4\nand\n5\n. Both of them will come to the party since they are each other's best friends, and both of them have invitations.\nIn the second testcase, Monocarp can send invitations to friends\n1,2\nand\n3\n, for example. Then friends\n1\nand\n2\nwill attend: friend\n1\nand his best friend\n2\nhave invitations, friend\n2\nand his best friend\n3\nhave invitations. Friend\n3\nwon't attend since his friend\n4\ndoesn't have an invitation. It's impossible to send invitations to fewer than\n3\nfriends in such a way that at least\n2\ncome.\nIn the third testcase, Monocarp can send invitations to both friends\n1\nand\n2\n, and both of them will attend.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "G2. Division + LCP (hard version)",
        "description": "This is the hard version of the problem. In this version\nl≤r\n.\nYou are given a string\ns\n. For a fixed\nk\n, consider a division of\ns\ninto exactly\nk\ncontinuous substrings\nw\n1\n,…,\nw\nk\n. Let\nf\nk\nbe the maximal possible\nLCP(\nw\n1\n,…,\nw\nk\n)\namong all divisions.\nLCP(\nw\n1\n,…,\nw\nm\n)\nis the length of the Longest Common Prefix of the strings\nw\n1\n,…,\nw\nm\n.\nFor example, if\ns=abababcab\nand\nk=4\n, a possible division is\nabababcab\n. The\nLCP(ab,ab,abc,ab)\nis\n2\n, since\nab\nis the Longest Common Prefix of those four strings. Note that each substring consists of a continuous segment of characters and each character belongs to exactly one substring.\nYour task is to find\nf\nl\n,\nf\nl+1\n,…,\nf\nr\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\n,\nl\n,\nr\n(\n1≤l≤r≤n≤2⋅\n10\n5\n) — the length of the string and the given range.\nThe second line of each test case contains string\ns\nof length\nn\n, all characters are lowercase English letters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nr−l+1\nvalues:\nf\nl\n,…,\nf\nr\n.\nExample\ninput\nCopy\n7\n3 1 3\naba\n3 2 3\naaa\n7 1 5\nabacaba\n9 1 6\nabababcab\n10 1 10\naaaaaaawac\n9 1 9\nabafababa\n7 2 7\nvvzvvvv\noutput\nCopy\n3 1 0 \n1 1 \n7 3 1 1 0 \n9 2 2 2 0 0 \n10 3 2 1 1 1 1 1 0 0 \n9 3 2 1 1 0 0 0 0 \n2 2 1 1 1 0 ",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "hashing",
            "math",
            "string suffix structures",
            "strings",
            "*2200"
        ]
    },
    {
        "title": "G1. Division + LCP (easy version)",
        "description": "This is the easy version of the problem. In this version\nl=r\n.\nYou are given a string\ns\n. For a fixed\nk\n, consider a division of\ns\ninto exactly\nk\ncontinuous substrings\nw\n1\n,…,\nw\nk\n. Let\nf\nk\nbe the maximal possible\nLCP(\nw\n1\n,…,\nw\nk\n)\namong all divisions.\nLCP(\nw\n1\n,…,\nw\nm\n)\nis the length of the Longest Common Prefix of the strings\nw\n1\n,…,\nw\nm\n.\nFor example, if\ns=abababcab\nand\nk=4\n, a possible division is\nabababcab\n. The\nLCP(ab,ab,abc,ab)\nis\n2\n, since\nab\nis the Longest Common Prefix of those four strings. Note that each substring consists of a continuous segment of characters and each character belongs to exactly one substring.\nYour task is to find\nf\nl\n,\nf\nl+1\n,…,\nf\nr\n. In this version\nl=r\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\n,\nl\n,\nr\n(\n1≤l=r≤n≤2⋅\n10\n5\n) — the length of the string and the given range.\nThe second line of each test case contains string\ns\nof length\nn\n, all characters are lowercase English letters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nr−l+1\nvalues:\nf\nl\n,…,\nf\nr\n.\nExample\ninput\nCopy\n7\n3 3 3\naba\n3 3 3\naaa\n7 2 2\nabacaba\n9 4 4\nabababcab\n10 1 1\ncodeforces\n9 3 3\nabafababa\n5 3 3\nzpozp\noutput\nCopy\n0\n1\n3\n2\n10\n2\n0\nNote\nIn the first sample\nn=k\n, so the only division of\naba\nis\naba\n. The answer is zero, because those strings do not have a common prefix.\nIn the second sample, the only division is\naaa\n. Their longest common prefix is one.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "hashing",
            "string suffix structures",
            "strings",
            "*1900"
        ]
    },
    {
        "title": "F. Equal XOR Segments",
        "description": "Let us call an array\nx\n1\n,…,\nx\nm\ninteresting if it is possible to divide the array into\nk>1\nparts so that bitwise XOR of values from each part are equal.\nMore formally, you must split array\nx\ninto\nk\nconsecutive segments, each element of\nx\nmust belong to exactly\n1\nsegment. Let\ny\n1\n,…,\ny\nk\nbe the XOR of elements from each part respectively. Then\ny\n1\n=\ny\n2\n=⋯=\ny\nk\nmust be fulfilled.\nFor example, if\nx=[1,1,2,3,0]\n, you can split it as follows:\n[1],[1],[2,3,0]\n. Indeed\n1=1=2⊕3⊕0\n.\nYou are given an array\na\n1\n,…,\na\nn\n. Your task is to answer\nq\nqueries:\nFor fixed\nl\n,\nr\n, determine whether the subarray\na\nl\n,\na\nl+1\n,…,\na\nr\nis interesting.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n2≤n≤2⋅\n10\n5\n,\n1≤q≤2⋅\n10\n5\n) — the number of elements in the array and the number of queries respectively.\nThe next line contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n0≤\na\ni\n<\n2\n30\n) — elements of the array.\nEach of the next\nq\nlines contains two integers\nl\nand\nr\n(\n1≤l<r≤n\n) describing the query.\nIt is guaranteed that the sum of\nn\nover all testcases does not exceed\n2⋅\n10\n5\n.\nIt is guaranteed that the sum of\nq\nover all testcases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output \"YES\" if the subarray is interesting and \"NO\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, the strings \"yES\", \"yes\", and \"Yes\" will be recognized as correct answers).\nExample\ninput\nCopy\n4\n5 5\n1 1 2 3 0\n1 5\n2 4\n3 5\n1 3\n3 4\n5 5\n1 2 3 4 5\n1 5\n2 4\n3 5\n1 3\n2 3\n7 4\n12 9 10 9 10 11 9\n1 5\n1 7\n2 6\n2 7\n11 4\n0 0 1 0 0 1 0 1 1 0 1\n1 2\n2 5\n6 9\n7 11\noutput\nCopy\nYES\nYES\nNO\nNO\nNO\n\nYES\nNO\nNO\nYES\nNO\n\nNO\nNO\nNO\nNO\n\nYES\nNO\nYES\nYES\nNote\nExplanation for the first test case:\nThe first query is described in the statement.\nIn the second query, we should divide\n[1,2,3]\n. A possible division is\n[1,2],[3]\n, since\n1⊕2=3\n.\nIt can be shown that for queries\n3,4,5\n, the subarrays are not interesting.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "*1800"
        ]
    },
    {
        "title": "E. Cells Arrangement",
        "description": "You are given an integer\nn\n. You choose\nn\ncells\n(\nx\n1\n,\ny\n1\n),(\nx\n2\n,\ny\n2\n),…,(\nx\nn\n,\ny\nn\n)\nin the grid\nn×n\nwhere\n1≤\nx\ni\n≤n\nand\n1≤\ny\ni\n≤n\n.\nLet\nH\nbe the set of distinct Manhattan distances between any pair of cells. Your task is to maximize the size of\nH\n. Examples of sets and their construction are given in the notes.\nIf there exists more than one solution, you are allowed to output any.\nManhattan distance between cells\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\nequals\n|\nx\n1\n−\nx\n2\n|+|\ny\n1\n−\ny\n2\n|\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤50\n) — the number of test cases.\nEach of the following\nt\nlines contains a single integer\nn\n(\n2≤n≤\n10\n3\n).\nOutput\nFor each test case, output\nn\npoints which maximize the size of\nH\n. It is not necessary to output an empty line at the end of the answer for each test case.\nExample\ninput\nCopy\n5\n2\n3\n4\n5\n6\noutput\nCopy\n1 1\n1 2\n\n2 1\n2 3\n3 1\n\n1 1\n1 3\n4 3\n4 4\n\n1 1\n1 3\n1 4\n2 1\n5 5\n\n1 4\n1 5\n1 6\n5 2\n5 5\n6 1\nNote\nIn the first testcase we have\nn=2\n. One of the possible arrangements is:\nThe arrangement with cells located in\n(1,1)\nand\n(1,2)\n.\nIn this case\nH={|1−1|+|1−1|,|1−1|+|2−2|,|1−1|+|1−2|}={0,0,1}={0,1}\n. Hence, the size of\nH\nis\n2\n. It can be shown that it is the greatest possible answer.\nIn the second testcase we have\nn=3\n. The optimal arrangement is:\nThe arrangement with cells located in\n(2,1)\n,\n(2,3)\nand\n(3,1)\n.\nH\n=\n{|2−2|+|1−1|,|2−2|+|3−3|,|3−3|+|1−1|,|2−2|+|1−3|,|2−3|+|1−1|,|2−3|+|3−1|}\n=\n{0,0,0,2,1,3}\n=\n{0,1,2,3}\n.\nFor\nn=4\na possible arrangement is:\nFor\nn=5\na possible arrangement is:\nFor\nn=6\na possible arrangement is:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1600"
        ]
    },
    {
        "title": "D. Permutation Game",
        "description": "Bodya and Sasha found a permutation\np\n1\n,…,\np\nn\nand an array\na\n1\n,…,\na\nn\n. They decided to play a well-known \"Permutation game\".\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nBoth of them chose a starting position in the permutation.\nThe game lasts\nk\nturns. The players make moves simultaneously. On each turn, two things happen to each player:\nIf the current position of the player is\nx\n, his score increases by\na\nx\n.\nThen the player either stays at his current position\nx\nor moves from\nx\nto\np\nx\n.\nThe winner of the game is the player with the higher score after exactly\nk\nturns.\nKnowing Bodya's starting position\nP\nB\nand Sasha's starting position\nP\nS\n, determine who wins the game if both players are trying to win.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains integers\nn\n,\nk\n,\nP\nB\n,\nP\nS\n(\n1≤\nP\nB\n,\nP\nS\n≤n≤2⋅\n10\n5\n,\n1≤k≤\n10\n9\n) — length of the permutation, duration of the game, starting positions respectively.\nThe next line contains\nn\nintegers\np\n1\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — elements of the permutation\np\n.\nThe next line contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — elements of array\na\n.\nIt is guaranteed that the sum of values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase output:\n\"Bodya\" if Bodya wins the game.\n\"Sasha\" if Sasha wins the game.\n\"Draw\" if the players have the same score.\nExample\ninput\nCopy\n10\n4 2 3 2\n4 1 2 3\n7 2 5 6\n10 8 2 10\n3 1 4 5 2 7 8 10 6 9\n5 10 5 1 3 7 10 15 4 3\n2 1000000000 1 2\n1 2\n4 4\n8 10 4 1\n5 1 4 3 2 8 6 7\n1 1 2 1 2 100 101 102\n5 1 2 5\n1 2 4 5 3\n4 6 9 4 2\n4 2 3 1\n4 1 3 2\n6 8 5 3\n6 9 5 4\n6 1 3 5 2 4\n6 9 8 9 5 10\n4 8 4 2\n2 3 4 1\n5 2 8 7\n4 2 3 1\n4 1 3 2\n6 8 5 3\n2 1000000000 1 2\n1 2\n1000000000 2\noutput\nCopy\nBodya\nSasha\nDraw\nDraw\nBodya\nSasha\nSasha\nSasha\nSasha\nBodya\nNote\nBelow you can find the explanation for the first testcase, where the game consists of\nk=2\nturns.\nTurn Bodya's position Bodya's score Bodya's move Sasha's position Sasha's score Sasha's move\nfirst\n3\n0+\na\n3\n=0+5=5\nstays on the same position\n2\n0+\na\n2\n=0+2=2\nmoves to\np\n2\n=1\nsecond\n3\n5+\na\n3\n=5+5=10\nstays on the same position\n1\n2+\na\n1\n=2+7=9\nstays on the same position\nfinal results\n3\n10\n1\n9\nAs we may see, Bodya's score is greater, so he wins the game. It can be shown that Bodya always can win this game.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "games",
            "graphs",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "C. Assembly via Remainders",
        "description": "You are given an array\nx\n2\n,\nx\n3\n,…,\nx\nn\n. Your task is to find any array\na\n1\n,…,\na\nn\n, where:\n1≤\na\ni\n≤\n10\n9\nfor all\n1≤i≤n\n.\nx\ni\n=\na\ni\nmod\na\ni−1\nfor all\n2≤i≤n\n.\nHere\ncmodd\ndenotes the remainder of the division of the integer\nc\nby the integer\nd\n. For example\n5mod2=1\n,\n72mod3=0\n,\n143mod14=3\n.\nNote that if there is more than one\na\nwhich satisfies the statement, you are allowed to find any.\nInput\nThe first line contains a single integer\nt\n(1≤t≤\n10\n4\n)\n — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(2≤n≤500)\n — the number of elements in\na\n.\nThe second line of each test case contains\nn−1\nintegers\nx\n2\n,…,\nx\nn\n(1≤\nx\ni\n≤500)\n — the elements of\nx\n.\nIt is guaranteed that the sum of values\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case output any\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) which satisfies the statement.\nExample\ninput\nCopy\n5\n4\n2 4 1\n3\n1 1\n6\n4 2 5 1 2\n2\n500\n3\n1 5\noutput\nCopy\n3 5 4 9\n2 5 11\n5 14 16 5 11 24\n501 500\n2 7 5\nNote\nIn the first test case\na=[3,5,4,9]\nsatisfies the conditions, because:\na\n2\nmod\na\n1\n=5mod3=2=\nx\n2\n;\na\n3\nmod\na\n2\n=4mod5=4=\nx\n3\n;\na\n4\nmod\na\n3\n=9mod4=1=\nx\n4\n;",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "number theory",
            "*1000"
        ]
    },
    {
        "title": "B. Prefiquence",
        "description": "You are given two binary strings\na\nand\nb\n. A binary string is a string consisting of the characters '0' and '1'.\nYour task is to determine the maximum possible number\nk\nsuch that a prefix of string\na\nof length\nk\nis a subsequence of string\nb\n.\nA sequence\na\nis a subsequence of a sequence\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) elements.\nInput\nThe first line consists of a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤2⋅\n10\n5\n) — the length of string\na\nand the length of string\nb\n, respectively.\nThe second line of each test case contains a binary string\na\nof length\nn\n.\nThe third line of each test case contains a binary string\nb\nof length\nm\n.\nIt is guaranteed that the sum of values\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. Similarly, the sum of values\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single number — the maximum\nk\n, such that the first\nk\ncharacters of\na\nform a subsequence of\nb\n.\nExample\ninput\nCopy\n6\n5 4\n10011\n1110\n3 3\n100\n110\n1 3\n1\n111\n4 4\n1011\n1111\n3 5\n100\n11010\n3 1\n100\n0\noutput\nCopy\n2\n2\n1\n1\n3\n0\nNote\nIn the first example, the string '\n10\n' is a subsequence of '\n1110\n' but the string '\n100\n' is not. So the answer is\n2\n.\nIn the fifth example,\na\n='\n100\n',\nb\n='\n11010\n', whole string\na\nis a subsequence of string\nb\n. So the answer is\n3\n.\nIn the sixth example, string\nb\ndoes not contain '\n1\n' so the answer is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "two pointers",
            "*800"
        ]
    },
    {
        "title": "A. Maximize?",
        "description": "You are given an integer\nx\n. Your task is to find any integer\ny\n(1≤y<x)\nsuch that\ngcd(x,y)+y\nis maximum possible.\nNote that if there is more than one\ny\nwhich satisfies the statement, you are allowed to find any.\ngcd(a,b)\nis the Greatest Common Divisor of\na\nand\nb\n. For example,\ngcd(6,4)=2\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach of the following\nt\nlines contains a single integer\nx\n(\n2≤x≤1000\n).\nOutput\nFor each test case, output any\ny\n(\n1≤y<x\n), which satisfies the statement.\nExample\ninput\nCopy\n7\n10\n7\n21\n100\n2\n1000\n6\noutput\nCopy\n5\n6\n18\n98\n1\n750\n3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "F. Next and Prev",
        "description": "Let\np\n1\n,…,\np\nn\nbe a permutation of\n[1,…,n]\n.\nLet the\nq\n-subsequence of\np\nbe a permutation of\n[1,q]\n, whose elements are in the same relative order as in\np\n1\n,…,\np\nn\n. That is, we extract all elements not exceeding\nq\ntogether from\np\nin the original order, and they make the\nq\n-subsequence of\np\n.\nFor a given array\na\n, let\npre(i)\nbe the largest value satisfying\npre(i)<i\nand\na\npre(i)\n>\na\ni\n. If it does not exist, let\npre(i)=−\n10\n100\n. Let\nnxt(i)\nbe the smallest value satisfying\nnxt(i)>i\nand\na\nnxt(i)\n>\na\ni\n. If it does not exist, let\nnxt(i)=\n10\n100\n.\nFor each\nq\nsuch that\n1≤q≤n\n, let\na\n1\n,…,\na\nq\nbe the\nq\n-subsequence of\np\n. For each\ni\nsuch that\n1≤i≤q\n,\npre(i)\nand\nnxt(i)\nwill be calculated as defined. Then, you will be given some integer values of\nx\n, and for each of them you have to calculate\n∑\ni=1\nq\nmin(nxt(i)−pre(i),x)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the length of the permutation.\nThe second line of each test case contains\nn\nintegers\np\n1\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the initial permutation.\nThen, for each\nq\nsuch that\n1≤q≤n\nin ascending order, you will be given an integer\nk\n(\n0≤k≤\n10\n5\n), representing the number of queries for the\nq\n-subsequence. Then\nk\nnumbers in a line follow: each of them is the value of\nx\nfor a single query (\n1≤x≤q\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\nand the sum of\nk\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, for each query, print a single line with an integer: the answer to the query.\nExample\ninput\nCopy\n1\n7\n6 1 4 3 2 5 7\n1 1\n0\n1 3\n1 2\n3 1 2 3\n1 3\n2 2 6\noutput\nCopy\n1\n9\n8\n5\n10\n14\n16\n14\n30\nNote\nThe\n1\n-subsequence is\n[1]\n, and\npre=[−\n10\n100\n]\n,\nnxt=[\n10\n100\n]\n.\nans(1)=min(\n10\n100\n−(−\n10\n100\n),1)=1\n.\nThe\n5\n-subsequence is\n[1,4,3,2,5]\n, and\npre=[−\n10\n100\n,−\n10\n100\n,2,3,−\n10\n100\n]\n,\nnxt=[2,5,5,5,\n10\n100\n]\n.\nans(1)=5,ans(2)=10,ans(3)=14\n.",
        "time_limit": "15 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "*3200"
        ]
    },
    {
        "title": "E2. Again Counting Arrays (Hard Version)",
        "description": "This is the hard version of the problem. The differences between the two versions are the constraints on\nn,m,\nb\n0\nand the time limit. You can make hacks only if both versions are solved.\nLittle R has counted many sets before, and now she decides to count arrays.\nLittle R thinks an array\nb\n0\n,…,\nb\nn\nconsisting of non-negative integers is continuous if and only if, for each\ni\nsuch that\n1≤i≤n\n,\n|\nb\ni\n−\nb\ni−1\n|=1\nis satisfied. She likes continuity, so she only wants to generate continuous arrays.\nIf Little R is given\nb\n0\nand\na\n1\n,…,\na\nn\n, she will try to generate a non-negative continuous array\nb\n, which has no similarity with\na\n. More formally, for all\n1≤i≤n\n,\na\ni\n≠\nb\ni\nholds.\nHowever, Little R does not have any array\na\n. Instead, she gives you\nn\n,\nm\nand\nb\n0\n. She wants to count the different integer arrays\na\n1\n,…,\na\nn\nsatisfying:\n1≤\na\ni\n≤m\n;\nAt least one non-negative continuous array\nb\n0\n,…,\nb\nn\ncan be generated.\nNote that\nb\ni\n≥0\n, but the\nb\ni\ncan be arbitrarily large.\nSince the actual answer may be enormous, please just tell her the answer modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt (1≤t≤\n10\n4\n)\n. The description of the test cases follows.\nThe first and only line of each test case contains three integers\nn\n,\nm\n, and\nb\n0\n(\n1≤n≤2⋅\n10\n6\n,\n1≤m≤2⋅\n10\n6\n,\n0≤\nb\n0\n≤2⋅\n10\n6\n) — the length of the array\na\n1\n,…,\na\nn\n, the maximum possible element in\na\n1\n,…,\na\nn\n, and the initial element of the array\nb\n0\n,…,\nb\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceeds\n10\n7\n.\nOutput\nFor each test case, output a single line containing an integer: the number of different arrays\na\n1\n,…,\na\nn\nsatisfying the conditions, modulo\n998244353\n.\nExample\ninput\nCopy\n6\n3 2 1\n5 5 3\n13 4 1\n100 6 7\n100 11 3\n1000 424 132\noutput\nCopy\n6\n3120\n59982228\n943484039\n644081522\n501350342\nNote\nIn the first test case, for example, when\na=[1,2,1]\n, we can set\nb=[1,0,1,0]\n. When\na=[1,1,2]\n, we can set\nb=[1,2,3,4]\n. In total, there are\n6\nvalid choices of\na\n1\n,…,\na\nn\n: in fact, it can be proved that only\na=[2,1,1]\nand\na=[2,1,2]\nmake it impossible to construct a non-negative continuous\nb\n0\n,…,\nb\nn\n, so the answer is\n2\n3\n−2=6\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*3500"
        ]
    },
    {
        "title": "E1. Again Counting Arrays (Easy Version)",
        "description": "This is the easy version of the problem. The differences between the two versions are the constraints on\nn,m,\nb\n0\nand the time limit. You can make hacks only if both versions are solved.\nLittle R has counted many sets before, and now she decides to count arrays.\nLittle R thinks an array\nb\n0\n,…,\nb\nn\nconsisting of non-negative integers is continuous if and only if, for each\ni\nsuch that\n1≤i≤n\n,\n|\nb\ni\n−\nb\ni−1\n|=1\nis satisfied. She likes continuity, so she only wants to generate continuous arrays.\nIf Little R is given\nb\n0\nand\na\n1\n,…,\na\nn\n, she will try to generate a non-negative continuous array\nb\n, which has no similarity with\na\n. More formally, for all\n1≤i≤n\n,\na\ni\n≠\nb\ni\nholds.\nHowever, Little R does not have any array\na\n. Instead, she gives you\nn\n,\nm\nand\nb\n0\n. She wants to count the different integer arrays\na\n1\n,…,\na\nn\nsatisfying:\n1≤\na\ni\n≤m\n;\nAt least one non-negative continuous array\nb\n0\n,…,\nb\nn\ncan be generated.\nNote that\nb\ni\n≥0\n, but the\nb\ni\ncan be arbitrarily large.\nSince the actual answer may be enormous, please just tell her the answer modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt (1≤t≤\n10\n4\n)\n. The description of the test cases follows.\nThe first and only line of each test case contains three integers\nn\n,\nm\n, and\nb\n0\n(\n1≤n≤2⋅\n10\n5\n,\n1≤m≤2⋅\n10\n5\n,\n0≤\nb\n0\n≤2⋅\n10\n5\n) — the length of the array\na\n1\n,…,\na\nn\n, the maximum possible element in\na\n1\n,…,\na\nn\n, and the initial element of the array\nb\n0\n,…,\nb\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceeds\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing an integer: the number of different arrays\na\n1\n,…,\na\nn\nsatisfying the conditions, modulo\n998244353\n.\nExample\ninput\nCopy\n6\n3 2 1\n5 5 3\n13 4 1\n100 6 7\n100 11 3\n1000 424 132\noutput\nCopy\n6\n3120\n59982228\n943484039\n644081522\n501350342\nNote\nIn the first test case, for example, when\na=[1,2,1]\n, we can set\nb=[1,0,1,0]\n. When\na=[1,1,2]\n, we can set\nb=[1,2,3,4]\n. In total, there are\n6\nvalid choices of\na\n1\n,…,\na\nn\n: in fact, it can be proved that only\na=[2,1,1]\nand\na=[2,1,2]\nmake it impossible to construct a non-negative continuous\nb\n0\n,…,\nb\nn\n, so the answer is\n2\n3\n−2=6\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math",
            "*3100"
        ]
    },
    {
        "title": "D. Long Way to be Non-decreasing",
        "description": "Little R is a magician who likes non-decreasing arrays. She has an array of length\nn\n, initially as\na\n1\n,…,\na\nn\n, in which each element is an integer between\n[1,m]\n. She wants it to be non-decreasing, i.e.,\na\n1\n≤\na\n2\n≤…≤\na\nn\n.\nTo do this, she can perform several magic tricks. Little R has a fixed array\nb\n1\n…\nb\nm\nof length\nm\n. Formally, let's define a trick as a procedure that does the following things in order:\nChoose a set\nS⊆{1,2,…,n}\n.\nFor each\nu∈S\n, assign\na\nu\nwith\nb\na\nu\n.\nLittle R wonders how many tricks are needed at least to make the initial array non-decreasing. If it is not possible with any amount of tricks, print\n−1\ninstead.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤\n10\n6\n,\n1≤m≤\n10\n6\n) — the length of the initial array and the range of the elements in the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤m\n) — the initial array.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,…,\nb\nm\n(\n1≤\nb\ni\n≤m\n) — the fixed magic array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\nand the sum of\nm\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer: the minimum number of tricks needed, or\n−1\nif it is impossible to make\na\n1\n,…,\na\nn\nnon-decreasing.\nExample\ninput\nCopy\n3\n5 8\n1 6 3 7 1\n2 3 5 8 7 1 5 6\n3 3\n1 3 2\n2 1 3\n10 10\n2 8 5 4 8 4 1 5 10 10\n6 7 2 6 3 4 1 1 3 5\noutput\nCopy\n3\n-1\n3\nNote\nIn the first case, the initial array\na\n1\n,…,\na\nn\nis\n[1,6,3,7,1]\n. You can choose\nS\nas follows:\nfirst trick:\nS=[2,4,5]\n,\na=[1,1,3,5,2]\n;\nsecond trick:\nS=[5]\n,\na=[1,1,3,5,3]\n;\nthird trick:\nS=[5]\n,\na=[1,1,3,5,5]\n.\nSo it is possible to make\na\n1\n,…,\na\nn\nnon-decreasing using\n3\ntricks. It can be shown that this is the minimum possible amount of tricks.\nIn the second case, it is impossible to make\na\n1\n,…,\na\nn\nnon-decreasing.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "dfs and similar",
            "graphs",
            "implementation",
            "shortest paths",
            "two pointers",
            "*2800"
        ]
    },
    {
        "title": "C. Fenwick Tree",
        "description": "Let\nlowbit(x)\ndenote the value of the lowest binary bit of\nx\n, e.g.\nlowbit(12)=4\n,\nlowbit(8)=8\n.\nFor an array\na\nof length\nn\n, if an array\ns\nof length\nn\nsatisfies\nsk=(\nk\n∑\ni=k−lowbit(k)+1\nai)mod998244353\nfor all\nk\n, then\ns\nis called the Fenwick Tree of\na\n. Let's denote it as\ns=f(a)\n.\nFor a positive integer\nk\nand an array\na\n,\nfk(a)\nis defined as follows:\nfk(a)={\nf(a) if k=1\nf(fk−1(a)) otherwise.\nYou are given an array\nb\nof length\nn\nand a positive integer\nk\n. Find an array\na\nthat satisfies\n0≤ai<998244353\nand\nfk(a)=b\n. It can be proved that an answer always exists. If there are multiple possible answers, you may print any of them.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤104\n). The description of the test cases follows.\nThe first line of each test case contains two positive integers\nn\n(\n1≤n≤2⋅105\n) and\nk\n(\n1≤k≤109\n), representing the length of the array and the number of times the function\nf\nis performed.\nThe second line of each test case contains an array\nb1,b2,…,bn\n(\n0≤bi<998244353\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, print a single line, containing a valid array\na\nof length\nn\n.\nExample\ninput\nCopy\n2\n8 1\n1 2 1 4 1 2 1 8\n6 2\n1 4 3 17 5 16\noutput\nCopy\n1 1 1 1 1 1 1 1\n1 2 3 4 5 6\nNote\nIn the first test case, it can be seen that\nf1([1,1,1,1,1,1,1,1])=[1,2,1,4,1,2,1,8]\n.\nIn the second test case, it can be seen that\nf2([1,2,3,4,5,6])=f1([1,3,3,10,5,11])=[1,4,3,17,5,16]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "data structures",
            "dp",
            "math",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "B2. Reverse Card (Hard Version)",
        "description": "The two versions are different problems. You may want to read both versions. You can make hacks only if both versions are solved.\nYou are given two positive integers\nn\n,\nm\n.\nCalculate the number of ordered pairs\n(a,b)\nsatisfying the following conditions:\n1≤a≤n\n,\n1≤b≤m\n;\nb⋅gcd(a,b)\nis a multiple of\na+b\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n1≤n,m≤2⋅\n10\n6\n).\nIt is guaranteed that neither the sum of\nn\nnor the sum of\nm\nover all test cases exceeds\n2⋅\n10\n6\n.\nOutput\nFor each test case, print a single integer: the number of valid pairs.\nExample\ninput\nCopy\n6\n1 1\n2 3\n3 5\n10 8\n100 1233\n1000000 1145141\noutput\nCopy\n0\n1\n1\n6\n423\n5933961\nNote\nIn the first test case, no pair satisfies the conditions.\nIn the fourth test case,\n(2,2),(3,6),(4,4),(6,3),(6,6),(8,8)\nsatisfy the conditions.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "B1. Reverse Card (Easy Version)",
        "description": "The two versions are different problems. You may want to read both versions. You can make hacks only if both versions are solved.\nYou are given two positive integers\nn\n,\nm\n.\nCalculate the number of ordered pairs\n(a,b)\nsatisfying the following conditions:\n1≤a≤n\n,\n1≤b≤m\n;\na+b\nis a multiple of\nb⋅gcd(a,b)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nm\n(\n1≤n,m≤2⋅\n10\n6\n).\nIt is guaranteed that neither the sum of\nn\nnor the sum of\nm\nover all test cases exceeds\n2⋅\n10\n6\n.\nOutput\nFor each test case, print a single integer: the number of valid pairs.\nExample\ninput\nCopy\n6\n1 1\n2 3\n3 5\n10 8\n100 1233\n1000000 1145141\noutput\nCopy\n1\n3\n4\n14\n153\n1643498\nNote\nIn the first test case, only\n(1,1)\nsatisfies the conditions.\nIn the fourth test case,\n(1,1),(2,1),(2,2),(3,1),(4,1),(5,1),(6,1),(6,2),(6,3),(7,1),(8,1),(9,1),(10,1),(10,2)\nsatisfy the conditions.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1400"
        ]
    },
    {
        "title": "A. Permutation Counting",
        "description": "You have some cards. An integer between\n1\nand\nn\nis written on each card: specifically, for each\ni\nfrom\n1\nto\nn\n, you have\na\ni\ncards which have the number\ni\nwritten on them.\nThere is also a shop which contains unlimited cards of each type. You have\nk\ncoins, so you can buy\nk\nnew cards in total, and the cards you buy can contain any integer between\n1\nand\nn\n.\nAfter buying the new cards, you rearrange all your cards in a line. The score of a rearrangement is the number of (contiguous) subarrays of length\nn\nwhich are a permutation of\n[1,2,…,n]\n. What's the maximum score you can get?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt (1≤t≤100)\n. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nk\n(\n1≤n≤2⋅\n10\n5\n,\n0≤k≤\n10\n12\n) — the number of distinct types of cards and the number of coins.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n) — the number of cards of type\ni\nyou have at the beginning.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing an integer: the maximum score you can get.\nExample\ninput\nCopy\n8\n1 10\n1\n2 4\n8 4\n3 4\n6 1 8\n3 9\n7 6 2\n5 3\n6 6 7 4 6\n9 7\n7 6 1 7 6 2 4 3 3\n10 10\n1 3 1 2 1 9 3 5 7 5\n9 8\n5 8 7 5 1 3 2 9 8\noutput\nCopy\n11\n15\n15\n22\n28\n32\n28\n36\nNote\nIn the first test case, the final (and only) array we can get is\n[1,1,1,1,1,1,1,1,1,1,1]\n(including\n11\nsingle\n1\ns), which contains\n11\nsubarrays consisting of a permutation of\n[1]\n.\nIn the second test case, we can buy\n0\ncards of type\n1\nand\n4\ncards of type\n2\n, and then we rearrange the cards as following:\n[1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2]\n. There are\n8\nsubarrays equal to\n[1,2]\nand\n7\nsubarrays equal to\n[2,1]\n, which make a total of\n15\nsubarrays which are a permutation of\n[1,2]\n. It can also be proved that this is the maximum score we can get.\nIn the third test case, one of the possible optimal rearrangements is\n[3,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,3]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "B. Rectangle Filling",
        "description": "There is an\nn×m\ngrid of white and black squares. In one operation, you can select any two squares of the same color, and color all squares in the subrectangle between them that color.\nFormally, if you select positions\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\n, both of which are currently the same color\nc\n, set the color of all\n(x,y)\nwhere\nmin(\nx\n1\n,\nx\n2\n)≤x≤max(\nx\n1\n,\nx\n2\n)\nand\nmin(\ny\n1\n,\ny\n2\n)≤y≤max(\ny\n1\n,\ny\n2\n)\nto\nc\n.\nThis diagram shows a sequence of two possible operations on a grid:\nIs it possible for all squares in the grid to be the same color, after performing any number of operations (possibly zero)?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤500\n) — the number of rows and columns in the grid, respectively.\nEach of the next\nn\nlines contains\nm\ncharacters 'W' and 'B' — the initial colors of the squares of the grid.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print \"YES\" if it is possible to make all squares in the grid the same color, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n8\n2 1\nW\nB\n6 6\nWWWWBW\nWBWWWW\nBBBWWW\nBWWWBB\nWWBWBB\nBBBWBW\n1 1\nW\n2 2\nBB\nBB\n3 4\nBWBW\nWBWB\nBWBW\n4 2\nBB\nBB\nWW\nWW\n4 4\nWWBW\nBBWB\nWWBB\nBBBB\n1 5\nWBBWB\noutput\nCopy\nNO\nYES\nYES\nYES\nYES\nNO\nYES\nNO\nNote\nIn the first example, it is impossible to ever change the color of any square with an operation, so we output NO.\nThe second example is the case pictured above. As shown in that diagram, it is possible for all squares to be white after two operations, so we output YES.\nIn the third and fourth examples, all squares are already the same color, so we output YES.\nIn the fifth example we can do everything in two operations. First, select positions\n(2,1)\nand\n(1,4)\nand color all squares with\n1≤x≤2\nand\n1≤y≤4\nto white. Then, select positions\n(2,1)\nand\n(3,4)\nand color all squares with\n2≤x≤3\nand\n1≤y≤4\nto white. After these two operations all squares are white.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "A. Card Exchange",
        "description": "You have a hand of\nn\ncards, where each card has a number written on it, and a fixed integer\nk\n. You can perform the following operation any number of times:\nChoose any\nk\ncards from your hand that all have the same number.\nExchange these cards for\nk−1\ncards, each of which can have any number you choose (including the number written on the cards you just exchanged).\nHere is one possible sequence of operations for the first example case, which has\nk=3\n:\nWhat is the minimum number of cards you can have in your hand at the end of this process?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤100\n,\n2≤k≤100\n) — the number of cards you have, and the number of cards you exchange during each operation, respectively.\nThe next line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…\nc\nn\n(\n1≤\nc\ni\n≤100\n) — the numbers written on your cards.\nOutput\nFor each test case, output a single integer — the minimum number of cards you can have left in your hand after any number of operations.\nExample\ninput\nCopy\n7\n5 3\n4 1 1 4 4\n1 10\n7\n7 2\n4 2 1 100 5 2 3\n10 4\n1 1 1 1 1 1 1 1 1 1\n5 2\n3 8 1 48 7\n6 2\n10 20 30 10 20 40\n6 3\n10 20 30 10 20 40\noutput\nCopy\n2\n1\n1\n3\n5\n1\n6\nNote\nThe first example case corresponds to the picture above. The sequence of operations displayed there is optimal, so the answer is\n2\n.\nIn the second example case, no operations can be performed, so the answer is\n1\n.\nIn the fourth example case, you can repeatedly select\n4\ncards numbered with\n1\nand replace them with\n3\ncards numbered with\n1\n, until there are\n3\ncards left.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "greedy",
            "*800"
        ]
    },
    {
        "title": "F. Conference",
        "description": "You have been asked to organize a very important art conference. The first step is to choose the dates.\nThe conference must last for a certain number of consecutive days. Each day, one lecturer must perform, and the same lecturer cannot perform more than once.\nYou asked\nn\npotential lecturers if they could participate in the conference. Lecturer\ni\nindicated that they could perform on any day from\nl\ni\nto\nr\ni\ninclusive.\nA certain segment of days can be chosen as the conference dates if there is a way to assign an available lecturer to each day of the segment, assigning each lecturer to no more than one day.\nFor each\nk\nfrom\n1\nto\nn\n, find how many ways there are to choose a segment of\nk\nconsecutive days as the conference dates.\nInput\nThe first line of input contains one integer\nn\n — the number of potential lecturers (\n1≤n≤2⋅\n10\n5\n).\nEach of the next\nn\nlines contains two integers\nl\ni\nand\nr\ni\n — the segment of available days for the\ni\nth lecturer (\n1≤\nl\ni\n≤\nr\ni\n≤2⋅\n10\n5\n).\nOutput\nPrint\nn\nintegers, where the\nk\nth number denotes the number of ways to select a segment of\nk\nconsecutive days as conference dates.\nExamples\ninput\nCopy\n3\n1 2\n3 4\n5 6\noutput\nCopy\n6\n2\n0\ninput\nCopy\n5\n1 3\n1 3\n1 3\n1 3\n1 3\noutput\nCopy\n3\n2\n1\n0\n0\nNote\nIn the first testcase, a one-day conference can be organized on any of the days from\n1\nto\n6\n. A two-day conference can be organized from day\n2\nto day\n3\n, as well as from day\n4\nto day\n5\n.\nIn the second testcase, five lecturers can perform only from day\n1\nto day\n3\n, so it will not be possible to organize a conference longer than three days.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "flows",
            "*3300"
        ]
    },
    {
        "title": "E. Connected Cubes",
        "description": "There are\nn⋅m\nunit cubes currently in positions\n(1,1,1)\nthrough\n(n,m,1)\n. Each of these cubes is one of\nk\ncolors. You want to add additional cubes at any integer coordinates such that the subset of cubes of each color is connected, where two cubes are considered connected if they share a face.\nIn other words, for every pair of cubes of the same color\nc\n, it should be possible to travel from one to the other, moving only through cubes of color\nc\nthat share a face.\nThe existing cubes are currently in the corner of a room. There are colorless cubes completely filling the planes\nx=0\n,\ny=0\n, and\nz=0\n, preventing you from placing additional cubes there or at any negative coordinates.\nFind a solution that uses at most\n4⋅\n10\n5\nadditional cubes (not including the cubes that are currently present), or determine that there is no solution. It can be shown that under the given constraints, if there is a solution, there is one using at most\n4⋅\n10\n5\nadditional cubes.\nInput\nThe first line of the input contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n,m,k≤50\n) — the number of rows and columns of cubes, and the number of colors, respectively.\nThe\ni\n-th of the next\nn\nlines contains\nm\nintegers. The\nj\n-th of these is\na\nij\n(\n1≤\na\nij\n≤k\n) — the color of the cube at position\n(i,j,1)\n. For every color from\n1\nto\nk\n, it is guaranteed that there is at least one cube in the input of that color.\nOutput\nIf there is no solution, print a single integer\n−1\n.\nOtherwise, the first line of output should contain a single integer\np\n(\n0≤p≤4⋅\n10\n5\n) — the number of additional cubes you will add.\nThe next\np\nlines should contain four integers\nx\n,\ny\n,\nz\nand\nc\n(\n1≤x,y,z≤\n10\n6\n,\n1≤c≤k\n) — indicating that you are adding a cube with color\nc\nat position\n(x,y,z)\n.\nNo two cubes in the output should have the same coordinates, and no cube in the output should have the same coordinates as any cube in the input.\nIf there are multiple solutions, print any.\nExamples\ninput\nCopy\n3 4 3\n3 2 3 1\n1 1 1 1\n1 3 3 2\noutput\nCopy\n13\n1 1 2 3\n1 3 2 3\n2 1 2 3\n2 2 2 3\n2 3 2 3\n3 3 2 3\n1 2 2 2\n1 2 3 2\n1 3 3 2\n1 4 3 2\n2 4 3 2\n3 4 3 2\n3 4 2 2\ninput\nCopy\n2 2 2\n2 1\n1 2\noutput\nCopy\n9\n1 3 1 1\n2 3 1 1\n3 1 1 1\n3 2 1 1\n3 3 1 1\n1 1 2 2\n1 2 2 2\n2 1 2 2\n2 2 2 2\nNote\nThe image in the statement corresponds to the first example case, with\nred=1\n,\nblue=2\n,\ngreen=3\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*3100"
        ]
    },
    {
        "title": "D. Missing Subarray Sum",
        "description": "There is a hidden array\na\nof\nn\npositive integers. You know that\na\nis a palindrome, or in other words, for all\n1≤i≤n\n,\na\ni\n=\na\nn+1−i\n. You are given the sums of all but one of its distinct subarrays, in arbitrary order. The subarray whose sum is not given can be any of the\nn(n+1)\n2\ndistinct subarrays of\na\n.\nRecover any possible palindrome\na\n. The input is chosen such that there is always at least one array\na\nthat satisfies the conditions.\nAn array\nb\nis a subarray of\na\nif\nb\ncan be obtained from\na\nby the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤1000\n) — the size of the array\na\n.\nThe next line of each test case contains\nn(n+1)\n2\n−1\nintegers\ns\ni\n(\n1≤\ns\ni\n≤\n10\n9\n) — all but one of the subarray sums of\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n1000\n.\nAdditional constraint on the input: There is always at least one valid solution.\nHacks are disabled for this problem.\nOutput\nFor each test case, print one line containing\nn\npositive integers\na\n1\n,\na\n2\n,⋯\na\nn\n — any valid array\na\n. Note that\na\nmust be a palindrome.\nIf there are multiple solutions, print any.\nExample\ninput\nCopy\n7\n3\n1 2 3 4 1\n4\n18 2 11 9 7 11 7 2 9\n4\n5 10 5 16 3 3 13 8 8\n4\n8 10 4 6 4 20 14 14 6\n5\n1 2 3 4 5 4 3 2 1 1 2 3 2 1\n5\n1 1 2 2 2 3 3 3 3 4 5 5 6 8\n3\n500000000 1000000000 500000000 500000000 1000000000\noutput\nCopy\n1 2 1 \n7 2 2 7 \n3 5 5 3 \n6 4 4 6 \n1 1 1 1 1 \n2 1 2 1 2 \n500000000 500000000 500000000 \nNote\nFor the first example case, the subarrays of\na=[1,2,1]\nare:\n[1]\nwith sum\n1\n,\n[2]\nwith sum\n2\n,\n[1]\nwith sum\n1\n,\n[1,2]\nwith sum\n3\n,\n[2,1]\nwith sum\n3\n,\n[1,2,1]\nwith sum\n4\n.\nSo the full list of subarray sums is\n1,1,2,3,3,4\n, and the sum that is missing from the input list is\n3\n.\nFor the second example case, the missing subarray sum is\n4\n, for the subarray\n[2,2]\n.\nFor the third example case, the missing subarray sum is\n13\n, because there are two subarrays with sum\n13\n(\n[3,5,5]\nand\n[5,5,3]\n) but\n13\nonly occurs once in the input.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*2900"
        ]
    },
    {
        "title": "C. Folding Strip",
        "description": "You have a strip of paper with a binary string\ns\nof length\nn\n. You can fold the paper in between any pair of adjacent digits.\nA set of folds is considered valid if after the folds, all characters that are on top of or below each other match. Note that all folds are made at the same time, so the characters don't have to match in between folds.\nFor example, these are valid foldings of\ns=110110110011\nand\ns=01110\n:\nThe length of the folded strip is the length seen from above after all folds are made. So for the two above examples, after the folds shown above, the lengths would be\n7\nand\n3\n, respectively.\nNotice that for the above folding of\ns=01110\n, if we made either of the two folds on their own, that would not be a valid folding. However, because we don't check for validity until all folds are made, this folding is valid.\nAfter performing a set of valid folds, what is the minimum length strip you can form?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the strip.\nThe second line of each test case contains a string\ns\nof\nn\ncharacters '0' and '1' — a description of the digits on the strip.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum possible length of the strip after a valid folding.\nExample\ninput\nCopy\n6\n6\n101101\n1\n0\n12\n110110110011\n5\n01110\n4\n1111\n2\n01\noutput\nCopy\n3\n1\n3\n3\n1\n2\nNote\nFor the first example case, one optimal folding is to fold the strip in the middle, which produces a strip of length 3.\nThe third and fourth example cases correspond to the images above. Note that the folding shown above for\ns=110110110011\nis not of minimal length.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "strings",
            "*2300"
        ]
    },
    {
        "title": "B. Missing Subsequence Sum",
        "description": "You are given two integers\nn\nand\nk\n. Find a sequence\na\nof non-negative integers of size at most\n25\nsuch that the following conditions hold.\nThere is no subsequence of\na\nwith a sum of\nk\n.\nFor all\n1≤v≤n\nwhere\nv≠k\n, there is a subsequence of\na\nwith a sum of\nv\n.\nA sequence\nb\nis a subsequence of\na\nif\nb\ncan be obtained from\na\nby the deletion of several (possibly, zero or all) elements, without changing the order of the remaining elements. For example,\n[5,2,3]\nis a subsequence of\n[1,5,7,8,2,4,3]\n.\nIt can be shown that under the given constraints, a solution always exists.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nEach test case consists of a single line containing two integers\nn\nand\nk\n(\n2≤n≤\n10\n6\n,\n1≤k≤n\n) — the parameters described above.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n7\n.\nOutput\nThe first line of output for each test case should contain a single integer\nm\n(\n1≤m≤25\n) — the size of your chosen sequence.\nThe second line of output for each test case should contain\nm\nintegers\na\ni\n(\n0≤\na\ni\n≤\n10\n9\n) — the elements of your chosen sequence.\nIf there are multiple solutions, print any.\nExample\ninput\nCopy\n5\n2 2\n6 1\n8 8\n9 3\n10 7\noutput\nCopy\n1\n1\n5\n2 3 4 5 6\n7\n1 1 1 1 1 1 1\n4\n7 1 4 1\n4\n1 2 8 3\nNote\nIn the first example, we just need a subsequence that adds up to\n1\n, but not one that adds up to\n2\n. So the array\na=[1]\nsuffices.\nIn the second example, all elements are greater than\nk=1\n, so no subsequence adds up to\n1\n. Every other integer between\n1\nand\nn\nis present in the array, so there is a subsequence of size\n1\nadding up to each of those numbers.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "number theory",
            "*1800"
        ]
    },
    {
        "title": "A. Everything Nim",
        "description": "Alice and Bob are playing a game on\nn\npiles of stones. On each player's turn, they select a positive integer\nk\nthat is at most the size of the smallest nonempty pile and remove\nk\nstones from each nonempty pile at once. The first player who is unable to make a move (because all piles are empty) loses.\nGiven that Alice goes first, who will win the game if both players play optimally?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of piles in the game.\nThe next line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the initial number of stones in the\ni\n-th pile.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print \"Alice\", otherwise print \"Bob\" (without quotes).\nExample\ninput\nCopy\n7\n5\n3 3 3 3 3\n2\n1 7\n7\n1 3 9 7 4 2 100\n3\n1 2 3\n6\n2 1 3 4 2 4\n8\n5 7 2 9 6 3 3 2\n1\n1000000000\noutput\nCopy\nAlice\nBob\nAlice\nAlice\nBob\nAlice\nAlice\nNote\nIn the first test case, Alice can win by choosing\nk=3\non her first turn, which will empty all of the piles at once.\nIn the second test case, Alice must choose\nk=1\non her first turn since there is a pile of size\n1\n, so Bob can win on the next turn by choosing\nk=6\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "J. Necromancer",
        "description": "Monocarp is playing a computer game. In this game, his character is a necromancer. He is fighting\nn\nmonsters numbered from\n1\nto\nn\n. Each monster has two parameters: health and strength.\nMonocarp considers\nq\nscenarios of the battle. In each scenario, he chooses some segment\n[l,r]\nof monsters and calculates the number of moves it takes to defeat all these monsters.\nEach scenario proceeds as follows. First, Monocarp kills monster\nl\nand revives it as a zombie (this does not count as a move). Then each move the following happens: let\ni\nbe the index of the first monster in the segment\n[l,r]\nthat is still alive. All zombies attack monster\ni\n, reducing its health by their total strength. After that, if monster\ni\nhas\n0\nor less health, it dies and Monocarp revives it as a zombie.\nWhen the monster is revived, the zombie's strength is equal to the monster's strength.\nHelp Monocarp for each scenario to calculate how many moves it will take to kill all the monsters in the segment.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the number of monsters and the number of scenarios, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n4\n), where\na\ni\nis the number of health points of the\ni\n-th monster.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n4\n), where\nb\ni\nis the strength of the\ni\n-th monster.\nThen\nq\nlines follow. The\nj\n-th of them contains two integers\nl\nj\nand\nr\nj\n(\n1≤\nl\nj\n≤\nr\nj\n≤n\n) — the boundaries of the\nj\n-th scenario.\nOutput\nFor each scenario, print a single integer — the number of moves it will take to kill all the monsters in the segment.\nExample\ninput\nCopy\n7 5\n4 5 9 9 4 2 4\n1 3 3 1 2 3 3\n3 5\n1 4\n6 6\n1 7\n2 6\noutput\nCopy\n4\n10\n0\n13\n7",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*3200"
        ]
    },
    {
        "title": "I. Equal Trees",
        "description": "You are given two rooted trees, consisting of\nn\nvertices each. The vertices in the trees are numbered from\n1\nto\nn\n, and the root is the vertex\n1\n.\nYou can perform the following operation: choose the tree and the vertex\nv\n(except the root of the tree) in it; connect the child nodes of\nv\nto the parent of\nv\nand remove\nv\nfrom the tree.\nLet's say that two trees are equal if both of the following conditions hold:\nthe sets of remaining vertices in both trees are the same;\nfor every vertex\nv\nwhich is not deleted, its parent in the first tree is the same as its parent in the second tree.\nYour task is to calculate the minimum number of aforementioned operation in order to make the trees equal.\nInput\nThe first line contains a single integer\nn\n(\n2≤n≤40\n) — the number of vertices in the trees.\nThe second line contains\nn−1\nintegers\na\n2\n,\na\n3\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n), where\na\ni\nthe parent of the\ni\n-th vertex in the first tree. Vertex\n1\nis the root.\nThe third line contains\nn−1\nintegers\nb\n2\n,\nb\n3\n,…,\nb\nn\n(\n1≤\nb\ni\n≤n\n), where\nb\ni\nthe parent of the\ni\n-th vertex in the second tree. Vertex\n1\nis the root.\nOutput\nPrint a single integer — the minimum number of aforementioned operation in order to make the trees equal.\nExamples\ninput\nCopy\n5\n1 5 5 1\n1 4 1 2\noutput\nCopy\n4\ninput\nCopy\n2\n1\n1\noutput\nCopy\n0\ninput\nCopy\n10\n4 7 10 6 2 9 7 1 1\n1 2 10 3 4 6 6 5 5\noutput\nCopy\n10",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "graphs",
            "meet-in-the-middle",
            "*3100"
        ]
    },
    {
        "title": "H. Composite Spells",
        "description": "Monocarp plays a fantasy RPG. His character is a mage, so he casts spells. There are two types of spells he knows — basic spells and composite spells.\nThere are\nn\nbasic spells in Monocarp's spell book, numbered from\n1\nto\nn\n. Each basic spell simply changes the health of the target: either decreases it or increases it. The\ni\n-th basic spell changes the target's health value by\nb\ni\n(increases by\nb\ni\nif\nb\ni\nis non-negative, or decreases by\n|\nb\ni\n|\nif\nb\ni\nis negative). If the target's health value goes to\n0\nor below, it dies, and all next spells cast at it do nothing.\nThere are also\nm\ncomposite spells in the spell book, numbered from\nn+1\nto\nn+m\n. Each composite spell is a sequence of other spells, cast in specific order. A composite spell can consist both of basic spells and composite spells; the\ni\n-th spell consists of\ns\ni\nother spells, and each of those spells has index strictly less than\ni\n(so there is no situation that composite spells infinitely cast each other). So, actually, each composite spell can be considered a finite sequence of basic spells, although its length might be huge. Note that the same spell can appear in a composite spell multiple times.\nMonocarp has decided to cast the\n(n+m)\n-th spell from his spell book. The target of this spell is a monster with an initial health value of\nhp\n. Monocarp wants to know whether the monster will be killed or not, and if it will be killed, which basic spell will kill it.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case is given as follows:\nthe first line contains two integers\nn\nand\nhp\n(\n1≤n≤5000\n;\n1≤hp≤\n10\n9\n) — the number of basic spells and the initial health value of the monster;\nthe second line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n−\n10\n9\n≤\nb\ni\n≤\n10\n9\n) — the descriptions of basic spells;\nthe third line contains one integer\nm\n(\n1≤m≤5000\n) — the number of composite spells;\nthen\nm\nlines follow, the\ni\n-th of these lines describes the\n(n+i)\n-th spell: it begins with an integer\ns\nn+i\n(\n1≤\ns\nn+i\n≤5000\n) denoting the length of the spell (the number of spells it consists of); then a sequence of integers from\n1\nto\n(n+i−1)\nfollows, denoting the sequence of spells.\nAdditional constraints on the input:\nthe sum of\nn\nover all test cases does not exceed\n5000\n;\nthe sum of\nm\nover all test cases does not exceed\n5000\n;\nthe total length of all composite spells over all test cases does not exceed\n5000\n.\nOutput\nFor each test case, print one integer:\nif the monster dies, print the index of the basic spell that kills the monster;\notherwise, print\n−1\n.\nExample\ninput\nCopy\n4\n4 9\n1 -2 3 -4\n3\n3 1 4 3\n4 1 2 1 2\n6 6 5 6 5 6 5\n4 9\n1 -2 3 -4\n3\n3 1 4 3\n4 1 2 1 2\n7 6 5 6 5 6 6 5\n3 31\n-10 -20 30\n1\n6 1 2 3 1 2 3\n6 20\n-1 -5 -9 -7 -1 -1\n4\n3 6 5 2\n4 3 3 7 6\n6 4 8 4 4 6 7\n3 6 5 7\noutput\nCopy\n4\n4\n-1\n-1",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*2600"
        ]
    },
    {
        "title": "G. Observation Towers",
        "description": "Consider a segment of an OX axis from\n1\nto\nn\n. There are\nk\nobservation towers on this segment.\nEach tower has two parameters — the coordinate\nx\ni\nand the height\nh\ni\n. The coordinates of all towers are distinct. From tower\ni\n, you can see point\nj\nif\n|\nx\ni\n−j|≤\nh\ni\n(where\n|a|\nis an absolute value of\na\n).\nYou can increase the height of any tower by\n1\nfor one coin. The height of each tower can be increased any number of times (including zero).\nYou need to process\nq\nindependent queries. In the\ni\n-th query, two different points\nl\nand\nr\nare given. You need to calculate the minimum number of coins required to be able to see both of these points (from one tower or from different towers).\nInput\nThe first line contains two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n;\n1≤k≤n\n) — the length of the segment of an OX axis and the number of observation towers.\nThe second line contains\nk\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nk\n(\n1≤\nx\ni\n≤n\n) — the coordinates of the observation towers. The coordinates of all towers are distinct.\nThe third line contains\nk\nintegers\nh\n1\n,\nh\n2\n,…,\nh\nk\n(\n0≤\nh\ni\n≤n\n) — the heights of the observation towers.\nThe fourth line contains a single integer\nq\n(\n1≤q≤2⋅\n10\n5\n) — the number of queries.\nEach of the next\nq\nlines contains two integers\nl\nand\nr\n(\n1≤l<r≤n\n) — the description of the next query.\nOutput\nFor each query, output a single integer — the minimum number of coins required to be able to see both points (from one tower or from different towers).\nExamples\ninput\nCopy\n20 3\n2 15 10\n6 2 0\n3\n1 20\n10 11\n3 4\noutput\nCopy\n3 1 0\ninput\nCopy\n10 2\n2 9\n1 2\n3\n4 5\n5 6\n1 10\noutput\nCopy\n2 2 0",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "*2400"
        ]
    },
    {
        "title": "F. Narrow Paths",
        "description": "Monocarp is wandering through a matrix consisting of\n2\nrows and\nn\ncolumns. Let's denote the cell in the\ni\n-th row and\nj\n-th column as\n(i,j)\n. Monocarp starts at cell\n(1,1)\nand wants to reach cell\n(2,n)\n.\nIn one move, Monocarp can move in one of two directions:\nright — from cell\n(i,j)\nto cell\n(i,j+1)\n;\ndown — from cell\n(i,j)\nto cell\n(i+1,j)\n.\nMonocarp can't go outside the matrix.\nPolycarp wants to prevent Monocarp from freely wandering through the matrix. To do this, he wants to choose exactly\nk\ndifferent cells in the matrix and block them. He cannot choose cells\n(1,1)\nand\n(2,n)\n.\nFor each\ni\nfrom\n0\nto\nn\n, Polycarp wants to know how many ways he can block exactly\nk\ncells, so that Monocarp has exactly\ni\ndifferent paths from\n(1,1)\nto\n(2,n)\n. Two paths are considered different if there exists a cell that Monocarp visits in one path but not in the other.\nAs the number of ways can be quite large, output it modulo\n10\n9\n+7\n.\nInput\nThe only line contains two integers\nn\nand\nk\n(\n2≤n≤2⋅\n10\n5\n;\n2≤k≤2⋅n−2\n) — the number of columns in the matrix and the number of cells Polycarp wants to block.\nOutput\nOutput\nn+1\nintegers: for each\ni\nfrom\n0\nto\nn\n, the number of ways to block exactly\nk\ncells, so that Monocarp has exactly\ni\ndifferent paths from\n(1,1)\nto\n(2,n)\n. Output all answers modulo\n10\n9\n+7\n.\nExamples\ninput\nCopy\n2 2\noutput\nCopy\n1 0 0\ninput\nCopy\n10 2\noutput\nCopy\n45 24 21 18 15 12 9 6 3 0 0\ninput\nCopy\n10 5\noutput\nCopy\n7812 420 210 90 30 6 0 0 0 0 0\ninput\nCopy\n22 10\noutput\nCopy\n467563090 1847560 1016158 534820 267410 125840 55055 22022 7865 2420 605 110 11 0 0 0 0 0 0 0 0 0 0",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "combinatorics",
            "*2000"
        ]
    },
    {
        "title": "E. Yet Another Permutation Constructive",
        "description": "Suppose you have a permutation\np\nof\nn\nintegers — an array where each element is an integer from\n1\nto\nn\n, and every integer from\n1\nto\nn\nappears exactly once.\nIn one operation, you remove every element of this permutation which is less than at least one of its neighbors. For example, when you apply the operation to\n[3,1,2,5,4]\n, you get\n[3,5]\n. If you apply an operation again, you get\n[5]\n.\nIt's easy to see that after applying a finite number of operations, you get an array consisting of a single integer\nn\n.\nYou are given two integers\nn\nand\nk\n. Find a permutation of\nn\nintegers such that it becomes an array consisting of a single element\nn\nafter exactly\nk\noperations (and not earlier).\nInput\nThe first line contains one integer\nt\n(\n1≤t≤2000\n) — the number of test cases.\nEach test case consists of one line containing two integers\nn\nand\nk\n(\n2≤n≤100\n;\n1≤k≤n−1\n).\nOutput\nFor each test case, print the answer as follows:\nif a permutation of size\nn\nwhich becomes an array consisting of a single element\nn\nafter exactly\nk\noperations does not exist, print\n−1\n;\notherwise, print\nn\ndistinct integers from\n1\nto\nn\n— the requested permutation. If there are multiple such permutations, print any of them.\nExample\ninput\nCopy\n4\n5 2\n5 4\n2 1\n3 2\noutput\nCopy\n3 1 2 5 4\n-1\n1 2\n2 1 3",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "constructive algorithms",
            "*1900"
        ]
    },
    {
        "title": "D. Staircase",
        "description": "There is a staircase consisting of\nn\nsteps. Each step is either intact, or broken. For each broken step, an integer\na\ni\nis given denoting the difficulty of repairing it.\nEvery day, you can either:\nrepair an arbitrary broken step. The effort it takes to repair the\ni\n-th step is equal to\na\ni\n;\nor repair two adjacent broken steps. The effort it takes to repair both the\ni\n-th step and the\n(i+1)\n-th step is equal to\n2⋅(\na\ni\n+\na\ni+1\n)\n.\nYou want to repair all broken steps of the staircase, and you want to do it in the minimum possible number of days. What is the minimum total effort it will take to repair all broken steps in the minimum number of days?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the number of steps;\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n8\n). If\na\ni\n=0\n, then the\ni\n-th step does not need to be repaired; otherwise, the\ni\n-th step is broken and\na\ni\nis the difficulty of repairing it.\nAdditional constraint on the input: the sum of values of\nn\ndoes not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the minimum possible total effort it will take to repair all broken steps in the minimum number of days.\nExample\ninput\nCopy\n6\n5\n0 0 0 0 0\n4\n0 13 15 8\n4\n13 15 0 8\n8\n1 2 3 4 5 6 7 8\n5\n99999999 100000000 99999999 99999999 99999999\n5\n2 3 4 3 2\noutput\nCopy\n0\n59\n64\n72\n899999993\n24\nNote\nIn the first test case, you don't have to do anything.\nIn the second test case, you can repair the\n3\n-rd and the\n4\n-th step during the first day, and the\n2\n-nd step during the second day. The total effort will be\n2⋅(15+8)+13=59\n.\nIn the third test case, you can repair the\n4\n-th step during the first day, and two first steps during the second day. The total effort will be\n8+2⋅(13+15)=64\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*1600"
        ]
    },
    {
        "title": "C. Firewood",
        "description": "It's pretty cold in Berland (yes, even in May). So Monocarp has to light his fireplace.\nMonocarp has a big log of wood, which weighs\n2\nn\ngrams. Monocarp has watched the weather forecast and decided that he has to burn\nk\ngrams of wood in the fireplace today, and the remaining\n2\nn\n−k\ngrams of wood will be used tomorrow.\nIn one minute, Monocarp can use his saw to split one of his logs in half. Initially he has only one log, but of course, after splitting a log, he gets two new logs. If the weight of the log is\nx\n, then each of the resulting logs has weight equal to\nx\n2\n. Monocarp can't split logs of weight\n1\ngram.\nMonocarp has to cut his log in such a way that some of the resulting logs weigh exactly\nk\ngrams in total (and since the total weight of wood doesn't change, the remaining logs will have a total weight equal to exactly\n2\nn\n−k\n). Help him to calculate the minimum number of minutes he has to spend cutting the logs.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of one line containing two integers\nn\nand\nk\n(\n1≤n≤60\n;\n1≤k≤\n2\nn\n−1\n).\nOutput\nFor each test case, print one integer — the minimum number of minutes Monocarp has to spend splitting the wood.\nExample\ninput\nCopy\n4\n2 2\n2 1\n10 3\n50 36679020707840\noutput\nCopy\n1\n2\n10\n16\nNote\nIn the first test case, Monocarp has to cut his log exactly once. Then he will have two logs weighing\n2\ngrams each.\nIn the second test case, Monocarp has to cut his log of\n4\ngrams once, then cut one of the resulting logs. He will have one log of weight\n2\nand two logs of weight\n1\n, so he can use two logs to get exactly\n3\ngrams.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*1500"
        ]
    },
    {
        "title": "B. Clock in the Pool",
        "description": "You are swimming in the pool, and you need to control the time of swimming.\nThe pool has a clock that cycles between three different modes: showing water temperature, showing air temperature, and showing time. At the start of the\n0\n-th second it starts showing water temperature, at the start of the\nk\n-th second it switches to air temperature. At the start of the\n2k\n-th second, it switches to showing time.\nAt the start of the\n3k\n-th second the clock starts showing water temperature again, at the start of the\n4k\n-th second — air temperature, and so on.\nYou looked at the clock during the\nm\n-th second to check the time, but it may be that the clock is not showing time right now. How much time do you have to wait to see the time on the clock?\nAnswer\nt\nindependent test cases.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Next\nt\ncases follow.\nThe first and only line of each test case contains two integers\nk\nand\nm\n(\n1≤k≤\n10\n8\n;1≤m≤\n10\n9\n) — the length of the period of the clock and the moment of time you check the clock.\nOutput\nFor each test case, print a single integer — the time you have to wait from the moment\nm\nuntil the moment the clock starts showing the time.\nYou can assume that you are able to read the time instantly the moment it displays on the clock.\nExample\ninput\nCopy\n5\n1 1\n5 14\n5 15\n10 110\n99999999 1000000000\noutput\nCopy\n1\n0\n10\n0\n99999989\nNote\nIn the first test case, the clock will start showing time during the\n2\n-nd second, so you have to wait\n2−1=1\nsecond.\nIn the second test case, the clock shows time from the\n10\n-th until the\n15\n-th second, so during the\n14\n-th second it shows time, and you don't have to wait.\nIn the third test case, during the\n15\n-th second, the clock is already showing water temperature. So you have to wait till the\n25\n-th second, when the clock starts showing time again. You'll wait\n25−15=10\nseconds.\nIn the fourth test case, the clock will start showing time at the start of the\n110\n-th second, so you'll wait\n110−110=0\nseconds.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "math",
            "*1400"
        ]
    },
    {
        "title": "A. 1-3-5",
        "description": "In Berland, coins of worth\n1\n,\n3\nand\n5\nburles are commonly used (burles are local currency).\nEva has to pay exactly\nn\nburles in a shop. She has an infinite amount of coins of all three types. However, she doesn't like to pay using coins worth\n1\nburle — she thinks they are the most convenient to use.\nHelp Eva to calculate the minimum number of coins worth\n1\nburle she has to use, if she has to pay exactly\nn\nburles. Note that she can spend any number of coins worth\n3\nand/or\n5\nburles.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nEach test case consists of one line, containing one integer\nn\n(\n1≤n≤100\n).\nOutput\nFor each test case, print one integer — the minimum number of\n1\n-burle coins Eva has to use.\nExample\ninput\nCopy\n5\n7\n8\n42\n2\n11\noutput\nCopy\n1\n0\n0\n2\n0\nNote\nIn the first test case, Eva should use\n1\ncoin worth\n1\nburle, and\n2\ncoins worth\n3\nburles.\nIn the second test case, Eva should use\n1\ncoin worth\n3\nburles and\n1\ncoin worth\n5\nburles.\nIn the third test case, Eva should use\n14\ncoins worth\n3\nburles.\nIn the fourth test case, Eva should use\n2\ncoins worth\n1\nburle.\nIn the fifth test case, Eva should use\n2\ncoins worth\n3\nburles and\n1\ncoin worth\n5\nburles.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*1100"
        ]
    },
    {
        "title": "F2. Frequency Mismatch (Hard Version)",
        "description": "This is the hard version of the problem. The difference between the two versions of this problem is the constraint on\nk\n. You can make hacks only if all versions of the problem are solved.\nYou are given an undirected tree of\nn\nnodes. Each node\nv\nhas a value\na\nv\nwritten on it. You have to answer queries related to the tree.\nYou are given\nq\nqueries. In each query, you are given\n5\nintegers,\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n,k\n. Denote the count of nodes with value\nc\non path\nu\n1\n→\nv\n1\nwith\nx\nc\n, and the count of nodes with value\nc\non path\nu\n2\n→\nv\n2\nwith\ny\nc\n. If there are\nz\nsuch values of\nc\nsuch that\nx\nc\n≠\ny\nc\n, output any\nmin(z,k)\nsuch values in any order.\nInput\nThe first line contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the number of nodes in the tree.\nThe next line contains\nn\nintegers,\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the value written on each node of the tree.\nThen\nn−1\nlines follow. Each line contains two integers\nu\nand\nv\n(\n1≤u,v≤n,u≠v\n) denoting an edge of the tree. It is guaranteed that the given edges form a tree.\nThe next line contains one integer\nq\n(\n1≤q≤\n10\n5\n) — the number of queries.\nThen\nq\nlines follow. Each line contains five integers\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n,k\n(\n1≤\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n≤n\n,\n1≤k≤10\n).\nOutput\nFor each query, output on a separate line. For a query, first output\nmin(z,k)\nand then on the same line, output any\nmin(z,k)\nvalues in any order which occur a different number of times in each path.\nExample\ninput\nCopy\n5\n5 2 3 4 3\n1 2\n1 3\n2 4\n2 5\n4\n1 4 4 5 3\n2 3 2 3 1\n1 4 4 5 1\n5 5 4 3 10\noutput\nCopy\n2 3 5\n0\n1 5\n3 5 2 4\nNote\nFor query\n1\n, the first path is\n1→2→4\n, coming across the multiset of values\n{5,2,4}\n. On the second path\n4→2→5\n, we have the multiset\n{4,2,3}\n. Two numbers —\n3\nand\n5\noccur a different number of times, hence we print them both.\nIn query\n2\n, there is no difference between the paths, hence we output\n0\n.\nIn query\n3\n, we have the same paths as query\n1\n, but we need to output only\n1\nvalue, hence we output\n5\n.\nIn query\n4\n, the first path is just the node\n5\n, resulting in the multiset\n{3}\n, and the second path\n4→2→1→3\ngives\n{4,2,5,3}\n. The numbers\n5\n,\n2\nand\n4\noccur a different number of times.",
        "time_limit": "4.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "hashing",
            "probabilities",
            "trees",
            "*2700"
        ]
    },
    {
        "title": "F1. Frequency Mismatch (Easy Version)",
        "description": "This is the easy version of the problem. The difference between the two versions of this problem is the constraint on\nk\n. You can make hacks only if all versions of the problem are solved.\nYou are given an undirected tree of\nn\nnodes. Each node\nv\nhas a value\na\nv\nwritten on it. You have to answer queries related to the tree.\nYou are given\nq\nqueries. In each query, you are given\n5\nintegers,\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n,k\n. Denote the count of nodes with value\nc\non path\nu\n1\n→\nv\n1\nwith\nx\nc\n, and the count of nodes with value\nc\non path\nu\n2\n→\nv\n2\nwith\ny\nc\n. If there are\nz\nsuch values of\nc\nsuch that\nx\nc\n≠\ny\nc\n, output any\nmin(z,k)\nsuch values in any order.\nInput\nThe first line contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the number of nodes in the tree.\nThe next line contains\nn\nintegers,\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the value written on each node of the tree.\nThen\nn−1\nlines follow. Each line contains two integers\nu\nand\nv\n(\n1≤u,v≤n,u≠v\n) denoting an edge of the tree. It is guaranteed that the given edges form a tree.\nThe next line contains one integer\nq\n(\n1≤q≤\n10\n5\n) — the number of queries.\nThen\nq\nlines follow. Each line contains five integers\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n,k\n(\n1≤\nu\n1\n,\nv\n1\n,\nu\n2\n,\nv\n2\n≤n\n,\nk=1\n).\nOutput\nFor each query, output on a separate line. For a query, first output\nmin(z,k)\nand then on the same line, output any\nmin(z,k)\nvalues in any order which occur a different number of times in each path.\nExample\ninput\nCopy\n5\n5 2 3 4 3\n1 2\n1 3\n2 4\n2 5\n3\n1 4 4 5 1\n2 3 2 3 1\n5 5 4 3 1\noutput\nCopy\n1 5\n0\n1 2\nNote\nFor query\n1\n, the first path is\n1→2→4\n, coming across the multiset of values\n{5,2,4}\n. On the second path\n4→2→5\n, we have the multiset\n{4,2,3}\n. Two numbers —\n3\nand\n5\noccur a different number of times, hence we print one of them.\nIn query\n2\n, there is no difference between the paths, hence we output\n0\n.\nIn query\n3\n, the first path is just the node\n5\n, resulting in the multiset\n{3}\n, and the second path\n4→2→1→3\ngives\n{4,2,5,3}\n. The numbers\n5\n,\n2\nand\n4\noccur a different number of times.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "divide and conquer",
            "hashing",
            "probabilities",
            "trees",
            "*2600"
        ]
    },
    {
        "title": "E. Carousel of Combinations",
        "description": "You are given an integer\nn\n. The function\nC(i,k)\nrepresents the number of distinct ways you can select\nk\ndistinct numbers from the set {\n1,2,…,i\n} and arrange them in a circle\n†\n†\n.\nFind the value of\n∑\ni=1\nn\n∑\nj=1\ni\n(C(i,j)modj).\ni\nHere, the operation\nxmody\ndenotes the remainder from dividing\nx\nby\ny\n.\nSince this value can be very large, find it modulo\n10\n9\n+7\n.\n†\n†\nIn a circular arrangement, sequences are considered identical if one can be rotated to match the other. For instance,\n[1,2,3]\nand\n[2,3,1]\nare equivalent in a circle.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n).\nOutput\nFor each test case, output a single integer on a new line — the value of the expression to be calculated modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n4\n1\n3\n6\n314159\noutput\nCopy\n0\n4\n24\n78926217\nNote\nIn the first test case,\nC(1,1)mod1=0\n.\nIn the second test case:\nC(1,1)=1\n(the arrangements are:\n[1]\n);\nC(2,1)=2\n(the arrangements are:\n[1]\n,\n[2]\n);\nC(2,2)=1\n(the arrangements are:\n[1,2]\n);\nC(3,1)=3\n(the arrangements are:\n[1]\n,\n[2]\n,\n[3]\n);\nC(3,2)=3\n(the arrangements are:\n[1,2]\n,\n[2,3]\n,\n[3,1]\n);\nC(3,3)=2\n(the arrangements are:\n[1,2,3]\n,\n[1,3,2]\n).\nIn total,\n(C(1,1)mod1)+(C(2,1)mod1)+(C(2,2)mod2)+(C(3,1)mod1)+(C(3,2)mod2)+(C(3,3)mod3)=4\n(\n.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "D. A BIT of an Inequality",
        "description": "You are given an array\na\n1\n,\na\n2\n,…,\na\nn\n. Find the number of tuples (\nx,y,z\n) such that:\n1≤x≤y≤z≤n\n, and\nf(x,y)⊕f(y,z)>f(x,z)\n.\nWe define\nf(l,r)=\na\nl\n⊕\na\nl+1\n⊕…⊕\na\nr\n, where\n⊕\ndenotes the bitwise XOR operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer on a new line — the number of described tuples.\nExample\ninput\nCopy\n3\n3\n6 2 4\n1\n3\n5\n7 3 7 2 1\noutput\nCopy\n4\n0\n16\nNote\nIn the first case, there are 4 such tuples in the array\n[6,2,4]\n:\n(\n1\n,\n2\n,\n2\n):\n(\na\n1\n⊕\na\n2\n)⊕(\na\n2\n)=4⊕2>(\na\n1\n⊕\na\n2\n)=4\n(\n1\n,\n1\n,\n3\n):\n(\na\n1\n)⊕(\na\n1\n⊕\na\n2\n⊕\na\n3\n)=6⊕0>(\na\n1\n⊕\na\n2\n⊕\na\n3\n)=0\n(\n1\n,\n2\n,\n3\n):\n(\na\n1\n⊕\na\n2\n)⊕(\na\n2\n⊕\na\n3\n)=4⊕6>(\na\n1\n⊕\na\n2\n⊕\na\n3\n)=0\n(\n1\n,\n3\n,\n3\n):\n(\na\n1\n⊕\na\n2\n⊕\na\n3\n)⊕(\na\n3\n)=0⊕4>(\na\n1\n⊕\na\n2\n⊕\na\n3\n)=0\nIn the second test case, there are no such tuples.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "math",
            "*1900"
        ]
    },
    {
        "title": "C. How Does the Rook Move?",
        "description": "You are given an\nn×n\nchessboard where you and the computer take turns alternatingly to place white rooks & black rooks on the board respectively. While placing rooks, you have to ensure that no two rooks attack each other. Two rooks attack each other if they share the same row or column regardless of color.\nA valid move is placing a rook on a position (\nr\n,\nc\n) such that it doesn't attack any other rook.\nYou start first, and when you make a valid move in your turn, placing a white rook at position (\nr\n,\nc\n), the computer will mirror you and place a black rook at position (\nc\n,\nr\n) in its turn. If\nr=c\n, then the computer can't mirror your move, and skips its turn.\nYou have already played\nk\nmoves with the computer (the computer tries to mirror these moves too), and you must continue playing the game until there are no valid moves remaining. How many different final configurations are possible when you continue the game after the\nk\nmoves? It is guaranteed that the\nk\nmoves and the implied computer moves are valid. Since the answer may be large, print it modulo\n10\n9\n+7\n.\nTwo configurations are considered different if there exists a coordinate (\nr\n,\nc\n) which has a rook in one configuration, but not in the other or the color of the rook on the coordinate is different.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤3⋅\n10\n5\n,\n0≤k≤n\n) — the size of the chessboard and the number of moves you have already played respectively.\nEach of the next\nk\nlines of the test case contains two integers\nr\ni\nand\nc\ni\n, denoting the\ni\n-th move you made.\nIt is guaranteed that the\nk\nmoves and the implied computer moves are valid.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer on a new line — the total number of possible final configurations modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n3\n4 1\n1 2\n8 1\n7 6\n1000 4\n4 4\n952 343\n222 333\n90 91\noutput\nCopy\n3\n331\n671968183\nNote\nIn the first test case, we have a\n4×4\ngrid and you've already played\n1\nmove. After you and the computer play a turn, we have a white rook at (\n1\n,\n2\n), and a black rook at (\n2\n,\n1\n). There are three possible configurations from this state —\nYou place a white rook at (\n3\n,\n4\n) and the computer places a black rook at (\n4\n,\n3\n) as a response.\nYou place a white rook at (\n4\n,\n3\n) and the computer places a black rook at (\n3\n,\n4\n) as a response.\nYou place a white rook at (\n3\n,\n3\n) and then at (\n4\n,\n4\n), or the other way around. They both result in the same configuration.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*1600"
        ]
    },
    {
        "title": "B. A BIT of a Construction",
        "description": "Given integers\nn\nand\nk\n, construct a sequence of\nn\nnon-negative (i.e.\n≥0\n) integers\na\n1\n,\na\n2\n,…,\na\nn\nsuch that\n∑\ni=1\nn\na\ni\n=k\nThe number of\n1\ns in the binary representation of\na\n1\n|\na\n2\n|…|\na\nn\nis maximized, where\n|\ndenotes the bitwise OR operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,\n1≤k≤\n10\n9\n) — the number of non-negative integers to be printed and the sum respectively.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a sequence\na\n1\n,\na\n2\n,…,\na\nn\non a new line that satisfies the conditions given above.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n4\n1 5\n2 3\n2 5\n6 51\noutput\nCopy\n5\n1 2\n5 0\n3 1 1 32 2 12\nNote\nIn the first test case, we have to print exactly one integer, hence we can only output\n5\nas the answer.\nIn the second test case, we output\n1,2\nwhich sum up to\n3\n, and\n1|2=(11\n)\n2\nhas two\n1\ns in its binary representation, which is the maximum we can achieve in these constraints.\nIn the fourth test case, we output\n3,1,1,32,2,12\nwhich sum up to\n51\n, and\n3|1|1|32|2|12=(101111\n)\n2\nhas five\n1\ns in its binary representation, which is the maximum we can achieve in these constraints.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "A. Stickogon",
        "description": "You are given\nn\nsticks of lengths\na\n1\n,\na\n2\n,…,\na\nn\n. Find the maximum number of regular (equal-sided) polygons you can construct simultaneously, such that:\nEach side of a polygon is formed by exactly one stick.\nNo stick is used in more than\n1\npolygon.\nNote: Sticks cannot be broken.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the number of sticks available.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤100\n) — the stick lengths.\nOutput\nFor each test case, output a single integer on a new line — the maximum number of regular (equal-sided) polygons you can make simultaneously from the sticks available.\nExample\ninput\nCopy\n4\n1\n1\n2\n1 1\n6\n2 2 3 3 3 3\n9\n4 2 2 2 2 4 2 4 4\noutput\nCopy\n0\n0\n1\n2\nNote\nIn the first test case, we only have one stick, hence we can't form any polygon.\nIn the second test case, the two sticks aren't enough to form a polygon either.\nIn the third test case, we can use the\n4\nsticks of length\n3\nto create a square.\nIn the fourth test case, we can make a pentagon with side length\n2\n, and a square of side length\n4\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*800"
        ]
    },
    {
        "title": "F. Nene and the Passing Game",
        "description": "Nene is training her team as a basketball coach. Nene's team consists of\nn\nplayers, numbered from\n1\nto\nn\n. The\ni\n-th player has an arm interval\n[\nl\ni\n,\nr\ni\n]\n. Two players\ni\nand\nj\n(\ni≠j\n) can pass the ball to each other if and only if\n|i−j|∈[\nl\ni\n+\nl\nj\n,\nr\ni\n+\nr\nj\n]\n(here,\n|x|\ndenotes the absolute value of\nx\n).\nNene wants to test the cooperation ability of these players. In order to do this, she will hold several rounds of assessment.\nIn each round, Nene will select a sequence of players\np\n1\n,\np\n2\n,…,\np\nm\nsuch that players\np\ni\nand\np\ni+1\ncan pass the ball to each other for all\n1≤i<m\n. The length of the sequence\nm\ncan be chosen by Nene. Each player can appear in the sequence\np\n1\n,\np\n2\n,…,\np\nm\nmultiple times or not appear in it at all.\nThen, Nene will throw a ball to player\np\n1\n, player\np\n1\nwill pass the ball to player\np\n2\nand so on... Player\np\nm\nwill throw a ball away from the basketball court so it can no longer be used.\nAs a coach, Nene wants each of\nn\nplayers to appear in at least one round of assessment. Since Nene has to go on a date after school, Nene wants you to calculate the minimum number of rounds of assessment needed to complete the task.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n5\n). The description of test cases follows.\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n6\n) — the number of players.\nThe\ni\n-th of the next\nn\nlines contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the arm interval of the\ni\n-th player.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n6\n.\nOutput\nFor each test case, output one integer — the minimum number of rounds of assessment Nene needs to complete her work.\nExample\ninput\nCopy\n5\n2\n1 1\n1 1\n2\n1 1\n2 2\n3\n1 3\n1 3\n1 3\n5\n1 1\n2 2\n1 5\n2 2\n1 1\n6\n1 2\n5 5\n2 3\n2 3\n2 2\n1 2\noutput\nCopy\n2\n2\n2\n1\n3\nNote\nIn the first two test cases, Nene can host two rounds of assessment: one with\np=[1]\nand one with\np=[2]\n. It can be shown that hosting one round of assessment is not enough, so the answer is\n2\n.\nIn the third test case, Nene can host two rounds of assessment: one with\np=[1,3]\nand one with\np=[2]\n. Player\n1\ncan pass the ball to player\n3\nas\n|3−1|=2∈[1+1,3+3]\n. It can be shown that hosting one round of assessment is not enough, so the answer is\n2\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dsu",
            "graphs",
            "sortings",
            "*3000"
        ]
    },
    {
        "title": "E2. Nene vs. Monsters (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the versions is the constraints on\na\ni\n. You can make hacks only if both versions of the problem are solved.\nNene is fighting with\nn\nmonsters, located in a circle. These monsters are numbered from\n1\nto\nn\n, and the\ni\n-th (\n1≤i≤n\n) monster's current energy level is\na\ni\n.\nSince the monsters are too strong, Nene decided to fight with them using the Attack Your Neighbour spell. When Nene uses this spell, the following actions happen in the following order one by one:\nThe\n1\n-st monster attacks the\n2\n-nd monster;\nThe\n2\n-nd monster attacks the\n3\n-rd monster;\n…\nThe\n(n−1)\n-th monster attacks the\nn\n-th monster;\nThe\nn\n-th monster attacks the\n1\n-st monster.\nWhen the monster with energy level\nx\nattacks the monster with the energy level\ny\n, the energy level of the defending monster becomes\nmax(0,y−x)\n(the energy level of the attacking monster remains equal to\nx\n).\nNene is going to use this spell\n10\n100\ntimes and deal with the monsters that will still have a non-zero energy level herself. She wants you to determine which monsters will have a non-zero energy level once she will use the described spell\n10\n100\ntimes.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of test cases follows.\nThe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of monsters.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the current energy levels of monsters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case,\nin the first line output an integer\nm\n — the number of monsters with non-zero energy level after\n10\n100\nuses of the spell;\nin the second line of output\nm\nintegers\ni\n1\n,\ni\n2\n,…,\ni\nm\n(\n1≤\ni\n1\n<\ni\n2\n<…<\ni\nm\n≤n\n) — the indices of these monsters in the increasing order.\nIf\nm=0\n, you may either output an empty line or don't output it.\nExample\ninput\nCopy\n5\n3\n2 5 3\n2\n0 0\n4\n1 5 7 2\n4\n4 2 1 2\n13\n1 1 4 5 1 4 1 9 1 9 8 1 0\noutput\nCopy\n1\n1 \n0\n\n1\n1 \n2\n1 3 \n6\n1 3 6 8 10 12 \nNote\nIn the first test case, the following actions happen during the first\n3\nuses of the spell in this order:\nNene uses the Attack Your Neighbour spell for the first time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,5−2)=3\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,3−3)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n;\nNene uses the Attack Your Neighbour spell for the second time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,3−2)=1\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,0−1)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n;\nNene uses the Attack Your Neighbour spell for the third time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,1−2)=0\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,0−0)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n.\nAfter each of the next uses of the spell, energy levels of monsters do not change. Thus, only the\n1\n-st monster has a non-zero energy level in the end.\nIn the second test case, both monsters initially have zero energy level.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*2700"
        ]
    },
    {
        "title": "E1. Nene vs. Monsters (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the versions is the constraints on\na\ni\n. You can make hacks only if both versions of the problem are solved.\nNene is fighting with\nn\nmonsters, located in a circle. These monsters are numbered from\n1\nto\nn\n, and the\ni\n-th (\n1≤i≤n\n) monster's current energy level is\na\ni\n.\nSince the monsters are too strong, Nene decided to fight with them using the Attack Your Neighbour spell. When Nene uses this spell, the following actions happen in the following order one by one:\nThe\n1\n-st monster attacks the\n2\n-nd monster;\nThe\n2\n-nd monster attacks the\n3\n-rd monster;\n…\nThe\n(n−1)\n-th monster attacks the\nn\n-th monster;\nThe\nn\n-th monster attacks the\n1\n-st monster.\nWhen the monster with energy level\nx\nattacks the monster with the energy level\ny\n, the energy level of the defending monster becomes\nmax(0,y−x)\n(the energy level of the attacking monster remains equal to\nx\n).\nNene is going to use this spell\n10\n100\ntimes and deal with the monsters that will still have a non-zero energy level herself. She wants you to determine which monsters will have a non-zero energy level once she will use the described spell\n10\n100\ntimes.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of test cases follows.\nThe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of monsters.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤2⋅\n10\n5\n) — the current energy levels of monsters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case,\nin the first line output an integer\nm\n — the number of monsters with non-zero energy level after\n10\n100\nuses of the spell;\nin the second line of output\nm\nintegers\ni\n1\n,\ni\n2\n,…,\ni\nm\n(\n1≤\ni\n1\n<\ni\n2\n<…<\ni\nm\n≤n\n) — the indices of these monsters in the increasing order.\nIf\nm=0\n, you may either output an empty line or don't output it.\nExample\ninput\nCopy\n5\n3\n2 5 3\n2\n0 0\n4\n1 5 7 2\n4\n4 2 1 2\n13\n1 1 4 5 1 4 1 9 1 9 8 1 0\noutput\nCopy\n1\n1 \n0\n\n1\n1 \n2\n1 3 \n6\n1 3 6 8 10 12 \nNote\nIn the first test case, the following actions happen during the first\n3\nuses of the spell in this order:\nNene uses the Attack Your Neighbour spell for the first time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,5−2)=3\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,3−3)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n;\nNene uses the Attack Your Neighbour spell for the second time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,3−2)=1\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,0−1)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n;\nNene uses the Attack Your Neighbour spell for the third time;\nthe\n1\n-st monster attacks the\n2\n-nd monster, after the attack the energy level of the\n2\n-nd monster becomes equal to\nmax(0,1−2)=0\n;\nthe\n2\n-nd monster attacks the\n3\n-rd monster, after the attack the energy level of the\n3\n-rd monster becomes equal to\nmax(0,0−0)=0\n;\nthe\n3\n-rd monster attacks the\n1\n-st monster, after the attack the energy level of the\n1\n-st monster becomes equal to\nmax(0,2−0)=2\n.\nAfter each of the next uses of the spell, energy levels of monsters do not change. Thus, only the\n1\n-st monster has a non-zero energy level in the end.\nIn the second test case, both monsters initially have zero energy level.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*2500"
        ]
    },
    {
        "title": "D. Nene and the Mex Operator",
        "description": "Nene gave you an array of integers\na\n1\n,\na\n2\n,…,\na\nn\nof length\nn\n.\nYou can perform the following operation no more than\n5⋅\n10\n5\ntimes (possibly zero):\nChoose two integers\nl\nand\nr\nsuch that\n1≤l≤r≤n\n, compute\nx\nas\nMEX({\na\nl\n,\na\nl+1\n,…,\na\nr\n})\n, and simultaneously set\na\nl\n:=x,\na\nl+1\n:=x,…,\na\nr\n:=x\n.\nHere,\nMEX\nof a set of integers\n{\nc\n1\n,\nc\n2\n,…,\nc\nk\n}\nis defined as the smallest non-negative integer\nm\nwhich does not occur in the set\nc\n.\nYour goal is to maximize the sum of the elements of the array\na\n. Find the maximum sum and construct a sequence of operations that achieves this sum. Note that you don't need to minimize the number of operations in this sequence, you only should use no more than\n5⋅\n10\n5\noperations in your solution.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤18\n) — the length of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n7\n) — the array\na\n.\nOutput\nIn the first line, output two integers\ns\nand\nm\n(\n0≤m≤5⋅\n10\n5\n) — the maximum sum of elements of the array\na\nand the number of operations in your solution.\nIn the\ni\n-th of the following\nm\nlines, output two integers\nl\nand\nr\n(\n1≤l≤r≤n\n), representing the parameters of the\ni\n-th operation.\nIt can be shown that the maximum sum of elements of the array\na\ncan always be obtained in no more than\n5⋅\n10\n5\noperations.\nExamples\ninput\nCopy\n2\n0 1\noutput\nCopy\n4 1\n1 2\ninput\nCopy\n3\n1 3 9\noutput\nCopy\n13 0\ninput\nCopy\n4\n1 100 2 1\noutput\nCopy\n105 2\n3 3\n3 4\ninput\nCopy\n1\n0\noutput\nCopy\n1 1\n1 1\nNote\nIn the first example, after the operation with\nl=1\nand\nr=2\nthe array\na\nbecomes equal to\n[2,2]\n. It can be shown that it is impossible to achieve a larger sum of the elements of\na\n, so the answer is\n4\n.\nIn the second example, the initial sum of elements is\n13\nwhich can be shown to be the largest.\nIn the third example, the array\na\nchanges as follows:\nafter the first operation (\nl=3\n,\nr=3\n), the array\na\nbecomes equal to\n[1,100,0,1]\n;\nafter the second operation (\nl=3\n,\nr=4\n), the array\na\nbecomes equal to\n[1,100,2,2]\n.\nIt can be shown that it is impossible to achieve a larger sum of the elements of\na\n, so the answer is\n105\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "divide and conquer",
            "dp",
            "greedy",
            "implementation",
            "math",
            "*2000"
        ]
    },
    {
        "title": "C. Nene's Magical Matrix",
        "description": "The magical girl Nene has an\nn×n\nmatrix\na\nfilled with zeroes. The\nj\n-th element of the\ni\n-th row of matrix\na\nis denoted as\na\ni,j\n.\nShe can perform operations of the following two types with this matrix:\nType\n1\noperation: choose an integer\ni\nbetween\n1\nand\nn\nand a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof integers from\n1\nto\nn\n. Assign\na\ni,j\n:=\np\nj\nfor all\n1≤j≤n\nsimultaneously.\nType\n2\noperation: choose an integer\ni\nbetween\n1\nand\nn\nand a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof integers from\n1\nto\nn\n. Assign\na\nj,i\n:=\np\nj\nfor all\n1≤j≤n\nsimultaneously.\nNene wants to maximize the sum of all the numbers in the matrix\n∑\ni=1\nn\n∑\nj=1\nn\na\ni,j\n. She asks you to find the way to perform the operations so that this sum is maximized. As she doesn't want to make too many operations, you should provide a solution with no more than\n2n\noperations.\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of test cases follows.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤500\n) — the size of the matrix\na\n.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, in the first line output two integers\ns\nand\nm\n(\n0≤m≤2n\n) — the maximum sum of the numbers in the matrix and the number of operations in your solution.\nIn the\nk\n-th of the next\nm\nlines output the description of the\nk\n-th operation:\nan integer\nc\n(\nc∈{1,2}\n) — the type of the\nk\n-th operation;\nan integer\ni\n(\n1≤i≤n\n) — the row or the column the\nk\n-th operation is applied to;\na permutation\np\n1\n,\np\n2\n,…,\np\nn\nof integers from\n1\nto\nn\n — the permutation used in the\nk\n-th operation.\nNote that you don't need to minimize the number of operations used, you only should use no more than\n2n\noperations. It can be shown that the maximum possible sum can always be obtained in no more than\n2n\noperations.\nExample\ninput\nCopy\n2\n1\n2\noutput\nCopy\n1 1\n1 1 1\n7 3\n1 1 1 2\n1 2 1 2\n2 1 1 2\nNote\nIn the first test case, the maximum sum\ns=1\ncan be obtained in\n1\noperation by setting\na\n1,1\n:=1\n.\nIn the second test case, the maximum sum\ns=7\ncan be obtained in\n3\noperations as follows:\nIt can be shown that it is impossible to make the sum of the numbers in the matrix larger than\n7\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1600"
        ]
    },
    {
        "title": "B. Nene and the Card Game",
        "description": "You and Nene are playing a card game. The deck with\n2n\ncards is used to play this game. Each card has an integer from\n1\nto\nn\non it, and each of integers\n1\nthrough\nn\nappears exactly on\n2\ncards. Additionally, there is a table where cards are placed during the game (initially, the table is empty).\nIn the beginning of the game, these\n2n\ncards are distributed between you and Nene so that each player receives\nn\ncards.\nAfter it, you and Nene alternatively take\n2n\nturns, i.e. each person takes\nn\nturns, starting with you. On each turn:\nThe player whose turn is it selects one of the cards in his hand. Let\nx\nbe the number on it.\nThe player whose turn is it receives\n1\npoint if there is already a card with the integer\nx\non the table (otherwise, he receives no points). After it, he places the selected card with the integer\nx\non the table.\nNote that turns are made publicly: each player can see all the cards on the table at each moment.\nNene is very smart so she always selects cards optimally in order to maximize her score in the end of the game (after\n2n\nrounds). If she has several optimal moves, she selects the move that minimizes your score in the end of the game.\nMore formally, Nene always takes turns optimally in order to maximize her score in the end of the game in the first place and to minimize your score in the end of the game in the second place.\nAssuming that the cards are already distributed and cards in your hand have integers\na\n1\n,\na\n2\n,…,\na\nn\nwritten on them, what is the maximum number of points you can get by taking your turns optimally?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of test cases follows.\nThe first line contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of cards you and Nene receive in the beginning of the game.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the integers on the cards in your hand. It is guaranteed that each integer from\n1\nthrough\nn\nappears in the sequence\na\n1\n,\na\n2\n,…,\na\nn\nat most\n2\ntimes.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer: the maximum number of points you can get.\nExample\ninput\nCopy\n5\n4\n1 1 2 3\n8\n7 4 1 2 8 8 5 5\n8\n7 1 4 5 3 4 2 6\n3\n1 2 3\n1\n1\noutput\nCopy\n1\n2\n1\n0\n0\nNote\nIn the first test case, the integers written on your cards are\n1\n,\n1\n,\n2\nand\n3\n. The integers written on Nene's cards are\n2\n,\n3\n,\n4\nand\n4\n. The game may proceed as follows:\nYou select one of the cards with an integer\n1\nwritten on it and place it on the table.\nNene selects one of the cards with an integer\n4\nwritten on it and places it on the table.\nYou select the card with an integer\n1\nwritten on it, receive\n1\npoint, and place the selected card on the table.\nNene selects the card with an integer\n4\nwritten on it, receive\n1\npoint, and places the selected card on the table.\nYou select the card with an integer\n2\nwritten on it and place it on the table.\nNene selects the card with an integer\n2\nwritten on it, receive\n1\npoint, and places the selected card on the table.\nYou select the card with an integer\n3\nwritten on it and place it on the table.\nNene selects the card with an integer\n3\nwritten on it, receive\n1\npoint, and places the selected card on the table.\nAt the end of the game, you scored\n1\npoint, and Nene scored\n3\n. It can be shown that you cannot score more than\n1\npoint if Nene plays optimally, so the answer is\n1\n.\nIn the second test case, if both players play optimally, you score\n2\npoints and Nene scores\n6\npoints.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "*800"
        ]
    },
    {
        "title": "A. Nene's Game",
        "description": "Nene invented a new game based on an increasing sequence of integers\na\n1\n,\na\n2\n,…,\na\nk\n.\nIn this game, initially\nn\nplayers are lined up in a row. In each of the rounds of this game, the following happens:\nNene finds the\na\n1\n-th,\na\n2\n-th,\n…\n,\na\nk\n-th players in a row. They are kicked out of the game simultaneously. If the\ni\n-th player in a row should be kicked out, but there are fewer than\ni\nplayers in a row, they are skipped.\nOnce no one is kicked out of the game in some round, all the players that are still in the game are declared as winners.\nFor example, consider the game with\na=[3,5]\nand\nn=5\nplayers. Let the players be named player A, player B,\n…\n, player E in the order they are lined up initially. Then,\nBefore the first round, players are lined up as ABCDE. Nene finds the\n3\n-rd and the\n5\n-th players in a row. These are players C and E. They are kicked out in the first round.\nNow players are lined up as ABD. Nene finds the\n3\n-rd and the\n5\n-th players in a row. The\n3\n-rd player is player D and there is no\n5\n-th player in a row. Thus, only player D is kicked out in the second round.\nIn the third round, no one is kicked out of the game, so the game ends after this round.\nPlayers A and B are declared as the winners.\nNene has not yet decided how many people would join the game initially. Nene gave you\nq\nintegers\nn\n1\n,\nn\n2\n,…,\nn\nq\nand you should answer the following question for each\n1≤i≤q\nindependently:\nHow many people would be declared as winners if there are\nn\ni\nplayers in the game initially?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤250\n). The description of test cases follows.\nThe first line case contains two integers\nk\nand\nq\n(\n1≤k,q≤100\n) — the length of the sequence\na\nand the number of values\nn\ni\nyou should solve this problem for.\nThe second line contains\nk\nintegers\na\n1\n,\na\n2\n,…,\na\nk\n(\n1≤\na\n1\n<\na\n2\n<…<\na\nk\n≤100\n) — the sequence\na\n.\nThe third line contains\nq\nintegers\nn\n1\n,\nn\n2\n,…,\nn\nq\n(\n1≤\nn\ni\n≤100\n).\nOutput\nFor each test case, output\nq\nintegers: the\ni\n-th (\n1≤i≤q\n) of them should be the number of players declared as winners if initially\nn\ni\nplayers join the game.\nExample\ninput\nCopy\n6\n2 1\n3 5\n5\n5 3\n2 4 6 7 9\n1 3 5\n5 4\n3 4 5 6 7\n1 2 3 4\n2 3\n69 96\n1 10 100\n1 1\n100\n50\n3 3\n10 20 30\n1 10 100\noutput\nCopy\n2 \n1 1 1 \n1 2 2 2 \n1 10 68 \n50 \n1 9 9 \nNote\nThe first test case was explained in the statement.\nIn the second test case, when\nn=1\n, the only player stays in the game in the first round. After that, the game ends and the only player is declared as a winner.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "games",
            "greedy",
            "*800"
        ]
    },
    {
        "title": "H. The Most Reckless Defense",
        "description": "You are playing a very popular Tower Defense game called \"Runnerfield 2\". In this game, the player sets up defensive towers that attack enemies moving from a certain starting point to the player's base.\nYou are given a grid of size\nn×m\n, on which\nk\ntowers are already placed and a path is laid out through which enemies will move. The cell at the intersection of the\nx\n-th row and the\ny\n-th column is denoted as\n(x,y)\n.\nEach second, a tower deals\np\ni\nunits of damage to all enemies within its range. For example, if an enemy is located at cell\n(x,y)\nand a tower is at\n(\nx\ni\n,\ny\ni\n)\nwith a range of\nr\n, then the enemy will take damage of\np\ni\nif\n(x−\nx\ni\n)\n2\n+(y−\ny\ni\n)\n2\n≤\nr\n2\n.\nEnemies move from cell\n(1,1)\nto cell\n(n,m)\n, visiting each cell of the path exactly once. An enemy instantly moves to an adjacent cell horizontally or vertically, but before doing so, it spends one second in the current cell. If its health becomes zero or less during this second, the enemy can no longer move. The player loses if an enemy reaches cell\n(n,m)\nand can make one more move.\nBy default, all towers have a zero range, but the player can set a tower's range to an integer\nr\n(\nr>0\n), in which case the health of all enemies will increase by\n3\nr\n. However, each\nr\ncan only be used for at most one tower.\nSuppose an enemy has a base health of\nh\nunits. If the tower ranges are\n2\n,\n4\n, and\n5\n, then the enemy's health at the start of the path will be\nh+\n3\n2\n+\n3\n4\n+\n3\n5\n=h+9+81+243=h+333\n. The choice of ranges is made once before the appearance of enemies and cannot be changed after the game starts.\nFind the maximum amount of base health\nh\nfor which it is possible to set the ranges so that the player does not lose when an enemy with health\nh\npasses through (without considering the additions for tower ranges).\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n,m≤50,1≤k<n⋅m\n) — the dimensions of the field and the number of towers on it.\nThe next\nn\nlines each contain\nm\ncharacters — the description of each row of the field, where the character \".\" denotes an empty cell, and the character \"#\" denotes a path cell that the enemies will pass through.\nThen follow\nk\nlines — the description of the towers. Each line of description contains three integers\nx\ni\n,\ny\ni\n, and\np\ni\n(\n1≤\nx\ni\n≤n,1≤\ny\ni\n≤m,1≤\np\ni\n≤500\n) — the coordinates of the tower and its attack parameter. All coordinates correspond to empty cells on the game field, and all pairs\n(\nx\ni\n,\ny\ni\n)\nare pairwise distinct.\nIt is guaranteed that the sum of\nn⋅m\ndoes not exceed\n2500\nfor all test cases.\nOutput\nFor each test case, output the maximum amount of base health\nh\non a separate line, for which it is possible to set the ranges so that the player does not lose when an enemy with health\nh\npasses through (without considering the additions for tower ranges).\nIf it is impossible to choose ranges even for an enemy with\n1\nunit of base health, output \"0\".\nExample\ninput\nCopy\n6\n2 2 1\n#.\n##\n1 2 1\n2 2 1\n#.\n##\n1 2 2\n2 2 1\n#.\n##\n1 2 500\n3 3 2\n#..\n##.\n.##\n1 2 4\n3 1 3\n3 5 2\n#.###\n#.#.#\n###.#\n2 2 2\n2 4 2\n5 5 4\n#....\n#....\n#....\n#....\n#####\n3 2 142\n4 5 9\n2 5 79\n1 3 50\noutput\nCopy\n0\n1\n1491\n11\n8\n1797\nNote\nIn the first example, there is no point in increasing the tower range, as it will not be able to deal enough damage to the monster even with\n1\nunit of health.\nIn the second example, the tower has a range of\n1\n, and it deals damage to the monster in cells\n(1,1)\nand\n(2,2)\n.\nIn the third example, the tower has a range of\n2\n, and it deals damage to the monster in all path cells. If the enemy's base health is\n1491\n, then after the addition for the tower range, its health will be\n1491+\n3\n2\n=1500\n, which exactly equals the damage the tower will deal to it in three seconds.\nIn the fourth example, the tower at\n(1,2)\nhas a range of\n1\n, and the tower at\n(3,1)\nhas a range of\n2\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "dp",
            "flows",
            "graph matchings",
            "shortest paths",
            "*2300"
        ]
    },
    {
        "title": "G. GCD on a grid",
        "description": "Not long ago, Egor learned about the Euclidean algorithm for finding the greatest common divisor of two numbers. The greatest common divisor of two numbers\na\nand\nb\nis the largest number that divides both\na\nand\nb\nwithout leaving a remainder. With this knowledge, Egor can solve a problem that he once couldn't.\nVasily has a grid with\nn\nrows and\nm\ncolumns, and the integer\na\ni\nj\nis located at the intersection of the\ni\n-th row and the\nj\n-th column. Egor wants to go from the top left corner (at the intersection of the first row and the first column) to the bottom right corner (at the intersection of the last row and the last column) and find the greatest common divisor of all the numbers along the path. He is only allowed to move down and to the right. Egor has written down several paths and obtained different GCD values. He became interested in finding the maximum possible GCD.\nUnfortunately, Egor is tired of calculating GCDs, so he asks for your help in finding the maximum GCD of the integers along the path from the top left corner to the bottom right corner of the grid.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n,m≤100\n) — the number of rows and columns of the grid.\nThen, there are\nn\nlines, where the\ni\n-th line contains\nm\nintegers\n(1≤\na\ni,j\n≤\n10\n6\n) — the integers written in the\ni\n-th row and the\nj\n-th column of the grid.\nIt is guaranteed that the sum of\nn⋅m\ndoes not exceed\n2⋅\n10\n5\nover all test cases.\nOutput\nFor each test case, output the maximum possible GCD along the path from the top left cell to the bottom right cell in a separate line.\nExample\ninput\nCopy\n3\n2 3\n30 20 30\n15 25 40\n3 3\n12 4 9\n3 12 2\n8 3 12\n2 4\n2 4 6 8\n1 3 6 9\noutput\nCopy\n10\n3\n1",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "implementation",
            "math",
            "number theory",
            "*1900"
        ]
    },
    {
        "title": "F. Unfair Game",
        "description": "Alice and Bob gathered in the evening to play an exciting game on a sequence of\nn\nintegers, each integer of the sequence doesn't exceed\n4\n. The rules of the game are too complex to describe, so let's just describe the winning condition — Alice wins if the bitwise XOR of all the numbers in the sequence is non-zero; otherwise, Bob wins.\nThe guys invited Eve to act as a judge. Initially, Alice and Bob play with\nn\nnumbers. After one game, Eve removes one of the numbers from the sequence, then Alice and Bob play with\nn−1\nnumbers. Eve removes one number again, after which Alice and Bob play with\nn−2\nnumbers. This continues until the sequence of numbers is empty.\nEve seems to think that in such a game, Alice almost always wins, so she wants Bob to win as many times as possible. Determine the maximum number of times Bob can win against Alice if Eve removes the numbers optimally.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains four integers\np\ni\n(\n0≤\np\ni\n≤200\n) — the number of ones, twos, threes, and fours in the sequence at the beginning of the game.\nOutput\nFor each test case, print the maximum number of times Bob will win in a separate line, if Eve removes the numbers optimally.\nExample\ninput\nCopy\n5\n1 1 1 0\n1 0 1 2\n2 2 2 0\n3 3 2 0\n0 9 9 9\noutput\nCopy\n1\n1\n3\n3\n12\nNote\nIn the first example, Bob wins when Eve has not removed any numbers yet.\nIn the second example, Bob wins if Eve removes one one and one three.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "games",
            "greedy",
            "math",
            "schedules",
            "*1800"
        ]
    },
    {
        "title": "E. Long Inversions",
        "description": "A binary string\ns\nof length\nn\nis given. A binary string is a string consisting only of the characters '1' and '0'.\nYou can choose an integer\nk\n(\n1≤k≤n\n) and then apply the following operation any number of times: choose\nk\nconsecutive characters of the string and invert them, i.e., replace all '0' with '1' and vice versa.\nUsing these operations, you need to make all the characters in the string equal to '1'.\nFor example, if\nn=5\n,\ns=00100\n, you can choose\nk=3\nand proceed as follows:\nchoose the substring from the\n1\n-st to the\n3\n-rd character and obtain\ns=11000\n;\nchoose the substring from the\n3\n-rd to the\n5\n-th character and obtain\ns=11111\n;\nFind the maximum value of\nk\nfor which it is possible to make all the characters in the string equal to '1' using the described operations. Note that the number of operations required to achieve this is not important.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤5000\n) — the length of the string\ns\n.\nThe second line of each test case contains a string\ns\nof length\nn\n, consisting of the characters '1' and '0'.\nIt is guaranteed that the sum of the values\nn\n2\nover all test cases in the test does not exceed\n25⋅\n10\n6\n.\nOutput\nFor each test case, output the maximum integer\nk\n(\n1≤k≤n\n) for which it is possible to obtain a string\ns\nconsisting only of the characters '1' using the described operations.\nExample\ninput\nCopy\n5\n5\n00100\n5\n01000\n7\n1011101\n3\n000\n2\n10\noutput\nCopy\n3\n2\n4\n3\n1",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "D. Inaccurate Subsequence Search",
        "description": "Maxim has an array\na\nof\nn\nintegers and an array\nb\nof\nm\nintegers (\nm≤n\n).\nMaxim considers an array\nc\nof length\nm\nto be good if the elements of array\nc\ncan be rearranged in such a way that at least\nk\nof them match the elements of array\nb\n.\nFor example, if\nb=[1,2,3,4]\nand\nk=3\n, then the arrays\n[4,1,2,3]\nand\n[2,3,4,5]\nare good (they can be reordered as follows:\n[1,2,3,4]\nand\n[5,2,3,4]\n), while the arrays\n[3,4,5,6]\nand\n[3,4,3,4]\nare not good.\nMaxim wants to choose every subsegment of array\na\nof length\nm\nas the elements of array\nc\n. Help Maxim count how many selected arrays will be good.\nIn other words, find the number of positions\n1≤l≤n−m+1\nsuch that the elements\na\nl\n,\na\nl+1\n,…,\na\nl+m−1\nform a good array.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤k≤m≤n≤2⋅\n10\n5\n) — the number of elements in arrays\na\nand\nb\n, the required number of matching elements.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of array\na\n. Elements of the array\na\nare not necessarily unique.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\ni\n≤\n10\n6\n) — the elements of array\nb\n. Elements of the array\nb\nare not necessarily unique.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. Similarly, it is guaranteed that the sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the number of good subsegments of array\na\non a separate line.\nExample\ninput\nCopy\n5\n7 4 2\n4 1 2 3 4 5 6\n1 2 3 4\n7 4 3\n4 1 2 3 4 5 6\n1 2 3 4\n7 4 4\n4 1 2 3 4 5 6\n1 2 3 4\n11 5 3\n9 9 2 2 10 9 7 6 3 6 3\n6 9 7 8 10\n4 1 1\n4 1 5 6\n6\noutput\nCopy\n4\n3\n2\n4\n1\nNote\nIn the first example, all subsegments are good.\nIn the second example, good subsegments start at positions\n1\n,\n2\n, and\n3\n.\nIn the third example, good subsegments start at positions\n1\nand\n2\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "C. Inhabitant of the Deep Sea",
        "description": "n\nships set out to explore the depths of the ocean. The ships are numbered from\n1\nto\nn\nand follow each other in ascending order; the\ni\n-th ship has a durability of\na\ni\n.\nThe Kraken attacked the ships\nk\ntimes in a specific order. First, it attacks the first of the ships, then the last, then the first again, and so on.\nEach attack by the Kraken reduces the durability of the ship by\n1\n. When the durability of the ship drops to\n0\n, it sinks and is no longer subjected to attacks (thus the ship ceases to be the first or last, and the Kraken only attacks the ships that have not yet sunk). If all the ships have sunk, the Kraken has nothing to attack and it swims away.\nFor example, if\nn=4\n,\nk=5\n, and\na=[1,2,4,3]\n, the following will happen:\nThe Kraken attacks the first ship, its durability becomes zero and now\na=[2,4,3]\n;\nThe Kraken attacks the last ship, now\na=[2,4,2]\n;\nThe Kraken attacks the first ship, now\na=[1,4,2]\n;\nThe Kraken attacks the last ship, now\na=[1,4,1]\n;\nThe Kraken attacks the first ship, its durability becomes zero and now\na=[4,1]\n.\nHow many ships were sunk after the Kraken's attack?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n,\n1≤k≤\n10\n15\n) — the number of ships and how many times the Kraken will attack the ships.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the durability of the ships.\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the number of ships sunk by the Kraken on a separate line.\nExample\ninput\nCopy\n6\n4 5\n1 2 4 3\n4 6\n1 2 4 3\n5 20\n2 7 1 8 2\n2 2\n3 2\n2 15\n1 5\n2 7\n5 2\noutput\nCopy\n2\n3\n5\n0\n2\n2",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. Progressive Square",
        "description": "A progressive square of size\nn\nis an\nn×n\nmatrix. Maxim chooses three integers\na\n1,1\n,\nc\n, and\nd\nand constructs a progressive square according to the following rules:\na\ni+1,j\n=\na\ni,j\n+c\n+\na\ni,j+1\n=\na\ni,j\n+d\nd\nFor example, if\nn=3\n,\na\n1,1\n=1\n,\nc=2\n, and\nd=3\n, then the progressive square looks as follows:\n⎛\n⎝\n⎜\n1\n3\n5\n4\n6\n8\n7\n9\n11\n⎞\n⎠\n⎟\n(\n)\nLast month Maxim constructed a progressive square and remembered the values of\nn\n,\nc\n, and\nd\n. Recently, he found an array\nb\nof\nn\n2\nintegers in random order and wants to make sure that these elements are the elements of that specific square.\nIt can be shown that for any values of\nn\n,\na\n1,1\n,\nc\n, and\nd\n, there exists exactly one progressive square that satisfies all the rules.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nc\n, and\nd\n(\n2≤n≤500\n,\n1≤c,d≤\n10\n6\n) — the size of the square and the values of\nc\nand\nd\nas described in the statement.\nThe second line of each test case contains\nn⋅n\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn⋅n\n(\n1≤\nb\ni\n≤\n10\n9\n) — the elements found by Maxim.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n25⋅\n10\n4\n.\nOutput\nFor each test case, output \"YES\" in a separate line if a progressive square for the given\nn\n,\nc\n, and\nd\ncan be constructed from the array elements\na\n, otherwise output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n5\n3 2 3\n3 9 6 5 7 1 10 4 8\n3 2 3\n3 9 6 5 7 1 11 4 8\n2 100 100\n400 300 400 500\n3 2 3\n3 9 6 6 5 1 11 4 8\n4 4 4\n15 27 7 19 23 23 11 15 7 3 19 23 11 15 11 15\noutput\nCopy\nNO\nYES\nYES\nNO\nNO",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "implementation",
            "sortings",
            "*1000"
        ]
    },
    {
        "title": "A. Yogurt Sale",
        "description": "The price of one yogurt at the \"Vosmiorochka\" store is\na\nburles, but there is a promotion where you can buy two yogurts for\nb\nburles.\nMaxim needs to buy exactly\nn\nyogurts. When buying two yogurts, he can choose to buy them at the regular price or at the promotion price.\nWhat is the minimum amount of burles Maxim should spend to buy\nn\nyogurts?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first and only line of each test case contains three integers\nn\n,\na\n, and\nb\n(\n1≤n≤100\n,\n1≤a,b≤30\n) — the number of yogurts Maxim wants to buy, the price for one yogurt, and the price for two yogurts on promotion.\nOutput\nFor each test case, print in a separate line the minimum cost of buying\nn\nyogurts at \"Vosmiorochka\".\nExample\ninput\nCopy\n4\n2 5 9\n3 5 9\n3 5 11\n4 5 11\noutput\nCopy\n9\n14\n15\n20\nNote\nIn the third test case of the example, it is more advantageous to buy three yogurts for\n15\nburles than two for\n11\nand one for\n5\n.\nIn the fourth test case of the example, you need to buy four yogurts, each for\n5\nburles.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Unique Strings",
        "description": "Let's say that two strings\na\nand\nb\nare equal if you can get the string\nb\nby cyclically shifting string\na\n. For example, the strings 0100110 and 1100100 are equal, while 1010 and 1100 are not.\nYou are given a binary string\ns\nof length\nn\n. Its first\nc\ncharacters are 1-s, and its last\nn−c\ncharacters are 0-s.\nIn one operation, you can replace one 0 with 1.\nCalculate the number of unique strings you can get using no more than\nk\noperations. Since the answer may be too large, print it modulo\n10\n9\n+7\n.\nInput\nThe first and only line contains three integers\nn\n,\nc\nand\nk\n(\n1≤n≤3000\n;\n1≤c≤n\n;\n0≤k≤n−c\n) — the length of string\ns\n, the length of prefix of 1-s and the maximum number of operations.\nOutput\nPrint the single integer — the number of unique strings you can achieve performing no more than\nk\noperations, modulo\n10\n9\n+7\n.\nExamples\ninput\nCopy\n1 1 0\noutput\nCopy\n1\ninput\nCopy\n3 1 2\noutput\nCopy\n3\ninput\nCopy\n5 1 1\noutput\nCopy\n3\ninput\nCopy\n6 2 2\noutput\nCopy\n7\ninput\nCopy\n24 3 11\noutput\nCopy\n498062\nNote\nIn the first test case, the only possible string is 1.\nIn the second test case, the possible strings are: 100, 110, and 111. String 101 is equal to 110, so we don't count it.\nIn the third test case, the possible strings are: 10000, 11000, 10100. String 10010 is equal to 10100, and 10001 is equal to 11000.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*3100"
        ]
    },
    {
        "title": "E. Chain Reaction",
        "description": "There are\nn\nmonsters standing in a row. The\ni\n-th monster has\na\ni\nhealth points.\nEvery second, you can choose one alive monster and launch a chain lightning at it. The lightning deals\nk\ndamage to it, and also spreads to the left (towards decreasing\ni\n) and to the right (towards increasing\ni\n) to alive monsters, dealing\nk\ndamage to each. When the lightning reaches a dead monster or the beginning/end of the row, it stops. A monster is considered alive if its health points are strictly greater than\n0\n.\nFor example, consider the following scenario: there are three monsters with health equal to\n[5,2,7]\n, and\nk=3\n. You can kill them all in\n4\nseconds:\nlaunch a chain lightning at the\n3\n-rd monster, then their health values are\n[2,−1,4]\n;\nlaunch a chain lightning at the\n1\n-st monster, then their health values are\n[−1,−1,4]\n;\nlaunch a chain lightning at the\n3\n-rd monster, then their health values are\n[−1,−1,1]\n;\nlaunch a chain lightning at the\n3\n-th monster, then their health values are\n[−1,−1,−2]\n.\nFor each\nk\nfrom\n1\nto\nmax(\na\n1\n,\na\n2\n,…,\na\nn\n)\n, calculate the minimum number of seconds it takes to kill all the monsters.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of monsters.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n5\n) — the health points of the\ni\n-th monster.\nOutput\nFor each\nk\nfrom\n1\nto\nmax(\na\n1\n,\na\n2\n,…,\na\nn\n)\n, output the minimum number of seconds it takes to kill all the monsters.\nExamples\ninput\nCopy\n3\n5 2 7\noutput\nCopy\n10 6 4 3 2 2 1 \ninput\nCopy\n4\n7 7 7 7\noutput\nCopy\n7 4 3 2 2 2 1 \ninput\nCopy\n10\n1 9 7 6 2 4 7 8 1 3\noutput\nCopy\n17 9 5 4 3 3 3 2 1 ",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dsu",
            "greedy",
            "implementation",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "D. Colored Balls",
        "description": "There are balls of\nn\ndifferent colors; the number of balls of the\ni\n-th color is\na\ni\n.\nThe balls can be combined into groups. Each group should contain at most\n2\nballs, and no more than\n1\nball of each color.\nConsider all\n2\nn\nsets of colors. For a set of colors, let's denote its value as the minimum number of groups the balls of those colors can be distributed into. For example, if there are three colors with\n3\n,\n1\nand\n7\nballs respectively, they can be combined into\n7\ngroups (and not less than\n7\n), so the value of that set of colors is\n7\n.\nYour task is to calculate the sum of values over all\n2\nn\npossible sets of colors. Since the answer may be too large, print it modulo\n998244353\n.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤5000\n) — the number of colors.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤5000\n) — the number of balls of the\ni\n-th color.\nAdditional constraint on input: the total number of balls doesn't exceed\n5000\n.\nOutput\nPrint a single integer — the sum of values of all\n2\nn\nsets of colors, taken modulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 1 2\noutput\nCopy\n11\ninput\nCopy\n1\n5\noutput\nCopy\n5\ninput\nCopy\n4\n1 3 3 7\noutput\nCopy\n76\nNote\nConsider the first example. There are\n8\nsets of colors:\nfor the empty set, its value is\n0\n;\nfor the set\n{1}\n, its value is\n1\n;\nfor the set\n{2}\n, its value is\n1\n;\nfor the set\n{3}\n, its value is\n2\n;\nfor the set\n{1,2}\n, its value is\n1\n;\nfor the set\n{1,3}\n, its value is\n2\n;\nfor the set\n{2,3}\n, its value is\n2\n;\nfor the set\n{1,2,3}\n, its value is\n2\n.\nSo, the sum of values over all\n2\nn\nsets of colors is\n11\n.",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "sortings",
            "*1800"
        ]
    },
    {
        "title": "C. Long Multiplication",
        "description": "You are given two integers\nx\nand\ny\nof the same length, consisting of digits from\n1\nto\n9\n.\nYou can perform the following operation any number of times (possibly zero): swap the\ni\n-th digit in\nx\nand the\ni\n-th digit in\ny\n.\nFor example, if\nx=73\nand\ny=31\n, you can swap the\n2\n-nd digits and get\nx=71\nand\ny=33\n.\nYour task is to maximize the product of\nx\nand\ny\nusing the aforementioned operation any number of times. If there are multiple answers, print any of them.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains a single integer\nx\n(\n1≤x<\n10\n100\n).\nThe second line of each test case contains a single integer\ny\n(\n1≤y<\n10\n100\n).\nAdditional constraint on input: the integers\nx\nand\ny\nconsist only of digits from\n1\nto\n9\n.\nOutput\nFor each test case, print two lines — the first line should contain the number\nx\nafter performing the operations; similarly, the second line should contain the number\ny\nafter performing the operations. If there are multiple answers, print any of them.\nExample\ninput\nCopy\n3\n73\n31\n2\n5\n3516\n3982\noutput\nCopy\n71\n33\n5\n2\n3912\n3586",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "B. Make It Ugly",
        "description": "Let's call an array\na\nbeautiful if you can make all its elements the same by using the following operation an arbitrary number of times (possibly, zero):\nchoose an index\ni\n(\n2≤i≤|a|−1\n) such that\na\ni−1\n=\na\ni+1\n, and replace\na\ni\nwith\na\ni−1\n.\nYou are given a beautiful array\na\n1\n,\na\n2\n,…,\na\nn\n. What is the minimum number of elements you have to remove from it in order for it to stop being beautiful? Swapping elements is prohibited. If it is impossible to do so, then output -1.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n).\nAdditional constraints on the input:\nin every test case, the given array\na\nis beautiful;\nthe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of elements you have to remove from the array\na\nin order for it to stop being beautiful. If it is impossible, then output -1.\nExample\ninput\nCopy\n4\n3\n2 2 2\n5\n1 2 1 2 1\n1\n1\n7\n3 3 3 5 3 3 3\noutput\nCopy\n-1\n1\n-1\n3\nNote\nIn the first testcase, it is impossible to modify the array in such a way that it stops being beautiful. An array consisting of identical numbers will remain beautiful no matter how many numbers we remove from it.\nIn the second testcase, you can remove the number at the index\n5\n, for example.\nThe resulting array will be\n[1,2,1,2]\n. Let's check if it is beautiful. Two operations are available:\nChoose\ni=2\n: the array becomes\n[1,1,1,2]\n. No more operations can be applied to it, and the numbers are not all the same.\nChoose\ni=3\ninstead: the array becomes\n[1,2,2,2]\n. No more operations can be applied to it either, and the numbers are still not all the same.\nThus, the array\n[1,2,1,2]\nis not beautiful.\nIn the fourth testcase, you can remove the first three elements, for example. The resulting array\n[5,3,3,3]\nis not beautiful.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. Painting the Ribbon",
        "description": "Alice and Bob have bought a ribbon consisting of\nn\nparts. Now they want to paint it.\nFirst, Alice will paint every part of the ribbon into one of\nm\ncolors. For each part, she can choose its color arbitrarily.\nThen, Bob will choose at most\nk\nparts of the ribbon and repaint them into the same color (he chooses the affected parts and the color arbitrarily).\nBob would like all parts to have the same color. However, Alice thinks that this is too dull, so she wants to paint the ribbon in such a way that Bob cannot make all parts have the same color.\nIs it possible to paint the ribbon in such a way?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of one line containing three integers\nn\n,\nm\nand\nk\n(\n1≤m,k≤n≤50\n) — the number of parts, the number of colors and the number of parts Bob can repaint, respectively.\nOutput\nFor each test case, print YES if Alice can paint the ribbon so that Bob cannot make all parts have the same color. Otherwise, print NO.\nYou can print every letter in any register. For example, Yes, yes, yEs will all be recognized as positive answer.\nExample\ninput\nCopy\n5\n1 1 1\n5 1 1\n5 2 1\n5 2 2\n5 5 3\noutput\nCopy\nNO\nNO\nYES\nNO\nYES\nNote\nIn the first test case, a ribbon consists of\n1\npart. So all its parts will always have the same color.\nIn the second test case, there is only\n1\ncolor.\nIn the third test case, Alice can paint the ribbon as follows:\n[1,2,1,2,1]\n. It's impossible to change the color of at most\n1\npart so that all parts have the same color.\nIn the fourth test case, no matter how Alice paints the ribbon, Bob will always be able to repaint\n2\nparts so that all parts have the same color.\nIn the fifth test case, Alice can paint the ribbon as follows:\n[1,2,3,4,5]\n. It's impossible to change the color of at most\n3\nparts so that all parts have the same color.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "A. Accuracy-Preserving Summation Algorithm",
        "description": "In the classic high-performance computing domain (HPC), the vast majority of computations are conducted in double-precision 64-bit floating-point numbers (fp64, double-precision, IEEE-754 binary64). The rise of Deep Neural Networks (DNNs) resulted in hardware (HW) capable of processing 16-bit floating point numbers (fp16, half precision, IEEE-754 binary16) up to 16 times faster in terms of floating-point operations per second (flops) and up to 4 times faster in terms of memory bandwidth (BW). At the same time, the short mantissa and exponent for fp16 numbers lead to a very fast loss of precision of computations, producing wrong computational results without any option to recover them in reduction operations of size greater than approximately\n2000\n. As the typical problem size in HPC is much larger than\n2000\n, this makes fp16 computations almost useless. To surmount this major roadblock, smarter algorithms for reduction operations are needed.\nDescription. There is a sequence of floating-point numbers stored in IEEE-754 binary64 (double precision, fp64) format\nx\ni\nof length\nN\n. The sequence needs to be summed up to\nS=\nx\n1\n+\nx\n2\n+…+\nx\nN\n. As professional computer equipment with native support for fp16 is usually unavailable to the general audience, we propose to do operations in a simplified simulated environment, that is, we do computations in fp64 format with mantissa and exponent cut to the range admissible in fp16. In particular, small values that do not fit fp16 admissible range turn into zeros, while excessively large values turn into infinities.\nObjective. Your objective is to sum up as many sequences as possible as fast as possible and as accurately as possible. Please note that you may do summation in fp64 format, but the summation process would be slow though accurate. If you do plain summation in fp16 format, it can be fast, but inaccurate, especially for larger sequences.\nInput\nThe input consists of a single line. It starts with an integer\nN\nrepresenting the number of values in the sequence. The following\nN\ndouble precision numbers form the sequence\nx\ni\n, where\ni=1,…,N\n.\nVariable constraints:\nLength of the sequence:\n2≤N≤1000000\n.\nValue of any individual number in the sequence: legal IEEE-754 binary64 value stored in decimal format.\nNote that the actual binary64 value is not always exactly equal to the given decimal value. Instead, the actual given value is the closest number representable in binary64. When reading the input, most programming languages will do the conversion for you automatically.\nIt is guaranteed that every number in the sequence either is\n0\nor has absolute value between\n10\n−300\nand\n10\n300\n, inclusive.\nOutput\nPrint a single line which will describe the summation process. The line should contain an encoded algorithm for the summation. We use this encoding to do actual summation and report the result to prevent the need to seek hardware capable of doing fp16 operations natively.\nAn encoded algorithm consists of the data type to use, followed by a list of values to sum up using this data type. The result of the algorithm is the sum of the given values, as computed in the given data type, from left to right, in the given order. It looks as follows:\n{type:value_1,value_2,...,value_k}\nAs you can see, the whole algorithm is surrounded by curly brackets (\"{\" and \"}\"). The next character represents one of the three possible data types:\n\"d\" for fp64 summation,\n\"s\" for fp32 summation,\n\"h\" for fp16 summation.\nThen goes a colon (\":\"). It is followed by a non-empty list of values to sum up, separated by commas (\",\"). Note that there are no spaces.\nEach value can be one of the following:\nan integer from\n1\nto\nN\nindicating a position in the input sequence: in this case, the value comes directly from the input;\nanother algorithm: in this case, the value is the result of this algorithm.\nSome examples:\n{d:1,2,3,4} tells to use double precision to compute\nx\n1\n+\nx\n2\n+\nx\n3\n+\nx\n4\n;\n{h:4,3,2,1} tells to use half precision to compute\nx\n4\n+\nx\n3\n+\nx\n2\n+\nx\n1\n;\n{d:{s:3,4},{h:2,1}} tells to use double precision to compute\ny+z\n, where:\ny\nis to use single precision to compute\nx\n3\n+\nx\n4\n,\nz\nis to use half precision to compute\nx\n2\n+\nx\n1\n;\n{h:1,4,{d:3,2}} tells to use half precision to compute\nx\n1\n+\nx\n4\n+y\n, where:\ny\nis to use double precision to compute\nx\n3\n+\nx\n2\n.\nEach input value must be used exactly once.\nScoring\nIn this problem, there are 2 example tests and 76 main tests. Each main test is scored as follows.\nThe first part of scoring is related to accuracy. We denote the sum calculated by the solution as\nS\nc\n. Next, we calculate the expected sum\nS\ne\nas precisely as we can, and store it in binary64 format. Then the accuracy score is calculated as:\nA=\n(max(\n|\nS\nc\n−\nS\ne\n|\nmax(|\nS\ne\n|,\n10\n−200\n)\n,\n10\n−20\n))\n0.05\n.\n0.05\nFor example, if the calculated sum is\n99.0\nand the expected sum is\n100.0\n, the accuracy score is\nA=\n(\n|99−100|\n|100|\n)\n0.05\n=\n(\n1\n100\n)\n0.05\n=0.794328...\n. If the relative error is\n1\n1000\n, the accuracy score is\nA=\n(\n1\n1000\n)\n0.05\n=0.707945...\n. If the solution is exact, we get\nA=\n(\n10\n−20\n)\n0.05\n=0.1\n.\nThe second part of scoring is related to the types used for summation. We define the weight\nW\nof the algorithm as follows. If the algorithm performs\nk\nadditions (adding up\nk+1\nvalues), its weight is:\n1⋅k\nfor half precision,\n2⋅k\nfor single precision,\n4⋅k\nfor double precision.\nAdditionally, if the algorithm contains other algorithms, their weights are computed recursively and added to the weight of the parent algorithm.\nThe third part of scoring is related to a penalty for memory reads. We list the\nN\nnumbers appearing in the algorithm from left to right, omitting all curly brackets. We divide the numbers into consecutive blocks of 16 elements; the last block may contain less than 16 elements. In each block, its first element\ni\ninitiates a memory read. For every other element\nj\nof the block, if\n|j−i|>15\n|\n, it is too far from the memory which was read for this block, and you get a penalty. The penalties increase gradually: the\nx\n-th penalty you get will be\nx/20000\n. The penalty counter\nx\nis global, it persists across different blocks. All the penalties add up to the total penalty\nP\n.\nFor example, consider the following algorithm: {s:1,2,3,4,5,6,7,8,9,10,{d:20,19,18,17,16},11,12,13,14,15}. It performs\n15\nadditions in single precision, and one of its elements is also an algorithm which performs\n4\nadditions in double precision. Thus its weight is\nW=15⋅2+4⋅4=46\n. The first memory read block is 1,2,3,4,5,6,7,8,9,10,20,19,18,17,16,11, the initial read is at position\n1\n, and the positions in the block that are more than\n15\nunits away are\n20\n,\n19\n,\n18\n, and\n17\n, so we get\n4\npenalties. The second memory read block is 12,13,14,15, the initial read is at position\n12\n, and there are no penalties. The total penalty is\nP=(1+2+3+4)/20000=0.0005\n.\nPutting the second and third part together, we calculate the average cost for a single operation as:\nC=\nW+P\nN−1\n.\nW\n+\nP\nThen the data score is calculated as:\nD=\n10.0\nC+0.5\n−\n−\n−\n−\n−\n−\n√\n.\n10.0\nLastly, taking the accuracy score into account, the score for the test is:\nScore=\nD\nA\n.\nD\nAll individual test scores for main tests sum up together to produce the final score. Examples are checked, but do not contribute to the score.\nExamples\ninput\nCopy\n2 -4.815473e+04 -1.862622e+04\noutput\nCopy\n{d:1,2}\ninput\nCopy\n3 -4.815473e+01 1.862622e+02 2.997603e+02\noutput\nCopy\n{d:1,2,3}\nNote\nTwo sets of tests are prepared in this problem: preliminary tests and final tests. For the duration of the competition, each submission is tested on the preliminary set of tests. When the competition is finished, for each contestant:\nThe jury takes the latest submission with non-zero score on preliminary tests.\nThis submission is tested on the final set of tests.\nThe contestants are ranked according to their performance on the final tests.\nThe two sets of tests are designed to be similar, but not identical.",
        "time_limit": "10 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "*special problem"
        ]
    },
    {
        "title": "J. Help, what does it mean to be \"Based\"",
        "description": "Input\nSup, gimme a single integer\nx\n(\n1≤x≤4\n) homie uwu :3\nOutput\nIf\nx=1\n, spit out some based code that, like when ya feed it two integers\na\nand\nb\n, it hands over their sum.\nIf\nx=2\n, slap some based code that takes an integer\na\nand returns its absolute value like magic, no cap.\nIf\nx=3\n, check this out: blaze some based code that grabs an integer\nn\n(\n1≤n≤50\n) and an array\na\nof\nn\ndistinct integers, then flexes the maximum value real quick.\nIf\nx=4\n, toss me some based code that snatches an integer\nn\n(\n1≤n≤50\n), an array\na\nof\nn\ndistinct integers and an integer\nk\n(\n1≤k≤n\n), then nails down that\nk\n-th largest value in the array. Get it, fam!\nExamples\ninput\nCopy\n1\noutput\nCopy\nyoink a\nyoink b\n*slaps a on top of b*\nyeet b\ngo touch some grass\ninput\nCopy\n2\noutput\nCopy\nyoink a\nbruh b is lowkey just 0\nrip this b fell off by a\nvibe check a ratios b\nsimp for 7\nbruh a is lowkey just b\nyeet a\ngo touch some grass\ninput\nCopy\n3\noutput\nCopy\nyoink n\nyoink a\nbruh m is lowkey just a[0]\nbruh i is lowkey just 1\nvibe check n ratios i\nsimp for 9\nyeet m\ngo touch some grass\nvibe check a[i] ratios m\nbruh m is lowkey just a[i]\n*slaps 1 on top of i*\nsimp for 5\ninput\nCopy\n4\noutput\nCopy\n Note\nSlide into the \"My Submissions\" page and vibe check ur code by clicking on its ID. You'll see just how based or cringe it is.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "expression parsing",
            "implementation",
            "sortings"
        ]
    },
    {
        "title": "I. Dark Matter",
        "description": "View the statement as a PDF.\nExample\ninput\nCopy\n1 + 1\noutput\nCopy\n3",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "geometry"
        ]
    },
    {
        "title": "H. Palindrome",
        "description": "A palindrome is a string that reads the same in both directions, for example z, uwu, or moom.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of testcases.\nThe following\nt\nlines each contain a string of length at most\n100\nconsisting of lowercase English letters.\nOutput\nFor each test case, output \"YES\" or \"NO\", denoting the answer.\nExamples\ninput\nCopy\n8\nac\ntle\nradar\nracecar\nphp\natcoder\ncodeforces\nsteam\noutput\nCopy\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\ninput\nCopy\n2\na\nz\noutput\nCopy\nNO\nYES",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "strings"
        ]
    },
    {
        "title": "G. Mathematician Takeover",
        "description": "A mathematician grabbed my computer as I was preparing this problem, deleted the statement, and changed the samples to fit his liking. The model solution and input/output format are still correct, but the samples are wrong.\nI've partially fixed the problem so that when you submit, it will be tested against the correct version of the problem. However, I can't fix the samples below. As a computer scientist, can you solve the correct problem?\nInput\nThe only line of input contains a real number\nx\n(\n1≤x≤100\n), given to exactly three decimal places.\nOutput\nOutput one real number — the answer. Your answer is considered correct if its absolute or relative error does not exceed\n10\n−4\n. Formally, let your answer be\na\n, and the jury's answer be\nb\n. Your answer is accepted if and only if\n|a−b|\nmax(1,|b|)\n≤\n10\n−4\n.\nExamples\ninput\nCopy\n1.234\noutput\nCopy\n0.21026\ninput\nCopy\n4.113\noutput\nCopy\n1.41415\ninput\nCopy\n99.000\noutput\nCopy\n4.59512",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "dfs and similar",
            "math"
        ]
    },
    {
        "title": "F. Grid",
        "description": "Input\nThe input contains\n21\nlines, each containing\n21\ncharacters\n0\nor\n1\n.\nExample\ninput\nCopy\n111111101011101111111\n100000100011001000001\n101110101101001011101\n101110101100101011101\n101110101001001011101\n100000100111101000001\n111111101010101111111\n000000000001100000000\n111100101111110011101\n000111010101100110101\n111101101101001000011\n001001000001000011000\n111101110000111001011\n000000001001001111100\n111111100001101010000\n100000100010010100111\n101110100110110011100\n101110101100000100010\n101110101010110000100\n100000101000011001001\n111111101011111111100\noutput\nCopy\n12",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force"
        ]
    },
    {
        "title": "E. Sweep Line",
        "description": "Be careful not to make a mistake. You might have to start all over again.\n— Someone, probably\nInput\nThe first line contains one integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤2\n) — the array\na\n.\nOutput\nOutput a single integer — the number of solutions, modulo\n20240401\n.\nExamples\ninput\nCopy\n7\n1 1 2 1 1 2 0\noutput\nCopy\n1\ninput\nCopy\n7\n1 1 2 1 1 1 0\noutput\nCopy\n2\ninput\nCopy\n7\n0 1 2 1 1 1 0\noutput\nCopy\n0\nNote\nIn the first sample, the array looks like this:\n1\n1\n2\n1\n1\n2\n0\nObviously, the answer here is\n1(mod20240401)\n.\nIn the second sample, the array looks like this:\n1\n1\n2\n1\n1\n1\n0\nI do not know why the answer here is\n2(mod20240401)\n, I had to take a guess.\nIn the third sample, the array looks like this:\n0\n1\n2\n1\n1\n1\n0\nIf the answer here is not\n0(mod20240401)\n, I am literally going to explode.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "combinatorics",
            "games",
            "math"
        ]
    },
    {
        "title": "D. Are You a Procrastinator?",
        "description": "!\nInput\n!\nOutput\n!\nScoring\n!\nExample\ninput\nCopy\n?\noutput\nCopy\n?\nNote\n!",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation"
        ]
    },
    {
        "title": "C. They Have Fooled",
        "description": "Input\nThe first line contains one integer\nn\n(\n0≤n≤12\n).\nOutput\nOne integer — the answer.\nExamples\ninput\nCopy\n0\noutput\nCopy\n10\ninput\nCopy\n1\noutput\nCopy\n10\ninput\nCopy\n5\noutput\nCopy\n7\ninput\nCopy\n9\noutput\nCopy\n0",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "schedules"
        ]
    },
    {
        "title": "B. Is it stated?",
        "description": "Input\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of testcases.\nThe following\nt\nlines each contain a string of length at most\n100\nconsisting of lowercase English letters.\nOutput\nFor each test case, output \"YES\" or \"NO\", denoting the answer.\nExample\ninput\nCopy\n10\nis\nit\nstated\nsubmit\nac\naccepted\nwa\nwronganswer\ntle\ntimelimitexceeded\noutput\nCopy\nNO\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNO\nYES",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "strings"
        ]
    },
    {
        "title": "A. Are You a Robot, Again?",
        "description": "",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "strings"
        ]
    },
    {
        "title": "I. Growing Trees",
        "description": "wowaka ft. Hatsune Miku - Ura-Omote Lovers\nඞ\nYou are given an undirected connected simple graph with\nn\nnodes and\nm\nedges, where edge\ni\nconnects node\nu\ni\nand\nv\ni\n, with two positive parameters\na\ni\nand\nb\ni\nattached to it. Additionally, you are also given an integer\nk\n.\nA non-negative array\nx\nwith size\nm\nis called a\nk\n-spanning-tree generator if it satisfies the following:\nConsider the undirected multigraph with\nn\nnodes where edge\ni\nis cloned\nx\ni\ntimes (i.e. there are\nx\ni\nedges connecting\nu\ni\nand\nv\ni\n). It is possible to partition the edges of this graph into\nk\nspanning trees, where each edge belongs to exactly one spanning tree\n†\n†\n.\nThe cost of such array\nx\nis defined as\n∑\nm\ni=1\na\ni\nx\n2\ni\n+\nb\ni\nx\ni\n. Find the minimum cost of a\nk\n-spanning-tree generator.\n†\n†\nA spanning tree of a (multi)graph is a subset of the graph's edges that form a tree connecting all vertices of the graph.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n≤50,n−1≤m≤min(50,\nn(n−1)\n2\n),1≤k≤\n10\n7\n) — the number of nodes in the graph, the number of edges in the graph, and the parameter for the\nk\n-spanning-tree generator.\nEach of the next\nm\nlines of each test case contains four integers\nu\ni\n,\nv\ni\n,\na\ni\n, and\nb\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n,\nu\ni\n≠\nv\ni\n,1≤\na\ni\n,\nb\ni\n≤1000\n) — the endpoints of the edge\ni\nand its two parameters. It is guaranteed that the graph is simple and connected.\nIt is guaranteed that the sum of\nn\n2\nand the sum of\nm\n2\nover all test cases does not exceed\n2500\n.\nOutput\nFor each test case, output a single integer: the minimum cost of a\nk\n-spanning-tree generator.\nExample\ninput\nCopy\n4\n5 5 1\n4 3 5 5\n2 1 5 7\n2 4 6 2\n5 3 3 5\n2 5 2 9\n5 5 3\n4 3 5 5\n2 1 5 7\n2 4 6 2\n5 3 3 5\n2 5 2 9\n2 1 10000000\n1 2 1000 1000\n10 15 10\n7 1 7 6\n5 8 6 6\n4 8 2 2\n4 3 10 9\n10 8 3 4\n4 6 6 1\n5 4 1 3\n9 3 4 3\n8 3 9 9\n7 5 10 3\n2 1 3 4\n6 1 6 4\n2 5 7 3\n10 7 2 1\n8 2 6 8\noutput\nCopy\n38\n191\n100000010000000000\n2722\nNote\nIn the first test case, a valid\n1\n-spanning-tree generator is\nx=[1,1,1,1,0]\n, as indicated by the following figure. The cost of this generator is\n(\n1\n2\n⋅5+1⋅5)+(\n1\n2\n⋅5+1⋅7)+(\n1\n2\n⋅6+1⋅2)+(\n1\n2\n⋅3+1⋅5)+(\n0\n2\n⋅4+0⋅9)=38\n. It can be proven that no other generator has a lower cost.\nThe\n1\n-spanning-tree partition of\nx=[1,1,1,1,0]\nIn the second test case, a valid\n3\n-spanning-tree generator is\nx=[2,3,2,2,3]\n, as indicated by the following figure. The cost of this generator is\n(\n2\n2\n⋅5+2⋅5)+(\n3\n2\n⋅5+3⋅7)+(\n2\n2\n⋅6+2⋅2)+(\n2\n2\n⋅3+2⋅5)+(\n3\n2\n⋅4+3⋅9)=191\n. It can be proven that no other generator has a lower cost.\nThe\n3\n-spanning-tree partition of\nx=[2,3,2,2,3]",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "flows",
            "graphs",
            "greedy",
            "*3200"
        ]
    },
    {
        "title": "H. Thanos Snap",
        "description": "Piotr Rubik - Psalm dla Ciebie\nඞ\nThere is an array\na\nof size\n2\nk\nfor some positive integer\nk\n, which is initially a permutation of values from\n1\nto\n2\nk\n. Alice and Bob play the following game on the array\na\n. First, a value\nt\nbetween\n1\nand\nk\nis shown to both Alice and Bob. Then, for exactly\nt\nturns, the following happens:\nAlice either does nothing, or chooses two distinct elements of the array\na\nand swaps them.\nBob chooses either the left half or the right half of the array\na\nand erases it.\nThe score of the game is defined as the maximum value in\na\nafter all\nt\nturns have been played. Alice wants to maximize this score, while Bob wants to minimize it.\nYou need to output\nk\nnumbers: the score of the game if both Alice and Bob play optimally for\nt\nfrom\n1\nto\nk\n.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer\nk\n(\n1≤k≤20\n) — the parameter of the size of\na\n.\nThe second line of each test case contains\n2\nk\nintegers\na\n1\n,\na\n2\n,…,\na\n2\nk\n(\n1≤\na\ni\n≤\n2\nk\n,\na\ni\n's are pairwise distinct) — the given array\na\n.\nIt is guaranteed that the sum of\n2\nk\nover all test cases does not exceed\n2\n20\n.\nOutput\nFor each test case, print\nk\nnumbers, where the\ni\n-th number is the score of the game if both Alice and Bob play optimally for\nt=i\n.\nExample\ninput\nCopy\n5\n1\n1 2\n2\n4 3 2 1\n3\n5 1 6 4 7 2 8 3\n4\n10 15 6 12 1 3 4 9 13 5 7 16 14 11 2 8\n5\n32 2 5 23 19 17 31 7 29 3 4 16 13 9 30 24 14 1 8 20 6 15 26 18 10 27 22 12 25 21 28 11\noutput\nCopy\n1\n3 1\n7 5 1\n15 13 9 1\n31 28 25 17 1\nNote\nIn the third test case, for\nt=2\n, the game could have proceeded as follows:\nInitially,\na=[5,1,6,4,7,2,8,3]\n.\nAlice swaps\na\n6\nand\na\n8\n,\na\nbecomes\n[5,1,6,4,7,3,8,2]\n.\nBob erases the right half of the array,\na\nbecomes\n[5,1,6,4]\n.\nAlice does nothing,\na\nremains as\n[5,1,6,4]\n.\nBob erases the right half of the array,\na\nbecomes\n[5,1]\n.\nThe game ends with a score of\n5\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "dp",
            "games",
            "greedy",
            "trees",
            "*3200"
        ]
    },
    {
        "title": "G. Clacking Balls",
        "description": "Rammstein - Ausländer\nඞ\nThere are\nm\nbaskets placed along a circle, numbered from\n1\nto\nm\nin clockwise order (basket\nm\nis next to basket\n1\n). Furthermore, there are\nn\nballs, where ball\ni\nis initially placed in basket\na\ni\n, and no basket contains more than one ball.\nAlice is allowed to perform the following operation, which always takes exactly one second whether you move/throw a ball or not:\nAlice chooses an integer\ni\nbetween\n1\nand\nn\nuniformly at random.\nIf ball\ni\nwas thrown away before, do nothing.\nOtherwise, ball\ni\nis moved from the basket currently containing it to the next basket (in clockwise order). If the target basket currently contains another ball\nj\n, throw ball\nj\naway.\nShe repeats this operation until there is exactly one ball left. Calculate the expected time needed (in seconds) for Alice to end the process.\nIt can be proven that the answer can be represented as a rational number\np\nq\nwith coprime\np\nand\nq\n. You need to output\np⋅\nq\n−1\nmod\n10\n9\n+7\n. It can be proven that\n10\n9\n+7∤q\n.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤3⋅\n10\n5\n,n≤m≤\n10\n9\n) — the number of balls and the number of baskets.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤m\n,\na\ni\n's are pairwise distinct) — the initial position of each ball.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer: the expected amount of time (in seconds) Alice needs to end the process, modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n5\n3 10\n5 1 4\n2 15\n15 1\n6 6\n1 2 3 4 5 6\n6 9\n6 5 4 3 2 1\n1 100\n69\noutput\nCopy\n600000042\n14\n35\n333333409\n0\nNote\nIn the first test case, Alice could have proceeded as follows (we define\na\ni\n=−1\nif ball\ni\nhas been thrown out):\nInitially,\na=[5,1,4]\n.\nAlice chooses\ni=2\nwith probability\n1\n3\n, and ball\n2\nis moved to basket\n2\n. After this,\na=[5,2,4]\n.\nAlice chooses\ni=2\nwith probability\n1\n3\n, and ball\n2\nis moved to basket\n3\n. After this,\na=[5,3,4]\n.\nAlice chooses\ni=2\nwith probability\n1\n3\n, and ball\n2\nis moved to basket\n4\n. As basket\n4\npreviously contains ball\n3\n, this ball is thrown out. After this,\na=[5,4,−1]\n.\nAlice chooses\ni=3\nwith probability\n1\n3\n. Ball\n3\nhas already been thrown out, so nothing happens. After this,\na=[5,4,−1]\n.\nAlice chooses\ni=2\nwith probability\n1\n3\n, and ball\n2\nis moved to basket\n5\n, which throws out ball\n1\n. After this,\na=[−1,5,−1]\n, and the process ends.\nThe answer for this test case is\n189\n5\n.\nThe answer for the second test case is\n14\n(note that these two balls are next to each other).\nThe answer for the third test case is\n35\n.\nThe answer for the fourth test case is\n220\n3\n.\nIn the fifth test case, as there is only one ball initially, the answer is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "probabilities",
            "*3100"
        ]
    },
    {
        "title": "F. Inversion Composition",
        "description": "My Chemical Romance - Disenchanted\nඞ\nYou are given a permutation\np\nof size\nn\n, as well as a non-negative integer\nk\n. You need to construct a permutation\nq\nof size\nn\nsuch that\ninv(q)+inv(q⋅p)=k\n†\n‡\n, or determine if it is impossible to do so.\n†\n†\nFor two permutations\np\nand\nq\nof the same size\nn\n, the permutation\nw=q⋅p\nis such that\nw\ni\n=\nq\np\ni\nfor all\n1≤i≤n\n.\n‡\n‡\nFor a permutation\np\nof size\nn\n, the function\ninv(p)\nreturns the number of inversions of\np\n, i.e. the number of pairs of indices\n1≤i<j≤n\nsuch that\np\ni\n>\np\nj\n.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤3⋅\n10\n5\n,0≤k≤n(n−1)\n) — the size of\np\nand the target number of inversions.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n,\np\ni\n's are pairwise distinct) — the given permutation\np\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print on one line \"YES\" if there exists a permutation\nq\nthat satisfies the given condition, or \"NO\" if there is no such permutation.\nIf the answer is \"YES\", on the second line, print\nn\nintegers\nq\n1\n,\nq\n2\n,…,\nq\nn\nthat represent such a satisfactory permutation\nq\n. If there are multiple such\nq\n's, print any of them.\nExample\ninput\nCopy\n5\n3 4\n2 3 1\n5 5\n2 3 5 1 4\n6 11\n5 1 2 3 4 6\n9 51\n3 1 4 2 5 6 7 8 9\n1 0\n1\noutput\nCopy\nYES\n3 2 1\nNO\nNO\nYES\n1 5 9 8 7 6 4 3 2\nYES\n1\nNote\nIn the first test case, we have\nq⋅p=[2,1,3]\n,\ninv(q)=3\n, and\ninv(q⋅p)=1\n.\nIn the fourth test case, we have\nq⋅p=[9,1,8,5,7,6,4,3,2]\n,\ninv(q)=24\n, and\ninv(q⋅p)=27\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*2500"
        ]
    },
    {
        "title": "E. No Palindromes",
        "description": "Christopher Tin ft. Soweto Gospel Choir - Baba Yetu\nඞ\nYou are given a string\ns\nconsisting of lowercase Latin characters. You need to partition\n†\nthis string into some substrings, such that each substring is not a palindrome\n‡\n.\n†\nA partition of a string\ns\nis an ordered sequence of some\nk\nstrings\nt\n1\n,\nt\n2\n,…,\nt\nk\n, such that\nt\n1\n+\nt\n2\n+…+\nt\nk\n=s\n, where\n+\nhere represents the concatenation operation.\n‡\nA string\ns\nis considered a palindrome if it reads the same backwards as forwards. For example,\nracecar\n,\nabccba\n, and\na\nare palindromes, but\nab\n,\ndokibird\n, and\nkurosanji\nare not.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains a string\ns\nconsisting of lowercase Latin characters (\n1≤|s|≤\n10\n6\n).\nIt is guaranteed that the sum of\n|s|\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print on one line \"YES\" if there exists a partition of\ns\nwhose parts are not palindromes, or \"NO\" if there is no such partition.\nIf the answer is \"YES\", on the second line, print an integer\nk\n — the number of parts that\ns\nneeds to be partitioned to such that each part is not a palindrome. On the third line, print\nk\nstrings\nt\n1\n,\nt\n2\n,…,\nt\nk\nrepresenting such a partition. If there are multiple such partitions, print any of them.\nExample\ninput\nCopy\n3\nsinktheyacht\nlllllllll\nuwuowouwu\noutput\nCopy\nYES\n1\nsinktheyacht\nNO\nYES\n3\nuw uow ouwu\nNote\nIn the first test case, since\nsinktheyacht\nis already non-palindrome, the partition\n[sinktheyacht]\nis valid.\nIn the second test case, as any substring of the string\ns\nis palindrome, there are no valid partitions.\nIn the third test case, another valid partition is\n[uw,uo,wou,wu]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "divide and conquer",
            "greedy",
            "hashing",
            "implementation",
            "math",
            "strings",
            "*2000"
        ]
    },
    {
        "title": "D. Buying Jewels",
        "description": "Nightwish feat. Jonsu - Erämaan Viimeinen\nඞ\nAlice has\nn\ncoins and wants to shop at Bob's jewelry store. Today, although Bob has not set up the store yet, Bob wants to make sure Alice will buy exactly\nk\njewels. To set up the store, Bob can erect at most\n60\nstalls (each containing an unlimited amount of jewels) and set the price per jewel for each stall to be an integer number of coins between\n1\nand\n10\n18\n.\nFortunately, Bob knows that Alice buys greedily: and she will go to stall\n1\n, buy as many jewels as possible, then go to stall\n2\n, buy as many jewels as possible, and so on until the last stall. Knowing this, Bob can choose the number of stalls to set up, as well as set the price for each stall so that Alice buys exactly\nk\njewels. Help Bob fulfill the task, or determine if it is impossible to do so.\nNote that Alice does not need to spend all her coins.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nEach test case contains two positive integers\nn\nand\nk\n(\n1≤n,k≤\n10\n18\n) — the number of coins Alice has and the number of jewels Bob wants Alice to have bought at the end.\nOutput\nFor each test case, print on one line \"YES\" if Bob can erect at most\n60\nstalls and set the prices for the stalls such that Alice buys exactly\nk\njewels, or \"NO\" if it is impossible to do so.\nIf the answer is \"YES\", on the second line, print an integer\ns\n(\n1≤s≤60\n) — the number of stalls to be set up by Bob. On the third line, print\ns\npositive integers\np\n1\n,\np\n2\n,…,\np\ns\n(\n1≤\np\ni\n≤\n10\n18\n)\nthat represent such a satisfactory pricing\np\n, where\np\ni\nis the price per jewel for stall\ni\n. If there are multiple such\np\n's, print any of them.\nExample\ninput\nCopy\n3\n7 3\n6 4\n255 8\noutput\nCopy\nYES\n10\n2 3 4 5 6 7 8 9 10 11\nNO\nYES\n8\n128 64 32 16 8 4 2 1\nNote\nIn the first test case, at the first stall, Alice buys\n3\njewels and is left with\n1\ncoin. This is not enough to buy any jewels for any of the remaining stalls, so Alice buys exactly\n3\njewels at the end.\nIn the third test case,\nAt the first stall, Alice buys\n1\njewel and is left with\n127\ncoins.\nAt the second stall, Alice buys\n1\njewel and is left with\n63\ncoins.\nAt the third stall, Alice buys\n1\njewel and is left with\n31\ncoins.\nAt the fourth stall, Alice buys\n1\njewel and is left with\n15\ncoins.\nAt the fifth stall, Alice buys\n1\njewel and is left with\n7\ncoins.\nAt the sixth stall, Alice buys\n1\njewel and is left with\n3\ncoins.\nAt the seventh stall, Alice buys\n1\njewel and is left with\n1\ncoin.\nAt the eighth stall, Alice buys\n1\njewel and is left with\n0\ncoins.\nTherefore, Alice buys exactly\n8\njewels in total.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*2000"
        ]
    },
    {
        "title": "C. Ticket Hoarding",
        "description": "Maître Gims - Est-ce que tu m'aimes ?\nඞ\nAs the CEO of a startup company, you want to reward each of your\nk\nemployees with a ticket to the upcoming concert. The tickets will be on sale for\nn\ndays, and by some time travelling, you have predicted that the price per ticket at day\ni\nwill be\na\ni\n. However, to prevent ticket hoarding, the concert organizers have implemented the following measures:\nA person may purchase no more than\nm\ntickets per day.\nIf a person purchases\nx\ntickets on day\ni\n, all subsequent days (i.e. from day\ni+1\nonwards) will have their prices per ticket increased by\nx\n.\nFor example, if\na=[1,3,8,4,5]\nand you purchase\n2\ntickets on day\n1\n, they will cost\n2\nin total, and the prices from day\n2\nonwards will become\n[5,10,6,7]\n. If you then purchase\n3\nmore tickets on day\n2\n, they will cost in total an additional\n15\n, and the prices from day\n3\nonwards will become\n[13,9,10]\n.\nFind the minimum spending to purchase\nk\ntickets.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n≤3⋅\n10\n5\n,1≤m≤\n10\n9\n,1≤k≤min(nm,\n10\n9\n)\n) — the number of sale days, the maximum amount of ticket purchasable each day, and the number of tickets to be bought at the end.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the price per ticket for each of the upcoming\nn\ndays.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer: the minimum amount of money needed to purchase exactly\nk\ntickets.\nExample\ninput\nCopy\n4\n4 2 3\n8 6 4 2\n4 2 8\n8 6 4 2\n5 100 1\n10000 1 100 10 1000\n6 3 9\n5 5 5 5 5 5\noutput\nCopy\n10\n64\n1\n72\nNote\nIn the first test case, one optimal way to buy\n3\ntickets is as follows:\nBuy\n0\ntickets on the first day. The prices per ticket for the remaining days are\n[6,4,2]\n.\nBuy\n0\ntickets on the second day. The prices per ticket for the remaining days are\n[4,2]\n.\nBuy\n1\nticket on the third day with cost\n4\n. The price per ticket for the remaining day is\n[3]\n.\nBuy\n2\ntickets on the fourth day with cost\n6\n.\nIn the second test case, there is only one way to buy\n8\ntickets:\nBuy\n2\ntickets on the first day with cost\n16\n. The prices per ticket for the remaining days are\n[8,6,4]\n.\nBuy\n2\ntickets on the second day with cost\n16\n. The prices per ticket for the remaining days are\n[8,6]\n.\nBuy\n2\ntickets on the third day with cost\n16\n. The price per ticket for the remaining day is\n[8]\n.\nBuy\n2\ntickets on the fourth day with cost\n16\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "B. Battle Cows",
        "description": "The HU - Shireg Shireg\nඞ\nThere are\nn\ncows participating in a coding tournament. Cow\ni\nhas a Cowdeforces rating of\na\ni\n(all distinct), and is initially in position\ni\n. The tournament consists of\nn−1\nmatches as follows:\nThe first match is between the cow in position\n1\nand the cow in position\n2\n.\nSubsequently, each match\ni\nis between the cow in position\ni+1\nand the winner of match\ni−1\n.\nIn each match, the cow with the higher Cowdeforces rating wins and proceeds to the next match.\nYou are the owner of cow\nk\n. For you, winning the tournament is not important; rather, you want your cow to win in as many matches as possible. As an acquaintance of the tournament organizers, you can ask them to swap the position of your cow with another cow only once, or you can choose to do nothing.\nFind the maximum number of wins your cow can achieve.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n2≤n≤\n10\n5\n,1≤k≤n\n) — the number of cows and your cow's index.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the Cowdeforces rating of the cows. It is guaranteed that\na\ni\n's are pairwise different.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, print one integer: the maximum number of wins cow\nk\ncan achieve if you choose to swap (or do nothing) optimally.\nExample\ninput\nCopy\n3\n6 1\n12 10 14 11 8 3\n6 5\n7 2 727 10 12 13\n2 2\n1000000000 1\noutput\nCopy\n1\n2\n0\nNote\nIn the first test case, it is optimal to do nothing. Let\na\n′\nbe the Cowdeforces rating of the cows in the original order (with your cow's rating bolded), then\nInitially,\na\n′\n=[12,10,14,11,8,3]\n.\nYour cow plays against the cow with Cowdeforces rating\n10\nand wins.\na\n′\n=[12,14,11,8,3]\n.\nYour cow plays against the cow with Cowdeforces rating\n14\nand loses.\nIn total, your cow wins\n1\nmatch.\nIn the second test case, it is optimal to swap your cow to position\n3\n. Then, let\na\n′\nbe the Cowdeforces rating of the cows in the order after the swap.\nInitially,\na\n′\n=[7,2,12,10,727,13]\n.\nThe cow with Cowdeforces rating\n7\nplays against the cow with Cowdeforces rating\n2\nand wins.\na\n′\n=[7,12,10,727,13]\n.\nThe cow with Cowdeforces rating\n7\nplays against your cow, and your cow wins.\na\n′\n=[12,10,727,13]\n.\nYour cow plays against the cow with Cowdeforces rating\n10\nand wins.\na\n′\n=[12,727,13]\n.\nYour cow plays against the cow with Cowdeforces rating\n727\nand loses.\nIn total, your cow wins\n2\nmatches.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "*1200"
        ]
    },
    {
        "title": "A. Dual Trigger",
        "description": "Ngọt - LẦN CUỐI (đi bên em xót xa người ơi)\nඞ\nThere are\nn\nlamps numbered\n1\nto\nn\nlined up in a row, initially turned off. You can perform the following operation any number of times (possibly zero):\nChoose two non-adjacent\n†\n†\nlamps that are currently turned off, then turn them on.\nDetermine whether you can reach configuration\ns\n, where\ns\ni\n=1\nmeans the\ni\n-th lamp is turned on, and\ns\ni\n=0\notherwise.\n†\n†\nOnly lamp\ni\nand\ni+1\nare adjacent for all\n1≤i<n\n. Note that lamp\nn\nand\n1\nare not adjacent when\nn≠2\n.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤50\n) — the number of lamps.\nThe second line of each test case contains a binary string\ns\nof size\nn\n — the final desired configuration.\nOutput\nFor each test case, print on one line \"YES\" if we can reach the configuration\ns\nvia applying the given operation any number of times. Otherwise, print \"NO\".\nExample\ninput\nCopy\n5\n10\n1101010110\n10\n1001001110\n6\n000000\n1\n1\n12\n111111111111\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first test case, the sequence of operation could have been as follows (note that initially\ns\nis all zero):\n0000000000→1000000010→1100000110→1101010110\n.\nIn the third test case, we don't have to do any operation.\nIn the fourth test case, we cannot do any operation, but we need the first lamp to be on. Therefore, it is impossible to achieve the desired state.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "G. Shuffling Songs",
        "description": "Vladislav has a playlist consisting of\nn\nsongs, numbered from\n1\nto\nn\n. Song\ni\nhas genre\ng\ni\nand writer\nw\ni\n. He wants to make a playlist in such a way that every pair of adjacent songs either have the same writer or are from the same genre (or both). He calls such a playlist exciting. Both\ng\ni\nand\nw\ni\nare strings of length no more than\n10\n4\n.\nIt might not always be possible to make an exciting playlist using all the songs, so the shuffling process occurs in two steps. First, some amount (possibly zero) of the songs are removed, and then the remaining songs in the playlist are rearranged to make it exciting.\nSince Vladislav doesn't like when songs get removed from his playlist, he wants the making playlist to perform as few removals as possible. Help him find the minimum number of removals that need to be performed in order to be able to rearrange the rest of the songs to make the playlist exciting.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤16\n) — the number of songs in the original playlist.\nThen\nn\nlines follow, the\ni\n-th of which contains two strings of lowercase letters\ng\ni\nand\nw\ni\n(\n1≤|\ng\ni\n|,|\nw\ni\n|≤\n10\n4\n) — the genre and the writer of the\ni\n-th song. Where\n|\ng\ni\n|\nand\n|\nw\ni\n|\nare lengths of the strings.\nThe sum of\n2\nn\nover all test cases does not exceed\n2\n16\n.\nThe sum of\n|\ng\ni\n|+|\nw\ni\n|\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of removals necessary so that the resulting playlist can be made exciting.\nExample\ninput\nCopy\n4\n1\npop taylorswift\n4\nelectronic themotans\nelectronic carlasdreams\npop themotans\npop irinarimes\n7\nrap eminem\nrap drdre\nrap kanyewest\npop taylorswift\nindierock arcticmonkeys\nindierock arcticmonkeys\npunkrock theoffspring\n4\na b\nc d\ne f\ng h\noutput\nCopy\n0\n0\n4\n3\nNote\nIn the first test case, the playlist is already exciting.\nIn the second test case, if you have the songs in the order\n4,3,1,2\n, it is exciting, so you don't need to remove any songs.\nIn the third test case, you can remove songs\n4,5,6,7\n. Then the playlist with songs in the order\n1,2,3\nis exciting.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "dfs and similar",
            "dp",
            "graphs",
            "hashing",
            "implementation",
            "strings",
            "*1900"
        ]
    },
    {
        "title": "F. 0, 1, 2, Tree!",
        "description": "Find the minimum height of a rooted tree\n†\n†\nwith\na+b+c\nvertices that satisfies the following conditions:\na\nvertices have exactly\n2\nchildren,\nb\nvertices have exactly\n1\nchild, and\nc\nvertices have exactly\n0\nchildren.\nIf no such tree exists, you should report it.\nThe tree above is rooted at the top vertex, and each vertex is labeled with the number of children it has. Here\na=2\n,\nb=1\n,\nc=3\n, and the height is\n2\n.\n†\n†\nA rooted tree is a connected graph without cycles, with a special vertex called the root. In a rooted tree, among any two vertices connected by an edge, one vertex is a parent (the one closer to the root), and the other one is a child.\nThe distance between two vertices in a tree is the number of edges in the shortest path between them. The height of a rooted tree is the maximum distance from a vertex to the root.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains three integers\na\n,\nb\n, and\nc\n(\n0≤a,b,c≤\n10\n5\n;\n1≤a+b+c\n).\nThe sum of\na+b+c\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, if no such tree exists, output\n−1\n. Otherwise, output one integer — the minimum height of a tree satisfying the conditions in the statement.\nExample\ninput\nCopy\n10\n2 1 3\n0 0 1\n0 1 1\n1 0 2\n1 1 3\n3 1 4\n8 17 9\n24 36 48\n1 0 0\n0 3 1\noutput\nCopy\n2\n0\n1\n1\n-1\n3\n6\n-1\n-1\n3\nNote\nThe first test case is pictured in the statement. It can be proven that you can't get a height smaller than\n2\n.\nIn the second test case, you can form a tree with a single vertex and no edges. It has height\n0\n, which is clearly optimal.\nIn the third test case, you can form a tree with two vertices joined by a single edge. It has height\n1\n, which is clearly optimal.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "implementation",
            "trees",
            "*1700"
        ]
    },
    {
        "title": "E. Nearly Shortest Repeating Substring",
        "description": "You are given a string\ns\nof length\nn\nconsisting of lowercase Latin characters. Find the length of the shortest string\nk\nsuch that several (possibly one) copies of\nk\ncan be concatenated together to form a string with the same length as\ns\nand, at most, one different character.\nMore formally, find the length of the shortest string\nk\nsuch that\nc=\nk+⋯+k\n⏟\nx times\nfor some positive integer\nx\n, strings\ns\nand\nc\nhas the same length and\nci≠si\nfor at most one\ni\n(i.e. there exist\n0\nor\n1\nsuch positions).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤103\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅105\n) — the length of string\ns\n.\nThe second line of each test case contains the string\ns\n, consisting of lowercase Latin characters.\nThe sum of\nn\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, print the length of the shortest string\nk\nsatisfying the constraints in the statement.\nExample\ninput\nCopy\n5\n4\nabaa\n4\nabba\n13\nslavicgslavic\n8\nhshahaha\n20\nstormflamestornflame\noutput\nCopy\n1\n4\n13\n2\n10\nNote\nIn the first test case, you can select\nk=a\nand\nk+k+k+k=aaaa\n, which only differs from\ns\nin the second position.\nIn the second test case, you cannot select\nk\nof length one or two. We can have\nk=abba\n, which is equal to\ns\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "number theory",
            "strings",
            "*1500"
        ]
    },
    {
        "title": "D. Product of Binary Decimals",
        "description": "Let's call a number a binary decimal if it is a positive integer and all digits in its decimal notation are either\n0\nor\n1\n. For example,\n1010111\nis a binary decimal, while\n10201\nand\n787788\nare not.\nGiven a number\nn\n, you are asked whether or not it is possible to represent\nn\nas a product of some (not necessarily distinct) binary decimals.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n).\nOutput\nFor each test case, output \"YES\" (without quotes) if\nn\ncan be represented as a product of binary decimals, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\", and \"Yes\" will be recognized as a positive response).\nExample\ninput\nCopy\n11\n121\n1\n14641\n12221\n10110\n100000\n99\n112\n2024\n12421\n1001\noutput\nCopy\nYES\nYES\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO\nYES\nNote\nThe first five test cases can be represented as a product of binary decimals as follows:\n121=11×11\n.\n1=1\nis already a binary decimal.\n14641=11×11×11×11\n.\n12221=11×11×101\n.\n10110=10110\nis already a binary decimal.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "number theory",
            "*1100"
        ]
    },
    {
        "title": "C. Clock Conversion",
        "description": "Given the time in 24-hour format, output the equivalent time in 12-hour format.\n24-hour format divides the day into 24 hours from\n00\nto\n23\n, each of which has 60 minutes from\n00\nto\n59\n.\n12-hour format divides the day into two halves: the first half is\nAM\n, and the second half is\nPM\n. In each half, the hours are numbered in the order\n12,01,02,03,…,11\n. Each hour has 60 minutes numbered from\n00\nto\n59\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1440\n) — the number of test cases.\nThe only line of each test case contains a string\ns\nof length\n5\nwith format hh:mm representing a valid time in the 24-hour format. hh represents the hour from\n00\nto\n23\n, and mm represents the minute from\n00\nto\n59\n.\nThe input will always be a valid time in 24-hour format.\nOutput\nFor each test case, output two strings separated by a space (\"hh:mm AM\" or \"hh:mm PM\"), which are the 12-hour equivalent to the time provided in the test case (without quotes).\nYou should output the time exactly as indicated; in particular, you should not remove leading zeroes.\nExample\ninput\nCopy\n11\n09:41\n18:06\n12:14\n00:59\n00:00\n14:34\n01:01\n19:07\n11:59\n12:00\n21:37\noutput\nCopy\n09:41 AM\n06:06 PM\n12:14 PM\n12:59 AM\n12:00 AM\n02:34 PM\n01:01 AM\n07:07 PM\n11:59 AM\n12:00 PM\n09:37 PM",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "B. Upscaling",
        "description": "You are given an integer\nn\n. Output a\n2n×2n\ncheckerboard made of\n2×2\nsquares alternating '\n#\n' and '\n.\n', with the top-left cell being '\n#\n'.\nThe picture above shows the answers for\nn=1,2,3,4\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤20\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤20\n) — it means you need to output a checkerboard of side length\n2n\n.\nOutput\nFor each test case, output\n2n\nlines, each containing\n2n\ncharacters without spaces — the checkerboard, as described in the statement. Do not output empty lines between test cases.\nExample\ninput\nCopy\n4\n1\n2\n3\n4\noutput\nCopy\n##\n##\n##..\n##..\n..##\n..##\n##..##\n##..##\n..##..\n..##..\n##..##\n##..##\n##..##..\n##..##..\n..##..##\n..##..##\n##..##..\n##..##..\n..##..##\n..##..##",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Stair, Peak, or Neither?",
        "description": "You are given three digits\na\n,\nb\n, and\nc\n. Determine whether they form a stair, a peak, or neither.\nA stair satisfies the condition\na<b<c\n.\nA peak satisfies the condition\na<b>c\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains three digits\na\n,\nb\n,\nc\n(\n0≤a\n,\nb\n,\nc≤9\n).\nOutput\nFor each test case, output \"STAIR\" if the digits form a stair, \"PEAK\" if the digits form a peak, and \"NONE\" otherwise (output the strings without quotes).\nExample\ninput\nCopy\n7\n1 2 3\n3 2 1\n1 5 3\n3 4 1\n0 0 0\n4 1 7\n4 5 7\noutput\nCopy\nSTAIR\nNONE\nPEAK\nPEAK\nNONE\nNONE\nSTAIR",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "K. Make Triangle",
        "description": "You are given\nn\npositive integers\nx\n1\n,\nx\n2\n,…,\nx\nn\nand three positive integers\nn\na\n,\nn\nb\n,\nn\nc\nsatisfying\nn\na\n+\nn\nb\n+\nn\nc\n=n\n.\nYou want to split the\nn\npositive integers into three groups, so that:\nThe first group contains\nn\na\nnumbers, the second group contains\nn\nb\nnumbers, the third group contains\nn\nc\nnumbers.\nLet\ns\na\nbe the sum of the numbers in the first group,\ns\nb\nbe the sum in the second group, and\ns\nc\nbe the sum in the third group. Then\ns\na\n,\ns\nb\n,\ns\nc\nare the sides of a triangle with positive area.\nDetermine if this is possible. If this is possible, find one way to do so.\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤100000\n) — the number of test cases. The descriptions of the\nt\ntest cases follow.\nThe first line of each test case contains the integers\nn,\nn\na\n,\nn\nb\n,\nn\nc\n(\n3≤n≤200000,1≤\nn\na\n,\nn\nb\n,\nn\nc\n≤n−2,\nn\na\n+\nn\nb\n+\nn\nc\n=n\n) — the number of integers to split into three groups, and the desired sizes of the three groups.\nThe second line of each test case contains\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n1≤\nx\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n200000\n.\nOutput\nFor each test case, print\nYES\nif it is possible to split the numbers into three groups satisfying all the conditions. Otherwise, print\nNO\n.\nIf such a split exists, then describe the three groups as follows.\nOn the next line, print\nn\na\nintegers\na\n1\n,\na\n2\n,…,\na\nn\na\n — the numbers in the first group.\nOn the next line, print\nn\nb\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\nb\n — the numbers in the second group.\nOn the next line, print\nn\nc\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\nc\n — the numbers in the third group.\nThese\nn\na\n+\nn\nb\n+\nn\nc\n=n\nintegers should be a permutation of\nx\n1\n,\nx\n2\n,…,\nx\nn\n, and they should satisfy the conditions from the statement.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n4\n6 2 2 2\n1 1 1 1 1 1\n5 3 1 1\n1 1 1 1 1\n6 2 2 2\n1 1 1 1 1 3\n8 1 2 5\n16 1 1 1 1 1 1 12\noutput\nCopy\nYES\n1 1 \n1 1 \n1 1 \nNO\nNO\nYES\n16 \n12 1 \n1 1 1 1 1 \nNote\nIn the first test case, we can put two\n1\ns into each group: the sum in each group would be\n2\n, and there exists a triangle with positive area and sides\n2\n,\n2\n,\n2\n.\nIn the second and third test cases, it can be shown that there is no such way to split numbers into groups.\nIn the fourth test case, we can put number\n16\ninto the first group, with sum\n16\n, numbers\n12\nand\n1\ninto the second group, with sum\n13\n, and the remaining five\n1\ns into the third group, with sum\n5\n, as there exists a triangle with positive area and sides\n16,13,5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*2800"
        ]
    },
    {
        "title": "J. Amanda the Amoeba",
        "description": "This problem has an attachment. You can use it to simulate and visualize the movements of the amoeba.\nAmoeba Amanda lives inside a rectangular grid of square pixels. Her body occupies some of these pixels. Other pixels may be either free or blocked. Amanda moves across the grid using the so-called amoeboid movement. In each step of such a movement, her body first shrinks by one pixel (one pixel of the body is removed and becomes free), and then grows at a different place (one previously-free pixel is added to the body).\nTo prevent structural damage, Amanda's body always occupies a connected region of pixels, which means that any pair of pixels forming the body can be connected by a sequence of adjacent pixels without ever leaving the body. Two pixels are considered adjacent if they share a common side (each pixel has at most 4 neighbours). The body remains connected even during the movement, including the moment after removing a pixel and before adding another one.\nYour task is to help Amanda find her way around. Given her initial position and desired final position, suggest a sequence of valid moves leading from the former to the latter.\nIllustration of sample\n1\n: The filled shape is the initial position, the dotted region is the final position.\nInput\nThe first line contains two integers\nr\nand\nc\n(\n1≤r,c≤50\n) — the size of the rectangular grid in pixels.\nThe next\nr\nlines contain\nc\ncharacters each, describing the initial position of Amanda. Each of those characters is either a dot\n.\ndenoting a free pixel, an asterisk\n*\ndenoting Amanda's body, or an\nX\ndenoting a blocked pixel which may never be occupied.\nThe next line is empty.\nThe next\nr\nlines describe the desired final position in the same format as the initial position.\nIt is guaranteed that:\nThe number of pixels forming Amanda's body is the same in both positions, and it is at least 2.\nThe body of Amanda is connected in the initial position.\nThe body of Amanda is connected in the final position.\nThe blocked pixels do not change between the descriptions of the initial and final position, their placement is exactly the same in both positions.\nOutput\nPrint\nYES\nif it is possible for Amanda to go from the initial position to the final one. Otherwise, print\nNO\n.\nIf it is possible, on the next line print one integer\nm\n(\n0≤m≤10000\n) — the number of moves to execute.\nThe following\nm\nlines must contain four integer coordinates each:\ni\n1\n,\nj\n1\n,\ni\n2\n,\nj\n2\n(\n1≤\ni\n1\n,\ni\n2\n≤r\n,\n1≤\nj\n1\n,\nj\n2\n≤c\n). These four coordinates specify one move, meaning that the pixel at\ni\n1\n-th row and\nj\n1\n-th column is first removed from the body. Then,\n(\ni\n2\n,\nj\n2\n)\nmust designate a different location where one pixel is added.\nThe sequence should consist only of valid moves and after the last move, Amanda's body should occupy the desired final position.\nIf there are multiple solutions, print any of them.\nUnder the assumptions of this problem, it can be proven that if it is possible for Amanda to go from the initial position to the desired final one, then it is possible to do it with at most\n10000\nmoves.\nExamples\ninput\nCopy\n5 8\n.******.\n**.X**..\n*******.\n**.X**..\n.******.\n\n.******.\n...X****\n.*******\n...X****\n.******.\noutput\nCopy\nYES\n5\n3 1 3 8\n2 1 2 8\n4 1 4 8\n2 2 4 7\n4 2 2 7\ninput\nCopy\n2 5\n*.X..\n**X..\n\n..X**\n..X*.\noutput\nCopy\nNO\nNote\nIn the first sample, Amanda executes 5 moves to reach the final position, as shown in the figure below.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "graphs",
            "implementation",
            "trees",
            "two pointers",
            "*2600"
        ]
    },
    {
        "title": "I. Disks",
        "description": "You are given\nn\ndisks in the plane. The center of each disk has integer coordinates, and the radius of each disk is a positive integer. No two disks overlap in a region of positive area, but it is possible for disks to be tangent to each other.\nYour task is to determine whether it is possible to change the radii of the disks in such a way that:\nDisks that were tangent to each other remain tangent to each other.\nNo two disks overlap in a region of positive area.\nThe sum of all radii strictly decreases.\nThe new radii are allowed to be arbitrary positive real numbers. The centers of the disks cannot be changed.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤1000\n) — the number of disks.\nThe next\nn\nlines contain three integers each. The\ni\n-th of such lines contains\nx\ni\n,\ny\ni\n(\n−\n10\n9\n≤\nx\ni\n,\ny\ni\n≤\n10\n9\n), and\nr\ni\n(\n1≤\nr\ni\n≤\n10\n9\n) — the coordinates of the center, and the radius, of the\ni\n-th disk.\nOutput\nPrint\nYES\nif it is possible to change the radii in the desired manner. Otherwise, print\nNO\n.\nExamples\ninput\nCopy\n5\n0 2 1\n0 0 1\n4 -3 4\n11 0 3\n11 5 2\noutput\nCopy\nYES\ninput\nCopy\n4\n2 2 2\n7 2 3\n7 7 2\n2 7 3\noutput\nCopy\nNO\nNote\nIn the first sample, one can decrease the radii of the first and third disk by\n0.5\n, and increase the radius of the second disk by\n0.5\n. This way, the sum of all radii decreases by\n0.5\n. The situation before and after changing the radii is depicted below.\nFirst sample (left) and a valid way to change the radii of the disks (right).\nIn the second sample, depicted below, there is no way to change the radii of the disks in the desired manner.\nSecond sample.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "geometry",
            "graph matchings",
            "graphs",
            "*1800"
        ]
    },
    {
        "title": "H. Division Avoidance",
        "description": "A newly discovered organism can be represented as a set of cells on an infinite grid. There is a coordinate system on the grid such that each cell has two integer coordinates\nx\nand\ny\n. A cell with coordinates\nx=a\nand\ny=b\nwill be denoted as\n(a,b)\n.\nInitially, the organism consists of a single cell\n(0,0)\n. Then zero or more divisions can happen. In one division, a cell\n(a,b)\nis removed and replaced by two cells\n(a+1,b)\nand\n(a,b+1)\n.\nFor example, after the first division, the organism always consists of two cells\n(1,0)\nand\n(0,1)\n, and after the second division, it is either the three cells\n(2,0)\n,\n(1,1)\nand\n(0,1)\n, or the three cells\n(1,0)\n,\n(1,1)\nand\n(0,2)\n.\nA division of a cell\n(a,b)\ncan only happen if the cells\n(a+1,b)\nand\n(a,b+1)\nare not yet part of the organism. For example, the cell\n(1,0)\ncannot divide if the organism currently consists of the three cells\n(1,0)\n,\n(1,1)\nand\n(0,2)\n, since the cell\n(1,1)\nthat would be one of the results of this division is already part of the organism.\nYou are given a set of forbidden cells\n(\nc\ni\n,\nd\ni\n)\n. Is it possible for the organism to contain none of those cells after zero or more divisions?\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤10000\n) — the number of test cases. The descriptions of the\nt\ntest cases follow.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤\n10\n6\n) — the number of forbidden cells.\nThe next\nn\nlines contain two integers each. The\ni\n-th of such lines contains\nc\ni\nand\nd\ni\n(\n0≤\nc\ni\n,\nd\ni\n≤\n10\n9\n) — the coordinates of the\ni\n-th forbidden cell. It is guaranteed that all forbidden cells are distinct.\nIt is guaranteed that the sum of values of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print\nYES\nif it is possible for the organism to contain no forbidden cells after zero or more divisions. Otherwise, print\nNO\n.\nExample\ninput\nCopy\n2\n4\n0 0\n1 0\n0 1\n1 1\n16\n0 0\n0 1\n0 2\n0 3\n1 0\n1 1\n1 2\n1 3\n2 0\n2 1\n2 2\n2 3\n3 0\n3 1\n3 2\n3 3\noutput\nCopy\nYES\nNO\nNote\nIn the first test case, dividing the following cells in the following order creates an organism without any forbidden cells:\n(0,0)\n,\n(1,0)\n,\n(1,1)\n,\n(0,1)\n,\n(2,1)\n,\n(2,2)\n,\n(1,2)\n,\n(1,1)\n. The following picture demonstrates how the organism changes during this process:\nIn the second test case, you can see that, surprisingly, any organism always has at least one cell in the\n0≤x,y≤3\nsquare, no matter how many divisions we do.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*3100"
        ]
    },
    {
        "title": "G. Scooter",
        "description": "The Czech Technical University campus consists of\nn\nbuildings, indexed from\n1\nto\nn\n. In each building, there can be a math class scheduled, or a computer science class, or neither (but not both). Additionally, in each building, there is at most one professor, and each professor is either an expert in mathematics or in computer science.\nAs an intern at University Express Inc., your job is to quickly transport the professors to their classes. For this, you have been granted a brand new two-person scooter, able to accommodate yourself, plus at most one passenger.\nInitially, you are the only person on the scooter. When you arrive at a building, you may drop off or pick up professors to/from that building. However, in order to improve the efficiency of your task, you are allowed to drive to each of the\nn\nbuildings at most once, in the order of your choice (you can also decide where to start the itinerary).\nAfter the end of your itinerary, in each building where a math class is scheduled, there must be a professor expert in math, and in each building where a computer science class is scheduled, there must be a professor expert in computer science.\nDevise an itinerary that makes it possible to teach all classes.\nInput\nThe first line contains an integer\nn\n(\n1≤n≤2000\n) — the number of buildings in the campus.\nThe second line contains a string of\nc\nof length\nn\nconsisting of the characters\n-\n,\nC\n,\nM\n— the\ni\n-th character denotes the subject of the class scheduled in the\ni\n-th building.\nC\nstands for computer science,\nM\nstands for mathematics, while\n-\nmeans that there is no class scheduled in the\ni\n-th building.\nThe third line contains a string\np\nof length\nn\nconsisting of the characters\n-\n,\nC\n,\nM\n— the\ni\n-th character denotes the expertise of the professor in the\ni\n-th building (if there is a professor).\nC\nstands for computer science,\nM\nstands for mathematics, while\n-\nmeans that there is no professor in the\ni\n-th building.\nIt is guaranteed that, for all tests given to your program, there exists a valid itinerary.\nOutput\nIn the first line print an integer\nl\n— the number of operations in your chosen itinerary.\nThe\ni\n-th (\n1≤i≤l\n) of the next\nl\nlines must contain one of three commands:\nDRIVE x\n— go to the building with the number\nx\n(\n1≤x≤n\n);\nPICKUP\n— pick up the professor which was initially at the current building;\nDROPOFF\n— drop off the passenger professor at the current building.\nIn order for the itinerary to be valid, the following conditions must hold:\nNo two\nDRIVE\ninstructions should go to the same building;\nAt most one\nDROPOFF\nand one\nPICKUP\ninstruction in this order should be issued at each specific building;\nFor all\nPICKUP\ninstructions, there must be a professor initially at the building, as well as no one already riding along on the scooter;\nFor all\nDROPOFF\ninstructions, there must be a professor riding along at the time of the command;\nAfter the itinerary, in each building, if there is a class in that building, there must be a professor expert in the class' subject (either initially, or because they were dropped off there).\nNote that, in particular, you cannot pick up a professor that you just dropped off for an itinerary to be valid.\nExamples\ninput\nCopy\n3\nCM-\n-CM\noutput\nCopy\n7\nDRIVE 3\nPICKUP\nDRIVE 2\nDROPOFF\nPICKUP\nDRIVE 1\nDROPOFF\ninput\nCopy\n1\nC\nC\noutput\nCopy\n0\ninput\nCopy\n2\n-M\nMC\noutput\nCopy\n4\nDRIVE 1\nPICKUP\nDRIVE 2\nDROPOFF\nNote\nIn the first sample, You start by driving to building number\n3\n. You then pick up the mathematics professor. After dropping him off at building number\n2\n, where a mathematics class is being held, you pick up the computer science professor from there, and drop her off at building number\n1\n, finishing your itinerary.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "graphs",
            "greedy",
            "*2300"
        ]
    },
    {
        "title": "F. Dating",
        "description": "You are the developer of a dating app which ignores gender completely. The app has\nn\nusers, indexed from\n1\nto\nn\n. Each user's profile features a list of the activities they enjoy doing. There are\nm\npossible activities, indexed from\n1\nto\nm\n.\nA match between two users is good if they share at least one activity and, at the same time, both of them like at least one activity that the other user does not like.\nFind a good match if it exists.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n2≤n≤200000\n,\n1≤m≤\n10\n6\n) — the number of users and the number of activities.\nEach of the following\nn\nlines contains a number\nk\ni\n(\n0≤\nk\ni\n≤m\n) — the number of activities that user\ni\nlikes — followed by\nk\ni\ndistinct integers from\n1\nto\nm\n— the activities user\ni\nlikes.\nIt is guaranteed that\nk\n1\n+\nk\n2\n+⋯+\nk\nn\ndoes not exceed\n10\n6\n.\nOutput\nPrint\nYES\nif a good match exists. Otherwise, print\nNO\n.\nIf a good match exists, on the next line print two integers — the indexes of two users that make a match.\nExamples\ninput\nCopy\n3 5\n3 1 2 4\n5 1 2 3 4 5\n2 1 5\noutput\nCopy\nYES\n3 1\ninput\nCopy\n3 3\n1 1\n1 2\n3 2 3 1\noutput\nCopy\nNO\nNote\nIn the first sample, users\n1\nand\n3\nform a match, because they share activity\n1\n, and, furthermore, user\n3\nlikes activity\n5\n(which user\n1\ndoes not like) and user\n1\nlikes activity\n4\n(which user\n3\ndoes not like). Note that users\n1\nand\n2\n, as well as users\n2\nand\n3\n, do not form a match, as there is no activity that users\n1\nor\n3\nlike, and user\n2\ndoesn't like.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "trees",
            "*2200"
        ]
    },
    {
        "title": "E. Damage per Second",
        "description": "You just created a new character in your favourite role-playing game and now have to decide how to skill him.\nThe two skill attributes to be chosen are: damage per hit and hits per second. Damage per hit is the amount of damage you deal with a single hit, while hits per second is the number of hits you can make in one second. Initially, both skill attributes are set at\n0\n. You have\nk\nskill points to distribute as you want; in other words, you can choose the values of the two skills so that they are positive integers with sum at most\nk\n.\nThe tutorial of the game (the boring part you want to finish as soon as possible) consists of\nn\nmonsters to be killed one after the other. The\ni\n-th monster has\nh\ni\nhealth points, i.e., it dies after you have inflicted at least\nh\ni\ndamage.\nHow can you assign the two skill attributes to minimize the time necessary to kill all the\nn\nmonsters?\nInput\nThe first line contains two integers\nn\nand\nk\n(\n1≤n≤200000\n,\n2≤k≤200000\n) — the number of enemies and the number of skill points.\nThe second line contains\nn\nintegers\nh\ni\n(\n1≤\nh\ni\n≤\n10\n13\n) — the health of the\ni\nth enemy.\nOutput\nPrint two positive integers\nx\nand\ny\n(\n1≤x,y\nand\nx+y≤k\n) — the number of skill points you want to invest in damage per hit and hits per second. If there are multiple optimal solutions, print any of them.\nExamples\ninput\nCopy\n1 7\n14\noutput\nCopy\n3 4\ninput\nCopy\n4 9\n1 2 3 4\noutput\nCopy\n4 5\ninput\nCopy\n5 13\n3 4 5 6 7\noutput\nCopy\n7 6\nNote\nIn the first sample, there is only one monster and you have\n7\nskill points to distribute. If you make\n3\ndamage per hit, you will need\n5\nhits to kill it. If you do\n4\nhits per second, you will need\n1.25\nseconds to beat the monster. There is no way to beat the monster faster than this.\nIn the second sample, you will need one hit for each monster and a total time of\n0.8\nseconds if you distribute\n4\nskill points on damage per hit and the remaining\n5\npoints on hits per second.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "math",
            "*2900"
        ]
    },
    {
        "title": "D. Funny or Scary?",
        "description": "You are designing a new video game. It has\nn\nscenarios, which the player may play in any order, but each scenario must be played exactly once. When a player switches from a scenario to another scenario, the game shows a specially crafted transition video to make it all feel part of one big story. This video is specific to a pair of scenarios, but not to their order, in other words, the video playing when switching from scenario\na\nto scenario\nb\nis the same as the video playing when switching from scenario\nb\nto scenario\na\n. Therefore, you need to create\nn(n−1)\n2\ndifferent transition videos, one for each possible pair of different scenarios.\nEach transition video can be either funny or scary. It is boring to see too many funny videos or too many scary videos in a row. Therefore, your goal is to create the videos in such a way that no matter in which order does the player approach the scenarios, they will never see more than\n⌈\n3n\n4\n⌉\ntransition videos of the same type in a row.\nYou have already come up with ideas for at most\n⌊\nn\n2\n⌋\nof the transition videos, and therefore already know if those will be funny or scary. Now you need to choose funny or scary for all other transition videos in such a way that the above requirement is satisfied.\nInput\nThe first line contains a single integer\nn\n(\n2≤n≤24\n) — the number of scenarios in the game.\nThe next\nn\nlines describe the partial transition video plan. Each of those lines contains\nn\ncharacters. The\nj\n-th character of the\ni\n-th line corresponds to the transition video between the\ni\n-th and the\nj\n-th scenarios. It will be F if the corresponding transition video will be funny, S if the corresponding transition video will be scary, ? if the corresponding transition video is still undecided, or . if\ni=j\n.\nIt is guaranteed that the\ni\n-th character of the\nj\n-th line and the\nj\n-th character of the\ni\n-th line will be the same for all\ni\nand\nj\n. It is guaranteed that at most\n⌊\nn\n2\n⌋\n(\nn\ndivided by 2, rounded down) transition videos will already be decided, in other words, that at most\n2⌊\nn\n2\n⌋\ncharacters in the input will be F or S.\nOutput\nPrint\nn\nlines describing the full transition video plan in the same format as the input. Each of those lines must contain\nn\ncharacters. The\nj\n-th character of the\ni\n-th line must be F if the corresponding transition video is funny, S if the corresponding transition video is scary, or . if\ni=j\n.\nEach ? character from the input must be replaced with either F or S, and all other characters from the input must remain unchanged. It must still hold that the\ni\n-th character of the\nj\n-th line and the\nj\n-th character of the\ni\n-th line are the same for all\ni\nand\nj\n.\nFor each permutation of the\nn\nscenarios, it must hold that the transition videos corresponding to playing the scenarios in this order do not have more than\n⌈\n3n\n4\n⌉\n(\n3n\ndivided by 4, rounded up) videos of the same type consecutively.\nIf there are multiple solutions, print any of them. It can be proven that for all inputs satisfying the constraints of this problem a solution always exists.\nExamples\ninput\nCopy\n5\n.?F??\n?.???\nF?.S?\n??S.?\n????.\noutput\nCopy\n.FFFF\nF.FFF\nFF.SF\nFFS.F\nFFFF.\ninput\nCopy\n12\n.???????????\n?.??????????\n??.?????????\n???.????????\n????.???????\n?????.??????\n??????.?????\n???????.????\n????????.???\n?????????.??\n??????????.?\n???????????.\noutput\nCopy\n.SSSFFSSSSFS\nS.SFFSFSFFFS\nSS.SFFFSSSFS\nSFS.FFSSSSFS\nFFFF.FFFFFSF\nFSFFF.SFFSFF\nSFFSFS.SSSFS\nSSSSFFS.SSFS\nSFSSFFSS.SFS\nSFSSFSSSS.FS\nFFFFSFFFFF.F\nSSSSFFSSSSF.\nNote\nIn the first sample: We are allowed\n⌈\n3⋅5\n4\n⌉=4\ntransition videos of the same type in a row, but for any permutation of the 5 scenarios the player will see only 4 transition videos in total, therefore we can choose funny or scary freely. We must still respect the already chosen types.\nIn the second sample: One of the 479001600 possible permutations of scenarios is 1, 7, 4, 12, 9, 8, 2, 6, 10, 3, 11, 5. The player will get the following sequence of transition videos for this permutation: SSSSSSSSSFS. Even though this sequence has 10 scary transition videos in total, it has only 9 scary transition videos in a row, which is the maximum allowed amount (\n⌈\n3⋅12\n4\n⌉=9\n).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*2600"
        ]
    },
    {
        "title": "B. Charming Meals",
        "description": "The Czech cuisine features\nn\nappetizers and\nn\nmain dishes. The\ni\n-th appetizer has spiciness\na\ni\n, and the\ni\n-th main dish has spiciness\nb\ni\n.\nA typical Czech meal consists of exactly one appetizer and one main dish. You want to pair up the\nn\nappetizers and\nn\nmain dishes into\nn\nmeals with each appetizer and each main dish being included in exactly one meal.\nYour meals shall surprise the diners, so you want the spiciness levels of the two parts of the same meal to be as different as possible. The charm of a meal is the difference (in absolute value) between the spiciness of the appetizer and the spiciness of the main dish. So, a meal consisting of an appetizer with spiciness\nx\nand a main dish with spiciness\ny\nhas charm equal to\n|x−y|\n.\nYou want to maximize the minimum charm of the resulting\nn\nmeals. What is the largest possible value of the minimum charm that you can achieve?\nInput\nEach test contains multiple test cases. The first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The descriptions of the\nt\ntest cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5000\n) —the number of appetizers and main dishes.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the spicinesses of the\nn\nappetizers.\nThe third line of each test case contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n≤\n10\n9\n) — the spicinesses of the\nn\nmain dishes.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n25⋅\n10\n6\n.\nOutput\nFor each test case, print the largest possible value of the minimum charm you can achieve.\nExample\ninput\nCopy\n4\n3\n0 0 0\n1000000000 1000000000 1000000000\n5\n1 2 3 4 5\n1 2 3 4 5\n6\n0 0 0 100 100 100\n100 100 100 0 0 0\n7\n14 25 62 74 86 95 12\n51 62 71 72 92 20 84\noutput\nCopy\n1000000000\n2\n100\n30\nNote\nIn the first test case, no matter how you pair up the appetizers with the main dishes, each meal will have an appetizer with spiciness\n0\nand a main dish with spiciness\n1000000000\n, so the charm of each meal will be\n1000000000\n.\nIn the second test case, one optimal way to pair up appetizers and main dishes is:\n(1,5)\n,\n(2,4)\n,\n(3,1)\n,\n(4,2)\n,\n(5,3)\n. The corresponding meals have charms:\n4\n,\n2\n,\n2\n,\n2\n,\n2\n. The resulting minimum charm is\n2\n.\nIn the third test case, one way to maximize the minimum charm is to pair up the three appetizers with spiciness\n0\nwith the three main dishes with spiciness\n100\n, and the three appetizers with spiciness\n100\nwith the three main dishes with spiciness\n0\n. Doing so, the charm of each meal will be exactly\n100\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "*1500"
        ]
    },
    {
        "title": "A. Grove",
        "description": "You want to plant trees in a square lawn of size\nn×n\nwhose corners have Cartesian coordinates\n(0,0)\n,\n(n,0)\n,\n(0,n)\n, and\n(n,n)\n. Trees can only be planted at locations with integer coordinates. Every tree will grow roots within a disk of radius\nr\ncentered at the location where the tree was planted; such disks must be fully contained in the lawn (possibly touching the boundary of the lawn) and can only intersect each other on their boundaries.\nFind a configuration that maximizes the number of trees.\nInput\nThe first and only line contains an integer\nn\n(\n1≤n≤20\n) and a real number\nr\n(\n0<r≤n/2\n) — the length of the sides of the lawn, and the radius of the disks where each tree will grow roots. The real number\nr\nis given in decimal notation with at least\n1\nand at most\n3\ndigits after the decimal point.\nOutput\nIn the first line, print the maximum number\nm\nof trees that can be planted.\nIn the next\nm\nlines, print a configuration that maximizes the number of trees. Specifically, in the\n(i+1)\n-th line, print two integers\nx\nand\ny\n— the coordinates of the location where the\ni\n-th tree should be planted. You can print the trees in any order.\nIf there are multiple solutions, print any of them.\nExamples\ninput\nCopy\n6 1.241\noutput\nCopy\n2\n4 2\n2 4\ninput\nCopy\n9 2.0\noutput\nCopy\n4\n2 2\n7 2\n2 6\n6 6\nNote\nFor the first sample, the sample output is shown in the following figure. Note that this is not the only configuration that maximizes the number of trees.\nFor the second sample, the sample output is shown in the following figure. Note that this is not the only configuration that maximizes the number of trees.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "geometry",
            "probabilities",
            "*3300"
        ]
    },
    {
        "title": "G. MST with Matching",
        "description": "You are given an undirected connected graph on\nn\nvertices. Each edge of this graph has a weight; the weight of the edge connecting vertices\ni\nand\nj\nis\nw\ni,j\n(or\nw\ni,j\n=0\nif there is no edge between\ni\nand\nj\n). All weights are positive integers.\nYou are also given a positive integer\nc\n.\nYou have to build a spanning tree of this graph; i. e. choose exactly\n(n−1)\nedges of this graph in such a way that every vertex can be reached from every other vertex by traversing some of the chosen edges. The cost of the spanning tree is the sum of two values:\nthe sum of weights of all chosen edges;\nthe maximum matching in the spanning tree (i. e. the maximum size of a set of edges such that they all belong to the chosen spanning tree, and no vertex has more than one incident edge in this set), multiplied by the given integer\nc\n.\nFind any spanning tree with the minimum cost. Since the graph is connected, there exists at least one spanning tree.\nInput\nThe first line contains two integers\nn\nand\nc\n(\n2≤n≤20\n;\n1≤c≤\n10\n6\n).\nThen\nn\nlines follow. The\ni\n-th of them contains\nn\nintegers\nw\ni,1\n,\nw\ni,2\n,…,\nw\ni,n\n(\n0≤\nw\ni,j\n≤\n10\n6\n), where\nw\ni,j\ndenotes the weight of the edge between\ni\nand\nj\n(or\nw\ni,j\n=0\nif there is no such edge).\nAdditional constraints on the input:\nfor every\ni∈[1,n]\n,\nw\ni,i\n=0\n;\nfor every pair of integers\n(i,j)\nsuch that\ni∈[1,n]\nand\nj∈[1,n]\n,\nw\ni,j\n=\nw\nj,i\n;\nthe given graph is connected.\nOutput\nPrint one integer — the minimum cost of a spanning tree of the given graph.\nExamples\ninput\nCopy\n4 10\n0 1 8 0\n1 0 1 0\n8 1 0 2\n0 0 2 0\noutput\nCopy\n21\ninput\nCopy\n4 5\n0 1 8 0\n1 0 1 0\n8 1 0 2\n0 0 2 0\noutput\nCopy\n14\nNote\nIn the first example, the minimum cost spanning tree consists of edges\n(1,3)\n,\n(2,3)\nand\n(3,4)\n. The maximum matching for it is\n1\n.\nIn the second example, the minimum cost spanning tree consists of edges\n(1,2)\n,\n(2,3)\nand\n(3,4)\n. The maximum matching for it is\n2\n.",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dsu",
            "graph matchings",
            "trees",
            "*3100"
        ]
    },
    {
        "title": "F. Rare Coins",
        "description": "There are\nn\nbags numbered from\n1\nto\nn\n, the\ni\n-th bag contains\na\ni\ngolden coins and\nb\ni\nsilver coins.\nThe value of a gold coin is\n1\n. The value of a silver coin is either\n0\nor\n1\n, determined for each silver coin independently (\n0\nwith probability\n1\n2\n,\n1\nwith probability\n1\n2\n).\nYou have to answer\nq\nindependent queries. Each query is the following:\nl\nr\n — calculate the probability that the total value of coins in bags from\nl\nto\nr\nis strictly greater than the total value in all other bags.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤n,q≤3⋅\n10\n5\n) — the number of bags and the number of queries, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n6\n) — the number of gold coins in the\ni\n-th bag.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n≤\n10\n6\n) — the number of silver coins in the\ni\n-th bag.\nNext\nq\nlines contain queries. The\nj\n-th of the next\nq\nlines contains two integers\nl\nj\nand\nr\nj\n(\n1≤\nl\nj\n≤\nr\nj\n≤n\n) — the description of the\nj\n-th query.\nAdditional constraints on the input:\nthe sum of the array\na\ndoesn't exceed\n10\n6\n;\nthe sum of the array\nb\ndoesn't exceed\n10\n6\n.\nOutput\nFor each query, print one integer — the probability that the total value of coins in bags from\nl\nto\nr\nis strictly greater than the total value in all other bags, taken modulo\n998244353\n.\nFormally, the probability can be expressed as an irreducible fraction\nx\ny\n. You have to print the value of\nx⋅\ny\n−1\nmod998244353\n, where\ny\n−1\nis an integer such that\ny⋅\ny\n−1\nmod998244353=1\n.\nExamples\ninput\nCopy\n2 2\n1 0\n0 2\n2 2\n1 1\noutput\nCopy\n748683265 748683265 \ninput\nCopy\n4 3\n2 3 4 5\n1 0 7 3\n3 3\n2 3\n1 4\noutput\nCopy\n997756929 273932289 1 \nNote\nIn both queries from the first example, the answer is\n1\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "probabilities",
            "*2500"
        ]
    },
    {
        "title": "E. Clique Partition",
        "description": "You are given two integers,\nn\nand\nk\n. There is a graph on\nn\nvertices, numbered from\n1\nto\nn\n, which initially has no edges.\nYou have to assign each vertex an integer; let\na\ni\nbe the integer on the vertex\ni\n. All\na\ni\nshould be distinct integers from\n1\nto\nn\n.\nAfter assigning integers, for every pair of vertices\n(i,j)\n, you add an edge between them if\n|i−j|+|\na\ni\n−\na\nj\n|≤k\n.\nYour goal is to create a graph which can be partitioned into the minimum possible (for the given values of\nn\nand\nk\n) number of cliques. Each vertex of the graph should belong to exactly one clique. Recall that a clique is a set of vertices such that every pair of vertices in it are connected with an edge.\nSince BledDest hasn't really brushed his programming skills up, he can't solve the problem \"given a graph, partition it into the minimum number of cliques\". So we also ask you to print the partition itself.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1600\n) — the number of test cases.\nEach test case consists of one line containing two integers\nn\nand\nk\n(\n2≤n≤40\n;\n1≤k≤2n\n).\nOutput\nFor each test case, print three lines:\nthe first line should contain\nn\ndistinct integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the values you assign to the vertices;\nthe second line should contain one integer\nq\n(\n1≤q≤n\n) — the number of cliques you partition the graph into;\nthe third line should contain\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤q\n) — the partition of the graph into cliques. Where two vertices\nu\nand\nv\nare in the same clique if\nc\nu\n=\nc\nv\n.\nIf there are multiple answers, print any of them.\nExample\ninput\nCopy\n3\n2 3\n5 4\n8 16\noutput\nCopy\n2 1\n1\n1 1\n3 1 5 2 4\n2\n1 1 2 1 2\n1 2 3 4 5 6 7 8\n1\n1 1 1 1 1 1 1 1",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "graphs",
            "greedy",
            "implementation",
            "*2100"
        ]
    },
    {
        "title": "D. Tandem Repeats?",
        "description": "You are given a string\ns\n, consisting of lowercase Latin letters and/or question marks.\nA tandem repeat is a string of an even length such that its first half is equal to its second half.\nA string\na\nis a substring of a string\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nYour goal is to replace each question mark with some lowercase Latin letter in such a way that the length of the longest substring that is a tandem repeat is maximum possible.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of testcases.\nThe only line of each testcase contains a string\ns\n(\n1≤|s|≤5000\n), consisting only of lowercase Latin letters and/or question marks.\nThe total length of the strings over all testcases doesn't exceed\n5000\n.\nOutput\nFor each testcase, print a single integer — the maximum length of the longest substring that is a tandem repeat after you replace each question mark in the string with some lowercase Latin letter.\nIf it's impossible to make any tandem repeat substrings in the string, print\n0\n.\nExample\ninput\nCopy\n4\nzaabaabz\n?????\ncode?????s\ncodeforces\noutput\nCopy\n6\n4\n10\n0",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "two pointers",
            "*1700"
        ]
    },
    {
        "title": "C. Arrow Path",
        "description": "There is a grid, consisting of\n2\nrows and\nn\ncolumns. The rows are numbered from\n1\nto\n2\nfrom top to bottom. The columns are numbered from\n1\nto\nn\nfrom left to right. Each cell of the grid contains an arrow pointing either to the left or to the right. No arrow points outside the grid.\nThere is a robot that starts in a cell\n(1,1)\n. Every second, the following two actions happen one after another:\nFirstly, the robot moves left, right, down or up (it can't try to go outside the grid, and can't skip a move);\nthen it moves along the arrow that is placed in the current cell (the cell it ends up after its move).\nYour task is to determine whether the robot can reach the cell\n(2,n)\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer (\n2≤n≤2⋅\n10\n5\n).\nThe second line contains a string consisting of exactly\nn\ncharacters < and/or > — the first row of the grid.\nThe third line contains a string consisting of exactly\nn\ncharacters < and/or > — the second row of the grid.\nAdditional constraints on the input:\nn\nis even;\nthere are no arrows pointing outside the grid;\nthe sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print YES if the robot can reach the cell\n(2,n)\n; otherwise, print NO.\nYou can print each letter in any case. For example, yes, Yes, YeS will all be recognized as positive answer.\nExample\ninput\nCopy\n4\n4\n>><<\n>>><\n2\n><\n><\n4\n>>><\n>><<\n6\n>><<><\n><>>><\noutput\nCopy\nYES\nYES\nNO\nYES\nNote\nIn the first example, one of the possible paths looks as follows:\n(1,1)→(1,2)→(1,3)→(2,3)→(2,4)\n.\nIn the second example, one of the possible paths looks as follows:\n(1,1)→(2,1)→(2,2)\n.\nIn the third example, there is no way to reach the cell\n(2,4)\n.\nIn the fourth example, one of the possible paths looks as follows:\n(1,1)→(2,1)→(2,2)→(1,2)→(1,3)→(2,3)→(2,4)→(2,5)→(2,6)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "dp",
            "graphs",
            "shortest paths",
            "*1300"
        ]
    },
    {
        "title": "B. Array Fix",
        "description": "You are given an integer array\na\nof length\nn\n.\nYou can perform the following operation any number of times (possibly zero): take any element of the array\na\n, which is at least\n10\n, delete it, and instead insert the digits that element consisted of in the same position, in order they appear in that element.\nFor example:\nif we apply this operation to the\n3\n-rd element of the array\n[12,3,45,67]\n, then the array becomes\n[12,3,4,5,67]\n.\nif we apply this operation to the\n2\n-nd element of the array\n[2,10]\n, then the array becomes\n[2,1,0]\n.\nYour task is to determine whether it is possible to make\na\nsorted in non-descending order using the aforementioned operation any number of times (possibly zero). In other words, you have to determine if it is possible to transform the array\na\nin such a way that\na\n1\n≤\na\n2\n≤⋯≤\na\nk\n, where\nk\nis the current length of the array\na\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains a single integer\nn\n(\n2≤n≤50\n).\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤99\n).\nOutput\nFor each test case, print YES if it is possible to make\na\nsorted in non-decreasing order using the aforementioned operation; otherwise, print NO.\nYou can print each letter in any case. For example, yes, Yes, YeS will all be recognized as a positive answer.\nExample\ninput\nCopy\n3\n4\n12 3 45 67\n3\n12 28 5\n2\n0 0\noutput\nCopy\nYES\nNO\nYES\nNote\nIn the first example, you can split the first element, then the array becomes\n[1,2,3,45,67]\n.\nIn the second example, there is no way to get a sorted array.\nIn the third example, the array is already sorted.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "A. Special Characters",
        "description": "You are given an integer\nn\n.\nYour task is to build a string of uppercase Latin letters. There must be exactly\nn\nspecial characters in this string. Let's call a character special if it is equal to exactly one of its neighbors.\nFor example, there are\n6\nspecial characters in the AAABAACC string (at positions:\n1\n,\n3\n,\n5\n,\n6\n,\n7\nand\n8\n).\nPrint any suitable string or report that there is no such string.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤50\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤50\n).\nOutput\nFor each test case, print the answer as follows:\nif there is no suitable string, print one line containing the string NO;\notherwise, print two lines. The first line should contain the string YES; on the second line print a string of length at most\n200\n — the answer itself (it can be shown that if some answers exist, then there is an answer of length at most\n200\n). If there are several solutions, print any of them.\nExample\ninput\nCopy\n3\n6\n1\n2\noutput\nCopy\nYES\nAAABAACC\nNO\nYES\nMM",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "*800"
        ]
    },
    {
        "title": "F. Nobody is needed",
        "description": "Oleg received a permutation\na\nof length\nn\nas a birthday present.\nOleg's friend Nechipor asks Oleg\nq\nquestions, each question is characterized by two numbers\nl\nand\nr\n, in response to the question Oleg must say the number of sets of indices\n(\nt\n1\n,\nt\n2\n,…,\nt\nk\n)\nof any length\nk≥1\nsuch that:\nl≤\nt\ni\n≤r\nfor each\ni\nfrom\n1\nto\nk\n.\nt\ni\n<\nt\ni+1\nfor each\ni\nfrom\n1\nto\nk−1\n.\na\nt\ni+1\nis divisible by\na\nt\ni\nfor each\ni\nfrom\n1\nto\nk−1\n.\nHelp Oleg and answer all of Nechipor's questions.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. The description of the sets of input data follows.\nThe first line of each set of input data contains two integers\nn\nand\nq\n(\n1≤n,q≤\n10\n6\n) — the length of the permutation and the number of Nechipor's questions.\nThe second line of each set of input data contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the permutation\na\nitself.\nIn each of the next\nq\nlines of each set of input data, there are two integers\nl\nand\nr\n(\n1≤l≤r≤n\n) — the next question of Nechipor.\nIt is guaranteed that the sum of the values of\nn\nand the sum of the values of\nq\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each set of input data, output the answers to all of Nechipor's questions.\nExample\ninput\nCopy\n4\n8 8\n2 1 6 3 5 4 8 7\n1 8\n2 8\n1 7\n1 6\n1 3\n5 8\n4 4\n2 3\n1 1\n1\n1 1\n3 3\n3 2 1\n1 2\n1 3\n2 3\n8 1\n1 2 3 4 5 6 7 8\n1 8\noutput\nCopy\n20 15 18 12 5 5 1 3\n1\n2 3 2\n27\nNote\nAll suitable arrays in the first set of input data: (\n1\n), (\n2\n), (\n3\n), (\n4\n), (\n5\n), (\n6\n), (\n7\n), (\n8\n), (\n1,3\n), (\n1,6\n), (\n1,7\n), (\n1,6,7\n), (\n2,3\n), (\n2,4\n), (\n2,5\n), (\n2,6\n), (\n2,7\n), (\n2,8\n), (\n2,6,7\n), (\n6,7\n).\nAll suitable arrays in the fourth set of input data: (\n1\n), (\n2\n), (\n3\n), (\n4\n), (\n5\n), (\n6\n), (\n7\n), (\n8\n), (\n1,2\n), (\n1,3\n), (\n1,4\n), (\n1,5\n), (\n1,6\n), (\n1,7\n), (\n1,8\n), (\n1,2,4\n), (\n1,2,6\n), (\n1,2,8\n), (\n1,2,4,8\n), (\n1,3,6\n), (\n1,4,8\n), (\n2,4\n), (\n2,6\n), (\n2,8\n), (\n2,4,8\n), (\n3,6\n), (\n4,8\n).",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "2-sat",
            "data structures",
            "dfs and similar",
            "dp",
            "*2500"
        ]
    },
    {
        "title": "E. Girl Permutation",
        "description": "Some permutation of length\nn\nis guessed.\nYou are given the indices of its prefix maximums and suffix maximums.\nRecall that a permutation of length\nk\nis an array of size\nk\nsuch that each integer from\n1\nto\nk\noccurs exactly once.\nPrefix maximums are the elements that are the maximum on the prefix ending at that element. More formally, the element\na\ni\nis a prefix maximum if\na\ni\n>\na\nj\nfor every\nj<i\n.\nSimilarly, suffix maximums are defined, the element\na\ni\nis a suffix maximum if\na\ni\n>\na\nj\nfor every\nj>i\n.\nYou need to output the number of different permutations that could have been guessed.\nAs this number can be very large, output the answer modulo\n10\n9\n+7\n.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains three integers\nn,\nm\n1\nand\nm\n2\n(\n1≤\nm\n1\n,\nm\n2\n≤n≤2⋅\n10\n5\n) — the length of the permutation, the number of prefix maximums, and the number of suffix maximums, respectively.\nThe second line of each test case contains\nm\n1\nintegers\np\n1\n<\np\n2\n<…<\np\nm\n1\n(\n1≤\np\ni\n≤n\n) — the indices of the prefix maximums in increasing order.\nThe third line of each test case contains\nm\n2\nintegers\ns\n1\n<\ns\n2\n<…<\ns\nm\n2\n(\n1≤\ns\ni\n≤n\n) — the indices of the suffix maximums in increasing order.\nIt is guaranteed that the sum of the values of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer on a separate line — the number of suitable permutations modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n6\n1 1 1\n1\n1\n4 2 3\n1 2\n2 3 4\n3 3 1\n1 2 3\n3\n5 3 4\n1 2 3\n2 3 4 5\n20 5 4\n1 2 3 4 12\n12 13 18 20\n6 2 3\n1 3\n3 4 6\noutput\nCopy\n1\n3\n1\n0\n317580808\n10\nNote\nThe following permutations are suitable for the second set of input data:\n[1,4,3,2]\n[2,4,3,1]\n[3,4,2,1]\nThe following permutations are suitable for the sixth set of input data:\n[2,1,6,5,3,4]\n[3,1,6,5,2,4]\n[3,2,6,5,1,4]\n[4,1,6,5,2,3]\n[4,2,6,5,1,3]\n[4,3,6,5,1,2]\n[5,1,6,4,2,3]\n[5,2,6,4,1,3]\n[5,3,6,4,1,2]\n[5,4,6,3,1,2]",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "number theory",
            "*2200"
        ]
    },
    {
        "title": "D. Birthday Gift",
        "description": "Yarik's birthday is coming soon, and Mark decided to give him an array\na\nof length\nn\n.\nMark knows that Yarik loves bitwise operations very much, and he also has a favorite number\nx\n, so Mark wants to find the maximum number\nk\nsuch that it is possible to select pairs of numbers [\nl\n1\n,\nr\n1\n], [\nl\n2\n,\nr\n2\n],\n…\n[\nl\nk\n,\nr\nk\n], such that:\nl\n1\n=1\n.\nr\nk\n=n\n.\nl\ni\n≤\nr\ni\nfor all\ni\nfrom\n1\nto\nk\n.\nr\ni\n+1=\nl\ni+1\nfor all\ni\nfrom\n1\nto\nk−1\n.\n(\na\nl\n1\n⊕\na\nl\n1\n+1\n⊕…⊕\na\nr\n1\n)|(\na\nl\n2\n⊕\na\nl\n2\n+1\n⊕…⊕\na\nr\n2\n)|…|(\na\nl\nk\n⊕\na\nl\nk\n+1\n⊕…⊕\na\nr\nk\n)≤x\n, where\n⊕\ndenotes the operation of bitwise XOR, and\n|\ndenotes the operation of bitwise OR.\nIf such\nk\ndoes not exist, then output\n−1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The following lines contain the descriptions of the test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤n≤\n10\n5\n,0≤x<\n2\n30\n) — the length of the array\na\nand the number\nx\nrespectively.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<\n2\n30\n) — the array\na\nitself.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer on a separate line — the maximum suitable number\nk\n, and\n−1\nif such\nk\ndoes not exist.\nExample\ninput\nCopy\n8\n3 1\n1 2 3\n2 2\n1 1\n2 2\n1 3\n2 3\n0 0\n3 2\n0 0 1\n4 2\n1 3 3 7\n2 2\n2 3\n5 0\n0 1 2 2 1\noutput\nCopy\n2\n2\n1\n2\n3\n-1\n1\n2\nNote\nIn the first test case, you can take\nk\nequal to\n2\nand choose two segments [\n1,1\n] and [\n2,3\n],\n(1)|(2⊕3)=1\n. It can be shown that\n2\nis the maximum possible answer.\nIn the second test case, the segments [\n1,1\n] and [\n2,2\n] are suitable,\n(1)|(1)=1\n. It is not possible to make more segments.\nIn the third test case, it is not possible to choose\n2\nsegments, as\n(1)|(3)=3>2\n, so the optimal answer is\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1900"
        ]
    },
    {
        "title": "C. Tree Cutting",
        "description": "You are given a tree with\nn\nvertices.\nYour task is to find the maximum number\nx\nsuch that it is possible to remove exactly\nk\nedges from this tree in such a way that the size of each remaining connected component\n†\n†\nis at least\nx\n.\n†\n†\nTwo vertices\nv\nand\nu\nare in the same connected component if there exists a sequence of numbers\nt\n1\n,\nt\n2\n,…,\nt\nk\nof arbitrary length\nk\n, such that\nt\n1\n=v\n,\nt\nk\n=u\n, and for each\ni\nfrom\n1\nto\nk−1\n, vertices\nt\ni\nand\nt\ni+1\nare connected by an edge.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of sets of input data. This is followed by a description of the sets of input data.\nThe first line of each set of input data contains two integers\nn\nand\nk\n(\n1≤k<n≤\n10\n5\n) — the number of vertices in the tree and the number of edges to be removed.\nEach of the next\nn−1\nlines of each set of input data contains two integers\nv\nand\nu\n(\n1≤v,u≤n\n) — the next edge of the tree.\nIt is guaranteed that the sum of the values of\nn\nfor all sets of input data does not exceed\n10\n5\n.\nOutput\nFor each set of input data, output a single line containing the maximum number\nx\nsuch that it is possible to remove exactly\nk\nedges from the tree in such a way that the size of each remaining connected component is at least\nx\n.\nExample\ninput\nCopy\n6\n5 1\n1 2\n1 3\n3 4\n3 5\n2 1\n1 2\n6 1\n1 2\n2 3\n3 4\n4 5\n5 6\n3 1\n1 2\n1 3\n8 2\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n3 8\n6 2\n1 2\n2 3\n1 4\n4 5\n5 6\noutput\nCopy\n2\n1\n3\n1\n1\n2\nNote\nThe tree in the first set of input data:\nAfter removing the edge\n1\n —\n3\n, the tree will look as follows:\nThe tree has split into two connected components. The first component consists of two vertices:\n1\nand\n2\n. The second connected component consists of three vertices:\n3,4\nand\n5\n. In both connected components, there are at least two vertices. It can be shown that the answer\n3\nis not achievable, so the answer is\n2\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "implementation",
            "trees",
            "*1600"
        ]
    },
    {
        "title": "B. Maximum Sum",
        "description": "You have an array\na\nof\nn\nintegers.\nYou perform exactly\nk\noperations on it. In one operation, you select any contiguous subarray of the array\na\n(possibly empty) and insert the sum of this subarray anywhere in the array.\nYour task is to find the maximum possible sum of the array after\nk\nsuch operations.\nAs this number can be very large, output the answer modulo\n10\n9\n+7\n.\nReminder: the remainder of a number\nx\nmodulo\np\nis the smallest non-negative\ny\nsuch that there exists an integer\nq\nand\nx=p⋅q+y\n.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤2⋅\n10\n5\n) — the length of the array\na\nand the number of operations, respectively.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the array\na\nitself.\nIt is guaranteed that the sum of the values of\nn\nand\nk\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test, output a single integer — the maximum sum of the array that can be obtained after\nk\noperations modulo\n10\n9\n+7\n.\nExample\ninput\nCopy\n12\n2 2\n-4 -7\n3 3\n2 2 8\n1 7\n7\n5 1\n4 -2 8 -12 9\n7 4\n8 14 -9 6 0 -1 3\n7 100\n5 3 -8 12 -5 -9 3\n6 1000\n-1000000000 -1000000000 -1000000000 -1000000000 -1000000000 -1000000000\n2 1\n1000000000 8\n5 4\n0 0 0 0 0\n6 10\n48973 757292 58277 -38574 27475 999984\n7 1\n-1000 1000 -1000 1000 -1000 1000 -1000\n10 10050\n408293874 -3498597 7374783 295774930 -48574034 26623784 498754833 -294875830 283045804 85938045\noutput\nCopy\n999999996\n96\n896\n17\n351\n716455332\n42\n2\n0\n897909241\n0\n416571966\nNote\nIn the first test case, it is advantageous to take an empty subarray of the array twice and insert the sum of the empty subarray (zero) anywhere, then the sum of the resulting array will be\n(−4)+(−7)+0+0=−11\n, modulo\n10\n9\n+7\nthis is\n999999996\n.\nIn the second test case, it is advantageous to take the sum of the entire array three times and place it anywhere in the array, then one of the possible sequences of actions: [\n2,2,8\n]\n→\n[\n2,2,8,12\n]\n→\n[\n2,2,8,12,24\n]\n→\n[\n2,2,8,12,24,48\n], the sum of the final array is\n2+2+8+12+24+48=96\n.\nIn the fourth test case, it is advantageous to take a subarray of the array consisting of the first three numbers (i.e. consisting of the numbers\n4,−2\nand\n8\n) and insert its sum at the beginning of the array, thereby obtaining the array [\n10,4,−2,8,−12,9\n], the sum of this array is\n17\n.\nIn the seventh test case, it will always be advantageous for us to take an empty subarray of the array. In this case, the sum of the resulting array will not differ from the sum of the original. The answer will be the sum of the original array, taken modulo —\n42\n, because\n(−6⋅(\n10\n9\n+7)+42=−6000000000)\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Median of an Array",
        "description": "You are given an array\na\nof\nn\nintegers.\nThe median of an array\nq\n1\n,\nq\n2\n,…,\nq\nk\nis the number\np\n⌈\nk\n2\n⌉\n, where\np\nis the array\nq\nsorted in non-decreasing order. For example, the median of the array\n[9,5,1,2,6]\nis\n5\n, as in the sorted array\n[1,2,5,6,9]\n, the number at index\n⌈\n5\n2\n⌉=3\nis\n5\n, and the median of the array\n[9,2,8,3]\nis\n3\n, as in the sorted array\n[2,3,8,9]\n, the number at index\n⌈\n4\n2\n⌉=2\nis\n3\n.\nYou are allowed to choose an integer\ni\n(\n1≤i≤n\n) and increase\na\ni\nby\n1\nin one operation.\nYour task is to find the minimum number of operations required to increase the median of the array.\nNote that the array\na\nmay not necessarily contain distinct numbers.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the array\na\n.\nIt is guaranteed that the sum of the values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required to increase the median of the array.\nExample\ninput\nCopy\n8\n3\n2 2 8\n4\n7 3 3 1\n1\n1000000000\n5\n5 5 5 4 5\n6\n2 1 2 3 1 4\n2\n1 2\n2\n1 1\n4\n5 5 5 5\noutput\nCopy\n1\n2\n1\n3\n2\n1\n2\n3\nNote\nIn the first test case, you can apply one operation to the first number and obtain the array\n[3,2,8]\n, the median of this array is\n3\n, as it is the number at index\n⌈\n3\n2\n⌉=2\nin the non-decreasing sorted array\n[2,3,8]\n. The median of the original array\n[2,2,8]\nis\n2\n, as it is the number at index\n⌈\n3\n2\n⌉=2\nin the non-decreasing sorted array\n[2,2,8]\n. Thus, the median increased (\n3>2\n) in just one operation.\nIn the fourth test case, you can apply one operation to each of the numbers at indices\n1,2,3\nand obtain the array\n[6,6,6,4,5]\n, the median of this array is\n6\n, as it is the number at index\n⌈\n5\n2\n⌉=3\nin the non-decreasing sorted array\n[4,5,6,6,6]\n. The median of the original array\n[5,5,5,4,5]\nis\n5\n, as it is the number at index\n⌈\n5\n2\n⌉=2\nin the non-decreasing sorted array\n[4,5,5,5,5]\n. Thus, the median increased (\n6>5\n) in three operations. It can be shown that this is the minimum possible number of operations.\nIn the fifth test case, you can apply one operation to each of the numbers at indices\n1,3\nand obtain the array\n[3,1,3,3,1,4]\n, the median of this array is\n3\n, as it is the number at index\n⌈\n6\n2\n⌉=3\nin the non-decreasing sorted array\n[1,1,3,3,3,4]\n. The median of the original array\n[2,1,2,3,1,4]\nis\n2\n, as it is the number at index\n⌈\n6\n2\n⌉=3\nin the non-decreasing sorted array\n[1,1,2,2,3,4]\n. Thus, the median increased (\n3>2\n) in two operations. It can be shown that this is the minimum possible number of operations.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "H. GCD is Greater",
        "description": "In the evenings during the hike, Kirill and Anton decided to take out an array of integers\na\nof length\nn\nfrom their backpack and play a game with it. The rules are as follows:\nKirill chooses from\n2\nto\n(n−2)\nnumbers and encircles them in red.\nAnton encircles all the remaining numbers in blue.\nKirill calculates the greatest common divisor (GCD) of all the red numbers.\nAnton calculates the bitwise AND of all the blue numbers and adds the number\nx\nto the result.\nIf the GCD of all the red numbers is strictly greater than the sum of the bitwise AND of all the blue numbers and the number\nx\n, then Kirill wins; otherwise, Anton wins.\nHelp Kirill to beat Anton or tell if it's impossible.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤20000\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n4≤n≤4⋅\n10\n5\n,\n0≤x≤4⋅\n10\n5\n) — the number of integers and the number\nx\nrespectively.\nThe second line contains an array\na\nof length\nn\n(\n1≤\na\ni\n≤4⋅\n10\n5\n).\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n4⋅\n10\n5\n. It is also guaranteed that the sum of the maximum values of\na\ni\nfor each test case does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" on the first line if the condition can be met, on the second line, output the number of chosen numbers by Kirill and the numbers themselves in any order separated by a space, and on the third line, output the size of the second set and the numbers in it.\nOtherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n8\n4 1\n4 3 1 8\n4 1\n4 5 8 4\n5 0\n1 1 1 1 1\n5 2\n31 63 127 63 31\n4 1\n1 3 3 3\n8 3\n4 3 4 1 2 2 5 3\n4 2\n1 4 3 6\n8 48\n31 61 37 15 53 26 61 12\noutput\nCopy\nYES\n2 4 8\n2 3 1 \nYES\n2 4 4\n2 5 8 \nNO\nYES\n2 63 63\n3 31 127 31\nYES\n2 3 3\n2 1 3\nYES\n2 4 4\n6 3 1 2 2 5 3\nYES\n2 3 6\n2 1 4 \nYES\n2 61 61\n6 31 37 15 53 26 12",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "math",
            "number theory",
            "*2600"
        ]
    },
    {
        "title": "G. Cook and Porridge",
        "description": "Finally, lunchtime!\nn\nschoolchildren have lined up in a long queue at the cook's tent for porridge. The cook will be serving porridge for\nD\nminutes. The schoolchild standing in the\ni\n-th position in the queue has a priority of\nk\ni\nand eats one portion of porridge in\ns\ni\nminutes.\nAt the beginning of each minute of the break, the cook serves the first schoolchild in the queue one portion of porridge, after which the schoolchild goes to eat their portion. If the\ni\n-th schoolchild is served a portion at the beginning of the\nx\n-th minute, then they will return to the queue at the end of the\n(x+\ns\ni\n)\n-th minute.\nWhen the\ni\n-th schoolchild returns to the queue, the schoolchildren at the end of the queue whose priority is strictly lower than that of the\ni\n-th schoolchild must let them pass. Thus, they will stand in the queue behind the last schoolchild whose priority is not lower than their own. That is, behind the last schoolchild\nj\nwith\nk\nj\n≥\nk\ni\n. If there is no such schoolchild in the queue, the\ni\n-th schoolchild will stand at the front of the queue.\nIf several schoolchildren return at the same time, they will return to the queue in ascending order of their\ns\ni\n.\nFor example, if\nn=3\n,\nD=3\n,\nk=[2,3,2]\n, and\ns=[2,1,3]\n, the serving will occur as follows:\nAt the beginning of minute\n1\n, the students in the queue are\n[1,2,3]\n, and student\n1\nis served porridge;\nat the beginning of minute\n2\n, the students in the queue are\n[2,3]\n, and student\n2\nis served porridge;\nat the beginning of minute\n3\n, the student in the queue is\n[3]\n, and student\n3\nis served porridge;\nat the end of minute\n3\n, student\n2\nreturns to the queue, and the queue becomes\n[2]\n;\nat the end of minute\n3\n, student\n1\nreturns to the queue, and the queue becomes\n[2,1]\n, as his priority is lower.\nDetermine the minimum number of minutes after the start of the break that each schoolchild will receive porridge at least once, or report that this will not happen within\nD\nminutes.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nD\n(\n1≤n≤2⋅\n10\n5\n,\n1≤D≤3⋅\n10\n5\n) — the number of schoolchildren in the queue and the break time, respectively.\nThe next\nn\nlines contain two integers\nk\ni\nand\ns\ni\n(\n1≤\nk\ni\n,\ns\ni\n,≤\n10\n9\n) — the priority and the time to eat one portion of porridge for the respective schoolchild. The schoolchildren are given in the order they stand in the queue (from the front to the end).\nIt is guaranteed that the sum of the values of\nn\nfor all input data sets does not exceed\n2⋅\n10\n5\n. Similarly, it is guaranteed that the sum of the values of\nD\nfor all input data sets does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum number of minutes after which each schoolchild will receive porridge at least once. If this does not happen within the break time, output\n−1\n.\nExample\ninput\nCopy\n7\n3 3\n2 2\n3 1\n2 3\n5 10\n10 3\n7 1\n11 3\n5 1\n6 1\n5 20\n4 2\n7 2\n8 5\n1 5\n3 1\n5 17\n1 3\n8 2\n8 3\n2 2\n1 1\n5 14\n8 2\n4 2\n1 3\n8 3\n6 4\n1 11\n4 5\n5 14\n8 2\n4 2\n1 3\n8 3\n6 4\noutput\nCopy\n3\n-1\n12\n6\n6\n1\n6",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "implementation",
            "*2500"
        ]
    },
    {
        "title": "F. Kirill and Mushrooms",
        "description": "As soon as everyone in the camp fell asleep, Kirill sneaked out of the tent and went to the Wise Oak to gather mushrooms.\nIt is known that there are\nn\nmushrooms growing under the Oak, each of which has magic power\nv\ni\n. Kirill really wants to make a magical elixir of maximum strength from the mushrooms.\nThe strength of the elixir is equal to the product of the number of mushrooms in it and the minimum magic power among these mushrooms. To prepare the elixir, Kirill will sequentially pick one mushroom growing under the Oak. Kirill can gather mushrooms in any order.\nHowever, it's not that simple. The Wise Oak informed Kirill of a permutation of numbers\np\nfrom\n1\nto\nn\n. If Kirill picks only\nk\nmushrooms, then the magic power of all mushrooms with indices\np\n1\n,\np\n2\n,…,\np\nk−1\nwill become\n0\n. Kirill will not use mushrooms with zero magic power to prepare the elixir.\nYour task is to help Kirill gather mushrooms in such a way that he can brew the elixir of maximum possible strength. However, Kirill is a little scared to stay near the oak for too long, so out of all the suitable options for gathering mushrooms, he asks you to find the one with the minimum number of mushrooms.\nA permutation of length\nn\nis an array consisting of\nn\ndifferent integers from\n1\nto\nn\nin any order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears in the array twice) and\n[1,3,4]\nis also not a permutation (\nn=3\n, but\n4\nappears in the array).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤200000\n) — the number of mushrooms.\nThe second line contains an array\nv\nof size\nn\n(\n1≤\nv\ni\n≤\n10\n9\n) — the magic powers of the mushrooms.\nThe third line contains a permutation\np\nof numbers from\n1\nto\nn\n.\nIt is guaranteed that the sum of the values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two integers separated by a space — the maximum strength of the elixir that can be brewed and the minimum number of mushrooms that Kirill needs to use for this.\nExample\ninput\nCopy\n6\n3\n9 8 14\n3 2 1\n5\n1 2 3 4 5\n1 2 3 4 5\n6\n1 2 3 4 5 6\n6 5 4 3 2 1\n5\n1 4 6 10 10\n2 1 4 5 3\n4\n2 2 5 5\n4 2 3 1\n5\n1 2 9 10 10\n1 4 2 3 5\noutput\nCopy\n16 2\n9 3\n8 2\n20 2\n5 1\n20 2\nNote\nIn the first example, you need to take the mushrooms with indices\n1\nand\n2\n, so the strength of the elixir is equal to\n2⋅min(\na\n1\n,\na\n2\n)=2⋅min(9,8)=2⋅8=16\n. Note that the magic power of the mushroom with index\n3\nafter picking two mushrooms will become\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "E. Binary Search",
        "description": "Anton got bored during the hike and wanted to solve something. He asked Kirill if he had any new problems, and of course, Kirill had one.\nYou are given a permutation\np\nof size\nn\n, and a number\nx\nthat needs to be found. A permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nYou decided that you are a cool programmer, so you will use an advanced algorithm for the search — binary search. However, you forgot that for binary search, the array must be sorted.\nYou did not give up and decided to apply this algorithm anyway, and in order to get the correct answer, you can perform the following operation no more than\n2\ntimes before running the algorithm: choose the indices\ni\n,\nj\n(\n1≤i,j≤n\n) and swap the elements at positions\ni\nand\nj\n.\nAfter that, the binary search is performed. At the beginning of the algorithm, two variables\nl=1\nand\nr=n+1\nare declared. Then the following loop is executed:\nIf\nr−l=1\n, end the loop\nm=⌊\nr+l\n2\n⌋\nIf\np\nm\n≤x\n, assign\nl=m\n, otherwise\nr=m\n.\nThe goal is to rearrange the numbers in the permutation before the algorithm so that after the algorithm is executed,\np\nl\nis equal to\nx\n. It can be shown that\n2\noperations are always sufficient.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains two integers\nn\nand\nx\n(\n1≤x≤n≤2⋅\n10\n5\n) — the length of the permutation and the number to be found.\nThe second line contains the permutation\np\nseparated by spaces (\n1≤\np\ni\n≤n\n).\nIt is guaranteed that the sum of the values of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output an integer\nk\n(\n0≤k≤2\n) on the first line — the number of operations performed by you. In the next\nk\nlines, output\n2\nintegers\ni\n,\nj\n(\n1≤i,j≤n\n) separated by a space, indicating that you are swapping the elements at positions\ni\nand\nj\n.\nNote that you do not need to minimize the number of operations.\nExample\ninput\nCopy\n5\n6 3\n1 2 3 4 5 6\n6 5\n3 1 6 5 2 4\n5 1\n3 5 4 2 1\n6 3\n4 3 1 5 2 6\n3 2\n3 2 1\noutput\nCopy\n0\n1\n3 4\n2\n2 4\n1 5\n2\n4 5\n2 4\n1\n1 3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "greedy",
            "*1700"
        ]
    },
    {
        "title": "D. Seraphim the Owl",
        "description": "The guys lined up in a queue of\nn\npeople, starting with person number\ni=1\n, to ask Serafim the Owl about the meaning of life. Unfortunately, Kirill was very busy writing the legend for this problem, so he arrived a little later and stood at the end of the line after the\nn\n-th person. Kirill is completely dissatisfied with this situation, so he decided to bribe some people ahead of him.\nFor the\ni\n-th person in the queue, Kirill knows two values:\na\ni\nand\nb\ni\n. If at the moment Kirill is standing at position\ni\n, then he can choose any position\nj\nsuch that\nj<i\nand exchange places with the person at position\nj\n. In this case, Kirill will have to pay him\na\nj\ncoins. And for each\nk\nsuch that\nj<k<i\n, Kirill will have to pay\nb\nk\ncoins to the person at position\nk\n. Kirill can perform this action any number of times.\nKirill is thrifty, so he wants to spend as few coins as possible, but he doesn't want to wait too long, so Kirill believes he should be among the first\nm\npeople in line.\nHelp Kirill determine the minimum number of coins he will have to spend in order to not wait too long.\nInput\nEach test consists of several sets of input data. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test case.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤m≤n≤200000\n) — the number of people in the queue besides Kirill and the maximum allowable final position of Kirill, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\nseparated by spaces (\n1≤\na\ni\n≤\n10\n9\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\nseparated by spaces (\n1≤\nb\ni\n≤\n10\n9\n).\nIt is guaranteed that the sum of the values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of coins Kirill needs to spend.\nExample\ninput\nCopy\n4\n4 2\n7 3 6 9\n4 3 8 5\n6 2\n6 9 7 1 8 3\n5 8 8 1 4 1\n7 7\n7 2 9 2 6 5 9\n9 1 10 7 1 4 9\n2 1\n2 3\n1 1\noutput\nCopy\n14\n22\n9\n3",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "C. Left and Right Houses",
        "description": "In the village of Letovo, there are\nn\nhouses. The villagers decided to build a big road that will divide the village into left and right sides. Each resident wants to live on either the right or the left side of the street, which is described as a sequence\na\n1\n,\na\n2\n,…,\na\nn\n, where\na\nj\n=0\nif the resident of the\nj\n-th house wants to live on the left side of the street; otherwise,\na\nj\n=1\n.\nThe road will pass between two houses. The houses to the left of it will be declared the left-side, and the houses to the right will be declared the right-side. More formally, let the road pass between houses\ni\nand\ni+1\n. Then the houses at positions between\n1\nand\ni\nwill be on the left side of the street, and at positions between\ni+1\nand\nn\nwill be on the right side. The road also may pass before the first and after the last house; in this case, the entire village is declared to be either the right or left side, respectively.\nTo make the design fair, it was decided to lay the road so that at least half of the residents on each side of the village are satisfied with the choice. That is, among\nx\nresidents on one side, at least\n⌈\nx\n2\n⌉\nshould want to live on that side, where\n⌈x⌉\ndenotes rounding up a real number\nx\n.\nTo the left of the road, there will be\ni\nhouses, among the corresponding\na\nj\nthere must be at least\n⌈\ni\n2\n⌉\nzeros. To the right of the road, there will be\nn−i\nhouses, among the corresponding\na\nj\nthere must be at least\n⌈\nn−i\n2\n⌉\nones.\nDetermine after which house\ni\nthe road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible. Formally, among all suitable positions\ni\n, minimize\n∣\n∣\nn\n2\n−i\n∣\n∣\n|\n.\nIf there are multiple suitable positions\ni\nwith the minimum\n∣\n∣\nn\n2\n−i\n∣\n∣\n|\n, output the smaller one.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤3⋅\n10\n5\n). The next line of each test case contains a string\na\nof length\nn\n, consisting only of\n0\nand\n1\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single number\ni\n — the position of the house after which the road should be laid (if it should be laid before the first house, output\n0\n). We can show that the answer always exists.\nExample\ninput\nCopy\n7\n3\n101\n6\n010111\n6\n011001\n3\n000\n3\n110\n3\n001\n4\n1100\noutput\nCopy\n2\n3\n2\n3\n0\n1\n0\nNote\nLet's consider the first example of input data.\nIf we lay the road after the first house, there will be one house\na\n1\n=1\non the left side of the street, the resident of which would like to live on the right side of the street. Then\n0\nout of\n1\nresidents on the even side will be satisfied with the choice, which means that the road cannot be laid after house\n1\n.\nIf we lay the road after the second house,\n1\nout of\n2\nresidents on the left side (with preferences\na\n1\n=1\n,\na\n2\n=0\n) and\n1\nout of\n1\nresident on the right side (with preference\na\n3\n=1\n) will be satisfied with the choice. More than half of the residents on each side are satisfied with the choice, which means that the road can be laid after house\n2\n. We can show that this is the optimal answer.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "*1200"
        ]
    },
    {
        "title": "B. Fireworks",
        "description": "One of the days of the hike coincided with a holiday, so in the evening at the camp, it was decided to arrange a festive fireworks display. For this purpose, the organizers of the hike bought two installations for launching fireworks and a huge number of shells for launching.\nBoth installations are turned on simultaneously. The first installation launches fireworks every\na\nminutes (i.e., after\na,2⋅a,3⋅a,…\nminutes after launch). The second installation launches fireworks every\nb\nminutes (i.e., after\nb,2⋅b,3⋅b,…\nminutes after launch).\nEach firework is visible in the sky for\nm+1\nminutes after launch, i.e., if a firework was launched after\nx\nminutes after the installations were turned on, it will be visible every minute from\nx\nto\nx+m\n, inclusive. If one firework was launched\nm\nminutes after another, both fireworks will be visible for one minute.\nWhat is the maximum number of fireworks that could be seen in the sky at the same time?\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first and only line of each test case contains integers\na\n,\nb\n,\nm\n(\n1≤a,b,m≤\n10\n18\n) — the frequency of launching for the first installation, the second installation, and the time the firework is visible in the sky.\nOutput\nFor each set of input data, output a single number — the maximum number of fireworks that can be seen simultaneously.\nExample\ninput\nCopy\n6\n6 7 4\n3 4 10\n7 8 56\n5 6 78123459896\n1 1 1\n1 1 1000000000000000000\noutput\nCopy\n2\n7\n17\n28645268630\n4\n2000000000000000002\nNote\nIn the first set of input data, the fireworks are visible in the sky for\n5\nminutes. Since the first installation launches fireworks every\n6\nminutes, and the second one every\n7\nminutes, two fireworks launched from the same installation will not be visible in the sky at the same time. At the same time, after\n7\nminutes from the start of the holiday, one firework from the first and one from the second camp will be visible. Thus, it is possible to see no more than\n2\nfireworks simultaneously.\nIn the third set of input data,\n17\nfireworks will be visible after\n112\nminutes:\n9\nfireworks launched from the first installation at times [\n56,63,70,77,84,91,98,105,112\n];\n8\nfireworks launched from the second installation at times [\n56,64,72,80,88,96,104,112\n].",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*900"
        ]
    },
    {
        "title": "A. Setting up Camp",
        "description": "The organizing committee plans to take the participants of the Olympiad on a hike after the tour. Currently, the number of tents needed to be taken is being calculated. It is known that each tent can accommodate up to\n3\npeople.\nAmong the participants, there are\na\nintroverts,\nb\nextroverts, and\nc\nuniversals:\nEach introvert wants to live in a tent alone. Thus, a tent with an introvert must contain exactly one person — only the introvert himself.\nEach extrovert wants to live in a tent with two others. Thus, the tent with an extrovert must contain exactly three people.\nEach universal is fine with any option (living alone, with one other person, or with two others).\nThe organizing committee respects the wishes of each participant very much, so they want to fulfill all of them.\nTell us the minimum number of tents needed to be taken so that all participants can be accommodated according to their preferences. If it is impossible to accommodate the participants in a way that fulfills all the wishes, output\n−1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by the descriptions of the test cases.\nEach test case is described by a single line containing three integers\na\n,\nb\n,\nc\n(\n0≤a,b,c≤\n10\n9\n) — the number of introverts, extroverts, and universals, respectively.\nOutput\nFor each test case, output a single integer — the minimum number of tents, or\n−1\nif it is impossible to accommodate the participants.\nExample\ninput\nCopy\n10\n1 2 3\n1 4 1\n1 4 2\n1 1 1\n1 3 2\n19 7 18\n0 0 0\n7 0 0\n0 24 0\n1000000000 1000000000 1000000000\noutput\nCopy\n3\n-1\n3\n-1\n3\n28\n0\n7\n8\n1666666667\nNote\nIn the first test case,\n1\ntent will be given to the introverts,\n1\ntent will be shared by two extroverts and one universal, and the last tent will be shared by two universals. In total,\n3\ntents are needed.\nIn the second test case, three extroverts will take\n1\ntent, and\n1\ntent will be taken by an introvert. Then, one extrovert and one universal will be left. This extrovert will not be able to live with two others.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "B. Equal XOR",
        "description": "You are given an array\na\nof length\n2n\n, consisting of each integer from\n1\nto\nn\nexactly twice.\nYou are also given an integer\nk\n(\n1≤k≤⌊\nn\n2\n⌋\n).\nYou need to find two arrays\nl\nand\nr\neach of length\n2k\nsuch that:\nl\nis a subset\n†\n†\nof\n[\na\n1\n,\na\n2\n,…\na\nn\n]\nr\nis a subset of\n[\na\nn+1\n,\na\nn+2\n,…\na\n2n\n]\nbitwise XOR of elements of\nl\nis equal to the bitwise XOR of elements of\nr\n; in other words,\nl\n1\n⊕\nl\n2\n⊕…⊕\nl\n2k\n=\nr\n1\n⊕\nr\n2\n⊕…⊕\nr\n2k\nIt can be proved that at least one pair of\nl\nand\nr\nalways exists. If there are multiple solutions, you may output any one of them.\n†\n†\nA sequence\nx\nis a subset of a sequence\ny\nif\nx\ncan be obtained by deleting several (possibly none or all) elements of\ny\nand rearranging the elements in any order. For example,\n[3,1,2,1]\n,\n[1,2,3]\n,\n[1,1]\nand\n[3,2]\nare subsets of\n[1,1,2,3]\nbut\n[4]\nand\n[2,2]\nare not subsets of\n[1,1,2,3]\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains\n2\nintegers\nn\nand\nk\n(\n2≤n≤5⋅\n10\n4\n,\n1≤k≤⌊\nn\n2\n⌋\n).\nThe second line contains\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n1≤\na\ni\n≤n\n). It is guaranteed that every integer from\n1\nto\nn\noccurs exactly twice in\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n4\n.\nOutput\nFor each test case, output two lines.\nOn the first line of output, output\n2k\nintegers\nl\n1\n,\nl\n2\n,…,\nl\n2k\n.\nOn the second line of output, output\n2k\nintegers\nr\n1\n,\nr\n2\n,…\nr\n2k\n.\nIf there are multiple solutions, you may output any one of them.\nExample\ninput\nCopy\n4\n2 1\n1 2 2 1\n6 1\n6 4 2 1 2 3 1 6 3 5 5 4\n4 1\n1 2 3 4 1 2 3 4\n6 2\n5 1 3 3 5 1 2 6 4 6 4 2\noutput\nCopy\n2 1\n2 1\n6 4\n1 3\n1 2\n1 2\n5 1 3 3\n6 4 2 4\nNote\nIn the first test case, we choose\nl=[2,1]\nand\nr=[2,1]\n.\n[2,1]\nis a subset of\n[\na\n1\n,\na\n2\n]\nand\n[2,1]\nis a subset of\n[\na\n3\n,\na\n4\n]\n, and\n2⊕1=2⊕1=3\n.\nIn the second test case,\n6⊕4=1⊕3=2\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "*1100"
        ]
    },
    {
        "title": "A. Destroying Bridges",
        "description": "There are\nn\nislands, numbered\n1,2,…,n\n. Initially, every pair of islands is connected by a bridge. Hence, there are a total of\nn(n−1)\n2\nbridges.\nEverule lives on island\n1\nand enjoys visiting the other islands using bridges. Dominater has the power to destroy at most\nk\nbridges to minimize the number of islands that Everule can reach using (possibly multiple) bridges.\nFind the minimum number of islands (including island\n1\n) that Everule can visit if Dominater destroys bridges optimally.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤100\n,\n0≤k≤\nn⋅(n−1)\n2\n).\nOutput\nFor each test case, output the minimum number of islands that Everule can visit if Dominater destroys bridges optimally.\nExample\ninput\nCopy\n6\n2 0\n2 1\n4 1\n5 10\n5 3\n4 4\noutput\nCopy\n2\n1\n4\n1\n5\n1\nNote\nIn the first test case, since no bridges can be destroyed, all the islands will be reachable.\nIn the second test case, you can destroy the bridge between islands\n1\nand\n2\n. Everule will not be able to visit island\n2\nbut can still visit island\n1\n. Therefore, the total number of islands that Everule can visit is\n1\n.\nIn the third test case, Everule always has a way of reaching all islands despite what Dominater does. For example, if Dominater destroyed the bridge between islands\n1\nand\n2\n, Everule can still visit island\n2\nby traveling by\n1→3→2\nas the bridges between\n1\nand\n3\n, and between\n3\nand\n2\nare not destroyed.\nIn the fourth test case, you can destroy all bridges since\nk=\nn⋅(n−1)\n2\n. Everule will be only able to visit\n1\nisland (island\n1\n).",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "graphs",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Minimum Hamming Distance",
        "description": "You are given a binary string\n†\n†\ns\nof length\nn\n.\nA binary string\np\nof the same length\nn\nis called good if for every\ni\n(\n1≤i≤n\n), there exist indices\nl\nand\nr\nsuch that:\n1≤l≤i≤r≤n\ns\ni\nis a mode\n‡\n‡\nof the string\np\nl\np\nl+1\n…\np\nr\nYou are given another binary string\nt\nof length\nn\n. Find the minimum Hamming distance\n§\n§\nbetween\nt\nand any good string\ng\n.\n†\n†\nA binary string is a string that only consists of characters\n0\nand\n1\n.\n‡\n‡\nCharacter\nc\nis a mode of string\np\nof length\nm\nif the number of occurrences of\nc\nin\np\nis at least\n⌈\nm\n2\n⌉\n. For example,\n0\nis a mode of\n010\n,\n1\nis not a mode of\n010\n, and both\n0\nand\n1\nare modes of\n011010\n.\n§\n§\nThe Hamming distance of strings\na\nand\nb\nof length\nm\nis the number of indices\ni\nsuch that\n1≤i≤m\nand\na\ni\n≠\nb\ni\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n4\n) — the length of the binary string\ns\n.\nThe second line of each test case contains a binary string\ns\nof length\nn\nconsisting of characters 0 and 1.\nThe third line of each test case contains a binary string\nt\nof length\nn\nconsisting of characters 0 and 1.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n, with the additional assurance that the sum of\nn\n2\nover all test cases does not exceed\n10\n8\nOutput\nFor each test case, print the minimum Hamming distance between\nt\nand any good string\ng\n.\nExample\ninput\nCopy\n3\n3\n000\n000\n4\n0000\n1111\n6\n111111\n000100\noutput\nCopy\n0\n2\n1\nNote\nIn the first test case,\ng=000\nis a good string which has Hamming distance\n0\nfrom\nt\n.\nIn the second test case,\ng=0011\nis a good string which has Hamming distance\n2\nfrom\nt\n. It can be proven that there are no good strings with Hamming distance less than\n2\nfrom\nt\n.\nIn the third test case,\ng=001100\nis a good string which has Hamming distance\n1\nfrom\nt\n.",
        "time_limit": "4 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "dp",
            "*3500"
        ]
    },
    {
        "title": "E2. MEX Game 2 (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is the constraint on\nt\n,\nm\nand the sum of\nm\n. You can make hacks only if both versions of the problem are solved.\nAlice and Bob play yet another game on an array\na\nof size\nn\n. Alice starts with an empty array\nc\n. Both players take turns playing, with Alice starting first.\nOn Alice's turn, she picks one element from\na\n, appends that element to\nc\n, and then deletes it from\na\n.\nOn Bob's turn, he picks at most\nk\nelements from\na\n, and then deletes it from\na\n.\nThe game ends when the array\na\nis empty. Alice's score is defined to be the MEX\n†\n†\nof\nc\n. Alice wants to maximize her score while Bob wants to minimize it. Find Alice's final score if both players play optimally.\nThe array will be given in compressed format. Instead of giving the elements present in the array, we will be giving their frequencies. Formally, you will be given\nm\n, the maximum element in the array, and then\nm+1\nintegers\nf\n0\n,\nf\n1\n,…,\nf\nm\n, where\nf\ni\nrepresents the number of times\ni\noccurs in the array\na\n.\n†\n†\nThe\nMEX\n(minimum excludant) of an array of integers is defined as the smallest non-negative integer which does not occur in the array. For example:\nThe MEX of\n[2,2,1]\nis\n0\n, because\n0\ndoes not belong to the array.\nThe MEX of\n[3,1,0,1]\nis\n2\n, because\n0\nand\n1\nbelong to the array, but\n2\ndoes not.\nThe MEX of\n[0,3,1,2]\nis\n4\n, because\n0\n,\n1\n,\n2\nand\n3\nbelong to the array, but\n4\ndoes not.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nm\nand\nk\n(\n1≤m≤2⋅\n10\n5\n,1≤k≤\n10\n9\n).\nThe second line contains\nm+1\nintegers\nf\n0\n,\nf\n1\n,…,\nf\nm\n(\n1≤\nf\ni\n≤\n10\n9\n).\nIt is guaranteed the sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, find Alice's score if both players play optimally.\nExample\ninput\nCopy\n5\n1 4\n4 5\n2 1000000000\n1000000000 1000000000 1000000000\n3 2\n2 3 100 1\n1 1\n2 2\n3 1\n1 1 1 1\noutput\nCopy\n2\n1\n3\n2\n1\nNote\nIn the first test case, the array\na\nis\n[0,0,0,0,1,1,1,1,1]\n. A possible game with a score of\n2\nis as follows:\nAlice chooses the element\n0\n. After this move,\na=[0,0,0,1,1,1,1,1]\nand\nc=[0]\n.\nBob chooses to remove the\n3\nelements\n0\n,\n0\nand\n1\n. After this move,\na=[0,1,1,1,1]\nand\nc=[0]\n.\nAlice chooses the element\n1\n. After this move,\na=[0,1,1,1]\nand\nc=[0,1]\n.\nBob removes the\n4\nremaining elements\n0\n,\n1\n,\n1\nand\n1\n. After this move,\na=[]\nand\nc=[0,1]\n.\nAt the end,\nc=[0,1]\nwhich has a MEX of\n2\n. Note that this is an example game and does not necessarily represent the optimal strategy for both players.\nIn the second test case, Alice can choose a\n0\nin her first turn, guaranteeing that her score is at least\n1\n. While Bob can remove all copies element\n1\nin his first turn, thus guaranteeing that Alice's score cannot exceed\n1\n. So Alice's score is\n1\nif both players play optimally.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "two pointers",
            "*3300"
        ]
    },
    {
        "title": "E1. MEX Game 2 (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is the constraint on\nt\n,\nm\nand the sum of\nm\n. You can make hacks only if both versions of the problem are solved.\nAlice and Bob play yet another game on an array\na\nof size\nn\n. Alice starts with an empty array\nc\n. Both players take turns playing, with Alice starting first.\nOn Alice's turn, she picks one element from\na\n, appends that element to\nc\n, and then deletes it from\na\n.\nOn Bob's turn, he picks at most\nk\nelements from\na\n, and then deletes it from\na\n.\nThe game ends when the array\na\nis empty. Alice's score is defined to be the MEX\n†\n†\nof\nc\n. Alice wants to maximize her score while Bob wants to minimize it. Find Alice's final score if both players play optimally.\nThe array will be given in compressed format. Instead of giving the elements present in the array, we will be giving their frequencies. Formally, you will be given\nm\n, the maximum element in the array, and then\nm+1\nintegers\nf\n0\n,\nf\n1\n,…,\nf\nm\n, where\nf\ni\nrepresents the number of times\ni\noccurs in the array\na\n.\n†\n†\nThe\nMEX\n(minimum excludant) of an array of integers is defined as the smallest non-negative integer which does not occur in the array. For example:\nThe MEX of\n[2,2,1]\nis\n0\n, because\n0\ndoes not belong to the array.\nThe MEX of\n[3,1,0,1]\nis\n2\n, because\n0\nand\n1\nbelong to the array, but\n2\ndoes not.\nThe MEX of\n[0,3,1,2]\nis\n4\n, because\n0\n,\n1\n,\n2\nand\n3\nbelong to the array, but\n4\ndoes not.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nm\nand\nk\n(\n1≤m≤50,1≤k≤\n10\n9\n).\nThe second line contains\nm+1\nintegers\nf\n0\n,\nf\n1\n,…,\nf\nm\n(\n1≤\nf\ni\n≤\n10\n9\n).\nIt is guaranteed the sum of\nm\nover all test cases does not exceed\n1000\n.\nOutput\nFor each test case, find Alice's score if both players play optimally.\nExample\ninput\nCopy\n5\n1 4\n4 5\n2 1000000000\n1000000000 1000000000 1000000000\n3 2\n2 3 100 1\n1 1\n2 2\n3 1\n1 1 1 1\noutput\nCopy\n2\n1\n3\n2\n1\nNote\nIn the first test case, the array\na\nis\n[0,0,0,0,1,1,1,1,1]\n. A possible game with a score of\n2\nis as follows:\nAlice chooses the element\n0\n. After this move,\na=[0,0,0,1,1,1,1,1]\nand\nc=[0]\n.\nBob chooses to remove the\n3\nelements\n0\n,\n0\nand\n1\n. After this move,\na=[0,1,1,1,1]\nand\nc=[0]\n.\nAlice chooses the element\n1\n. After this move,\na=[0,1,1,1]\nand\nc=[0,1]\n.\nBob removes the\n4\nremaining elements\n0\n,\n1\n,\n1\nand\n1\n. After this move,\na=[]\nand\nc=[0,1]\n.\nAt the end,\nc=[0,1]\nwhich has a MEX of\n2\n. Note that this is an example game and does not necessarily represent the optimal strategy for both players.\nIn the second test case, Alice can choose a\n0\nin her first turn, guaranteeing that her score is at least\n1\n. While Bob can remove all copies of element\n1\nin his first turn, thus guaranteeing that Alice's score cannot exceed\n1\n. So Alice's score is\n1\nif both players play optimally.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*2900"
        ]
    },
    {
        "title": "D2. Counting Is Fun (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is the constraint on\nn\n. You can make hacks only if both versions of the problem are solved.\nAn array\nb\nof\nm\nnon-negative integers is said to be good if all the elements of\nb\ncan be made equal to\n0\nusing the following operation some (possibly, zero) times:\nSelect two distinct indices\nl\nand\nr\n(\n1≤l<r≤m\n) and subtract\n1\nfrom all\nb\ni\nsuch that\nl≤i≤r\n.\nYou are given two positive integers\nn\n,\nk\nand a prime number\np\n.\nOver all\n(k+1\n)\nn\narrays of length\nn\nsuch that\n0≤\na\ni\n≤k\nfor all\n1≤i≤n\n, count the number of good arrays.\nSince the number might be too large, you are only required to find it modulo\np\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three positive integers\nn\n,\nk\nand\np\n(\n3≤n≤3000\n,\n1≤k≤n\n,\n10\n8\n<p<\n10\n9\n) — the length of the array\na\n, the upper bound on the elements of\na\nand modulus\np\n.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n10\n7\n, and\np\nis prime.\nOutput\nFor each test case, on a new line, output the number of good arrays modulo\np\n.\nExample\ninput\nCopy\n4\n3 1 998244853\n4 1 998244353\n3 2 998244353\n343 343 998244353\noutput\nCopy\n4\n7\n10\n456615865\nNote\nIn the first test case, the\n4\ngood arrays\na\nare:\n[0,0,0]\n;\n[0,1,1]\n;\n[1,1,0]\n;\n[1,1,1]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "*2800"
        ]
    },
    {
        "title": "D1. Counting Is Fun (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is the constraint on\nn\n. You can make hacks only if both versions of the problem are solved.\nAn array\nb\nof\nm\nnon-negative integers is said to be good if all the elements of\nb\ncan be made equal to\n0\nusing the following operation some (possibly, zero) times:\nSelect two distinct indices\nl\nand\nr\n(\n1≤l<r≤m\n) and subtract\n1\nfrom all\nb\ni\nsuch that\nl≤i≤r\n.\nYou are given two positive integers\nn\n,\nk\nand a prime number\np\n.\nOver all\n(k+1\n)\nn\narrays of length\nn\nsuch that\n0≤\na\ni\n≤k\nfor all\n1≤i≤n\n, count the number of good arrays.\nSince the number might be too large, you are only required to find it modulo\np\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three positive integers\nn\n,\nk\nand\np\n(\n3≤n≤400\n,\n1≤k≤n\n,\n10\n8\n<p<\n10\n9\n) — the length of the array\na\n, the upper bound on the elements of\na\nand modulus\np\n.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n2⋅\n10\n5\n, and\np\nis prime.\nOutput\nFor each test case, on a new line, output the number of good arrays modulo\np\n.\nExample\ninput\nCopy\n4\n3 1 998244853\n4 1 998244353\n3 2 998244353\n343 343 998244353\noutput\nCopy\n4\n7\n10\n456615865\nNote\nIn the first test case, the\n4\ngood arrays\na\nare:\n[0,0,0]\n;\n[0,1,1]\n;\n[1,1,0]\n;\n[1,1,1]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "math",
            "*2400"
        ]
    },
    {
        "title": "C. Tree Compass",
        "description": "You are given a tree with\nn\nvertices numbered\n1,2,…,n\n. Initially, all vertices are colored white.\nYou can perform the following two-step operation:\nChoose a vertex\nv\n(\n1≤v≤n\n) and a distance\nd\n(\n0≤d≤n−1\n).\nFor all vertices\nu\n(\n1≤u≤n\n) such that\ndist\n†\n(u,v)=d\n, color\nu\nblack.\nConstruct a sequence of operations to color all the nodes in the tree black using the minimum possible number of operations. It can be proven that it is always possible to do so using at most\nn\noperations.\n†\n†\ndist(x,y)\ndenotes the number of edges on the (unique) simple path between vertices\nx\nand\ny\non the tree.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n3\n) — the number of vertices of the tree.\nThe following\nn−1\nlines of each test case describe the edges of the tree. The\ni\n-th of these lines contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n), the indices of the vertices connected by the\ni\n-th edge.\nIt is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n3\n.\nOutput\nFor each test case, first output a single integer\nop\n (1≤op≤n)\n, the minimum number of operations needed to color all vertices of the tree black.\nThen, output\nop\nlines, each containing\n2\nintegers. The\ni\n-th line should contain the values of\nv\nand\nd\nchosen for the\ni\n-th operation (\n1≤v≤n\n,\n0≤d≤n−1\n)\nYou must guarantee that at the end of\nop\noperations, all vertices are colored black.\nIf there are multiple solutions, you may output any one of them.\nExample\ninput\nCopy\n4\n1\n2\n1 2\n4\n1 2\n1 3\n1 4\n7\n2 7\n3 2\n6 4\n5 7\n1 6\n6 7\noutput\nCopy\n1\n1 0\n2\n1 1\n2 1\n2\n1 1\n2 1\n3\n6 1\n7 1\n2 1\nNote\nIn the first test case, there is only one possible operation, and performing it gives us a valid answer.\nIn the second test case, the first operation colors vertex\n2\nblack, and the second operation colors vertex\n1\nblack. It can be shown that it is impossible to color both vertices black in one operation, so the minimum number of operations needed is\n2\n. Another possible solution is to use the\n2\noperations:\n(u,r)=(1,0)\nand\n(u,r)=(2,0)\n.\nIn the third test case, the first operation colors vertices\n2\n,\n3\nand\n4\nblack, and the second operation colors vertex\n1\nblack. Again, it can be shown that it is impossible to color all vertices black in\n1\noperation, so the minimum number of operations needed is\n2\n.\nIn the fourth test case, the first operation colors vertices\n4\n,\n1\nand\n7\nblack, the second operation colors vertices\n2\n,\n5\nand\n6\nblack while the third operation colors vertices\n3\nand\n7\nblack. Notice that it is allowed to color vertex\n7\nblack twice.\nThus, each node was marked at least once, with node\n7\nmarked twice. It can be shown that it is impossible to color all vertices black in fewer than\n3\nmoves.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "greedy",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "B. Non-Palindromic Substring",
        "description": "A string\nt\nis said to be\nk\n-good if there exists at least one substring\n†\n†\nof length\nk\nwhich is not a palindrome\n‡\n‡\n. Let\nf(t)\ndenote the sum of all values of\nk\nsuch that the string\nt\nis\nk\n-good.\nYou are given a string\ns\nof length\nn\n. You will have to answer\nq\nof the following queries:\nGiven\nl\nand\nr\n(\nl<r\n), find the value of\nf(\ns\nl\ns\nl+1\n…\ns\nr\n)\n.\n†\n†\nA substring of a string\nz\nis a contiguous segment of characters from\nz\n. For example, \"\ndefor\n\", \"\ncode\n\" and \"\no\n\" are all substrings of \"\ncodeforces\n\" while \"\ncodes\n\" and \"\naaa\n\" are not.\n‡\n‡\nA palindrome is a string that reads the same backwards as forwards. For example, the strings \"\nz\n\", \"\naa\n\" and \"\ntacocat\n\" are palindromes while \"\ncodeforces\n\" and \"\nab\n\" are not.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n2≤n≤2⋅\n10\n5\n,1≤q≤2⋅\n10\n5\n), the size of the string and the number of queries respectively.\nThe second line of each test case contains the string\ns\n. It is guaranteed the string\ns\nonly contains lowercase English characters.\nThe next\nq\nlines each contain two integers,\nl\nand\nr\n(\n1≤l<r≤n\n).\nIt is guaranteed the sum of\nn\nand the sum of\nq\nboth do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output\nf(\ns\nl\ns\nl+1\n…\ns\nr\n)\n.\nExample\ninput\nCopy\n5\n4 4\naaab\n1 4\n1 3\n3 4\n2 4\n3 2\nabc\n1 3\n1 2\n5 4\npqpcc\n1 5\n4 5\n1 3\n2 4\n2 1\naa\n1 2\n12 1\nsteponnopets\n1 12\noutput\nCopy\n9\n0\n2\n5\n5\n2\n14\n0\n2\n5\n0\n65\nNote\nIn the first query of the first test case, the string is\naaab\n.\naaab\n,\naab\nand\nab\nare all substrings that are not palindromes, and they have lengths\n4\n,\n3\nand\n2\nrespectively. Thus, the string is\n2\n-good,\n3\n-good and\n4\n-good. Hence,\nf(aaab)=2+3+4=9\n.\nIn the second query of the first test case, the string is\naaa\n. There are no non-palindromic substrings. Hence,\nf(aaa)=0\n.\nIn the first query of the second test case, the string is\nabc\n.\nab\n,\nbc\nand\nabc\nare all substrings that are not palindromes, and they have lengths\n2\n,\n2\nand\n3\nrespectively. Thus, the string is\n2\n-good and\n3\n-good. Hence,\nf(abc)=2+3=5\n. Note that even though there are\n2\nnon-palindromic substrings of length\n2\n, we count it only once.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "hashing",
            "implementation",
            "math",
            "strings",
            "*2000"
        ]
    },
    {
        "title": "A. MEX Game 1",
        "description": "Alice and Bob play yet another game on an array\na\nof size\nn\n. Alice starts with an empty array\nc\n. Both players take turns playing, with Alice starting first.\nOn Alice's turn, she picks one element from\na\n, appends that element to\nc\n, and then deletes it from\na\n.\nOn Bob's turn, he picks one element from\na\n, and then deletes it from\na\n.\nThe game ends when the array\na\nis empty. Game's score is defined to be the MEX\n†\n†\nof\nc\n. Alice wants to maximize the score while Bob wants to minimize it. Find game's final score if both players play optimally.\n†\n†\nThe\nMEX\n(minimum excludant) of an array of integers is defined as the smallest non-negative integer which does not occur in the array. For example:\nThe MEX of\n[2,2,1]\nis\n0\n, because\n0\ndoes not belong to the array.\nThe MEX of\n[3,1,0,1]\nis\n2\n, because\n0\nand\n1\nbelong to the array, but\n2\ndoes not.\nThe MEX of\n[0,3,1,2]\nis\n4\n, because\n0\n,\n1\n,\n2\nand\n3\nbelong to the array, but\n4\ndoes not.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<n\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, find game's score if both players play optimally.\nExample\ninput\nCopy\n3\n4\n0 0 1 1\n4\n0 1 2 3\n2\n1 1\noutput\nCopy\n2\n1\n0\nNote\nIn the first test case, a possible game with a score of\n2\nis as follows:\nAlice chooses the element\n1\n. After this move,\na=[0,0,1]\nand\nc=[1]\n.\nBob chooses the element\n0\n. After this move,\na=[0,1]\nand\nc=[1]\n.\nAlice chooses the element\n0\n. After this move,\na=[1]\nand\nc=[1,0]\n.\nBob chooses the element\n1\n. After this move,\na=[]\nand\nc=[1,0]\n.\nAt the end,\nc=[1,0]\n, which has a MEX of\n2\n. Note that this is an example game and does not necessarily represent the optimal strategy for both players.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "H. Farmer John's Favorite Intern",
        "description": "Peaches...\n⠀\nRuby just won an internship position at Farmer John's farm by winning a coding competition! As the newly recruited intern, Ruby is tasked with maintaining Farmer John's peach tree, a tree consisting of\nn\nnodes rooted at node\n1\n. Each node initially contains\na\ni\n=0\npeaches, and there are two types of events that can happen:\nGrowth event at some node\nx\n: Ruby must choose either the parent of\nx\nor any node in the subtree of\nx\nand increase the amount of peaches it contains by one.\nHarvest event at some node\nx\n: Ruby must choose a single node that is in the subtree of\nx\nand decrease the amount of peaches it contains by one. Note that this is not the same set of nodes as the growth event.\nNote that the subtree of\nx\nincludes the node\nx\nas well.\nRuby is also given an array\nb\nof length\nn\n. The peach tree is deemed healthy if\na\ni\n≥\nb\ni\nfor every node\ni\n.\nRuby is asked to perform\nq\noperations of two types:\n1 x v — Perform\nv\ngrowth events on node\nx\n. Ruby does not have to choose the same node to increase in every growth event.\n2 x v — Perform\nv\nharvest events on node\nx\n. Ruby does not have to choose the same node to decrease in every harvest event.\nFor every prefix of operations, Ruby asks you to find if she can perform these operations in some order such that the resulting peach tree (at the end of these operations) is healthy. Note that Ruby can't perform a harvest event that makes any\na\ni\nnegative.\nEvery prefix is independent, meaning that for a given operation, Ruby may choose different nodes to perform events on for every prefix that contains that operation.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)  — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n)  — the size of the tree and the number of operations.\nThe second line contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n<i\n)  — the parent of each node.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n≤\n10\n6\n)  — the minimum number of peaches each node needs for the peach tree to be considered healthy.\nThe next\nq\nlines describe the operations Ruby will perform. Each line contains three integers\nt\n,\nx\n, and\nv\n(\n1≤t≤2\n,\n1≤x≤n\n,\n1≤v≤\n10\n6\n). If\nt=1\n, this denotes that Ruby must perform\nv\ngrowth events on node\nx\n. If\nt=2\n, this denotes that Ruby must perform\nv\nharvest events on node\nx\n.\nIt is guaranteed that the sum of\nn\ndoes not exceed\n2⋅\n10\n5\nand the sum of\nq\ndoes not exceed\n2⋅\n10\n5\nOutput\nFor each test case, output\nq\nlines. The\ni\n-th line should contain \"YES\" if Ruby can make the peach tree healthy after performing operations\n1,2,…,i\nin some order. Otherwise, it should contain \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n2\n8 8\n1 1 1 4 3 6 6\n5 6 2 9 8 4 1 3\n1 3 14\n1 4 17\n1 2 7\n2 2 1\n1 6 1\n2 1 1000000\n1 4 999999\n1 3 1\n10 20\n1 1 1 2 5 2 4 7 2\n311353 270334 74853 385085 315501 183346 234819 417314 103862 429437\n1 1 837541\n1 10 933876\n1 1 565958\n1 4 791455\n2 3 85054\n2 3 440978\n1 4 981040\n1 5 68522\n2 1 858305\n2 4 184308\n1 4 905081\n2 8 519626\n2 2 269090\n1 1 43016\n2 2 517644\n1 5 355792\n1 9 319241\n2 10 125447\n2 10 523890\n1 10 241045\noutput\nCopy\nNO\nNO\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nYES\nYES\nNO\nNO\nYES\nYES\nNO\nYES\nYES\nNO\nYES\nNO\nNO\nYES\nYES\nNO\nNO\nNote\nFor the prefix containing operations\n1,2,…,5\nin the first test case, Ruby may perform the operations in the following order:\nRuby performs operation\n2\nand chooses to increase\na\n4\nby\n9\nand\na\n5\nby\n8\n.\nRuby performs operation\n1\nand chooses to increase\na\n1\nby\n5\n,\na\n3\nby\n2\n,\na\n6\nby\n4\n, and\na\n8\nby\n3\n.\nRuby performs operation\n3\nand chooses to increase\na\n2\nby\n7\n.\nRuby performs operation\n4\nand chooses to decrease\na\n2\nby\n1\n.\nRuby performs operation\n5\nand chooses to increase\na\n7\nby\n1\n.",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "flows",
            "trees",
            "*3500"
        ]
    },
    {
        "title": "G. Bessie and Cards",
        "description": "Second Dark Matter Battle - Pokemon Super Mystery Dungeon\n⠀\nBessie has recently started playing a famous card game. In the game, there is only one deck of cards, consisting of\na\n\"draw\n0\n\" cards,\nb\n\"draw\n1\n\" cards,\nc\n\"draw\n2\n\" cards, and\n5\nspecial cards. At the start of the game, all cards are in the randomly shuffled deck.\nBessie starts the game by drawing the top\n5\ncards of the deck. She may then play \"draw\nx\n\" cards from the hand to draw the next\nx\ncards from the top of the deck. Note that every card can only be played once, special cards cannot be played, and if Bessie uses a \"draw\n2\n\" card when there is only\n1\ncard remaining in the deck, then she simply draws that remaining card. Bessie wins if she draws all\n5\nspecial cards.\nSince Bessie is not very good at math problems, she wants you to find the probability that she wins, given that the deck is shuffled randomly over all\n(a+b+c+5)!\npossible orderings. It can be shown that this answer can always be expressed as a fraction\np\nq\nwhere\np\nand\nq\nare coprime integers. Output\np⋅q−1\nmodulo\n998244353\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nEach test case contains three integers\na\n,\nb\n, and\nc\n(\n0≤a,b,c≤2⋅105\n) – the number of draw\n0\ncards, draw\n1\ncards, and draw\n2\ncards, respectively.\nIt is guaranteed that the sum of\na\nover all test cases does not exceed\n2⋅105\n, the sum of\nb\nover all test cases does not exceed\n2⋅105\n, and the sum of\nc\nover all test cases does not exceed\n2⋅105\n.\nOutput\nFor each test case, output a single integer — the probability that Bessie wins, modulo\n998244353\n.\nExample\ninput\nCopy\n4\n1 1 1\n0 0 0\n5 3 7\n3366 1434 1234\noutput\nCopy\n903173463\n1\n35118742\n398952013\nNote\nIn the first case, we have\n1\nof each type of \"draw\" card and\n5\nspecial cards. There are\n30720\nstarting decks where Bessie will win by drawing the top\n5\ncards and\n40320\nstarting decks in total. Thus, the probability of Bessie winning is\n30720\n40320\n=\n16\n21\n.\nOne example of a winning starting deck is, top to bottom,\n\"Special\",\n\"Draw\n1\n\",\n\"Special\",\n\"Special\",\n\"Draw\n0\n\",\n\"Draw\n2\n\",\n\"Special\",\n\"Special\".\nOne example of a losing starting deck is:\n\"Special\",\n\"Draw\n1\n\",\n\"Special\",\n\"Special\",\n\"Draw\n0\n\",\n\"Special\",\n\"Special\",\n\"Draw\n2\n\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2800"
        ]
    },
    {
        "title": "F. Farmer John's Favorite Function",
        "description": "ΩΩPARTS - Camellia\n⠀\nFarmer John has an array\na\nof length\nn\n. He also has a function\nf\nwith the following recurrence:\nf(1)=\na\n1\n−\n−\n√\n;\nFor all\ni>1\n,\nf(i)=\nf(i−1)+\na\ni\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n√\n.\nNote that\nf(i)\nis not necessarily an integer.\nHe plans to do\nq\nupdates to the array. Each update, he gives you two integers\nk\nand\nx\nand he wants you to set\na\nk\n=x\n. After each update, he wants to know\n⌊f(n)⌋\n, where\n⌊t⌋\ndenotes the value of\nt\nrounded down to the nearest integer.\nInput\nThe first line contains\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n), the length of\na\nand the number of updates he will perform.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n18\n).\nThe next\nq\nlines each contain two integers\nk\nand\nx\n(\n1≤k≤n\n,\n0≤x≤\n10\n18\n), the index of the update and the element he will replace\na\nk\nwith.\nOutput\nFor each update, output an integer,\n⌊f(n)⌋\n, on a new line.\nExamples\ninput\nCopy\n5 6\n0 14 0 7 6\n1 4\n1 3\n2 15\n4 1\n5 2\n5 8\noutput\nCopy\n3\n2\n3\n2\n1\n3\ninput\nCopy\n15 10\n3364 1623 5435 7 6232 245 7903 3880 9738 577 4598 1868 1112 8066 199\n14 4284\n14 8066\n6 92\n6 245\n2 925\n2 1623\n5 176\n5 6232\n3 1157\n3 5435\noutput\nCopy\n16\n17\n16\n17\n16\n17\n16\n17\n16\n17\ninput\nCopy\n2 2\n386056082462833225 923951085408043421\n1 386056082462833225\n1 386056082462833224\noutput\nCopy\n961223744\n961223743\ninput\nCopy\n13 10\n31487697732100 446330174221392699 283918145228010533 619870471872432389 11918456891794188 247842810542459080 140542974216802552 698742782599365547 533363381213535498 92488084424940128 401887157851719898 128798321287952855 137376848358184069\n3 283918145228010532\n3 283918145228010533\n1 2183728930312\n13 1000000000000000000\n10 1000000000000000000\n9 1000000000000000000\n8 1000000000000000000\n7 1000000000000000000\n6 1000000000000000000\n5 1000000000000000000\noutput\nCopy\n370643829\n370643830\n370643829\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\n1000000000\nNote\nIn the first test case, the array after the first update is\n[4,14,0,7,6]\n. The values of\nf\nare:\nf(1)=2\n;\nf(2)=4\n;\nf(3)=2\n;\nf(4)=3\n;\nf(5)=3\n.\nSince\n⌊f(5)⌋=3\n, we output\n3\n.\nThe array after the second update is\n[3,14,0,7,6]\n. The values of\nf\n, rounded to\n6\ndecimal places, are:\nf(1)≈1.732051\n;\nf(2)≈3.966365\n;\nf(3)≈1.991573\n;\nf(4)≈2.998595\n;\nf(5)≈2.999766\n.\nSince\n⌊f(5)⌋=2\n, we output\n2\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "math",
            "*2700"
        ]
    },
    {
        "title": "E. Farm Game",
        "description": "Lunatic Princess - Touhou\n⠀\nFarmer Nhoj has brought his cows over to Farmer John's farm to play a game! FJ's farm can be modeled by a number line with walls at points\n0\nand\nl+1\n. On the farm, there are\n2n\ncows, with\nn\nof the cows belonging to FJ and the other\nn\nbelonging to FN. They place each of their cows at a distinct point, and no two FJ's cows nor FN's cows are adjacent. Two cows are adjacent if there are no other cows between them.\nFormally, if\na\n1\n,\na\n2\n,…,\na\nn\nrepresents the positions of FJ's cows and\nb\n1\n,\nb\n2\n,…,\nb\nn\nrepresents the positions of FN's cows, then either\n0<\na\n1\n<\nb\n1\n<\na\n2\n<\nb\n2\n<…<\na\nn\n<\nb\nn\n<l+1\nor\n0<\nb\n1\n<\na\n1\n<\nb\n2\n<\na\n2\n<…<\nb\nn\n<\na\nn\n<l+1\n.\nIn one move, a farmer chooses a number\nk\n(1≤k≤n)\nand a direction (left or right). Then, that farmer chooses\nk\nof his cows and moves them one position towards the chosen direction. A farmer cannot move any of his cows onto the walls or onto another farmer's cow. If a farmer cannot move any cows, then that farmer loses. FJ starts the game, making the first turn.\nGiven\nl\nand\nn\n, find the number of possible game configurations for Farmer John to win if both farmers play optimally. It may be the case that the game will continue indefinitely, in which no farmer wins. A configuration is different from another if there is any\ni\nsuch that\na\ni\nor\nb\ni\nis different. Output the answer modulo\n998244353\n.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case contains two integers\nl\nand\nn\n(\n2≤l≤\n10\n6\n,1≤n≤⌊\nl\n2\n⌋\n) — the length of the number line and the number of cows each farmer will place.\nIt is guaranteed the sum of\nl\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case output an integer: the number of game configurations where Farmer John wins if both farmers play optimally, modulo\n998244353\n.\nExample\ninput\nCopy\n3\n2 1\n3 1\n420 69\noutput\nCopy\n0\n2\n870279412\nNote\nLet J denote FJ's cow, N denote FN's cow, and _ denote an empty space.\nFor the first test case, the two possible configurations are JN or NJ. In both cases, since FJ makes the first turn and cannot make any moves, he cannot win.\nFor the second case there are two possible configurations for FJ to win: N_J and J_N.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "games",
            "*2300"
        ]
    },
    {
        "title": "D. Learning to Paint",
        "description": "Pristine Beat - Touhou\n⠀\nElsie is learning how to paint. She has a canvas of\nn\ncells numbered from\n1\nto\nn\nand can paint any (potentially empty) subset of cells.\nElsie has a 2D array\na\nwhich she will use to evaluate paintings. Let the maximal contiguous intervals of painted cells in a painting be\n[\nl\n1\n,\nr\n1\n],[\nl\n2\n,\nr\n2\n],…,[\nl\nx\n,\nr\nx\n]\n. The beauty of the painting is the sum of\na\nl\ni\n,\nr\ni\nover all\n1≤i≤x\n. In the image above, the maximal contiguous intervals of painted cells are\n[2,4],[6,6],[8,9]\nand the beauty of the painting is\na\n2,4\n+\na\n6,6\n+\na\n8,9\n.\nThere are\n2\nn\nways to paint the strip. Help Elsie find the\nk\nlargest possible values of the beauty of a painting she can obtain, among all these ways. Note that these\nk\nvalues do not necessarily have to be distinct. It is guaranteed that there are at least\nk\ndifferent ways to paint the canvas.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains\n2\nintegers\nn\nand\nk\n(\n1≤n≤\n10\n3\n,\n1≤k≤min(\n2\nn\n,5⋅\n10\n3\n)\n) — the number of cells and the number of largest values of the beauty of a painting you must find.\nThe next\nn\nlines of each test case describe\na\nwhere the\ni\n-th of which contains\nn−i+1\nintegers\na\ni,i\n,\na\ni,i+1\n,…,\na\ni,n\n(\n−\n10\n6\n≤\na\ni,j\n≤\n10\n6\n).\nIt is guaranteed the sum of\nn\nover all test cases does not exceed\n10\n3\nand the sum of\nk\nover all test cases does not exceed\n5⋅\n10\n3\n.\nOutput\nFor each test case, output\nk\nintegers in one line: the\ni\n-th of them must represent the\ni\n-th largest value of the beauty of a painting Elsie can obtain.\nExample\ninput\nCopy\n4\n1 2\n-5\n2 4\n2 -3\n-1\n3 8\n2 4 3\n1 3\n5\n6 20\n0 -6 -3 0 -6 -2\n-7 -5 -2 -3 -4\n7 0 -9 -4\n2 -1 1\n1 -2\n-6\noutput\nCopy\n0 -5 \n2 0 -1 -3 \n7 5 4 3 3 2 1 0 \n8 8 7 7 5 5 2 2 1 1 1 1 1 1 0 0 0 0 0 -1 \nNote\nIn the first test case, Elsie can either paint the only cell or not paint it. If she paints the only cell, the beauty of the painting is\n−5\n. If she chooses not to paint it, the beauty of the painting is\n0\n. Thus, the largest beauty she can obtain is\n0\nand the second largest beauty she can obtain is\n−5\n.\nBelow is an illustration of the third test case.",
        "time_limit": "4.5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*2100"
        ]
    },
    {
        "title": "C2. Bessie's Birthday Cake (Hard Version)",
        "description": "Proof Geometric Construction Can Solve All Love Affairs - manbo-p\n⠀\nThis is the hard version of the problem. The only difference between the two versions is the constraint on\ny\n. In this version\n0≤y≤n−x\n. You can make hacks only if both versions are solved.\nBessie has received a birthday cake from her best friend Elsie, and it came in the form of a regular polygon with\nn\nsides. The vertices of the cake are numbered from\n1\nto\nn\nclockwise. You and Bessie are going to choose some of those vertices to cut non-intersecting diagonals into the cake. In other words, the endpoints of the diagonals must be part of the chosen vertices.\nBessie would only like to give out pieces of cake which result in a triangle to keep consistency. The size of the pieces doesn't matter, and the whole cake does not have to be separated into all triangles (other shapes are allowed in the cake, but those will not be counted).\nBessie has already chosen\nx\nof those vertices that can be used to form diagonals. She wants you to choose no more than\ny\nother vertices such that the number of triangular pieces of cake she can give out is maximized.\nWhat is the maximum number of triangular pieces of cake Bessie can give out?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case consists of three integers,\nn\n,\nx\n, and\ny\n(\n4≤n≤\n10\n9\n,\n2≤x≤min(n,2⋅\n10\n5\n)\n,\n0≤y≤n−x\n) — the number of sides of the polygon, number of vertices Bessie has chosen, and the maximum number of other vertices you can choose.\nThe second line consists of\nx\ndistinct integers from\n1\nto\nn\n, representing the vertices Bessie has chosen.\nIt is guaranteed the sum of\nx\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum number of non-intersecting triangular pieces of cake she can give out.\nExample\ninput\nCopy\n3\n8 4 2\n1 6 2 5\n7 3 1\n6 4 3\n4 2 2\n1 3\noutput\nCopy\n6\n5\n2\nNote\nIn test cases\n1\n,\n2\nand\n3\n, you can get\n6\n,\n5\nand\n2\nnon-intersecting triangular pieces of cake, respectively. A possible construction is shown in the following pictures:\nThe green dots represent vertices that Bessie chose, the yellow dots represent vertices that you chose, the blue lines represent diagonals that are drawn, and the red numbers represent triangles that are counted.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "greedy",
            "math",
            "*1700"
        ]
    },
    {
        "title": "C1. Bessie's Birthday Cake (Easy Version)",
        "description": "Proof Geometric Construction Can Solve All Love Affairs - manbo-p\n⠀\nThis is the easy version of the problem. The only difference between the two versions is the constraint on\ny\n. In this version\ny=0\n. You can make hacks only if both versions are solved.\nBessie has received a birthday cake from her best friend Elsie, and it came in the form of a regular polygon with\nn\nsides. The vertices of the cake are numbered from\n1\nto\nn\nclockwise. You and Bessie are going to choose some of those vertices to cut non-intersecting diagonals into the cake. In other words, the endpoints of the diagonals must be part of the chosen vertices.\nBessie would only like to give out pieces of cake which result in a triangle to keep consistency. The size of the pieces doesn't matter, and the whole cake does not have to be separated into all triangles (other shapes are allowed in the cake, but those will not be counted).\nBessie has already chosen\nx\nof those vertices that can be used to form diagonals. She wants you to choose no more than\ny\nother vertices such that the number of triangular pieces of cake she can give out is maximized.\nWhat is the maximum number of triangular pieces of cake Bessie can give out?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case consists of three integers,\nn\n,\nx\n, and\ny\n(\n4≤n≤\n10\n9\n,\n2≤x≤min(n,2⋅\n10\n5\n)\n,\ny=0\n) — the number of sides of the polygon, number of vertices Bessie has chosen, and the maximum number of other vertices you can choose.\nThe second line consists of\nx\ndistinct integers from\n1\nto\nn\n, representing the vertices Bessie has chosen.\nIt is guaranteed the sum of\nx\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the maximum number of non-intersecting triangular pieces of cake she can give out.\nExample\ninput\nCopy\n3\n8 4 0\n1 6 2 5\n8 8 0\n1 3 2 5 4 6 7 8\n4 2 0\n1 3\noutput\nCopy\n2\n6\n2\nNote\nIn test cases\n1\n,\n2\nand\n3\n, you can get\n2\n,\n6\nand\n2\nnon-intersecting triangular pieces of cake, respectively. A possible construction is shown in the following pictures:\nThe green dots represent vertices that can be used, the blue lines represent diagonals that are drawn, and the red numbers represent triangles that are counted.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. Bessie and MEX",
        "description": "MOOO! - Doja Cat\n⠀\nFarmer John has a permutation\np\n1\n,\np\n2\n,…,\np\nn\n, where every integer from\n0\nto\nn−1\noccurs exactly once. He gives Bessie an array\na\nof length\nn\nand challenges her to construct\np\nbased on\na\n.\nThe array\na\nis constructed so that\na\ni\n=\nMEX(\np\n1\n,\np\n2\n,…,\np\ni\n)−\np\ni\n, where the\nMEX\nof an array is the minimum non-negative integer that does not appear in that array. For example,\nMEX(1,2,3)=0\nand\nMEX(3,1,0)=2\n.\nHelp Bessie construct any valid permutation\np\nthat satisfies\na\n. The input is given in such a way that at least one valid\np\nexists. If there are multiple possible\np\n, it is enough to print one of them.\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the lengths of\np\nand\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−n≤\na\ni\n≤n\n) — the elements of array\na\n.\nIt is guaranteed that there is at least one valid\np\nfor the given data.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers on a new line, the elements of\np\n.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n3\n5\n1 1 -2 1 2\n5\n1 1 1 1 1\n3\n-2 1 2\noutput\nCopy\n0 1 4 2 3 \n0 1 2 3 4 \n2 0 1 \nNote\nIn the first case,\np=[0,1,4,2,3]\nis one possible output.\na\nwill then be calculated as\na\n1\n=MEX(0)−0=1\n,\na\n2\n=MEX(0,1)−1=1\n,\na\n3\n=MEX(0,1,4)−4=−2\n,\na\n4\n=MEX(0,1,4,2)−2=1\n,\na\n5\n=MEX(0,1,4,2,3)−3=2\n.\nSo, as required,\na\nwill be\n[1,1,−2,1,2]\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ]
    },
    {
        "title": "A. Farmer John's Challenge",
        "description": "Trade Winds - Patrick Deng\n⠀\nLet's call an array\na\nsorted if\na\n1\n≤\na\n2\n≤…≤\na\nn−1\n≤\na\nn\n.\nYou are given two of Farmer John's favorite integers,\nn\nand\nk\n. He challenges you to find any array\na\n1\n,\na\n2\n,…,\na\nn\nsatisfying the following requirements:\n1≤\na\ni\n≤\n10\n9\nfor each\n1≤i≤n\n;\nOut of the\nn\ntotal cyclic shifts of\na\n, exactly\nk\nof them are sorted.\n†\n†\nIf there is no such array\na\n, output\n−1\n.\n†\n†\nThe\nx\n-th (\n1≤x≤n\n) cyclic shift of the array\na\nis\na\nx\n,\na\nx+1\n…\na\nn\n,\na\n1\n,\na\n2\n…\na\nx−1\n. If\nc\nx,i\ndenotes the\ni\n'th element of the\nx\n'th cyclic shift of\na\n, exactly\nk\nsuch\nx\nshould satisfy\nc\nx,1\n≤\nc\nx,2\n≤…≤\nc\nx,n−1\n≤\nc\nx,n\n.\nFor example, the cyclic shifts for\na=[1,2,3,3]\nare the following:\nx=1\n:\n[1,2,3,3]\n(sorted);\nx=2\n:\n[2,3,3,1]\n(not sorted);\nx=3\n:\n[3,3,1,2]\n(not sorted);\nx=4\n:\n[3,1,2,3]\n(not sorted).\nInput\nThe first line contains\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nEach test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤\n10\n3\n) — the length of\na\nand the number of sorted cyclic shifts\na\nmust have.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n3\n.\nOutput\nFor each test case, print a single line:\nif there is a valid array\na\n, output\nn\nintegers, representing\na\n1\n,\na\n2\n,…,\na\nn\n;\notherwise, output\n−1\n.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n3\n2 2\n3 1\n3 2\noutput\nCopy\n1 1\n69420 69 420\n-1\nNote\nIn the first testcase,\na=[1,1]\nsatisfies\nn=2,k=2\n:\nThe two cyclic shifts of\na\nare\n[\na\n1\n,\na\n2\n]\nand\n[\na\n2\n,\na\n1\n]\n, which are both\n[1,1]\nand are sorted.\nIn the second testcase,\na=[69420,69,420]\nsatisfies\nn=3,k=1\n:\nThe three cyclic shifts of\na\nare\n[\na\n1\n,\na\n2\n,\na\n3\n]\n,\n[\na\n2\n,\na\n3\n,\na\n1\n]\n,\n[\na\n3\n,\na\n1\n,\na\n2\n]\n, which are\n[69420,69,420]\n,\n[69,420,69420]\n, and\n[420,69420,69]\n, respectively.\nOnly\n[69,420,69420]\nis sorted.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Rudolf and Subway",
        "description": "Building bridges did not help Bernard, and he continued to be late everywhere. Then Rudolf decided to teach him how to use the subway.\nRudolf depicted the subway map as an undirected connected graph, without self-loops, where the vertices represent stations. There is at most one edge between any pair of vertices.\nTwo vertices are connected by an edge if it is possible to travel directly between the corresponding stations, bypassing other stations. The subway in the city where Rudolf and Bernard live has a color notation. This means that any edge between stations has a specific color. Edges of a specific color together form a subway line. A subway line cannot contain unconnected edges and forms a connected subgraph of the given subway graph.\nAn example of the subway map is shown in the figure.\nRudolf claims that the route will be optimal if it passes through the minimum number of subway lines.\nHelp Bernard determine this minimum number for the given departure and destination stations.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThis is followed by descriptions of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤2⋅\n10\n5\n,1≤m≤2⋅\n10\n5\n) — the number of subway stations and the number of direct routes between stations (i.e., graph edges).\nThis is followed by\nm\nlines — the description of the edges. Each line of the description contains three integers\nu\n,\nv\n, and\nc\n(\n1≤u,v≤n,u≠v,1≤c≤2⋅\n10\n5\n) — the numbers of the vertices between which there is an edge, and the color of this edge. It is guaranteed that edges of the same color form a connected subgraph of the given subway graph. There is at most one edge between a pair of any two vertices.\nThis is followed by two integers\nb\nand\ne\n(\n1≤b,e≤n\n) — the departure and destination stations.\nThe sum of all\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. The sum of all\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, output a single integer — the minimum number of subway lines through which the route from station\nb\nto station\ne\ncan pass.\nExamples\ninput\nCopy\n5\n6 6\n1 2 1\n2 3 1\n5 2 2\n2 4 2\n4 6 2\n3 6 3\n1 3\n6 6\n1 2 1\n2 3 1\n5 2 2\n2 4 2\n4 6 2\n3 6 3\n1 6\n6 6\n1 2 1\n2 3 1\n5 2 2\n2 4 2\n4 6 2\n3 6 3\n6 6\n4 3\n1 2 1\n1 3 1\n4 1 1\n2 3\n6 7\n1 2 43\n1 3 34\n4 6 43\n6 3 43\n2 3 43\n5 3 43\n4 5 43\n1 6\noutput\nCopy\n1\n2\n0\n1\n1\ninput\nCopy\n3\n7 9\n2 4 1\n3 6 1\n2 3 5\n1 7 1\n4 7 1\n2 5 4\n5 4 4\n3 4 1\n3 7 1\n5 3\n6 5\n6 5 83691\n4 1 83691\n5 4 83691\n3 2 83691\n4 3 83691\n5 1\n6 7\n6 1 83691\n6 2 83691\n2 5 83691\n5 6 83691\n2 3 83691\n5 4 83574\n3 5 83691\n1 4\noutput\nCopy\n2\n1\n2\nNote\nThe subway graph for the first example is shown in the figure in the problem statement.\nIn the first test case, from vertex\n1\nto vertex\n3\n, you can travel along the path\n1→2→3\n, using only the green line.\nIn the second test case, from vertex\n1\nto vertex\n6\n, you can travel along the path\n1→2→3→6\n, using the green and blue lines.\nIn the third test case, there is no need to travel from vertex\n6\nto the same vertex, so the number of lines is\n0\n.\nIn the fourth test case, all edges of the graph belong to one line, so the answer is\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "shortest paths",
            "*2000"
        ]
    },
    {
        "title": "F. Rudolf and Imbalance",
        "description": "Rudolf has prepared a set of\nn\nproblems with complexities\na\n1\n<\na\n2\n<\na\n3\n<⋯<\na\nn\n. He is not entirely satisfied with the balance, so he wants to add at most one problem to fix it.\nFor this, Rudolf came up with\nm\nmodels of problems and\nk\nfunctions. The complexity of the\ni\n-th model is\nd\ni\n, and the complexity of the\nj\n-th function is\nf\nj\n. To create a problem, he selects values\ni\nand\nj\n(\n1≤i≤m\n,\n1≤j≤k\n) and by combining the\ni\n-th model with the\nj\n-th function, he obtains a new problem with complexity\nd\ni\n+\nf\nj\n(a new element is inserted into the array\na\n).\nTo determine the imbalance of the set, Rudolf sorts the complexities of the problems in ascending order and finds the largest value of\na\ni\n−\na\ni−1\n(\ni>1\n).\nWhat is the minimum value of imbalance that Rudolf can achieve by adding at most one problem, created according to the described rules?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n2≤n≤\n10\n5\n,\n1≤m,k≤2⋅\n10\n5\n) — the number of prepared problems, the number of models, and the number of functions, respectively.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,\na\n3\n,…\na\nn\n(\n1≤\na\ni\n≤2⋅\n10\n9\n,\na\ni\n<\na\ni+1\n) — the complexities of the prepared problems.\nThe third line of each test case contains\nm\nintegers\nd\n1\n,\nd\n2\n,\nd\n3\n,…\nd\nm\n(\n1≤\nd\ni\n≤\n10\n9\n) — the complexities of the models.\nThe fourth line of each test case contains\nk\nintegers\nf\n1\n,\nf\n2\n,\nf\n3\n,…\nf\nk\n(\n1≤\nf\ni\n≤\n10\n9\n) — the complexities of the functions.\nIt is guaranteed that the sum of\nn\nover all testcases does not exceed\n10\n5\n.\nIt is guaranteed that the sum of\nm\nover all testcases does not exceed\n2⋅\n10\n5\n.\nIt is guaranteed that the sum of\nk\nover all testcases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, output a single number — the minimum imbalance that Rudolf can achieve.\nExample\ninput\nCopy\n7\n5 5 5\n5 10 15 20 26\n11 14 16 13 8\n16 4 5 3 1\n7 6 5\n1 4 7 10 18 21 22\n2 3 5 7 4 2\n6 8 9 3 2\n7 6 5\n1 4 7 10 18 21 22\n2 3 5 7 4 2\n6 8 13 3 2\n5 6 3\n2 10 13 20 25\n11 6 10 16 14 5\n6 17 15\n4 2 2\n11 12 14 15\n19 14\n10 6\n8 4 2\n3 10 16 18 21 22 29 30\n9 13 16 15\n4 2\n2 4 7\n4 21\n4 15 14 5\n20 1 15 1 12 5 11\noutput\nCopy\n5\n4\n5\n8\n2\n7\n11",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "two pointers",
            "*1800"
        ]
    },
    {
        "title": "E. Rudolf and k Bridges",
        "description": "Bernard loves visiting Rudolf, but he is always running late. The problem is that Bernard has to cross the river on a ferry. Rudolf decided to help his friend solve this problem.\nThe river is a grid of\nn\nrows and\nm\ncolumns. The intersection of the\ni\n-th row and the\nj\n-th column contains the number\na\ni,j\n — the depth in the corresponding cell. All cells in the first and last columns correspond to the river banks, so the depth for them is\n0\n.\nThe river may look like this.\nRudolf can choose the row\n(i,1),(i,2),…,(i,m)\nand build a bridge over it. In each cell of the row, he can install a support for the bridge. The cost of installing a support in the cell\n(i,j)\nis\na\ni,j\n+1\n. Supports must be installed so that the following conditions are met:\nA support must be installed in cell\n(i,1)\n;\nA support must be installed in cell\n(i,m)\n;\nThe distance between any pair of adjacent supports must be no more than\nd\n. The distance between supports\n(i,\nj\n1\n)\nand\n(i,\nj\n2\n)\nis\n|\nj\n1\n−\nj\n2\n|−1\n.\nBuilding just one bridge is boring. Therefore, Rudolf decided to build\nk\nbridges on consecutive rows of the river, that is, to choose some\ni\n(\n1≤i≤n−k+1\n) and independently build a bridge on each of the rows\ni,i+1,…,i+k−1\n. Help Rudolf minimize the total cost of installing supports.\nInput\nThe first line contains a single integer\nt\n(1≤t≤\n10\n3\n)\n— the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains four integers\nn\n,\nm\n,\nk\n, and\nd\n(\n1≤k≤n≤100\n,\n3≤m≤2⋅\n10\n5\n,\n1≤d≤m\n) — the number of rows and columns of the field, the number of bridges, and the maximum distance between supports.\nThen follow\nn\nlines,\ni\n-th line contains\nm\npositive integers\na\ni,j\n(\n0≤\na\ni,j\n≤\n10\n6\n,\na\ni,1\n=\na\ni,m\n=0\n) — the depths of the river cells.\nIt is guaranteed that the sum of\nn⋅m\nfor all sets of input data does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single number — the minimum total cost of supports installation.\nExample\ninput\nCopy\n5\n3 11 1 4\n0 1 2 3 4 5 4 3 2 1 0\n0 1 2 3 2 1 2 3 3 2 0\n0 1 2 3 5 5 5 5 5 2 0\n4 4 2 1\n0 3 3 0\n0 2 1 0\n0 1 2 0\n0 3 3 0\n4 5 2 5\n0 1 1 1 0\n0 2 2 2 0\n0 2 1 1 0\n0 3 2 1 0\n1 8 1 1\n0 10 4 8 4 4 2 0\n4 5 3 2\n0 8 4 4 0\n0 3 4 8 0\n0 8 1 10 0\n0 10 1 5 0\noutput\nCopy\n4\n8\n4\n15\n14\nNote\nIn the first test case, it is most profitable to build a bridge on the second row.\nIt is not a top view, but side view: gray cells — bridge itself, white cells are empty, black cells — supports, blue cells — water, brown cells — river bottom.\nIn the second test case, it is most profitable to build bridges on the second and third rows. The supports will be placed in cells\n(2,3)\n,\n(3,2)\n, and on the river banks.\nIn the third test case the supports can be placed along the river banks.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "two pointers",
            "*1600"
        ]
    },
    {
        "title": "D. Rudolf and the Ball Game",
        "description": "Rudolf and Bernard decided to play a game with their friends.\nn\npeople stand in a circle and start throwing a ball to each other. They are numbered from\n1\nto\nn\nin the clockwise order.\nLet's call a transition a movement of the ball from one player to his neighbor. The transition can be made clockwise or counterclockwise.\nLet's call the clockwise (counterclockwise) distance from player\ny\n1\nto player\ny\n2\nthe number of transitions clockwise (counterclockwise) that need to be made to move from player\ny\n1\nto player\ny\n2\n. For example, if\nn=7\nthen the clockwise distance from\n2\nto\n5\nis\n3\n, and the counterclockwise distance from\n2\nto\n5\nis\n4\n.\nInitially, the ball is with the player number\nx\n(players are numbered clockwise). On the\ni\n-th move the person with the ball throws it at a distance of\nr\ni\n(\n1≤\nr\ni\n≤n−1\n) clockwise or counterclockwise. For example, if there are\n7\nplayers, and the\n2\nnd player, after receiving the ball, throws it a distance of\n5\n, then the ball will be caught by either the\n7\nth player (throwing clockwise) or the\n4\nth player (throwing counterclockwise). An illustration of this example is shown below.\nThe game was interrupted after\nm\nthrows due to unexpected rain. When the rain stopped, the guys gathered again to continue. However, no one could remember who had the ball. As it turned out, Bernard remembered the distances for each of the throws and the direction for some of the throws (clockwise or counterclockwise).\nRudolf asks you to help him and based on the information from Bernard, calculate the numbers of the players who could have the ball after\nm\nthrows.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains three integers\nn,m,x\n(\n2≤n≤1000\n,\n1≤m≤1000\n,\n1≤x≤n\n) — the number of players, the number of throws made, and the number of the player who threw the ball first, respectively.\nThe next\nm\nlines contain information about each throw in order. Each of them contains an integer\nr\ni\n(\n1≤\nr\ni\n≤n−1\n) — the distance at which the\ni\n-th throw was made, and a symbol\nc\ni\n, equal to '0', '1', or '?':\nif\nc\ni\n='0', then the\ni\n-th throw was made clockwise,\nif\nc\ni\n='1', then the\ni\n-th throw was made counterclockwise,\nif\nc\ni\n='?', then Bernard does not remember the direction and the\ni\n-th throw could have been made either clockwise or counterclockwise.\nIt is guaranteed that the sum\nn⋅m\n(\nn\nmultiplied by\nm\n) over all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two lines.\nIn the first line, output the number of players\nk\n(\n1≤k≤n\n) who could have the ball at the end of the game.\nIn the next line, output\nk\nnumbers\nb\ni\n(\n1≤\nb\ni\n≤n\n) — the numbers of the players in increasing order. All numbers must be different.\nExample\ninput\nCopy\n5\n6 3 2\n2 ?\n2 ?\n2 ?\n12 1 2\n3 1\n10 7 4\n2 ?\n9 1\n4 ?\n7 0\n2 0\n8 1\n5 ?\n5 3 1\n4 0\n4 ?\n1 ?\n4 1 1\n2 ?\noutput\nCopy\n3\n2 4 6 \n1\n11 \n4\n3 5 7 9 \n3\n2 3 5 \n1\n3 \nNote\nBelow is an illustration of three throws for the first test case. The arrows denote possible throw directions. Players who could have the ball after the throw are highlighted in gray.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "implementation",
            "*1200"
        ]
    },
    {
        "title": "C. Rudolf and the Ugly String",
        "description": "Rudolf has a string\ns\nof length\nn\n. Rudolf considers the string\ns\nto be ugly if it contains the substring\n†\n†\n\"pie\" or the substring \"map\", otherwise the string\ns\nwill be considered beautiful.\nFor example, \"ppiee\", \"mmap\", \"dfpiefghmap\" are ugly strings, while \"mathp\", \"ppiiee\" are beautiful strings.\nRudolf wants to shorten the string\ns\nby removing some characters to make it beautiful.\nThe main character doesn't like to strain, so he asks you to make the string beautiful by removing the minimum number of characters. He can remove characters from any positions in the string (not just from the beginning or end of the string).\n†\n†\nString\na\nis a substring of\nb\nif there exists a consecutive segment of characters in string\nb\nequal to\na\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the length of the string\ns\n.\nThe next line of each test case contains the string\ns\nof length\nn\n. The string\ns\nconsists of lowercase Latin letters.\nThe sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the minimum number of characters that need to be deleted to make the string\ns\nbeautiful. If the string is initially beautiful, then output\n0\n.\nExample\ninput\nCopy\n6\n9\nmmapnapie\n9\nazabazapi\n8\nmappppie\n18\nmapmapmapmapmapmap\n1\np\n11\npppiepieeee\noutput\nCopy\n2\n0\n2\n6\n0\n2\nNote\nIn the first test case, for example, you can delete the\n4\nth and\n9\nth characters to make the string beautiful.\nIn the second test case, the string is already beautiful.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "strings",
            "*900"
        ]
    },
    {
        "title": "B. Rudolf and 121",
        "description": "Rudolf has an array\na\nof\nn\nintegers, the elements are numbered from\n1\nto\nn\n.\nIn one operation, he can choose an index\ni\n(\n2≤i≤n−1\n) and assign:\na\ni−1\n=\na\ni−1\n−1\na\ni\n=\na\ni\n−2\na\ni+1\n=\na\ni+1\n−1\nRudolf can apply this operation any number of times. Any index\ni\ncan be used zero or more times.\nCan he make all the elements of the array equal to zero using this operation?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases in the test.\nThe first line of each case contains a single integer\nn\n(\n3≤n≤2⋅\n10\n5\n) — the number of elements in the array.\nThe second line of each case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\nj\n≤\n10\n9\n) — the elements of the array.\nIt is guaranteed that the sum of the values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if it is possible to make all the elements of the array zero using the described operations. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n7\n5\n1 3 5 5 2\n5\n2 4 4 5 1\n5\n0 1 3 3 1\n6\n5 6 0 2 3 0\n4\n1 2 7 2\n3\n7 1 0\n4\n1 1 1 1\noutput\nCopy\nYES\nNO\nYES\nNO\nNO\nNO\nNO\nNote\nIn the first example, the original array is\n[1,3,5,5,2]\n, to make all its elements zero, Rudolf can act as follows:\napply the operation at\ni=4\nand get the array\n[1,3,4,3,1]\n;\napply the operation at\ni=3\nand get the array\n[1,2,2,2,1]\n;\napply the operation at\ni=2\nand get the array\n[0,0,1,2,1]\n;\napply the operation at\ni=4\nand get the array\n[0,0,0,0,0]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1000"
        ]
    },
    {
        "title": "A. Rudolf and the Ticket",
        "description": "Rudolf is going to visit Bernard, and he decided to take the metro to get to him. The ticket can be purchased at a machine that accepts exactly two coins, the sum of which does not exceed\nk\n.\nRudolf has two pockets with coins. In the left pocket, there are\nn\ncoins with denominations\nb\n1\n,\nb\n2\n,…,\nb\nn\n. In the right pocket, there are\nm\ncoins with denominations\nc\n1\n,\nc\n2\n,…,\nc\nm\n. He wants to choose exactly one coin from the left pocket and exactly one coin from the right pocket (two coins in total).\nHelp Rudolf determine how many ways there are to select indices\nf\nand\ns\nsuch that\nb\nf\n+\nc\ns\n≤k\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases. Then follows the description of each test case.\nThe first line of each test case contains three natural numbers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤100,1≤k≤2000\n) — the number of coins in the left and right pockets, and the maximum sum of two coins for the ticket payment at the counter, respectively.\nThe second line of each test case contains\nn\nintegers\nb\ni\n(\n1≤\nb\ni\n≤1000\n) — the denominations of coins in the left pocket.\nThe third line of each test case contains\nm\nintegers\nc\ni\n(\n1≤\nc\ni\n≤1000\n) — the denominations of coins in the right pocket.\nOutput\nFor each testcase, output a single integer — the number of ways Rudolf can select two coins, taking one from each pocket, so that the sum of the coins does not exceed\nk\n.\nExample\ninput\nCopy\n4\n4 4 8\n1 5 10 14\n2 1 8 1\n2 3 4\n4 8\n1 2 3\n4 2 7\n1 1 1 1\n2 7\n3 4 2000\n1 1 1\n1 1 1 1\noutput\nCopy\n6\n0\n4\n12\nNote\nNote that the pairs indicate the indices of the coins in the array, not their denominations.\nIn the first test case, Rudolf can choose the following pairs of coins:\n[1,1],[1,2],[1,4],[2,1],[2,2],[2,4]\n.\nIn the second test case, Rudolf cannot choose one coin from each pocket in any way, as the sum of any two elements from the first and second arrays will exceed the value of\nk=4\n.\nIn the third test case, Rudolf can choose:\n[1,1],[2,1],[3,1],[4,1]\n.\nIn the fourth test case, Rudolf can choose any coin from the left pocket and any coin from the right pocket.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*800"
        ]
    },
    {
        "title": "B. Binary Path",
        "description": "You are given a\n2×n\ngrid filled with zeros and ones. Let the number at the intersection of the\ni\n-th row and the\nj\n-th column be\na\nij\n.\nThere is a grasshopper at the top-left cell\n(1,1)\nthat can only jump one cell right or downwards. It wants to reach the bottom-right cell\n(2,n)\n. Consider the binary string of length\nn+1\nconsisting of numbers written in cells of the path without changing their order.\nYour goal is to:\nFind the lexicographically smallest\n†\n†\nstring you can attain by choosing any available path;\nFind the number of paths that yield this lexicographically smallest string.\n†\n†\nIf two strings\ns\nand\nt\nhave the same length, then\ns\nis lexicographically smaller than\nt\nif and only if in the first position where\ns\nand\nt\ndiffer, the string\ns\nhas a smaller element than the corresponding element in\nt\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains a binary string\na\n11\na\n12\n…\na\n1n\n(\na\n1i\nis either\n0\nor\n1\n).\nThe third line of each test case contains a binary string\na\n21\na\n22\n…\na\n2n\n(\na\n2i\nis either\n0\nor\n1\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two lines:\nThe lexicographically smallest string you can attain by choosing any available path;\nThe number of paths that yield this string.\nExample\ninput\nCopy\n3\n2\n00\n00\n4\n1101\n1100\n8\n00100111\n11101101\noutput\nCopy\n000\n2\n11000\n1\n001001101\n4\nNote\nIn the first test case, the lexicographically smallest string is\n000\n. There are two paths that yield this string:\nIn the second test case, the lexicographically smallest string is\n11000\n. There is only one path that yields this string:",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1300"
        ]
    },
    {
        "title": "A. Shuffle Party",
        "description": "You are given an array\na\n1\n,\na\n2\n,…,\na\nn\n. Initially,\na\ni\n=i\nfor each\n1≤i≤n\n.\nThe operation\nswap(k)\nfor an integer\nk≥2\nis defined as follows:\nLet\nd\nbe the largest divisor\n†\n†\nof\nk\nwhich is not equal to\nk\nitself. Then swap the elements\na\nd\nand\na\nk\n.\nSuppose you perform\nswap(i)\nfor each\ni=2,3,…,n\nin this exact order. Find the position of\n1\nin the resulting array. In other words, find such\nj\nthat\na\nj\n=1\nafter performing these operations.\n†\n†\nAn integer\nx\nis a divisor of\ny\nif there exists an integer\nz\nsuch that\ny=x⋅z\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe only line of each test case contains one integer\nn\n(\n1≤n≤\n10\n9\n) — the length of the array\na\n.\nOutput\nFor each test case, output the position of\n1\nin the resulting array.\nExample\ninput\nCopy\n4\n1\n4\n5\n120240229\noutput\nCopy\n1\n4\n4\n67108864\nNote\nIn the first test case, the array is\n[1]\nand there are no operations performed.\nIn the second test case,\na\nchanges as follows:\nInitially,\na\nis\n[1,2,3,4]\n.\nAfter performing\nswap(2)\n,\na\nchanges to\n[\n2\n–\n,\n1\n–\n,3,4]\n(the elements being swapped are underlined).\nAfter performing\nswap(3)\n,\na\nchanges to\n[\n3\n–\n,1,\n2\n–\n,4]\n.\nAfter performing\nswap(4)\n,\na\nchanges to\n[3,\n4\n–\n,2,\n1\n–\n]\n.\nFinally, the element\n1\nlies on index\n4\n(that is,\na\n4\n=1\n). Thus, the answer is\n4\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Grand Finale: Circles",
        "description": "You are given\nn\ncircles on the plane. The\ni\n-th of these circles is given by a tuple of integers\n(\nx\ni\n,\ny\ni\n,\nr\ni\n)\n, where\n(\nx\ni\n,\ny\ni\n)\nare the coordinates of its center, and\nr\ni\nis the radius of the circle.\nPlease find a circle\nC\nwhich meets the following conditions:\nC\nis contained inside all\nn\ncircles given in the input.\nAmong all circles\nC\nthat meet the first condition, the radius of the circle is maximum.\nLet the largest suitable circle have the radius of\na\n.\nYour output\nC\n, described as\n(x,y,r)\n, will be accepted if it meets the following conditions:\nFor each\ni\n,\n(\nx\ni\n−x\n)\n2\n+(\ny\ni\n−y\n)\n2\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n−\n√\n+r≤\nr\ni\n+max(a,1)⋅\n10\n−7\n.\nThe absolute or relative error of\nr\ndoes not exceed\n10\n−7\n. Formally, your answer is accepted if and only if\n|r−a|\nmax(1,a)\n≤\n10\n−7\n.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of circles.\nThe\ni\n-th of the following\nn\nlines contains three integers\nx\ni\n,\ny\ni\n,\nr\ni\n(\n−\n10\n6\n≤\nx\ni\n,\ny\ni\n≤\n10\n6\n,\n1≤\nr\ni\n≤2⋅\n10\n6\n).\nIt is guaranteed that there is a circle with a radius of at least\n10\n−6\nwhich is contained inside all\nn\ncircles.\nOutput\nOutput three real values,\nx\n,\ny\n, and\nr\n — the coordinates of the center and the radius of the circle.\nExamples\ninput\nCopy\n4\n1 1 3\n-1 1 3\n1 -1 2\n-1 -1 2\noutput\nCopy\n0.0000000000000000 -0.7637626158259733 0.9724747683480533\ninput\nCopy\n4\n41580 -23621 95642\n-41580 -23621 95642\n0 47821 95642\n0 0 109750\noutput\nCopy\n0.0000000000000000 0.0000000000000000 47821.0000000000000000\nNote\nA two-dimensional plot depicting the first test case is given below. The output circle\nC\nis dashed with blue lines.\nA two-dimensional plot depicting the second test case is given below. The output circle\nC\nis dashed with blue lines.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "*3300"
        ]
    },
    {
        "title": "E. Yet Yet Another Permutation Problem",
        "description": "You are given a permutation\np\nof length\nn\n.\nPlease count the number of permutations\nq\nof length\nn\nwhich satisfy the following:\nfor each\n1≤i<n\n,\nmax(\nq\n1\n,…,\nq\ni\n)≠max(\np\n1\n,…,\np\ni\n)\n.\nSince the answer may be large, output the answer modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n). It is guaranteed that\np\nis a permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the answer modulo\n998244353\n.\nExample\ninput\nCopy\n6\n2\n2 1\n3\n1 2 3\n3\n3 1 2\n4\n2 4 1 3\n5\n3 5 1 4 2\n15\n6 13 2 8 7 11 1 3 9 15 4 5 12 10 14\noutput\nCopy\n1\n3\n2\n4\n18\n424488915\nNote\nIn the first test case,\np=[2,1]\n. The only suitable\nq\nis\n[1,2]\n. Indeed, we need to satisfy the inequality\nq\n1\n≠\np\n1\n. It only holds for\nq=[1,2]\n.\nIn the second test case,\np=[1,2,3]\n. So\nq\nhas to satisfy two inequalities:\nq\n1\n≠\np\n1\nand\nmax(\nq\n1\n,\nq\n2\n)≠max(1,2)=2\n. One can prove that this only holds for the following\n3\npermutations:\nq=[2,3,1]\n: in this case\nq\n1\n=2≠1\nand\nmax(\nq\n1\n,\nq\n2\n)=3≠2\n;\nq=[3,1,2]\n: in this case\nq\n1\n=3≠1\nand\nmax(\nq\n1\n,\nq\n2\n)=3≠2\n;\nq=[3,2,1]\n: in this case\nq\n1\n=3≠1\nand\nmax(\nq\n1\n,\nq\n2\n)=3≠2\n.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "divide and conquer",
            "fft",
            "math",
            "*3400"
        ]
    },
    {
        "title": "D. Bitwise Paradox",
        "description": "You are given two arrays\na\nand\nb\nof size\nn\nalong with a fixed integer\nv\n.\nAn interval\n[l,r]\nis called a good interval if\n(\nb\nl\n∣\nb\nl+1\n∣…∣\nb\nr\n)≥v\n, where\n|\ndenotes the bitwise OR operation. The beauty of a good interval is defined as\nmax(\na\nl\n,\na\nl+1\n,…,\na\nr\n)\n.\nYou are given\nq\nqueries of two types:\n\"1 i x\": assign\nb\ni\n:=x\n;\n\"2 l r\": find the minimum beauty among all good intervals\n[\nl\n0\n,\nr\n0\n]\nsatisfying\nl≤\nl\n0\n≤\nr\n0\n≤r\n. If there is no suitable good interval, output\n−1\ninstead.\nPlease process all queries.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nv\n(\n1≤n≤2⋅\n10\n5\n,\n1≤v≤\n10\n9\n).\nThe second line of each testcase contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe third line of each testcase contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n).\nThe fourth line of each testcase contains one integer\nq\n(\n1≤q≤2⋅\n10\n5\n).\nThe\ni\n-th of the following\nq\nlines contains the description of queries. Each line is of one of two types:\n\"1 i x\" (\n1≤i≤n\n,\n1≤x≤\n10\n9\n)\n;\n\"2 l r\" (\n1≤l≤r≤n\n).\nIt is guaranteed that both the sum of\nn\nand the sum of\nq\nover all test cases do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the answers for all queries of the second type.\nExample\ninput\nCopy\n3\n3 7\n2 1 3\n2 2 3\n4\n2 1 3\n1 2 5\n2 2 3\n2 1 3\n4 5\n5 1 2 4\n4 2 3 3\n6\n2 1 4\n1 3 15\n2 3 4\n2 2 4\n1 2 13\n2 1 4\n1 5\n6\n4\n1\n2 1 1\noutput\nCopy\n-1 3 2 \n5 2 2 1 \n-1 \nNote\nIn the first test case,\na=[2,1,3]\n,\nb=[2,2,3]\n, and\nv=7\n.\nThe first query is of the second type and has\nl=1\nand\nr=3\n. The largest interval available is\n[1,3]\n, and its bitwise OR is\nb\n1\n∣\nb\n2\n∣\nb\n3\n=3\nwhich is less than\nv\n. Thus, no good interval exists.\nThe second query asks to change\nb\n2\nto\n5\n, so\nb\nbecomes\n[2,5,3]\n.\nThe third query is of the second type and has\nl=2\nand\nr=3\n. There are three possible intervals:\n[2,2]\n,\n[3,3]\n, and\n[2,3]\n. However,\nb\n2\n=5<v\n,\nb\n3\n=3<v\n. So only the last interval is good: it has\nb\n2\n∣\nb\n3\n=7\n. The answer is thus\nmax(\na\n2\n,\na\n3\n)=3\n.\nThe fourth query is of the second type and has\nl=1\nand\nr=3\n. There are three good intervals:\n[1,2]\n,\n[2,3]\n, and\n[1,3]\n. Their beauty is\n2\n,\n3\n,\n3\ncorrespondingly. The answer is thus\n2\n.\nIn the second test case,\na=[5,1,2,4]\n,\nb=[4,2,3,3]\n, and\nv=5\n.\nThe first query has\nl=1\nand\nr=4\n. The only good intervals are:\n[1,2]\n,\n[1,3]\n,\n[1,4]\n. Their beauty is\n5\n,\n5\n,\n5\ncorrespondingly. The answer is thus\n5\n.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "data structures",
            "greedy",
            "two pointers",
            "*3100"
        ]
    },
    {
        "title": "C. Pokémon Arena",
        "description": "You are at a dueling arena. You also possess\nn\nPokémons. Initially, only the\n1\n-st Pokémon is standing in the arena.\nEach Pokémon has\nm\nattributes. The\nj\n-th attribute of the\ni\n-th Pokémon is\na\ni,j\n. Each Pokémon also has a cost to be hired: the\ni\n-th Pokémon's cost is\nc\ni\n.\nYou want to have the\nn\n-th Pokémon stand in the arena. To do that, you can perform the following two types of operations any number of times in any order:\nChoose three integers\ni\n,\nj\n,\nk\n(\n1≤i≤n\n,\n1≤j≤m\n,\nk>0\n), increase\na\ni,j\nby\nk\npermanently. The cost of this operation is\nk\n.\nChoose two integers\ni\n,\nj\n(\n1≤i≤n\n,\n1≤j≤m\n) and hire the\ni\n-th Pokémon to duel with the current Pokémon in the arena based on the\nj\n-th attribute. The\ni\n-th Pokémon will win if\na\ni,j\nis greater than or equal to the\nj\n-th attribute of the current Pokémon in the arena (otherwise, it will lose). After the duel, only the winner will stand in the arena. The cost of this operation is\nc\ni\n.\nFind the minimum cost you need to pay to have the\nn\n-th Pokémon stand in the arena.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤4⋅\n10\n5\n,\n1≤m≤2⋅\n10\n5\n,\n2≤n⋅m≤4⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n).\nThe\ni\n-th of the following\nn\nlines contains\nm\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n1≤\na\ni,j\n≤\n10\n9\n).\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, output the minimum cost to make the\nn\n-th Pokémon stand in the arena.\nExample\ninput\nCopy\n4\n3 3\n2 3 1\n2 9 9\n6 1 7\n1 2 1\n3 3\n2 3 1\n9 9 9\n6 1 7\n1 2 1\n4 2\n2 8 3 5\n18 24\n17 10\n1 10\n1 1\n6 3\n21412674 3212925 172015806 250849370 306960171 333018900\n950000001 950000001 950000001\n821757276 783362401 760000001\n570000001 700246226 600757652\n380000001 423513575 474035234\n315201473 300580025 287023445\n1 1 1\noutput\nCopy\n2\n6\n17\n1224474550\nNote\nIn the first test case, the attribute array of the\n1\n-st Pokémon (which is standing in the arena initially) is\n[2,9,9]\n.\nIn the first operation, you can choose\ni=3\n,\nj=1\n,\nk=1\n, and increase\na\n3,1\nby\n1\npermanently. Now the attribute array of the\n3\n-rd Pokémon is\n[2,2,1]\n. The cost of this operation is\nk=1\n.\nIn the second operation, you can choose\ni=3\n,\nj=1\n, and hire the\n3\n-rd Pokémon to duel with the current Pokémon in the arena based on the\n1\n-st attribute. Since\na\ni,j\n=\na\n3,1\n=2≥2=\na\n1,1\n, the\n3\n-rd Pokémon will win. The cost of this operation is\nc\n3\n=1\n.\nThus, we have made the\n3\n-rd Pokémon stand in the arena within the cost of\n2\n. It can be proven that\n2\nis minimum possible.\nIn the second test case, the attribute array of the\n1\n-st Pokémon in the arena is\n[9,9,9]\n.\nIn the first operation, you can choose\ni=2\n,\nj=3\n,\nk=2\n, and increase\na\n2,3\nby\n2\npermanently. Now the attribute array of the\n2\n-nd Pokémon is\n[6,1,9]\n. The cost of this operation is\nk=2\n.\nIn the second operation, you can choose\ni=2\n,\nj=3\n, and hire the\n2\n-nd Pokémon to duel with the current Pokémon in the arena based on the\n3\n-rd attribute. Since\na\ni,j\n=\na\n2,3\n=9≥9=\na\n1,3\n, the\n2\n-nd Pokémon will win. The cost of this operation is\nc\n2\n=3\n.\nIn the third operation, you can choose\ni=3\n,\nj=2\n, and hire the\n3\n-rd Pokémon to duel with the current Pokémon in the arena based on the\n2\n-nd attribute. Since\na\ni,j\n=\na\n1,2\n=2≥1=\na\n2,2\n, the\n3\n-rd Pokémon can win. The cost of this operation is\nc\n3\n=1\n.\nThus, we have made the\n3\n-rd Pokémon stand in the arena within the cost of\n6\n. It can be proven that\n6\nis minimum possible.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "graphs",
            "greedy",
            "implementation",
            "shortest paths",
            "sortings",
            "*2400"
        ]
    },
    {
        "title": "B. Pinball",
        "description": "There is a one-dimensional grid of length\nn\n. The\ni\n-th cell of the grid contains a character\ns\ni\n, which is either '<' or '>'.\nWhen a pinball is placed on one of the cells, it moves according to the following rules:\nIf the pinball is on the\ni\n-th cell and\ns\ni\nis '<', the pinball moves one cell to the left in the next second. If\ns\ni\nis '>', it moves one cell to the right.\nAfter the pinball has moved, the character\ns\ni\nis inverted (i. e. if\ns\ni\nused to be '<', it becomes '>', and vice versa).\nThe pinball stops moving when it leaves the grid: either from the left border or from the right one.\nYou need to answer\nn\nindependent queries. In the\ni\n-th query, a pinball will be placed on the\ni\n-th cell. Note that we always place a pinball on the initial grid.\nFor each query, calculate how many seconds it takes the pinball to leave the grid. It can be shown that the pinball will always leave the grid within a finite number of steps.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n). The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤5⋅\n10\n5\n).\nThe second line of each test case contains a string\ns\n1\ns\n2\n…\ns\nn\nof length\nn\nconsisting of characters '<' and '>'.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, for each\ni\n(\n1≤i≤n\n) output the answer if a pinball is initially placed on the\ni\n-th cell.\nExample\ninput\nCopy\n3\n3\n><<\n4\n<<<<\n6\n<><<<>\noutput\nCopy\n3 6 5 \n1 2 3 4 \n1 4 7 10 8 1 \nNote\nIn the first test case, the movement of the pinball for\ni=1\nis shown in the following pictures. It takes the pinball\n3\nseconds to leave the grid.\nThe movement of the pinball for\ni=2\nis shown in the following pictures. It takes the pinball\n6\nseconds to leave the grid.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "implementation",
            "math",
            "two pointers",
            "*2000"
        ]
    },
    {
        "title": "A. Bitwise Operation Wizard",
        "description": "This is an interactive problem.\nThere is a secret sequence\np0,p1,…,pn−1\n, which is a permutation of\n{0,1,…,n−1}\n.\nYou need to find any two indices\ni\nand\nj\nsuch that\npi⊕pj\nis maximized, where\n⊕\ndenotes the bitwise XOR operation.\nTo do this, you can ask queries. Each query has the following form: you pick arbitrary indices\na\n,\nb\n,\nc\n, and\nd\n(\n0≤a,b,c,d<n\n). Next, the jury calculates\nx=(pa∣pb)\nand\ny=(pc∣pd)\n, where\n|\ndenotes the bitwise OR operation. Finally, you receive the result of comparison between\nx\nand\ny\n. In other words, you are told if\nx<y\n,\nx>y\n, or\nx=y\n.\nPlease find any two indices\ni\nand\nj\n(\n0≤i,j<n\n) such that\npi⊕pj\nis maximum among all such pairs, using at most\n3n\nqueries. If there are multiple pairs of indices satisfying the condition, you may output any one of them.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤103\n). The description of the test cases follows.\nInteraction\nThe first line of each test case contains one integer\nn\n(\n2≤n≤104\n). At this moment, the permutation\np0,p1,…,pn−1\nis chosen. The interactor in this task is not adaptive. In other words, the sequence\np\nis fixed in every test case and does not change during the interaction.\nTo ask a query, you need to pick four indices\na\n,\nb\n,\nc\n, and\nd\n(\n0≤a,b,c,d<n\n) and print the line of the following form:\n\"? a b c d\"\nAfter that, you receive:\n\"<\" if\n(pa∣pb)<(pc∣pd)\n;\n\"=\" if\n(pa∣pb)=(pc∣pd)\n;\n\">\" if\n(pa∣pb)>(pc∣pd)\n.\nYou can make at most\n3n\nqueries of this form.\nNext, if your program has found a pair of indices\ni\nand\nj\n(\n0≤i,j<n\n) such that\npi⊕pj\nis maximized, print the line of the following form:\n\"! i j\"\nNote that this line is not considered a query and is not taken into account when counting the number of queries asked.\nAfter this, proceed to the next test case.\nIf you make more than\n3n\nqueries during an interaction, your program must terminate immediately, and you will receive the Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer for a test case, do not forget to output the end of line and flush the output. Otherwise, you will get the verdict Idleness Limit Exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n104\n.\nHacks\nTo hack, follow the test format below.\nThe first line contains the number of test cases\nt\n(\n1≤t≤103\n). The description of the test cases follows.\nThe first line of each test case contains one integer\nn\n(\n2≤n≤104\n).\nThe second line of each test case contains\nn\nintegers\np0,p1,…,pn−1\n, which represent a permutation of integers from\n0\nto\nn−1\n.\nThe sum of\nn\nover all test cases should not exceed\n104\n.\nExample\ninput\nCopy\n2\n4\n\n<\n\n=\n\n>\n\n2\noutput\nCopy\n? 0 2 3 1\n\n? 1 1 2 3\n\n? 1 2 0 3\n\n! 3 2\n\n! 0 1\nNote\nIn the first test case, the hidden permutation is\np=[0,3,1,2]\n.\nFor the query \"? 0 2 3 1\", the jury return \"<\" because\n(p0∣p2)=(0∣1)=1<(p3∣p1)=(2∣3)=3\n.\nFor the query \"? 1 1 2 3\", the jury return \"=\" because\n(p1∣p1)=(3∣3)=3=(p2∣p3)=(1∣2)=3\n.\nFor the query \"? 1 2 0 3\", the jury return \">\" because\n(p1∣p2)=(3∣1)=3>(p0∣p3)=(0∣2)=2\n.\nThe answer\ni=3\nand\nj=2\nis valid:\n(p3⊕p2)=(2⊕1)=3\nis indeed equal to the maximum possible value of\npi⊕pj\n. Another valid answer would be\ni=0\nand\nj=1\n. As the number of queries does not exceed\n3n=12\n, the answer is considered correct.\nIn the second test case,\nn=2\n, so\np\nis either\n[0,1]\nor\n[1,0]\n. In any case,\np0⊕p1=1\nis maximum possible.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "interactive",
            "math",
            "*1700"
        ]
    },
    {
        "title": "F. Andrey's Tree",
        "description": "Master Andrey loves trees\n†\n†\nvery much, so he has a tree consisting of\nn\nvertices.\nBut it's not that simple. Master Timofey decided to steal one vertex from the tree. If Timofey stole vertex\nv\nfrom the tree, then vertex\nv\nand all edges with one end at vertex\nv\nare removed from the tree, while the numbers of other vertices remain unchanged. To prevent Andrey from getting upset, Timofey decided to make the resulting graph a tree again. To do this, he can add edges between any vertices\na\nand\nb\n, but when adding such an edge, he must pay\n|a−b|\ncoins to the Master's Assistance Center.\nNote that the resulting tree does not contain vertex\nv\n.\nTimofey has not yet decided which vertex\nv\nhe will remove from the tree, so he wants to know for each vertex\n1≤v≤n\n, the minimum number of coins needed to be spent to make the graph a tree again after removing vertex\nv\n, as well as which edges need to be added.\n†\n†\nA tree is an undirected connected graph without cycles.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n5≤n≤2⋅\n10\n5\n) — the number of vertices in Andrey's tree.\nThe next\nn−1\nlines contain a description of the tree's edges. The\ni\n-th of these lines contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n) — the numbers of vertices connected by the\ni\n-th edge.\nIt is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output the answer in the following format:\nFor each vertex\nv\n(in the order from\n1\nto\nn\n), in the first line output two integers\nw\nand\nm\n— the minimum number of coins that need to be spent to make the graph a tree again after removing vertex\nv\n, and the number of added edges.\nThen output\nm\nlines, each containing two integers\na\nand\nb\n(\n1≤a,b≤n,a≠v,b≠v\n,\na≠b\n) — the ends of the added edge.\nIf there are multiple ways to add edges, you can output any solution with the minimum cost.\nExample\ninput\nCopy\n3\n5\n1 3\n1 4\n4 5\n3 2\n5\n4 2\n4 3\n3 5\n5 1\n5\n2 1\n1 5\n1 4\n1 3\noutput\nCopy\n1 1\n3 4\n\n0 0\n\n1 1\n1 2\n\n2 1\n3 5\n\n0 0\n\n0 0\n\n0 0\n\n1 1\n1 2\n\n1 1\n1 2\n\n1 1\n1 2\n\n3 3\n2 3\n4 5\n3 4\n\n0 0\n\n0 0\n\n0 0\n\n0 0\nNote\nIn the first test case:\nConsider the removal of vertex\n4\n:\nThe optimal solution would be to add an edge from vertex\n5\nto vertex\n3\n. Then we will spend\n|5−3|=2\ncoins.\nIn the third test case:\nConsider the removal of vertex\n1\n:\nThe optimal solution would be:\nAdd an edge from vertex\n2\nto vertex\n3\n, spending\n|2−3|=1\ncoin.\nAdd an edge from vertex\n3\nto vertex\n4\n, spending\n|3−4|=1\ncoin.\nAdd an edge from vertex\n4\nto vertex\n5\n, spending\n|4−5|=1\ncoin.\nThen we will spend a total of\n1+1+1=3\ncoins.\nConsider the removal of vertex\n2\n:\nNo edges need to be added, as the graph will remain a tree after removing the vertex.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "dfs and similar",
            "dsu",
            "greedy",
            "implementation",
            "trees",
            "*2800"
        ]
    },
    {
        "title": "E. Distance Learning Courses in MAC",
        "description": "The New Year has arrived in the Master's Assistance Center, which means it's time to introduce a new feature!\nNow students are given distance learning courses, with a total of\nn\ncourses available. For the\ni\n-th distance learning course, a student can receive a grade ranging from\nx\ni\nto\ny\ni\n.\nHowever, not all courses may be available to each student. Specifically, the\nj\n-th student is only given courses with numbers from\nl\nj\nto\nr\nj\n, meaning the distance learning courses with numbers\nl\nj\n,\nl\nj\n+1,…,\nr\nj\n.\nThe creators of the distance learning courses have decided to determine the final grade in a special way. Let the\nj\n-th student receive grades\nc\nl\nj\n,\nc\nl\nj\n+1\n,…,\nc\nr\nj\nfor their distance learning courses. Then their final grade will be equal to\nc\nl\nj\n|\nc\nl\nj\n+1\n|\n…\n|\nc\nr\nj\n, where\n|\ndenotes the bitwise OR operation.\nSince the chatbot for solving distance learning courses is broken, the students have asked for your help. For each of the\nq\nstudents, tell them the maximum final grade they can achieve.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of distance learning courses.\nEach of the following\nn\nlines contains two integers\nx\ni\nand\ny\ni\n(\n0≤\nx\ni\n≤\ny\ni\n<\n2\n30\n) — the minimum and maximum grade that can be received for the\ni\n-th course.\nThe next line contains a single integer\nq\n(\n1≤q≤2⋅\n10\n5\n) — the number of students.\nEach of the following\nq\nlines contains two integers\nl\nj\nand\nr\nj\n(\n1≤\nl\nj\n≤\nr\nj\n≤n\n) — the minimum and maximum course numbers accessible to the\nj\n-th student.\nIt is guaranteed that the sum of\nn\nover all test cases and the sum of\nq\nover all test cases do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nq\nintegers, where the\nj\n-th integer is the maximum final grade that the\nj\n-th student can achieve.\nExample\ninput\nCopy\n3\n2\n0 1\n3 4\n3\n1 1\n1 2\n2 2\n4\n1 7\n1 7\n3 10\n2 2\n5\n1 3\n3 4\n2 3\n1 4\n1 2\n6\n1 2\n2 2\n0 1\n1 1\n3 3\n0 0\n4\n3 4\n5 5\n2 5\n1 2\noutput\nCopy\n1 5 4 \n15 11 15 15 7 \n1 3 3 3 \nNote\nIn the first test case:\nThe maximum grade for the first student is\n1\n:\nOn the first distance learning course, he will receive a grade of\n1\n.\nTherefore, the final grade is\n1\n.\nThe maximum grade for the second student is\n5\n:\nOn the first distance learning course, he will receive a grade of\n1\n.\nOn the second distance learning course, he will receive a grade of\n4\n.\nTherefore, the final grade is\n1\n|\n4\n=\n5\n.\nThe maximum grade for the third student is\n4\n:\nOn the second distance learning course, he will receive a grade of\n4\n.\nTherefore, the final grade is\n4\n.\nIn the second test case:\nThe maximum grade for the first student is\n15\n:\nOn the first distance learning course, he will receive a grade of\n7\n.\nOn the second distance learning course, he will receive a grade of\n4\n.\nOn the third distance learning course, he will receive a grade of\n8\n.\nTherefore, the final grade is\n7\n|\n4\n|\n8\n=\n15\n.\nThe maximum grade for the second student is\n11\n:\nOn the third distance learning course, he will receive a grade of\n9\n.\nOn the fourth distance learning course, he will receive a grade of\n2\n.\nTherefore, the final grade is\n9\n|\n2\n=\n11\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "data structures",
            "greedy",
            "math",
            "*2400"
        ]
    },
    {
        "title": "D. Exam in MAC",
        "description": "The Master's Assistance Center has announced an entrance exam, which consists of the following.\nThe candidate is given a set\ns\nof size\nn\nand some strange integer\nc\n. For this set, it is needed to calculate the number of pairs of integers\n(x,y)\nsuch that\n0≤x≤y≤c\n,\nx+y\nis not contained in the set\ns\n, and also\ny−x\nis not contained in the set\ns\n.\nYour friend wants to enter the Center. Help him pass the exam!\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nc\n(\n1≤n≤3⋅\n10\n5\n,\n1≤c≤\n10\n9\n) — the size of the set and the strange integer.\nThe second line of each test case contains\nn\nintegers\ns\n1\n,\ns\n2\n,…,\ns\nn\n(\n0≤\ns\n1\n<\ns\n2\n<…<\ns\nn\n≤c\n) — the elements of the set\ns\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of suitable pairs of integers.\nExample\ninput\nCopy\n8\n3 3\n1 2 3\n1 179\n57\n4 6\n0 3 5 6\n1 1\n1\n5 10\n0 2 4 8 10\n5 10\n1 3 5 7 9\n4 10\n2 4 6 7\n3 1000000000\n228 1337 998244353\noutput\nCopy\n3\n16139\n10\n2\n33\n36\n35\n499999998999122959\nNote\nIn the first test case, the following pairs are suitable:\n(0,0)\n,\n(2,2)\n,\n(3,3)\n.\nIn the third test case, the following pairs are suitable:\n(0,1)\n,\n(0,2)\n,\n(0,4)\n,\n(1,3)\n,\n(2,6)\n,\n(3,4)\n,\n(3,5)\n,\n(4,5)\n,\n(4,6)\n,\n(5,6)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "implementation",
            "math",
            "*1800"
        ]
    },
    {
        "title": "C. Messenger in MAC",
        "description": "In the new messenger for the students of the Master's Assistance Center, Keftemerum, an update is planned, in which developers want to optimize the set of messages shown to the user. There are a total of\nn\nmessages. Each message is characterized by two integers\na\ni\nand\nb\ni\n. The time spent reading the set of messages with numbers\np\n1\n,\np\n2\n,…,\np\nk\n(\n1≤\np\ni\n≤n\n, all\np\ni\nare distinct) is calculated by the formula:\n∑\ni=1\nk\na\np\ni\n+\n∑\ni=1\nk−1\n|\nb\np\ni\n−\nb\np\ni+1\n|\nk\nk\n1\nNote that the time to read a set of messages consisting of one message with number\np\n1\nis equal to\na\np\n1\n. Also, the time to read an empty set of messages is considered to be\n0\n.\nThe user can determine the time\nl\nthat he is willing to spend in the messenger. The messenger must inform the user of the maximum possible size of the set of messages, the reading time of which does not exceed\nl\n. Note that the maximum size of the set of messages can be equal to\n0\n.\nThe developers of the popular messenger failed to implement this function, so they asked you to solve this problem.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nl\n(\n1≤n≤2000\n,\n1≤l≤\n10\n9\n) — the number of messages and the time the user is willing to spend in the messenger.\nThe\ni\n-th of the next\nn\nlines contains two integers\na\ni\nand\nb\ni\n(\n1≤\na\ni\n,\nb\ni\n≤\n10\n9\n) — characteristics of the\ni\n-th message.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n4⋅\n10\n6\n.\nOutput\nFor each test case, output a single integer — the maximum possible size of a set of messages, the reading time of which does not exceed\nl\n.\nExample\ninput\nCopy\n5\n5 8\n4 3\n1 5\n2 4\n4 3\n2 3\n1 6\n4 10\n3 12\n4 8\n2 1\n2 12\n5 26\n24 7\n8 28\n30 22\n3 8\n17 17\n5 14\n15 3\n1000000000 998244353\n179 239\n228 1337\n993 1007\noutput\nCopy\n3\n1\n2\n1\n0\nNote\nIn the first test case, you can take a set of three messages with numbers\np\n1\n=3\n,\np\n2\n=2\n, and\np\n3\n=5\n. The time spent reading this set is equal to\na\n3\n+\na\n2\n+\na\n5\n+|\nb\n3\n−\nb\n2\n|+|\nb\n2\n−\nb\n5\n|=2+1+2+|4−5|+|5−3|=8\n.\nIn the second test case, you can take a set of one message with number\np\n1\n=1\n. The time spent reading this set is equal to\na\n1\n=4\n.\nIn the fifth test case, it can be shown that there is no such non-empty set of messages, the reading time of which does not exceed\nl\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "data structures",
            "dp",
            "greedy",
            "sortings",
            "*1800"
        ]
    },
    {
        "title": "B. Informatics in MAC",
        "description": "In the Master's Assistance Center, Nyam-Nyam was given a homework assignment in informatics.\nThere is an array\na\nof length\nn\n, and you want to divide it into\nk>1\nsubsegments\n†\n†\nin such a way that the\nMEX\n‡\non each subsegment is equal to the same integer.\nHelp Nyam-Nyam find any suitable division, or determine that it does not exist.\n†\n†\nA division of an array into\nk\nsubsegments is defined as\nk\npairs of integers\n(\nl\n1\n,\nr\n1\n),(\nl\n2\n,\nr\n2\n),…,(\nl\nk\n,\nr\nk\n)\nsuch that\nl\ni\n≤\nr\ni\nand for each\n1≤j≤k−1\n,\nl\nj+1\n=\nr\nj\n+1\n, and also\nl\n1\n=1\nand\nr\nk\n=n\n. These pairs represent the subsegments themselves.\n‡\nMEX\n‡\nof an array is the smallest non-negative integer that does not belong to the array.\nFor example:\nMEX\nof the array\n[2,2,1]\nis\n0\n, because\n0\ndoes not belong to the array.\nMEX\nof the array\n[3,1,0,1]\nis\n2\n, because\n0\nand\n1\nbelong to the array, but\n2\ndoes not.\nMEX\nof the array\n[0,3,1,2]\nis\n4\n, because\n0\n,\n1\n,\n2\n, and\n3\nbelong to the array, but\n4\ndoes not.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer\n−1\nif a suitable division does not exist.\nOtherwise, on the first line, output an integer\nk\n(\n2≤k≤n\n) — the number of subsegments in the division.\nThen output\nk\nlines — the division into subsegments. The\ni\n-th line should contain two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the boundaries of the\ni\n-th subsegment.\nThe following conditions must be satisfied:\nFor all\n1≤j≤k−1\n,\nl\nj+1\n=\nr\nj\n+1\n;\nl\n1\n=1\n,\nr\nk\n=n\n.\nIf there are multiple possible solutions, output any of them.\nExample\ninput\nCopy\n5\n2\n0 0\n5\n0 1 2 3 4\n8\n0 1 7 1 0 1 0 3\n3\n2 2 2\n4\n0 1 2 0\noutput\nCopy\n2\n1 1\n2 2\n-1\n3\n1 3\n4 5\n6 8\n3\n1 1\n2 2\n3 3\n-1\nNote\nIn the first test case, the array\na\ncan be divided into\n2\nsubsegments with boundaries\n[1,1]\nand\n[2,2]\n:\nMEX\nof the first subsegment\n[0]\nis\n1\n, as\n0\nbelongs to the subsegment, but\n1\ndoes not.\nMEX\nof the second subsegment\n[0]\nis\n1\n, as\n0\nbelongs to the subsegment, but\n1\ndoes not.\nIn the second test case, it can be proven that the required division does not exist.\nIn the third test case, the array\na\ncan be divided into\n3\nsubsegments with boundaries\n[1,3]\n,\n[4,5]\n,\n[6,8]\n:\nMEX\nof the first subsegment\n[0,1,7]\nis\n2\n, as\n0\nand\n1\nbelong to the subsegment, but\n2\ndoes not.\nMEX\nof the second subsegment\n[1,0]\nis\n2\n, as\n0\nand\n1\nbelong to the subsegment, but\n2\ndoes not.\nMEX\nof the third subsegment\n[1,0,3]\nis\n2\n, as\n0\nand\n1\nbelong to the subsegment, but\n2\ndoes not.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1200"
        ]
    },
    {
        "title": "A. Entertainment in MAC",
        "description": "Congratulations, you have been accepted to the Master's Assistance Center! However, you were extremely bored in class and got tired of doing nothing, so you came up with a game for yourself.\nYou are given a string\ns\nand an even integer\nn\n. There are two types of operations that you can apply to it:\nAdd the reversed string\ns\nto the end of the string\ns\n(for example, if\ns=\ncpm, then after applying the operation\ns=\ncpmmpc).\nReverse the current string\ns\n(for example, if\ns=\ncpm, then after applying the operation\ns=\nmpc).\nIt is required to determine the lexicographically smallest\n†\n†\nstring that can be obtained after applying exactly\nn\noperations. Note that you can apply operations of different types in any order, but you must apply exactly\nn\noperations in total.\n†\n†\nA string\na\nis lexicographically smaller than a string\nb\nif and only if one of the following holds:\na\nis a prefix of\nb\n, but\na≠b\n;\nin the first position where\na\nand\nb\ndiffer, the string\na\nhas a letter that appears earlier in the alphabet than the corresponding letter in\nb\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single even integer\nn\n(\n2≤n≤\n10\n9\n) — the number of operations applied to the string\ns\n.\nThe second line of each test case contains a single string\ns\n(\n1≤|s|≤100\n), consisting of lowercase English letters, — the string to which the operations are applied.\nOutput\nFor each test case, output a single line — the lexicographically smallest string that can be obtained after applying exactly\nn\noperations.\nExample\ninput\nCopy\n5\n4\ncpm\n2\ngrib\n10\nkupitimilablodarbuz\n1000000000\ncapybara\n6\nabacaba\noutput\nCopy\ncpm\nbirggrib\nkupitimilablodarbuz\narabypaccapybara\nabacaba\nNote\nIn the first test case, you can apply the operation of the second type (i.e., reverse the string\ns\n)\n4\ntimes. Then the string\ns\nwill remain equal to cpm.\nIn the second test case, you can do the following:\nApply the operation of the second type, after which\ns\nwill become equal to birg.\nApply operation of the first type (i.e., add the reversed string\ns\nto the end of the string\ns\n), after which\ns\nwill become equal to birggrib.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "strings",
            "*800"
        ]
    },
    {
        "title": "E. Weird LCM Operations",
        "description": "Given an integer\nn\n, you construct an array\na\nof\nn\nintegers, where\na\ni\n=i\nfor all integers\ni\nin the range\n[1,n]\n. An operation on this array is defined as follows:\nSelect three distinct indices\ni\n,\nj\n, and\nk\nfrom the array, and let\nx=\na\ni\n,\ny=\na\nj\n, and\nz=\na\nk\n.\nUpdate the array as follows:\na\ni\n=lcm(y,z)\n,\na\nj\n=lcm(x,z)\n, and\na\nk\n=lcm(x,y)\n, where\nlcm\nrepresents the least common multiple.\nYour task is to provide a possible sequence of operations, containing at most\n⌊\nn\n6\n⌋+5\noperations such that after executing these operations, if you create a set containing the greatest common divisors (GCDs) of all subsequences with a size greater than\n1\n, then all numbers from\n1\nto\nn\nshould be present in this set.\nAfter all the operations\na\ni\n≤\n10\n18\nshould hold for all\n1≤i≤n\n.\nWe can show that an answer always exists.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n2\n) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains an integer\nn\n(\n3≤n≤3⋅\n10\n4\n) — the length of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n4\n.\nOutput\nThe first line should contain an integer\nk\n(\n0≤k≤⌊\nn\n6\n⌋+5\n) — where\nk\nis the number of operations.\nThe next\nk\nlines should contain the description of each operation i.e.\n3\nintegers\ni\n,\nj\nand\nk\n, where\n1≤i,j,k≤n\nand all must be distinct.\nExample\ninput\nCopy\n3\n3\n4\n7\noutput\nCopy\n1\n1 2 3\n1\n1 3 4\n3\n3 5 7\n5 6 7\n2 3 4\nNote\nIn the third test case,\na=[1,2,3,4,5,6,7]\n.\nFirst operation:\ni=3\n,\nj=5\n,\nk=7\nx=3\n,\ny=5\n,\nz=7\n.\na=[1,2,lcm(y,z),4,lcm(x,z),6,lcm(x,y)]\n=\n[1,2,35,4,21,6,15]\n.\nSecond operation:\ni=5\n,\nj=6\n,\nk=7\nx=21\n,\ny=6\n,\nz=15\n.\na=[1,2,35,4,lcm(y,z),lcm(x,z),lcm(x,y)]\n=\n[1,2,35,4,30,105,42]\n.\nThird operation:\ni=2\n,\nj=3\n,\nk=4\nx=2\n,\ny=35\n,\nz=4\n.\na=[1,lcm(y,z),lcm(x,z),lcm(x,y),30,105,42]\n=\n[1,140,4,70,30,105,42]\n.\nSubsequences whose GCD equal to\ni\nis as follows:\ngcd(\na\n1\n,\na\n2\n)=gcd(1,140)=1\ngcd(\na\n3\n,\na\n4\n)=gcd(4,70)=2\ngcd(\na\n5\n,\na\n6\n,\na\n7\n)=gcd(30,105,42)=3\ngcd(\na\n2\n,\na\n3\n)=gcd(140,4)=4\ngcd(\na\n2\n,\na\n4\n,\na\n5\n,\na\n6\n)=gcd(140,70,30,105)=5\ngcd(\na\n5\n,\na\n7\n)=gcd(30,42)=6\ngcd(\na\n2\n,\na\n4\n,\na\n6\n,\na\n7\n)=gcd(140,70,105,42)=7",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "number theory",
            "*3000"
        ]
    },
    {
        "title": "D2. XOR Break — Game Version",
        "description": "This is an interactive problem.\nThis is the game version of the problem. Note that the solution of this problem may or may not share ideas with the solution of the solo version. You can solve and get points for both versions independently.\nAlice and Bob are playing a game. The game starts with a positive integer\nn\n, with players taking turns. On each turn of the game, the following sequence of events takes place:\nThe player having the integer\np\nbreaks it into two integers\np\n1\nand\np\n2\n, where\n0<\np\n1\n<p\n,\n0<\np\n2\n<p\nand\np\n1\n⊕\np\n2\n=p\n.\nIf no such\np\n1\n,\np\n2\nexist, the player loses.\nOtherwise, the opponent does either select the integer\np\n1\nor\np\n2\n.\nThe game continues with the selected integer. The opponent will try to break it.\nAs Alice, your goal is to win. You can execute a maximum of\n63\nbreak operations. You have the choice to play first or second. The system will act for Bob.\nHere\n⊕\ndenotes the bitwise XOR operation.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n18\n) — the number the game starts with.\nInteraction\nFor each test case, the interaction begins by reading the integer\nn\n.\nAfter reading\nn\n, print a single line containing either \"first\" or \"second\", denoting what you want to play as (as first or second correspondingly).\nOn Alice's turn, you are required to print two positive integers,\np\n1\nand\np\n2\nsuch that\n0<\np\n1\n<p\n,\n0<\np\n2\n<p\nand\np\n1\n⊕\np\n2\n=p\n. Here,\np\nequals one of the two integers printed by Bob in the previous turn. If no turn has occurred previously,\np\nis equal to\nn\n. If Alice cannot perform a break operation, print \"0 0\" to receive a Wrong answer verdict.\nOn Bob's turn, you should read two integers,\np\n1\nand\np\n2\nsuch that\n0<\np\n1\n<p\n,\n0<\np\n2\n<p\nand\np\n1\n⊕\np\n2\n=p\n. Here,\np\nequals one of the two integers printed by Alice in the previous turn. If no turn has occurred previously,\np\nis equal to\nn\n. If Bob cannot perform a break operation\np\n1\n=0\nand\np\n2\n=0\nin which case you should proceed to the next test case.\nIf any break operation performed by Alice is invalid, the interactor prints \"-1 -1\" and your code should promptly exit to receive a wrong answer verdict.\nIf Alice performs\n63\nturns and Bob can still execute a break operation on the current integers, the interactor prints \"-1 -1\", and your code should promptly exit to receive a wrong answer verdict.\nAfter printing a query, do not forget to output the end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nIn this problem, hacks are disabled.\nExample\ninput\nCopy\n4\n1\n\n0 0\n3\n\n\n0 0\n13\n\n\n3 4\n\n0 0\n777777770001\n\n\n0 0\noutput\nCopy\nsecond\n\n\nfirst\n2 1\n\n\nfirst\n10 7\n\n1 2\n\n\nfirst\n777777770000 1\nNote\nExplanation for the interaction.\nInteractor / Bob Alice Explanation\n4\nt\n1\nn\nfor the first test case\nsecond Alice chooses to go second\n0 0 Bob says he cannot break\np=1\n3\nn\nfor the second test case\nfirst Alice chooses to go first\n1 2 Alice breaks\np=3\ninto\np\n1\n=1\nand\np\n2\n=2\n0 0 Bob says he cannot break\np=1\nor\np=2\n13\nn\nfor the third test case\nfirst Alice chooses to go first\n10 7 Alice breaks\np=13\ninto\np\n1\n=10\nand\np\n2\n=7\n3 4 Bob breaks\np=7\ninto\np\n1\n=3\nand\np\n2\n=4\n1 2 Alice breaks\np=3\ninto\np\n1\n=1\nand\np\n2\n=2\n0 0 Bob says he cannot break\np=1\nor\np=2\n777777770001\nn\nfor the fourth test case\nfirst Alice chooses to go first\n777777770000 1 Alice breaks\np=777777770001\ninto\np\n1\n=777777770000\nand\np\n2\n=1\n0 0 Bob says he cannot perform break operation.\nThis table is for explanation only and does not reflect the actual behavior of the interactor.\nNote that in the last test case Bob could choose\np\n1\nand perform a break operation but he gave up.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "games",
            "greedy",
            "interactive",
            "*2400"
        ]
    },
    {
        "title": "D1. XOR Break — Solo Version",
        "description": "This is the solo version of the problem. Note that the solution of this problem may or may not share ideas with the solution of the game version. You can solve and get points for both versions independently.\nYou can make hacks only if both versions of the problem are solved.\nGiven an integer variable\nx\nwith the initial value of\nn\n. A single break operation consists of the following steps:\nChoose a value\ny\nsuch that\n0<y<x\nand\n0<(x⊕y)<x\n.\nUpdate\nx\nby either setting\nx=y\nor setting\nx=x⊕y\n.\nDetermine whether it is possible to transform\nx\ninto\nm\nusing a maximum of\n63\nbreak operations. If it is, provide the sequence of operations required to achieve\nx=m\n.\nYou don't need to minimize the number of operations.\nHere\n⊕\ndenotes the bitwise XOR operation.\nInput\nThe first line contains one positive integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of a single line containing two integers\nn\nand\nm\n(\n1≤m<n≤\n10\n18\n) — the initial value of\nx\nand the target value of\nx\n.\nOutput\nFor each test case, output your answer in the following format.\nIf it is not possible to achieve\nm\nin\n63\noperations, print\n−1\n.\nOtherwise,\nThe first line should contain\nk\n(\n1≤k≤63\n) — where\nk\nis the number of operations required.\nThe next line should contain\nk+1\nintegers — the sequence where variable\nx\nchanges after each break operation. The\n1\n-st and\nk+1\n-th integers should be\nn\nand\nm\n, respectively.\nExample\ninput\nCopy\n3\n7 3\n4 2\n481885160128643072 45035996273704960\noutput\nCopy\n1\n7 3\n-1\n3\n481885160128643072 337769972052787200 49539595901075456 45035996273704960\nNote\nIn the first test case\nn=7\n, for the first operation\nx=7\nif we choose\ny=3\nthen\n(7⊕3)<7\n, hence we can update\nx\nwith\n3\nwhich is equal to\nm\n.\nIn the second test case\nn=4\n, for the first operation\nx=4\n.\nIf we choose:\ny=1\nthen\n(4⊕1)>4\ny=2\nthen\n(4⊕2)>4\ny=3\nthen\n(4⊕3)>4\nHence we can't do the first operation and it is impossible to make\nx=2\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*2100"
        ]
    },
    {
        "title": "C. Find a Mine",
        "description": "This is an interactive problem.\nYou are given a grid with\nn\nrows and\nm\ncolumns. The coordinates\n(x,y)\nrepresent the cell on the grid, where\nx\n(\n1≤x≤n\n) is the row number counting from the top and\ny\n(\n1≤y≤m\n) is the column number counting from the left. It is guaranteed that there are exactly\n2\nmines in the grid at distinct cells, denoted as\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\n. You are allowed to make no more than\n4\nqueries to the interactor, and after these queries, you need to provide the location of one of the mines.\nIn each query, you can choose any grid cell\n(x,y)\n, and in return, you will receive the minimum Manhattan distance from both the mines to the chosen cell, i.e., you will receive the value\nmin(|x−\nx\n1\n|+|y−\ny\n1\n|,|x−\nx\n2\n|+|y−\ny\n2\n|)\n.\nYour task is to determine the location of one of the mines after making the queries.\nInput\nEach test contains multiple test cases. The first line of input contains a single integer\nt\n(\n1≤t≤3⋅\n10\n3\n) — the number of test cases.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n2≤n≤\n10\n8\n,\n2≤m≤\n10\n8\n) — the number of rows and columns.\nInteraction\nFor each test case, the interaction starts with reading\nn\nand\nm\n.\nThen you are allowed to make at most\n4\nqueries in the following way:\n\"? x y\" (\n1≤x≤n\nand\n1≤y≤m\n)\nAfter each one, you should read an integer\nd\nwhich is equal to\nmin(|x−\nx\n1\n|+|y−\ny\n1\n|,|x−\nx\n2\n|+|y−\ny\n2\n|)\n.\nWhen you have found the location of any one of the mines, print a single line \"! x y\" (without quotes), representing the row and the column of one of the mines. Outputting the answer does not count as a query.\nAfter printing the answer, your program must then continue to solve the remaining test cases, or exit if all test cases have been solved.\nThe interactor for this problem is not adaptive: cells of mines are fixed before any queries are made.\nAfter printing a query, do not forget to output the end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nHacks:\nTo make a hack, use the following format:\nThe first line contains a single integer\nt\n(\n1≤t≤3⋅\n10\n3\n) — the number of test cases.\nThe description of each test case should consist of three lines.\nThe first line contains two integers\nn\nand\nm\n(\n2≤n≤\n10\n8\n,\n2≤m≤\n10\n8\n) — the number of rows and columns.\nThe second line contains the coordinates of the first mine\nx\n1\nand\ny\n1\n(\n1≤\nx\n1\n≤n\n,\n1≤\ny\n1\n≤m\n).\nThe third line contains the coordinates of the second mine\nx\n2\nand\ny\n2\n(\n1≤\nx\n2\n≤n\n,\n1≤\ny\n2\n≤m\n).\nThe mines should be located at different positions.\nExample\ninput\nCopy\n2\n4 4\n\n3\n\n2\n\n2\n\n0\n\n5 5\n\n1\n\n2\n\n3\noutput\nCopy\n? 1 1\n\n? 1 4\n\n? 4 1\n\n? 2 3\n\n! 2 3\n\n? 5 5\n\n? 2 2\n\n? 3 3\n\n! 1 1\nNote\nIn the first test case, we start by querying the upper-left corner\n(1,1)\nand get the result\n3\n, which means that there is a mine on the counter diagonal, and there is no mine above it.\nIn the image below, each cell contains a number indicating the distance to the blue cell. The green cells are candidates to contain the nearest mine.\nThen we ask three cells on that diagonal, and at the last query, we get the result\n0\n, which means that a mine is found at the position\n(2,3)\n.\nThe second mine was located at the position\n(3,2)\n.\nIn the second test case, we start by asking the lower-right corner\n(5,5)\n, and get the result\n1\n, which means that one of the two neighbours contains a mine, let's call it mine\n1\n.\nThen we ask cell\n(2,2)\n. We can see that these green cells don't intersect with the green cells from the first query, so they contain the other mine, let's call it mine\n2\n.\nQuery\n3\nis cell\n(3,3)\n. These cells contain mine\n1\n, but we still don't know where exactly. Nevertheless, we can determine that the only possible cell for mine\n2\nis\n(1,1)\n, because all other candidates are at a distance closer than\n3\nfor this query.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "geometry",
            "greedy",
            "interactive",
            "math",
            "*1700"
        ]
    },
    {
        "title": "B. Yet Another Coin Problem",
        "description": "You have\n5\ndifferent types of coins, each with a value equal to one of the first\n5\ntriangular numbers:\n1\n,\n3\n,\n6\n,\n10\n, and\n15\n. These coin types are available in abundance. Your goal is to find the minimum number of these coins required such that their total value sums up to exactly\nn\n.\nWe can show that the answer always exists.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤\n10\n9\n) — the target value.\nOutput\nFor each test case, output a single number — the minimum number of coins required.\nExample\ninput\nCopy\n14\n1\n2\n3\n5\n7\n11\n12\n14\n16\n17\n18\n20\n98\n402931328\noutput\nCopy\n1\n2\n1\n3\n2\n2\n2\n3\n2\n3\n2\n2\n8\n26862090\nNote\nIn the first test case, for\nn=1\n, the answer is\n1\nsince only one\n1\nvalue coin is sufficient.\n1=1⋅1\n.\nIn the fourth test case, for\nn=5\n, the answer is\n3\n, which can be achieved using two\n1\nvalue coins and one\n3\nvalue coin.\n5=2⋅1+1⋅3\n.\nIn the seventh test case, for\nn=12\n, the answer is\n2\n, which can be achieved using two\n6\nvalue coins.\nIn the ninth test case, for\nn=16\n, the answer is\n2\n, which can be achieved using one\n1\nvalue coin and one\n15\nvalue coin or using one\n10\nvalue coin and one\n6\nvalue coin.\n16=1⋅1+1⋅15=1⋅6+1⋅10\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1200"
        ]
    },
    {
        "title": "A. Too Min Too Max",
        "description": "Given an array\na\nof\nn\nelements, find the maximum value of the expression:\n|\na\ni\n−\na\nj\n|+|\na\nj\n−\na\nk\n|+|\na\nk\n−\na\nl\n|+|\na\nl\n−\na\ni\n|\n|\n|\n|\n|\n|\n|\n|\nwhere\ni\n,\nj\n,\nk\n, and\nl\nare four distinct indices of the array\na\n, with\n1≤i,j,k,l≤n\n.\nHere\n|x|\ndenotes the absolute value of\nx\n.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n4≤n≤100\n) — the length of the given array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n6\n≤\na\ni\n≤\n10\n6\n).\nOutput\nFor each test case, print a single integer — the maximum value.\nExample\ninput\nCopy\n5\n4\n1 1 1 1\n5\n1 1 2 2 3\n8\n5 1 3 2 -3 -1 10 3\n4\n3 3 1 1\n4\n1 2 2 -1\noutput\nCopy\n0\n6\n38\n8\n8\nNote\nIn the first test case, for any selection of\ni\n,\nj\n,\nk\n,\nl\n, the answer will be\n0\n. For example,\n|\na\n1\n−\na\n2\n|+|\na\n2\n−\na\n3\n|+|\na\n3\n−\na\n4\n|+|\na\n4\n−\na\n1\n|=|1−1|+|1−1|+|1−1|+|1−1|=0+0+0+0=0\n.\nIn the second test case, for\ni=1\n,\nj=3\n,\nk=2\n, and\nl=5\n, the answer will be\n6\n.\n|\na\n1\n−\na\n3\n|+|\na\n3\n−\na\n2\n|+|\na\n2\n−\na\n5\n|+|\na\n5\n−\na\n1\n|=|1−2|+|2−1|+|1−3|+|3−1|=1+1+2+2=6\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Turtle Magic: Royal Turtle Shell Pattern",
        "description": "Turtle Alice is currently designing a fortune cookie box, and she would like to incorporate the theory of LuoShu into it.\nThe box can be seen as an\nn×m\ngrid (\nn,m≥5\n), where the rows are numbered\n1,2,…,n\nand columns are numbered\n1,2,…,m\n. Each cell can either be empty or have a single fortune cookie of one of the following shapes: circle or square. The cell at the intersection of the\na\n-th row and the\nb\n-th column is denoted as\n(a,b)\n.\nInitially, the entire grid is empty. Then, Alice performs\nq\noperations on the fortune cookie box. The\ni\n-th operation (\n1≤i≤q\n) is as follows: specify a currently empty cell\n(\nr\ni\n,\nc\ni\n)\nand a shape (circle or square), then put a fortune cookie of the specified shape on cell\n(\nr\ni\n,\nc\ni\n)\n. Note that after the\ni\n-th operation, the cell\n(\nr\ni\n,\nc\ni\n)\nis no longer empty.\nBefore all operations and after each of the\nq\noperations, Alice wonders what the number of ways to place fortune cookies in all remaining empty cells is, such that the following condition is satisfied:\nNo three consecutive cells (in horizontal, vertical, and both diagonal directions) contain cookies of the same shape. Formally:\nThere does not exist any\n(i,j)\nsatisfying\n1≤i≤n,1≤j≤m−2\n, such that there are cookies of the same shape in cells\n(i,j),(i,j+1),(i,j+2)\n.\nThere does not exist any\n(i,j)\nsatisfying\n1≤i≤n−2,1≤j≤m\n, such that there are cookies of the same shape in cells\n(i,j),(i+1,j),(i+2,j)\n.\nThere does not exist any\n(i,j)\nsatisfying\n1≤i≤n−2,1≤j≤m−2\n, such that there are cookies of the same shape in cells\n(i,j),(i+1,j+1),(i+2,j+2)\n.\nThere does not exist any\n(i,j)\nsatisfying\n1≤i≤n−2,1≤j≤m−2\n, such that there are cookies of the same shape in cells\n(i,j+2),(i+1,j+1),(i+2,j)\n.\nYou should output all answers modulo\n998244353\n. Also note that it is possible that after some operations, the condition is already not satisfied with the already placed candies, in this case you should output\n0\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nm\n,\nq\n(\n5≤n,m≤\n10\n9\n,0≤q≤min(n×m,\n10\n5\n)\n).\nThe\ni\n-th of the next\nq\nlines contains two integers\nr\ni\n,\nc\ni\nand a single string\nshape\ni\n(\n1≤\nr\ni\n≤n,1≤\nc\ni\n≤m\n,\nshape\ni\n=\n\"circle\" or \"square\"), representing the operations. It is guaranteed that the cell on the\nr\ni\n-th row and the\nc\ni\n-th column is initially empty. That means, each\n(\nr\ni\n,\nc\ni\n)\nwill appear at most once in the updates.\nThe sum of\nq\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output\nq+1\nlines. The first line of each test case should contain the answer before any operations. The\ni\n-th line (\n2≤i≤q+1\n) should contain the answer after the first\ni−1\noperations. All answers should be taken modulo\n998244353\n.\nExample\ninput\nCopy\n2\n6 7 4\n3 3 circle\n3 6 square\n5 3 circle\n5 4 square\n5 5 3\n1 1 circle\n1 2 circle\n1 3 circle\noutput\nCopy\n8\n4\n3\n1\n0\n8\n4\n1\n0\nNote\nIn the second sample, after placing a circle-shaped fortune cookie to cells\n(1,1)\n,\n(1,2)\nand\n(1,3)\n, the condition is already not satisfied. Therefore, you should output\n0\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "combinatorics",
            "constructive algorithms",
            "dfs and similar",
            "math",
            "*2300"
        ]
    },
    {
        "title": "F. Turtle Mission: Robot and the Earthquake",
        "description": "The world is a grid with\nn\nrows and\nm\ncolumns. The rows are numbered\n0,1,…,n−1\n, while the columns are numbered\n0,1,…,m−1\n. In this world, the columns are cyclic (i.e. the top and the bottom cells in each column are adjacent). The cell on the\ni\n-th row and the\nj\n-th column (\n0≤i<n,0≤j<m\n) is denoted as\n(i,j)\n.\nAt time\n0\n, the cell\n(i,j)\n(where\n0≤i<n,0≤j<m\n) contains either a rock or nothing. The state of cell\n(i,j)\ncan be described using the integer\na\ni,j\n:\nIf\na\ni,j\n=1\n, there is a rock at\n(i,j)\n.\nIf\na\ni,j\n=0\n, there is nothing at\n(i,j)\n.\nAs a result of aftershocks from the earthquake, the columns follow tectonic plate movements: each column moves cyclically upwards at a velocity of\n1\ncell per unit of time. Formally, for some\n0≤i<n,0≤j<m\n, if\n(i,j)\ncontains a rock at the moment, it will move from\n(i,j)\nto\n(i−1,j)\n(or to\n(n−1,j)\nif\ni=0\n).\nThe robot called RT is initially positioned at\n(0,0)\n. It has to go to\n(n−1,m−1)\nto carry out an earthquake rescue operation (to the bottom rightmost cell). The earthquake doesn't change the position of the robot, they only change the position of rocks in the world.\nLet RT's current position be\n(x,y)\n(\n0≤x<n,0≤y<m\n), it can perform the following operations:\nGo one cell cyclically upwards, i.e. from\n(x,y)\nto\n((x+n−1)modn,y)\nusing\n1\nunit of time.\nGo one cell cyclically downwards, i.e.\n(x,y)\nto\n((x+1)modn,y)\nusing\n1\nunit of time.\nGo one cell to the right, i.e.\n(x,y)\nto\n(x,y+1)\nusing\n1\nunit of time. (RT may perform this operation only if\ny<m−1\n.)\nNote that RT cannot go left using the operations nor can he stay at a position.\nUnfortunately, RT will explode upon colliding with a rock. As such, when RT is at\n(x,y)\nand there is a rock at\n((x+1)modn,y)\nor\n((x+2)modn,y)\n, RT cannot move down or it will be hit by the rock.\nSimilarly, if\ny+1<m\nand there is a rock at\n((x+1)modn,y+1)\n, RT cannot move right or it will be hit by the rock.\nHowever, it is worth noting that if there is a rock at\n(xmodn,y+1)\nand\n((x+1)modn,y)\n, RT can still move right safely.\nFind the minimum amount of time RT needs to reach\n(n−1,m−1)\nwithout colliding with any rocks. If it is impossible to do so, output\n−1\n.\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nIn each test case, the first line contains two integers\nn\n,\nm\n(\n3≤n,m≤\n10\n3\n) — the size of the planet's boundaries.\nEach of the next\nn\nlines contains\nm\nintegers. The\n(j+1)\n-th integer on the\n(i+1)\n-th line (\n0≤i<n,0≤j<m\n) is\na\ni,j\n(\n0≤\na\ni,j\n≤1\n), which denotes whether or not there is a rock at\n(i,j)\nat time\n0\n.\nAdditionally, it is guaranteed that\na\n0,0\n=0\n, and\na\ni,m−1\n=0\nfor\n0≤i<n\n. In other words, there is no rock at RT's initial position as well as column\nm−1\n.\nThe sum of\nn⋅m\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case:\nIf the destination can be reached without colliding with any rocks, output a single integer — the minimum amount of time RT needs to reach\n(n−1,m−1)\n.\nOtherwise, output\n−1\n.\nExamples\ninput\nCopy\n6\n4 5\n0 1 0 0 0\n0 0 1 0 0\n1 0 1 1 0\n0 0 0 0 0\n3 3\n0 0 0\n1 0 0\n0 0 0\n5 3\n0 0 0\n0 0 0\n1 0 0\n0 0 0\n1 0 0\n3 7\n0 0 1 0 0 1 0\n1 0 1 0 1 0 0\n0 1 0 0 0 0 0\n3 4\n0 1 0 0\n1 0 0 0\n0 1 1 0\n5 5\n0 0 0 0 0\n0 1 0 1 0\n0 1 0 1 0\n0 1 0 1 0\n0 0 0 1 0\noutput\nCopy\n7\n3\n3\n8\n-1\n12\ninput\nCopy\n6\n3 3\n0 0 0\n0 0 0\n0 0 0\n4 3\n0 1 0\n1 0 0\n0 1 0\n1 0 0\n4 3\n0 1 0\n0 1 0\n0 1 0\n0 1 0\n3 3\n0 0 0\n1 1 0\n0 0 0\n3 3\n0 1 0\n0 0 0\n0 1 0\n5 5\n0 0 0 0 0\n0 1 1 0 0\n0 1 1 0 0\n0 0 0 0 0\n0 0 1 0 0\noutput\nCopy\n3\n3\n-1\n-1\n3\n8\nNote\nVisual explanation of the first test case in the example:",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "graphs",
            "shortest paths",
            "*2100"
        ]
    },
    {
        "title": "E. Turtle vs. Rabbit Race: Optimal Trainings",
        "description": "Isaac begins his training. There are\nn\nrunning tracks available, and the\ni\n-th track (\n1≤i≤n\n) consists of\na\ni\nequal-length sections.\nGiven an integer\nu\n(\n1≤u≤\n10\n9\n), finishing each section can increase Isaac's ability by a certain value, described as follows:\nFinishing the\n1\n-st section increases Isaac's performance by\nu\n.\nFinishing the\n2\n-nd section increases Isaac's performance by\nu−1\n.\nFinishing the\n3\n-rd section increases Isaac's performance by\nu−2\n.\n…\nFinishing the\nk\n-th section (\nk≥1\n) increases Isaac's performance by\nu+1−k\n. (The value\nu+1−k\ncan be negative, which means finishing an extra section decreases Isaac's performance.)\nYou are also given an integer\nl\n. You must choose an integer\nr\nsuch that\nl≤r≤n\nand Isaac will finish each section of each track\nl,l+1,…,r\n(that is, a total of\n∑\nr\ni=l\na\ni\n=\na\nl\n+\na\nl+1\n+…+\na\nr\nsections).\nAnswer the following question: what is the optimal\nr\nyou can choose that the increase in Isaac's performance is maximum possible?\nIf there are multiple\nr\nthat maximize the increase in Isaac's performance, output the smallest\nr\n.\nTo increase the difficulty, you need to answer the question for\nq\ndifferent values of\nl\nand\nu\n.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe descriptions of the test cases follow.\nThe first line contains a single integer\nn\n(\n1≤n≤\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n4\n).\nThe third line contains a single integer\nq\n(\n1≤q≤\n10\n5\n).\nThe next\nq\nlines each contain two integers\nl\nand\nu\n(\n1≤l≤n,1≤u≤\n10\n9\n) — the descriptions to each query.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. The sum of\nq\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nq\nintegers: the\ni\n-th integer contains the optimal\nr\nfor the\ni\n-th query. If there are multiple solutions, output the smallest one.\nExample\ninput\nCopy\n5\n6\n3 1 4 1 5 9\n3\n1 8\n2 7\n5 9\n1\n10\n1\n1 1\n9\n5 10 9 6 8 3 10 7 3\n5\n8 56\n1 12\n9 3\n1 27\n5 45\n5\n7 9 2 5 2\n10\n1 37\n2 9\n3 33\n4 32\n4 15\n2 2\n4 2\n2 19\n3 7\n2 7\n10\n9 1 6 7 6 3 10 7 3 10\n5\n10 43\n3 23\n9 3\n6 8\n5 14\noutput\nCopy\n3 4 5 \n1 \n9 2 9 4 9 \n5 2 5 5 5 2 4 5 4 2 \n10 6 9 7 7 \nNote\nFor the\n1\n-st query in the first test case:\nBy choosing\nr=3\n, Isaac finishes\na\n1\n+\na\n2\n+\na\n3\n=3+1+4=8\nsections in total, hence his increase in performance is\nu+(u−1)+…+(u−7)=8+7+6+5+4+3+2+1=36\n.\nBy choosing\nr=4\n, Isaac finishes\na\n1\n+\na\n2\n+\na\n3\n+\na\n4\n=3+1+4+1=9\nsections in total, hence his increase in performance is\nu+(u−1)+…+(u−8)=8+7+6+5+4+3+2+1+0=36\n.\nBoth choices yield the optimal increase in performance, however we want to choose the smallest\nr\n. So we choose\nr=3\n.\nFor the\n2\n-nd query in the first test case, by choosing\nr=4\n, Isaac finishes\na\n2\n+\na\n3\n+\na\n4\n=1+4+1=6\nsections in total, hence his increase in performance is\nu+(u−1)+…+(u−5)=7+6+5+4+3+2=27\n. This is the optimal increase in performance.\nFor the\n3\n-rd query in the first test case:\nBy choosing\nr=5\n, Isaac finishes\na\n5\n=5\nsections in total, hence his increase in performance is\nu+(u−1)+…+(u−4)=9+8+7+6+5=35\n.\nBy choosing\nr=6\n, Isaac finishes\na\n5\n+\na\n6\n=5+9=14\nsections in total, hence his increase in performance is\nu+(u−1)+…+(u−13)=9+8+7+6+5+4+3+2+1+0+(−1)+(−2)+(−3)+(−4)=35\n.\nBoth choices yield the optimal increase in performance, however we want to choose the smallest\nr\n. So we choose\nr=5\n.\nHence the output for the first test case is\n[3,4,5]\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "math",
            "ternary search",
            "*1500"
        ]
    },
    {
        "title": "D. Turtle Tenacity: Continual Mods",
        "description": "Given an array\na\n1\n,\na\n2\n,…,\na\nn\n, determine whether it is possible to rearrange its elements into\nb\n1\n,\nb\n2\n,…,\nb\nn\n, such that\nb\n1\nmod\nb\n2\nmod…mod\nb\nn\n≠0\n.\nHere\nxmody\ndenotes the remainder from dividing\nx\nby\ny\n. Also, the modulo operations are calculated from left to right. That is,\nxmodymodz=(xmody)modz\n. For example,\n2024mod1000mod8=(2024mod1000)mod8=24mod8=0\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if it is possible, \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n8\n6\n1 2 3 4 5 6\n5\n3 3 3 3 3\n3\n2 2 3\n5\n1 1 2 3 7\n3\n1 2 2\n3\n1 1 2\n6\n5 2 10 10 10 2\n4\n3 6 9 3\noutput\nCopy\nYES\nNO\nYES\nNO\nYES\nNO\nYES\nNO\nNote\nIn the first test case, rearranging the array into\nb=[1,2,3,4,5,6]\n(doing nothing) would result in\n1mod2mod3mod4mod5mod6=1\n. Hence it is possible to achieve the goal.\nIn the second test case, the array\nb\nmust be equal to\n[3,3,3,3,3]\n, which would result in\n3mod3mod3mod3mod3=0\n. Hence it is impossible to achieve the goal.\nIn the third test case, rearranging the array into\nb=[3,2,2]\nwould result in\n3mod2mod2=1\n. Hence it is possible to achieve the goal.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "sortings",
            "*1200"
        ]
    },
    {
        "title": "C. Turtle Fingers: Count the Values of k",
        "description": "You are given three positive integers\na\n,\nb\nand\nl\n(\na,b,l>0\n).\nIt can be shown that there always exists a way to choose non-negative (i.e.\n≥0\n) integers\nk\n,\nx\n, and\ny\nsuch that\nl=k⋅\na\nx\n⋅\nb\ny\n.\nYour task is to find the number of distinct possible values of\nk\nacross all such ways.\nInput\nThe first line contains the integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe following\nt\nlines contain three integers,\na\n,\nb\nand\nl\n(\n2≤a,b≤100\n,\n1≤l≤\n10\n6\n) — description of a test case.\nOutput\nOutput\nt\nlines, with the\ni\n-th (\n1≤i≤t\n) line containing an integer, the answer to the\ni\n-th test case.\nExample\ninput\nCopy\n11\n2 5 20\n2 5 21\n4 6 48\n2 3 72\n3 5 75\n2 2 1024\n3 7 83349\n100 100 1000000\n7 3 2\n2 6 6\n17 3 632043\noutput\nCopy\n6\n1\n5\n12\n6\n11\n24\n4\n1\n3\n24\nNote\nIn the first test case,\na=2,b=5,l=20\n. The possible values of\nk\n(and corresponding\nx,y\n) are as follows:\nChoose\nk=1,x=2,y=1\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=1⋅\n2\n2\n⋅\n5\n1\n=20=l\n.\nChoose\nk=2,x=1,y=1\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=2⋅\n2\n1\n⋅\n5\n1\n=20=l\n.\nChoose\nk=4,x=0,y=1\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=4⋅\n2\n0\n⋅\n5\n1\n=20=l\n.\nChoose\nk=5,x=2,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=5⋅\n2\n2\n⋅\n5\n0\n=20=l\n.\nChoose\nk=10,x=1,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=10⋅\n2\n1\n⋅\n5\n0\n=20=l\n.\nChoose\nk=20,x=0,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=20⋅\n2\n0\n⋅\n5\n0\n=20=l\n.\nIn the second test case,\na=2,b=5,l=21\n. Note that\nl=21\nis not divisible by either\na=2\nor\nb=5\n. Therefore, we can only set\nx=0,y=0\n, which corresponds to\nk=21\n.\nIn the third test case,\na=4,b=6,l=48\n. The possible values of\nk\n(and corresponding\nx,y\n) are as follows:\nChoose\nk=2,x=1,y=1\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=2⋅\n4\n1\n⋅\n6\n1\n=48=l\n.\nChoose\nk=3,x=2,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=3⋅\n4\n2\n⋅\n6\n0\n=48=l\n.\nChoose\nk=8,x=0,y=1\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=8⋅\n4\n0\n⋅\n6\n1\n=48=l\n.\nChoose\nk=12,x=1,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=12⋅\n4\n1\n⋅\n6\n0\n=48=l\n.\nChoose\nk=48,x=0,y=0\n. Then\nk⋅\na\nx\n⋅\nb\ny\n=48⋅\n4\n0\n⋅\n6\n0\n=48=l\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1100"
        ]
    },
    {
        "title": "B. Turtle Math: Fast Three Task",
        "description": "You are given an array\na\n1\n,\na\n2\n,…,\na\nn\n.\nIn one move, you can perform either of the following two operations:\nChoose an element from the array and remove it from the array. As a result, the length of the array decreases by\n1\n;\nChoose an element from the array and increase its value by\n1\n.\nYou can perform any number of moves. If the current array becomes empty, then no more moves can be made.\nYour task is to find the minimum number of moves required to make the sum of the elements of the array\na\ndivisible by\n3\n. It is possible that you may need\n0\nmoves.\nNote that the sum of the elements of an empty array (an array of length\n0\n) is equal to\n0\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n4\n).\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the minimum number of moves.\nExample\ninput\nCopy\n8\n4\n2 2 5 4\n3\n1 3 2\n4\n3 7 6 8\n1\n1\n4\n2 2 4 2\n2\n5 5\n7\n2 4 8 1 9 3 4\n2\n4 10\noutput\nCopy\n1\n0\n0\n1\n1\n2\n1\n1\nNote\nIn the first test case, initially the array\na=[2,2,5,4]\n. One of the optimal ways to make moves is:\nremove the current\n4\nth element and get\na=[2,2,5]\n;\nAs a result, the sum of the elements of the array\na\nwill be divisible by\n3\n(indeed,\na\n1\n+\na\n2\n+\na\n3\n=2+2+5=9\n).\nIn the second test case, initially, the sum of the array is\n1+3+2=6\n, which is divisible by\n3\n. Therefore, no moves are required. Hence, the answer is\n0\n.\nIn the fourth test case, initially, the sum of the array is\n1\n, which is not divisible by\n3\n. By removing its only element, you will get an empty array, so its sum is\n0\n. Hence, the answer is\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "A. Turtle Puzzle: Rearrange and Negate",
        "description": "You are given an array\na\nof\nn\nintegers. You must perform the following two operations on the array (the first, then the second):\nArbitrarily rearrange the elements of the array or leave the order of its elements unchanged.\nChoose at most one contiguous segment of elements and replace the signs of all elements in this segment with their opposites. Formally, you can choose a pair of indices\nl,r\nsuch that\n1≤l≤r≤n\nand assign\na\ni\n=−\na\ni\nfor all\nl≤i≤r\n(negate elements). Note that you may choose not to select a pair of indices and leave all the signs of the elements unchanged.\nWhat is the maximum sum of the array elements after performing these two operations (the first, then the second)?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the number of elements in array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−100≤\na\ni\n≤100\n) — elements of the array.\nOutput\nFor each test case, output the maximum sum of the array elements after sequentially performing the two given operations.\nExample\ninput\nCopy\n8\n3\n-2 3 -3\n1\n0\n2\n0 1\n1\n-99\n4\n10 -2 -3 7\n5\n-1 -2 -3 -4 -5\n6\n-41 22 -69 73 -15 -50\n12\n1 2 3 4 5 6 7 8 9 10 11 12\noutput\nCopy\n8\n0\n1\n99\n22\n15\n270\n78\nNote\nIn the first test case, you can first rearrange the array to get\n[3,−2,−3]\n(operation 1), then choose\nl=2,r=3\nand get the sum\n3+−((−2)+(−3))=8\n(operation 2).\nIn the second test case, you can do nothing in both operations and get the sum\n0\n.\nIn the third test case, you can do nothing in both operations and get the sum\n0+1=1\n.\nIn the fourth test case, you can first leave the order unchanged (operation 1), then choose\nl=1,r=1\nand get the sum\n−(−99)=99\n(operation 2).\nIn the fifth test case, you can first leave the order unchanged (operation 1), then choose\nl=2,r=3\nand get the sum\n10+−((−2)+(−3))+7=22\n(operation 2).\nIn the sixth test case, you can first leave the order unchanged (operation 1), then choose\nl=1,r=5\nand get the sum\n−((−1)+(−2)+(−3)+(−4)+(−5))=15\n(operation 2).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "G. Moving Platforms",
        "description": "There is a game where you need to move through a labyrinth. The labyrinth consists of\nn\nplatforms, connected by\nm\npassages.\nEach platform is at some level\nl\ni\n, an integer number from\n0\nto\nH−1\n. In a single step, if you are currently on platform\ni\n, you can stay on it, or move to another platform\nj\n. To move to platform\nj\nthey have to be connected by the passage, and their levels have to be the same, namely\nl\ni\n=\nl\nj\n.\nAfter each step, the levels of all platforms change. The new level of platform\ni\nis calculated as\nl\n′\ni\n=(\nl\ni\n+\ns\ni\n)modH\n, for all\ni\n.\nYou start on platform\n1\n. Find the minimum number of steps you need to get to platform\nn\n.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nH\n(\n2≤n≤\n10\n5\n,\n1≤m≤\n10\n5\n,\n1≤H≤\n10\n9\n).\nThe second line contains\nn\nintegers\nl\ni\n, the initial level of each platform (\n0≤\nl\ni\n≤H−1\n).\nThe third line contains\nn\nintegers\ns\ni\n, the change of level for each platform (\n0≤\ns\ni\n≤H−1\n).\nNext\nm\nlines contain a description of the passages. Each passage is described as a pair of integers — the platforms, connected by the passage. There is at most one passage connecting each pair of platforms, and there is no passage connecting a platform to itself.\nThe sum of\nn\nfor all tests does not exceed\n10\n5\n, the sum of\nm\nfor all tests does not exceed\n10\n5\n.\nOutput\nFor each test case, print a single integer, the minimum number of steps needed to get from platform\n1\nto platform\nn\n.\nIf it is impossible to get to platform\nn\n, print\n−1\n.\nExample\ninput\nCopy\n3\n3 3 10\n1 9 4\n2 3 0\n1 2\n3 2\n1 3\n2 1 10\n1 2\n4 6\n1 2\n8 7 25\n22 14 5 3 10 14 11 1\n9 5 4 10 7 16 18 18\n2 8\n6 3\n3 5\n7 5\n2 6\n1 4\n4 7\noutput\nCopy\n6\n-1\n52\nNote\nThis is how levels of the platforms change, and what actions we need to perform in the first example.\nPlatform 1 Platform 2 Platform 3 Action\nStep 1 1 9 4 Stay on the platform 1\nStep 2 3 2 4 Stay on the platform 1\nStep 3 5 5 4 Move to the platform 2\nStep 4 7 8 4 Stay on the platform 2\nStep 5 9 1 4 Stay on the platform 2\nStep 6 1 4 4 Move to the platform 3",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "graphs",
            "math",
            "number theory",
            "shortest paths",
            "*2300"
        ]
    },
    {
        "title": "F. Feed Cats",
        "description": "There is a fun game where you need to feed cats that come and go. The level of the game consists of\nn\nsteps. There are\nm\ncats; the cat\ni\nis present in steps from\nl\ni\nto\nr\ni\n, inclusive. In each step, you can feed all the cats that are currently present or do nothing.\nIf you feed the same cat more than once, it will overeat, and you will immediately lose the game. Your goal is to feed as many cats as possible without causing any cat to overeat.\nFind the maximum number of cats you can feed.\nFormally, you need to select several integer points from the segment from\n1\nto\nn\nin such a way that among given segments, none covers two or more of the selected points, and as many segments as possible cover one of the selected points.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤\n10\n6\n,\n1≤m≤2⋅\n10\n5\n).\nThe\ni\n-th of the next\nm\nlines contains a pair of integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n).\nThe sum of\nn\nfor all tests does not exceed\n10\n6\n, the sum of\nm\nfor all tests does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer, the maximum number of cats you can feed.\nExample\ninput\nCopy\n3\n15 6\n2 10\n3 5\n2 4\n7 7\n8 12\n11 11\n1000 1\n1 1000\n5 10\n1 2\n3 4\n3 4\n3 4\n3 4\n1 1\n1 2\n3 3\n3 4\n3 4\noutput\nCopy\n5\n1\n10\nNote\nIn the first example, one of the ways to feed five cats is to feed at steps\n4\nand\n11\n.\nAt step\n4\n, cats\n1\n,\n2\n, and\n3\nwill be fed.\nAt step\n11\n, cats\n5\nand\n6\nwill be fed.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "E. Final Countdown",
        "description": "You are in a nuclear laboratory that is about to explode and destroy the Earth. You must save the Earth before the final countdown reaches zero.\nThe countdown consists of\nn\n(\n1≤n≤4⋅\n10\n5\n) mechanical indicators, each showing one decimal digit. You noticed that when the countdown changes its state from\nx\nto\nx−1\n, it doesn't happen in one move. Instead, each change of a single digit takes one second.\nSo, for example, if the countdown shows 42, then it will change to 41 in one second, because only one digit is changed, but if the countdown shows 2300, then it will change to 2299 in three seconds, because the three last digits are changed.\nFind out how much time is left before the countdown reaches zero.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤4⋅\n10\n5\n).\nThe second line contains a string of\nn\ndigits, the current state of the countdown. It is guaranteed that at least one digit is not zero.\nThe sum of\nn\nfor all tests does not exceed\n4⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer without leading zeroes, the number of seconds left before the countdown reaches zero. Note that this number may be huge.\nExample\ninput\nCopy\n5\n2\n42\n5\n12345\n2\n99\n4\n0005\n27\n456480697259671309012631002\noutput\nCopy\n46\n13715\n108\n5\n507200774732968121125145546\nNote\nIn the first example, there are four changes that take 2 seconds: 40 to 39, 30 to 29, 20 to 19, and 10 to 09, other changes take 1 second each. So the total time is\n2⋅4+1⋅(42−4)=46\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "implementation",
            "math",
            "number theory",
            "*1600"
        ]
    },
    {
        "title": "D. Card Game",
        "description": "Two players are playing an online card game. The game is played using a 32-card deck. Each card has a suit and a rank. There are four suits: clubs, diamonds, hearts, and spades. We will encode them with characters 'C', 'D', 'H', and 'S', respectively. And there are 8 ranks, in increasing order: '2', '3', '4', '5', '6', '7', '8', '9'.\nEach card is denoted by two letters: its rank and its suit. For example, the 8 of Hearts is denoted as 8H.\nAt the beginning of the game, one suit is chosen as the trump suit.\nIn each round, players make moves like this: the first player places one of his cards on the table, and the second player must beat this card with one of their cards. After that, both cards are moved to the discard pile.\nA card can beat another card if both cards have the same suit and the first card has a higher rank than the second. For example, 8S can beat 4S. Additionally, a trump card can beat any non-trump card, regardless of the rank of the cards, for example, if the trump suit is clubs ('C'), then 3C can beat 9D. Note that trump cards can be beaten only by the trump cards of higher rank.\nThere were\nn\nrounds played in the game, so the discard pile now contains\n2n\ncards. You want to reconstruct the rounds played in the game, but the cards in the discard pile are shuffled. Find any possible sequence of\nn\nrounds that might have been played in the game.\nInput\nThe first line contains integer\nt\n(\n1≤t≤100\n) — the number of test cases. Then\nt\ntest cases follow.\nThe first line of a test case contains the integer number\nn\n(\n1≤n≤16\n).\nThe second line of a test case contains one character, the trump suit. It is one of \"CDHS\".\nThe third line of a test case contains the description of\n2n\ncards. Each card is described by a two-character string, the first character is the rank of the card, which is one of \"23456789\", and the second one is the suit of the card, which is one of \"CDHS\". All cards are different.\nOutput\nFor each test case print the answer to it:\nPrint\nn\nlines. In each line, print the description of two cards, in the same format as in the input: the first card that was played by the first player, and then the card that was used by the second player to beat it.\nIf there is no solution, print a single line \"IMPOSSIBLE\".\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n8\n3\nS\n3C 9S 4C 6D 3S 7S\n2\nC\n3S 5D 9S 6H\n1\nH\n6C 5D\n1\nS\n7S 3S\n1\nH\n9S 9H\n1\nS\n9S 9H\n1\nC\n9D 8H\n2\nC\n9C 9S 6H 8C\noutput\nCopy\n3C 4C\n6D 9S\n3S 7S\nIMPOSSIBLE\nIMPOSSIBLE\n3S 7S\n9S 9H\n9H 9S\nIMPOSSIBLE\n6H 9C\n9S 8C",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1400"
        ]
    },
    {
        "title": "C. LR-remainders",
        "description": "You are given an array\na\nof length\nn\n, a positive integer\nm\n, and a string of commands of length\nn\n. Each command is either the character 'L' or the character 'R'.\nProcess all\nn\ncommands in the order they are written in the string\ns\n. Processing a command is done as follows:\nFirst, output the remainder of the product of all elements of the array\na\nwhen divided by\nm\n.\nThen, if the command is 'L', remove the leftmost element from the array\na\n, if the command is 'R', remove the rightmost element from the array\na\n.\nNote that after each move, the length of the array\na\ndecreases by\n1\n, and after processing all commands, it will be empty.\nWrite a program that will process all commands in the order they are written in the string\ns\n(from left to right).\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases in the input. Then descriptions of\nt\ntest cases follow.\nEach test case of the input is given by three lines.\nThe first line contains two integers\nn\nand\nm\n(\n1≤n≤2⋅\n10\n5\n,1≤m≤\n10\n4\n) — the initial length of the array\na\nand the value to take the remainder by.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n4\n) — the elements of the array\na\n.\nThe third line contains a string\ns\nconsisting of\nn\ncharacters 'L' and 'R'.\nIt is guaranteed that the sum of the values of\nn\nfor all test cases in a test does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n, where\nb\ni\nis the remainder when dividing the product of all elements of the current state of the array\na\nby\nm\nat the beginning of the execution of the\ni\n-th command.\nExample\ninput\nCopy\n4\n4 6\n3 1 4 2\nLRRL\n5 1\n1 1 1 1 1\nLLLLL\n6 8\n1 2 3 4 5 6\nRLLLRR\n1 10000\n10000\nR\noutput\nCopy\n0 2 4 1 \n0 0 0 0 0 \n0 0 0 4 4 4 \n0 \nNote\nIn the first test case of the example:\n3⋅1⋅4⋅2mod6=24mod6=0\n;\ns\n1\n=L\n, so we remove the first element and get the array\n[1,4,2]\n;\n1⋅4⋅2mod6=8mod6=2\n;\ns\n2\n=R\n, so we remove the last element and get the array\n[1,4]\n;\n1⋅4mod6=4mod6=4\n;\ns\n3\n=R\n, so we remove the last element and get the array\n[1]\n;\n1mod6=1\n;\ns\n4\n=L\n, so we remove the first element and get an empty array.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "math",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "B. Chaya Calendar",
        "description": "The Chaya tribe believes that there are\nn\nsigns of the apocalypse. Over time, it has been found out that the\ni\n-th sign occurs every\na\ni\nyears (in years\na\ni\n,\n2⋅\na\ni\n,\n3⋅\na\ni\n,\n…\n).\nAccording to the legends, for the apocalypse to happen, the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on. That is, if the\ni\n-th sign occurred in the year\nx\n, the tribe starts waiting for the occurrence of the\n(i+1)\n-th sign, starting from the year\nx+1\n.\nIn which year will the\nn\n-th sign occur and the apocalypse will happen?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the number of signs.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,\na\n3\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the periodicities of the signs.\nOutput\nFor each test case, output a single integer — the year in which all\nn\nsigns will occur.\nExample\ninput\nCopy\n4\n6\n3 2 4 5 9 18\n5\n1 2 3 4 5\n5\n1 1 1 1 1\n6\n50 30 711 200 503 1006\noutput\nCopy\n36\n5\n5\n2012\nNote\nIn the first set of input data of the example:\nThe tribe will wait for the first sign in the\n3\n-rd year;\nthe tribe will wait for the second sign in the\n4\n-th year (since year\n2\nhave already passed);\nthe tribe will wait for the third sign in the\n8\n-th year (since the second sign has already occurred in the\n4\n-th year);\nthe tribe will wait for the fourth sign in the\n10\n-th year (since year\n5\nhave already passed);\nthe tribe will wait for the fifth sign in the\n18\n-th year (since year\n9\nhave already passed);\nthe tribe will wait for the sixth sign in the\n36\n-th year (since the fifth sign has already occurred in the\n18\n-th year).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "number theory",
            "*1100"
        ]
    },
    {
        "title": "A. Thorns and Coins",
        "description": "During your journey through computer universes, you stumbled upon a very interesting world. It is a path with\nn\nconsecutive cells, each of which can either be empty, contain thorns, or a coin. In one move, you can move one or two cells along the path, provided that the destination cell does not contain thorns (and belongs to the path). If you move to the cell with a coin, you pick it up.\nHere, green arrows correspond to legal moves, and the red arrow corresponds to an illegal move.\nYou want to collect as many coins as possible. Find the maximum number of coins you can collect in the discovered world if you start in the leftmost cell of the path.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the length of the path.\nThe second line of each test case contains a string of\nn\ncharacters, the description of the path. The character '.' denotes an empty cell, '@' denotes a cell with a coin, and '*' denotes a cell with thorns. It is guaranteed that the first cell is empty.\nOutput\nFor each test case, output a single integer, the maximum number of coins you can collect.\nExample\ninput\nCopy\n3\n10\n.@@*@.**@@\n5\n.@@@@\n15\n.@@..@***..@@@*\noutput\nCopy\n3\n4\n3\nNote\nThe picture for the first example is in the problem statement.\nHere is the picture for the second example:\nAnd here is the picture for the third example:",
        "time_limit": "1 second",
        "memory_limit": "512 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "G. One-Dimensional Puzzle",
        "description": "You have a one-dimensional puzzle, all the elements of which need to be put in one row, connecting with each other. All the puzzle elements are completely white and distinguishable from each other only if they have different shapes.\nEach element has straight borders at the top and bottom, and on the left and right it has connections, each of which can be a protrusion or a recess. You cannot rotate the elements.\nYou can see that there are exactly\n4\ntypes of elements. Two elements can be connected if the right connection of the left element is opposite to the left connection of the right element.\nAll possible types of elements.\nThe puzzle contains\nc\n1\n,\nc\n2\n,\nc\n3\n,\nc\n4\nelements of each type. The puzzle is considered complete if you have managed to combine all elements into one long chain. You want to know how many ways this can be done.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n5\n) — the number of input test cases. The descriptions of the test cases follow.\nThe description of each test case contains\n4\nintegers\nc\ni\n(\n0≤\nc\ni\n≤\n10\n6\n) — the number of elements of each type, respectively.\nIt is guaranteed that the sum of\nc\ni\nfor all test cases does not exceed\n4⋅\n10\n6\n.\nOutput\nFor each test case, print one integer — the number of possible ways to solve the puzzle.\nTwo methods are considered different if there is\ni\n, such that the types of elements at the\ni\nposition in these methods differ.\nSince the answer can be very large, output it modulo\n998244353\n.\nIf it is impossible to solve the puzzle, print\n0\n.\nExample\ninput\nCopy\n11\n1 1 1 1\n1 2 5 10\n4 6 100 200\n900000 900000 900000 900000\n0 0 0 0\n0 0 566 239\n1 0 0 0\n100 0 100 0\n0 0 0 4\n5 5 0 2\n5 4 0 5\noutput\nCopy\n4\n66\n0\n794100779\n1\n0\n1\n0\n1\n36\n126",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "number theory",
            "*2000"
        ]
    },
    {
        "title": "F. Chat Screenshots",
        "description": "There are\nn\npeople in the programming contest chat. Chat participants are ordered by activity, but each person sees himself at the top of the list.\nFor example, there are\n4\nparticipants in the chat, and their order is\n[2,3,1,4]\n. Then\n1\n-st user sees the order\n[1,2,3,4]\n.\n2\n-nd user sees the order\n[2,3,1,4]\n.\n3\n-rd user sees the order\n[3,2,1,4]\n.\n4\n-th user sees the order\n[4,2,3,1]\n.\nk\npeople posted screenshots in the chat, which show the order of participants shown to this user. The screenshots were taken within a short period of time, and the order of participants has not changed.\nYour task is to determine whether there is a certain order that all screenshots correspond to.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of input test cases. The descriptions of test cases follow.\nThe first line of the description of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤2⋅\n10\n5\n,n⋅k≤2⋅\n10\n5\n) — the number of chat participants and the number of participants who posted screenshots.\nThe following\nk\nlines contain descriptions of screenshots posted by the participants.\nThe\ni\n-th row contains\nn\nintegers\na\nij\neach (\n1≤\na\nij\n≤n\n, all\na\nij\nare different) — the order of participants shown to the participant\na\ni0\n, where\na\ni0\n— the author of the screenshot. You can show that in the screenshot description it will always be at the top of the list.\nIt is guaranteed that the sum of\nn⋅k\nfor all test cases does not exceed\n2⋅\n10\n5\n. It is also guaranteed that all the authors of the screenshots are different.\nOutput\nOutput\nt\nlines, each of which is the answer to the corresponding test case. As an answer, output \"YES\" if there exists at least one order of participants, under which all\nk\nscreenshots could have been obtained. Otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nExample\ninput\nCopy\n10\n5 1\n1 2 3 4 5\n4 4\n1 2 3 4\n2 3 1 4\n3 2 1 4\n4 2 3 1\n6 2\n1 3 5 2 4 6\n6 3 5 2 1 4\n3 3\n1 2 3\n2 3 1\n3 2 1\n10 2\n1 2 3 4 5 6 7 8 9 10\n10 9 8 7 6 5 4 3 2 1\n1 1\n1\n5 2\n1 2 3 5 4\n2 1 3 5 4\n3 3\n3 1 2\n2 3 1\n1 3 2\n5 4\n3 5 1 4 2\n2 5 1 4 3\n1 5 4 3 2\n5 1 4 3 2\n3 3\n1 3 2\n2 1 3\n3 2 1\noutput\nCopy\nYES\nYES\nYES\nYES\nNO\nYES\nYES\nYES\nYES\nNO",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "graphs",
            "*1700"
        ]
    },
    {
        "title": "E. Anna and the Valentine's Day Gift",
        "description": "Sasha gave Anna a list\na\nof\nn\nintegers for Valentine's Day. Anna doesn't need this list, so she suggests destroying it by playing a game.\nPlayers take turns. Sasha is a gentleman, so he gives Anna the right to make the first move.\nOn her turn, Anna must choose an element\na\ni\nfrom the list and reverse the sequence of its digits. For example, if Anna chose the element with a value of\n42\n, it would become\n24\n; if Anna chose the element with a value of\n1580\n, it would become\n851\n. Note that leading zeros are removed. After such a turn, the number of elements in the list does not change.\nOn his turn, Sasha must extract two elements\na\ni\nand\na\nj\n(\ni≠j\n) from the list, concatenate them in any order and insert the result back into the list. For example, if Sasha chose the elements equal to\n2007\nand\n19\n, he would remove these two elements from the list and add the integer\n200719\nor\n192007\n. After such a turn, the number of elements in the list decreases by\n1\n.\nPlayers can't skip turns. The game ends when Sasha can't make a move, i.e. after Anna's move there is exactly one number left in the list. If this integer is not less than\n10\nm\n(i.e.,\n≥\n10\nm\n), Sasha wins. Otherwise, Anna wins.\nIt can be shown that the game will always end. Determine who will win if both players play optimally.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThen follows the description of the test cases.\nThe first line of each test case contains integers\nn\n,\nm\n(\n1≤n≤2⋅\n10\n5\n,\n0≤m≤2⋅\n10\n6\n) — the number of integers in the list and the parameter determining when Sasha wins.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the list that Sasha gave to Anna.\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output:\n\"Sasha\", if Sasha wins with optimal play;\n\"Anna\", if Anna wins with optimal play.\nExample\ninput\nCopy\n9\n2 2\n14 2\n3 5\n9 56 1\n4 10\n1 2007 800 1580\n4 5\n5000 123 30 4\n10 10\n6 4 6 2 3 1 10 9 10 7\n1 1\n6\n1 1\n10\n8 9\n1 2 9 10 10 2 10 2\n4 5\n10 10 10 10\noutput\nCopy\nSasha\nAnna\nAnna\nSasha\nSasha\nAnna\nAnna\nAnna\nSasha\nNote\nConsider the first test case.\nAnna can reverse the integer\n2\n, then Sasha can concatenate the integers\n2\nand\n14\n, obtaining the integer\n214\n, which is greater than\n10\n2\n=100\n. If Anna had reversed the integer\n14\n, Sasha would have concatenated the integers\n41\nand\n2\n, obtaining the integer\n412\n, which is greater than\n10\n2\n=100\n. Anna has no other possible moves, so she loses.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "D. Divisible Pairs",
        "description": "Polycarp has two favorite integers\nx\nand\ny\n(they can be equal), and he has found an array\na\nof length\nn\n.\nPolycarp considers a pair of indices\n⟨i,j⟩\n(\n1≤i<j≤n\n) beautiful if:\na\ni\n+\na\nj\nis divisible by\nx\n;\na\ni\n−\na\nj\nis divisible by\ny\n.\nFor example, if\nx=5\n,\ny=2\n,\nn=6\n,\na=\n[\n1,2,7,4,9,6\n], then the only beautiful pairs are:\n⟨1,5⟩\n:\na\n1\n+\na\n5\n=1+9=10\n(\n10\nis divisible by\n5\n) and\na\n1\n−\na\n5\n=1−9=−8\n(\n−8\nis divisible by\n2\n);\n⟨4,6⟩\n:\na\n4\n+\na\n6\n=4+6=10\n(\n10\nis divisible by\n5\n) and\na\n4\n−\na\n6\n=4−6=−2\n(\n−2\nis divisible by\n2\n).\nFind the number of beautiful pairs in the array\na\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains three integers\nn\n,\nx\n, and\ny\n(\n2≤n≤2⋅\n10\n5\n,\n1≤x,y≤\n10\n9\n) — the size of the array and Polycarp's favorite integers.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of beautiful pairs in the array\na\n.\nExample\ninput\nCopy\n7\n6 5 2\n1 2 7 4 9 6\n7 9 5\n1 10 15 3 8 12 15\n9 4 10\n14 10 2 2 11 11 13 5 6\n9 5 6\n10 7 6 7 9 7 7 10 10\n9 6 2\n4 9 7 1 2 2 13 3 15\n9 2 3\n14 6 1 15 12 15 8 2 15\n10 5 7\n13 3 3 2 12 11 3 7 13 14\noutput\nCopy\n2\n0\n1\n3\n5\n7\n0",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "number theory",
            "*1300"
        ]
    },
    {
        "title": "C. Make Equal Again",
        "description": "You have an array\na\nof\nn\nintegers.\nYou can no more than once apply the following operation: select three integers\ni\n,\nj\n,\nx\n(\n1≤i≤j≤n\n) and assign all elements of the array with indexes from\ni\nto\nj\nthe value\nx\n. The price of this operation depends on the selected indices and is equal to\n(j−i+1)\nburles.\nFor example, the array is equal to\n[1,2,3,4,5,1]\n. If we choose\ni=2,j=4,x=8\n, then after applying this operation, the array will be equal to\n[1,8,8,8,5,1]\n.\nWhat is the least amount of burles you need to spend to make all the elements of the array equal?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of input test cases. The descriptions of the test cases follow.\nThe first line of the description of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array.\nThe second line of the description of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — array elements.\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer — the minimum number of burles that will have to be spent to make all the elements of the array equal. It can be shown that this can always be done.\nExample\ninput\nCopy\n8\n6\n1 2 3 4 5 1\n7\n1 1 1 1 1 1 1\n8\n8 8 8 1 2 8 8 8\n1\n1\n2\n1 2\n3\n1 2 3\n7\n4 3 2 7 1 1 3\n9\n9 9 2 9 2 5 5 5 3\noutput\nCopy\n4\n0\n2\n0\n1\n2\n6\n7",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ]
    },
    {
        "title": "B. Make Equal",
        "description": "There are\nn\ncontainers of water lined up, numbered from left to right from\n1\nto\nn\n. Each container can hold any amount of water; initially, the\ni\n-th container contains\na\ni\nunits of water. The sum of\na\ni\nis divisible by\nn\n.\nYou can apply the following operation any (possibly zero) number of times: pour any amount of water from the\ni\n-th container to the\nj\n-th container, where\ni\nmust be less than\nj\n(i.e.\ni<j\n). Any index can be chosen as\ni\nor\nj\nany number of times.\nDetermine whether it is possible to make the amount of water in all containers the same using this operation.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of containers with water.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the amounts of water in the containers. It is guaranteed that the sum of\na\ni\nin each test case does not exceed\n2⋅\n10\n9\n. Also, the sum of\na\ni\nis divisible by\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases in the input does not exceed\n2⋅\n10\n5\n.\nOutput\nOutput\nt\nlines, each of which is the answer to the corresponding test case. As the answer, output \"YES\" if it is possible to make the amount of water in all containers the same using the described operation. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n6\n1\n43\n2\n1 3\n5\n4 5 2 1 3\n3\n1 2 3\n7\n4 5 5 0 6 4 4\n7\n6 5 5 1 3 4 4\noutput\nCopy\nYES\nNO\nYES\nNO\nNO\nYES\nNote\nIn the third test case of the example (\na=[4,5,2,1,3]\n), you can proceed as follows:\npour\n1\nunit of water from the first vessel to the fourth, then\na=[3,5,2,2,3]\n;\npour\n1\nunit of water from the second vessel to the third, then\na=[3,4,3,2,3]\n;\npour\n1\nunit of water from the second vessel to the fourth, then\na=[3,3,3,3,3]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "*800"
        ]
    },
    {
        "title": "A. Recovering a Small String",
        "description": "Nikita had a word consisting of exactly\n3\nlowercase Latin letters. The letters in the Latin alphabet are numbered from\n1\nto\n26\n, where the letter \"a\" has the index\n1\n, and the letter \"z\" has the index\n26\n.\nHe encoded this word as the sum of the positions of all the characters in the alphabet. For example, the word \"cat\" he would encode as the integer\n3+1+20=24\n, because the letter \"c\" has the index\n3\nin the alphabet, the letter \"a\" has the index\n1\n, and the letter \"t\" has the index\n20\n.\nHowever, this encoding turned out to be ambiguous! For example, when encoding the word \"ava\", the integer\n1+22+1=24\nis also obtained.\nDetermine the lexicographically smallest word of\n3\nletters that could have been encoded.\nA string\na\nis lexicographically smaller than a string\nb\nif and only if one of the following holds:\na\nis a prefix of\nb\n, but\na≠b\n;\nin the first position where\na\nand\nb\ndiffer, the string\na\nhas a letter that appears earlier in the alphabet than the corresponding letter in\nb\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases in the test.\nThis is followed by the descriptions of the test cases.\nThe first and only line of each test case contains an integer\nn\n(\n3≤n≤78\n) — the encoded word.\nOutput\nFor each test case, output the lexicographically smallest three-letter word that could have been encoded on a separate line.\nExample\ninput\nCopy\n5\n24\n70\n3\n55\n48\noutput\nCopy\naav\nrzz\naaa\nczz\nauz",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "*800"
        ]
    },
    {
        "title": "I. Counting Is Fun",
        "description": "You are given a binary\n†\n†\npattern\np\nof length\nn\n.\nA binary string\nq\nof the same length\nn\nis called good if for every\ni\n(\n1≤i≤n\n), there exist indices\nl\nand\nr\nsuch that:\n1≤l≤i≤r≤n\n, and\np\ni\nis a mode\n‡\n‡\nof the string\nq\nl\nq\nl+1\n…\nq\nr\n.\nCount the number of good binary strings modulo\n998244353\n.\n†\n†\nA binary string is a string that only consists of characters\n0\nand\n1\n.\n‡\n‡\nCharacter\nc\nis a mode of string\nt\nof length\nm\nif the number of occurrences of\nc\nin\nt\nis at least\n⌈\nm\n2\n⌉\n. For example,\n0\nis a mode of\n010\n,\n1\nis not a mode of\n010\n, and both\n0\nand\n1\nare modes of\n011010\n.\nInput\nThe first line of input contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the binary string\np\n.\nThe second line of input contains a binary string\np\nof length\nn\nconsisting of characters 0 and 1.\nOutput\nOutput the number of good strings modulo\n998244353\n.\nExamples\ninput\nCopy\n1\n0\noutput\nCopy\n1\ninput\nCopy\n3\n111\noutput\nCopy\n5\ninput\nCopy\n4\n1011\noutput\nCopy\n9\ninput\nCopy\n6\n110001\noutput\nCopy\n36\ninput\nCopy\n12\n111010001111\noutput\nCopy\n2441\nNote\nIn the second example, the good strings are\n010\n;\n011\n;\n101\n;\n110\n;\n111\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "*3500"
        ]
    },
    {
        "title": "H. Interactive Mex Tree",
        "description": "This is an interactive problem.\nAlice has a tree\nT\nconsisting of\nn\nnodes, numbered from\n1\nto\nn\n. Alice will show\nT\nto Bob. After observing\nT\n, Bob needs to tell Alice two permutations\np\n1\nand\np\n2\nof\n[1,2,…,n]\n.\nThen, Alice will play\nq\nrounds of the following game.\nAlice will create an array\na\nthat is a permutation of\n[0,1,…,n−1]\n. The value of node\nv\nwill be\na\nv\n.\nAlice will choose two nodes\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) of\nT\nand tell them to Bob. Bob will need to find the\nMEX\n†\nof the values on the unique simple path between nodes\nu\nand\nv\n.\nTo find this value, Bob can ask Alice at most\n5\nqueries. In each query, Bob should give three integers\nt\n,\nl\nand\nr\nto Alice such that\nt\nis either\n1\nor\n2\n, and\n1≤l≤r≤n\n. Alice will then tell Bob the value equal to\nmin\ni=l\nr\na[\np\nt,i\n].\nr\nNote that all rounds are independent of each other. In particular, the values of\na\n,\nu\nand\nv\ncan be different in different rounds.\nBob is puzzled as he only knows the HLD solution, which requires\nO(log(n))\nqueries per round. So he needs your help to win the game.\n†\n†\nThe\nMEX\n(minimum excludant) of a collection of integers\nc\n1\n,\nc\n2\n,…,\nc\nk\nis defined as the smallest non-negative integer\nx\nwhich does not occur in the collection\nc\n.\nInteraction\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Read it. The description of the test cases follows.\nThe first line of each test case contains two positive integers\nn\nand\nq\n(\n2≤n≤\n10\n5\n,\n1≤q≤\n10\n4\n) — the number of nodes in\nT\nand the number of rounds respectively.\nThe following next\nn−1\nlines contains two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — denoting an edge between nodes\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nand\nq\nover all test cases does not exceed\n10\n5\nand\n10\n4\nrespectively.\nIt is also guaranteed that the sum of\nn⋅q\ndoes not exceed\n3⋅\n10\n6\n.\nThe interaction for each test case begins by outputting two permutations\np\n1\nand\np\n2\nof\n[1,2,…,n]\n.\nOn a new line, output\nn\nspace-separated distinct integers denoting\np\n1\n.\nIn the next line, output\nn\nspace-separated distinct integers denoting\np\n2\n.\nAlice will start playing the game.\nFor each round, you must read two integers,\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n). You need to find the\nMEX\nof the values on the unique simple path between nodes\nu\nand\nv\n.\nTo make a query, output \"?\nt\nl\nr\n\" without quotes, such that\nt\nis either\n1\nor\n2\n, and\n1≤l≤r≤n\n. Afterwards, you should read a single integer — the answer to your query\nmin\nr\ni=l\na\np\nt,i\n. You can make at most\n5\nsuch queries in each round.\nIf you want to print the answer, output \"!\nx\n\" (\n1≤x,y≤n\n) without quotes. After doing that, read a single integer, which is normally equal to\n1\n.\nIf you receive the integer\n−1\ninstead of a valid reply, it means your program has made an invalid query, exceeded the query limit, or gave an incorrect answer on the previous test case. Your program must terminate immediately to receive a Wrong Answer verdict. Otherwise, you can get an arbitrary verdict because your solution will continue to read from a closed stream.\nAfter printing a query or the answer, do not forget to output the end of the line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nHacks\nTo hack, follow the test format below.\nThe first line should contain a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case should contain two positive integers\nn\nand\nq\n(\n2≤n≤\n10\n5\n;\n1≤q≤\n10\n4\n) — the number of nodes in\nT\nand the number of rounds respectively.\nThe following next\nn−1\nlines should contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — denoting an edge between nodes\nu\nand\nv\n. The given edges must form a tree.\nFor each of the\nq\nrounds, first print a permutation of\n[0,1,2,…,n−1]\non a new line, denoting the array\na\nchosen by Alice during the start of the round.\nIn the following line, print two distinct nodes\nu\nand\nv\n(\n1≤u,v≤v\n,\nu≠v\n), representing the endpoints of the path asked by Alice.\nThe sum of\nn\nand\nq\nover all test cases should not exceed\n10\n5\nand\n10\n4\nrespectively.\nThe sum of\nn⋅q\nshould not exceed\n3⋅\n10\n6\n.\nExample\ninput\nCopy\n1\n3 1\n1 2\n2 3\n\n\n2 3\n\n1\n\n0\n\n1\noutput\nCopy\n1 2 3\n2 1 3\n\n? 1 2 3\n\n? 2 1 3\n\n! 0\nNote\nIn the first test, the interaction proceeds as follows.\nSolution Jury Explanation\n1 There are 1 test cases.\n3 1 The tree\nT\nconsists of\n3\nnodes, and Alice will play for only one round.\n1 2 First edge of\nT\n2 3 Second edge of\nT\n1 2 3 The permutation\np\n1\n2 1 3 The permutation\np\n2\nAlice shuffles\na\nto\na=[0,2,1]\nbefore giving the nodes for the only round.\n2 3 Nodes for the round\n? 1 2 3 1\nmin(\na\np\n1,2\n,\na\np\n1,3\n)=min(\na\n2\n,\na\n3\n)=1\n? 2 1 3 0\nmin(\na\np\n2,1\n,\na\np\n2,2\n,\na\np\n2,3\n)=min(\na\n2\n,\na\n1\n,\na\n3\n)=0\n! 0 1 Considering the output of queries, it is clear that\nMEX\nis\n0\n. Since the output is correct, the jury responds with\n1\n.\nAfter each test case, make sure to read\n1\nor\n−1\n.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "interactive",
            "trees",
            "*3300"
        ]
    },
    {
        "title": "G. Prefix Max Set Counting",
        "description": "Define a function\nf\nsuch that for an array\nb\n,\nf(b)\nreturns the array of prefix maxima of\nb\n. In other words,\nf(b)\nis an array containing only those elements\nb\ni\n, for which\nb\ni\n=max(\nb\n1\n,\nb\n2\n,…,\nb\ni\n)\n, without changing their order. For example,\nf([3,10,4,10,15,1])=[3,10,10,15]\n.\nYou are given a tree consisting of\nn\nnodes rooted at\n1\n.\nA permutation\n†\n†\np\nof is considered a pre-order of the tree if for all\ni\nthe following condition holds:\nLet\nk\nbe the number of proper descendants\n‡\n‡\nof node\np\ni\n.\nFor all\nx\nsuch that\ni<x≤i+k\n,\np\nx\nis a proper descendant of node\np\ni\n.\nFind the number of distinct values of\nf(a)\nover all possible pre-orders\na\n. Since this value might be large, you only need to find it modulo\n998244353\n.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\n‡\n‡\nNode\nt\nis a proper descendant of node\ns\nif\ns≠t\nand\ns\nis on the unique simple path from\nt\nto\n1\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the number of vertices.\nThe following next\nn−1\nlines contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — denoting an edge between nodes\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output the number of distinct values of\nf(a)\nmodulo\n998244353\nthat you can get.\nExample\ninput\nCopy\n6\n1\n2\n1 2\n3\n1 2\n1 3\n3\n1 2\n2 3\n5\n1 2\n1 3\n1 4\n1 5\n10\n1 2\n2 3\n1 4\n2 5\n2 6\n4 7\n5 8\n4 9\n9 10\noutput\nCopy\n1\n1\n2\n1\n8\n6\nNote\nIn the first test case, the only valid pre-order is\na=[1]\n. So the only possible value of\nf(a)\nis\n[1]\n.\nIn the second test case, the only valid pre-order is\na=[1,2]\n. So the only possible value\nf(a)\nis\n[1,2]\n.\nIn the third test case, the two valid pre-orders are\na=[1,2,3]\nand\na=[1,3,2]\n. So the possible values of\nf(a)\nare\n[1,2,3]\nand\n[1,3]\n.\nIn the fifth test case, the possible values of\nf(a)\nare:\n[1,5]\n;\n[1,2,5]\n;\n[1,3,5]\n;\n[1,4,5]\n;\n[1,2,3,5]\n;\n[1,2,4,5]\n;\n[1,3,4,5]\n;\n[1,2,3,4,5]\n.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "trees",
            "*3100"
        ]
    },
    {
        "title": "F. Maximize the Difference",
        "description": "For an array\nb\nof\nm\nnon-negative integers, define\nf(b)\nas the maximum value of\nmax\ni=1\nm\n(\nb\ni\n|x)−\nmin\ni=1\nm\n(\nb\ni\n|x)\nover all possible non-negative integers\nx\n, where\n|\nis bitwise OR operation.\nYou are given integers\nn\nand\nq\n. You start with an empty array\na\n. Process the following\nq\nqueries:\nv\n: append\nv\nto the back of\na\nand then output\nf(a)\n. It is guaranteed that\n0≤v<n\n.\nThe queries are given in a modified way.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n≤\n2\n22\n,\n1≤q≤\n10\n6\n) — the number of queries.\nThe second line of each test case contains\nq\nspace-separated integers\ne\n1\n,\ne\n2\n,…,\ne\nq\n(\n0≤\ne\ni\n<n\n) — the encrypted values of\nv\n.\nLet\nlast\ni\nequal the output of the\n(i−1)\n-th query for\ni≥2\nand\nlast\ni\n=0\nfor\ni=1\n. Then the value of\nv\nfor the\ni\n-th query is (\ne\ni\n+\nlast\ni\n) modulo\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2\n22\nand the sum of\nq\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print\nq\nintegers. The\ni\n-th integer is the output of the\ni\n-th query.\nExample\ninput\nCopy\n2\n5 2\n1 2\n7 4\n3 1 5 2\noutput\nCopy\n0 2\n0 2 3 5\nNote\nIn the first test case, the final\na=[1,2]\n. For\ni=1\n, the answer is always\n0\n, irrespective of\nx\n. For\ni=2\n, we can select\nx=5\n.\nIn the second test case, the final\na=[3,1,0,5]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dfs and similar",
            "*2700"
        ]
    },
    {
        "title": "E. 2..3...4.... Wonderful! Wonderful!",
        "description": "Stack has an array\na\nof length\nn\nsuch that\na\ni\n=i\nfor all\ni\n(\n1≤i≤n\n). He will select a positive integer\nk\n(\n1≤k≤⌊\nn−1\n2\n⌋\n) and do the following operation on\na\nany number (possibly\n0\n) of times.\nSelect a subsequence\n†\n†\ns\nof length\n2⋅k+1\nfrom\na\n. Now, he will delete the first\nk\nelements of\ns\nfrom\na\n. To keep things perfectly balanced (as all things should be), he will also delete the last\nk\nelements of\ns\nfrom\na\n.\nStack wonders how many arrays\na\ncan he end up with for each\nk\n(\n1≤k≤⌊\nn−1\n2\n⌋\n). As Stack is weak at counting problems, he needs your help.\nSince the number of arrays might be too large, please print it modulo\n998244353\n.\n†\n†\nA sequence\nx\nis a subsequence of a sequence\ny\nif\nx\ncan be obtained from\ny\nby deleting several (possibly, zero or all) elements. For example,\n[1,3]\n,\n[1,2,3]\nand\n[2,3]\nare subsequences of\n[1,2,3]\n. On the other hand,\n[3,1]\nand\n[2,1,3]\nare not subsequences of\n[1,2,3]\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n6\n) — the length of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test, on a new line, print\n⌊\nn−1\n2\n⌋\nspace-separated integers — the\ni\n-th integer representing the number of arrays modulo\n998244353\nthat Stack can get if he selects\nk=i\n.\nExample\ninput\nCopy\n4\n3\n4\n5\n10\noutput\nCopy\n2 \n4 \n10 2 \n487 162 85 10 \nNote\nIn the first test case, two\na\nare possible for\nk=1\n:\n[1,2,3]\n;\n[2]\n.\nIn the second test case, four\na\nare possible for\nk=1\n:\n[1,2,3,4]\n;\n[1,3]\n;\n[2,3]\n;\n[2,4]\n.\nIn the third test case, two\na\nare possible for\nk=2\n:\n[1,2,3,4,5]\n;\n[3]\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2400"
        ]
    },
    {
        "title": "D2. Sum over all Substrings (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is the constraint on\nt\nand\nn\n. You can make hacks only if both versions of the problem are solved.\nFor a binary\n†\n†\npattern\np\nand a binary string\nq\n, both of length\nm\n,\nq\nis called\np\n-good if for every\ni\n(\n1≤i≤m\n), there exist indices\nl\nand\nr\nsuch that:\n1≤l≤i≤r≤m\n, and\np\ni\nis a mode\n‡\n‡\nof the string\nq\nl\nq\nl+1\n…\nq\nr\n.\nFor a pattern\np\n, let\nf(p)\nbe the minimum possible number of\n1\ns in a\np\n-good binary string (of the same length as the pattern).\nYou are given a binary string\ns\nof size\nn\n. Find\n∑\ni=1\nn\n∑\nj=i\nn\nf(\ns\ni\ns\ni+1\n…\ns\nj\n).\nn\nn\nIn other words, you need to sum the values of\nf\nover all\nn(n+1)\n2\nsubstrings of\ns\n.\n†\n†\nA binary pattern is a string that only consists of characters\n0\nand\n1\n.\n‡\n‡\nCharacter\nc\nis a mode of string\nt\nof length\nm\nif the number of occurrences of\nc\nin\nt\nis at least\n⌈\nm\n2\n⌉\n. For example,\n0\nis a mode of\n010\n,\n1\nis not a mode of\n010\n, and both\n0\nand\n1\nare modes of\n011010\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the length of the binary string\ns\n.\nThe second line of each test case contains a binary string\ns\nof length\nn\nconsisting of only characters\n0\nand\n1\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output the sum of values of\nf\nover all substrings of\ns\n.\nExample\ninput\nCopy\n4\n1\n1\n2\n10\n5\n00000\n20\n11110110000000111111\noutput\nCopy\n1\n2\n0\n346\nNote\nIn the first test case, the only\n1\n-good string is\n1\n. Thus,\nf(1)=1\n.\nIn the second test case,\nf(10)=1\nbecause\n01\nis\n10\n-good, and\n00\nis not\n10\n-good. Thus, the answer is\nf(1)+f(10)+f(0)=1+1+0=2\n.\nIn the third test case,\nf\nequals to\n0\nfor all\n1≤i≤j≤5\n. Thus, the answer is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "divide and conquer",
            "dp",
            "dsu",
            "greedy",
            "implementation",
            "strings",
            "*2100"
        ]
    },
    {
        "title": "D1. Sum over all Substrings (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is the constraint on\nt\nand\nn\n. You can make hacks only if both versions of the problem are solved.\nFor a binary\n†\n†\npattern\np\nand a binary string\nq\n, both of length\nm\n,\nq\nis called\np\n-good if for every\ni\n(\n1≤i≤m\n), there exist indices\nl\nand\nr\nsuch that:\n1≤l≤i≤r≤m\n, and\np\ni\nis a mode\n‡\n‡\nof the string\nq\nl\nq\nl+1\n…\nq\nr\n.\nFor a pattern\np\n, let\nf(p)\nbe the minimum possible number of\n1\ns in a\np\n-good binary string (of the same length as the pattern).\nYou are given a binary string\ns\nof size\nn\n. Find\n∑\ni=1\nn\n∑\nj=i\nn\nf(\ns\ni\ns\ni+1\n…\ns\nj\n).\nn\nn\nIn other words, you need to sum the values of\nf\nover all\nn(n+1)\n2\nsubstrings of\ns\n.\n†\n†\nA binary pattern is a string that only consists of characters\n0\nand\n1\n.\n‡\n‡\nCharacter\nc\nis a mode of string\nt\nof length\nm\nif the number of occurrences of\nc\nin\nt\nis at least\n⌈\nm\n2\n⌉\n. For example,\n0\nis a mode of\n010\n,\n1\nis not a mode of\n010\n, and both\n0\nand\n1\nare modes of\n011010\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the length of the binary string\ns\n.\nThe second line of each test case contains a binary string\ns\nof length\nn\nconsisting of only characters\n0\nand\n1\n.\nIt is guaranteed that the sum of\nn\n2\nover all test cases does not exceed\n10\n4\n.\nOutput\nFor each test case, output the sum of values of\nf\nover all substrings of\ns\n.\nExample\ninput\nCopy\n4\n1\n1\n2\n10\n5\n00000\n20\n11110110000000111111\noutput\nCopy\n1\n2\n0\n346\nNote\nIn the first test case, the only\n1\n-good string is\n1\n. Thus,\nf(1)=1\n.\nIn the second test case,\nf(10)=1\nbecause\n01\nis\n10\n-good, and\n00\nis not\n10\n-good. Thus, the answer is\nf(1)+f(10)+f(0)=1+1+0=2\n.\nIn the third test case,\nf\nequals to\n0\nfor all\n1≤i≤j≤5\n. Thus, the answer is\n0\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "strings",
            "*1800"
        ]
    },
    {
        "title": "C. Lexicographically Largest",
        "description": "Stack has an array\na\nof length\nn\n. He also has an empty set\nS\n. Note that\nS\nis not a multiset.\nHe will do the following three-step operation exactly\nn\ntimes:\nSelect an index\ni\nsuch that\n1≤i≤|a|\n.\nInsert\n†\n†\na\ni\n+i\ninto\nS\n.\nDelete\na\ni\nfrom\na\n. Note that the indices of all elements to the right of\na\ni\nwill decrease by\n1\n.\nNote that after\nn\noperations,\na\nwill be empty.\nStack will now construct a new array\nb\nwhich is\nS\nsorted in decreasing order. Formally,\nb\nis an array of size\n|S|\nwhere\nb\ni\nis the\ni\n-th largest element of\nS\nfor all\n1≤i≤|S|\n.\nFind the lexicographically largest\n‡\n‡\nb\nthat Stack can make.\n†\n†\nA set can only contain unique elements. Inserting an element that is already present in a set will not change the elements of the set.\n‡\n‡\nAn array\np\nis lexicographically larger than a sequence\nq\nif and only if one of the following holds:\nq\nis a prefix of\np\n, but\np≠q\n; or\nin the first position where\np\nand\nq\ndiffer, the array\np\nhas a larger element than the corresponding element in\nq\n.\nNote that\n[3,1,4,1,5]\nis lexicographically larger than\n[3,1,3]\n,\n[]\n, and\n[3,1,4,1]\nbut not\n[3,1,4,1,5,9]\n,\n[3,1,4,1,5]\n, and\n[4]\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the length of array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of array\na\n.\nThe sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output the lexicographically largest\nb\n.\nExample\ninput\nCopy\n3\n2\n2 1\n5\n1 100 1000 1000000 1000000000\n3\n6 4 8\noutput\nCopy\n3 2 \n1000000005 1000004 1003 102 2 \n11 7 6 \nNote\nIn the first test case, select\ni=1\nin the first operation, insert\na\n1\n+1=3\nin\nS\n, and delete\na\n1\nfrom\na\n. After the first operation,\na\nbecomes\na=[1]\n. In the second operation, we select\ni=1\nagain and insert\na\n1\n+1=2\nin\nS\n. Thus\nS={2,3}\n, and\nb=[3,2]\n.\nNote that if you select\ni=2\nin the first operation, and\ni=1\nin the second operation,\nS={3}\nas\n3\nwill be inserted twice, resulting in\nb=[3]\n.\nAs\n[3,2]\nis lexicographically larger than\n[3]\n, we should select\ni=1\nin the first operation.\nIn the second test case, in each operation, select the last element.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "greedy",
            "sortings",
            "*1700"
        ]
    },
    {
        "title": "B. Permutation Printing",
        "description": "You are given a positive integer\nn\n.\nFind a permutation\n†\n†\np\nof length\nn\nsuch that there do not exist two distinct indices\ni\nand\nj\n(\n1≤i,j<n\n;\ni≠j\n) such that\np\ni\ndivides\np\nj\nand\np\ni+1\ndivides\np\nj+1\n.\nRefer to the Notes section for some examples.\nUnder the constraints of this problem, it can be proven that at least one\np\nexists.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n3≤n≤\n10\n5\n) — the length of the permutation\np\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output\np\n1\n,\np\n2\n,…,\np\nn\n.\nIf there are multiple solutions, you may output any one of them.\nExample\ninput\nCopy\n2\n4\n3\noutput\nCopy\n4 1 2 3\n1 2 3\nNote\nIn the first test case,\np=[4,1,2,3]\nis a valid permutation. However, the permutation\np=[1,2,3,4]\nis not a valid permutation as we can choose\ni=1\nand\nj=3\n. Then\np\n1\n=1\ndivides\np\n3\n=3\nand\np\n2\n=2\ndivides\np\n4\n=4\n. Note that the permutation\np=[3,4,2,1]\nis also not a valid permutation as we can choose\ni=3\nand\nj=2\n. Then\np\n3\n=2\ndivides\np\n2\n=4\nand\np\n4\n=1\ndivides\np\n3\n=2\n.\nIn the second test case,\np=[1,2,3]\nis a valid permutation. In fact, all\n6\npermutations of length\n3\nare valid.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "math",
            "*1000"
        ]
    },
    {
        "title": "A. Maximise The Score",
        "description": "There are\n2n\npositive integers written on a whiteboard. Being bored, you decided to play a one-player game with the numbers on the whiteboard.\nYou start with a score of\n0\n. You will increase your score by performing the following move exactly\nn\ntimes:\nChoose two integers\nx\nand\ny\nthat are written on the whiteboard.\nAdd\nmin(x,y)\nto your score.\nErase\nx\nand\ny\nfrom the whiteboard.\nNote that after performing the move\nn\ntimes, there will be no more integers written on the whiteboard.\nFind the maximum final score you can achieve if you optimally perform the\nn\nmoves.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤50\n) — the number of integers written on the whiteboard is\n2n\n.\nThe second line of each test case contains\n2n\nintegers\na\n1\n,\na\n2\n,…,\na\n2n\n(\n1≤\na\ni\n≤\n10\n7\n) — the numbers written on the whiteboard.\nOutput\nFor each test case, output the maximum final score that you can achieve.\nExample\ninput\nCopy\n3\n1\n2 3\n2\n1 1 2 1\n3\n1 1 1 1 1 1\noutput\nCopy\n2\n2\n3\nNote\nIn the first test case, you can only make one move. You select\nx=2\nand\ny=3\n, and your score will be\nmin(x,y)=2\n.\nIn the second test case, the following is a sequence of moves that achieves a final score of\n2\n:\nIn the first move, select\nx=1\nand\ny=1\n. Then, add\nmin(x,y)=1\nto the score. After erasing\nx\nand\ny\n, the integers left on the whiteboard are\n1\nand\n2\n.\nIn the second move, select\nx=1\nand\ny=2\n. Then, add\nmin(x,y)=1\nto the score. After removing\nx\nand\ny\n, no more integers will be left on the whiteboard.\nIt can be proved that it is not possible to get a score greater than\n2\n.\nIn the third test case, you will perform the move thrice, adding\n1\nto the score each time.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "F. Sasha and the Wedding Binary Search Tree",
        "description": "Having overcome all the difficulties and hardships, Sasha finally decided to marry his girlfriend. To do this, he needs to give her an engagement ring. However, his girlfriend does not like such romantic gestures, but she does like binary search trees\n†\n†\n. So Sasha decided to give her such a tree.\nAfter spending a lot of time on wedding websites for programmers, he found the perfect binary search tree with the root at vertex\n1\n. In this tree, the value at vertex\nv\nis equal to\nva\nl\nv\n.\nBut after some time, he forgot the values in some vertices. Trying to remember the found tree, Sasha wondered — how many binary search trees could he have found on the website, if it is known that the values in all vertices are integers in the segment\n[1,C]\n. Since this number can be very large, output it modulo\n998244353\n.\n†\n†\nA binary search tree is a rooted binary tree in which for any vertex\nx\n, the following property holds: the values of all vertices in the left subtree of vertex\nx\n(if it exists) are less than or equal to the value at vertex\nx\n, and the values of all vertices in the right subtree of vertex\nx\n(if it exists) are greater than or equal to the value at vertex\nx\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nC\n(\n2≤n≤5⋅\n10\n5\n,\n1≤C≤\n10\n9\n) — the number of vertices in the tree and the maximum allowed value at the vertex.\nThe next\nn\nlines describe the vertices of the tree. The\ni\n-th line contains three integers\nL\ni\n,\nR\ni\nand\nva\nl\ni\n(\n−1≤\nL\ni\n,\nR\ni\n≤n\n,\n−1≤va\nl\ni\n≤C\n,\nL\ni\n,\nR\ni\n,va\nl\ni\n≠0\n) — the number of the left child, the number of the right child, and the value at the\ni\n-th vertex, respectively. If\nL\ni\n=−1\n, then the\ni\n-th vertex has no left son. If\nR\ni\n=−1\n, then the\ni\n-th vertex has no right son. If\nva\nl\ni\n=−1\n, then the value at the\ni\n-th vertex is unknown.\nIt is guaranteed that at least one suitable binary search tree exists.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of suitable binary search trees modulo\n998244353\n.\nExample\ninput\nCopy\n3\n5 5\n2 3 -1\n-1 -1 2\n4 -1 3\n-1 5 -1\n-1 -1 -1\n3 69\n2 3 47\n-1 -1 13\n-1 -1 69\n3 3\n2 3 -1\n-1 -1 -1\n-1 -1 -1\noutput\nCopy\n4\n1\n10\nNote\nIn the first test case, the binary search tree has the following form:\nThen the possible values at the vertices are:\n[2,2,3,2,2]\n,\n[2,2,3,2,3]\n,\n[2,2,3,3,3]\n, and\n[3,2,3,3,3]\n.\nIn the second test case, the values at all vertices are known, so there is only one suitable binary search tree.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "dfs and similar",
            "math",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "E. Sasha and the Happy Tree Cutting",
        "description": "Sasha was given a tree\n†\n†\nwith\nn\nvertices as a prize for winning yet another competition. However, upon returning home after celebrating his victory, he noticed that some parts of the tree were missing. Sasha remembers that he colored some of the edges of this tree. He is certain that for any of the\nk\npairs of vertices\n(\na\n1\n,\nb\n1\n),…,(\na\nk\n,\nb\nk\n)\n, he colored at least one edge on the simple path\n‡\n‡\nbetween vertices\na\ni\nand\nb\ni\n.\nSasha does not remember how many edges he exactly colored, so he asks you to tell him the minimum number of edges he could have colored to satisfy the above condition.\n†\n†\nA tree is an undirected connected graph without cycles.\n‡\n‡\nA simple path is a path that passes through each vertex at most once.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the tree.\nThe next\n(n−1)\nlines describe the edges of the tree. The\ni\n-th line contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n) — the numbers of the vertices connected by the\ni\n-th edge.\nThe next line contains a single integer\nk\n(\n1≤k≤20\n) — the number of pairs of vertices between which Sasha colored at least one edge on a simple path.\nThe next\nk\nlines describe pairs. The\nj\n-th line contains two integers\na\nj\nand\nb\nj\n(\n1≤\na\nj\n,\nb\nj\n≤n,\na\nj\n≠\nb\nj\n) — the vertices in the\nj\n-th pair.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n. It is guaranteed that the sum of\n2\nk\nover all test cases does not exceed\n2\n20\n.\nOutput\nFor each test case, output a single integer — the minimum number of edges Sasha could have colored.\nExample\ninput\nCopy\n3\n4\n1 2\n2 3\n2 4\n2\n1 3\n4 1\n6\n1 2\n3 1\n6 1\n5 2\n4 2\n3\n3 1\n3 6\n2 6\n5\n1 2\n2 3\n3 4\n4 5\n4\n1 2\n2 3\n3 4\n4 5\noutput\nCopy\n1\n2\n4\nNote\nIn the first test case, Sasha could have colored only one edge\n(1,2)\n. Then, there would be at least one colored edge on the simple path between vertices\n1\nand\n3\n, and vertices\n4\nand\n1\n.\nIn the second test case, Sasha could have colored the edges\n(1,6)\nand\n(1,3)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dfs and similar",
            "dp",
            "graphs",
            "greedy",
            "math",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "D. Sasha and a Walk in the City",
        "description": "Sasha wants to take a walk with his girlfriend in the city. The city consists of\nn\nintersections, numbered from\n1\nto\nn\n. Some of them are connected by roads, and from any intersection, there is exactly one simple path\n†\n†\nto any other intersection. In other words, the intersections and the roads between them form a tree.\nSome of the intersections are considered dangerous. Since it is unsafe to walk alone in the city, Sasha does not want to visit three or more dangerous intersections during the walk.\nSasha calls a set of intersections good if the following condition is satisfied:\nIf in the city only the intersections contained in this set are dangerous, then any simple path in the city contains no more than two dangerous intersections.\nHowever, Sasha does not know which intersections are dangerous, so he is interested in the number of different good sets of intersections in the city. Since this number can be very large, output it modulo\n998244353\n.\n†\n†\nA simple path is a path that passes through each intersection at most once.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤3⋅\n10\n5\n) — the number of intersections in the city.\nThe next\n(n−1)\nlines describe the roads. The\ni\n-th line contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n) — the numbers of the intersections connected by the\ni\n-th road.\nIt is guaranteed that these roads form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of good sets of intersections modulo\n998244353\n.\nExample\ninput\nCopy\n4\n3\n1 3\n3 2\n4\n3 4\n2 3\n3 1\n5\n1 2\n3 4\n5 1\n2 3\n4\n1 2\n2 3\n3 4\noutput\nCopy\n7\n12\n16\n11\nNote\nIn the first test case, there are\n2\n3\n=8\nsets of intersections. All of them are good, except for the set\n{1,2,3}\n, because if intersections\n1,2\n, and\n3\nare dangerous, then the simple path\n1−2−3\ncontains\n3\ndangerous intersections. Thus, there are\n7\ngood sets.\nIn the second test case, there are\n2\n4\n=16\nsets of intersections. Among them, the sets\n{1,2,3,4}\n,\n{1,2,3}\n,\n{1,3,4}\n,\n{2,3,4}\nare not good. Thus, there are a total of\n12\ngood sets. The city layout is shown below:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "C. Sasha and the Casino",
        "description": "Sasha decided to give his girlfriend the best handbag, but unfortunately for Sasha, it is very expensive. Therefore, Sasha wants to earn it. After looking at earning tips on the internet, he decided to go to the casino.\nSasha knows that the casino operates under the following rules. If Sasha places a bet of\ny\ncoins (where\ny\nis a positive integer), then in case of winning, he will receive\ny⋅k\ncoins (i.e., his number of coins will increase by\ny⋅(k−1)\n). And in case of losing, he will lose the entire bet amount (i.e., his number of coins will decrease by\ny\n).\nNote that the bet amount must always be a positive (\n>0\n) integer and cannot exceed Sasha's current number of coins.\nSasha also knows that there is a promotion at the casino: he cannot lose more than\nx\ntimes in a row.\nInitially, Sasha has\na\ncoins. He wonders whether he can place bets such that he is guaranteed to win any number of coins. In other words, is it true that for any integer\nn\n, Sasha can make bets so that for any outcome that does not contradict the rules described above, at some moment of time he will have at least\nn\ncoins.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe single line of each test case contains three integers\nk,x\nand\na\n(\n2≤k≤30\n,\n1≤x≤100\n,\n1≤a≤\n10\n9\n) — the number of times the bet is increased in case of a win, the maximum number of consecutive losses, and the initial number of coins Sasha has.\nOutput\nFor each test case, output \"YES\" (without quotes) if Sasha can achieve it and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, the strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive answer).\nExample\ninput\nCopy\n9\n2 1 7\n2 1 1\n2 3 15\n3 3 6\n4 4 5\n5 4 7\n4 88 1000000000\n25 69 231\n13 97 18806\noutput\nCopy\nYES\nNO\nYES\nNO\nNO\nYES\nNO\nNO\nNO\nNote\nIn the first test case, Sasha can proceed as follows:\nIf Sasha places a bet for the first time or if he won the previous bet, then he places\n1\ncoin.\nIf Sasha lost the previous bet, then he places\n2\ncoins.\nNote that Sasha cannot lose more than once in a row.\nIt can be proven that with this strategy, Sasha can obtain as many coins as he wants.\nIn the second test case, Sasha can only place\n1\ncoin for the first time. But in case of a loss, he will not be able to place any more bets, so he will not be able to guarantee having as many coins as he wants.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "constructive algorithms",
            "games",
            "greedy",
            "math",
            "*1400"
        ]
    },
    {
        "title": "B. Sasha and the Drawing",
        "description": "Even in kindergarten, Sasha liked a girl. Therefore, he wanted to give her a drawing and attract her attention.\nAs a drawing, he decided to draw a square grid of size\nn×n\n, in which some cells are colored. But coloring the cells is difficult, so he wants to color as few cells as possible. But at the same time, he wants at least\nk\ndiagonals to have at least one colored cell. Note that the square grid of size\nn×n\nhas a total of\n4n−2\ndiagonals.\nHelp little Sasha to make the girl fall in love with him and tell him the minimum number of cells he needs to color.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n2≤n≤\n10\n8\n,\n1≤k≤4n−2\n) — the size of the square grid and the minimum number of diagonals in which there should be at least one colored cell.\nOutput\nFor each test case, output a single integer — the minimum number of cells that need to be colored.\nExample\ninput\nCopy\n7\n3 4\n3 3\n3 10\n3 9\n4 7\n7 11\n2 3\noutput\nCopy\n2\n2\n6\n5\n4\n6\n2\nNote\nIn the pictures below, the colored cells are marked in black, and all diagonals are marked in purple.\nIn the first test case, you can color\n2\ncells so that\n4\ndiagonals contain at least one colored cell:\nIn the third test case, you can color\n6\ncells so that all\n10\ndiagonals contain at least one colored cell:",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "A. Sasha and the Beautiful Array",
        "description": "Sasha decided to give his girlfriend an array\na\n1\n,\na\n2\n,…,\na\nn\n. He found out that his girlfriend evaluates the beauty of the array as the sum of the values\n(\na\ni\n−\na\ni−1\n)\nfor all integers\ni\nfrom\n2\nto\nn\n.\nHelp Sasha and tell him the maximum beauty of the array\na\nthat he can obtain, if he can rearrange its elements in any way.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤100\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nOutput\nFor each test case, output a single integer — the maximum beauty of the array\na\nthat can be obtained.\nExample\ninput\nCopy\n5\n3\n2 1 3\n3\n69 69 69\n5\n100 54 80 43 90\n4\n3 4 3 3\n2\n2 1\noutput\nCopy\n2\n0\n57\n1\n1\nNote\nIn the first test case, the elements of the array\na\ncan be rearranged to make\na=[1,2,3]\n. Then its beauty will be equal to\n(\na\n2\n−\na\n1\n)+(\na\n3\n−\na\n2\n)=(2−1)+(3−2)=2\n.\nIn the second test case, there is no need to rearrange the elements of the array\na\n. Then its beauty will be equal to\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*800"
        ]
    },
    {
        "title": "F. Digital Patterns",
        "description": "Anya is engaged in needlework. Today she decided to knit a scarf from semi-transparent threads. Each thread is characterized by a single integer — the transparency coefficient.\nThe scarf is made according to the following scheme: horizontal threads with transparency coefficients\na\n1\n,\na\n2\n,…,\na\nn\nand vertical threads with transparency coefficients\nb\n1\n,\nb\n2\n,…,\nb\nm\nare selected. Then they are interwoven as shown in the picture below, forming a piece of fabric of size\nn×m\n, consisting of exactly\nnm\nnodes:\nExample of a piece of fabric for\nn=m=4\n.\nAfter the interweaving tightens and there are no gaps between the threads, each node formed by a horizontal thread with number\ni\nand a vertical thread with number\nj\nwill turn into a cell, which we will denote as\n(i,j)\n. Cell\n(i,j)\nwill have a transparency coefficient of\na\ni\n+\nb\nj\n.\nThe interestingness of the resulting scarf will be the number of its sub-squares\n†\n†\nin which there are no pairs of neighboring\n††\ncells with the same transparency coefficients.\nAnya has not yet decided which threads to use for the scarf, so you will also be given\nq\nqueries to increase/decrease the coefficients for the threads on some ranges. After each query of which you need to output the interestingness of the resulting scarf.\n†\n†\nA sub-square of a piece of fabric is defined as the set of all its cells\n(i,j)\n, such that\nx\n0\n≤i≤\nx\n0\n+d\nand\ny\n0\n≤j≤\ny\n0\n+d\nfor some integers\nx\n0\n,\ny\n0\n, and\nd\n(\n1≤\nx\n0\n≤n−d\n,\n1≤\ny\n0\n≤m−d\n,\nd≥0\n).\n††\n. Cells\n(\ni\n1\n,\nj\n1\n)\nand\n(\ni\n2\n,\nj\n2\n)\nare neighboring if and only if\n|\ni\n1\n−\ni\n2\n|+|\nj\n1\n−\nj\n2\n|=1\n.\nInput\nThe first line contains three integers\nn\n,\nm\n, and\nq\n(\n1≤n,m≤3⋅\n10\n5\n,\n0≤q≤3⋅\n10\n5\n) — the number of horizontal threads, the number of vertical threads, and the number of change requests.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n) — the transparency coefficients for the horizontal threads, with the threads numbered from top to bottom.\nThe third line contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n−\n10\n9\n≤\nb\ni\n≤\n10\n9\n) — the transparency coefficients for the vertical threads, with the threads numbered from left to right.\nThe next\nq\nlines specify the change requests. Each request is described by a quadruple of integers\nt\n,\nl\n,\nr\n, and\nx\n(\n1≤t≤2\n,\nl≤r\n,\n−\n10\n9\n≤x≤\n10\n9\n). Depending on the parameter\nt\nin the request, the following actions are required:\nt=1\n. The transparency coefficients for the horizontal threads in the range\n[l,r]\nare increased by\nx\n(in other words, for all integers\nl≤i≤r\n, the value of\na\ni\nis increased by\nx\n);\nt=2\n. The transparency coefficients for the vertical threads in the range\n[l,r]\nare increased by\nx\n(in other words, for all integers\nl≤i≤r\n, the value of\nb\ni\nis increased by\nx\n).\nOutput\nOutput\n(q+1)\nlines. In the\n(i+1)\n-th line (\n0≤i≤q\n), output a single integer — the interestingness of the scarf after applying the first\ni\nrequests.\nExamples\ninput\nCopy\n4 4 0\n1 1 2 3\n1 2 2 3\noutput\nCopy\n20\ninput\nCopy\n3 3 2\n1 1 1\n2 2 8\n1 2 3 1\n2 2 3 -6\noutput\nCopy\n9\n10\n11\ninput\nCopy\n3 2 2\n-1000000000 0 1000000000\n-1000000000 1000000000\n1 1 1 1000000000\n2 2 2 -1000000000\noutput\nCopy\n8\n7\n7\nNote\nIn the first example, the transparency coefficients of the cells in the resulting plate are as follows:\n2 3 3 4\n2 3 3 4\n3 4 4 5\n4 5 5 6\nThen there are the following sub-squares that do not contain two neighboring cells with the same transparency coefficient:\nEach of the\n16\ncells separately;\nA sub-square with the upper left corner at cell\n(3,1)\nand the lower right corner at cell\n(4,2)\n;\nA sub-square with the upper left corner at cell\n(2,3)\nand the lower right corner at cell\n(3,4)\n;\nA sub-square with the upper left corner at cell\n(2,1)\nand the lower right corner at cell\n(3,2)\n;\nA sub-square with the upper left corner at cell\n(3,3)\nand the lower right corner at cell\n(4,4)\n.\nIn the second example, after the first query, the transparency coefficients of the horizontal threads are\n[1,2,2]\n. After the second query, the transparency coefficients of the vertical threads are\n[2,−4,2]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "implementation",
            "math",
            "*2900"
        ]
    },
    {
        "title": "E. Modular Sequence",
        "description": "You are given two integers\nx\nand\ny\n. A sequence\na\nof length\nn\nis called modular if\na\n1\n=x\n, and for all\n1<i≤n\nthe value of\na\ni\nis either\na\ni−1\n+y\nor\na\ni−1\nmody\n. Here\nxmody\ndenotes the remainder from dividing\nx\nby\ny\n.\nDetermine if there exists a modular sequence of length\nn\nwith the sum of its elements equal to\nS\n, and if it exists, find any such sequence.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤2⋅\n10\n4\n). The description of the test cases follows.\nThe first and only line of each test case contains four integers\nn\n,\nx\n,\ny\n, and\ns\n(\n1≤n≤2⋅\n10\n5\n,\n0≤x≤2⋅\n10\n5\n,\n1≤y≤2⋅\n10\n5\n,\n0≤s≤2⋅\n10\n5\n) — the length of the sequence, the parameters\nx\nand\ny\n, and the required sum of the sequence elements.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n, and also the sum of\ns\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, if the desired sequence exists, output \"Yes\" on the first line (without quotes). Then, on the second line, output\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\nseparated by a space — the elements of the sequence\na\n. If there are multiple suitable sequences, output any of them.\nIf the sequence does not exist, output \"No\" on a single line.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n3\n5 8 3 28\n3 5 3 6\n9 1 5 79\noutput\nCopy\nYES\n8 11 2 2 5 \nNO\nNO\nNote\nIn the first example, the sequence\n[8,11,2,5,2]\nsatisfies the conditions. Thus,\na\n1\n=8=x\n,\na\n2\n=11=\na\n1\n+3\n,\na\n3\n=2=\na\n2\nmod3\n,\na\n4\n=5=\na\n3\n+3\n,\na\n5\n=2=\na\n4\nmod3\n.\nIn the second example, the first element of the sequence should be equal to\n5\n, so the sequence\n[2,2,2]\nis not suitable.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "dp",
            "graphs",
            "greedy",
            "math",
            "number theory",
            "*2300"
        ]
    },
    {
        "title": "D. Lonely Mountain Dungeons",
        "description": "Once, the people, elves, dwarves, and other inhabitants of Middle-earth gathered to reclaim the treasures stolen from them by Smaug. In the name of this great goal, they rallied around the powerful elf Timothy and began to plan the overthrow of the ruler of the Lonely Mountain.\nThe army of Middle-earth inhabitants will consist of several squads. It is known that each pair of creatures of the same race, which are in different squads, adds\nb\nunits to the total strength of the army. But since it will be difficult for Timothy to lead an army consisting of a large number of squads, the total strength of an army consisting of\nk\nsquads is reduced by\n(k−1)⋅x\nunits. Note that the army always consists of at least one squad.\nIt is known that there are\nn\nraces in Middle-earth, and the number of creatures of the\ni\n-th race is equal to\nc\ni\n. Help the inhabitants of Middle-earth determine the maximum strength of the army they can assemble.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nb\n, and\nx\n(\n1≤n≤2⋅\n10\n5\n,\n1≤b≤\n10\n6\n,0≤x≤\n10\n9\n) — the number of races and the constants\nb\nand\nx\ndescribed above.\nThe second line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤2⋅\n10\n5\n) — the number of creatures of each of the\nn\nraces.\nIt is guaranteed that the sum of the values\nc\n1\n+\nc\n2\n+…+\nc\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum strength of the army that the inhabitants of Middle-earth can assemble.\nExample\ninput\nCopy\n5\n3 1 0\n1 2 3\n3 5 10\n2 5 3\n4 3 3\n3 2 1 2\n4 1 0\n4 1 4 2\n4 1 10\n4 1 4 2\noutput\nCopy\n4\n40\n9\n13\n0\nNote\nIn the first test case, the inhabitants of Middle-earth can form\n3\nsquads. Since\nx=0\n, the army's strength will not decrease due to the number of squads. The inhabitants can be distributed among the squads as follows:\nThe single representative of the first species can be sent to the first squad.\nThe first representative of the second species can be sent to the first squad, the second representative of the second species can be sent to the second squad. Then the total strength of the army will increase by\nb=1\n.\nThe first representative of the third species can be sent to the first squad, the second representative of the third species can be sent to the second squad, the third representative of the third species can be sent to the third squad. Then the total strength of the army will increase by\n3⋅b=3\n, as they form three pairs in different squads.\nThus, the total strength of the army is\n4\n.\nIn the second test case, the inhabitants of Middle-earth can form\n3\nsquads. Since\nx=10\n, the army's strength will decrease by\n20\n. The inhabitants can be distributed among the squads as follows:\nThe first representative of the first species can be sent to the first squad, the second representative of the first species can be sent to the second squad. Then the total strength of the army will increase by\nb=5\n.\nThe first and second representatives of the second species can be sent to the first squad, the third and fourth representatives of the second species can be sent to the second squad, the fifth representative of the second species can be sent to the third squad. Then the total strength of the army will increase by\n8⋅b=40\n.\nThe first representative of the third species can be sent to the first squad, the second representative of the third species can be sent to the second squad, the third representative of the third species can be sent to the third squad. Then the total strength of the army will increase by\n3⋅b=15\n, as they form three pairs in different squads.\nThus, the total strength of the army is\n5+40+15−20=40\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "math",
            "ternary search",
            "*1900"
        ]
    },
    {
        "title": "C. Physical Education Lesson",
        "description": "In a well-known school, a physical education lesson took place. As usual, everyone was lined up and asked to settle in \"the first–\nk\n-th\" position.\nAs is known, settling in \"the first–\nk\n-th\" position occurs as follows: the first\nk\npeople have numbers\n1,2,3,…,k\n, the next\nk−2\npeople have numbers\nk−1,k−2,…,2\n, the next\nk\npeople have numbers\n1,2,3,…,k\n, and so on. Thus, the settling repeats every\n2k−2\npositions. Examples of settling are given in the \"Note\" section.\nThe boy Vasya constantly forgets everything. For example, he forgot the number\nk\ndescribed above. But he remembers the position he occupied in the line, as well as the number he received during the settling. Help Vasya understand how many natural numbers\nk\nfit under the given constraints.\nNote that the settling exists if and only if\nk>1\n. In particular, this means that the settling does not exist for\nk=1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. This is followed by the description of the test cases.\nThe only line of each test case contains two integers\nn\nand\nx\n(\n1≤x<n≤\n10\n9\n) — Vasya's position in the line and the number Vasya received during the settling.\nOutput\nFor each test case, output a single integer — the number of different\nk\nthat fit under the given constraints.\nIt can be proven that under the given constraints, the answer is finite.\nExample\ninput\nCopy\n5\n10 2\n3 1\n76 4\n100 99\n1000000000 500000000\noutput\nCopy\n4\n1\n9\n0\n1\nNote\nIn the first test case,\nk\nequals\n2,3,5,6\nare suitable.\nAn example of settling for these\nk\n:\nk\n/ №\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n2\n1\n2\n1\n2\n1\n2\n1\n2\n1\n2\n3\n1\n2\n3\n2\n1\n2\n3\n2\n1\n2\n5\n1\n2\n3\n4\n5\n4\n3\n2\n1\n2\n6\n1\n2\n3\n4\n5\n6\n5\n4\n3\n2\nIn the second test case,\nk=2\nis suitable.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1600"
        ]
    },
    {
        "title": "B. Equalize",
        "description": "Vasya has two hobbies — adding permutations\n†\n†\nto arrays and finding the most frequently occurring element. Recently, he found an array\na\nand decided to find out the maximum number of elements equal to the same number in the array\na\nthat he can obtain after adding some permutation to the array\na\n.\nMore formally, Vasya must choose exactly one permutation\np\n1\n,\np\n2\n,\np\n3\n,…,\np\nn\nof length\nn\n, and then change the elements of the array\na\naccording to the rule\na\ni\n:=\na\ni\n+\np\ni\n. After that, Vasya counts how many times each number occurs in the array\na\nand takes the maximum of these values. You need to determine the maximum value he can obtain.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single number — the maximum number of elements equal to the same number after the operation of adding a permutation.\nExample\ninput\nCopy\n7\n2\n1 2\n4\n7 1 4 1\n3\n103 102 104\n5\n1 101 1 100 1\n5\n1 10 100 1000 1\n2\n3 1\n3\n1000000000 999999997 999999999\noutput\nCopy\n2\n2\n3\n2\n1\n1\n2\nNote\nIn the first test case, it is optimal to choose\np=[2,1]\n. Then after applying the operation, the array\na\nwill be\n[3,3]\n, in which the number\n3\noccurs twice, so the answer is\n2\n.\nIn the second test case, one of the optimal options is\np=[2,3,1,4]\n. After applying the operation, the array\na\nwill be\n[9,4,5,5]\n. Since the number\n5\noccurs twice, the answer is\n2\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "two pointers",
            "*1200"
        ]
    },
    {
        "title": "A. Rectangle Cutting",
        "description": "Bob has a rectangle of size\na×b\n. He tries to cut this rectangle into two rectangles with integer sides by making a cut parallel to one of the sides of the original rectangle. Then Bob tries to form some other rectangle from the two resulting rectangles, and he can rotate and move these two rectangles as he wishes.\nNote that if two rectangles differ only by a\n90\n∘\nrotation, they are considered the same. For example, the rectangles\n6×4\nand\n4×6\nare considered the same.\nThus, from the\n2×6\nrectangle, another rectangle can be formed, because it can be cut into two\n2×3\nrectangles, and then these two rectangles can be used to form the\n4×3\nrectangle, which is different from the\n2×6\nrectangle.\nHowever, from the\n2×1\nrectangle, another rectangle cannot be formed, because it can only be cut into two rectangles of\n1×1\n, and from these, only the\n1×2\nand\n2×1\nrectangles can be formed, which are considered the same.\nHelp Bob determine if he can obtain some other rectangle, or if he is just wasting his time.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by the description of the test cases.\nThe single line of each test case contains two integers\na\nand\nb\n(\n1≤a,b≤\n10\n9\n) — the size of Bob's rectangle.\nOutput\nFor each test case, output \"Yes\" if Bob can obtain another rectangle from the\na×b\nrectangle. Otherwise, output \"No\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive answers.\nExample\ninput\nCopy\n7\n1 1\n2 1\n2 6\n3 2\n2 2\n2 4\n6 3\noutput\nCopy\nNo\nNo\nYes\nYes\nYes\nYes\nNo\nNote\nIn the first test case, the\n1×1\nrectangle cannot be cut into two rectangles, so another rectangle cannot be obtained from it.\nIn the fourth test case, the\n3×2\nrectangle can be cut into two\n3×1\nrectangles, and from these, the\n1×6\nrectangle can be formed.\nIn the fifth test case, the\n2×2\nrectangle can be cut into two\n1×2\nrectangles, and from these, the\n1×4\nrectangle can be formed.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Paint Charges",
        "description": "A horizontal grid strip of\nn\ncells is given. In the\ni\n-th cell, there is a paint charge of size\na\ni\n. This charge can be:\neither used to the left — then all cells to the left at a distance less than\na\ni\n(from\nmax(i−\na\ni\n+1,1)\nto\ni\ninclusive) will be painted,\nor used to the right — then all cells to the right at a distance less than\na\ni\n(from\ni\nto\nmin(i+\na\ni\n−1,n)\ninclusive) will be painted,\nor not used at all.\nNote that a charge can be used no more than once (that is, it cannot be used simultaneously to the left and to the right). It is allowed for a cell to be painted more than once.\nWhat is the minimum number of times a charge needs to be used to paint all the cells of the strip?\nInput\nThe first line of the input contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases in the test. This is followed by descriptions of\nt\ntest cases.\nEach test case is specified by two lines. The first one contains an integer\nn\n(\n1≤n≤100\n) — the number of cells in the strip. The second line contains\nn\npositive integers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n), where\na\ni\nis the size of the paint charge in the\ni\n-th cell from the left of the strip.\nIt is guaranteed that the sum of the values of\nn\nin the test does not exceed\n1000\n.\nOutput\nFor each test case, output the minimum number of times the charges need to be used to paint all the cells of the strip.\nExample\ninput\nCopy\n13\n1\n1\n2\n1 1\n2\n2 1\n2\n1 2\n2\n2 2\n3\n1 1 1\n3\n3 1 2\n3\n1 3 1\n7\n1 2 3 1 2 4 2\n7\n2 1 1 1 2 3 1\n10\n2 2 5 1 6 1 8 2 8 2\n6\n2 1 2 1 1 2\n6\n1 1 4 1 3 2\noutput\nCopy\n1\n2\n1\n1\n1\n3\n1\n2\n3\n4\n2\n3\n3\nNote\nIn the third test case of the example, it is sufficient to use the charge from the\n1\n-st cell to the right, then it will cover both cells\n1\nand\n2\n.\nIn the ninth test case of the example, you need to:\nuse the charge from the\n3\n-rd cell to the left, covering cells from the\n1\n-st to the\n3\n-rd;\nuse the charge from the\n5\n-th cell to the left, covering cells from the\n4\n-th to the\n5\n-th;\nuse the charge from the\n7\n-th cell to the left, covering cells from the\n6\n-th to the\n7\n-th.\nIn the eleventh test case of the example, you need to:\nuse the charge from the\n5\n-th cell to the right, covering cells from the\n5\n-th to the\n10\n-th;\nuse the charge from the\n7\n-th cell to the left, covering cells from the\n1\n-st to the\n7\n-th.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "math",
            "*2300"
        ]
    },
    {
        "title": "F. Microcycle",
        "description": "Given an undirected weighted graph with\nn\nvertices and\nm\nedges. There is at most one edge between each pair of vertices in the graph, and the graph does not contain loops (edges from a vertex to itself). The graph is not necessarily connected.\nA cycle in the graph is called simple if it doesn't pass through the same vertex twice and doesn't contain the same edge twice.\nFind any simple cycle in this graph in which the weight of the lightest edge is minimal.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n3≤n≤m≤min(\nn⋅(n−1)\n2\n,2⋅\n10\n5\n)\n) — the size of the graph and the number of edges.\nThe next\nm\nlines of the test case contain three integers\nu\n,\nv\n, and\nw\n(\n1≤u,v≤n\n,\nu≠v\n,\n1≤w≤\n10\n6\n) — vertices\nu\nand\nv\nare connected by an edge of weight\nw\n.\nIt is guaranteed that there is at most one edge between each pair of vertices. Note that under the given constraints, there is always at least one simple cycle in the graph.\nIt is guaranteed that the sum of the values of\nm\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a pair of numbers\nb\nand\nk\n, where:\nb\n — the minimum weight of the edge in the found cycle,\nk\n — the number of vertices in the found cycle.\nOn the next line, output\nk\nnumbers from\n1\nto\nn\n — the vertices of the cycle in traversal order.\nNote that the answer always exists, as under the given constraints, there is always at least one simple cycle in the graph.\nExample\ninput\nCopy\n5\n6 6\n1 2 1\n2 3 1\n3 1 1\n4 5 1\n5 6 1\n6 4 1\n6 6\n1 2 10\n2 3 8\n3 1 5\n4 5 100\n5 6 40\n6 4 3\n6 15\n1 2 4\n5 2 8\n6 1 7\n6 3 10\n6 5 1\n3 2 8\n4 3 4\n5 3 6\n2 6 6\n5 4 5\n4 1 3\n6 4 5\n4 2 1\n3 1 7\n1 5 5\n4 6\n2 3 2\n1 3 10\n1 4 1\n3 4 7\n2 4 5\n1 2 2\n4 5\n2 1 10\n3 1 3\n4 2 6\n1 4 7\n2 3 3\noutput\nCopy\n1 3\n1 2 3 \n3 3\n6 4 5 \n1 5\n4 2 1 6 3 \n1 4\n1 4 3 2 \n3 3\n2 3 1 ",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "greedy",
            "implementation",
            "sortings",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "E. Klever Permutation",
        "description": "You are given two integers\nn\nand\nk\n(\nk≤n\n), where\nk\nis even.\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin any order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (as\n2\nappears twice in the array) and\n[0,1,2]\nis also not a permutation (as\nn=3\n, but\n3\nis not present in the array).\nYour task is to construct a\nk\n-level permutation of length\nn\n.\nA permutation is called\nk\n-level if, among all the sums of continuous segments of length\nk\n(of which there are exactly\nn−k+1\n), any two sums differ by no more than\n1\n.\nMore formally, to determine if the permutation\np\nis\nk\n-level, first construct an array\ns\nof length\nn−k+1\n, where\ns\ni\n=\n∑\ni+k−1\nj=i\np\nj\n, i.e., the\ni\n-th element is equal to the sum of\np\ni\n,\np\ni+1\n,…,\np\ni+k−1\n.\nA permutation is called\nk\n-level if\nmax(s)−min(s)≤1\n.\nFind any\nk\n-level permutation of length\nn\n.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by the description of the test cases.\nThe first and only line of each test case contains two integers\nn\nand\nk\n(\n2≤k≤n≤2⋅\n10\n5\n,\nk\nis even), where\nn\nis the length of the desired permutation.\nIt is guaranteed that the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output any\nk\n-level permutation of length\nn\n.\nIt is guaranteed that such a permutation always exists given the constraints.\nExample\ninput\nCopy\n5\n2 2\n3 2\n10 4\n13 4\n7 4\noutput\nCopy\n2 1\n1 3 2\n1 8 4 10 2 7 5 9 3 6\n4 10 1 13 5 9 2 12 6 8 3 11 7\n1 6 3 7 2 5 4\nNote\nIn the second test case of the example:\np\n1\n+\np\n2\n=3+1=4\n;\np\n2\n+\np\n3\n=1+2=3\n.\nThe maximum among the sums is\n4\n, and the minimum is\n3\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "two pointers",
            "*1400"
        ]
    },
    {
        "title": "D. Find the Different Ones!",
        "description": "You are given an array\na\nof\nn\nintegers, and\nq\nqueries.\nEach query is represented by two integers\nl\nand\nr\n(\n1≤l≤r≤n\n). Your task is to find, for each query, two indices\ni\nand\nj\n(or determine that they do not exist) such that:\nl≤i≤r\n;\nl≤j≤r\n;\na\ni\n≠\na\nj\n.\nIn other words, for each query, you need to find a pair of different elements among\na\nl\n,\na\nl+1\n,…,\na\nr\n, or report that such a pair does not exist.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of the array\na\n.\nThe third line of each test case contains a single integer\nq\n(\n1≤q≤2⋅\n10\n5\n) — the number of queries.\nThe next\nq\nlines contain two integers each,\nl\nand\nr\n(\n1≤l<r≤n\n) — the boundaries of the query.\nIt is guaranteed that the sum of the values of\nn\nacross all test cases does not exceed\n2⋅\n10\n5\n. Similarly, it is guaranteed that the sum of the values of\nq\nacross all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output two integers separated by space:\ni\nand\nj\n(\nl≤i,j≤r\n), for which\na\ni\n≠\na\nj\n. If such a pair does not exist, output\ni=−1\nand\nj=−1\n.\nYou may separate the outputs for the test cases with empty lines. This is not a mandatory requirement.\nExample\ninput\nCopy\n5\n5\n1 1 2 1 1\n3\n1 5\n1 2\n1 3\n6\n30 20 20 10 10 20\n5\n1 2\n2 3\n2 4\n2 6\n3 5\n4\n5 2 3 4\n4\n1 2\n1 4\n2 3\n2 4\n5\n1 4 3 2 4\n5\n1 5\n2 4\n3 4\n3 5\n4 5\n5\n2 3 1 4 2\n7\n1 2\n1 4\n1 5\n2 4\n2 5\n3 5\n4 5\noutput\nCopy\n2 3\n-1 -1\n1 3\n\n2 1\n-1 -1\n4 2\n4 6\n5 3\n\n1 2\n1 2\n2 3\n3 2\n\n1 3\n2 4\n3 4\n5 3\n5 4\n\n1 2\n4 2\n1 3\n2 3\n3 2\n5 4\n5 4",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dp",
            "dsu",
            "greedy",
            "two pointers",
            "*1300"
        ]
    },
    {
        "title": "C. Choose the Different Ones!",
        "description": "Given an array\na\nof\nn\nintegers, an array\nb\nof\nm\nintegers, and an even number\nk\n.\nYour task is to determine whether it is possible to choose exactly\nk\n2\nelements from both arrays in such a way that among the chosen elements, every integer from\n1\nto\nk\nis included.\nFor example:\nIf\na=[2,3,8,5,6,5]\n,\nb=[1,3,4,10,5]\n,\nk=6\n, then it is possible to choose elements with values\n2,3,6\nfrom array\na\nand elements with values\n1,4,5\nfrom array\nb\n. In this case, all numbers from\n1\nto\nk=6\nwill be included among the chosen elements.\nIf\na=[2,3,4,5,6,5]\n,\nb=[1,3,8,10,3]\n,\nk=6\n, then it is not possible to choose elements in the required way.\nNote that you are not required to find a way to choose the elements — your program should only check whether it is possible to choose the elements in the required way.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains three integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤2⋅\n10\n5\n,\n2≤k≤2⋅min(n,m)\n,\nk\nis even) — the length of array\na\n, the length of array\nb\n, and the number of elements to be chosen, respectively.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n) — the elements of array\na\n.\nThe third line of each test case contains\nm\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nm\n(\n1≤\nb\nj\n≤\n10\n6\n) — the elements of array\nb\n.\nIt is guaranteed that the sum of values\nn\nand\nm\nover all test cases in a test does not exceed\n4⋅\n10\n5\n.\nOutput\nOutput\nt\nlines, each of which is the answer to the corresponding test case. As the answer, output \"YES\" if it is possible to choose\nk\n2\nnumbers from each array in such a way that among the chosen elements, every integer from\n1\nto\nk\nis included. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n6\n6 5 6\n2 3 8 5 6 5\n1 3 4 10 5\n6 5 6\n2 3 4 5 6 5\n1 3 8 10 3\n3 3 4\n1 3 5\n2 4 6\n2 5 4\n1 4\n7 3 4 4 2\n1 4 2\n2\n6 4 4 2\n1 5 2\n3\n2 2 1 4 3\noutput\nCopy\nYES\nNO\nYES\nYES\nNO\nNO\nNote\nIn the first test case of the example, it is possible to choose elements equal to\n2\n,\n3\n, and\n6\nfrom array\na\nand elements equal to\n1\n,\n4\n, and\n5\nfrom array\nb\n. Thus, all numbers from\n1\nto\nk=6\nare included among the chosen elements.\nIn the second test case of the example, it can be shown that it is not possible to choose exactly three elements from each array in the required way.\nIn the third test case of the example, it is possible to choose elements equal to\n1\nand\n3\nfrom array\na\nand elements equal to\n2\nand\n4\nfrom array\nb\n. Thus, all numbers from\n1\nto\nk=4\nare included among the chosen elements.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ]
    },
    {
        "title": "B. Following the String",
        "description": "Polycarp lost the string\ns\nof length\nn\nconsisting of lowercase Latin letters, but he still has its trace.\nThe trace of the string\ns\nis an array\na\nof\nn\nintegers, where\na\ni\nis the number of such indices\nj\n(\nj<i\n) that\ns\ni\n=\ns\nj\n. For example, the trace of the string abracadabra is the array [\n0,0,0,1,0,2,0,3,1,1,4\n].\nGiven a trace of a string, find any string\ns\nfrom which it could have been obtained. The string\ns\nshould consist only of lowercase Latin letters a-z.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then the descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the lost string.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n<n\n) — the trace of the string. It is guaranteed that for the given trace, there exists a suitable string\ns\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a string\ns\nthat corresponds to the given trace. If there are multiple such strings\ns\n, then output any of them.\nThe string\ns\nshould consist of lowercase Latin letters a-z.\nIt is guaranteed that for each test case, a valid answer exists.\nExample\ninput\nCopy\n5\n11\n0 0 0 1 0 2 0 3 1 1 4\n10\n0 0 0 0 0 1 0 1 1 0\n1\n0\n8\n0 1 2 3 4 5 6 7\n8\n0 0 0 0 0 0 0 0\noutput\nCopy\nabracadabra\ncodeforces\na\naaaaaaaa\ndijkstra",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "strings",
            "*900"
        ]
    },
    {
        "title": "A. Make it White",
        "description": "You have a horizontal strip of\nn\ncells. Each cell is either white or black.\nYou can choose a continuous segment of cells once and paint them all white. After this action, all the black cells in this segment will become white, and the white ones will remain white.\nWhat is the minimum length of the segment that needs to be painted white in order for all\nn\ncells to become white?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤10\n) — the length of the strip.\nThe second line of each test case contains a string\ns\n, consisting of\nn\ncharacters, each of which is either 'W' or 'B'. The symbol 'W' denotes a white cell, and 'B' — a black one. It is guaranteed that at least one cell of the given strip is black.\nOutput\nFor each test case, output a single number — the minimum length of a continuous segment of cells that needs to be painted white in order for the entire strip to become white.\nExample\ninput\nCopy\n8\n6\nWBBWBW\n1\nB\n2\nWB\n3\nBBW\n4\nBWWB\n6\nBWBWWB\n6\nWWBBWB\n9\nWBWBWWWBW\noutput\nCopy\n4\n1\n1\n2\n4\n6\n4\n7\nNote\nIn the first test case of the example for the strip \"WBBWBW\", the minimum length of the segment to be repainted white is\n4\n. It is necessary to repaint to white the segment from the\n2\n-nd to the\n5\n-th cell (the cells are numbered from\n1\nfrom left to right).",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*800"
        ]
    },
    {
        "title": "G. Vlad and Trouble at MIT",
        "description": "Vladislav has a son who really wanted to go to MIT. The college dormitory at MIT (Moldova Institute of Technology) can be represented as a tree with\nn\nvertices, each vertex being a room with exactly one student. A tree is a connected undirected graph with\nn\nvertices and\nn−1\nedges.\nTonight, there are three types of students:\nstudents who want to party and play music (marked with\nP\n),\nstudents who wish to sleep and enjoy silence (marked with\nS\n), and\nstudents who don't care (marked with\nC\n).\nInitially, all the edges are thin walls which allow music to pass through, so when a partying student puts music on, it will be heard in every room. However, we can place some thick walls on any edges — thick walls don't allow music to pass through them.\nThe university wants to install some thick walls so that every partying student can play music, and no sleepy student can hear it.\nBecause the university lost a lot of money in a naming rights lawsuit, they ask you to find the minimum number of thick walls they will need to use.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the tree.\nThe second line of each test case contains\nn−1\nintegers\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n<i\n) — it means there is an edge between\ni\nand\na\ni\nin the tree.\nThe third line of each test case contains a string\ns\nof length\nn\nconsisting of characters\nP\n,\nS\n, and\nC\n, denoting that student\ni\nis of type\ns\ni\n.\nThe sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of thick walls needed.\nExample\ninput\nCopy\n3\n3\n1 1\nCSP\n4\n1 2 2\nPCSS\n4\n1 2 2\nPPSS\noutput\nCopy\n1\n1\n2\nNote\nIn the first case, we can install one thick wall between rooms\n1\nand\n2\n, as shown below. We cannot install\n0\nwalls, since then the music from room 3 will reach room 2 where a student wants to sleep, so the answer is\n1\n. There are other valid solutions.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "flows",
            "graphs",
            "greedy",
            "implementation",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "F. Vlad and Avoiding X",
        "description": "Vladislav has a grid of size\n7×7\n, where each cell is colored black or white. In one operation, he can choose any cell and change its color (black\n↔\nwhite).\nFind the minimum number of operations required to ensure that there are no black cells with four diagonal neighbors also being black.\nThe left image shows that initially there are two black cells violating the condition. By flipping one cell, the grid will work.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤200\n) — the number of test cases. Then follows the description of the test cases.\nEach test case consists of\n7\nlines, each containing\n7\ncharacters. Each of these characters is either\nW\nor\nB\n, denoting a white or black cell, respectively.\nOutput\nFor each test case, output a single integer — the minimum number of operations required to ensure that there are no black cells with all four diagonal neighbors also being black.\nExample\ninput\nCopy\n4\nWWWWWWW\nWWWWBBB\nWWWWWBW\nWWBBBBB\nWWWBWWW\nWWBBBWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWBBBBBW\nWBBBBBW\nWBBBBBW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWWWWWWW\nWBBBBBW\nBBBBBBB\nBBBBBBB\nWWWWWWW\nBBBBBBB\nBBBBBBB\nBBBBBBB\noutput\nCopy\n1\n2\n0\n5\nNote\nThe first test case is illustrated in the statement.\nThe second test case is illustrated below:\nIn the third test case, the grid already satisfies the condition.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dfs and similar",
            "dp",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "E. Vlad and an Odd Ordering",
        "description": "Vladislav has\nn\ncards numbered\n1,2,…,n\n. He wants to lay them down in a row as follows:\nFirst, he lays down all the odd-numbered cards from smallest to largest.\nNext, he lays down all cards that are twice an odd number from smallest to largest (i.e.\n2\nmultiplied by an odd number).\nNext, he lays down all cards that are\n3\ntimes an odd number from smallest to largest (i.e.\n3\nmultiplied by an odd number).\nNext, he lays down all cards that are\n4\ntimes an odd number from smallest to largest (i.e.\n4\nmultiplied by an odd number).\nAnd so on, until all cards are laid down.\nWhat is the\nk\n-th card he lays down in this process? Once Vladislav puts a card down, he cannot use that card again.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤5⋅\n10\n4\n) — the number of test cases.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤k≤n≤\n10\n9\n) — the number of cards Vlad has, and the position of the card you need to output.\nOutput\nFor each test case, output a single integer — the\nk\n-th card Vladislav lays down.\nExample\ninput\nCopy\n11\n7 1\n7 2\n7 3\n7 4\n7 5\n7 6\n7 7\n1 1\n34 14\n84 19\n1000000000 1000000000\noutput\nCopy\n1\n3\n5\n7\n2\n6\n4\n1\n27\n37\n536870912\nNote\nIn the first seven test cases,\nn=7\n. Vladislav lays down the cards as follows:\nFirst — all the odd-numbered cards in the order\n1\n,\n3\n,\n5\n,\n7\n.\nNext — all cards that are twice an odd number in the order\n2\n,\n6\n.\nNext, there are no remaining cards that are\n3\ntimes an odd number. (Vladislav has only one of each card.)\nNext — all cards that are\n4\ntimes an odd number, and there is only one such card:\n4\n.\nThere are no more cards left, so Vladislav stops.\nThus the order of cards is\n1\n,\n3\n,\n5\n,\n7\n,\n2\n,\n6\n,\n4\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "data structures",
            "dp",
            "implementation",
            "math",
            "number theory",
            "*1500"
        ]
    },
    {
        "title": "D. Vlad and Division",
        "description": "Vladislav has\nn\nnon-negative integers, and he wants to divide all of them into several groups so that in any group, any pair of numbers does not have matching bit values among bits from\n1\n-st to\n31\n-st bit (i.e., considering the\n31\nleast significant bits of the binary representation).\nFor an integer\nk\n, let\nk\n2\n(i)\ndenote the\ni\n-th bit in its binary representation (from right to left, indexing from 1). For example, if\nk=43\n, since\n43=\n101011\n2\n, then\n43\n2\n(1)=1\n,\n43\n2\n(2)=1\n,\n43\n2\n(3)=0\n,\n43\n2\n(4)=1\n,\n43\n2\n(5)=0\n,\n43\n2\n(6)=1\n,\n43\n2\n(7)=0\n,\n43\n2\n(8)=0,…,\n43\n2\n(31)=0\n.\nFormally, for any two numbers\nx\nand\ny\nin the same group, the condition\nx\n2\n(i)≠\ny\n2\n(i)\nmust hold for all\n1≤i<32\n.\nWhat is the minimum number of groups Vlad needs to achieve his goal? Each number must fall into exactly one group.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the total number of integers.\nThe second line of each test case contains\nn\ngiven integers\na\n1\n,…,\na\nn\n(\n0≤\na\nj\n<\n2\n31\n).\nThe sum of\nn\nover all test cases in a test does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer  — the minimum number of groups required to satisfy the condition.\nExample\ninput\nCopy\n9\n4\n1 4 3 4\n2\n0 2147483647\n5\n476319172 261956880 2136179468 1671164475 1885526767\n3\n1335890506 811593141 1128223362\n4\n688873446 627404104 1520079543 1458610201\n4\n61545621 2085938026 1269342732 1430258575\n4\n0 0 2147483647 2147483647\n3\n0 0 2147483647\n8\n1858058912 289424735 1858058912 2024818580 1858058912 289424735 122665067 289424735\noutput\nCopy\n4\n1\n3\n2\n2\n3\n2\n2\n4\nNote\nIn the first test case, any two numbers have the same last\n31\nbits, so we need to place each number in its own group.\nIn the second test case,\na\n1\n=\n0000000000000000000000000000000\n2\n,\na\n2\n=\n1111111111111111111111111111111\n2\nso they can be placed in the same group because\na\n1\n(i)≠\na\n2\n(i)\nfor each\ni\nbetween\n1\nand\n31\n, inclusive.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "C. Vlad and a Sum of Sum of Digits",
        "description": "Please note that the time limit for this problem is only 0.5 seconds per test.\nVladislav wrote the integers from\n1\nto\nn\n, inclusive, on the board. Then he replaced each integer with the sum of its digits.\nWhat is the sum of the numbers on the board now?\nFor example, if\nn=12\nthen initially the numbers on the board are:\n1,2,3,4,5,6,7,8,9,10,11,12.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12.\nThen after the replacement, the numbers become:\n1,2,3,4,5,6,7,8,9,1,2,3.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n1\n2\n3.\nThe sum of these numbers is\n1+2+3+4+5+6+7+8+9+1+2+3=51\n. Thus, for\nn=12\nthe answer is\n51\n.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the largest number Vladislav writes.\nOutput\nFor each test case, output a single integer — the sum of the numbers at the end of the process.\nExample\ninput\nCopy\n7\n12\n1\n2\n3\n1434\n2024\n200000\noutput\nCopy\n51\n1\n3\n6\n18465\n28170\n4600002",
        "time_limit": "0.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*1200"
        ]
    },
    {
        "title": "B. Vlad and Shapes",
        "description": "Vladislav has a binary square grid of\nn×n\ncells. A triangle or a square is drawn on the grid with symbols\n1\n. As he is too busy being cool, he asks you to tell him which shape is drawn on the grid.\nA triangle is a shape consisting of\nk\n(\nk>1\n) consecutive rows, where the\ni\n-th row has\n2⋅i−1\nconsecutive characters\n1\n, and the central 1s are located in one column. An upside down triangle is also considered a valid triangle (but not rotated by 90 degrees).\nTwo left pictures contain examples of triangles:\nk=4\n,\nk=3\n. The two right pictures don't contain triangles.\nA square is a shape consisting of\nk\n(\nk>1\n) consecutive rows, where the\ni\n-th row has\nk\nconsecutive characters\n1\n, which are positioned at an equal distance from the left edge of the grid.\nExamples of two squares:\nk=2\n,\nk=4\n.\nFor the given grid, determine the type of shape that is drawn on it.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤10\n) — the size of the grid.\nThe next\nn\nlines each contain\nn\ncharacters\n0\nor\n1\n.\nThe grid contains exactly one triangle or exactly one square that contains all the\n1\ns in the grid. It is guaranteed that the size of the triangle or square is greater than\n1\n(i.e., the shape cannot consist of exactly one 1).\nOutput\nFor each test case, output \"SQUARE\" if all the\n1\ns in the grid form a square, and \"TRIANGLE\" otherwise (without quotes).\nExample\ninput\nCopy\n6\n3\n000\n011\n011\n4\n0000\n0000\n0100\n1110\n2\n11\n11\n5\n00111\n00010\n00000\n00000\n00000\n10\n0000000000\n0000000000\n0000000000\n0000000000\n0000000000\n1111111110\n0111111100\n0011111000\n0001110000\n0000100000\n3\n111\n111\n111\noutput\nCopy\nSQUARE\nTRIANGLE\nSQUARE\nTRIANGLE\nTRIANGLE\nSQUARE",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Vlad and the Best of Five",
        "description": "Vladislav has a string of length\n5\n, whose characters are each either\nA\nor\nB\n.\nWhich letter appears most frequently:\nA\nor\nB\n?\nInput\nThe first line of the input contains an integer\nt\n(\n1≤t≤32\n) — the number of test cases.\nThe only line of each test case contains a string of length\n5\nconsisting of letters\nA\nand\nB\n.\nAll\nt\nstrings in a test are different (distinct).\nOutput\nFor each test case, output one letter (\nA\nor\nB\n) denoting the character that appears most frequently in the string.\nExample\ninput\nCopy\n8\nABABB\nABABA\nBBBAB\nAAAAA\nBBBBB\nBABAA\nAAAAB\nBAAAA\noutput\nCopy\nB\nA\nB\nA\nB\nA\nA\nA",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "D. Good Trip",
        "description": "There are\nn\nchildren in a class,\nm\npairs among them are friends. The\ni\n-th pair who are friends have a friendship value of\nf\ni\n.\nThe teacher has to go for\nk\nexcursions, and for each of the excursions she chooses a pair of children randomly, equiprobably and independently. If a pair of children who are friends is chosen, their friendship value increases by\n1\nfor all subsequent excursions (the teacher can choose a pair of children more than once). The friendship value of a pair who are not friends is considered\n0\n, and it does not change for subsequent excursions.\nFind the expected value of the sum of friendship values of all\nk\npairs chosen for the excursions (at the time of being chosen). It can be shown that this answer can always be expressed as a fraction\np\nq\nwhere\np\nand\nq\nare coprime integers. Calculate\np⋅\nq\n−1\nmod(\n10\n9\n+7)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤5⋅\n10\n4\n). Description of the test cases follows.\nThe first line of each test case contains\n3\nintegers\nn\n,\nm\nand\nk\n(\n2≤n≤\n10\n5\n,\n0≤m≤min(\n10\n5\n,\nn(n−1)\n2\n)\n,\n1≤k≤2⋅\n10\n5\n) — the number of children, pairs of friends and excursions respectively.\nThe next\nm\nlines contain three integers each —\na\ni\n,\nb\ni\n,\nf\ni\n— the indices of the pair of children who are friends and their friendship value. (\na\ni\n≠\nb\ni\n,\n1≤\na\ni\n,\nb\ni\n≤n\n,\n1≤\nf\ni\n≤\n10\n9\n). It is guaranteed that all pairs of friends are distinct.\nIt is guaranteed that the sum of\nn\nand sum\nm\nover all test cases does not exceed\n10\n5\nand the sum of\nk\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the answer to the problem.\nExample\ninput\nCopy\n4\n100 0 24\n2 1 10\n1 2 1\n3 1 2\n2 1 1\n5 2 4\n1 2 25\n3 2 24\noutput\nCopy\n0\n55\n777777784\n40000020\nNote\nFor the first test case, there are no pairs of friends, so the friendship value of all pairs is\n0\nand stays\n0\nfor subsequent rounds, hence the friendship value for all excursions is\n0\n.\nFor the second test case, there is only one pair possible\n(1,2)\nand its friendship value is initially\n1\n, so each turn they are picked and their friendship value increases by\n1\n. Therefore, the total sum is\n1+2+3+…+10=55\n.\nFor the third test case, the final answer is\n7\n9\n=777777784mod(\n10\n9\n+7)\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "probabilities",
            "*1900"
        ]
    },
    {
        "title": "B. A Balanced Problemset?",
        "description": "Jay managed to create a problem of difficulty\nx\nand decided to make it the second problem for Codeforces Round #921.\nBut Yash fears that this problem will make the contest highly unbalanced, and the coordinator will reject it. So, he decided to break it up into a problemset of\nn\nsub-problems such that the difficulties of all the sub-problems are a positive integer and their sum is equal to\nx\n.\nThe coordinator, Aleksey, defines the balance of a problemset as the GCD of the difficulties of all sub-problems in the problemset.\nFind the maximum balance that Yash can achieve if he chooses the difficulties of the sub-problems optimally.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n3\n) denoting the number of test cases.\nEach test case contains a single line of input containing two integers\nx\n(\n1≤x≤\n10\n8\n) and\nn\n(\n1≤n≤x\n).\nOutput\nFor each test case, print a single line containing a single integer denoting the maximum balance of the problemset Yash can achieve.\nExample\ninput\nCopy\n3\n10 3\n5 5\n420 69\noutput\nCopy\n2\n1\n6\nNote\nFor the first test case, one possible way is to break up the problem of difficulty\n10\ninto a problemset having three problems of difficulties\n4\n,\n2\nand\n4\nrespectively, giving a balance equal to\n2\n.\nFor the second test case, there is only one way to break up the problem of difficulty\n5\ninto a problemset of\n5\nproblems with each problem having a difficulty\n1\ngiving a balance equal to\n1\n.",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "A. We Got Everything Covered!",
        "description": "You are given two positive integers\nn\nand\nk\n.\nYour task is to find a string\ns\nsuch that all possible strings of length\nn\nthat can be formed using the first\nk\nlowercase English alphabets occur as a subsequence of\ns\n.\nIf there are multiple answers, print the one with the smallest length. If there are still multiple answers, you may print any of them.\nNote: A string\na\nis called a subsequence of another string\nb\nif\na\ncan be obtained by deleting some (possibly zero) characters from\nb\nwithout changing the order of the remaining characters.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤676\n) denoting the number of test cases.\nEach test case consists of a single line of input containing two integers\nn\n(\n1≤n≤26\n) and\nk\n(\n1≤k≤26\n).\nOutput\nFor each test case, print a single line containing a single string\ns\nwhich satisfies the above property. If there are multiple answers, print the one with the smallest length. If there are still multiple answers, you may print any of them.\nExample\ninput\nCopy\n4\n1 2\n2 1\n2 2\n2 3\noutput\nCopy\nab\naa\nbaab\nabcbac\nNote\nFor the first test case, there are two strings of length\n1\nwhich can be formed using the first\n2\nlowercase English alphabets, and they are present in\ns\nas a subsequence as follows:\na:ab\nb:ab\nFor the second test case, there is only one string of length\n2\nwhich can be formed using the first lowercase English alphabet, and it is present in\ns\nas a subsequence as follows:\naa:aa\nFor the third test case, there are\n4\nstrings of length\n2\nwhich can be formed using the first\n2\nlowercase English alphabets, and they are present in\ns\nas a subsequence as follows:\naa:baab\nab:baab\nba:baab\nbb:baab\nFor the fourth test case, there are\n9\nstrings of length\n2\nwhich can be formed using the first\n3\nlowercase English alphabets, and they are present in\ns\nas a subsequence as follows:\naa:abcbac\nab:abcbac\nac:abcbac\nba:abcbac\nbb:abcbac\nbc:abcbac\nca:abcbac\ncb:abcbac\ncc:abcbac",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "strings",
            "*800"
        ]
    },
    {
        "title": "F. Anti-Proxy Attendance",
        "description": "This is an interactive problem!\nMr. 1048576 is one of those faculty who hates wasting his time in taking class attendance. Instead of taking attendance the old-fashioned way, he decided to try out something new today.\nThere are\nn\nstudents in his class, having roll numbers\n1\nto\nn\n. He knows that exactly\n1\nstudent is absent today. In order to determine who is absent, he can ask some queries to the class. In each query, he can provide two integers\nl\nand\nr\n(\n1≤l≤r≤n\n) and all students whose roll numbers are between\nl\nand\nr\n(inclusive) will raise their hands. He then counts them to determine if the roll number of the absent student lies between these values.\nThings seemed fine until his teaching assistant noticed something — the students are dishonest! Some students whose roll numbers lie in the given range may not raise their hands, while some other students whose roll number does not lie in the given range may raise their hands. But the students don't want to raise much suspicion. So, only the following\n4\ncases are possible for a particular query\n(l,r)\n—\nTrue Positive:\nr−l+1\nstudents are present and\nr−l+1\nstudents raised their hands.\nTrue Negative:\nr−l\nstudents are present and\nr−l\nstudents raised their hands.\nFalse Positive:\nr−l\nstudents are present but\nr−l+1\nstudents raised their hands.\nFalse Negative:\nr−l+1\nstudents are present but\nr−l\nstudents raised their hands.\nIn the first two cases, the students are said to be answering honestly, while in the last two cases, the students are said to be answering dishonestly. The students can mutually decide upon their strategy, not known to Mr. 1048576. Also, the students do not want to raise any suspicion and at the same time, want to create a lot of confusion. So, their strategy always meets the following two conditions —\nThe students will never answer honestly\n3\ntimes in a row.\nThe students will never answer dishonestly\n3\ntimes in a row.\nMr. 1048576 is frustrated by this act of students. So, he is willing to mark at most\n2\nstudents as absent (though he knows that only one is). The attendance is said to be successful if the student who is actually absent is among those two. Also, due to limited class time, he can only ask up to\n⌈\nlog\n1.116\nn⌉−1\nqueries (weird numbers but okay). Help him complete a successful attendance.\nInteraction\nFirst read a line containing a single integer\nt\n(\n1≤t≤2048\n) denoting the number of independent test cases that you must solve.\nFor each test case, first read a line containing a single integer\nn\n(\n3≤n≤\n10\n5\n). Then you may ask up to\n⌈\nlog\n1.116\nn⌉−1\nqueries.\nTo ask a query, print a single line in the format \"? l r\" (without quotes)\n(1≤l≤r≤n)\n. Then read a single line containing a single integer\nx\n(\nr−l≤x≤r−l+1\n) denoting the number of students who raised their hands corresponding to the query.\nTo mark a student as absent, print a single line in the format \"! a\" (without quotes)\n(1≤a≤n)\n. Then read a single integer\ny\n(\ny∈{0,1}\n). If the student with roll number\na\nwas absent,\ny=1\n, else,\ny=0\n. Note that this operation does not count as a query but you can do this operation at most\n2\ntimes.\nTo end a test case, print a single line in the format \"#\" (without quotes). Then you must continue solving the remaining test cases.\nIf you ask more queries than allowed or ask an invalid query, you will get the Wrong answer verdict.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nAfter printing the answers, do not forget to output end of line and flush the output buffer. Otherwise, you will get the verdict Idleness limit exceeded. To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nRead documentation for other languages.\nNote that the grader for this problem is adaptive meaning that the answer may change depending on your queries but will always remain consistent with the constraints and the answer to the previous queries.\nInput format for Hacks\nThe test cases for this problem use both non-adaptive and adaptive graders. You can use the non-adaptive grader for making hacks.\nThe first line of input contains a single integer\nt\n(\n1≤t≤2048\n).\nThe first line of each test case contains three integers\ng\n,\nn\nand\nx\nwhere\ng=1\n(to identify that this test case must use the non-adaptive grader),\nn\n(\n3≤n≤\n10\n5\n) represents the number of students in the class and\nx\n(\n1≤x≤n\n) represents the roll number of the student who is absent. You must ensure that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nThe second line of each test case contains a single string\nS\n(\n1≤|S|≤120,\nS\ni\n∈{T,F}\n). This string represents the pattern of the truth sequence. If\nS\n(i−1)mod|S|+1\n=T\n, the students will act honestly during the\ni\n-th query, otherwise they will act dishonestly. You must also ensure that there is no index\ni\nsuch that\nS\n(i−1)mod|S|+1\n=\nS\nimod|S|+1\n=\nS\n(i+1)mod|S|+1\n.\nExample\ninput\nCopy\n2\n5\n\n3\n\n2\n\n1\n\n2\n\n0\n\n1\n\n0\n\n2\n\n0\n\n1\n\n6\n\n6\n\n2\n\n2\n\n0\n\n1\n\n1\n\n0\n\n0\n\n0\n\n1\noutput\nCopy\n? 1 4\n\n? 3 5\n\n? 2 2\n\n? 1 3\n\n? 3 3\n\n? 3 3\n\n! 3\n\n? 2 4\n\n? 4 4\n\n! 2\n\n#\n\n? 1 6\n\n? 1 3\n\n? 4 6\n\n? 1 1\n\n? 3 3\n\n? 5 5\n\n! 3\n\n? 2 2\n\n? 4 4\n\n! 4\n\n#\nNote\nFor the first test case, the student with roll number\n2\nis absent and the truth sequence (see section for hacks) is TFFTFTTF. During execution of your solution, this test case will use a non-adaptive grader.\nFor the second test case, the student with roll number\n4\nis absent, and the truth sequence is FFTFTTFT. During the execution of your solution, in this test case your program will interact with an adaptive grader. So, the actual answer might be different depending on your queries but will always remain consistent with the responses to the previous queries.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "interactive",
            "ternary search",
            "*3500"
        ]
    },
    {
        "title": "E. Paper Cutting Again",
        "description": "There is a rectangular sheet of paper with initial height\nn\nand width\nm\n. Let the current height and width be\nh\nand\nw\nrespectively. We introduce a\nxy\n-coordinate system so that the four corners of the sheet are\n(0,0),(w,0),(0,h)\n, and\n(w,h)\n. The sheet can then be cut along the lines\nx=1,2,…,w−1\nand the lines\ny=1,2,…,h−1\n. In each step, the paper is cut randomly along any one of these\nh+w−2\nlines. After each vertical and horizontal cut, the right and bottom piece of paper respectively are discarded.\nFind the expected number of steps required to make the area of the sheet of paper strictly less than\nk\n. It can be shown that this answer can always be expressed as a fraction\np\nq\nwhere\np\nand\nq\nare coprime integers. Calculate\np⋅\nq\n−1\nmod(\n10\n9\n+7)\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤57000\n). Description of the test cases follows.\nThe first line of each test case contains 3 integers\nn\n,\nm\n, and\nk\n(\n1≤n,m≤\n10\n6\n,\n2≤k≤\n10\n12\n).\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n10\n6\n.\nOutput\nFor each test case, print one integer — the answer to the problem.\nExample\ninput\nCopy\n4\n2 4 10\n2 4 8\n2 4 2\n2 4 6\noutput\nCopy\n0\n1\n833333342\n250000003\nNote\nFor the first test case, the area is already less than\n10\nso no cuts are required.\nFor the second test case, the area is exactly\n8\nso any one of the\n4\npossible cuts would make the area strictly less than\n8\n.\nFor the third test case, the final answer is\n17\n6\n=833333342mod(\n10\n9\n+7)\n.\nFor the fourth test case, the final answer is\n5\n4\n=250000003mod(\n10\n9\n+7)\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "probabilities",
            "*3100"
        ]
    },
    {
        "title": "D. Balanced Subsequences",
        "description": "A sequence of brackets is called balanced if one can turn it into a valid math expression by adding characters '+' and '1'. For example, sequences '(())()', '()', and '(()(()))' are balanced, while ')(', '(()', and '(()))(' are not.\nA subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.\nYou are given three integers\nn\n,\nm\nand\nk\n. Find the number of sequences consisting of\nn\n'(' and\nm\n')', such that the longest balanced subsequence is of length\n2⋅k\n. Since the answer can be large calculate it modulo\n1000000007\n(\n10\n9\n+7\n).\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤3⋅\n10\n3\n). Description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nm\nand\nk\n(\n1≤n,m,k≤2⋅\n10\n3\n)\nOutput\nFor each test case, print one integer — the answer to the problem.\nExample\ninput\nCopy\n3\n2 2 2\n3 2 3\n3 2 1\noutput\nCopy\n2\n0\n4\nNote\nFor the first test case \"()()\", \"(())\" are the\n2\nsequences\nFor the second test case no sequence is possible.\nFor the third test case \")((()\", \")(()(\", \")()((\", \"())((\" are the\n4\nsequences.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2700"
        ]
    },
    {
        "title": "C. Fractal Origami",
        "description": "You have a square piece of paper with a side length equal to\n1\nunit. In one operation, you fold each corner of the square to the center of the paper, thus forming another square with a side length equal to\n1\n2\n–\n√\nunits. By taking this square as a new square, you do the operation again and repeat this process a total of\nN\ntimes.\nPerforming operations for\nN=2\n.\nAfter performing the set of operations, you open the paper with the same side up you started with and see some crease lines on it. Every crease line is one of two types: a mountain or a valley. A mountain is when the paper folds outward, and a valley is when the paper folds inward.\nYou calculate the sum of the length of all mountain crease lines on the paper and call it\nM\n. Similarly, you calculate for valley crease lines and call it\nV\n. You want to find the value of\nM\nV\n.\nIt can be proved that this value can be represented in the form of\nA+B\n2\n–\n√\n, where\nA\nand\nB\nare rational numbers. Let this\nB\nbe represented as an irreducible fraction\np\nq\n, your task is to print\np∗inv(q)\nmodulo\n999999893\n(note the unusual modulo), where\ninv(q)\nis the modular inverse of\nq\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). Description of the test cases follows.\nThe only line of each test case contains an integer\nN\n(\n1≤N≤\n10\n9\n), the number of operations you perform on the square paper.\nOutput\nFor each test case, print on a new line the required answer.\nExample\ninput\nCopy\n3\n1\n2\n3\noutput\nCopy\n0\n1\n714285638\nNote\nThe blue lines in the given figures represent mountain crease lines, and the green lines represent valley crease lines.\nCrease lines after\n1\noperation\n(\nM\nV\n=0)\n. Crease lines after\n2\noperations\n(\nM\nV\n=\n2\n–\n√\n−1)\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "geometry",
            "math",
            "matrices",
            "*2400"
        ]
    },
    {
        "title": "B. Space Harbour",
        "description": "There are\nn\npoints numbered\n1\nto\nn\non a straight line. Initially, there are\nm\nharbours. The\ni\n-th harbour is at point\nX\ni\nand has a value\nV\ni\n. It is guaranteed that there are harbours at the points\n1\nand\nn\n. There is exactly one ship on each of the\nn\npoints. The cost of moving a ship from its current location to the next harbour is the product of the value of the nearest harbour to its left and the distance from the nearest harbour to its right. Specifically, if a ship is already at a harbour, the cost of moving it to the next harbour is\n0\n.\nAdditionally, there are\nq\nqueries, each of which is either of the following\n2\ntypes:\n1\nx\nv\n— Add a harbour at point\nx\nwith value\nv\n. It is guaranteed that before adding the harbour, there is no harbour at point\nx\n.\n2\nl\nr\n— Print the sum of the cost of moving all ships at points from\nl\nto\nr\nto their next harbours. Note that you just need to calculate the cost of moving the ships but not actually move them.\nInput\nThe first line contains three integers\nn\n,\nm\n, and\nq\n(\n2≤m≤n≤3⋅\n10\n5\n,\n1≤q≤3⋅\n10\n5\n) — the number of points, harbours, and queries, respectively.\nThe second line contains\nm\ndistinct integers\nX\n1\n,\nX\n2\n,…,\nX\nm\n(1≤\nX\ni\n≤n)\n— the position at which the\ni\n-th harbour is located.\nThe third line contains\nm\nintegers\nV\n1\n,\nV\n2\n,…,\nV\nm\n(1≤\nV\ni\n≤\n10\n7\n)\n— the value of the\ni\n-th harbour.\nEach of the next\nq\nlines contains three integers. The first integer is\nt\n(\n1≤t≤2\n) — type of query. If\nt=1\n, then the next two integers are\nx\nand\nv\n(\n2≤x≤n−1\n,\n1≤v≤\n10\n7\n) — first-type query. If\nt=2\n, then the next two integers are\nl\nand\nr\n(\n1≤l≤r≤n\n) — second-type query.\nIt is guaranteed that there is at least one second-type query.\nOutput\nFor every second-type query, print one integer in a new line — answer to this query.\nExample\ninput\nCopy\n8 3 4\n1 3 8\n3 24 10\n2 2 5\n1 5 15\n2 5 5\n2 7 8\noutput\nCopy\n171\n0\n15\nNote\nFor the first type\n2\nquery, the cost for ships at positions\n2\n,\n3\n,\n4\nand\n5\nare\n3(3×1)\n,\n0\n,\n96(24×4)\nand\n72(24×3)\nrespectively.\nFor the second type\n2\nquery, since the ship at position\n5\nis already at a harbour, so the cost is\n0\n.\nFor the third type\n2\nquery, the cost for ships at position\n7\nand\n8\nare\n15(15×1)\nand\n0\nrespectively.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "math",
            "sortings",
            "*2100"
        ]
    },
    {
        "title": "A. Did We Get Everything Covered?",
        "description": "You are given two integers\nn\nand\nk\nalong with a string\ns\n.\nYour task is to check whether all possible strings of length\nn\nthat can be formed using the first\nk\nlowercase English alphabets occur as a subsequence of\ns\n. If the answer is NO, you also need to print a string of length\nn\nthat can be formed using the first\nk\nlowercase English alphabets which does not occur as a subsequence of\ns\n.\nIf there are multiple answers, you may print any of them.\nNote: A string\na\nis called a subsequence of another string\nb\nif\na\ncan be obtained by deleting some (possibly zero) characters from\nb\nwithout changing the order of the remaining characters.\nInput\nThe first line of input contains a single integer\nt(1≤t≤\n10\n5\n)\n, the number of test cases.\nThe first line of each test case contains\n3\nintegers\nn(1≤n≤26),k(1≤k≤26),m(1≤m≤1000)\n, where\nn\nand\nk\nare the same as described in the input and\nm\nis the length of the string\ns\n.\nThe second line of each test case contains a single string\ns\nof length\nm\n, comprising only of the first\nk\nlowercase English alphabets.\nIt is guaranteed that the sum of\nm\nand the sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, print YES if all possible strings of length\nn\nthat can be formed using the first\nk\nlowercase English alphabets occur as a subsequence of\ns\n, else print NO.\nIf your answer is NO, print a string of length\nn\nthat can be formed using the first\nk\nlowercase English alphabets which does not occur as a subsequence of\ns\nin the next line.\nYou may print each letter of YES or NO in any case (for example, YES, yES, YeS will all be recognized as a positive answer).\nExample\ninput\nCopy\n3\n2 2 4\nabba\n2 2 3\nabb\n3 3 10\naabbccabab\noutput\nCopy\nYES\nNO\naa\nNO\nccc\nNote\nFor the first test case, all possible strings (aa, ab, ba, bb) of length\n2\nthat can be formed using the first\n2\nEnglish alphabets occur as a subsequence of abba.\nFor the second test case, the string aa is not a subsequence of abb.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "shortest paths",
            "strings",
            "*1500"
        ]
    },
    {
        "title": "F. Shrink-Reverse",
        "description": "You are given a binary string\ns\nof length\nn\n(a string consisting of\nn\ncharacters, and each character is either 0 or 1).\nLet's look at\ns\nas at a binary representation of some integer, and name that integer as the value of string\ns\n. For example, the value of 000 is\n0\n, the value of 01101 is\n13\n, \"100000\" is\n32\nand so on.\nYou can perform at most\nk\noperations on\ns\n. Each operation should have one of the two following types:\nSWAP: choose two indices\ni<j\nin\ns\nand swap\ns\ni\nwith\ns\nj\n;\nSHRINK-REVERSE: delete all leading zeroes from\ns\nand reverse\ns\n.\nFor example, after you perform SHRINK-REVERSE on 000101100, you'll get 001101.\nWhat is the minimum value of\ns\nyou can achieve by performing at most\nk\noperations on\ns\n?\nInput\nThe first line contains two integers\nn\nand\nk\n(\n2≤n≤5⋅\n10\n5\n;\n1≤k≤n\n) — the length of the string\ns\nand the maximum number of operations.\nThe second line contains the string\ns\nof length\nn\nconsisting of characters 0 and/or 1.\nAdditional constraint on the input:\ns\ncontains at least one 1.\nOutput\nPrint a single integer — the minimum value of\ns\nyou can achieve using no more than\nk\noperations. Since the answer may be too large, print it modulo\n10\n9\n+7\n.\nNote that you need to minimize the original value, not the remainder.\nExamples\ninput\nCopy\n8 2\n10010010\noutput\nCopy\n7\ninput\nCopy\n8 2\n01101000\noutput\nCopy\n7\ninput\nCopy\n30 30\n111111111111111111111111111111\noutput\nCopy\n73741816\ninput\nCopy\n14 1\n10110001111100\noutput\nCopy\n3197\nNote\nIn the first example, one of the optimal strategies is the following:\n10010010\n−\n→\n−\nSWAP\n00010110;\n00010110\n−\n→\n−\nSWAP\n00000111.\nThe value of 00000111 is\n7\n.\nIn the second example, one of the optimal strategies is the following:\n01101000\n−\n→\n−\n−\n−\nSHRINK\n1101000\n−\n→\n−\n−\n−\nREVERSE\n0001011;\n0001011\n−\n→\n−\nSWAP\n0000111.\nThe value of 0000111 is\n7\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "hashing",
            "implementation",
            "string suffix structures",
            "strings",
            "*2800"
        ]
    },
    {
        "title": "E. Count Paths",
        "description": "You are given a tree, consisting of\nn\nvertices, numbered from\n1\nto\nn\n. Every vertex is colored in some color, denoted by an integer from\n1\nto\nn\n.\nA simple path of the tree is called beautiful if:\nit consists of at least\n2\nvertices;\nthe first and the last vertices of the path have the same color;\nno other vertex on the path has the same color as the first vertex.\nCount the number of the beautiful simple paths of the tree. Note that paths are considered undirected (i. e. the path from\nx\nto\ny\nis the same as the path from\ny\nto\nx\n).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of vertices in the tree.\nThe second line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤n\n) — the color of each vertex.\nThe\ni\n-th of the next\nn−1\nlines contains two integers\nv\ni\nand\nu\ni\n(\n1≤\nv\ni\n,\nu\ni\n≤n\n;\nv\ni\n≠\nu\ni\n) — the\ni\n-th edge of the tree.\nThe given edges form a valid tree. The sum of\nn\nover all testcases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print a single integer — the number of the beautiful simple paths of the tree.\nExample\ninput\nCopy\n4\n3\n1 2 1\n1 2\n2 3\n5\n2 1 2 1 2\n1 2\n1 3\n3 4\n4 5\n5\n1 2 3 4 5\n1 2\n1 3\n3 4\n4 5\n4\n2 2 2 2\n3 1\n3 2\n3 4\noutput\nCopy\n1\n3\n0\n3",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "dp",
            "dsu",
            "graphs",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "D. Slimes",
        "description": "There are\nn\nslimes placed in a line. The slimes are numbered from\n1\nto\nn\nin order from left to right. The size of the\ni\n-th slime is\na\ni\n.\nEvery second, the following happens: exactly one slime eats one of its neighbors and increases its size by the eaten neighbor's size. A slime can eat its neighbor only if it is strictly bigger than this neighbor. If there is no slime which is strictly bigger than one of its neighbors, the process ends.\nFor example, suppose\nn=5\n,\na=[2,2,3,1,4]\n. The process can go as follows:\nfirst, the\n3\n-rd slime eats the\n2\n-nd slime. The size of the\n3\n-rd slime becomes\n5\n, the\n2\n-nd slime is eaten.\nthen, the\n3\n-rd slime eats the\n1\n-st slime (they are neighbors since the\n2\n-nd slime is already eaten). The size of the\n3\n-rd slime becomes\n7\n, the\n1\n-st slime is eaten.\nthen, the\n5\n-th slime eats the\n4\n-th slime. The size of the\n5\n-th slime becomes\n5\n, the\n4\n-th slime is eaten.\nthen, the\n3\n-rd slime eats the\n5\n-th slime (they are neighbors since the\n4\n-th slime is already eaten). The size of the\n3\n-rd slime becomes\n12\n, the\n5\n-th slime is eaten.\nFor each slime, calculate the minimum number of seconds it takes for this slime to be eaten by another slime (among all possible ways the process can go), or report that it is impossible.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the number of slimes.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n).\nThe sum of\nn\nover all test cases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print\nn\nintegers. The\ni\n-th integer should be equal to the minimum number of seconds it takes for the\ni\n-th slime to be eaten by another slime or -1 if it is impossible.\nExample\ninput\nCopy\n4\n4\n3 2 4 2\n3\n1 2 3\n5\n2 2 3 1 1\n7\n4 2 3 6 1 1 8\noutput\nCopy\n2 1 2 1 \n1 1 -1 \n2 1 -1 1 2 \n2 1 1 3 1 1 4 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "data structures",
            "greedy",
            "two pointers",
            "*1800"
        ]
    },
    {
        "title": "C. Find B",
        "description": "An array\na\nof length\nm\nis considered good if there exists an integer array\nb\nof length\nm\nsuch that the following conditions hold:\n∑\ni=1\nm\na\ni\n=\n∑\ni=1\nm\nb\ni\n;\na\ni\n≠\nb\ni\nfor every index\ni\nfrom\n1\nto\nm\n;\nb\ni\n>0\nfor every index\ni\nfrom\n1\nto\nm\n.\nYou are given an array\nc\nof length\nn\n. Each element of this array is greater than\n0\n.\nYou have to answer\nq\nqueries. During the\ni\n-th query, you have to determine whether the subarray\nc\nl\ni\n,\nc\nl\ni\n+1\n,…,\nc\nr\ni\nis good.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤3⋅\n10\n5\n) — the length of the array\nc\nand the number of queries.\nThe second line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n9\n).\nThen\nq\nlines follow. The\ni\n-th of them contains two integers\nl\ni\nand\nr\ni\n(\n1≤\nl\ni\n≤\nr\ni\n≤n\n) — the borders of the\ni\n-th subarray.\nAdditional constraints on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n; the sum of\nq\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each query, print YES if the subarray is good. Otherwise, print NO.\nYou can output each letter of the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will all be recognized as positive responses.\nExample\ninput\nCopy\n1\n5 4\n1 2 1 4 5\n1 5\n4 4\n3 4\n1 3\noutput\nCopy\nYES\nNO\nYES\nNO",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1400"
        ]
    },
    {
        "title": "B. Monsters Attack!",
        "description": "You are playing a computer game. The current level of this game can be modeled as a straight line. Your character is in point\n0\nof this line. There are\nn\nmonsters trying to kill your character; the\ni\n-th monster has health equal to\na\ni\nand is initially in the point\nx\ni\n.\nEvery second, the following happens:\nfirst, you fire up to\nk\nbullets at monsters. Each bullet targets exactly one monster and decreases its health by\n1\n. For each bullet, you choose its target arbitrary (for example, you can fire all bullets at one monster, fire all bullets at different monsters, or choose any other combination). Any monster can be targeted by a bullet, regardless of its position and any other factors;\nthen, all alive monsters with health\n0\nor less die;\nthen, all alive monsters move\n1\npoint closer to you (monsters to the left of you increase their coordinates by\n1\n, monsters to the right of you decrease their coordinates by\n1\n). If any monster reaches your character (moves to the point\n0\n), you lose.\nCan you survive and kill all\nn\nmonsters without letting any of them reach your character?\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤3⋅\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains two integers\nn\nand\nk\n(\n1≤n≤3⋅\n10\n5\n;\n1≤k≤2⋅\n10\n9\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n);\nthe third line contains\nn\nintegers\nx\n1\n,\nx\n2\n,…,\nx\nn\n(\n−n≤\nx\n1\n<\nx\n2\n<\nx\n3\n<⋯<\nx\nn\n≤n\n;\nx\ni\n≠0\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print YES if you can kill all\nn\nmonsters before they reach your character, or NO otherwise.\nYou can output each letter of the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will all be recognized as positive responses.\nExample\ninput\nCopy\n5\n3 2\n1 2 3\n-1 2 3\n2 1\n1 1\n-1 1\n4 10\n3 4 2 5\n-3 -2 1 3\n5 3\n2 1 3 2 5\n-3 -2 3 4 5\n2 1\n1 2\n1 2\noutput\nCopy\nYES\nNO\nYES\nYES\nNO\nNote\nIn the first example, you can act as follows:\nduring the\n1\n-st second, fire\n1\nbullet at the\n1\n-st monster and\n1\nbullet at the\n3\n-rd monster. Then the\n1\n-st monster dies, the\n2\n-nd and the\n3\n-rd monster move closer;\nduring the\n2\n-nd second, fire\n2\nbullets at the\n2\n-nd monster. Then the\n2\n-nd monster dies, the\n3\n-rd monster moves closer;\nduring the\n3\n-rd second, fire\n2\nbullets at the\n3\n-rd monster. Then the\n3\n-rd monster dies.\nIn the second example, you can fire only\n1\nbullet, so you can kill only one of the two monsters during the\n1\n-st second. Then, the remaining monster moves closer and kills your character.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "A. Moving Chips",
        "description": "There is a ribbon divided into\nn\ncells, numbered from\n1\nto\nn\nfrom left to right. Each cell either contains a chip or is free.\nYou can perform the following operation any number of times (possibly zero): choose a chip and move it to the closest free cell to the left. You can choose any chip that you want, provided that there is at least one free cell to the left of it. When you move the chip, the cell where it was before the operation becomes free.\nYour goal is to move the chips in such a way that they form a single block, without any free cells between them. What is the minimum number of operations you have to perform?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n2≤n≤50\n) — the number of cells;\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤1\n);\na\ni\n=0\nmeans that the\ni\n-th cell is free;\na\ni\n=1\nmeans that the\ni\n-th cell contains a chip.\nAdditional constraint on the input: in each test case, at least one cell contains a chip.\nOutput\nFor each test case, print one integer — the minimum number of operations you have to perform so that all chips form a single block without any free cells between them.\nExample\ninput\nCopy\n5\n8\n0 1 1 1 0 1 1 0\n6\n0 1 0 0 0 0\n6\n1 1 1 1 1 1\n5\n1 0 1 0 1\n9\n0 1 1 0 0 0 1 1 0\noutput\nCopy\n1\n0\n0\n2\n3\nNote\nIn the first example, you can perform the operation on the chip in the\n7\n-th cell. The closest free cell to the left is the\n5\n-th cell, so it moves there. After that, all chips form a single block.\nIn the second example, all chips are already in a single block. Same for the third example.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "F. Replace on Segment",
        "description": "You are given an array\na\n1\n,\na\n2\n,…,\na\nn\n, where each element is an integer from\n1\nto\nx\n.\nYou can perform the following operation with it any number of times:\nchoose three integers\nl\n,\nr\nand\nk\nsuch that\n1≤l≤r≤n\n,\n1≤k≤x\nand each element\na\ni\nsuch that\nl≤i≤r\nis different from\nk\n. Then, for each\ni∈[l,r]\n, replace\na\ni\nwith\nk\n.\nIn other words, you choose a subsegment of the array and an integer from\n1\nto\nx\nwhich does not appear in that subsegment, and replace every element in the subsegment with that chosen integer.\nYour goal is to make all elements in the array equal. What is the minimum number of operations that you have to perform?\nInput\nThe first line contains one integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains two integers\nn\nand\nx\n(\n1≤x≤n≤100\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤x\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n500\n.\nOutput\nFor each test case, print one integer — the minimum number of operations you have to perform.\nExample\ninput\nCopy\n3\n3 2\n1 2 1\n6 3\n1 2 3 1 2 3\n12 3\n3 1 3 1 2 1 1 2 3 1 1 3\noutput\nCopy\n1\n2\n2",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dp",
            "graph matchings",
            "*2500"
        ]
    },
    {
        "title": "E. Increasing Subsequences",
        "description": "Let's recall that an increasing subsequence of the array\na\nis a sequence that can be obtained from it by removing some elements without changing the order of the remaining elements, and the remaining elements are strictly increasing (i. e\na\nb\n1\n<\na\nb\n2\n<⋯<\na\nb\nk\nand\nb\n1\n<\nb\n2\n<⋯<\nb\nk\n). Note that an empty subsequence is also increasing.\nYou are given a positive integer\nX\n. Your task is to find an array of integers of length at most\n200\n, such that it has exactly\nX\nincreasing subsequences, or report that there is no such array. If there are several answers, you can print any of them.\nIf two subsequences consist of the same elements, but correspond to different positions in the array, they are considered different (for example, the array\n[2,2]\nhas two different subsequences equal to\n[2]\n).\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe only line of each test case contains a single integer\nX\n(\n2≤X≤\n10\n18\n).\nOutput\nFor each query, print the answer to it. If it is impossible to find the required array, print -1 on the first line. Otherwise, print a positive integer\nn\non the first line — the length of the array. On the second line, print\nn\nintegers — the required array itself. If there are several answers, you can print any of them. All elements of the array should be in the range\n[−\n10\n9\n;\n10\n9\n]\n.\nExample\ninput\nCopy\n4\n2\n5\n13\n37\noutput\nCopy\n1\n0\n3\n0 1 0\n5\n2 2 3 4 2\n7\n-1 -1 0 0 2 3 -1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "divide and conquer",
            "greedy",
            "math",
            "*1800"
        ]
    },
    {
        "title": "D. Berserk Monsters",
        "description": "Monocarp is playing a computer game (yet again). Guess what is he doing? That's right, killing monsters.\nThere are\nn\nmonsters in a row, numbered from\n1\nto\nn\n. The\ni\n-th monster has two parameters: attack value equal to\na\ni\nand defense value equal to\nd\ni\n. In order to kill these monsters, Monocarp put a berserk spell on them, so they're attacking each other instead of Monocarp's character.\nThe fight consists of\nn\nrounds. Every round, the following happens:\nfirst, every alive monster\ni\ndeals\na\ni\ndamage to the closest alive monster to the left (if it exists) and the closest alive monster to the right (if it exists);\nthen, every alive monster\nj\nwhich received more than\nd\nj\ndamage during this round dies. I. e. the\nj\n-th monster dies if and only if its defense value\nd\nj\nis strictly less than the total damage it received this round.\nFor each round, calculate the number of monsters that will die during that round.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n);\nthe third line contains\nn\nintegers\nd\n1\n,\nd\n2\n,…,\nd\nn\n(\n1≤\nd\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print\nn\nintegers. The\ni\n-th integer should be equal to the number of monsters that die during the\ni\n-th round.\nExample\ninput\nCopy\n3\n5\n3 4 7 5 10\n4 9 1 18 1\n2\n2 1\n1 3\n4\n1 1 2 4\n3 3 4 2\noutput\nCopy\n3 1 0 0 0 \n0 0 \n1 1 1 0 \nNote\nExplanation for the first test case of the example:\nDuring the first round, the following happens:\nthe monster\n1\ndeals\n3\ndamage to the monster\n2\n;\nthe monster\n2\ndeals\n4\ndamage to the monster\n1\nand the monster\n3\n;\nthe monster\n3\ndeals\n7\ndamage to the monster\n2\nand the monster\n4\n;\nthe monster\n4\ndeals\n5\ndamage to the monster\n3\nand the monster\n5\n;\nthe monster\n5\ndeals\n10\ndamage to the monster\n4\n;\nthe monster\n1\ndoes not die, since it received\n4\ndamage and its defense is\n4\n;\nthe monster\n2\ndies, since it received\n10\ndamage and its defense is\n9\n;\nthe monster\n3\ndies, since it received\n9\ndamage and its defense is\n1\n;\nthe monster\n4\ndoes not die, since it received\n17\ndamage and its defense is\n18\n;\nthe monster\n5\ndies, since it received\n5\ndamage and its defense is\n1\n.\nAfter the first round, the monsters\n1\nand\n4\nstay alive.\nDuring the second round, the following happens:\nthe monster\n1\ndeals\n3\ndamage to the monster\n4\n;\nthe monster\n4\ndeals\n5\ndamage to the monster\n1\n;\nthe monster\n1\ndies, since it received\n5\ndamage and its defense is\n4\n;\nthe monster\n4\ndoes not die, since it received\n3\ndamage and its defense is\n18\n.\nDuring the next three rounds, only the\n4\n-th monster is alive, so nothing happens.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dsu",
            "implementation",
            "math",
            "*1900"
        ]
    },
    {
        "title": "C. Closest Cities",
        "description": "There are\nn\ncities located on the number line, the\ni\n-th city is in the point\na\ni\n. The coordinates of the cities are given in ascending order, so\na\n1\n<\na\n2\n<⋯<\na\nn\n.\nThe distance between two cities\nx\nand\ny\nis equal to\n|\na\nx\n−\na\ny\n|\n.\nFor each city\ni\n, let's define the closest city\nj\nas the city such that the distance between\ni\nand\nj\nis not greater than the distance between\ni\nand each other city\nk\n. For example, if the cities are located in points\n[0,8,12,15,20]\n, then:\nthe closest city to the city\n1\nis the city\n2\n;\nthe closest city to the city\n2\nis the city\n3\n;\nthe closest city to the city\n3\nis the city\n4\n;\nthe closest city to the city\n4\nis the city\n3\n;\nthe closest city to the city\n5\nis the city\n4\n.\nThe cities are located in such a way that for every city, the closest city is unique. For example, it is impossible for the cities to be situated in points\n[1,2,3]\n, since this would mean that the city\n2\nhas two closest cities (\n1\nand\n3\n, both having distance\n1\n).\nYou can travel between cities. Suppose you are currently in the city\nx\n. Then you can perform one of the following actions:\ntravel to any other city\ny\n, paying\n|\na\nx\n−\na\ny\n|\ncoins;\ntravel to the city which is the closest to\nx\n, paying\n1\ncoin.\nYou are given\nm\nqueries. In each query, you will be given two cities, and you have to calculate the minimum number of coins you have to spend to travel from one city to the other city.\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case is given in the following format:\nthe first line contains one integer\nn\n(\n2≤n≤\n10\n5\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\n1\n<\na\n2\n<⋯<\na\nn\n≤\n10\n9\n);\nthe third line contains one integer\nm\n(\n1≤m≤\n10\n5\n);\nthen\nm\nlines follow; the\ni\n-th of them contains two integers\nx\ni\nand\ny\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n;\nx\ni\n≠\ny\ni\n), denoting that in the\ni\n-th query, you have to calculate the minimum number of coins you have to spend to travel from the city\nx\ni\nto the city\ny\ni\n.\nAdditional constraints on the input:\nin every test case, for each city, the closest city is determined uniquely;\nthe sum of\nn\nover all test cases does not exceed\n10\n5\n;\nthe sum of\nm\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each query, print one integer — the minimum number of coins you have to spend.\nExample\ninput\nCopy\n1\n5\n0 8 12 15 20\n5\n1 4\n1 5\n3 4\n3 2\n5 1\noutput\nCopy\n3\n8\n1\n4\n14\nNote\nLet's consider the first two queries in the example from the statement:\nin the first query, you are initially in the city\n1\n. You can travel to the closest city (which is the city\n2\n), paying\n1\ncoin. Then you travel to the closest city (which is the city\n3\n) again, paying\n1\ncoin. Then you travel to the closest city (which is the city\n4\n) again, paying\n1\ncoin. In total, you spend\n3\ncoins to get from the city\n1\nto the city\n4\n;\nin the second query, you can use the same way to get from the city\n1\nto the city\n4\n, and then spend\n5\ncoins to travel from the city\n4\nto the city\n5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1300"
        ]
    },
    {
        "title": "B. Forming Triangles",
        "description": "You have\nn\nsticks, numbered from\n1\nto\nn\n. The length of the\ni\n-th stick is\n2\na\ni\n.\nYou want to choose exactly\n3\nsticks out of the given\nn\nsticks, and form a non-degenerate triangle out of them, using the sticks as the sides of the triangle. A triangle is called non-degenerate if its area is strictly greater than\n0\n.\nYou have to calculate the number of ways to choose exactly\n3\nsticks so that a triangle can be formed out of them. Note that the order of choosing sticks does not matter (for example, choosing the\n1\n-st,\n2\n-nd and\n4\n-th stick is the same as choosing the\n2\n-nd,\n4\n-th and\n1\n-st stick).\nInput\nThe first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines:\nthe first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n);\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the number of ways to choose exactly\n3\nsticks so that a triangle can be formed out of them.\nExample\ninput\nCopy\n4\n7\n1 1 1 1 1 1 1\n4\n3 2 1 3\n3\n1 2 3\n1\n1\noutput\nCopy\n35\n2\n0\n0\nNote\nIn the first test case of the example, any three sticks out of the given\n7\ncan be chosen.\nIn the second test case of the example, you can choose the\n1\n-st,\n2\n-nd and\n4\n-th stick, or the\n1\n-st,\n3\n-rd and\n4\n-th stick.\nIn the third test case of the example, you cannot form a triangle out of the given sticks with lengths\n2\n,\n4\nand\n8\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "math",
            "sortings",
            "*1200"
        ]
    },
    {
        "title": "A. Tricky Template",
        "description": "You are given an integer\nn\nand three strings\na,b,c\n, each consisting of\nn\nlowercase Latin letters.\nLet a template be a string\nt\nconsisting of\nn\nlowercase and/or uppercase Latin letters. The string\ns\nmatches the template\nt\nif the following conditions hold for all\ni\nfrom\n1\nto\nn\n:\nif the\ni\n-th letter of the template is lowercase, then\ns\ni\nmust be the same as\nt\ni\n;\nif the\ni\n-th letter of the template is uppercase, then\ns\ni\nmust be different from the lowercase version of\nt\ni\n. For example, if there is a letter 'A' in the template, you cannot use the letter 'a' in the corresponding position of the string.\nAccordingly, the string doesn't match the template if the condition doesn't hold for at least one\ni\n.\nDetermine whether there exists a template\nt\nsuch that the strings\na\nand\nb\nmatch it, while the string\nc\ndoes not.\nInput\nThe first line contains an integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤20\n) — the length of the given strings.\nThe next three lines contain the strings\na,b\nand\nc\n. Each string consists of exactly\nn\nlowercase Latin letters.\nOutput\nFor each testcase, print \"YES\" if there exists a template\nt\nsuch that the strings\na\nand\nb\nmatch it, while the string\nc\ndoes not. Otherwise, print \"NO\".\nExample\ninput\nCopy\n4\n1\na\nb\nc\n2\naa\nbb\naa\n10\nmathforces\nluckforces\nadhoccoder\n3\nacc\nabd\nabc\noutput\nCopy\nYES\nNO\nYES\nNO\nNote\nIn the first test case, you can use the template \"C\". The first letter of strings\na\nand\nb\ndiffer from 'c', so they match the template. The first letter of string\nc\nequals 'c', so it doesn't match.\nIn the third test case, you can use the template \"CODEforces\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "G. Mischievous Shooter",
        "description": "Once the mischievous and wayward shooter named Shel found himself on a rectangular field of size\nn×m\n, divided into unit squares. Each cell either contains a target or not.\nShel only had a lucky shotgun with him, with which he can shoot in one of the four directions: right-down, left-down, left-up, or right-up. When fired, the shotgun hits all targets in the chosen direction, the Manhattan distance to which does not exceed a fixed constant\nk\n. The Manhattan distance between two points\n(\nx\n1\n,\ny\n1\n)\nand\n(\nx\n2\n,\ny\n2\n)\nis equal to\n|\nx\n1\n−\nx\n2\n|+|\ny\n1\n−\ny\n2\n|\n.\nPossible hit areas for\nk=3\n.\nShel's goal is to hit as many targets as possible. Please help him find this value.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains field dimensions\nn\n,\nm\n, and the constant for the shotgun's power\nk\n(\n1≤n,m,k≤\n10\n5\n,1≤n⋅m≤\n10\n5\n).\nEach of the next\nn\nlines contains\nm\ncharacters — the description of the next field row, where the character '.' means the cell is empty, and the character '#' indicates the presence of a target.\nIt is guaranteed that the sum of\nn⋅m\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer on a separate line, which is equal to the maximum possible number of hit targets with one shot.\nExample\ninput\nCopy\n4\n3 3 1\n.#.\n###\n.#.\n2 5 3\n###..\n...##\n4 4 2\n..##\n###.\n#..#\n####\n2 1 3\n#\n#\noutput\nCopy\n3\n4\n5\n2\nNote\nPossible optimal shots for the examples in the statement:",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "dp",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "F. Sum of Progression",
        "description": "You are given an array\na\nof\nn\nnumbers. There are also\nq\nqueries of the form\ns,d,k\n.\nFor each query\nq\n, find the sum of elements\na\ns\n+\na\ns+d\n⋅2+⋯+\na\ns+d⋅(k−1)\n⋅k\n. In other words, for each query, it is necessary to find the sum of\nk\nelements of the array with indices starting from the\ns\n-th, taking steps of size\nd\n, multiplying it by the serial number of the element in the resulting sequence.\nInput\nEach test consists of several testcases. The first line contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases. Next lines contain descriptions of testcases.\nThe first line of each testcase contains two numbers\nn,q\n(\n1≤n≤\n10\n5\n,1≤q≤2⋅\n10\n5\n) — the number of elements in the array\na\nand the number of queries.\nThe second line contains\nn\nintegers\na\n1\n,...\na\nn\n(\n−\n10\n8\n≤\na\n1\n,...,\na\nn\n≤\n10\n8\n) — elements of the array\na\n.\nThe next\nq\nlines each contain three integers\ns\n,\nd\n, and\nk\n(\n1≤s,d,k≤n\n,\ns+d⋅(k−1)≤n\n).\nIt is guaranteed that the sum of\nn\nover all testcases does not exceed\n10\n5\n, and that the sum of\nq\nover all testcases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print\nq\nnumbers in a separate line — the desired sums, separated with space.\nExample\ninput\nCopy\n5\n3 3\n1 1 2\n1 2 2\n2 2 1\n1 1 2\n3 1\n-100000000 -100000000 -100000000\n1 1 3\n5 3\n1 2 3 4 5\n1 2 3\n2 3 2\n1 1 5\n3 1\n100000000 100000000 100000000\n1 1 3\n7 7\n34 87 5 42 -44 66 -32\n2 2 2\n4 3 1\n1 3 2\n6 2 1\n5 2 2\n2 5 2\n6 1 2\noutput\nCopy\n5 1 3 \n-600000000 \n22 12 55 \n600000000 \n171 42 118 66 -108 23 2 ",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "implementation",
            "math",
            "*1900"
        ]
    },
    {
        "title": "E. Eat the Chip",
        "description": "Alice and Bob are playing a game on a checkered board. The board has\nh\nrows, numbered from top to bottom, and\nw\ncolumns, numbered from left to right. Both players have a chip each. Initially, Alice's chip is located at the cell with coordinates\n(\nx\na\n,\ny\na\n)\n(row\nx\na\n, column\ny\na\n), and Bob's chip is located at\n(\nx\nb\n,\ny\nb\n)\n. It is guaranteed that the initial positions of the chips do not coincide. Players take turns making moves, with Alice starting.\nOn her turn, Alice can move her chip one cell down or one cell down-right or down-left (diagonally). Bob, on the other hand, moves his chip one cell up, up-right, or up-left. It is not allowed to make moves that go beyond the board boundaries.\nMore formally, if at the beginning of Alice's turn she is in the cell with coordinates\n(\nx\na\n,\ny\na\n)\n, then she can move her chip to one of the cells\n(\nx\na\n+1,\ny\na\n)\n,\n(\nx\na\n+1,\ny\na\n−1)\n, or\n(\nx\na\n+1,\ny\na\n+1)\n. Bob, on his turn, from the cell\n(\nx\nb\n,\ny\nb\n)\ncan move to\n(\nx\nb\n−1,\ny\nb\n)\n,\n(\nx\nb\n−1,\ny\nb\n−1)\n, or\n(\nx\nb\n−1,\ny\nb\n+1)\n. The new chip coordinates\n(\nx\n′\n,\ny\n′\n)\nmust satisfy the conditions\n1≤\nx\n′\n≤h\nand\n1≤\ny\n′\n≤w\n.\nExample game state. Alice plays with the white chip, Bob with the black one. Arrows indicate possible moves.\nA player immediately wins if they place their chip in a cell occupied by the other player's chip. If either player cannot make a move (Alice—if she is in the last row, i.e.\nx\na\n=h\n, Bob—if he is in the first row, i.e.\nx\nb\n=1\n), the game immediately ends in a draw.\nWhat will be the outcome of the game if both opponents play optimally?\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by the description of the test cases.\nEach test case consists of a single line containing six integers\nh\n,\nw\n,\nx\na\n,\ny\na\n,\nx\nb\n,\ny\nb\n(\n1≤\nx\na\n,\nx\nb\n≤h≤\n10\n6\n,\n1≤\ny\na\n,\ny\nb\n≤w≤\n10\n9\n) — the dimensions of the board and the initial positions of Alice's and Bob's chips. It is guaranteed that either\nx\na\n≠\nx\nb\nor\ny\na\n≠\ny\nb\n.\nIt is guaranteed that the sum of\nh\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output \"Alice\" if Alice wins, \"Bob\" if Bob wins, and \"Draw\" if neither player can secure a victory. You can output each letter in any case (lowercase or uppercase). For example, the strings \"bOb\", \"bob\", \"Bob\", and \"BOB\" will be accepted as Bob's victory.\nExample\ninput\nCopy\n12\n6 5 2 2 5 3\n4 1 2 1 4 1\n1 4 1 3 1 1\n5 5 1 4 5 2\n4 4 1 1 4 4\n10 10 1 6 10 8\n10 10 2 6 10 7\n10 10 9 1 8 1\n10 10 8 1 10 2\n10 10 1 1 2 1\n10 10 1 3 4 1\n10 10 3 1 1 1\noutput\nCopy\nAlice\nBob\nDraw\nDraw\nDraw\nAlice\nDraw\nDraw\nBob\nAlice\nAlice\nDraw",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "math",
            "*1600"
        ]
    },
    {
        "title": "D. Very Different Array",
        "description": "Petya has an array\na\ni\nof\nn\nintegers. His brother Vasya became envious and decided to make his own array of\nn\nintegers.\nTo do this, he found\nm\nintegers\nb\ni\n(\nm≥n\n), and now he wants to choose some\nn\nintegers of them and arrange them in a certain order to obtain an array\nc\ni\nof length\nn\n.\nTo avoid being similar to his brother, Vasya wants to make his array as different as possible from Petya's array. Specifically, he wants the total difference\nD=\n∑\nn\ni=1\n|\na\ni\n−\nc\ni\n|\nto be as large as possible.\nHelp Vasya find the maximum difference\nD\nhe can obtain.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤m≤2⋅\n10\n5\n).\nThe second line of each test case contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤\n10\n9\n). The third line of each test case contains\nm\nintegers\nb\ni\n(\n1≤\nb\ni\n≤\n10\n9\n).\nIt is guaranteed that in a test, the sum of\nm\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum total difference\nD\nthat can be obtained.\nExample\ninput\nCopy\n9\n4 6\n6 1 2 4\n3 5 1 7 2 3\n3 4\n1 1 1\n1 1 1 1\n5 5\n1 2 3 4 5\n1 2 3 4 5\n2 6\n5 8\n8 7 5 8 2 10\n2 2\n4 1\n9 6\n4 6\n8 10 6 4\n3 10 6 1 8 9\n3 5\n6 5 2\n1 7 9 7 2\n5 5\n9 10 6 3 7\n5 9 2 3 9\n1 6\n3\n2 7 10 1 1 5\noutput\nCopy\n16\n0\n12\n11\n10\n23\n15\n25\n7\nNote\nIn the first example, Vasya can, for example, create the array\n(1,5,7,2)\n. Then the total difference will be\nD=|6−1|+|1−5|+|2−7|+|4−2|=5+4+5+2=16\n.\nIn the second example, all the integers available to Vasya are equal to 1, so he can only create the array\n(1,1,1)\n, for which the difference\nD=0\n.\nIn the third example, Vasya can, for example, create the array\n(5,4,3,2,1)\n. Then the total difference will be\nD=|1−5|+|2−4|+|3−3|+|4−2|+|5−1|=4+2+0+2+4=12\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ]
    },
    {
        "title": "C. Sending Messages",
        "description": "Stepan is a very busy person. Today he needs to send\nn\nmessages at moments\nm\n1\n,\nm\n2\n,…\nm\nn\n(\nm\ni\n<\nm\ni+1\n). Unfortunately, by the moment\n0\n, his phone only has\nf\nunits of charge left. At the moment\n0\n, the phone is turned on.\nThe phone loses\na\nunits of charge for each unit of time it is on. Also, at any moment, Stepan can turn off the phone and turn it on later. This action consumes\nb\nunits of energy each time. Consider turning on and off to be instantaneous, so you can turn it on at moment\nx\nand send a message at the same moment, and vice versa, send a message at moment\nx\nand turn off the phone at the same moment.\nIf at any point the charge level drops to\n0\n(becomes\n≤0\n), it is impossible to send a message at that moment.\nSince all messages are very important to Stepan, he wants to know if he can send all the messages without the possibility of charging the phone.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by the descriptions of the test cases.\nThe first line of each test case contains four integers\nn\n,\nf\n,\na\n, and\nb\n(\n1≤n≤2⋅\n10\n5\n,\n1≤f,a,b≤\n10\n9\n) — the number of messages, the initial phone's charge, the charge consumption per unit of time, and the consumption when turned off and on sequentially.\nThe second line of each test case contains\nn\nintegers\nm\n1\n,\nm\n2\n,…,\nm\nn\n(\n1≤\nm\ni\n≤\n10\n9\n,\nm\ni\n<\nm\ni+1\n) — the moments at which messages need to be sent.\nIt is guaranteed that in a test the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if Stepan can send all the messages, and \"NO\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nExample\ninput\nCopy\n6\n1 3 1 5\n3\n7 21 1 3\n4 6 10 13 17 20 26\n5 10 1 2\n1 2 3 4 5\n1 1000000000 1000000000 1000000000\n1000000000\n3 11 9 6\n6 8 10\n12 621526648 2585904 3566299\n51789 61859 71998 73401 247675 298086 606959 663464 735972 806043 806459 919683\noutput\nCopy\nNO\nYES\nYES\nNO\nNO\nYES\nNote\nIn the first test case of the example, at moment\n0\n, the phone's charge is\n3\n. When sending a message at moment\n3\nwithout turning it off,\n(3−0)⋅1=3\nunits of charge will be spent. In this case, the charge will drop to\n0\nand Stepan will not be able to send the message. When turning off and on, the phone's charge will decrease by\n5\n, so it will not be possible to send the message in this way.\nIn the third test case of the example, at moment\n0\n, the phone's charge is\n10\n. The phone loses\n1\nunit of charge per unit of time, and when turned off and on, it loses\n2\nunits of charge. To send all messages, the following actions can be taken:\nTurn off the phone at moment\n0\nand turn it on at moment\n1\n, after which\n10−2=8\nunits of charge will remain;\nsend a message at moment\n1\n;\nsend a message at moment\n2\n, after which\n8−(2−1)⋅1=7\nunits of charge will remain;\nTurn off the phone at moment\n2\nand turn it on at moment\n3\n, after which\n7−2=5\nunits of charge will remain;\nsend a message at moment\n3\n;\nTurn off the phone at moment\n3\nand turn it on at moment\n4\n, after which\n5−2=3\nunits of charge will remain;\nsend a message at moment\n4\n;\nTurn off the phone at moment\n4\nand turn it on at moment\n5\n, after which\n3−2=1\nunit of charge will remain;\nsend a message at moment\n5\n.\nThe last (sixth) test set of the example may fail if there is an integer overflow in your solution.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*900"
        ]
    },
    {
        "title": "B. Arranging Cats",
        "description": "In order to test the hypothesis about the cats, the scientists must arrange the cats in the boxes in a specific way. Of course, they would like to test the hypothesis and publish a sensational article as quickly as possible, because they are too engrossed in the next hypothesis about the phone's battery charge.\nScientists have\nn\nboxes in which cats may or may not sit. Let the current state of the boxes be denoted by the sequence\nb\n1\n,…,\nb\nn\n:\nb\ni\n=1\nif there is a cat in box number\ni\n, and\nb\ni\n=0\notherwise.\nFortunately, the unlimited production of cats has already been established, so in one day, the scientists can perform one of the following operations:\nTake a new cat and place it in a box (for some\ni\nsuch that\nb\ni\n=0\n, assign\nb\ni\n=1\n).\nRemove a cat from a box and send it into retirement (for some\ni\nsuch that\nb\ni\n=1\n, assign\nb\ni\n=0\n).\nMove a cat from one box to another (for some\ni,j\nsuch that\nb\ni\n=1,\nb\nj\n=0\n, assign\nb\ni\n=0,\nb\nj\n=1\n).\nIt has also been found that some boxes were immediately filled with cats. Therefore, the scientists know the initial position of the cats in the boxes\ns\n1\n,…,\ns\nn\nand the desired position\nf\n1\n,…,\nf\nn\n.\nDue to the large amount of paperwork, the scientists do not have time to solve this problem. Help them for the sake of science and indicate the minimum number of days required to test the hypothesis.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by descriptions of the test cases.\nEach test case consists of three lines.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of boxes.\nThe second line of each test case contains a string\ns\nof\nn\ncharacters, where the\ni\n-th character is '1' if there is a cat in the\ni\n-th box and '0' otherwise.\nThe third line of each test case contains a string\nf\nof\nn\ncharacters, where the\ni\n-th character is '1' if there should be a cat in the\ni\n-th box and '0' otherwise.\nIt is guaranteed that in a test the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer on a separate line — the minimum number of operations required to obtain the desired position from the initial position. It can be shown that a solution always exists.\nExample\ninput\nCopy\n6\n5\n10010\n00001\n1\n1\n1\n3\n000\n111\n4\n0101\n1010\n3\n100\n101\n8\n10011001\n11111110\noutput\nCopy\n2\n0\n3\n2\n1\n4\nNote\nIn the first test case, you can first move the cat from the first box to the fifth, and then remove the cat from the fourth box.\nIn the second test case, there is nothing to do — the only cat is already sitting in the correct box.\nIn the third test case of input data, it takes three days to place a cat in each box.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Square",
        "description": "A square of positive (strictly greater than\n0\n) area is located on the coordinate plane, with sides parallel to the coordinate axes. You are given the coordinates of its corners, in random order. Your task is to find the area of the square.\nInput\nEach test consists of several testcases. The first line contains one integer\nt\n(\n1≤t≤100\n) — the number of testcases. The following is a description of the testcases.\nEach testcase contains four lines, each line contains two integers\nx\ni\n,\ny\ni\n(\n−1000≤\nx\ni\n,\ny\ni\n≤1000\n), coordinates of the corners of the square.\nIt is guaranteed that there is a square with sides parallel to the coordinate axes, with positive (strictly greater than\n0\n) area, with corners in given points.\nOutput\nFor each test case, print a single integer, the area of the square.\nExample\ninput\nCopy\n3\n1 2\n4 5\n1 5\n4 2\n-1 1\n1 -1\n1 1\n-1 -1\n45 11\n45 39\n17 11\n17 39\noutput\nCopy\n9\n4\n784",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "F2. Smooth Sailing (Hard Version)",
        "description": "The only difference between the two versions of this problem is the constraint on\nq\n. You can make hacks only if both versions of the problem are solved.\nThomas is sailing around an island surrounded by the ocean. The ocean and island can be represented by a grid with\nn\nrows and\nm\ncolumns. The rows are numbered from\n1\nto\nn\nfrom top to bottom, and the columns are numbered from\n1\nto\nm\nfrom left to right. The position of a cell at row\nr\nand column\nc\ncan be represented as\n(r,c)\n. Below is an example of a valid grid.\nExample of a valid grid\nThere are three types of cells: island, ocean and underwater volcano. Cells representing the island are marked with a '#', cells representing the ocean are marked with a '.', and cells representing an underwater volcano are marked with a 'v'. It is guaranteed that there is at least one island cell and at least one underwater volcano cell. It is also guaranteed that the set of all island cells forms a single connected component\n†\n†\nand the set of all ocean cells and underwater volcano cells forms a single connected component. Additionally, it is guaranteed that there are no island cells at the edge of the grid (that is, at row\n1\n, at row\nn\n, at column\n1\n, and at column\nm\n).\nDefine a round trip starting from cell\n(x,y)\nas a path Thomas takes which satisfies the following conditions:\nThe path starts and ends at\n(x,y)\n.\nIf Thomas is at cell\n(i,j)\n, he can go to cells\n(i+1,j)\n,\n(i−1,j)\n,\n(i,j−1)\n, and\n(i,j+1)\nas long as the destination cell is an ocean cell or an underwater volcano cell and is still inside the grid. Note that it is allowed for Thomas to visit the same cell multiple times in the same round trip.\nThe path must go around the island and fully encircle it. Some path\np\nfully encircles the island if it is impossible to go from an island cell to a cell on the grid border by only traveling to adjacent on a side or diagonal cells without visiting a cell on path\np\n. In the image below, the path starting from\n(2,2)\n, going to\n(1,3)\n, and going back to\n(2,2)\nthe other way does not fully encircle the island and is not considered a round trip.\nExample of a path that does not fully encircle the island\nThe safety of a round trip is the minimum Manhattan distance\n‡\n‡\nfrom a cell on the round trip to an underwater volcano (note that the presence of island cells does not impact this distance).\nYou have\nq\nqueries. A query can be represented as\n(x,y)\nand for every query, you want to find the maximum safety of a round trip starting from\n(x,y)\n. It is guaranteed that\n(x,y)\nis an ocean cell or an underwater volcano cell.\n†\n†\nA set of cells forms a single connected component if from any cell of this set it is possible to reach any other cell of this set by moving only through the cells of this set, each time going to a cell with a common side.\n‡\n‡\nManhattan distance between cells\n(\nr\n1\n,\nc\n1\n)\nand\n(\nr\n2\n,\nc\n2\n)\nis equal to\n|\nr\n1\n−\nr\n2\n|+|\nc\n1\n−\nc\n2\n|\n.\nInput\nThe first line contains three integers\nn\n,\nm\n, and\nq\n(\n3≤n,m≤\n10\n5\n,\n9≤n⋅m≤3⋅\n10\n5\n,\n1≤q≤3⋅\n10\n5\n) — the number of rows and columns of the grid and the number of queries.\nEach of the following\nn\nlines contains\nm\ncharacters describing the cells of the grid. The character '#' denotes an island cell, '.' denotes an ocean cell, and 'v' denotes an underwater volcano cell.\nIt is guaranteed that there is at least one island cell and at least one underwater volcano cell. It is guaranteed that the set of all island cells forms a single connected component and the set of all ocean cells and underwater volcano cells forms a single connected component. Also, it is guaranteed that there are no island cells at the edge of the grid (that is, at the row\n1\n, at the row\nn\n, at the column\n1\n, and at the column\nm\n).\nThe following\nq\nlines describe the queries. Each of these lines contains two integers\nx\nand\ny\n(\n1≤x≤n\n,\n1≤y≤m\n) denoting a round trip starting from\n(x,y)\n.\nIt is guaranteed that\n(x,y)\nis an ocean cell or an underwater volcano cell.\nOutput\nFor each query, output a single integer — the maximum safety of a round trip starting from the specified position.\nExamples\ninput\nCopy\n9 9 3\n.........\n.........\n....###..\n...v#....\n..###....\n...##...v\n...##....\n.........\nv........\n1 1\n9 1\n5 7\noutput\nCopy\n3\n0\n3\ninput\nCopy\n3 3 5\n..v\n.#.\n...\n1 2\n1 3\n2 3\n2 1\n3 2\noutput\nCopy\n0\n0\n0\n0\n0\ninput\nCopy\n14 13 5\n.............\n.............\n.............\n...vvvvvvv...\n...v.....v...\n...v.###.v...\n...v.#.#.v...\n...v..v..v...\n...v..v..v...\n....v...v....\n.....vvv.....\n.............\n.............\n.............\n1 1\n7 7\n5 6\n4 10\n13 6\noutput\nCopy\n3\n0\n1\n0\n2\ninput\nCopy\n10 11 4\n...........\n..#######..\n..#..#..#..\n..#.....#..\n..#..v..#..\n..#.###.#..\n..#.#.#.#..\n..#...#.#..\n..#####.#..\n...........\n7 6\n3 7\n6 8\n1 1\noutput\nCopy\n1\n2\n3\n4\nNote\nFor the first example, the image below shows an optimal round trip starting from\n(1,1)\n. The round trip has a safety of\n3\nas the minimum Manhattan distance from a cell on the round trip to an underwater volcano is\n3\n.\nExample of an optimal round trip\nFor the fourth example, remember that it is allowed for Thomas to visit the same cell multiple times in the same round trip. For example, doing so is necessary for the round trip starting from\n(7,6)\n.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dsu",
            "geometry",
            "graphs",
            "trees",
            "*3000"
        ]
    },
    {
        "title": "F1. Smooth Sailing (Easy Version)",
        "description": "The only difference between the two versions of this problem is the constraint on\nq\n. You can make hacks only if both versions of the problem are solved.\nThomas is sailing around an island surrounded by the ocean. The ocean and island can be represented by a grid with\nn\nrows and\nm\ncolumns. The rows are numbered from\n1\nto\nn\nfrom top to bottom, and the columns are numbered from\n1\nto\nm\nfrom left to right. The position of a cell at row\nr\nand column\nc\ncan be represented as\n(r,c)\n. Below is an example of a valid grid.\nExample of a valid grid\nThere are three types of cells: island, ocean and underwater volcano. Cells representing the island are marked with a '#', cells representing the ocean are marked with a '.', and cells representing an underwater volcano are marked with a 'v'. It is guaranteed that there is at least one island cell and at least one underwater volcano cell. It is also guaranteed that the set of all island cells forms a single connected component\n†\n†\nand the set of all ocean cells and underwater volcano cells forms a single connected component. Additionally, it is guaranteed that there are no island cells at the edge of the grid (that is, at row\n1\n, at row\nn\n, at column\n1\n, and at column\nm\n).\nDefine a round trip starting from cell\n(x,y)\nas a path Thomas takes which satisfies the following conditions:\nThe path starts and ends at\n(x,y)\n.\nIf Thomas is at cell\n(i,j)\n, he can go to cells\n(i+1,j)\n,\n(i−1,j)\n,\n(i,j−1)\n, and\n(i,j+1)\nas long as the destination cell is an ocean cell or an underwater volcano cell and is still inside the grid. Note that it is allowed for Thomas to visit the same cell multiple times in the same round trip.\nThe path must go around the island and fully encircle it. Some path\np\nfully encircles the island if it is impossible to go from an island cell to a cell on the grid border by only traveling to adjacent on a side or diagonal cells without visiting a cell on path\np\n. In the image below, the path starting from\n(2,2)\n, going to\n(1,3)\n, and going back to\n(2,2)\nthe other way does not fully encircle the island and is not considered a round trip.\nExample of a path that does not fully encircle the island\nThe safety of a round trip is the minimum Manhattan distance\n‡\n‡\nfrom a cell on the round trip to an underwater volcano (note that the presence of island cells does not impact this distance).\nYou have\nq\nqueries. A query can be represented as\n(x,y)\nand for every query, you want to find the maximum safety of a round trip starting from\n(x,y)\n. It is guaranteed that\n(x,y)\nis an ocean cell or an underwater volcano cell.\n†\n†\nA set of cells forms a single connected component if from any cell of this set it is possible to reach any other cell of this set by moving only through the cells of this set, each time going to a cell with a common side.\n‡\n‡\nManhattan distance between cells\n(\nr\n1\n,\nc\n1\n)\nand\n(\nr\n2\n,\nc\n2\n)\nis equal to\n|\nr\n1\n−\nr\n2\n|+|\nc\n1\n−\nc\n2\n|\n.\nInput\nThe first line contains three integers\nn\n,\nm\n, and\nq\n(\n3≤n,m≤\n10\n5\n,\n9≤n⋅m≤3⋅\n10\n5\n,\n1≤q≤5\n) — the number of rows and columns of the grid and the number of queries.\nEach of the following\nn\nlines contains\nm\ncharacters describing the cells of the grid. The character '#' denotes an island cell, '.' denotes an ocean cell, and 'v' denotes an underwater volcano cell.\nIt is guaranteed that there is at least one island cell and at least one underwater volcano cell. It is guaranteed that the set of all island cells forms a single connected component and the set of all ocean cells and underwater volcano cells forms a single connected component. Also, it is guaranteed that there are no island cells at the edge of the grid (that is, at the row\n1\n, at the row\nn\n, at the column\n1\n, and at the column\nm\n).\nThe following\nq\nlines describe the queries. Each of these lines contains two integers\nx\nand\ny\n(\n1≤x≤n\n,\n1≤y≤m\n) denoting a round trip starting from\n(x,y)\n.\nIt is guaranteed that\n(x,y)\nis an ocean cell or an underwater volcano cell.\nOutput\nFor each query, output a single integer — the maximum safety of a round trip starting from the specified position.\nExamples\ninput\nCopy\n9 9 3\n.........\n.........\n....###..\n...v#....\n..###....\n...##...v\n...##....\n.........\nv........\n1 1\n9 1\n5 7\noutput\nCopy\n3\n0\n3\ninput\nCopy\n3 3 5\n..v\n.#.\n...\n1 2\n1 3\n2 3\n2 1\n3 2\noutput\nCopy\n0\n0\n0\n0\n0\ninput\nCopy\n14 13 5\n.............\n.............\n.............\n...vvvvvvv...\n...v.....v...\n...v.###.v...\n...v.#.#.v...\n...v..v..v...\n...v..v..v...\n....v...v....\n.....vvv.....\n.............\n.............\n.............\n1 1\n7 7\n5 6\n4 10\n13 6\noutput\nCopy\n3\n0\n1\n0\n2\ninput\nCopy\n10 11 4\n...........\n..#######..\n..#..#..#..\n..#.....#..\n..#..v..#..\n..#.###.#..\n..#.#.#.#..\n..#...#.#..\n..#####.#..\n...........\n7 6\n3 7\n6 8\n1 1\noutput\nCopy\n1\n2\n3\n4\nNote\nFor the first example, the image below shows an optimal round trip starting from\n(1,1)\n. The round trip has a safety of\n3\nas the minimum Manhattan distance from a cell on the round trip to an underwater volcano is\n3\n.\nExample of an optimal round trip\nFor the fourth example, remember that it is allowed for Thomas to visit the same cell multiple times in the same round trip. For example, doing so is necessary for the round trip starting from\n(7,6)\n.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "dfs and similar",
            "dsu",
            "graphs",
            "shortest paths",
            "*2500"
        ]
    },
    {
        "title": "E. Counting Binary Strings",
        "description": "Patrick calls a substring\n†\n†\nof a binary string\n‡\n‡\ngood if this substring contains exactly one 1.\nHelp Patrick count the number of binary strings\ns\nsuch that\ns\ncontains exactly\nn\ngood substrings and has no good substring of length strictly greater than\nk\n. Note that substrings are differentiated by their location in the string, so if\ns=\n1010 you should count both occurrences of 10.\n†\n†\nA string\na\nis a substring of a string\nb\nif\na\ncan be obtained from\nb\nby the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\n‡\n‡\nA binary string is a string that only contains the characters 0 and 1.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤2500\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2500\n,\n1≤k≤n\n) — the number of required good substrings and the maximum allowed length of a good substring.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2500\n.\nOutput\nFor each test case, output a single integer — the number of binary strings\ns\nsuch that\ns\ncontains exactly\nn\ngood substrings and has no good substring of length strictly greater than\nk\n. Since this integer can be too large, output it modulo\n998244353\n.\nExample\ninput\nCopy\n6\n1 1\n3 2\n4 2\n5 4\n6 2\n2450 2391\noutput\nCopy\n1\n3\n5\n12\n9\n259280854\nNote\nIn the first test case, the only suitable binary string is 1. String 01 is not suitable because it contains a substring 01 with length\n2>1\n.\nIn the second test case, suitable binary strings are 011, 110 and 111.\nIn the third test case, suitable binary strings are 101, 0110, 0111, 1110, and 1111.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2100"
        ]
    },
    {
        "title": "D. Array Repetition",
        "description": "Jayden has an array\na\nwhich is initially empty. There are\nn\noperations of two types he must perform in the given order.\nJayden appends an integer\nx\n(\n1≤x≤n\n) to the end of array\na\n.\nJayden appends\nx\ncopies of array\na\nto the end of array\na\n. In other words, array\na\nbecomes\n[a,\na,…,a\n⏟\nx\n]\n. It is guaranteed that he has done at least one operation of the first type before this.\nJayden has\nq\nqueries. For each query, you must tell him the\nk\n-th element of array\na\n. The elements of the array are numbered from\n1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤5000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nq\n(\n1≤n,q≤105\n) — the number of operations and the number of queries.\nThe following\nn\nlines describe the operations. Each line contains two integers\nb\nand\nx\n(\nb∈{1,2}\n), where\nb\ndenotes the type of operation. If\nb=1\n, then\nx\n(\n1≤x≤n\n) is the integer Jayden appends to the end of the array. If\nb=2\n, then\nx\n(\n1≤x≤109\n) is the number of copies Jayden appends to the end of the array.\nThe next line of each test case contains\nq\nintegers\nk1,k2,…,kq\n(\n1≤ki≤min(1018,c)\n), which denote the queries, where\nc\nis the size of the array after finishing all\nn\noperations.\nIt is guaranteed that the sum of\nn\nand the sum of\nq\nover all test cases does not exceed\n105\n.\nOutput\nFor each test case, output\nq\nintegers — answers to Jayden's queries.\nExample\ninput\nCopy\n4\n5 10\n1 1\n1 2\n2 1\n1 3\n2 3\n1 2 3 4 5 6 14 15 16 20\n10 10\n1 3\n1 8\n2 15\n1 6\n1 9\n1 1\n2 6\n1 1\n2 12\n2 10\n32752 25178 3198 3199 2460 2461 31450 33260 9016 4996\n12 5\n1 6\n1 11\n2 392130334\n1 4\n2 744811750\n1 10\n1 5\n2 209373780\n2 178928984\n1 3\n2 658326464\n2 1000000000\n914576963034536490 640707385283752918 636773368365261971 584126563607944922 1000000000000000000\n2 2\n1 1\n1 2\n1 2\noutput\nCopy\n1 2 1 2 3 1 2 3 1 3\n9 8 1 3 1 3 6 3 8 8\n11 11 11 10 11\n1 2\nNote\nIn the first test case:\nAfter the first operation\na=[1]\n;\nAfter the second operation\na=[1,2]\n;\nAfter the third operation\na=[1,2,1,2]\n;\nAfter the fourth operation\na=[1,2,1,2,3]\n;\nAfter the fifth operation\na=[1,2,1,2,3,1,2,1,2,3,1,2,1,2,3,1,2,1,2,3]\n.\nIn the fourth test case, after all operations\na=[1,2]\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dsu",
            "implementation",
            "math",
            "*1900"
        ]
    },
    {
        "title": "C. Partitioning the Array",
        "description": "Allen has an array\na\n1\n,\na\n2\n,…,\na\nn\n. For every positive integer\nk\nthat is a divisor of\nn\n, Allen does the following:\nHe partitions the array into\nn\nk\ndisjoint subarrays of length\nk\n. In other words, he partitions the array into the following subarrays:\n[\na\n1\n,\na\n2\n,…,\na\nk\n],[\na\nk+1\n,\na\nk+2\n,…,\na\n2k\n],…,[\na\nn−k+1\n,\na\nn−k+2\n,…,\na\nn\n]\n[\n]\n[\n]\n[\n]\nAllen earns one point if there exists some positive integer\nm\n(\nm≥2\n) such that if he replaces every element in the array with its remainder when divided by\nm\n, then all subarrays will be identical.\nHelp Allen find the number of points he will earn.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the number of points Allen will earn.\nExample\ninput\nCopy\n8\n4\n1 2 1 4\n3\n1 2 3\n5\n1 1 1 1 1\n6\n1 3 1 1 3 1\n6\n6 2 6 2 2 2\n6\n2 6 3 6 6 6\n10\n1 7 5 1 4 3 1 3 1 4\n1\n1\noutput\nCopy\n2\n1\n2\n4\n4\n1\n2\n1\nNote\nIn the first test case,\nk=2\nearns a point since Allen can pick\nm=2\nand both subarrays will be equal to\n[1,0]\n.\nk=4\nalso earns a point, since no matter what\nm\nAllen chooses, there will be only one subarray and thus all subarrays are equal.\nIn the second test case, Allen earns\n1\npoint for\nk=3\n, where his choice for\nm\ndoes not matter.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1600"
        ]
    },
    {
        "title": "B. Summation Game",
        "description": "Alice and Bob are playing a game. They have an array\na\n1\n,\na\n2\n,…,\na\nn\n. The game consists of two steps:\nFirst, Alice will remove at most\nk\nelements from the array.\nSecond, Bob will multiply at most\nx\nelements of the array by\n−1\n.\nAlice wants to maximize the sum of elements of the array while Bob wants to minimize it. Find the sum of elements of the array after the game if both players play optimally.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers\nn\n,\nk\n, and\nx\n(\n1≤n≤2⋅\n10\n5\n,\n1≤x,k≤n\n) — the number of elements in the array, the limit on the number of elements of the array that Alice can remove, and the limit on the number of elements of the array that Bob can multiply\n−1\nto.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤1000\n) — the elements of the array.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the sum of elements of the array after the game if both players play optimally.\nExample\ninput\nCopy\n8\n1 1 1\n1\n4 1 1\n3 1 2 4\n6 6 3\n1 4 3 2 5 6\n6 6 1\n3 7 3 3 32 15\n8 5 3\n5 5 3 3 3 2 9 9\n10 6 4\n1 8 2 9 3 3 4 5 3 200\n2 2 1\n4 3\n2 1 2\n1 3\noutput\nCopy\n0\n2\n0\n3\n-5\n-9\n0\n-1\nNote\nIn the first test case, it is optimal for Alice to remove the only element of the array. Then, the sum of elements of the array is\n0\nafter the game is over.\nIn the second test case, it is optimal for Alice to not remove any elements. Bob will then multiply\n4\nby\n−1\n. So the final sum of elements of the array is\n3+1+2−4=2\n.\nIn the fifth test case, it is optimal for Alice to remove\n9,9\n. Bob will then multiply\n5,5,3\nby\n−1\n. So the final sum of elements of the array is\n−5−5−3+3+3+2=−5\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "sortings",
            "*1100"
        ]
    },
    {
        "title": "A. Satisfying Constraints",
        "description": "Alex is solving a problem. He has\nn\nconstraints on what the integer\nk\ncan be. There are three types of constraints:\nk\nmust be greater than or equal to some integer\nx\n;\nk\nmust be less than or equal to some integer\nx\n;\nk\nmust be not equal to some integer\nx\n.\nHelp Alex find the number of integers\nk\nthat satisfy all\nn\nconstraints. It is guaranteed that the answer is finite (there exists at least one constraint of type\n1\nand at least one constraint of type\n2\n). Also, it is guaranteed that no two constraints are the exact same.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤100\n) — the number of constraints.\nThe following\nn\nlines describe the constraints. Each line contains two integers\na\nand\nx\n(\na∈{1,2,3},1≤x≤\n10\n9\n).\na\ndenotes the type of constraint. If\na=1\n,\nk\nmust be greater than or equal to\nx\n. If\na=2\n,\nk\nmust be less than or equal to\nx\n. If\na=3\n,\nk\nmust be not equal to\nx\n.\nIt is guaranteed that there is a finite amount of integers satisfying all\nn\nconstraints (there exists at least one constraint of type\n1\nand at least one constraint of type\n2\n). It is also guaranteed that no two constraints are the exact same (in other words, all pairs\n(a,x)\nare distinct).\nOutput\nFor each test case, output a single integer — the number of integers\nk\nthat satisfy all\nn\nconstraints.\nExample\ninput\nCopy\n6\n4\n1 3\n2 10\n3 1\n3 5\n2\n1 5\n2 4\n10\n3 6\n3 7\n1 2\n1 7\n3 100\n3 44\n2 100\n2 98\n1 3\n3 99\n6\n1 5\n2 10\n1 9\n2 2\n3 2\n3 9\n5\n1 1\n2 2\n3 1\n3 2\n3 3\n6\n1 10000\n2 900000000\n3 500000000\n1 100000000\n3 10000\n3 900000001\noutput\nCopy\n7\n0\n90\n0\n0\n800000000\nNote\nIn the first test case,\nk≥3\nand\nk≤10\n. Furthermore,\nk≠1\nand\nk≠5\n. The possible integers\nk\nthat satisfy the constraints are\n3,4,6,7,8,9,10\n. So the answer is\n7\n.\nIn the second test case,\nk≥5\nand\nk≤4\n, which is impossible. So the answer is\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*800"
        ]
    },
    {
        "title": "H. Tree Diameter",
        "description": "There is a hidden tree with\nn\nvertices. The\nn−1\nedges of the tree are numbered from\n1\nto\nn−1\n. You can ask the following queries of two types:\nGive the grader an array\na\nwith\nn−1\npositive integers. For each edge from\n1\nto\nn−1\n, the weight of edge\ni\nis set to\na\ni\n. Then, the grader will return the length of the diameter\n†\n†\n.\nGive the grader two indices\n1≤a,b≤n−1\n. The grader will return the number of edges between edges\na\nand\nb\n. In other words, if edge\na\nconnects\nu\na\nand\nv\na\nwhile edge\nb\nconnects\nu\nb\nand\nv\nb\n, the grader will return\nmin(dist(\nu\na\n,\nu\nb\n),dist(\nv\na\n,\nu\nb\n),dist(\nu\na\n,\nv\nb\n),dist(\nv\na\n,\nv\nb\n))\n, where\ndist(u,v)\nrepresents the number of edges on the path between vertices\nu\nand\nv\n.\nFind any tree isomorphic\n‡\n‡\nto the hidden tree after at most\nn\nqueries of type 1 and\nn\nqueries of type 2 in any order.\n†\n†\nThe distance between two vertices is the sum of the weights on the unique simple path that connects them. The diameter is the largest of all those distances.\n‡\n‡\nTwo trees, consisting of\nn\nvertices each, are called isomorphic if there exists a permutation\np\ncontaining integers from\n1\nto\nn\nsuch that edge (\nu\n,\nv\n) is present in the first tree if and only if the edge (\np\nu\n,\np\nv\n) is present in the second tree.\nInput\nThe first and only line of input contains a single integer\nn\n(\n3≤n≤1000\n) — the number of vertices in the tree.\nInteraction\nBegin the interaction by reading\nn\n.\nYou are allowed to make queries in the following way:\n\"\n?1\na\n1\na\n2\n…\na\nn−1\n\" (\n1≤\na\ni\n≤\n10\n9\n). Then, you should read an integer\nk\nwhich represents the length of the diameter. You are only allowed to ask this query at most\nn\ntimes.\n\"\n?2ab\n\" (\n1≤a,b≤n−1\n). Then, you should read an integer\nk\nwhich represents the number of edges between edges\na\nand\nb\n. You are only allowed to ask this query at most\nn\ntimes.\nIn case your query is invalid. the program will terminate immediately and you will receive Wrong answer verdict.\nTo give the final answer, print \"!\" on a single line, followed by\nn−1\nlines where line\ni\ncontains \"\nu\ni\nv\ni\n\" (\n1≤\nu\ni\n,\nv\ni\n≤n\n) which represents that for each\ni\nfrom\n1\nto\nn−1\n, there is an edge between\nu\ni\nand\nv\ni\n.\nAfter printing a query do not forget to output end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee documentation for other languages.\nHacks\nThe first line contains a single integer\nn\n(\n3≤n≤1000\n) — the number of vertices in the tree.\nThe next\nn−1\nlines contain two integers each\nu\ni\n,\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n) — the edges of the tree.\nExample\ninput\nCopy\n5\n\n3\n\n1\n\n9\n\n0\noutput\nCopy\n? 1 1 1 1 1\n\n? 2 1 3\n\n? 1 4 3 2 1\n\n? 2 4 2\n\n!\n3 1\n4 2\n1 2\n2 5\nNote\nThe hidden tree in the example is shown above. The number on the vertices represents the vertex number while the number on the edges represents the edge number.\nIn the first query, all the edges are set to weight\n1\n, so the diameter has length\n3\nas shown in the diagram.\nIn the second query, there is\n1\nedge between edges\n1\nand\n3\n.\nIn the third query, the diameter is\n9\nby taking edges\n1\n,\n2\nand\n3\n.\nIn the fourth query, there are no edges between edges\n4\nand\n2\n.\nThe answer given in the example is shown in the above diagram. Since it is isomorphic to the hidden tree, it is accepted as a correct answer. Note that the edges can be printed in any order.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "interactive",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "G. Tree LGM",
        "description": "In TreeWorld, there is a popular two-player game played on a tree with\nn\nvertices labelled from\n1\nto\nn\n. In this game, the tournament leaders first choose a vertex to be the root of the tree and choose another vertex (possibly the same vertex as the root) to place a coin on. Then, each player will take turns moving the coin to any child\n†\n†\nof the vertex that the coin is currently on. The first player who is unable to make a move loses.\nAlice wants to be a tree LGM, so she spends a lot of time studying the game. She wrote down an\nn\nby\nn\nmatrix\ns\n, where\ns\ni,j\n=1\nif the first player can win with the root of the tree chosen to be vertex\ni\n, and the coin was initially placed on vertex\nj\n. Otherwise,\ns\ni,j\n=0\n. Alice is a perfectionist, so she assumes that both players play perfectly in the game.\nHowever, she accidentally knocked her head on the way to the tournament and forgot what the tree looked like. Determine whether there exists a tree that satisfies the winning and losing states represented by matrix\ns\n, and if it exists, construct a valid tree.\n†\n†\nA vertex\nc\nis a child of vertex\nu\nif there is an edge between\nc\nand\nu\n, and\nc\ndoes not lie on the unique simple path from the root to vertex\nu\n.\nInput\nThe first line contains a single integer\nn\n(\n1≤n≤5000\n) — the number of vertices in the tree.\nEach of the next\nn\nlines contains a string with\nn\ncharacters, the\nj\n-th character of the\ni\n-th line representing\ns\ni,j\n(\ns\ni,j\n∈{0,1}\n) — the winning and losing states of the tree.\nOutput\nIf there is no tree satisfying the winning and losing states represented by matrix\ns\n, print a single line containing \"NO\".\nOtherwise, if there exists a tree satisfying matrix\ns\n, print \"YES\" on the first line, followed by\nn−1\nlines each containing two integers\nu\nand\nv\n(\n1≤u,v≤n\n) representing that the tree has an edge between vertices\nu\nand\nv\n.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIf there are multiple trees satisfying the winning and losing states represented by matrix\ns\n, print any of them.\nExamples\ninput\nCopy\n4\n1100\n0101\n0011\n0101\noutput\nCopy\nYES\n4 1\n3 2\n2 4\ninput\nCopy\n3\n001\n010\n100\noutput\nCopy\nNO\nNote\nIn the first test case, the line graph\n1−4−2−3\nsatisfies the winning and losing states represented by matrix\ns\n. For example,\ns\n3,3\n=1\nas the first player can move the coin from\n3→2\n, then the second player moves the coin from\n2→4\n, and finally, the first player moves the coin from\n4→1\n. At this point,\n1\nhas no children, so the second player is unable to make a move and loses. On the other hand,\ns\n1,3\n=0\nas if\n1\nis the root, then\n3\nhas no children so the first player is unable to make the first move and loses.\nIn the second test case, it is possible to prove that no tree satisfies the winning and losing states represented by matrix\ns\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "divide and conquer",
            "games",
            "trees",
            "*3500"
        ]
    },
    {
        "title": "F2. Wine Factory (Hard Version)",
        "description": "This is the hard version of the problem. The only difference between the two versions is the constraint on\nc\ni\nand\nz\n. You can make hacks only if both versions of the problem are solved.\nThere are three arrays\na\n,\nb\nand\nc\n.\na\nand\nb\nhave length\nn\nand\nc\nhas length\nn−1\n. Let\nW(a,b,c)\ndenote the liters of wine created from the following process.\nCreate\nn\nwater towers. The\ni\n-th water tower initially has\na\ni\nliters of water and has a wizard with power\nb\ni\nin front of it. Furthermore, for each\n1≤i≤n−1\n, there is a valve connecting water tower\ni\nto\ni+1\nwith capacity\nc\ni\n.\nFor each\ni\nfrom\n1\nto\nn\nin this order, the following happens:\nThe wizard in front of water tower\ni\nremoves at most\nb\ni\nliters of water from the tower and turns the removed water into wine.\nIf\ni≠n\n, at most\nc\ni\nliters of the remaining water left in water tower\ni\nflows through the valve into water tower\ni+1\n.\nThere are\nq\nupdates. In each update, you will be given integers\np\n,\nx\n,\ny\nand\nz\nand you will update\na\np\n:=x\n,\nb\np\n:=y\nand\nc\np\n:=z\n. After each update, find the value of\nW(a,b,c)\n. Note that previous updates to arrays\na\n,\nb\nand\nc\npersist throughout future updates.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n2≤n≤5⋅\n10\n5\n,\n1≤q≤5⋅\n10\n5\n) — the number of water towers and the number of updates.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the number of liters of water in water tower\ni\n.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n≤\n10\n9\n) — the power of the wizard in front of water tower\ni\n.\nThe fourth line contains\nn−1\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn−1\n(\n0≤\nc\ni\n≤\n10\n18\n) — the capacity of the pipe connecting water tower\ni\nto\ni+1\n.\nEach of the next\nq\nlines contains four integers\np\n,\nx\n,\ny\nand\nz\n(\n1≤p≤n\n,\n0≤x,y≤\n10\n9\n,\n0≤z≤\n10\n18\n) — the updates done to arrays\na\n,\nb\nand\nc\n.\nNote that\nc\nn\ndoes not exist, so the value of\nz\ndoes not matter when\np=n\n.\nOutput\nPrint\nq\nlines, each line containing a single integer representing\nW(a,b,c)\nafter each update.\nExamples\ninput\nCopy\n4 3\n3 3 3 3\n1 4 2 8\n5 2 1\n4 3 8 1000000000\n2 5 1 1\n3 0 0 0\noutput\nCopy\n11\n8\n5\ninput\nCopy\n5 5\n10 3 8 9 2\n3 4 10 8 1\n6 5 9 2\n5 4 9 1\n1 1 1 1\n2 7 4 8\n4 1 1 1\n1 8 3 3\noutput\nCopy\n31\n25\n29\n21\n23\nNote\nThe first update does not make any modifications to the arrays.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n5\nliters of water in tower 2 and\n4\nliters of water is turned into wine. The remaining\n1\nliter of water flows into tower 3.\nWhen\ni=3\n, there are\n4\nliters of water in tower 3 and\n2\nliters of water is turned into wine. Even though there are\n2\nliters of water remaining, only\n1\nliter of water can flow into tower 4.\nWhen\ni=4\n, there are\n4\nliters of water in tower 4. All\n4\nliters of water are turned into wine.\nHence,\nW(a,b,c)=1+4+2+4=11\nafter the first update.\nThe second update modifies the arrays to\na=[3,5,3,3]\n,\nb=[1,1,2,8]\n, and\nc=[5,1,1]\n.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n7\nliters of water in tower 2 and\n1\nliter of water is turned into wine. Even though there are\n6\nliters of water remaining, only\n1\nliter of water can flow to tower 3.\nWhen\ni=3\n, there are\n4\nliters of water in tower 3 and\n2\nliters of water is turned into wine. Even though there are\n2\nliters of water remaining, only\n1\nliter of water can flow into tower 4.\nWhen\ni=4\n, there are\n4\nliters of water in tower 4. All\n4\nliters of water are turned into wine.\nHence,\nW(a,b,c)=1+1+2+4=8\nafter the second update.\nThe third update modifies the arrays to\na=[3,5,0,3]\n,\nb=[1,1,0,8]\n, and\nc=[5,1,0]\n.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n7\nliters of water in tower 2 and\n1\nliter of water is turned into wine. Even though there are\n6\nliters of water remaining, only\n1\nliter of water can flow to tower 3.\nWhen\ni=3\n, there is\n1\nliter of water in tower 3 and\n0\nliters of water is turned into wine. Even though there is\n1\nliter of water remaining, no water can flow to tower 4.\nWhen\ni=4\n, there are\n3\nliters of water in tower 4. All\n3\nliters of water are turned into wine.\nHence,\nW(a,b,c)=1+1+0+3=5\nafter the third update.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dp",
            "flows",
            "greedy",
            "matrices",
            "*2800"
        ]
    },
    {
        "title": "F1. Wine Factory (Easy Version)",
        "description": "This is the easy version of the problem. The only difference between the two versions is the constraint on\nc\ni\nand\nz\n. You can make hacks only if both versions of the problem are solved.\nThere are three arrays\na\n,\nb\nand\nc\n.\na\nand\nb\nhave length\nn\nand\nc\nhas length\nn−1\n. Let\nW(a,b,c)\ndenote the liters of wine created from the following process.\nCreate\nn\nwater towers. The\ni\n-th water tower initially has\na\ni\nliters of water and has a wizard with power\nb\ni\nin front of it. Furthermore, for each\n1≤i≤n−1\n, there is a valve connecting water tower\ni\nto\ni+1\nwith capacity\nc\ni\n.\nFor each\ni\nfrom\n1\nto\nn\nin this order, the following happens:\nThe wizard in front of water tower\ni\nremoves at most\nb\ni\nliters of water from the tower and turns the removed water into wine.\nIf\ni≠n\n, at most\nc\ni\nliters of the remaining water left in water tower\ni\nflows through the valve into water tower\ni+1\n.\nThere are\nq\nupdates. In each update, you will be given integers\np\n,\nx\n,\ny\nand\nz\nand you will update\na\np\n:=x\n,\nb\np\n:=y\nand\nc\np\n:=z\n. After each update, find the value of\nW(a,b,c)\n. Note that previous updates to arrays\na\n,\nb\nand\nc\npersist throughout future updates.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n2≤n≤5⋅\n10\n5\n,\n1≤q≤5⋅\n10\n5\n) — the number of water towers and the number of updates.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤\n10\n9\n) — the number of liters of water in water tower\ni\n.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n0≤\nb\ni\n≤\n10\n9\n) — the power of the wizard in front of water tower\ni\n.\nThe fourth line contains\nn−1\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn−1\n(\nc\ni\n=\n10\n18\n) — the capacity of the pipe connecting water tower\ni\nto\ni+1\n.\nEach of the next\nq\nlines contains four integers\np\n,\nx\n,\ny\nand\nz\n(\n1≤p≤n\n,\n0≤x,y≤\n10\n9\n,\nz=\n10\n18\n) — the updates done to arrays\na\n,\nb\nand\nc\n.\nNote that\nc\nn\ndoes not exist, so the value of\nz\ndoes not matter when\np=n\n.\nOutput\nPrint\nq\nlines, each line containing a single integer representing\nW(a,b,c)\nafter each update.\nExamples\ninput\nCopy\n4 3\n3 3 3 3\n1 4 2 8\n1000000000000000000 1000000000000000000 1000000000000000000\n4 3 8 1000000000000000000\n2 5 1 1000000000000000000\n3 0 0 1000000000000000000\noutput\nCopy\n12\n12\n10\ninput\nCopy\n5 5\n10 3 8 9 2\n3 4 10 8 1\n1000000000000000000 1000000000000000000 1000000000000000000 1000000000000000000\n5 4 9 1000000000000000000\n1 1 1 1000000000000000000\n2 7 4 1000000000000000000\n4 1 1 1000000000000000000\n1 8 3 1000000000000000000\noutput\nCopy\n34\n25\n29\n21\n27\nNote\nThe first update does not make any modifications to the arrays.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n5\nliters of water in tower 2 and\n4\nliters of water is turned into wine. The remaining\n1\nliter of water flows into tower 3.\nWhen\ni=3\n, there are\n4\nliters of water in tower 3 and\n2\nliters of water is turned into wine. The remaining\n2\nliters of water flows into tower 4.\nWhen\ni=4\n, there are\n5\nliters of water in tower 4. All\n5\nliters of water are turned into wine.\nHence,\nW(a,b,c)=1+4+2+5=12\nafter the first update.\nThe second update modifies the arrays to\na=[3,5,3,3]\n,\nb=[1,1,2,8]\n, and\nc=[\n10\n18\n,\n10\n18\n,\n10\n18\n]\n.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n7\nliters of water in tower 2 and\n1\nliter of water is turned into wine. The remaining\n6\nliters of water flow into tower 3.\nWhen\ni=3\n, there are\n9\nliters of water in tower 3 and\n2\nliters of water is turned into wine. The remaining\n7\nliters of water flow into tower 4.\nWhen\ni=4\n, there are\n10\nliters of water in tower 4. Only\n8\nliters of water is turned into wine.\nHence,\nW(a,b,c)=1+1+2+8=12\nafter the second update.\nThe third update modifies the arrays to\na=[3,5,0,3]\n,\nb=[1,1,0,8]\n, and\nc=[\n10\n18\n,\n10\n18\n,\n10\n18\n]\n.\nWhen\ni=1\n, there are\n3\nliters of water in tower 1 and\n1\nliter of water is turned into wine. The remaining\n2\nliters of water flow into tower 2.\nWhen\ni=2\n, there are\n7\nliters of water in tower 2 and\n1\nliter of water is turned into wine. The remaining\n6\nliters of water flow into tower 3.\nWhen\ni=3\n, there are\n6\nliters of water in tower 3 and\n0\nliters of water is turned into wine. The remaining\n6\nliters of water flow into tower 4.\nWhen\ni=4\n, there are\n9\nliters of water in tower 4. Only\n8\nliters of water is turned into wine.\nHence,\nW(a,b,c)=1+1+0+8=10\nafter the third update.",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*2300"
        ]
    },
    {
        "title": "E. Counting Prefixes",
        "description": "There is a hidden array\na\nof size\nn\nconsisting of only\n1\nand\n−1\n. Let\np\nbe the prefix sums of array\na\n. More formally,\np\nis an array of length\nn\ndefined as\np\ni\n=\na\n1\n+\na\n2\n+…+\na\ni\n. Afterwards, array\np\nis sorted in non-decreasing order. For example, if\na=[1,−1,−1,1,1]\n, then\np=[1,0,−1,0,1]\nbefore sorting and\np=[−1,0,0,1,1]\nafter sorting.\nYou are given the prefix sum array\np\nafter sorting, but you do not know what array\na\nis. Your task is to count the number of initial arrays\na\nsuch that the above process results in the given sorted prefix sum array\np\n. As this number can be large, you are only required to find it modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5000\n) — the size of the hidden array\na\n.\nThe second line of each test case contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n|\np\ni\n|≤n\n) — the\nn\nprefix sums of\na\nsorted in non-decreasing order.\nIt is guaranteed that\np\n1\n≤\np\n2\n≤…≤\np\nn\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n5000\n.\nOutput\nFor each test case, output the answer modulo\n998244353\n.\nExample\ninput\nCopy\n5\n1\n0\n1\n1\n3\n-1 1 2\n5\n-1 0 0 1 1\n5\n-4 -3 -3 -2 -1\noutput\nCopy\n0\n1\n0\n3\n1\nNote\nIn the first two test cases, the only possible arrays\na\nfor\nn=1\nare\na=[1]\nand\na=[−1]\n. Their respective sorted prefix sum arrays\np\nare\np=[1]\nand\np=[−1]\n. Hence, there is no array\na\nthat can result in the sorted prefix sum array\np=[0]\nand there is exactly\n1\narray\na\nthat can result in the sorted prefix sum array\np=[1]\n.\nIn the third test case, it can be proven that there is no array\na\nthat could result in the sorted prefix sum array\np=[−1,1,2]\n.\nIn the fourth test case, the\n3\npossible arrays\na\nthat could result in the sorted prefix sum array\np=[−1,0,0,1,1]\nare:\na=[1,−1,1,−1,−1]\n. The prefix sum array before sorting is\np=[1,0,1,0,−1]\n, which after sorting gives\np=[−1,0,0,1,1]\n.\na=[1,−1,−1,1,1]\n. The prefix sum array before sorting is\np=[1,0,−1,0,1]\n, which after sorting gives\np=[−1,0,0,1,1]\n.\na=[−1,1,1,−1,1]\n. The prefix sum array before sorting is\np=[−1,0,1,0,1]\n, which after sorting gives\np=[−1,0,0,1,1]\n.\nFor the fifth test case, the only possible array\na\nthat could result in the sorted prefix sum array\np=[−4,−3,−3,−2,−1]\nis\na=[−1,−1,−1,−1,1]\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "dp",
            "implementation",
            "math",
            "*2600"
        ]
    },
    {
        "title": "D. 01 Tree",
        "description": "There is an edge-weighted complete binary tree with\nn\nleaves. A complete binary tree is defined as a tree where every non-leaf vertex has exactly 2 children. For each non-leaf vertex, we label one of its children as the left child and the other as the right child.\nThe binary tree has a very strange property. For every non-leaf vertex, one of the edges to its children has weight\n0\nwhile the other edge has weight\n1\n. Note that the edge with weight\n0\ncan be connected to either its left or right child.\nYou forgot what the tree looks like, but luckily, you still remember some information about the leaves in the form of an array\na\nof size\nn\n. For each\ni\nfrom\n1\nto\nn\n,\na\ni\nrepresents the distance\n†\n†\nfrom the root to the\ni\n-th leaf in dfs order\n‡\n‡\n. Determine whether there exists a complete binary tree which satisfies array\na\n. Note that you do not need to reconstruct the tree.\n†\n†\nThe distance from vertex\nu\nto vertex\nv\nis defined as the sum of weights of the edges on the path from vertex\nu\nto vertex\nv\n.\n‡\n‡\nThe dfs order of the leaves is found by calling the following\ndfs\nfunction on the root of the binary tree.\n\ndfs_order = []\n\nfunction dfs(v):\n    if v is leaf:\n        append v to the back of dfs_order\n    else:\n        dfs(left child of v)\n        dfs(right child of v)\n\ndfs(root)\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the size of array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n−1\n) — the distance from the root to the\ni\n-th leaf.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print \"YES\" if there exists a complete binary tree which satisfies array\na\nand \"NO\" otherwise.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).\nExample\ninput\nCopy\n2\n5\n2 1 0 1 1\n5\n1 0 2 1 3\noutput\nCopy\nYES\nNO\nNote\nIn the first test case, the following tree satisfies the array.\nIn the second test case, it can be proven that there is no complete binary tree that satisfies the array.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dsu",
            "greedy",
            "sortings",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "C. Grouping Increases",
        "description": "You are given an array\na\nof size\nn\n. You will do the following process to calculate your penalty:\nSplit array\na\ninto two (possibly empty) subsequences\n†\n†\ns\nand\nt\nsuch that every element of\na\nis either in\ns\nor\nt\n‡\n.\nFor an array\nb\nof size\nm\n, define the penalty\np(b)\nof an array\nb\nas the number of indices\ni\nbetween\n1\nand\nm−1\nwhere\nb\ni\n<\nb\ni+1\n.\nThe total penalty you will receive is\np(s)+p(t)\n.\nIf you perform the above process optimally, find the minimum possible penalty you will receive.\n†\n†\nA sequence\nx\nis a subsequence of a sequence\ny\nif\nx\ncan be obtained from\ny\nby the deletion of several (possibly, zero or all) elements.\n‡\n‡\nSome valid ways to split array\na=[3,1,4,1,5]\ninto\n(s,t)\nare\n([3,4,1,5],[1])\n,\n([1,1],[3,4,5])\nand\n([],[3,1,4,1,5])\nwhile some invalid ways to split\na\nare\n([3,4,5],[1])\n,\n([3,1,4,1],[1,5])\nand\n([1,3,4],[5,1])\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of the array\na\n.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the elements of the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer representing the minimum possible penalty you will receive.\nExample\ninput\nCopy\n5\n5\n1 2 3 4 5\n8\n8 2 3 1 1 7 4 3\n5\n3 3 3 3 3\n1\n1\n2\n2 1\noutput\nCopy\n3\n1\n0\n0\n0\nNote\nIn the first test case, a possible way to split\na\nis\ns=[2,4,5]\nand\nt=[1,3]\n. The penalty is\np(s)+p(t)=2+1=3\n.\nIn the second test case, a possible way to split\na\nis\ns=[8,3,1]\nand\nt=[2,1,7,4,3]\n. The penalty is\np(s)+p(t)=0+1=1\n.\nIn the third test case, a possible way to split\na\nis\ns=[]\nand\nt=[3,3,3,3,3]\n. The penalty is\np(s)+p(t)=0+0=0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "greedy",
            "*1400"
        ]
    },
    {
        "title": "B. Plus-Minus Split",
        "description": "You are given a string\ns\nof length\nn\nconsisting of characters \"+\" and \"-\".\ns\nrepresents an array\na\nof length\nn\ndefined by\na\ni\n=1\nif\ns\ni\n=\n\"+\" and\na\ni\n=−1\nif\ns\ni\n=\n\"-\".\nYou will do the following process to calculate your penalty:\nSplit\na\ninto non-empty arrays\nb\n1\n,\nb\n2\n,…,\nb\nk\nsuch that\nb\n1\n+\nb\n2\n+…+\nb\nk\n=\na\n†\n, where\n+\ndenotes array concatenation.\nThe penalty of a single array is the absolute value of its sum multiplied by its length. In other words, for some array\nc\nof length\nm\n, its penalty is calculated as\np(c)=|\nc\n1\n+\nc\n2\n+…+\nc\nm\n|⋅m\n.\nThe total penalty that you will receive is\np(\nb\n1\n)+p(\nb\n2\n)+…+p(\nb\nk\n)\n.\nIf you perform the above process optimally, find the minimum possible penalty you will receive.\n†\n†\nSome valid ways to split\na=[3,1,4,1,5]\ninto\n(\nb\n1\n,\nb\n2\n,…,\nb\nk\n)\nare\n([3],[1],[4],[1],[5])\n,\n([3,1],[4,1,5])\nand\n([3,1,4,1,5])\nwhile some invalid ways to split\na\nare\n([3,1],[1,5])\n,\n([3],[],[1,4],[1,5])\nand\n([3,4],[5,1,1])\n.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤5000\n) — the length of string\ns\n.\nThe second line of each test case contains string\ns\n(\ns\ni\n∈{+,−}\n,\n|s|=n\n).\nNote that there are no constraints on the sum of\nn\nover all test cases.\nOutput\nFor each test case, output a single integer representing the minimum possible penalty you will receive.\nExample\ninput\nCopy\n5\n1\n+\n5\n-----\n6\n+-+-+-\n10\n--+++++++-\n20\n+---++++-+++++---++-\noutput\nCopy\n1\n5\n0\n4\n4\nNote\nIn the first test case, we have\na=[1]\n. We can split array\na\ninto\n([1])\n. Then, the sum of penalties of the subarrays is\np([1])=1\n.\nIn the second test case, we have\na=[−1,−1,−1,−1,−1]\n. We can split array\na\ninto\n([−1],[−1],[−1],[−1],[−1])\n. Then, the sum of penalties of the subarrays is\np([−1])+p([−1])+p([−1])+p([−1])+p([−1])=1+1+1+1+1=5\n.\nIn the third test case, we have\na=[1,−1,1,−1,1,−1]\n. We can split array\na\ninto\n([1,−1,1,−1],[1,−1])\n. Then, the sum of penalties of the subarrays is\np([1,−1,1,−1])+p([1,−1])=0+0=0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "*800"
        ]
    },
    {
        "title": "A. Wallet Exchange",
        "description": "Alice and Bob are bored, so they decide to play a game with their wallets. Alice has\na\ncoins in her wallet, while Bob has\nb\ncoins in his wallet.\nBoth players take turns playing, with Alice making the first move. In each turn, the player will perform the following steps in order:\nChoose to exchange wallets with their opponent, or to keep their current wallets.\nRemove\n1\ncoin from the player's current wallet. The current wallet cannot have\n0\ncoins before performing this step.\nThe player who cannot make a valid move on their turn loses. If both Alice and Bob play optimally, determine who will win the game.\nInput\nEach test contains multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. The description of the test cases follows.\nThe first and only line of each test case contains two integers\na\nand\nb\n(\n1≤a,b≤\n10\n9\n) — the number of coins in Alice's and Bob's wallets, respectively.\nOutput\nFor each test case, output \"Alice\" if Alice will win the game, and \"Bob\" if Bob will win the game.\nExample\ninput\nCopy\n10\n1 1\n1 4\n5 3\n4 5\n11 9\n83 91\n1032 9307\n839204 7281\n1000000000 1000000000\n53110 2024\noutput\nCopy\nBob\nAlice\nBob\nAlice\nBob\nBob\nAlice\nAlice\nBob\nBob\nNote\nIn the first test case, an example of the game is shown below:\nAlice chooses to not swap wallets with Bob in step 1 of her move. Now,\na=0\nand\nb=1\n.\nSince Alice's wallet is empty, Bob must choose to not swap their wallets in step 1 of his move. Now,\na=0\nand\nb=0\n.\nSince both Alice's and Bob's wallets are empty, Alice is unable to make a move. Hence, Bob wins.\nIn the second test case, an example of the game is shown below:\nAlice chooses to swap wallets with Bob in step 1 of her move. Now,\na=3\nand\nb=1\n.\nBob chooses to swap wallets with Alice in step 1 of his move. Now,\na=1\nand\nb=2\n.\nAlice chooses to not swap wallets with Bob in step 1 of her move. Now,\na=0\nand\nb=2\n.\nSince Alice's wallet is empty, Bob can only choose to not swap wallets with Alice in step 1 of his move. Now,\na=0\nand\nb=1\n.\nSince Alice's wallet is empty, Alice can only choose to swap wallets with Bob in step 1 of her move. Now,\na=0\nand\nb=0\n.\nSince both Alice's wallet and Bob's wallet are empty, Bob is unable to make a move. Hence, Alice wins.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Permutation of Given",
        "description": "You were given only one number,\nn\n. It didn't seem interesting to you, so you wondered if it's possible to come up with an array of length\nn\nconsisting of non-zero integers, such that if each element of the array is replaced by the sum of its neighbors (the elements on the ends are replaced by their only neighbors), you obtain a permutation of the numbers in the original array.\nInput\nEach test case contains only one number,\nn\n(\n2≤n≤\n10\n6\n).\nOutput\nIf a solution exists, output \"YES\" (without quotes), followed by an array\na\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n,\na\ni\n≠0\n) that satisfies the condition of the problem. If there are multiple possible answers, output any of them.\nIf there is no suitable array, output \"NO\" (without quotes).\nThe words \"YES\" and \"NO\" can be output in any case, for example, \"YES\", \"Yes\", \"yEs\", and so on.\nExamples\ninput\nCopy\n4\noutput\nCopy\nYES\n1 2 -2 -1\ninput\nCopy\n5\noutput\nCopy\nNO\nNote\nIn the first test, the array [\n1,2,−2,−1\n] is suitable, because if each element is replaced by the sum of its neighbors, the resulting array is [\n2,−1,1,−2\n], which is a permutation of the original array.\nIn the second test, it can be shown that there is no solution.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*2700"
        ]
    },
    {
        "title": "F. Caterpillar on a Tree",
        "description": "The caterpillar decided to visit every node of the tree. Initially, it is sitting at the root.\nThe tree is represented as a rooted tree with the root at the node\n1\n. Each crawl to a neighboring node takes\n1\nminute for the caterpillar.\nAnd there is a trampoline under the tree. If the caterpillar detaches from the tree and falls onto the trampoline, it will end up at the root of the tree in\n0\nseconds. But the trampoline is old and can withstand no more than\nk\ncaterpillar's falls.\nWhat is the minimum time the caterpillar can take to visit all the nodes of the tree?\nMore formally, we need to find the minimum time required to visit all the nodes of the tree, if the caterpillar starts at the root (node\n1\n) and moves using two methods.\nCrawl along an edge to one of the neighboring nodes: takes\n1\nminute.\nTeleport to the root: takes no time, no new nodes become visited.\nThe second method (teleportation) can be used at most\nk\ntimes. The caterpillar can finish the journey at any node.\nInput\nThe first line of the input contains two integers:\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of nodes in the tree, and\nk\n(\n0≤k≤\n10\n9\n) — the maximum number of teleports to the root.\nThe second line contains\nn−1\nintegers\np\n2\n,\np\n3\n, ...,\np\nn\n(\n1≤\np\ni\n≤n\n) — the ancestors in the tree for nodes\n2,3,…,n\n; node\n1\nis the root.\nOutput\nPrint a single number in a single line — the minimum number of minutes required to visit all the nodes of the tree.\nExamples\ninput\nCopy\n8 1\n1 1 2 2 4 3 3\noutput\nCopy\n9\ninput\nCopy\n4 0\n4 4 1\noutput\nCopy\n4\nNote\nThe figure shows one of the ways to traverse the tree from the first test in 9 minutes.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "graphs",
            "greedy",
            "implementation",
            "sortings",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E. ace5 and Task Order",
        "description": "This is an interactive problem!\nIn the new round, there were\nn\ntasks with difficulties from\n1\nto\nn\n. The coordinator, who decided to have the first round with tasks in unsorted order of difficulty, rearranged the tasks, resulting in a permutation of difficulties from\n1\nto\nn\n. After that, the coordinator challenged ace5 to guess the permutation in the following way.\nInitially, the coordinator chooses a number\nx\nfrom\n1\nto\nn\n.\nace5 can make queries of the form:\n? i\n. The answer will be:\n>\n, if\na\ni\n>x\n, after which\nx\nincreases by\n1\n.\n<\n, if\na\ni\n<x\n, after which\nx\ndecreases by\n1\n.\n=\n, if\na\ni\n=x\n, after which\nx\nremains unchanged.\nThe task for ace5 is to guess the permutation in no more than\n40n\nqueries. Since ace5 is too busy writing the announcement, he has entrusted this task to you.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nInteraction\nThe interaction between your program and the jury's program begins with reading a positive integer\nn\n(\n1≤n≤2000\n) — the length of the hidden permutation.\nTo make a query, output a line in the format \"? i\", where\n1≤i≤n\n.\nAs an answer, you will receive:\n\">\", if\na\ni\n>\nx\n, after which\nx\nwill increase by\n1\n.\n\"<\", if\na\ni\n<\nx\n, after which\nx\nwill decrease by\n1\n.\n\"=\", if\na\ni\n=\nx\n, after which\nx\nwill remain unchanged.\nYou can make no more than\n40n\nqueries. To output the answer, you need to print \"! a_1 a_2 ... a_n\", where\n1≤\na\ni\n≤n\n, and all of them are distinct. Outputting the answer does not count as a query.\nIf your program makes more than\n40n\nqueries for one test case, or makes an invalid query, then the response to the query will be -1. After receiving such a response, your program should immediately terminate to receive the verdict Wrong Answer. Otherwise, it may receive any other verdict.\nAfter outputting a query, do not forget to print a newline and flush the output buffer. Otherwise, you will receive the verdict Presentation Error. To flush the buffer, use:\nfflush(stdout) or cout.flush() in C++;\nSystem.out.flush() in Java;\nflush(output) in Pascal;\nstdout.flush() in Python;\nsee the documentation for other languages.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nThe interactor in this problem is not adaptive.\nHacks:\nTo make a hack, use the following format:\nThe first line contains a single integer\nt\n— the number of test cases.\nThe description of each test case should consist of two lines. The first line contains the numbers\nn\nand\nx\n(\n1≤x≤n≤2000\n) — the length of the hidden permutation and the initial value of the number\nx\n. The second line contains\nn\ndistinct numbers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — the permutation that the jury should choose in this test case.\nSum of\nn\nover all test cases should not exceed\n2000\n.\nExample\ninput\nCopy\n2\n5\n\n>\n\n=\n\n<\n\n=\n\n<\n\n<\n\n2\n\n>\noutput\nCopy\n? 4\n\n? 2\n\n? 1\n\n? 5\n\n? 1\n\n? 3\n\n! 2 4 1 5 3\n\n? 1\n\n! 2 1 \nNote\nIn the first test, the hidden permutation is\na\n= [\n2,4,1,5,3\n], and the initial value of\nx\nis\n3\n.\nIn the second test, the hidden permutation is\na\n= [\n2,1\n], and the initial value of\nx\nis\n1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "divide and conquer",
            "implementation",
            "interactive",
            "probabilities",
            "sortings",
            "*2200"
        ]
    },
    {
        "title": "D. Blocking Elements",
        "description": "You are given an array of numbers\na\n1\n,\na\n2\n,…,\na\nn\n. Your task is to block some elements of the array in order to minimize its cost. Suppose you block the elements with indices\n1≤\nb\n1\n<\nb\n2\n<…<\nb\nm\n≤n\n. Then the cost of the array is calculated as the maximum of:\nthe sum of the blocked elements, i.e.,\na\nb\n1\n+\na\nb\n2\n+…+\na\nb\nm\n.\nthe maximum sum of the segments into which the array is divided when the blocked elements are removed. That is, the maximum sum of the following (\nm+1\n) subarrays: [\n1,\nb\n1\n−1\n], [\nb\n1\n+1,\nb\n2\n−1\n], [\n…\n], [\nb\nm−1\n+1,\nb\nm\n−1\n], [\nb\nm\n+1,n\n] (the sum of numbers in a subarray of the form [\nx,x−1\n] is considered to be\n0\n).\nFor example, if\nn=6\n, the original array is [\n1,4,5,3,3,2\n], and you block the elements at positions\n2\nand\n5\n, then the cost of the array will be the maximum of the sum of the blocked elements (\n4+3=7\n) and the sums of the subarrays (\n1\n,\n5+3=8\n,\n2\n), which is\nmax(7,1,8,2)=8\n.\nYou need to output the minimum cost of the array after blocking.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤30000\n) — the number of queries.\nEach test case consists of two lines. The first line contains an integer\nn\n(\n1≤n≤\n10\n5\n) — the length of the array\na\n. The second line contains\nn\nelements\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the array\na\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single number — the minimum cost of blocking the array.\nExample\ninput\nCopy\n3\n6\n1 4 5 3 3 2\n5\n1 2 3 4 5\n6\n4 1 6 3 10 7\noutput\nCopy\n7\n5\n11\nNote\nThe first test case matches with the array from the statement. To obtain a cost of\n7\n, you need to block the elements at positions\n2\nand\n4\n. In this case, the cost of the array is calculated as the maximum of:\nthe sum of the blocked elements, which is\na\n2\n+\na\n4\n=7\n.\nthe maximum sum of the segments into which the array is divided when the blocked elements are removed, i.e., the maximum of\na\n1\n,\na\n3\n,\na\n5\n+\na\n6\n=max(1,5,5)=5\n.\nSo the cost is\nmax(7,5)=7\n.\nIn the second test case, you can block the elements at positions\n1\nand\n4\n.\nIn the third test case, to obtain the answer\n11\n, you can block the elements at positions\n2\nand\n5\n. There are other ways to get this answer, for example, blocking positions\n4\nand\n6\n.",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "implementation",
            "two pointers",
            "*1900"
        ]
    },
    {
        "title": "C. XOR-distance",
        "description": "You are given integers\na\n,\nb\n,\nr\n. Find the smallest value of\n|(a⊕x)−(b⊕x)|\namong all\n0≤x≤r\n.\n⊕\nis the operation of bitwise XOR, and\n|y|\nis absolute value of\ny\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤104\n) — the number of test cases.\nEach test case contains integers\na\n,\nb\n,\nr\n(\n0≤a,b,r≤1018\n).\nOutput\nFor each test case, output a single number — the smallest possible value.\nExample\ninput\nCopy\n10\n4 6 0\n0 3 2\n9 6 10\n92 256 23\n165 839 201\n1 14 5\n2 7 2\n96549 34359 13851\n853686404475946 283666553522252166 127929199446003072\n735268590557942972 916721749674600979 895150420120690183\noutput\nCopy\n2\n1\n1\n164\n542\n5\n3\n37102\n27934920819538516\n104449824168870225\nNote\nIn the first test, when\nr=0\n, then\nx\nis definitely equal to\n0\n, so the answer is\n|4⊕0−6⊕0|=|4−6|=2\n.\nIn the second test:\nWhen\nx=0\n,\n|0⊕0−3⊕0|=|0−3|=3\n.\nWhen\nx=1\n,\n|0⊕1−3⊕1|=|1−2|=1\n.\nWhen\nx=2\n,\n|0⊕2−3⊕2|=|2−1|=1\n.\nTherefore, the answer is\n1\n.\nIn the third test, the minimum is achieved when\nx=1\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "implementation",
            "math",
            "*1400"
        ]
    },
    {
        "title": "B. Minimize Inversions",
        "description": "You are given two permutations\na\nand\nb\nof length\nn\n. A permutation is an array of\nn\nelements from\n1\nto\nn\nwhere all elements are distinct. For example, an array [\n2,1,3\n] is a permutation, but [\n0,1\n] and [\n1,3,1\n] aren't.\nYou can (as many times as you want) choose two indices\ni\nand\nj\n, then swap\na\ni\nwith\na\nj\nand\nb\ni\nwith\nb\nj\nsimultaneously.\nYou hate inversions, so you want to minimize the total number of inversions in both permutations.\nAn inversion in a permutation\np\nis a pair of indices\n(i,j)\nsuch that\ni<j\nand\np\ni\n>\np\nj\n. For example, if\np=[3,1,4,2,5]\nthen there are\n3\ninversions in it (the pairs of indices are\n(1,2)\n,\n(1,4)\nand\n(3,4)\n).\nInput\nThe first line contains an integer\nt\n(\n1≤t≤20000\n) — the number of test cases.\nEach test case consists of three lines. The first line contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the permutations\na\nand\nb\n. The second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n) — permutation\na\n. The third line contains\nb\nin a similar format.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two permutations\na\n′\nand\nb\n′\n(in the same format as in the input) — the permutations after all operations. The total number of inversions in\na\n′\nand\nb\n′\nshould be the minimum possible among all pairs of permutations that can be obtained using operations from the statement.\nIf there are multiple solutions, print any of them.\nExample\ninput\nCopy\n3\n5\n1 2 3 4 5\n5 4 3 2 1\n3\n3 1 2\n3 1 2\n6\n2 5 6 1 3 4\n1 5 3 6 2 4\noutput\nCopy\n3 2 5 1 4\n3 4 1 5 2\n1 2 3\n1 2 3\n2 3 4 6 5 1\n1 2 4 3 5 6\nNote\nIn the first test case, the minimum possible number of inversions is\n10\n.\nIn the second test case, we can sort both permutations at the same time. For this, the following operations can be done:\nSwap the elements in the positions\n1\nand\n3\nin both permutations. After the operation,\na=\n[\n2,1,3\n],\nb=\n[\n2,1,3\n].\nSwap the elements in the positions\n1\nand\n2\n. After the operations,\na\nand\nb\nare sorted.\nIn the third test case, the minimum possible number of inversions is\n7\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "sortings",
            "*900"
        ]
    },
    {
        "title": "A. Brick Wall",
        "description": "A brick is a strip of size\n1×k\n, placed horizontally or vertically, where\nk\ncan be an arbitrary number that is at least\n2\n(\nk≥2\n).\nA brick wall of size\nn×m\nis such a way to place several bricks inside a rectangle\nn×m\n, that all bricks lie either horizontally or vertically in the cells, do not cross the border of the rectangle, and that each cell of the\nn×m\nrectangle belongs to exactly one brick. Here\nn\nis the height of the rectangle\nn×m\nand\nm\nis the width. Note that there can be bricks with different values of k in the same brick wall.\nThe wall stability is the difference between the number of horizontal bricks and the number of vertical bricks. Note that if you used\n0\nhorizontal bricks and\n2\nvertical ones, then the stability will be\n−2\n, not\n2\n.\nWhat is the maximal possible stability of a wall of size\nn×m\n?\nIt is guaranteed that under restrictions in the statement at least one\nn×m\nwall exists.\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤10000\n), the number of test cases.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n2≤n,m≤\n10\n4\n).\nOutput\nFor each test case, print one integer, the maximum stability of a wall of size\nn×m\n.\nExample\ninput\nCopy\n5\n2 2\n7 8\n16 9\n3 5\n10000 10000\noutput\nCopy\n2\n28\n64\n6\n50000000\nNote\nIn the 1st test case, the maximum stability of\n2\nis obtained by placing two horizontal bricks\n1×2\none on top of the other.\nIn the 2nd test case, one can get the maximum stability of\n28\nby placing\n4\nhorizontal bricks\n1×2\nin each of the\n7\nrows.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Construct Tree",
        "description": "You are given an array of integers\nl\n1\n,\nl\n2\n,…,\nl\nn\nand an integer\nd\n. Is it possible to construct a tree satisfying the following three conditions?\nThe tree contains\nn+1\nnodes.\nThe length of the\ni\n-th edge is equal to\nl\ni\n.\nThe (weighted) diameter of the tree is equal to\nd\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤250\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nd\n(\n2≤n≤2000,1≤d≤2000\n).\nThe second line of each test case contains\nn\nintegers\nl\n1\n,\nl\n2\n,…,\nl\nn\n(\n1≤\nl\ni\n≤d\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output\nYes\nif it is possible to construct a tree that satisfies all the conditions, and\nNo\notherwise.\nYou can print the letters in any case (upper or lower).\nExample\ninput\nCopy\n3\n4 10\n1 2 3 4\n4 7\n1 4 3 4\n6 18\n2 4 3 7 6 7\noutput\nCopy\nYes\nNo\nYes\nNote\nBelow, you are given the illustrations of trees for the first and third test cases. One of the diameters is highlighted by coloring its edges in red.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "trees",
            "*2500"
        ]
    },
    {
        "title": "E. Construct Matrix",
        "description": "You are given an even integer\nn\nand an integer\nk\n. Your task is to construct a matrix of size\nn×n\nconsisting of numbers\n0\nand\n1\nin such a way that the following conditions are true, or report that it is impossible:\nthe sum of all the numbers in the matrix is exactly\nk\n;\nthe bitwise\nXOR\nof all the numbers in the row\ni\nis the same for each\ni\n;\nthe bitwise\nXOR\nof all the numbers in the column\nj\nis the same for each\nj\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤130\n) — the number of test cases. The description of the test cases follows.\nEach test case is described by a single line, which contains two integers\nn\nand\nk\n(\n2≤n≤1000\n,\nn\nis even,\n0≤k≤\nn\n2\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2000\n.\nOutput\nFor each test case, output\nYes\nif it's possible to construct a matrix that satisfies all of the problem's conditions, and\nNo\notherwise.\nIf it is possible to construct a matrix, the\ni\n-th of the next\nn\nlines should contain\nn\nintegers representing the elements in the\ni\n-th row of the matrix.\nExample\ninput\nCopy\n5\n4 0\n6 6\n6 5\n4 2\n6 36\noutput\nCopy\nYes\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\nYes\n1 0 0 0 0 0\n0 1 0 0 0 0\n0 0 1 0 0 0\n0 0 0 1 0 0\n0 0 0 0 1 0\n0 0 0 0 0 1\nNo\nNo\nYes\n1 1 1 1 1 1\n1 1 1 1 1 1\n1 1 1 1 1 1\n1 1 1 1 1 1\n1 1 1 1 1 1\n1 1 1 1 1 1\nNote\nIn the first example, all conditions are satisfied:\nthe sum of all the numbers in the matrix is exactly\n0\n;\nthe bitwise\nXOR\nof all the numbers in the row\ni\nis\n0\nfor each\ni\n;\nthe bitwise\nXOR\nof all the numbers in the column\nj\nis\n0\nfor each\nj\n.\nIn the third example, it can be shown that it's impossible to find a matrix satisfying all the problem's conditions.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*2500"
        ]
    },
    {
        "title": "D. Yet Another Inversions Problem",
        "description": "You are given a permutation\np\n0\n,\np\n1\n,…,\np\nn−1\nof odd integers from\n1\nto\n2n−1\nand a permutation\nq\n0\n,\nq\n1\n,…,\nq\nk−1\nof integers from\n0\nto\nk−1\n.\nAn array\na\n0\n,\na\n1\n,…,\na\nnk−1\nof length\nnk\nis defined as follows:\na\ni⋅k+j\n=\np\ni\n⋅\n2\nq\nj\nfor all\n0≤i<n\nand all\n0≤j<k\nFor example, if\np=[3,5,1]\nand\nq=[0,1]\n, then\na=[3,6,5,10,1,2]\n.\nNote that all arrays in the statement are zero-indexed. Note that each element of the array\na\nis uniquely determined.\nFind the number of inversions in the array\na\n. Since this number can be very large, you should find only its remainder modulo\n998244353\n.\nAn inversion in array\na\nis a pair\n(i,j)\n(\n0≤i<j<nk\n) such that\na\ni\n>\na\nj\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n,k≤2⋅\n10\n5\n) — the lengths of arrays\np\nand\nq\n.\nThe second line of each test case contains\nn\ndistinct integers\np\n0\n,\np\n1\n,…,\np\nn−1\n(\n1≤\np\ni\n≤2n−1\n,\np\ni\nis odd) — the array\np\n.\nThe third line of each test case contains\nk\ndistinct integers\nq\n0\n,\nq\n1\n,…,\nq\nk−1\n(\n0≤\nq\ni\n<k\n) — the array\nq\n.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\nand the sum of\nk\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output one integer: the number of inversions in array\na\nmodulo\n998244353\n.\nExample\ninput\nCopy\n4\n3 2\n3 5 1\n0 1\n3 4\n1 3 5\n3 2 0 1\n1 5\n1\n0 1 2 3 4\n8 3\n5 1 7 11 15 3 9 13\n2 0 1\noutput\nCopy\n9\n25\n0\n104\nNote\nIn the first test case, array\na\nis equal to\n[3,6,5,10,1,2]\n. There are\n9\ninversions in it:\n(0,4)\n,\n(0,5)\n,\n(1,2)\n,\n(1,4)\n,\n(1,5)\n,\n(2,4)\n,\n(2,5)\n,\n(3,4)\n,\n(3,5)\n. Note that these are pairs\n(i,j)\nsuch that\ni<j\nand\na\ni\n>\na\nj\n.\nIn the second test case, array\na\nis equal to\n[8,4,1,2,24,12,3,6,40,20,5,10]\n. There are\n25\ninversions in it.\nIn the third test case, array\na\nis equal to\n[1,2,4,8,16]\n. There are no inversions in it.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "dp",
            "implementation",
            "math",
            "number theory",
            "*2300"
        ]
    },
    {
        "title": "C. Watering an Array",
        "description": "You have an array of integers\na1,a2,…,an\nof length\nn\n. On the\ni\n-th of the next\nd\ndays you are going to do exactly one of the following two actions:\nAdd\n1\nto each of the first\nbi\nelements of the array\na\n(i.e., set\naj:=aj+1\nfor each\n1≤j≤bi\n).\nCount the elements which are equal to their position (i.e., the\naj=j\n). Denote the number of such elements as\nc\n. Then, you add\nc\nto your score, and reset the entire array\na\nto a\n0\n-array of length\nn\n(i.e., set\n[a1,a2,…,an]:=[0,0,…,0]\n).\nYour score is equal to\n0\nin the beginning. Note that on each day you should perform exactly one of the actions above: you cannot skip a day or perform both actions on the same day.\nWhat is the maximum score you can achieve at the end?\nSince\nd\ncan be quite large, the sequence\nb\nis given to you in the compressed format:\nYou are given a sequence of integers\nv1,v2,…,vk\n. The sequence\nb\nis a concatenation of infinitely many copies of\nv\n:\nb=[v1,v2,…,vk,v1,v2,…,vk,…]\n.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤103\n) — the number of test cases.\nThe first line of each test case contains three integers\nn\n,\nk\nand\nd\n(\n1≤n≤2000\n,\n1≤k≤105\n,\nk≤d≤109\n) — the length of the array\na\n, the length of the sequence\nv\nand the number of days you are going to perform operations on.\nThe second line of each test case contains\nn\nintegers\na1,a2,…,an\n(\n0≤ai≤n\n) — the array\na\n.\nThe third line of each test case contains\nk\nintegers\nv1,v2,…,vk\n(\n1≤vi≤n\n) — the sequence\nv\n.\nIt is guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2000\nand the sum of\nk\nover all test cases doesn't exceed\n105\n.\nOutput\nFor each test case, output one integer: the maximum score you can achieve at the end of the\nd\n-th day.\nExample\ninput\nCopy\n5\n3 4 4\n1 2 3\n1 3 2 3\n6 2 3\n6 1 2 4 1 5\n6 6\n5 1 1\n0 5 0 5 0\n5\n1 1 1\n1\n1\n3 4 6\n1 2 3\n1 3 2 3\noutput\nCopy\n4\n3\n0\n1\n5\nNote\nIn the first test case, the sequence\nb\nis equal to\n[1,3,2,3,1,3,2,3,…]\nand one of the optimal solutions for this case is as follows:\nPerform the operation of the second type on the\n1\n-st day: your score increases by\n3\nand array\na\nbecomes equal to\n[0,0,0]\n.\nPerform the operation of the first type on the\n2\n-nd day: array\na\nbecomes equal to\n[1,1,1]\n.\nPerform the operation of the first type on the\n3\n-rd day: array\na\nbecomes equal to\n[2,2,1]\n.\nPerform the operation of the second type on the\n4\n-th day: your score increases by\n1\nand array\na\nbecomes equal to\n[0,0,0]\n.\nIt can be shown that it is impossible to score more than\n4\n, so the answer is\n4\n.\nIn the second test case, the sequence\nb\nis equal to\n[6,6,6,6,…]\n. One of the ways to score\n3\nis to perform operations of the first type on the\n1\n-st and the\n3\n-rd days and to perform an operation of the second type on the\n2\n-nd day.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*1600"
        ]
    },
    {
        "title": "B. Erase First or Second Letter",
        "description": "You are given a string\ns\nof length\nn\n. Let's define two operations you can apply on the string:\nremove the first character of the string;\nremove the second character of the string.\nYour task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains\nn\n(\n1≤n≤\n10\n5\n) — the length of the string.\nThe second line of each test case contains the string\ns\n. It is guaranteed that the string only contains lowercase letters of the English alphabet.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer: the number of distinct non-empty strings you can get.\nExample\ninput\nCopy\n5\n5\naaaaa\n1\nz\n5\nababa\n14\nbcdaaaabcdaaaa\n20\nabcdefghijklmnopqrst\noutput\nCopy\n5\n1\n9\n50\n210\nNote\nIn the first test case, we can get the following strings:\na\n,\naa\n,\naaa\n,\naaaa\n,\naaaaa\n.\nIn the third test case, for example, the word\nba\ncan be reached in the following way:\nremove the first character of the current string\nababa\n, getting\nbaba\n;\nremove the second character of the current string\nbaba\n, getting\nbba\n;\nremove the second character of the current string\nbba\n, getting\nba\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "dp",
            "strings",
            "*1100"
        ]
    },
    {
        "title": "A. Least Product",
        "description": "You are given an array of integers\na\n1\n,\na\n2\n,…,\na\nn\n. You can perform the following operation any number of times (possibly zero):\nChoose any element\na\ni\nfrom the array and change its value to any integer between\n0\nand\na\ni\n(inclusive). More formally, if\na\ni\n<0\n, replace\na\ni\nwith any integer in\n[\na\ni\n,0]\n, otherwise replace\na\ni\nwith any integer in\n[0,\na\ni\n]\n.\nLet\nr\nbe the minimum possible product of all the\na\ni\nafter performing the operation any number of times.\nFind the minimum number of operations required to make the product equal to\nr\n. Also, print one such shortest sequence of operations. If there are multiple answers, you can print any of them.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤500\n) - the number of test cases. This is followed by their description.\nThe first line of each test case contains the a single integer\nn\n(\n1≤n≤100\n) — the length of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nOutput\nFor each test case:\nThe first line must contain the minimum number of operations\nk\n(\n0≤k≤n\n).\nThe\nj\n-th of the next\nk\nlines must contain two integers\ni\nand\nx\n, which represent the\nj\n-th operation. That operation consists in replacing\na\ni\nwith\nx\n.\nExample\ninput\nCopy\n4\n1\n155\n4\n2 8 -1 3\n4\n-1 0 -2 -5\n4\n-15 -75 -25 -30\noutput\nCopy\n1\n1 0\n0\n0\n1\n3 0\nNote\nIn the first test case, we can change the value of the first integer into\n0\nand the product will become\n0\n, which is the minimum possible.\nIn the second test case, initially, the product of integers is equal to\n2⋅8⋅(−1)⋅3=−48\nwhich is the minimum possible, so we should do nothing in this case.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "H2. Matrix Rank (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions of this problem are the constraints on\nk\n. You can make hacks only if all versions of the problem are solved.\nYou are given integers\nn\n,\np\nand\nk\n.\np\nis guaranteed to be a prime number.\nFor each\nr\nfrom\n0\nto\nk\n, find the number of\nn×n\nmatrices\nA\nof the field\n†\n†\nof integers modulo\np\nsuch that the rank\n‡\n‡\nof\nA\nis exactly\nr\n. Since these values are big, you are only required to output them modulo\n998244353\n.\n†\n†\nhttps://en.wikipedia.org/wiki/Field_(mathematics)\n‡\n‡\nhttps://en.wikipedia.org/wiki/Rank_(linear_algebra)\nInput\nThe first line of input contains three integers\nn\n,\np\nand\nk\n(\n1≤n≤\n10\n18\n,\n2≤p<998244353\n,\n0≤k≤5⋅\n10\n5\n).\nIt is guaranteed that\np\nis a prime number.\nOutput\nOutput\nk+1\nintegers, the answers for each\nr\nfrom\n0\nto\nk\n.\nExamples\ninput\nCopy\n3 2 3\noutput\nCopy\n1 49 294 168 \ninput\nCopy\n1 51549919 2\noutput\nCopy\n1 51549918 0 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "matrices",
            "string suffix structures",
            "*2700"
        ]
    },
    {
        "title": "H1. Matrix Rank (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions of this problem are the constraints on\nk\n. You can make hacks only if all versions of the problem are solved.\nYou are given integers\nn\n,\np\nand\nk\n.\np\nis guaranteed to be a prime number.\nFor each\nr\nfrom\n0\nto\nk\n, find the number of\nn×n\nmatrices\nA\nof the field\n†\n†\nof integers modulo\np\nsuch that the rank\n‡\n‡\nof\nA\nis exactly\nr\n. Since these values are big, you are only required to output them modulo\n998244353\n.\n†\n†\nhttps://en.wikipedia.org/wiki/Field_(mathematics)\n‡\n‡\nhttps://en.wikipedia.org/wiki/Rank_(linear_algebra)\nInput\nThe first line of input contains three integers\nn\n,\np\nand\nk\n(\n1≤n≤\n10\n18\n,\n2≤p<998244353\n,\n0≤k≤5000\n).\nIt is guaranteed that\np\nis a prime number.\nOutput\nOutput\nk+1\nintegers, the answers for each\nr\nfrom\n0\nto\nk\n.\nExamples\ninput\nCopy\n3 2 3\noutput\nCopy\n1 49 294 168 \ninput\nCopy\n1 51549919 2\noutput\nCopy\n1 51549918 0 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "math",
            "matrices",
            "*2700"
        ]
    },
    {
        "title": "G. Optimizations From Chelsu",
        "description": "You are given a tree with\nn\nvertices, whose vertices are numbered from\n1\nto\nn\n. Each edge is labeled with some integer\nw\ni\n.\nDefine\nlen(u,v)\nas the number of edges in the simple path between vertices\nu\nand\nv\n, and\ngcd(u,v)\nas the Greatest Common Divisor of all numbers written on the edges of the simple path between vertices\nu\nand\nv\n. For example,\nlen(u,u)=0\nand\ngcd(u,u)=0\nfor any\n1≤u≤n\n.\nYou need to find the maximum value of\nlen(u,v)⋅gcd(u,v)\nover all pairs of vertices in the tree.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. This is followed by their description.\nThe first line of each test case contains the number\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices in the tree.\nThe next\nn−1\nlines specify the edges in the format\nu\n,\nv\n,\nw\n(\n1≤u,v≤n\n,\n1≤w≤\n10\n12\n).\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single number equal to the maximum value of\nlen(u,v)⋅gcd(u,v)\nover all pairs of vertices in the tree.\nExample\ninput\nCopy\n4\n2\n1 2 1000000000000\n4\n3 2 6\n2 1 10\n2 4 6\n8\n1 2 12\n2 3 9\n3 4 9\n4 5 6\n5 6 12\n6 7 4\n7 8 9\n12\n1 2 12\n2 3 12\n2 4 6\n2 5 9\n5 6 6\n1 7 4\n4 8 12\n8 9 4\n8 10 12\n2 11 9\n7 12 9\noutput\nCopy\n1000000000000\n12\n18\n24",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "divide and conquer",
            "dp",
            "number theory",
            "trees",
            "*3500"
        ]
    },
    {
        "title": "F. Group Division",
        "description": "In the\n31\nst lyceum, there were two groups of olympiad participants: computer science and mathematics. The number of computer scientists was\nn\n1\n, and the number of mathematicians was\nn\n2\n. It is not known for certain who belonged to which group, but it is known that there were friendly connections between some pairs of people (these connections could exist between a pair of people from the same group or from different groups).\nThe connections were so strong that even if one person is removed along with all their friendly connections, any pair of people still remains acquainted either directly or through mutual friends.\n†\n†\nMore formally, two people\n(x,y)\nare acquainted in the following case: there are people\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\nn\n1\n+\nn\n2\n) such that the following conditions are simultaneously met:\n∙\nPerson\nx\nis directly acquainted with\na\n1\n.\n∙\nPerson\na\nn\nis directly acquainted with\ny\n.\n∙\nPerson\na\ni\nis directly acquainted with\na\ni+1\nfor any (\n1≤i≤n−1\n).\nThe teachers were dissatisfied with the fact that computer scientists were friends with mathematicians and vice versa, so they decided to divide the students into two groups in such a way that the following two conditions are met:\n∙\nThere were\nn\n1\npeople in the computer science group, and\nn\n2\npeople in the mathematics group.\n∙\nAny pair of computer scientists should be acquainted (acquaintance involving mutual friends, who must be from the same group as the people in the pair, is allowed), the same should be true for mathematicians.\nHelp them solve this problem and find out who belongs to which group.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤1000\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains three integers\nn\n1\n,\nn\n2\n, and\nm\n(\n1≤\nn\n1\n,\nn\n2\n≤2000\n,\n1≤m≤5000\n).\nn\n1\n,\nn\n2\nare the sizes of the two groups described in the problem, and\nm\nis the number of friendly connections initially.\nThe following\nm\nlines describe the friendly connections: in the\ni\n-th (\n1≤i≤m\n) line, a pair of numbers\n(a,b)\nis given, which means that the person with number\na\nis friends with the person with number\nb\n(and vice versa).\nIt is guaranteed that for each test case, all friendly connections are distinct.\nIt is guaranteed that the sum of\nn\n1\n+\nn\n2\nfor all test cases does not exceed\n2000\n, and the sum of\nm\nfor all test cases does not exceed\n5000\n.\nIt is also guaranteed that for each test case, a solution exists.\nIf there are several answers, print any of them.\nOutput\nFor each test case, output two lines.\nIn the first line, output\nn\n1\ndistinct numbers\na\ni\n(\n1≤\na\ni\n≤\nn\n1\n+\nn\n2\n) — the people belonging to the first group.\nIn the second line, output\nn\n2\ndistinct numbers\nb\ni\n(\n1≤\nb\ni\n≤\nn\n1\n+\nn\n2\n) — the people belonging to the second group.\nAll numbers must be distinct.\nIf there are several possible answers, print any one.\nExample\ninput\nCopy\n3\n1 2 3\n2 3\n1 3\n1 2\n1 4 7\n2 5\n3 4\n2 4\n1 2\n3 5\n4 5\n1 5\n3 3 7\n1 2\n1 6\n2 3\n2 5\n3 4\n4 5\n4 6\noutput\nCopy\n3 \n1 2 \n5 \n1 2 3 4 \n4 5 6 \n1 2 3 \nNote\nConsider the third test case. The division into groups looks as follows:\nThe students selected as computer scientists are colored in green, and those selected as mathematicians are colored in blue.\nConsider all pairs of computer scientists and how they are acquainted:\nPairs\n(4,5),(4,6)\nare directly acquainted.\nPair\n(5,6)\nis acquainted through the computer scientist with number\n4\n.\nConsider all pairs of mathematicians and how they are acquainted:\nPairs\n(1,2),(2,3)\nare directly acquainted.\nPair\n(1,3)\nis acquainted through the mathematician with number\n2\n.\nWe conclude that any pair of people belonging to the same group is acquainted with each other, thus the division into two groups is correct.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "greedy",
            "*2900"
        ]
    },
    {
        "title": "E. Happy Life in University",
        "description": "Egor and his friend Arseniy are finishing school this year and will soon enter university. And since they are very responsible guys, they have started preparing for admission already.\nFirst of all, they decided to take care of where they will live for the long four years of study, and after visiting the university's website, they found out that the university dormitory can be represented as a root tree with\nn\nvertices with the root at vertex\n1\n. In the tree, each vertex represents a recreation with some type of activity\na\ni\n. The friends need to choose\n2\nrecreations (not necessarily different) in which they will settle. The guys are convinced that the more the value of the following function\nf(u,v)=diff(u,lca(u,v))⋅diff(v,lca(u,v))\n, the more fun their life will be. Help Egor and Arseniy and find the maximum value of\nf(u,v)\namong all pairs of recreations!\n†\ndiff(u,v)\n†\n — the number of different activities listed on the simple path from vertex\nu\nto vertex\nv\n.\n†\nlca(u,v)\n†\n — a vertex\np\nsuch that it is at the maximum distance from the root and is a parent of both vertex\nu\nand vertex\nv\n.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤3⋅\n10\n5\n).\nThe second line of each test case contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n≤i−1\n), where\np\ni\n — the parent of vertex\ni\n.\nThe third line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤n\n), where\na\ni\n — the number of the activity located at vertex\ni\n.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, output the maximum value of\nf(u,v)\nfor all pairs of recreations\n(u,v)\n.\nExample\ninput\nCopy\n4\n2\n1\n1 2\n7\n1 1 2 2 3 3\n6 5 2 3 6 5 6\n13\n1 1 1 2 2 2 3 3 4 5 6 6\n2 2 2 1 4 9 7 2 5 2 1 11 2\n12\n1 1 1 2 2 3 4 4 7 7 6\n11 2 1 11 12 8 5 8 8 5 11 7\noutput\nCopy\n2\n9\n9\n12\nNote\nConsider the fourth test case. The tree has the following structure:\nAll recreations are colored. The same colors mean that the activities in the recreations match. Consider the pair of vertices\n(11,12)\n,\nlca(11,12)=1\n. Write down all activities on the path from\n11\nto\n1\n —\n[11,5,1,11]\n, among them there are\n3\ndifferent activities, so\ndiff(11,1)=3\n. Also write down all activities on the path from\n12\nto\n1\n —\n[7,8,2,11]\n, among them there are\n4\ndifferent activities, so\ndiff(12,1)=4\n. We get that\nf(11,12)=diff(12,1)⋅diff(11,1)=4⋅3=12\n, which is the answer for this tree. It can be shown that a better answer is impossible to obtain.",
        "time_limit": "1 second",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "greedy",
            "trees",
            "*2300"
        ]
    },
    {
        "title": "D. Mathematical Problem",
        "description": "The mathematicians of the 31st lyceum were given the following task:\nYou are given an odd number\nn\n, and you need to find\nn\ndifferent numbers that are squares of integers. But it's not that simple. Each number should have a length of\nn\n(and should not have leading zeros), and the multiset of digits of all the numbers should be the same. For example, for\n234\nand\n432\n, and\n11223\nand\n32211\n, the multisets of digits are the same, but for\n123\nand\n112233\n, they are not.\nThe mathematicians couldn't solve this problem. Can you?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases.\nThe following\nt\nlines contain one odd integer\nn\n(\n1≤n≤99\n) — the number of numbers to be found and their length.\nIt is guaranteed that the solution exists within the given constraints.\nIt is guaranteed that the sum of\nn\n2\ndoes not exceed\n10\n5\n.\nThe numbers can be output in any order.\nOutput\nFor each test case, you need to output\nn\nnumbers of length\nn\n — the answer to the problem.\nIf there are several answers, print any of them.\nExample\ninput\nCopy\n3\n1\n3\n5\noutput\nCopy\n1\n169\n196\n961\n16384\n31684\n36481\n38416\n43681\nNote\nBelow are the squares of the numbers that are the answers for the second test case:\n169\n=\n13\n2\n196\n=\n14\n2\n961\n=\n31\n2\nBelow are the squares of the numbers that are the answers for the third test case:\n16384\n=\n128\n2\n31684\n=\n178\n2\n36481\n=\n191\n2\n38416\n=\n196\n2\n43681\n=\n209\n2",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "geometry",
            "math",
            "*1700"
        ]
    },
    {
        "title": "C. Training Before the Olympiad",
        "description": "Masha and Olya have an important team olympiad coming up soon. In honor of this, Masha, for warm-up, suggested playing a game with Olya:\nThere is an array\na\nof size\nn\n. Masha goes first, and the players take turns. Each move is described by the following sequence of actions:\n∙\nIf the size of the array is\n1\n, the game ends.\n∙\nThe player who is currently playing chooses two different indices\ni\n,\nj\n(\n1≤i,j≤|a|\n), and performs the following operation — removes\na\ni\nand\na\nj\nfrom the array and adds to the array a number equal to\n⌊\na\ni\n+\na\nj\n2\n⌋⋅2\n. In other words, first divides the sum of the numbers\na\ni\n,\na\nj\nby\n2\nrounding down, and then multiplies the result by\n2\n.\nMasha aims to maximize the final number, while Olya aims to minimize it.\nMasha and Olya decided to play on each non-empty prefix of the initial array\na\n, and asked for your help.\nFor each\nk=1,2,…,n\n, answer the following question. Let only the first\nk\nelements of the array\na\nbe present in the game, with indices\n1,2,…,k\nrespectively. What number will remain at the end with optimal play by both players?\nInput\nThe first line contains an integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the size of the array.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the array on which Masha and Olya play.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output\nn\nintegers. The\nk\n-th of these numbers should be equal to the number that will remain at the end with optimal play by both players, on the array consisting of the first\nk\nelements of the array\na\n.\nExample\ninput\nCopy\n4\n1\n31\n6\n6 3 7 2 5 4\n3\n3 10 11\n5\n7 13 11 19 1\noutput\nCopy\n31 \n6 8 16 18 22 26 \n3 12 24 \n7 20 30 48 50 \nNote\nIn the third test case, for a prefix of length\n1\n, the answer is\n3\n. For a prefix of length\n2\n, Masha has only one move, so the answer is\n12\n. For a prefix of length\n3\n, Masha has three possible moves: she chooses\n3\nand\n10\n, then the final number is\n22\n,\n3\nand\n11\n, then the final number is\n24\n,\n10\nand\n11\n, then the final number is\n22\n, so Masha will choose\n3\nand\n11\nand get\n24\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ]
    },
    {
        "title": "B. Two Divisors",
        "description": "A certain number\n1≤x≤\n10\n9\nis chosen. You are given two integers\na\nand\nb\n, which are the two largest divisors of the number\nx\n. At the same time, the condition\n1≤a<b<x\nis satisfied.\nFor the given numbers\na\n,\nb\n, you need to find the value of\nx\n.\n†\n†\nThe number\ny\nis a divisor of the number\nx\nif there is an integer\nk\nsuch that\nx=y⋅k\n.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follows the description of the test cases.\nThe only line of each test cases contains two integers\na\n,\nb\n(\n1≤a<b≤\n10\n9\n).\nIt is guaranteed that\na\n,\nb\nare the two largest divisors for some number\n1≤x≤\n10\n9\n.\nOutput\nFor each test case, output the number\nx\n, such that\na\nand\nb\nare the two largest divisors of the number\nx\n.\nIf there are several answers, print any of them.\nExample\ninput\nCopy\n8\n2 3\n1 2\n3 11\n1 5\n5 10\n4 6\n3 9\n250000000 500000000\noutput\nCopy\n6\n4\n33\n25\n20\n12\n27\n1000000000\nNote\nFor the first test case, all divisors less than\n6\nare equal to\n[1,2,3]\n, among them the two largest will be\n2\nand\n3\n.\nFor the third test case, all divisors less than\n33\nare equal to\n[1,3,11]\n, among them the two largest will be\n3\nand\n11\n.\nFor the fifth test case, all divisors less than\n20\nare equal to\n[1,2,4,5,10]\n, among them the two largest will be\n5\nand\n10\n.\nFor the sixth test case, all divisors less than\n12\nare equal to\n[1,2,3,4,6]\n, among them the two largest will be\n4\nand\n6\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ]
    },
    {
        "title": "A. 2023",
        "description": "In a sequence\na\n, whose product was equal to\n2023\n,\nk\nnumbers were removed, leaving a sequence\nb\nof length\nn\n. Given the resulting sequence\nb\n, find any suitable sequence\na\nand output which\nk\nelements were removed from it, or state that such a sequence could not have existed.\nNotice that you are not guaranteed that such array exists.\nInput\nEach test consists of several test cases. The first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains two integers\nn\n(\n1≤n,k≤5\n) — the size of sequence\nb\nand the number of numbers removed from sequence\na\n.\nThe second line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤2023\n) — the remaining sequence. The values of\nb\ni\nmight not be divisors of\n2023\n.\nOutput\nFor each test case, output \"YES\" if the sequence\na\nexists, and in the following line output\nk\nnon-negative integers that were removed from the sequence\na\n. If the sequence\na\ndoes not exist, output \"NO\" in a single line.\nYou can output the answer in any case (uppercase or lowercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive answers.\nExample\ninput\nCopy\n7\n2 2\n5 2\n3 1\n7 17 7\n4 2\n1 289 1 1\n3 1\n7 17 17\n1 1\n289\n1 1\n2023\n1 3\n1\noutput\nCopy\nNO\nNO\nYES\n7 1\nYES\n1\nYES\n7\nYES\n1\nYES\n7 17 17\nNote\nIn third test case product is equal to\n289⋅7=2023\n.\nIn fourth test case product is already equal to\n2023\n.\nIn seventh test case product is equal to\n7⋅17⋅17=2023\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "number theory",
            "*800"
        ]
    },
    {
        "title": "G. Bicycles",
        "description": "All of Slavic's friends are planning to travel from the place where they live to a party using their bikes. And they all have a bike except Slavic. There are\nn\ncities through which they can travel. They all live in the city\n1\nand want to go to the party located in the city\nn\n. The map of cities can be seen as an undirected graph with\nn\nnodes and\nm\nedges. Edge\ni\nconnects cities\nu\ni\nand\nv\ni\nand has a length of\nw\ni\n.\nSlavic doesn't have a bike, but what he has is money. Every city has exactly one bike for sale. The bike in the\ni\n-th city has a slowness factor of\ns\ni\n. Once Slavic buys a bike, he can use it whenever to travel from the city he is currently in to any neighboring city, by taking\nw\ni\n⋅\ns\nj\ntime, considering he is traversing edge\ni\nusing a bike\nj\nhe owns.\nSlavic can buy as many bikes as he wants as money isn't a problem for him. Since Slavic hates traveling by bike, he wants to get from his place to the party in the shortest amount of time possible. And, since his informatics skills are quite rusty, he asks you for help.\nWhat's the shortest amount of time required for Slavic to travel from city\n1\nto city\nn\n? Slavic can't travel without a bike. It is guaranteed that it is possible for Slavic to travel from city\n1\nto any other city.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two space-separated integers\nn\nand\nm\n(\n2≤n≤1000\n;\nn−1≤m≤1000\n) — the number of cities and the number of roads, respectively.\nThe\ni\n-th of the following\nm\nlines each contain three integers\nu\ni\n,\nv\ni\n,\nw\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n;\n1≤\nw\ni\n≤\n10\n5\n), denoting that there is a road between cities\nu\ni\nand\nv\ni\nof length\nw\ni\n. The same pair of cities can be connected by more than one road.\nThe next line contains\nn\nintegers\ns\n1\n,…,\ns\nn\n(\n1≤\ns\ni\n≤1000\n) — the slowness factor of each bike.\nThe sum of\nn\nover all test cases does not exceed\n1000\n, and the sum of\nm\nover all test cases does not exceed\n1000\n.\nAdditional constraint on the input: it is possible to travel from city\n1\nto any other city.\nOutput\nFor each test case, output a single integer denoting the shortest amount of time Slavic can reach city\nn\nstarting from city\n1\n.\nExample\ninput\nCopy\n3\n5 5\n1 2 2\n3 2 1\n2 4 5\n2 5 7\n4 5 1\n5 2 1 3 3\n5 10\n1 2 5\n1 3 5\n1 4 4\n1 5 8\n2 3 6\n2 4 3\n2 5 2\n3 4 1\n3 5 8\n4 5 2\n7 2 8 4 1\n7 10\n3 2 8\n2 1 4\n2 5 7\n2 6 4\n7 1 2\n4 3 5\n6 4 2\n6 7 1\n6 7 4\n4 5 9\n7 6 5 4 3 2 1\noutput\nCopy\n19\n36\n14",
        "time_limit": "4 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "graphs",
            "greedy",
            "implementation",
            "shortest paths",
            "sortings",
            "*1800"
        ]
    },
    {
        "title": "F. Greetings",
        "description": "There are\nn\npeople on the number line; the\ni\n-th person is at point\na\ni\nand wants to go to point\nb\ni\n. For each person,\na\ni\n<\nb\ni\n, and the starting and ending points of all people are distinct. (That is, all of the\n2n\nnumbers\na\n1\n,\na\n2\n,…,\na\nn\n,\nb\n1\n,\nb\n2\n,…,\nb\nn\nare distinct.)\nAll the people will start moving simultaneously at a speed of\n1\nunit per second until they reach their final point\nb\ni\n. When two people meet at the same point, they will greet each other once. How many greetings will there be?\nNote that a person can still greet other people even if they have reached their final point.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of people.\nThen\nn\nlines follow, the\ni\n-th of which contains two integers\na\ni\nand\nb\ni\n(\n−\n10\n9\n≤\na\ni\n<\nb\ni\n≤\n10\n9\n) — the starting and ending positions of each person.\nFor each test case, all of the\n2n\nnumbers\na\n1\n,\na\n2\n,…,\na\nn\n,\nb\n1\n,\nb\n2\n,…,\nb\nn\nare distinct.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer denoting the number of greetings that will happen.\nExample\ninput\nCopy\n5\n2\n2 3\n1 4\n6\n2 6\n3 9\n4 5\n1 8\n7 10\n-2 100\n4\n-10 10\n-5 5\n-12 12\n-13 13\n5\n-4 9\n-2 5\n3 4\n6 7\n8 10\n4\n1 2\n3 4\n5 6\n7 8\noutput\nCopy\n1\n9\n6\n4\n0\nNote\nIn the first test case, the two people will meet at point\n3\nand greet each other.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "sortings",
            "*1500"
        ]
    },
    {
        "title": "E. Romantic Glasses",
        "description": "Iulia has\nn\nglasses arranged in a line. The\ni\n-th glass has\na\ni\nunits of juice in it. Iulia drinks only from odd-numbered glasses, while her date drinks only from even-numbered glasses.\nTo impress her date, Iulia wants to find a contiguous subarray of these glasses such that both Iulia and her date will have the same amount of juice in total if only the glasses in this subarray are considered. Please help her to do that.\nMore formally, find out if there exists two indices\nl\n,\nr\nsuch that\n1≤l≤r≤n\n, and\na\nl\n+\na\nl+2\n+\na\nl+4\n+⋯+\na\nr\n=\na\nl+1\n+\na\nl+3\n+⋯+\na\nr−1\nif\nl\nand\nr\nhave the same parity and\na\nl\n+\na\nl+2\n+\na\nl+4\n+⋯+\na\nr−1\n=\na\nl+1\n+\na\nl+3\n+⋯+\na\nr\notherwise.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the total number of glasses.\nThe second line of each test case contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the amount of juice in each glass.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if there exists a subarray satisfying the condition, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n6\n3\n1 3 2\n6\n1 1 1 1 1 1\n10\n1 6 9 8 55 3 14 2 7 2\n8\n1 2 11 4 1 5 1 2\n6\n2 6 1 5 7 8\n9\n2 5 10 4 4 9 6 7 8\noutput\nCopy\nYES\nYES\nNO\nYES\nNO\nYES\nNote\nIn the first test case, Iulia can pick\nl=1\nand\nr=3\n. Then she drinks\na\n1\n+\na\n3\n=1+2=3\nunits and her date drinks\na\n2\n=3\nunits of juice.\nIn the second test case, Iulia can pick\nl=2\nand\nr=5\n. Then she drinks\na\n3\n+\na\n5\n=1+1=2\nunits and her date drinks\na\n2\n+\na\n4\n=1+1=2\nunits of juice.\nIn the third test case no such contiguous subarray works.\nIn the fourth test case, Iulia can pick\nl=2\nand\nr=8\n. Then she drinks\na\n3\n+\na\n5\n+\na\n7\n=11+1+1=13\nunits and her date drinks\na\n2\n+\na\n4\n+\na\n6\n+\na\n8\n=2+4+5+2=13\nunits of juice.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "*1300"
        ]
    },
    {
        "title": "D. Unnatural Language Processing",
        "description": "Lura was bored and decided to make a simple language using the five letters\na\n,\nb\n,\nc\n,\nd\n,\ne\n. There are two types of letters:\nvowels — the letters\na\nand\ne\n. They are represented by\nV\n.\nconsonants — the letters\nb\n,\nc\n, and\nd\n. They are represented by\nC\n.\nThere are two types of syllables in the language:\nCV\n(consonant followed by vowel) or\nCVC\n(vowel with consonant before and after). For example,\nba\n,\nced\n,\nbab\nare syllables, but\naa\n,\neda\n,\nbaba\nare not.\nA word in the language is a sequence of syllables. Lura has written a word in the language, but she doesn't know how to split it into syllables. Help her break the word into syllables.\nFor example, given the word\nbacedbab\n, it would be split into syllables as\nba.ced.bab\n(the dot\n.\nrepresents a syllable boundary).\nInput\nThe input consists of multiple test cases. The first line contains an integer\nt\n(\n1≤t≤100\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the word.\nThe second line of each test case contains a string consisting of\nn\nlowercase Latin characters  — the word.\nAll words given are valid words in the language; that is, they only use the letters\na\n,\nb\n,\nc\n,\nd\n,\ne\n, and each word is made up of several syllables.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor test case, output a string denoting the word split into syllables by inserting a dot\n.\nbetween every pair of adjacent syllables.\nIf there are multiple possible splittings, output any of them. The input is given in such a way that at least one possible splitting exists.\nExample\ninput\nCopy\n6\n8\nbacedbab\n4\nbaba\n13\ndaddecabeddad\n3\ndac\n6\ndacdac\n22\ndababbabababbabbababba\noutput\nCopy\nba.ced.bab\nba.ba\ndad.de.ca.bed.dad\ndac\ndac.dac\nda.bab.ba.ba.bab.bab.ba.bab.ba",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*900"
        ]
    },
    {
        "title": "C. Can I Square?",
        "description": "Calin has\nn\nbuckets, the\ni\n-th of which contains\na\ni\nwooden squares of side length\n1\n.\nCan Calin build a square using all the given squares?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of buckets.\nThe second line of each test case contains\nn\nintegers\na\n1\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — the number of squares in each bucket.\nThe sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output \"YES\" if Calin can build a square using all of the given\n1×1\nsquares, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nExample\ninput\nCopy\n5\n1\n9\n2\n14 2\n7\n1 2 3 4 5 6 7\n6\n1 3 5 7 9 11\n4\n2 2 2 2\noutput\nCopy\nYES\nYES\nNO\nYES\nNO\nNote\nIn the first test case, Calin can build a\n3×3\nsquare.\nIn the second test case, Calin can build a\n4×4\nsquare.\nIn the third test case, Calin cannot build a square using all the given squares.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "B. Not Quite Latin Square",
        "description": "A Latin square is a\n3×3\ngrid made up of the letters\nA\n,\nB\n, and\nC\nsuch that:\nin each row, the letters\nA\n,\nB\n, and\nC\neach appear once, and\nin each column, the letters\nA\n,\nB\n, and\nC\neach appear once.\nFor example, one possible Latin square is shown below.\n⎡\n⎣\n⎢\nA\nC\nB\nB\nA\nC\nC\nB\nA\n⎤\n⎦\n⎥\n[\n]\nYou are given a Latin square, but one of the letters was replaced with a question mark\n?\n. Find the letter that was replaced.\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤108\n) — the number of testcases.\nEach test case contains three lines, each consisting of three characters, representing the Latin square. Each character is one of\nA\n,\nB\n,\nC\n, or\n?\n.\nEach test case is a Latin square with exactly one of the letters replaced with a question mark\n?\n.\nOutput\nFor each test case, output the letter that was replaced.\nExample\ninput\nCopy\n3\nABC\nC?B\nBCA\nBCA\nCA?\nABC\n?AB\nBCA\nABC\noutput\nCopy\nA\nB\nC\nNote\nThe correct Latin squares for the three test cases are shown below:\n⎡\n⎣\n⎢\nA\nC\nB\nB\nA\nC\nC\nB\nA\n⎤\n⎦\n⎥\n⎡\n⎣\n⎢\nB\nC\nA\nC\nA\nB\nA\nB\nC\n⎤\n⎦\n⎥\n⎡\n⎣\n⎢\nC\nB\nA\nA\nC\nB\nB\nA\nC\n⎤\n⎦\n⎥\n[\n]\n[\n]\n[\n]",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "A. Odd One Out",
        "description": "You are given three digits\na\n,\nb\n,\nc\n. Two of them are equal, but the third one is different from the other two.\nFind the value that occurs exactly once.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤270\n) — the number of test cases.\nThe only line of each test case contains three digits\na\n,\nb\n,\nc\n(\n0≤a\n,\nb\n,\nc≤9\n). Two of the digits are equal, but the third one is different from the other two.\nOutput\nFor each test case, output the value that occurs exactly once.\nExample\ninput\nCopy\n10\n1 2 2\n4 3 4\n5 5 6\n7 8 8\n9 0 9\n3 6 3\n2 8 2\n5 7 7\n7 7 5\n5 7 5\noutput\nCopy\n1\n3\n6\n7\n0\n6\n8\n5\n5\n7",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "implementation",
            "*800"
        ]
    },
    {
        "title": "G2. Light Bulbs (Hard Version)",
        "description": "The easy and hard versions of this problem differ only in the constraints on\nn\n. In the hard version, the sum of values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. Furthermore, there are no additional constraints on the value of\nn\nin a single test case.\nThere are\n2n\nlight bulbs arranged in a row. Each light bulb has a color from\n1\nto\nn\n(exactly two light bulbs for each color).\nInitially, all light bulbs are turned off. You choose a set of light bulbs\nS\nthat you initially turn on. After that, you can perform the following operations in any order any number of times:\nchoose two light bulbs\ni\nand\nj\nof the same color, exactly one of which is on, and turn on the second one;\nchoose three light bulbs\ni,j,k\n, such that both light bulbs\ni\nand\nk\nare on and have the same color, and the light bulb\nj\nis between them (\ni<j<k\n), and turn on the light bulb\nj\n.\nYou want to choose a set of light bulbs\nS\nthat you initially turn on in such a way that by performing the described operations, you can ensure that all light bulbs are turned on.\nCalculate two numbers:\nthe minimum size of the set\nS\nthat you initially turn on;\nthe number of sets\nS\nof minimum size (taken modulo\n998244353\n).\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of pairs of light bulbs.\nThe second line of each test case contains\n2n\nintegers\nc\n1\n,\nc\n2\n,…,\nc\n2n\n(\n1≤\nc\ni\n≤n\n), where\nc\ni\nis the color of the\ni\n-th light bulb. For each color from\n1\nto\nn\n, exactly two light bulbs have this color.\nAdditional constraint on the input: the sum of values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output two integers:\nthe minimum size of the set\nS\nthat you initially turn on;\nthe number of sets\nS\nof minimum size (taken modulo\n998244353\n).\nExample\ninput\nCopy\n4\n2\n2 2 1 1\n2\n1 2 2 1\n2\n1 2 1 2\n5\n3 4 4 5 3 1 1 5 2 2\noutput\nCopy\n2 4\n1 2\n1 4\n2 8",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "data structures",
            "dfs and similar",
            "dp",
            "graphs",
            "hashing",
            "*2300"
        ]
    },
    {
        "title": "G1. Light Bulbs (Easy Version)",
        "description": "The easy and hard versions of this problem differ only in the constraints on\nn\n. In the easy version, the sum of values of\nn\n2\nover all test cases does not exceed\n10\n6\n. Furthermore,\nn\ndoes not exceed\n1000\nin each test case.\nThere are\n2n\nlight bulbs arranged in a row. Each light bulb has a color from\n1\nto\nn\n(exactly two light bulbs for each color).\nInitially, all light bulbs are turned off. You choose a set of light bulbs\nS\nthat you initially turn on. After that, you can perform the following operations in any order any number of times:\nchoose two light bulbs\ni\nand\nj\nof the same color, exactly one of which is on, and turn on the second one;\nchoose three light bulbs\ni,j,k\n, such that both light bulbs\ni\nand\nk\nare on and have the same color, and the light bulb\nj\nis between them (\ni<j<k\n), and turn on the light bulb\nj\n.\nYou want to choose a set of light bulbs\nS\nthat you initially turn on in such a way that by performing the described operations, you can ensure that all light bulbs are turned on.\nCalculate two numbers:\nthe minimum size of the set\nS\nthat you initially turn on;\nthe number of sets\nS\nof minimum size (taken modulo\n998244353\n).\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤1000\n) — the number of pairs of light bulbs.\nThe second line of each test case contains\n2n\nintegers\nc\n1\n,\nc\n2\n,…,\nc\n2n\n(\n1≤\nc\ni\n≤n\n), where\nc\ni\nis the color of the\ni\n-th light bulb. For each color from\n1\nto\nn\n, exactly two light bulbs have this color.\nAdditional constraint on the input: the sum of values of\nn\n2\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output two integers:\nthe minimum size of the set\nS\nthat you initially turn on;\nthe number of sets\nS\nof minimum size (taken modulo\n998244353\n).\nExample\ninput\nCopy\n4\n2\n2 2 1 1\n2\n1 2 2 1\n2\n1 2 1 2\n5\n3 4 4 5 3 1 1 5 2 2\noutput\nCopy\n2 4\n1 2\n1 4\n2 8",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dfs and similar",
            "dp",
            "dsu",
            "graphs",
            "math",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "F. Programming Competition",
        "description": "BerSoft is the biggest IT corporation in Berland. There are\nn\nemployees at BerSoft company, numbered from\n1\nto\nn\n.\nThe first employee is the head of the company, and he does not have any superiors. Every other employee\ni\nhas exactly one direct superior\np\ni\n.\nEmployee\nx\nis considered to be a superior (direct or indirect) of employee\ny\nif one of the following conditions holds:\nemployee\nx\nis the direct superior of employee\ny\n;\nemployee\nx\nis a superior of the direct superior of employee\ny\n.\nThe structure of BerSoft is organized in such a way that the head of the company is superior of every employee.\nA programming competition is going to be held soon. Two-person teams should be created for this purpose. However, if one employee in a team is the superior of another, they are uncomfortable together. So, teams of two people should be created so that no one is the superior of the other. Note that no employee can participate in more than one team.\nYour task is to calculate the maximum possible number of teams according to the aforementioned rules.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of employees.\nThe second line contains\nn−1\nintegers\np\n2\n,\np\n3\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n), where\np\ni\nis the index of the direct superior of the\ni\n-th employee.\nThe sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible number of teams according to the aforementioned rules.\nExample\ninput\nCopy\n6\n4\n1 2 1\n2\n1\n5\n5 5 5 1\n7\n1 2 1 1 3 3\n7\n1 1 3 2 2 4\n7\n1 2 1 1 1 3\noutput\nCopy\n1\n0\n1\n3\n3\n3\nNote\nIn the first test case, team\n(3,4)\ncan be created.\nIn the second test case, no team can be created, because there are only\n2\nemployees and one is the superior of another.\nIn the third test case, team\n(2,3)\ncan be created.\nIn the fourth test case, teams\n(2,4)\n,\n(3,5)\nand\n(6,7)\ncan be created.\nIn the fifth test case, teams\n(2,3)\n,\n(6,4)\nand\n(5,7)\ncan be created.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "graph matchings",
            "greedy",
            "trees",
            "*1900"
        ]
    },
    {
        "title": "E2. Game with Marbles (Hard Version)",
        "description": "The easy and hard versions of this problem differ only in the constraints on the number of test cases and\nn\n. In the hard version, the number of test cases does not exceed\n10\n4\n, and the sum of values of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n. Furthermore, there are no additional constraints on\nn\nin a single test case.\nRecently, Alice and Bob were given marbles of\nn\ndifferent colors by their parents. Alice has received\na\n1\nmarbles of color\n1\n,\na\n2\nmarbles of color\n2\n,...,\na\nn\nmarbles of color\nn\n. Bob has received\nb\n1\nmarbles of color\n1\n,\nb\n2\nmarbles of color\n2\n, ...,\nb\nn\nmarbles of color\nn\n. All\na\ni\nand\nb\ni\nare between\n1\nand\n10\n9\n.\nAfter some discussion, Alice and Bob came up with the following game: players take turns, starting with Alice. On their turn, a player chooses a color\ni\nsuch that both players have at least one marble of that color. The player then discards one marble of color\ni\n, and their opponent discards all marbles of color\ni\n. The game ends when there is no color\ni\nsuch that both players have at least one marble of that color.\nThe score in the game is the difference between the number of remaining marbles that Alice has and the number of remaining marbles that Bob has at the end of the game. In other words, the score in the game is equal to\n(A−B)\n, where\nA\nis the number of marbles Alice has and\nB\nis the number of marbles Bob has at the end of the game. Alice wants to maximize the score, while Bob wants to minimize it.\nCalculate the score at the end of the game if both players play optimally.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of colors;\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the number of marbles of the\ni\n-th color that Alice has;\nthe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n), where\nb\ni\nis the number of marbles of the\ni\n-th color that Bob has.\nAdditional constraint on the input: the sum of\nn\nfor all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the score at the end of the game if both Alice and Bob act optimally.\nExample\ninput\nCopy\n5\n3\n4 2 1\n1 2 4\n4\n1 20 1 20\n100 15 10 20\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1\n3\n5 6 5\n2 1 7\n6\n3 2 4 2 5 5\n9 4 7 9 2 5\noutput\nCopy\n1\n-9\n2999999997\n8\n-6\nNote\nIn the first example, one way to achieve a score of\n1\nis as follows:\nAlice chooses color\n1\n, discards\n1\nmarble. Bob also discards\n1\nmarble;\nBob chooses color\n3\n, discards\n1\nmarble. Alice also discards\n1\nmarble;\nAlice chooses color\n2\n, discards\n1\nmarble, and Bob discards\n2\nmarble.\nAs a result, Alice has\na=[3,1,0]\nremaining, and Bob has\nb=[0,0,3]\nremaining. The score is\n3+1−3=1\n.\nIt can be shown that neither Alice nor Bob can achieve a better score if both play optimally.\nIn the second example, Alice can first choose color\n1\n, then Bob will choose color\n4\n, after which Alice will choose color\n2\n, and Bob will choose color\n3\n. It can be shown that this is the optimal game.",
        "time_limit": "3.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "games",
            "greedy",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "E1. Game with Marbles (Easy Version)",
        "description": "The easy and hard versions of this problem differ only in the constraints on the number of test cases and\nn\n. In the easy version, the number of test cases does not exceed\n10\n3\n, and\nn\ndoes not exceed\n6\n.\nRecently, Alice and Bob were given marbles of\nn\ndifferent colors by their parents. Alice has received\na\n1\nmarbles of color\n1\n,\na\n2\nmarbles of color\n2\n,...,\na\nn\nmarbles of color\nn\n. Bob has received\nb\n1\nmarbles of color\n1\n,\nb\n2\nmarbles of color\n2\n, ...,\nb\nn\nmarbles of color\nn\n. All\na\ni\nand\nb\ni\nare between\n1\nand\n10\n9\n.\nAfter some discussion, Alice and Bob came up with the following game: players take turns, starting with Alice. On their turn, a player chooses a color\ni\nsuch that both players have at least one marble of that color. The player then discards one marble of color\ni\n, and their opponent discards all marbles of color\ni\n. The game ends when there is no color\ni\nsuch that both players have at least one marble of that color.\nThe score in the game is the difference between the number of remaining marbles that Alice has and the number of remaining marbles that Bob has at the end of the game. In other words, the score in the game is equal to\n(A−B)\n, where\nA\nis the number of marbles Alice has and\nB\nis the number of marbles Bob has at the end of the game. Alice wants to maximize the score, while Bob wants to minimize it.\nCalculate the score at the end of the game if both players play optimally.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nEach test case consists of three lines:\nthe first line contains a single integer\nn\n(\n2≤n≤6\n) — the number of colors;\nthe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n), where\na\ni\nis the number of marbles of the\ni\n-th color that Alice has;\nthe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n9\n), where\nb\ni\nis the number of marbles of the\ni\n-th color that Bob has.\nOutput\nFor each test case, output a single integer — the score at the end of the game if both Alice and Bob act optimally.\nExample\ninput\nCopy\n5\n3\n4 2 1\n1 2 4\n4\n1 20 1 20\n100 15 10 20\n5\n1000000000 1000000000 1000000000 1000000000 1000000000\n1 1 1 1 1\n3\n5 6 5\n2 1 7\n6\n3 2 4 2 5 5\n9 4 7 9 2 5\noutput\nCopy\n1\n-9\n2999999997\n8\n-6\nNote\nIn the first example, one way to achieve a score of\n1\nis as follows:\nAlice chooses color\n1\n, discards\n1\nmarble. Bob also discards\n1\nmarble;\nBob chooses color\n3\n, discards\n1\nmarble. Alice also discards\n1\nmarble;\nAlice chooses color\n2\n, discards\n1\nmarble, and Bob discards\n2\nmarble.\nAs a result, Alice has\na=[3,1,0]\nremaining, and Bob has\nb=[0,0,3]\nremaining. The score is\n3+1−3=1\n.\nIt can be shown that neither Alice nor Bob can achieve a better score if both play optimally.\nIn the second example, Alice can first choose color\n1\n, then Bob will choose color\n4\n, after which Alice will choose color\n2\n, and Bob will choose color\n3\n. It can be shown that this is the optimal game.",
        "time_limit": "3.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "D. Three Activities",
        "description": "Winter holidays are coming up. They are going to last for\nn\ndays.\nDuring the holidays, Monocarp wants to try all of these activities exactly once with his friends:\ngo skiing;\nwatch a movie in a cinema;\nplay board games.\nMonocarp knows that, on the\ni\n-th day, exactly\na\ni\nfriends will join him for skiing,\nb\ni\nfriends will join him for a movie and\nc\ni\nfriends will join him for board games.\nMonocarp also knows that he can't try more than one activity in a single day.\nThus, he asks you to help him choose three distinct days\nx,y,z\nin such a way that the total number of friends to join him for the activities (\na\nx\n+\nb\ny\n+\nc\nz\n) is maximized.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n3≤n≤\n10\n5\n) — the duration of the winter holidays in days.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n8\n) — the number of friends that will join Monocarp for skiing on the\ni\n-th day.\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n8\n) — the number of friends that will join Monocarp for a movie on the\ni\n-th day.\nThe fourth line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n8\n) — the number of friends that will join Monocarp for board games on the\ni\n-th day.\nThe sum of\nn\nover all testcases doesn't exceed\n10\n5\n.\nOutput\nFor each testcase, print a single integer — the maximum total number of friends that can join Monocarp for the activities on three distinct days.\nExample\ninput\nCopy\n4\n3\n1 10 1\n10 1 1\n1 1 10\n4\n30 20 10 1\n30 5 15 20\n30 25 10 10\n10\n5 19 12 3 18 18 6 17 10 13\n15 17 19 11 16 3 11 17 17 17\n1 17 18 10 15 8 17 3 13 12\n10\n17 5 4 18 12 4 11 2 16 16\n8 4 14 19 3 12 6 7 5 16\n3 4 8 11 10 8 10 2 20 3\noutput\nCopy\n30\n75\n55\n56\nNote\nIn the first testcase, Monocarp can choose day\n2\nfor skiing, day\n1\nfor a movie and day\n3\nfor board games. This way,\na\n2\n=10\nfriends will join him for skiing,\nb\n1\n=10\nfriends will join him for a movie and\nc\n3\n=10\nfriends will join him for board games. The total number of friends is\n30\n.\nIn the second testcase, Monocarp can choose day\n1\nfor skiing, day\n4\nfor a movie and day\n2\nfor board games.\n30+20+25=75\nfriends in total. Note that Monocarp can't choose day\n1\nfor all activities, because he can't try more than one activity in a single day.\nIn the third testcase, Monocarp can choose day\n2\nfor skiing, day\n3\nfor a movie and day\n7\nfor board games.\n19+19+17=55\nfriends in total.\nIn the fourth testcase, Monocarp can choose day\n1\nfor skiing, day\n4\nfor a movie and day\n9\nfor board games.\n17+19+20=56\nfriends in total.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ]
    },
    {
        "title": "C. Quests",
        "description": "Monocarp is playing a computer game. In order to level up his character, he can complete quests. There are\nn\nquests in the game, numbered from\n1\nto\nn\n.\nMonocarp can complete quests according to the following rules:\nthe\n1\n-st quest is always available for completion;\nthe\ni\n-th quest is available for completion if all quests\nj<i\nhave been completed at least once.\nNote that Monocarp can complete the same quest multiple times.\nFor each completion, the character gets some amount of experience points:\nfor the first completion of the\ni\n-th quest, he gets\na\ni\nexperience points;\nfor each subsequent completion of the\ni\n-th quest, he gets\nb\ni\nexperience points.\nMonocarp is a very busy person, so he has free time to complete no more than\nk\nquests. Your task is to calculate the maximum possible total experience Monocarp can get if he can complete no more than\nk\nquests.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains two integers\nn\nand\nk\n(\n1≤n≤2⋅\n10\n5\n;\n1≤k≤2⋅\n10\n5\n) — the number of quests and the maximum number of quests Monocarp can complete, respectively.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n3\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n1≤\nb\ni\n≤\n10\n3\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible total experience Monocarp can get if he can complete no more than\nk\nquests.\nExample\ninput\nCopy\n4\n4 7\n4 3 1 2\n1 1 1 1\n3 2\n1 2 5\n3 1 8\n5 5\n3 2 4 1 4\n2 3 1 4 7\n6 4\n1 4 5 4 5 10\n1 5 1 2 5 1\noutput\nCopy\n13\n4\n15\n15\nNote\nIn the first test case, one of the possible quest completion sequences is as follows:\n1,1,2,3,2,4,4\n; its total experience is equal to\n4\n–\n+1+\n3\n–\n+\n1\n–\n+1+\n2\n–\n+1=13\n(the underlined numbers correspond to the instances when we complete a quest for the first time).\nIn the second test case, one of the possible quest completion sequences is as follows:\n1,1\n; its total experience is equal to\n1\n–\n+3=4\n.\nIn the third test case, one of the possible quest completion sequences is as follows:\n1,2,2,2,3\n; its total experience is equal to\n3\n–\n+\n2\n–\n+3+3+\n4\n–\n=15\n.",
        "time_limit": "2.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ]
    },
    {
        "title": "B. Preparing for the Contest",
        "description": "Monocarp is practicing for a big contest. He plans to solve\nn\nproblems to make sure he's prepared. Each of these problems has a difficulty level: the first problem has a difficulty level of\n1\n, the second problem has a difficulty level of\n2\n, and so on, until the last (\nn\n-th) problem, which has a difficulty level of\nn\n.\nMonocarp will choose some order in which he is going to solve all\nn\nproblems. Whenever he solves a problem which is more difficult than the last problem he solved, he gets excited because he feels like he's progressing. He doesn't get excited when he solves the first problem in his chosen order.\nFor example, if Monocarp solves the problems in the order\n[3,\n5\n–\n,4,1,\n6\n–\n,2]\n, he gets excited twice (the corresponding problems are underlined).\nMonocarp wants to get excited exactly\nk\ntimes during his practicing session. Help him to choose the order in which he has to solve the problems!\nInput\nThe first line contains one integer\nt\n(\n1≤t≤1000\n) — the number of test cases.\nEach test case consists of one line containing two integers\nn\nand\nk\n(\n2≤n≤50\n;\n0≤k≤n−1\n).\nOutput\nFor each test case, print\nn\ndistinct integers from\n1\nto\nn\n, denoting the order in which Monocarp should solve the problems. If there are multiple answers, print any of them.\nIt can be shown that under the constraints of the problem, the answer always exists.\nExample\ninput\nCopy\n3\n6 2\n5 4\n5 0\noutput\nCopy\n3 5 4 1 6 2\n1 2 3 4 5\n5 4 3 2 1",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "A. Problemsolving Log",
        "description": "Monocarp is participating in a programming contest, which features\n26\nproblems, named from 'A' to 'Z'. The problems are sorted by difficulty. Moreover, it's known that Monocarp can solve problem 'A' in\n1\nminute, problem 'B' in\n2\nminutes, ..., problem 'Z' in\n26\nminutes.\nAfter the contest, you discovered his contest log — a string, consisting of uppercase Latin letters, such that the\ni\n-th letter tells which problem Monocarp was solving during the\ni\n-th minute of the contest. If Monocarp had spent enough time in total on a problem to solve it, he solved it. Note that Monocarp could have been thinking about a problem after solving it.\nGiven Monocarp's contest log, calculate the number of problems he solved during the contest.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤100\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n1≤n≤500\n) — the duration of the contest, in minutes.\nThe second line contains a string of length exactly\nn\n, consisting only of uppercase Latin letters, — Monocarp's contest log.\nOutput\nFor each testcase, print a single integer — the number of problems Monocarp solved during the contest.\nExample\ninput\nCopy\n3\n6\nACBCBC\n7\nAAAAFPC\n22\nFEADBBDFFEDFFFDHHHADCC\noutput\nCopy\n3\n1\n4",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*800"
        ]
    },
    {
        "title": "F. Palindromic Problem",
        "description": "You are given a string\ns\nof length\nn\n, consisting of lowercase Latin letters.\nYou are allowed to replace at most one character in the string with an arbitrary lowercase Latin letter.\nPrint the lexicographically minimal string that can be obtained from the original string and contains the maximum number of palindromes as substrings. Note that if a palindrome appears more than once as a substring, it is counted the same number of times it appears.\nThe string\na\nis lexicographically smaller than the string\nb\nif and only if one of the following holds:\na\nis a prefix of\nb\n, but\na≠b\n;\nin the first position where\na\nand\nb\nare different, the string\na\ncontains a letter that appears earlier in the alphabet than the corresponding letter in\nb\n.\nInput\nThe first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n) — the number of characters in the string.\nThe second line contains the string\ns\nitself, consisting of exactly\nn\nlowercase Latin letters.\nOutput\nIn the first line, print one integer — the maximum number of palindromic substrings that can be obtained using the operation described in the statement at most once.\nIn the second line, print the string that can be obtained from\ns\nand has the maximum possible number of palindromic substrings. If there are multiple answers, print the lexicographically smallest one.\nExamples\ninput\nCopy\n5\naabaa\noutput\nCopy\n15\naaaaa\ninput\nCopy\n5\naaaaa\noutput\nCopy\n15\naaaaa\ninput\nCopy\n4\nawoo\noutput\nCopy\n7\naooo",
        "time_limit": "5 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "hashing",
            "string suffix structures",
            "strings",
            "*2800"
        ]
    },
    {
        "title": "E. Matrix Problem",
        "description": "You are given a matrix\na\n, consisting of\nn\nrows by\nm\ncolumns. Each element of the matrix is equal to\n0\nor\n1\n.\nYou can perform the following operation any number of times (possibly zero): choose an element of the matrix and replace it with either\n0\nor\n1\n.\nYou are also given two arrays\nA\nand\nB\n(of length\nn\nand\nm\nrespectively). After you perform the operations, the matrix should satisfy the following conditions:\nthe number of ones in the\ni\n-th row of the matrix should be exactly\nA\ni\nfor every\ni∈[1,n]\n.\nthe number of ones in the\nj\n-th column of the matrix should be exactly\nB\nj\nfor every\nj∈[1,m]\n.\nCalculate the minimum number of operations you have to perform.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n2≤n,m≤50\n).\nThen\nn\nlines follow. The\ni\n-th of them contains\nm\nintegers\na\ni,1\n,\na\ni,2\n,…,\na\ni,m\n(\n0≤\na\ni,j\n≤1\n).\nThe next line contains\nn\nintegers\nA\n1\n,\nA\n2\n,…,\nA\nn\n(\n0≤\nA\ni\n≤m\n).\nThe next line contains\nm\nintegers\nB\n1\n,\nB\n2\n,…,\nB\nm\n(\n0≤\nB\ni\n≤n\n).\nOutput\nPrint one integer — the minimum number of operations you have to perform, or -1 if it is impossible.\nExamples\ninput\nCopy\n3 3\n0 0 0\n0 0 0\n0 0 0\n1 1 1\n1 1 1\noutput\nCopy\n3\ninput\nCopy\n3 3\n1 1 1\n1 1 1\n1 1 1\n3 2 1\n1 2 3\noutput\nCopy\n3\ninput\nCopy\n2 2\n0 0\n0 0\n1 2\n0 1\noutput\nCopy\n-1",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "flows",
            "graphs",
            "*2400"
        ]
    },
    {
        "title": "D. Array Collapse",
        "description": "You are given an array\n[\np\n1\n,\np\n2\n,…,\np\nn\n]\n, where all elements are distinct.\nYou can perform several (possibly zero) operations with it. In one operation, you can choose a contiguous subsegment of\np\nand remove all elements from that subsegment, except for the minimum element on that subsegment. For example, if\np=[3,1,4,7,5,2,6]\nand you choose the subsegment from the\n3\n-rd element to the\n6\n-th element, the resulting array is\n[3,1,2,6]\n.\nAn array\na\nis called reachable if it can be obtained from\np\nusing several (maybe zero) aforementioned operations. Calculate the number of reachable arrays, and print it modulo\n998244353\n.\nInput\nThe first line of the input contains one integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nEach test case consists of two lines. The first line contains one integer\nn\n(\n1≤n≤3⋅\n10\n5\n). The second line contains\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤\n10\n9\n).\nAdditional constraint on the input: the sum of\nn\nover all test cases does not exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the number of reachable arrays, taken modulo\n998244353\n.\nExample\ninput\nCopy\n3\n2\n2 1\n4\n2 4 1 3\n5\n10 2 6 3 4\noutput\nCopy\n2\n6\n12",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "divide and conquer",
            "dp",
            "trees",
            "*2100"
        ]
    },
    {
        "title": "C. Game with Multiset",
        "description": "In this problem, you are initially given an empty multiset. You have to process two types of queries:\nADD\nx\n— add an element equal to\n2\nx\nto the multiset;\nGET\nw\n— say whether it is possible to take the sum of some subset of the current multiset and get a value equal to\nw\n.\nInput\nThe first line contains one integer\nm\n(\n1≤m≤\n10\n5\n) — the number of queries.\nThen\nm\nlines follow, each of which contains two integers\nt\ni\n,\nv\ni\n, denoting the\ni\n-th query. If\nt\ni\n=1\n, then the\ni\n-th query is ADD\nv\ni\n(\n0≤\nv\ni\n≤29\n). If\nt\ni\n=2\n, then the\ni\n-th query is GET\nv\ni\n(\n0≤\nv\ni\n≤\n10\n9\n).\nOutput\nFor each GET query, print YES if it is possible to choose a subset with sum equal to\nw\n, or NO if it is impossible.\nExamples\ninput\nCopy\n5\n1 0\n1 0\n1 0\n2 3\n2 4\noutput\nCopy\nYES\nNO\ninput\nCopy\n7\n1 0\n1 1\n1 2\n1 10\n2 4\n2 6\n2 7\noutput\nCopy\nYES\nYES\nYES",
        "time_limit": "1.5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "bitmasks",
            "brute force",
            "greedy",
            "*1300"
        ]
    },
    {
        "title": "B. Swap and Delete",
        "description": "You are given a binary string\ns\n(a string consisting only of 0-s and 1-s).\nYou can perform two types of operations on\ns\n:\ndelete one character from\ns\n. This operation costs\n1\ncoin;\nswap any pair of characters in\ns\n. This operation is free (costs\n0\ncoins).\nYou can perform these operations any number of times and in any order.\nLet's name a string you've got after performing operations above as\nt\n. The string\nt\nis good if for each\ni\nfrom\n1\nto\n|t|\nt\ni\n≠\ns\ni\n(\n|t|\nis the length of the string\nt\n). The empty string is always good. Note that you are comparing the resulting string\nt\nwith the initial string\ns\n.\nWhat is the minimum total cost to make the string\nt\ngood?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Then\nt\ntest cases follow.\nThe only line of each test case contains a binary string\ns\n(\n1≤|s|≤2⋅\n10\n5\n;\ns\ni\n∈{\n0, 1\n}\n) — the initial string, consisting of characters 0 and/or 1.\nAdditional constraint on the input: the total length of all strings\ns\ndoesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print one integer — the minimum total cost to make string\nt\ngood.\nExample\ninput\nCopy\n4\n0\n011\n0101110001\n111100\noutput\nCopy\n1\n1\n0\n4\nNote\nIn the first test case, you have to delete a character from\ns\nto get the empty string\nt\n. Only then\nt\nbecomes good. One deletion costs\n1\ncoin.\nIn the second test case, you can, for example, delete the second character from\ns\nto get the string 01, and then swap the first and second characters to get the string\nt\n=\n10. String\nt\nis good, since\nt\n1\n≠\ns\n1\nand\nt\n2\n≠\ns\n2\n. The total cost is\n1\ncoin.\nIn the third test case, you can, for example, swap\ns\n1\nwith\ns\n2\n, swap\ns\n3\nwith\ns\n4\n, swap\ns\n5\nwith\ns\n7\n,\ns\n6\nwith\ns\n8\nand\ns\n9\nwith\ns\n10\n. You'll get\nt\n=\n1010001110. All swap operations are free, so the total cost is\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "strings",
            "*1000"
        ]
    },
    {
        "title": "A. Rating Increase",
        "description": "Monocarp is a great solver of adhoc problems. Recently, he participated in an Educational Codeforces Round, and gained rating!\nMonocarp knew that, before the round, his rating was\na\n. After the round, it increased to\nb\n(\nb>a\n). He wrote both values one after another to not forget them.\nHowever, he wrote them so close to each other, that he can't tell now where the first value ends and the second value starts.\nPlease, help him find some values\na\nand\nb\nsuch that:\nneither of them has a leading zero;\nboth of them are strictly greater than\n0\n;\nb>a\n;\nthey produce the given value\nab\nwhen written one after another.\nIf there are multiple answers, you can print any of them.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe only line of each testcase consists of a single string\nab\nof length from\n2\nto\n8\nthat:\nconsists only of digits;\ndoesn't start with a zero.\nOutput\nFor each testcase, determine if such values\na\nand\nb\nexist. If they don't, print -1. Otherwise, print two integers\na\nand\nb\n.\nIf there are multiple answers, you can print any of them.\nExample\ninput\nCopy\n5\n20002001\n391125\n200200\n2001000\n12\noutput\nCopy\n2000 2001\n39 1125\n-1\n200 1000\n1 2\nNote\nIn the second testcase, printing\n3\nand\n91125\nis also valid.\nIn the third testcase,\n20\nand\n0200\nis not valid, because\nb\nhas a leading zero.\n200\nand\n200\nis not valid, because\n200\nis not strictly greater than\n200\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "L. LOL Lovers",
        "description": "There are\nn\nfood items lying in a row on a long table. Each of these items is either a loaf of bread (denoted as a capital Latin letter 'L' with ASCII code 76) or an onion (denoted as a capital Latin letter 'O' with ASCII code 79). There is at least one loaf of bread and at least one onion on the table.\nYou and your friend want to divide the food on the table: you will take a prefix of this row (several leftmost items), and the friend will take the rest. However, there are several restrictions:\nEach person should have at least one item.\nThe number of your loaves should differ from the number of your friend's loaves.\nThe number of your onions should differ from the number of your friend's onions.\nFind any correct division and print the number of items you take or report that there is no answer.\nInput\nThe first line contains one integer\nn\n(\n2≤n≤200\n) — the number of food items on the table. The second line contains a string of length\nn\nconsisting of letters 'L' and 'O'.\ni\n-th symbol represents the type of the\ni\n-th food item on the table: 'L' stands for a loaf of bread, and 'O' stands for an onion. It is guaranteed that this string contains at least one letter 'L' and at least one letter 'O'.\nOutput\nPrint one integer — a number\nk\nsuch that, if you take\nk\nleftmost items and your friend takes the remaining\nn−k\nitems, each of you and your friend get at least one item, your number of loaves is different from your friend's, and your number of onions is different from your friend's. If there are several possible answers, print any of them. If there are no possible answers, print the number\n−1\n.\nExamples\ninput\nCopy\n3\nLOL\noutput\nCopy\n-1\ninput\nCopy\n2\nLO\noutput\nCopy\n1\ninput\nCopy\n4\nLLLO\noutput\nCopy\n1\ninput\nCopy\n4\nOLOL\noutput\nCopy\n-1\ninput\nCopy\n10\nLLOOOOLLLO\noutput\nCopy\n5\nNote\nIn the first example, in any division the left and the right part contain one loaf of bread.\nIn the second example, the division is 'L' and 'O', and in these two strings the number of loaves is different (1 and 0) and the number of onions is different (0 and 1).\nIn the third example, any number 1, 2 or 3 is a correct answer.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "strings",
            "*800"
        ]
    },
    {
        "title": "K. Kim's Quest",
        "description": "In the long-forgotten halls of Kombinatoria's ancient academy, a gifted mathematician named Kim is faced with an unusual challenge. They found an old sequence of integers, which is believed to be a cryptic message from the legendary Kombinatoria's Oracle, and Kim wants to decipher its hidden meaning.\nKim's mission is to find specific patterns within the sequence, known as Harmonious Subsequences. These are extraordinary subsequences where the sum of every three consecutive numbers is even, and each subsequence must be at least three numbers in length.\nGiven a sequence\na\ni\n(\n1≤i≤n\n) of length\nn\n, its subsequence of length\nm\nis equal to\na\nb\n1\n,\na\nb\n2\n,…,\na\nb\nm\nand is uniquely defined by a set of\nm\nindices\nb\nj\n, such that\n1≤\nb\n1\n<\nb\n2\n<…<\nb\nm\n≤n\n. Subsequences given by different sets of indices\nb\nj\nare considered different.\nThere's a twist in Kim's quest: the number of these Harmonious Subsequences could be overwhelming. To report the findings effectively, Kim must calculate the total number of these subsequences, presenting the answer as a remainder after dividing by the number\n998244353\n.\nInput\nThe first line contains a single integer\nn\n — the length of the sequence (\n3≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nspace-separated integers\na\ni\n — the elements of the sequence (\n1≤\na\ni\n≤2⋅\n10\n5\n).\nOutput\nOutput one number — the number of Harmonious Subsequences, modulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 2 3\noutput\nCopy\n1\ninput\nCopy\n5\n2 8 2 6 4\noutput\nCopy\n16\ninput\nCopy\n5\n5 7 1 3 5\noutput\nCopy\n0\ninput\nCopy\n11\n3 1 4 1 5 9 2 6 5 3 6\noutput\nCopy\n386\ninput\nCopy\n54\n2 1 1 1 1 2 1 2 2 2 2 1 1 1 2 1 1 2\n2 1 2 2 2 2 2 2 2 1 1 1 2 2 1 1 1 1\n2 2 1 1 2 2 2 2 2 1 1 1 2 2 1 2 1 1\noutput\nCopy\n0\nNote\nIn the provided input data for the fifth sample, the sequence of numbers is split into three separate lines for clarity, but it should be understood that in the actual test data, the sequence is given in one line. The actual number of Harmonious Subsequences in this example is\n4991221765=5×998244353\n, hence the output is zero as a result of finding its remainder after dividing by the number\n998244353\n.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "dp",
            "*1800"
        ]
    },
    {
        "title": "H. Hypercatapult Commute",
        "description": "A revolutionary new transport system is currently operating in Byteland. This system requires neither roads nor sophisticated mechanisms, only giant catapults.\nThe system works as follows. There are\nn\ncities in Byteland. In every city there is a catapult, right in the city center. People who want to travel are put in a special capsule, and a catapult throws this capsule to the center of some other city. Every catapult is powerful enough to throw the capsule to any other city, with any number of passengers inside the capsule. The only problem is that it takes a long time to charge the catapult, so it is only possible to use it once a day.\nThe passenger may need to use the catapults multiple times. For example, if the passenger wants to travel from city A to city B, they can first use one catapult to move from A to C, and then transfer to another catapult to move from C to B.\nToday there are\nm\npassengers. Passenger\ni\nwants to travel from city\na\ni\nto city\nb\ni\n. Your task is to find the way to deliver all the passengers to their destinations in a single day, using the minimal possible number of catapults, or say that it is impossible.\nInput\nThe first line of the input contains two integers\nn\nand\nm\n(\n1≤n≤1000\n,\n0≤m≤\n10\n5\n) — the number of cities and the number of passengers. The next\nm\nlines contain pairs of numbers\na\ni\nand\nb\ni\n(\n1≤\na\ni\n,\nb\ni\n≤n\n,\na\ni\n≠\nb\ni\n).\nOutput\nIn the first line print the number\nk\n — the minimal number of catapults you need to use.\nIn the next\nk\nlines, print descriptions of each catapult launch, in the order they need to be performed. Each description should consist of two integers\nc\ni\n,\nd\ni\n, the index of the city to launch from, and the index of destination city.\nNote that you don't need to print what passengers should be put into the capsule on each launch, but it should be possible for each passenger to reach their destination city using the plan you provide.\nIf it is impossible to deliver all passengers, print the single number\n−1\n.\nExamples\ninput\nCopy\n5 6\n1 3\n1 2\n2 3\n4 2\n1 5\n5 1\noutput\nCopy\n5\n5 1\n1 2\n4 2\n2 3\n3 5\ninput\nCopy\n3 6\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\noutput\nCopy\n-1",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "graphs",
            "*2400"
        ]
    },
    {
        "title": "F. Fugitive Frenzy",
        "description": "The city of F. can be represented as a tree. A famous fugitive is hiding in it, and today a faithful police officer decided to catch him at all costs. The police officer is stronger than the fugitive, but the fugitive is much faster than the former. That is why the pursuit proceeds as follows. At the moment\nt=0\nthe police officer appears at the vertex with number\ns\n, and the fugitive spawns at any other vertex of his choice. After that, they take turns, starting with the police officer.\nDuring the police officer's move, she selects any vertex adjacent to the one where she is currently located and moves there. The police officer spends one minute moving. Also, the police officer may decide to stand still instead, in which case she waits one minute at the vertex at which she started her move. If at the end of the turn the police officer ends up at the same vertex as the fugitive, she instantly catches him and the chase ends.\nThe fugitive's move is as follows. Let him be at vertex\nb\n, and the police officer at vertex\np\n. Then the fugitive chooses any vertex\nb\n′\n≠p\nsuch that the path between the vertices\nb\nand\nb\n′\ndoes not contain vertex\np\nand instantly moves there. In particular, he can always choose\nb\n′\n=b\nto stay where he is. The fugitive's move takes no time.\nNote that the fugitive managed to attach a radio bug to the police officer's badge a week ago, so the fugitive knows the location of the police officer at every moment (in particular, he knows the number\ns\n). On the contrary, the police officer knows nothing about the fugitive's movements and will only be able to detect him at the very moment she catches him.\nThe police officer aims to catch the fugitive as fast as possible, and the fugitive aims to be caught as late as possible. Since the chase can be thought of as a game with incomplete information, participants can use mixed (probabilistic) strategies — thus, the police officer acts to minimize the expected duration of the chase, and the fugitive — to maximize it.\nFind the mathematical expectation of the duration of the chase with optimal actions of the police officer and the fugitive. It can be proven that it is always finite. In particular, with optimal strategies, the probability that the chase continues indefinitely is equal to zero.\nInput\nThe first line contains an integer\nn\n — the number of vertices in the tree (\n2≤n≤100\n). The next\nn−1\nlines describe the city of F.: each of them contains a pair of integers\nu\ni\n,\nv\ni\n — the numbers of the ends of an edge (\n1≤\nu\ni\n,\nv\ni\n≤n\n). These edges are guaranteed to form a tree.\nThe last line contains an integer\ns\n — the number of the vertex where the police officer initially appears (\n1≤s≤n\n).\nOutput\nPrint one real number — the mathematical expectation of the duration of the chase with the optimal strategies of the police officer and the fugitive. Your answer will be accepted if its absolute or relative error does not exceed\n10\n−6\n; formally, if\np\nis your answer, and\nj\nis the jury's answer, this should hold:\n|p−j|\nmax{1,|j|}\n≤\n10\n−6\n.\nExamples\ninput\nCopy\n2\n1 2\n2\noutput\nCopy\n1\ninput\nCopy\n3\n1 2\n1 3\n1\noutput\nCopy\n2\ninput\nCopy\n4\n4 3\n4 1\n4 2\n4\noutput\nCopy\n3.66667\ninput\nCopy\n7\n1 4\n4 5\n5 2\n4 6\n6 7\n7 3\n3\noutput\nCopy\n8.3525\nNote\nThe trees from the examples are depicted below.",
        "time_limit": "5 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "math",
            "probabilities",
            "*3100"
        ]
    },
    {
        "title": "E. Evaluate It and Back Again",
        "description": "Aidan and Nadia are long-time friends with a shared passion for mathematics. Each of them has a favorite number: Aidan's favorite number is\np\n, and Nadia's is\nq\n.\nTo commemorate their friendship, their friends want to make a present: a plaque with an arithmetic expression whose value is equal to their favorite numbers. At first glance, it sounds impossible, but the answer is simple: Aidan reads left-to-right, while Nadia reads right-to-left, so the same expression can have different values for them.\nFor example, if 2023-12-13 is written on the plaque, then Aidan would calculate the result as\n2023−12−13=1998\n, and Nadia would calculate it as\n31−21−3202=−3192\n.\nFind an arithmetic expression that, when read left-to-right, evaluates to\np\n, and, when read right-to-left, evaluates to\nq\n. Its length must be at most\n1000\ncharacters. It's guaranteed that such an expression exists for all valid inputs.\nInput\nThe first line of the input contains two integers\np\nand\nq\n(\n−\n10\n18\n≤p,q≤\n10\n18\n).\nOutput\nPrint the expression without spaces or line breaks. It can only contain digits 0 through 9, '+', '-', and '*' characters.\nThe expression must contain at most\n1000\ncharacters. Leading zeros in numbers are not allowed (the only exception is the notation '0' representing the number\n0\n) in both the expression and its reverse. Use of unary '+' or '-' is not allowed. The expression must be well-formed in both directions. The calculation uses the standard operator precedence.\nExamples\ninput\nCopy\n1998 -3192\noutput\nCopy\n2023-12-13\ninput\nCopy\n413 908\noutput\nCopy\n12*34+5",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*2200"
        ]
    },
    {
        "title": "D. Divisibility Test",
        "description": "Daisy has recently learned divisibility rules for integers and she is fascinated by them. One of the tests she learned is a divisibility test by 3. You can find a sum of all digits of a decimal number and check if the resulting sum is divisible by 3. Moreover, the resulting sum of digits is congruent modulo 3 to the original number — the remainder modulo 3 is preserved. For example,\n75≡7+5(mod3)\n. Daisy is specifically interested in such remainder preserving divisibility tests.\nThere are more examples like that that she learned for decimal integers (integers base 10):\nTo test divisibility modulo 11, find an alternating sum of digits. Counting digits from the last (least significant) digit, add digits on odd positions (the last, 3rd to the last, etc) and subtract digits on even positions (2nd to the last, 4th to the last, etc) to get the sum that is congruent modulo 11 to the original number. For example,\n123≡1−2+3(mod11)\n.\nTo test divisibility modulo 4, keep the last two digits. Their value is congruent modulo 4 to the original number. For example,\n876543≡43(mod4)\n.\nTo test divisibility modulo 7, find an alternating sum of groups of three digits. For example,\n4389328≡4−389+328(mod7)\n.\nSimilar tests can be found in other bases. For example, to test divisibility modulo 5 for octal numbers (base 8), find an alternating sum of groups of two digits. For example,\n1234\n8\n≡−\n12\n8\n+\n34\n8\n(mod5)\n.\nDaisy wants to find such rules for a given base\nb\n. She is interested in three kinds of divisibility rules:\nKind 1 — take the last\nk\ndigits of an integer in base\nb\n.\nKind 2 — take a sum of groups of\nk\ndigits of an integer in base\nb\n.\nKind 3 — take an alternating sum of groups of\nk\ndigits of an integer in base\nb\n.\nIt is not always possible to find such a divisibility rule. For example, in base 10 there is no such test for divisibility modulo 6, even though different approaches to testing divisibility by 6 exist.\nGiven base\nb\nand modulo\nn\n, Daisy wants to know the smallest group size\nk\nfor which such a divisibility test exits.\nInput\nThere are several tests in the input. The first line of the input contains an integer\nt\n — the number of tests. The next\nt\nlines describe the tests.\nEach test consists of a line with two integers\nb\nand\nn\n — the base and the modulo (\nb,n≥2\n). The sum of all\nb\nvalues in the input does not exceed\n10\n6\n, and the sum of all\nn\nvalues in the input does not exceed\n10\n6\n.\nOutput\nWrite\nt\nlines — a line for each test in the input. On a line for a test write a single integer\n0\nif the divisibility test for a given\nb\nand\nn\ndoes not exist. Otherwise, write two integers\na\nand\nk\n, where\na\nis the kind of the divisibility test (1, 2, or 3) and\nk\nis the number of digits in a group for the test, such that\nk\nis the lowest among all possible divisiblity tests for the given\nb\nand\nn\n.\nExample\ninput\nCopy\n6\n10 3\n10 11\n10 4\n10 7\n8 5\n10 6\noutput\nCopy\n2 1\n3 1\n1 2\n3 3\n3 2\n0",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "math",
            "*1900"
        ]
    },
    {
        "title": "B. Blueprint for Seating",
        "description": "An aircraft manufacturing company wants to optimize their products for passenger airlines. The company's latest research shows that most of the delays happen because of slow boarding.\nMost of the medium-sized aircraft are designed with 3-3 seat layout, meaning each row has 6 seats: 3 seats on the left side, a single aisle, and 3 seats on the right side. At each of the left and right sides there is a window seat, a middle seat, and an aisle seat. A passenger that boards an aircraft assigned to an aisle seat takes significantly less time than a passenger assigned to a window seat even when there is no one else in the aircraft.\nThe company decided to compute an inconvenience of a layout as the total sum of distances from each of the seats of a single row to the closest aisle. The distance from a seat to an aisle is the number of seats between them. For a 3-3 layout, a window seat has a distance of 2, a middle seat — 1, and an aisle seat — 0. The inconvenience of a 3-3 layout is\n(2+1+0)+(0+1+2)=6\n. The inconvenience of a 3-5-3 layout is\n(2+1+0)+(0+1+2+1+0)+(0+1+2)=10\n.\nFormally, a layout is a sequence of positive integers\na\n1\n,\na\n2\n,…,\na\nk+1\n — group\ni\nhaving\na\ni\nseats, with\nk\naisles between groups, the\ni\n-th aisle being between groups\ni\nand\ni+1\n. This means that in a layout each aisle must always be between two seats, so no aisle can be next to a window, and no two aisles can be next to each other.\nThe company decided to design a layout with a row of\nn\nseats,\nk\naisles and having the minimum inconvenience possible. Help them find the minimum inconvenience among all layouts of\nn\nseats and\nk\naisles, and count the number of such layouts modulo\n998244353\n.\nInput\nThe first line contains an integer\nt\n — the number of test cases you need to solve (\n1≤t≤\n10\n5\n).\nFor each of the test cases, there is a single line containing\nn\nand\nk\n — the number of seats, and the number of aisles in a row (\n2≤n≤\n10\n9\n;\n1≤k≤\n10\n5\n;\nk<n\n).\nThe total sum of\nk\nin all\nt\ngiven test cases does not exceed\n10\n6\n.\nOutput\nFor each test case print two integers — the minimum inconvenience among all possible layouts, and the number of layouts with the minimum inconvenience modulo\n998244353\n.\nExample\ninput\nCopy\n8\n4 1\n3 2\n4 2\n5 2\n6 1\n6 2\n1000000000 1\n9 2\noutput\nCopy\n2 1\n0 1\n0 1\n1 3\n6 1\n2 4\n249999999500000000 1\n6 3\nNote\nIn the last test case of 9 2 the possible layouts with the minimum inconvenience of 6 are 3-4-2, 2-4-3, and 2-5-2.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "divide and conquer",
            "math",
            "*2100"
        ]
    },
    {
        "title": "A. Accumulator Apex",
        "description": "Allyn is playing a new strategy game called \"Accumulator Apex\". In this game, Allyn is given the initial value of an integer\nx\n, referred to as the accumulator, and\nk\nlists of integers. Allyn can make multiple turns. On each turn, Allyn can withdraw the leftmost element from any non-empty list and add it to the accumulator\nx\nif the resulting\nx\nis non-negative. Allyn can end the game at any moment. The goal of the game is to get the largest possible value of the accumulator\nx\n. Please help Allyn find the largest possible value of the accumulator\nx\nthey can get in this game.\nInput\nThe first line of the input contains two integers\nx\nand\nk\n(\n0≤x≤\n10\n9\n,1≤k≤\n10\n5\n) — the initial value of the accumulator\nx\nand the number of lists. The next\nk\nlines contain the description of lists: an integer\nl\ni\n(\nl\ni\n≥1\n) followed on the same line by\nl\ni\nelements of the list in the order from left to right. Each element of lists does not exceed\n10\n9\nby the absolute value, and the total size of all lists does not exceed\n10\n5\n.\nOutput\nThe sole line of the output should contain the largest value of the accumulator\nx\nAllyn can get.\nExamples\ninput\nCopy\n1 3\n2 -1 2\n2 -2 3\n2 -3 4\noutput\nCopy\n4\ninput\nCopy\n1 2\n3 -1 -1 4\n4 1 -3 -4 8\noutput\nCopy\n4\nNote\nIn the first input, we start with\nx=1\n. Then, we can take the first integer from the first list and get\nx=0\n — adding the next integer\n2\nfrom the first list we get\nx=2\n. After that, we can add the integers from the second list and obtain\nx=3\n. Finally, we can add the integers from the third list and obtain\nx=4\n.\nIn the second input, we can add the first integer from the second list and get\nx=2\n. Then, by adding the elements from the first list, we get\nx=4\n. We cannot add more integers to increase\nx\n.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "sortings",
            "*1900"
        ]
    },
    {
        "title": "J. Two Colors",
        "description": "You are given a tree consisting of\nn\nvertices. Some vertices of the tree are red, all other vertices are blue.\nEach edge of the tree has a positive weight. Let's define\nd(x,y)\nas the distance between the vertices\nx\nand\ny\n, i. e. the sum of weights of edges belonging to the simple path between\nx\nand\ny\n.\nFor each vertex, you have to choose an integer\nv\ni\n. These integers should meet the following constraint: for every blue vertex\nb\nand every red vertex\nr\n,\nd(b,r)≥\nv\nb\n+\nv\nr\n.\nYou have to maximize the value of\n∑\ni=1\nn\nv\ni\n.\nNote that the values of\nv\ni\nare not necessarily positive.\nInput\nThe first line contains one integer\nn\n(\n2≤n≤3⋅\n10\n5\n).\nThe second line contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n0≤\nc\ni\n≤1\n). If the\ni\n-th vertex is red,\nc\ni\n=1\n, otherwise\nc\ni\n=0\n.\nThen\nn−1\nlines follow. Each line contains three integers\nx\ni\n,\ny\ni\nand\nw\ni\n(\n1≤\nx\ni\n,\ny\ni\n≤n\n;\n1≤\nw\ni\n≤\n10\n6\n;\nx\ni\n≠\ny\ni\n) denoting an edge between the vertices\nx\ni\nand\ny\ni\nwhich has weight\nw\ni\n. These edges form a tree.\nOutput\nIf the value of\n∑\ni=1\nn\nv\ni\ncan be as big as possible, print Infinity. Otherwise, print one integer — the maximum possible value of\n∑\ni=1\nn\nv\ni\nyou can get.\nExamples\ninput\nCopy\n4\n1 1 0 0\n3 4 50\n3 2 100\n2 1 100\noutput\nCopy\n350\ninput\nCopy\n6\n0 1 0 1 0 1\n1 2 1\n1 4 1\n1 6 1\n6 5 100\n6 3 100\noutput\nCopy\n203\ninput\nCopy\n3\n1 1 1\n1 2 100\n2 3 100\noutput\nCopy\nInfinity\nNote\nIn the first example, you can assign\nv\n1\n=120,\nv\n2\n=20,\nv\n3\n=80,\nv\n4\n=130\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "*2900"
        ]
    },
    {
        "title": "I. Inverse Problem",
        "description": "Consider the following problem.\nYou are given a string\ns\n, consisting of\nn\nlowercase Latin letters, and an integer\nk\n(\nn\nis not divisible by\nk\n). Each letter is one of the first\nc\nletters of the alphabet.\nYou apply the following operation until the length of the string is less than\nk\n: choose a contiguous substring of the string of length exactly\nk\n, remove it from the string and glue the resulting parts together without changing the order.\nLet the resulting string of length smaller than\nk\nbe\nt\n. What is lexicographically smallest string\nt\nthat can obtained?\nYou are asked the inverse of this problem. Given two integers\nn\nand\nk\n(\nn\nis not divisible by\nk\n) and a string\nt\n, consisting of (\nnmodk\n) lowercase Latin letters, count the number of strings\ns\nthat produce\nt\nas the lexicographically smallest solution.\nPrint that number modulo\n998244353\n.\nInput\nThe first line contains three integers\nn,k\nand\nc\n(\n1≤n≤\n10\n6\n;\n2≤k≤\n10\n6\n;\n1≤c≤26\n;\nn\nis not divisible by\nk\n) — the length of string\ns\n, the length of the substring that is being removed and the number of first letters from the alphabet.\nThe second line contains string\nt\n, consisting of exactly (\nnmodk\n) lowercase Latin letters. Each letter is one of the first\nc\nletters of the alphabet.\nOutput\nPrint a single integer — the number of strings\ns\nthat produce\nt\nas the lexicographically smallest solution.\nExamples\ninput\nCopy\n3 2 2\na\noutput\nCopy\n6\ninput\nCopy\n5 3 3\nbc\noutput\nCopy\n15\ninput\nCopy\n34 12 26\ncodeforces\noutput\nCopy\n988024123\ninput\nCopy\n5 3 1\naa\noutput\nCopy\n1\nNote\nThe strings\ns\nin the first example: \"aaa\", \"aab\", \"aba\", \"abb\", \"baa\", \"bba\".\nThe strings\ns\nin the second example: \"bcabc\", \"bcacc\", \"bcbbc\", \"bcbcc\", \"bccbc\", \"bcccc\", \"caabc\", \"cabbc\", \"cacbc\", \"cbabc\", \"cbbbc\", \"cbcbc\", \"ccabc\", \"ccbbc\", \"cccbc\".",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "combinatorics",
            "dp",
            "*2700"
        ]
    },
    {
        "title": "H. Sum of Digits of Sums",
        "description": "You are given an array\n[\na\n1\n,\na\n2\n,…,\na\nn\n]\n, consisting of positive integers.\nFor every\ni\nfrom\n1\nto\nn\n, calculate\n∑\nj=1\nn\nF(\na\ni\n+\na\nj\n)\n, where\nF(x)\nis the sum of digits of\nx\n.\nInput\nThe first line contains one integer\nn\n(\n2≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n<\n10\n9\n).\nOutput\nPrint\nn\nintegers. The\ni\n-th of them should be equal to\n∑\nj=1\nn\nF(\na\ni\n+\na\nj\n)\n.\nExamples\ninput\nCopy\n4\n1 3 3 7\noutput\nCopy\n18 17 17 15 \ninput\nCopy\n3\n42 1337 999\noutput\nCopy\n38 53 47 ",
        "time_limit": "6 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "*special problem",
            "binary search",
            "data structures",
            "*2400"
        ]
    },
    {
        "title": "G. Pool Records",
        "description": "Alice and Bob are swimming in the pool under the guidance of their instructor Monocarp.\nThe pool can be represented as a segment on the OX-axis from\n0\nto\n50\n. Both Alice and Bob started at moment\n0\nat point\n0\nwith positive real speeds\nv\nA\nand\nv\nB\ncorrespondingly.\nBoth Alice and Bob swim from\n0\nto point\n50\n, then instantly turn back and swim from\n50\nto\n0\n. At\n0\nthey turn back again and swim to\n50\nand so on.\nMonocarp logged all valuable info about Alice and Bob, including moments of time when they met at the same point (Alice and Bob swim on parallel lanes, so they don't bother each other). Let's name that moments of time as sequence\nt\n1\n,\nt\n2\n,…,\nt\nn\n.\nDue to some incident, Monocarp lost almost all data he recorded, and all he has now is array\nt\n. Monocarp remembers that Alice and Bob had distinct positive real swimming speeds\nv\nA\nand\nv\nB\n(\nv\nA\n>0\n;\nv\nB\n>0\n;\nv\nA\n≠\nv\nB\n) and that sequence\nt\ncontains the first\nn\nmeeting moments.\nBut looking at sequence\nt\nhe noticed that all\nt\ni\nare integer values, and now he doubts is sequence\nt\nvalid or there are some errors in it. Help Monocarp to check array\nt\n!\nInput\nThe first line contains a single integer\nc\n(\n1≤c≤\n10\n4\n) — the number of test cases. Then\nc\ncases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the size of array\nt\n.\nThe second line of each test case contains\nn\nintegers\nt\n1\n,\nt\n2\n,…,\nt\nn\n(\n1≤\nt\n1\n<\nt\n2\n<⋯<\nt\nn\n≤\n10\n9\n) — the meeting moments in the increasing order.\nIt's guaranteed that the sum of\nn\nover all test cases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print VALID if the array\nt\nis a valid array, or (in other words) exist such real values\nv\nA\nand\nv\nB\n(\nv\nA\n,\nv\nB\n>0\n;\nv\nA\n≠\nv\nB\n) that array\nt\ncontains the first\nn\nmeeting moments of Alice and Bob in the pool.\nOtherwise, print INVALID.\nYou can output the answer in any case (upper or lower). For example, the strings \"vALid\", \"valid\", \"Valid\", and \"VALID\" will be recognized as positive responses.\nExample\ninput\nCopy\n7\n1\n42\n4\n3 4 6 8\n5\n1 2 3 4 5\n3\n999999998 999999999 1000000000\n5\n4 6 8 12 16\n4\n6 11 12 14\n2\n10 30\noutput\nCopy\nVALID\nVALID\nVALID\nINVALID\nVALID\nINVALID\nINVALID\nNote\nIn the first test case, imagine a situation:\nv\nA\n=1\nand\nv\nB\n=\n29\n21\n. Then, at moment\n42\nAlice and Bob will be at point\n42\n.\nIn the second test case, imagine a situation:\nv\nA\n=\n175\n6\nand\nv\nB\n=\n25\n6\n. Then, at moment\n3\nAlice and Bob will meet at point\n12.5\n, at\n4\nthey'll meet at point\n50\n3\n, at moment\n6\nthey'll meet at\n25\nand at moment\n8\n — at point\n100\n3\n. Since it's exactly the first\n4\nmeeting moments. Array\nt\nmay be valid.\nIn the third test case, one of the possible situations is\nv\nA\n=25\nand\nv\nB\n=75\n.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "greedy",
            "*2700"
        ]
    },
    {
        "title": "F. Build Railway Stations",
        "description": "Monocarp is playing a computer game where he's controlling an empire. An empire consists of\nn\ncities, connected by\nn−1\nroads. The cities are numbered from\n1\nto\nn\n. It's possible to reach every city from every other one using the roads.\nTraversing every road takes\n2\nhours. However, that can be improved. Monocarp can build railway stations in no more than\nk\ncities. After they are built, all existing roads that connect two cities with railway stations get converted to railroads and become\n1\nhour to traverse.\nLet\nf(x,y)\nbe the total time it takes to traverse the roads on the shortest path between cities\nx\nand\ny\n.\nMonocarp wants to build at most\nk\nrailway stations in such a way that the following value is minimized:\n∑\nv=1\nn\n∑\nu=1\nv−1\nf(v,u)\n(the total time it takes to travel from every city to every other one). What the smallest value he can achieve?\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains two integers\nn\nand\nk\n(\n2≤k≤n≤2⋅\n10\n5\n) — the number of cities and the maximum number of railway stations Monocarp can build.\nEach of the following\nn−1\nlines contains two integers\nv\nand\nu\n(\n1≤v,u≤n\n;\nv≠u\n) — a road that connects cities\nv\nand\nu\n.\nIt's possible to reach every city from every other one using the roads. The sum of\nn\nover all testcases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print a single integer — the smallest total time it takes to travel from every city to every other one that Monocarp can achieve after building at most\nk\nrailway stations.\nExample\ninput\nCopy\n3\n5 2\n1 2\n2 3\n3 4\n4 5\n4 4\n1 2\n1 3\n1 4\n5 3\n1 2\n1 3\n2 4\n2 5\noutput\nCopy\n34\n9\n26",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "greedy",
            "trees",
            "*2000"
        ]
    },
    {
        "title": "E. Maximum Sum Subarrays",
        "description": "You are given two integer arrays\na\nand\nb\n, both of length\nn\n.\nYou can perform the following operation any number of times (possibly zero): swap\na\ni\nand\nb\ni\n.\nLet\nf(c)\nbe the maximum sum of a contiguous subarray of the array\nc\n(including the empty subsegment, which sum is\n0\n).\nYour task is to calculate the maximum possible value of\nf(a)+f(b)\n, using the aforementioned operation any number of times.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n).\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−\n10\n9\n≤\na\ni\n≤\n10\n9\n).\nThe third line contains\nn\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nn\n(\n−\n10\n9\n≤\nb\ni\n≤\n10\n9\n).\nThe sum of\nn\nover all test case doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, print a single integer — the maximum possible value of\nf(a)+f(b)\n, using the aforementioned operation any number of times.\nExample\ninput\nCopy\n3\n3\n2 -1 3\n-4 0 1\n6\n4 2 -6 1 6 -4\n-6 -2 -3 7 -3 2\n2\n-2 -5\n0 -1\noutput\nCopy\n6\n21\n0",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*2100"
        ]
    },
    {
        "title": "D. Remove and Add",
        "description": "You are given an array\na\n1\n,\na\n2\n,…,\na\nn\n, consisting of\nn\nintegers.\nYou goal is to make is strictly increasing. To achieve that, you perform each of the following operations exactly once:\nfirst, remove any element;\nsecond, select any number of elements (possibly, none or all\nn−1\n) and add\n1\nto them.\nNote that you are not allowed to rearrange the elements of the array.\nFor the resulting array\na\n′\n,\na\n′\n1\n<\na\n′\n2\n<⋯<\na\n′\nn−1\nshould hold. Determine if it's possible to achieve that.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of each testcase contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the number of elements of the array.\nThe second line contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n6\n).\nThe sum of\nn\nover all testcases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print YES if it's possible to remove one element and add\n1\nto some elements (possibly, none or all), so that the array becomes strictly increasing. Otherwise, print NO.\nExample\ninput\nCopy\n8\n4\n4 4 1 5\n5\n4 4 1 5 5\n2\n10 5\n3\n1 2 3\n3\n2 1 1\n4\n1 1 1 1\n4\n1 3 1 2\n5\n1 1 3 3 1\noutput\nCopy\nYES\nNO\nYES\nYES\nYES\nNO\nYES\nYES\nNote\nIn the first testcase, you can remove the third element and add\n1\nto the second and the last element.\na\n′\nwill become\n[4,5,6]\n, which is strictly increasing.\nIn the second testcase, there is no way to perform the operations, so that the result is strictly increasing.\nIn the third testcase, you can remove either of the elements.\nIn the fourth testcase, you are already given a strictly increasing array, but you still have to remove an element. The result\na\n′\ncan be\n[1,3]\n, for example.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "greedy",
            "*1800"
        ]
    },
    {
        "title": "C. Poisonous Swamp",
        "description": "The first location in the brand new critically acclaimed fantasy action RPG \"Ancient Staff\" is a poisonous swamp. The swamp has some lily pads growing in it. It can be represented as a\n2×n\ngrid (\n2\nrows and\nn\ncolumns), where each cell is either empty or has a lily pad in it.\nThere are exactly\nn\nlily pads in a swamp — one in each column. A frog is sitting on top of every lily pad. In one move, every frog must jump to an adjacent by a side cell.\nAfter the move, no frog can be outside the grid and no two frogs can share the same lily pad. Two frogs from adjacent cells can't jump towards each other (i.e. swap cells).\nIf a frog jumps to a lily pad, it survives. Otherwise, it falls into a poisonous swamp and gets devoured by an eldritch creature living on its bottom.\nYou can choose the direction each frogs jumps at. Determine the maximum number of frogs that can survive after one move.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of testcases.\nThe first line of the testcase contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the number of columns in a swamp grid.\nEach of the following two lines contains a description of a row of a swamp — a string, consisting of exactly\nn\ncharacters. Each character is either a dot ('.'), denoting a swamp cell, or an asterisk ('*'), denoting a lily pad with a frog.\nIn each column, there is exactly one dot and exactly one asterisk. The sum of\nn\nover all testcases doesn't exceed\n2⋅\n10\n5\n.\nOutput\nFor each testcase, print a single integer — the maximum number of frogs that can survive after one move, if you choose the direction each frogs jumps at.\nExample\ninput\nCopy\n3\n5\n*..**\n.**..\n1\n*\n.\n3\n...\n***\noutput\nCopy\n2\n0\n2\nNote\nThe\ni\n-th frog is the frog on the lily pad in the\ni\n-th column.\nIn the first testcase:\nthe first frog can't survive because there's no adjacent lily pad;\nthe second and the third frogs can jump right and up, respectively, — there's no way to save them both at the same time;\nthe fourth and the fifth frogs can jump left and left, respectively, — there's no way to save them both at the same time; note, however, that the third and the fourth frogs will end up in the same cell in the swamp, which is not prohibited.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "*special problem",
            "implementation",
            "implementation",
            "*1600"
        ]
    },
    {
        "title": "B. Security Guard",
        "description": "Monocarp is a security guard in Berland State University. Every day, he tracks how many people and at what time enter and leave the university. He writes this information down as follows:\nwhen someone enters the university, Monocarp writes a plus sign '+';\nwhen someone leaves the university, Monocarp writes a minus sign '-'.\nAt the beginning of the current day, there are no people at the university, except for Monocarp. During the day, Monocarp wrote out a sequence\ns\n. The characters in\ns\nare listed in the order Monocarp wrote them.\nSuddenly, Monocarp's boss decided to check his work. Unfortunately, Monocarp is a bit careless. So, the sequence\ns\nthat he wrote might be impossible. For example, the sequence \"+--\" can't happen, since it represents a scenario when one person enters the university and two leave.\nBefore his boss starts checking the sequence, Monocarp has the time to swap at most one pair of characters in it. Can he do it in such a way that the resulting sequence is plausible? Note that if the given sequence is already plausible, Monocarp doesn't have to swap anything.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases.\nThe only line of each test case contains a single string\ns\n(\n1≤|s|≤3⋅\n10\n5\n), consisting only of characters '+' and/or '-'. A plus sign '+' represents a person entering the university. A minus sign '-' represents a person leaving the university.\nThe sum of all\n|s|\nover all test cases doesn't exceed\n3⋅\n10\n5\n.\nOutput\nFor each test case, print an answer.\nIf it's impossible to swap at most one pair of characters so that the resulting sequence is plausible, print -1.\nOtherwise, print two integers. If you swap one pair of characters, print two distinct integers from\n1\nto\nn\n — the indices of characters to swap. If you don't swap, print one integer from\n1\nto\nn\ntwice — swap a character with itself.\nIf there are multiple answers, print any of them.\nExample\ninput\nCopy\n6\n-+\n+-\n+++-\n---++\n+\n-\noutput\nCopy\n1 2\n1 1\n1 1\n-1\n1 1\n-1",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "greedy",
            "*1600"
        ]
    },
    {
        "title": "A. Username",
        "description": "On the official website of Berland, each account has two parameters: username and ID.\nUsername is a string consisting of lowercase Latin letters and/or digits, which contains at least one letter. For example, user0, 1fox1, zzzz are correct usernames, but 1337 and User22 are not.\nThe ID of the account for a given username is generated as follows: a positive integer without leading zeroes is appended to the end of the username. For example, the ID user0125 can be generated by the following usernames: user012, user01, user0; but neither by user nor us.\nYou are given a string\ns\n — a valid ID. Your task is to determine any valid username that can generate the given ID. If there are several correct usernames, you can print any of them.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases.\nThe only line of each test case contains a string\ns\n(\n2≤|s|≤50\n), consisting of lowercase Latin letters and/or digits.\nAdditional constraint on input: there is at least one valid username that can generate the given ID.\nOutput\nFor each test case on a separate line, print a string — any valid username that can generate the given ID. If there are multiple correct usernames, you can print any of them.\nExample\ninput\nCopy\n4\nuser0125\na1\nkotlin990000\n1code0forces101\noutput\nCopy\nuser0\na\nkotlin9\n1code0forces",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "*special problem",
            "implementation",
            "*1100"
        ]
    },
    {
        "title": "I. Short Permutation Problem",
        "description": "Xomu - Last Dance\n⠀\nYou are given an integer\nn\n.\nFor each\n(m,k)\nsuch that\n3≤m≤n+1\nand\n0≤k≤n−1\n, count the permutations of\n[1,2,...,n]\nsuch that\np\ni\n+\np\ni+1\n≥m\nfor exactly\nk\nindices\ni\n, modulo\n998244353\n.\nInput\nThe input consists of a single line, which contains two integers\nn\n,\nx\n(\n2≤n≤4000\n,\n1≤x<1000000007\n).\nOutput\nLet\na\nm,k\nbe the answer for the pair\n(m,k)\n, modulo\n998244353\n.\nLet\nS=\n∑\nm=3\nn+1\n∑\nk=0\nn−1\na\nm,k\nx\nmn+k\n.\n+\n1\n1\nOutput a single line with an integer:\nS\nmodulo\n1000000007\n.\nNote that using two different modulos is intentional. We want you to calculate all the\na\nm,k\nmodulo\n998244353\n, then treat them like integers in the range\n[0,998244352]\n, and hash them modulo\n1000000007\n.\nExamples\ninput\nCopy\n3 2\noutput\nCopy\n77824\ninput\nCopy\n4 1000000000\noutput\nCopy\n30984329\ninput\nCopy\n8 327869541\noutput\nCopy\n85039220\ninput\nCopy\n4000 1149333\noutput\nCopy\n584870166\nNote\nIn the first test case, the answers for all\n(m,k)\nare shown in the following table:\nk=0\nk=1\nk=2\nm=3\n0\n0\n6\nm=4\n0\n4\n2\nThe answer for\n(m,k)=(3,2)\nis\n6\n, because for every permutation of length\n3\n,\na\ni\n+\na\ni+1\n≥3\nexactly\n2\ntimes.\nThe answer for\n(m,k)=(4,2)\nis\n2\n. In fact, there are\n2\npermutations of length\n3\nsuch that\na\ni\n+\na\ni+1\n≥4\nexactly\n2\ntimes:\n[1,3,2]\n,\n[2,3,1]\n.\nTherefore, the value to print is\n2\n9\n⋅0+\n2\n10\n⋅0+\n2\n11\n⋅6+\n2\n12\n⋅0+\n2\n13\n⋅4+\n2\n14\n⋅2≡77824(mod1000000007)\n.\nIn the second test case, the answers for all\n(m,k)\nare shown in the following table:\nk=0\nk=1\nk=2\nk=3\nm=3\n0\n0\n0\n24\nm=4\n0\n0\n12\n12\nm=5\n0\n4\n16\n4\nThe answer for\n(m,k)=(5,1)\nis\n4\n. In fact, there are\n4\npermutations of length\n4\nsuch that\na\ni\n+\na\ni+1\n≥5\nexactly\n1\ntime:\n[2,1,3,4]\n,\n[3,1,2,4]\n,\n[4,2,1,3]\n,\n[4,3,1,2]\n.\nIn the third test case, the answers for all\n(m,k)\nare shown in the following table:\nk=0\nk=1\nk=2\nk=3\nk=4\nk=5\nk=6\nk=7\nm=3\n0\n0\n0\n0\n0\n0\n0\n40320\nm=4\n0\n0\n0\n0\n0\n0\n10080\n30240\nm=5\n0\n0\n0\n0\n0\n1440\n17280\n21600\nm=6\n0\n0\n0\n0\n480\n8640\n21600\n9600\nm=7\n0\n0\n0\n96\n3456\n16416\n16896\n3456\nm=8\n0\n0\n48\n2160\n12960\n18240\n6480\n432\nm=9\n0\n16\n1152\n9648\n18688\n9648\n1152\n16",
        "time_limit": "7 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "fft",
            "math",
            "*1900"
        ]
    },
    {
        "title": "H. Parallel Swaps Sort",
        "description": "Dubmood - Keygen 8\n⠀\nYou are given a permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\n. You can perform the following operation some (possibly\n0\n) times:\nchoose a subarray\n[l,r]\nof even length;\nswap\na\nl\n,\na\nl+1\n;\nswap\na\nl+2\n,\na\nl+3\n(if\nl+3≤r\n);\n…\nswap\na\nr−1\n,\na\nr\n.\nSort the permutation in at most\n10\n6\noperations. You do not need to minimize the number of operations.\nInput\nThe first line contains a single integer\nn\n(\n2≤n≤3⋅\n10\n5\n) — the length of the permutation.\nThe second line contains\nn\nintegers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n, the\np\ni\nare distinct) — the permutation before performing the operations.\nOutput\nOutput your operations in the following format.\nThe first line should contain an integer\nk\n(\n0≤k≤\n10\n6\n) — the number of operations.\nThe next\nk\nlines represent the\nk\noperations in order. Each of these\nk\nlines should contain two integers\nl\nand\nr\n(\n1≤l<r≤n\n,\nr−l+1\nmust be even) — the corresponding operation consists in choosing the subarray\n[l,r]\nand swapping its elements according to the problem statement.\nAfter all the operations,\na\ni\n=i\nmust be true for each\ni\n(\n1≤i≤n\n).\nExamples\ninput\nCopy\n5\n2 5 4 1 3\noutput\nCopy\n5\n1 4\n1 2\n2 5\n1 4\n4 5\ninput\nCopy\n9\n1 2 3 4 5 6 7 8 9\noutput\nCopy\n0\ninput\nCopy\n10\n6 4 2 3 8 10 9 1 5 7\noutput\nCopy\n15\n1 8\n6 9\n1 8\n3 10\n1 10\n1 10\n1 6\n6 9\n6 9\n2 7\n9 10\n5 10\n1 6\n2 9\n1 10\nNote\nIn the first test:\nAt the beginning,\np=[2,5,4,1,3]\n.\nIn the first operation, you can choose\n[l,r]=[1,4]\n. Then,\n(\na\n1\n,\na\n2\n)\nare swapped and\n(\na\n3\n,\na\n4\n)\nare swapped. The new permutation is\np=[5,2,1,4,3]\n.\nIn the second operation, you can choose\n[l,r]=[1,2]\n. Then,\n(\na\n1\n,\na\n2\n)\nare swapped. The new permutation is\np=[2,5,1,4,3]\n.\nIn the third operation, you can choose\n[l,r]=[2,5]\n. Then,\n(\na\n2\n,\na\n3\n)\nare swapped and\n(\na\n4\n,\na\n5\n)\nare swapped. The new permutation is\np=[2,1,5,3,4]\n.\nIn the fourth operation, you can choose\n[l,r]=[1,4]\n. Then,\n(\na\n1\n,\na\n2\n)\nare swapped and\n(\na\n3\n,\na\n4\n)\nare swapped. The new permutation is\np=[1,2,3,5,4]\n.\nIn the fifth operation, you can choose\n[l,r]=[4,5]\n. Then,\n(\na\n4\n,\na\n5\n)\nare swapped. The new permutation is\np=[1,2,3,4,5]\n, which is sorted.\nIn the second test, the permutation is already sorted, so you do not need to perform any operation.",
        "time_limit": "7 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "*3500"
        ]
    },
    {
        "title": "G. Pumping Lemma",
        "description": "Tanchiky & Siromaru - Crystal Gravity\n⠀\nYou are given two strings\ns\n,\nt\nof length\nn\n,\nm\n, respectively. Both strings consist of lowercase letters of the English alphabet.\nCount the triples\n(x,y,z)\nof strings such that the following conditions are true:\ns=x+y+z\n(the symbol\n+\nrepresents the concatenation);\nt=x+\ny+⋯+y\n\n\n\n\n\n\n\n\n\n\n\nk times\n+z\nfor some integer\nk\n.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n1≤n<m≤\n10\n7\n) — the length of the strings\ns\nand\nt\n, respectively.\nThe second line contains the string\ns\nof length\nn\n, consisting of lowercase letters of the English alphabet.\nThe third line contains the string\nt\nof length\nm\n, consisting of lowercase letters of the English alphabet.\nOutput\nOutput a single integer: the number of valid triples\n(x,y,z)\n.\nExamples\ninput\nCopy\n4 8\nabcd\nabcbcbcd\noutput\nCopy\n1\ninput\nCopy\n3 5\naaa\naaaaa\noutput\nCopy\n5\ninput\nCopy\n12 16\nabbababacaab\nabbababababacaab\noutput\nCopy\n8\nNote\nIn the first test case, the only valid triple is\n(x,y,z)=(\"a\",\"bc\",\"d\")\n. In fact,\n\"abcd\"=\"a\"+\"bc\"+\"d\"\n;\n\"abcbcbcd\"=\"a\"+\"bc\"+\"bc\"+\"bc\"+\"d\"\n.\nIn the second test case, there are\n5\nvalid triples:\n(x,y,z)=(\"\",\"a\",\"aa\")\n;\n(x,y,z)=(\"\",\"aa\",\"a\")\n;\n(x,y,z)=(\"a\",\"a\",\"a\")\n;\n(x,y,z)=(\"a\",\"aa\",\"\")\n;\n(x,y,z)=(\"aa\",\"a\",\"\")\n.\nIn the third test case, there are\n8\nvalid triples:\n(x,y,z)=(\"ab\",\"ba\",\"babacaab\")\n;\n(x,y,z)=(\"abb\",\"ab\",\"abacaab\")\n;\n(x,y,z)=(\"abba\",\"ba\",\"bacaab\")\n;\n(x,y,z)=(\"ab\",\"baba\",\"bacaab\")\n;\n(x,y,z)=(\"abbab\",\"ab\",\"acaab\")\n;\n(x,y,z)=(\"abb\",\"abab\",\"acaab\")\n;\n(x,y,z)=(\"abbaba\",\"ba\",\"caab\")\n;\n(x,y,z)=(\"abba\",\"baba\",\"caab\")\n.",
        "time_limit": "2 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "hashing",
            "strings",
            "*3000"
        ]
    },
    {
        "title": "F2. Small Permutation Problem (Hard Version)",
        "description": "Andy Tunstall - MiniBoss\n⠀\nIn the easy version, the\na\ni\nare in the range\n[0,n]\n; in the hard version, the\na\ni\nare in the range\n[−1,n]\nand the definition of good permutation is slightly different. You can make hacks only if all versions of the problem are solved.\nYou are given an integer\nn\nand an array\na\n1\n,\na\n2\n,…,\na\nn\nof integers in the range\n[−1,n]\n.\nA permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\nis good if, for each\ni\n, the following condition is true:\nif\na\ni\n≠−1\n, the number of values\n≤i\nin\n[\np\n1\n,\np\n2\n,…,\np\ni\n]\nis exactly\na\ni\n.\nCount the good permutations of\n[1,2,…,n]\n, modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n−1≤\na\ni\n≤n\n), which describe the conditions for a good permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing the number of good permutations, modulo\n998244353\n.\nExample\ninput\nCopy\n10\n5\n-1 -1 -1 -1 -1\n5\n1 2 3 4 5\n6\n0 2 2 2 -1 -1\n6\n-1 -1 -1 -1 -1 5\n6\n-1 -1 3 2 -1 -1\n15\n0 0 -1 -1 -1 2 2 -1 -1 -1 -1 9 11 13 15\n6\n0 2 2 2 4 6\n6\n0 1 3 4 5 5\n6\n1 2 3 2 4 6\n15\n0 0 1 1 1 2 3 4 5 6 7 9 11 13 15\noutput\nCopy\n120\n1\n4\n0\n0\n494403526\n4\n0\n0\n532305727\nNote\nIn the first test case, all the permutations of length\n5\nare good, so there are\n120\ngood permutations.\nIn the second test case, the only good permutation is\n[1,2,3,4,5]\n.\nIn the third test case, there are\n4\ngood permutations:\n[2,1,5,6,3,4]\n,\n[2,1,5,6,4,3]\n,\n[2,1,6,5,3,4]\n,\n[2,1,6,5,4,3]\n. For example,\n[2,1,5,6,3,4]\nis good because:\na\n1\n=0\n, and there are\n0\nvalues\n≤1\nin\n[\np\n1\n]=[2]\n;\na\n2\n=2\n, and there are\n2\nvalues\n≤2\nin\n[\np\n1\n,\np\n2\n]=[2,1]\n;\na\n3\n=2\n, and there are\n2\nvalues\n≤3\nin\n[\np\n1\n,\np\n2\n,\np\n3\n]=[2,1,5]\n;\na\n4\n=2\n, and there are\n2\nvalues\n≤4\nin\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n]=[2,1,5,6]\n;\na\n5\n=−1\n, so there are no restrictions on\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n,\np\n5\n]\n;\na\n6\n=−1\n, so there are no restrictions on\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n,\np\n5\n,\np\n6\n]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*2500"
        ]
    },
    {
        "title": "F1. Small Permutation Problem (Easy Version)",
        "description": "Andy Tunstall - MiniBoss\n⠀\nIn the easy version, the\na\ni\nare in the range\n[0,n]\n; in the hard version, the\na\ni\nare in the range\n[−1,n]\nand the definition of good permutation is slightly different. You can make hacks only if all versions of the problem are solved.\nYou are given an integer\nn\nand an array\na\n1\n,\na\n2\n…,\na\nn\nof integers in the range\n[0,n]\n.\nA permutation\np\n1\n,\np\n2\n,…,\np\nn\nof\n[1,2,…,n]\nis good if, for each\ni\n, the following condition is true:\nthe number of values\n≤i\nin\n[\np\n1\n,\np\n2\n,…,\np\ni\n]\nis exactly\na\ni\n.\nCount the good permutations of\n[1,2,…,n]\n, modulo\n998244353\n.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n0≤\na\ni\n≤n\n), which describe the conditions for a good permutation.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing the number of good permutations, modulo\n998244353\n.\nExample\ninput\nCopy\n5\n5\n1 2 3 4 5\n6\n0 2 2 2 4 6\n6\n0 1 3 4 5 5\n6\n1 2 3 2 4 6\n15\n0 0 1 1 1 2 3 4 5 6 7 9 11 13 15\noutput\nCopy\n1\n4\n0\n0\n532305727\nNote\nIn the first test case, the only good permutation is\n[1,2,3,4,5]\n.\nIn the second test case, there are\n4\ngood permutations:\n[2,1,5,6,3,4]\n,\n[2,1,5,6,4,3]\n,\n[2,1,6,5,3,4]\n,\n[2,1,6,5,4,3]\n. For example,\n[2,1,5,6,3,4]\nis good because:\na\n1\n=0\n, and there are\n0\nvalues\n≤1\nin\n[\np\n1\n]=[2]\n;\na\n2\n=2\n, and there are\n2\nvalues\n≤2\nin\n[\np\n1\n,\np\n2\n]=[2,1]\n;\na\n3\n=2\n, and there are\n2\nvalues\n≤3\nin\n[\np\n1\n,\np\n2\n,\np\n3\n]=[2,1,5]\n;\na\n4\n=2\n, and there are\n2\nvalues\n≤4\nin\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n]=[2,1,5,6]\n;\na\n5\n=4\n, and there are\n4\nvalues\n≤5\nin\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n,\np\n5\n]=[2,1,5,6,3]\n;\na\n6\n=6\n, and there are\n6\nvalues\n≤6\nin\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n,\np\n5\n,\np\n6\n]=[2,1,5,6,3,4]\n.\nIn the third test case, there are no good permutations, because there are no permutations with\na\n6\n=5\nvalues\n≤6\nin\n[\np\n1\n,\np\n2\n,\np\n3\n,\np\n4\n,\np\n5\n,\np\n6\n]\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "dp",
            "math",
            "*2200"
        ]
    },
    {
        "title": "E. Multiple Lamps",
        "description": "Kid2Will - Fire Aura\n⠀\nYou have\nn\nlamps, numbered from\n1\nto\nn\n. Initially, all the lamps are turned off.\nYou also have\nn\nbuttons. The\ni\n-th button toggles all the lamps whose index is a multiple of\ni\n. When a lamp is toggled, if it was off it turns on, and if it was on it turns off.\nYou have to press some buttons according to the following rules.\nYou have to press at least one button.\nYou cannot press the same button multiple times.\nYou are given\nm\npairs\n(\nu\ni\n,\nv\ni\n)\n. If you press the button\nu\ni\n, you also have to press the button\nv\ni\n(at any moment, not necessarily after pressing the button\nu\ni\n). Note that, if you press the button\nv\ni\n, you don't need to press the button\nu\ni\n.\nYou don't want to waste too much electricity. Find a way to press buttons such that at the end at most\n⌊n/5⌋\nlamps are on, or print\n−1\nif it is impossible.\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\nand\nm\n(\n1≤n≤2⋅\n10\n5\n,\n0≤m≤2⋅\n10\n5\n) — the number of lamps and the number of pairs, respectively.\nEach of the next\nm\nlines contains two integers\nu\ni\n,\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n\n,\nu\ni\n≠\nv\ni\n). If you press the button\nu\ni\n, you also have to press the button\nv\ni\n. It is guaranteed that the pairs\n(\nu\ni\n,\nv\ni\n)\nare distinct.\nIt is guaranteed that the sum of\nn\nand the sum of\nm\nover all test cases do not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case:\nIf there is no choice of buttons that makes at most\n⌊n/5⌋\nlamps on at the end, output a single line containing\n−1\n.\nOtherwise, output two lines. The first line should contain an integer\nk\n(\n1≤k≤n\n) — the number of pressed buttons. The second line should contain\nk\nintegers\nb\n1\n,\nb\n2\n,…,\nb\nk\n(\n1≤\nb\ni\n≤n\n) — the indices of the pressed buttons (in any order). The\nb\ni\nmust be distinct, and at the end at most\n⌊n/5⌋\nlamps must be turned on.\nExample\ninput\nCopy\n4\n4 0\n5 2\n4 1\n5 1\n15 9\n7 8\n8 9\n9 10\n10 9\n11 1\n12 2\n13 3\n14 4\n15 5\n5 4\n1 2\n2 3\n3 4\n4 5\noutput\nCopy\n-1\n4\n3 5 1 2\n3\n8 9 10\n1\n5\nNote\nIn the first test case, you need to turn at most\n⌊4/5⌋\nlamps on, which means that no lamp can be turned on. You can show that no choice of at least one button turns\n0\nlamps on.\nIn the second test case, you can press buttons\n3\n,\n5\n,\n1\n,\n2\n.\nInitially, all the lamps are off;\nafter pressing button\n3\n, the lamps whose index is a multiple of\n3\n(i.e.,\n3\n) are toggled, so lamp\n3\nis turned on;\nafter pressing button\n5\n, the lamps whose index is a multiple of\n5\n(i.e.,\n5\n) are toggled, so lamps\n3\n,\n5\nare turned on;\nafter pressing button\n1\n, the lamps whose index is a multiple of\n1\n(i.e.,\n1\n,\n2\n,\n3\n,\n4\n,\n5\n) are toggled, so lamps\n1\n,\n2\n,\n4\nare turned on;\nafter pressing button\n2\n, the lamps whose index is a multiple of\n2\n(i.e.,\n2\n,\n4\n) are toggled, so lamp\n1\nis turned on.\nThis is valid because\nyou pressed at least one button;\nyou pressed all the buttons at most once;\nyou pressed button\nu\n2\n=5\n, which means that you had to also press button\nv\n2\n=1\n: in fact, button\n1\nhas been pressed;\nat the end, only lamp\n1\nis on.\nIn the third test case, pressing the buttons\n8\n,\n9\n,\n10\nturns only the lamps\n8\n,\n9\n,\n10\non.",
        "time_limit": "3 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "math",
            "number theory",
            "*2400"
        ]
    },
    {
        "title": "D. Split Plus K",
        "description": "eliteLAQ - Desert Ruins\n⠀\nThere are\nn\npositive integers\na\n1\n,\na\n2\n,…,\na\nn\non a blackboard. You are also given a positive integer\nk\n. You can perform the following operation some (possibly\n0\n) times:\nchoose a number\nx\non the blackboard;\nerase one occurrence of\nx\n;\nwrite two positive integers\ny\n,\nz\nsuch that\ny+z=x+k\non the blackboard.\nIs it possible to make all the numbers on the blackboard equal? If yes, what is the minimum number of operations you need?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains two integers\nn\n,\nk\n(\n1≤n≤2⋅\n10\n5\n,\n1≤k≤\n10\n12\n) — the number of integers initially on the blackboard and the constant\nk\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n12\n) — the initial state of the blackboard.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single line containing an integer: the minimum number of operations you need to make all the numbers on the blackboard equal, or\n−1\nif it is impossible.\nExample\ninput\nCopy\n9\n2 1\n3 4\n2 3\n7 11\n3 10\n100 40 100\n2 1\n1 2\n2 2\n1 2\n1 327869541\n327869541\n5 26250314066\n439986238782 581370817372 409476934981 287439719777 737637983182\n5 616753575719\n321037808624 222034505841 214063039282 441536506916 464097941819\n5 431813672576\n393004301966 405902283416 900951084746 672201172466 518769038906\noutput\nCopy\n3\n1\n4\n-1\n-1\n0\n3119\n28999960732\n-1\nNote\nIn the first test case,\nk=1\n. You can make all the numbers on the blackboard equal to\n2\nwith the following operations:\nErase\nx=4\nand write\n(y,z)=(2,3)\n. Note that\ny+z=x+k\n. The blackboard now contains the multiset\n{3,2,3}\n.\nErase\nx=3\nand write\n(y,z)=(2,2)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{2,2,2,3}\n.\nErase\nx=3\nand write\n(y,z)=(2,2)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{2,2,2,2,2}\n.\nThis makes all the numbers equal in\n3\noperations. It can be shown that you cannot make all the numbers equal in less than\n3\noperations.\nIn the second test case,\nk=3\n. You can make all the numbers on the blackboard equal to\n7\nwith the following operation:\nErase\nx=11\nand write\n(y,z)=(7,7)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{7,7,7}\n.\nIn the third test case,\nk=10\n. You can make all the numbers on the blackboard equal to\n40\nwith the following operations:\nErase\nx=100\nand write\n(y,z)=(70,40)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{70,40,40,100}\n.\nErase\nx=70\nand write\n(y,z)=(40,40)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{40,40,40,40,100}\n.\nErase\nx=100\nand write\n(y,z)=(40,70)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{40,40,40,40,40,70}\n.\nErase\nx=70\nand write\n(y,z)=(40,40)\n. Note that\ny+z=x+k\n. The blackboard now contains\n{40,40,40,40,40,40,40}\n.\nIn the fourth and in the fifth test case, you can show that it is impossible to make all the numbers on the blackboard equal.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1900"
        ]
    },
    {
        "title": "C. Heavy Intervals",
        "description": "Shiki - Pure Ruby\n⠀\nYou have\nn\nintervals\n[\nl\n1\n,\nr\n1\n],[\nl\n2\n,\nr\n2\n],…,[\nl\nn\n,\nr\nn\n]\n, such that\nl\ni\n<\nr\ni\nfor each\ni\n, and all the endpoints of the intervals are distinct.\nThe\ni\n-th interval has weight\nc\ni\nper unit length. Therefore, the weight of the\ni\n-th interval is\nc\ni\n⋅(\nr\ni\n−\nl\ni\n)\n.\nYou don't like large weights, so you want to make the sum of weights of the intervals as small as possible. It turns out you can perform all the following three operations:\nrearrange the elements in the array\nl\nin any order;\nrearrange the elements in the array\nr\nin any order;\nrearrange the elements in the array\nc\nin any order.\nHowever, after performing all of the operations, the intervals must still be valid (i.e., for each\ni\n,\nl\ni\n<\nr\ni\nmust hold).\nWhat's the minimum possible sum of weights of the intervals after performing the operations?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤\n10\n4\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n5\n) — the number of intervals.\nThe second line of each test case contains\nn\nintegers\nl\n1\n,\nl\n2\n,…,\nl\nn\n(\n1≤\nl\ni\n≤2⋅\n10\n5\n) — the left endpoints of the initial intervals.\nThe third line of each test case contains\nn\nintegers\nr\n1\n,\nr\n2\n,…,\nr\nn\n(\nl\ni\n<\nr\ni\n≤2⋅\n10\n5\n) — the right endpoints of the initial intervals.\nIt is guaranteed that\n{\nl\n1\n,\nl\n2\n,…,\nl\nn\n,\nr\n1\n,\nr\n2\n,…,\nr\nn\n}\nare all distinct.\nThe fourth line of each test case contains\nn\nintegers\nc\n1\n,\nc\n2\n,…,\nc\nn\n(\n1≤\nc\ni\n≤\n10\n7\n) — the initial weights of the intervals per unit length.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer: the minimum possible sum of weights of the intervals after your operations.\nExample\ninput\nCopy\n2\n2\n8 3\n12 23\n100 100\n4\n20 1 2 5\n30 4 3 10\n2 3 2 3\noutput\nCopy\n2400\n42\nNote\nIn the first test case, you can make\nl=[8,3]\n;\nr=[23,12]\n;\nc=[100,100]\n.\nIn that case, there are two intervals:\ninterval\n[8,23]\nwith weight\n100\nper unit length, and\n100⋅(23−8)=1500\nin total;\ninterval\n[3,12]\nwith weight\n100\nper unit length, and\n100⋅(12−3)=900\nin total.\nThe sum of the weights is\n2400\n. It can be shown that there is no configuration of final intervals whose sum of weights is less than\n2400\n.\nIn the second test case, you can make\nl=[1,2,5,20]\n;\nr=[3,4,10,30]\n;\nc=[3,3,2,2]\n.\nIn that case, there are four intervals:\ninterval\n[1,3]\nwith weight\n3\nper unit length, and\n3⋅(3−1)=6\nin total;\ninterval\n[2,4]\nwith weight\n3\nper unit length, and\n3⋅(4−2)=6\nin total;\ninterval\n[5,10]\nwith weight\n2\nper unit length, and\n2⋅(10−5)=10\nin total;\ninterval\n[20,30]\nwith weight\n2\nper unit length, and\n2⋅(30−20)=20\nin total.\nThe sum of the weights is\n42\n. It can be shown that there is no configuration of final intervals whose sum of weights is less than\n42\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dsu",
            "greedy",
            "math",
            "sortings",
            "*1400"
        ]
    },
    {
        "title": "B. Make Almost Equal With Mod",
        "description": "xi - Solar Storm\n⠀\nYou are given an array\na\n1\n,\na\n2\n,…,\na\nn\nof distinct positive integers. You have to do the following operation exactly once:\nchoose a positive integer\nk\n;\nfor each\ni\nfrom\n1\nto\nn\n, replace\na\ni\nwith\na\ni\n mod \nk\n†\n.\nFind a value of\nk\nsuch that\n1≤k≤\n10\n18\nand the array\na\n1\n,\na\n2\n,…,\na\nn\ncontains exactly\n2\ndistinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such\nk\nalways exists. If there are multiple solutions, you can print any of them.\n†\n†\na mod b\ndenotes the remainder after dividing\na\nby\nb\n. For example:\n7 mod 3=1\nsince\n7=3⋅2+1\n15 mod 4=3\nsince\n15=4⋅3+3\n21 mod 1=0\nsince\n21=21⋅1+0\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤500\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤100\n) — the length of the array\na\n.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n17\n) — the initial state of the array. It is guaranteed that all the\na\ni\nare distinct.\nNote that there are no constraints on the sum of\nn\nover all test cases.\nOutput\nFor each test case, output a single integer: a value of\nk\n(\n1≤k≤\n10\n18\n) such that the array\na\n1\n,\na\n2\n,…,\na\nn\ncontains exactly\n2\ndistinct values at the end of the operation.\nExample\ninput\nCopy\n5\n4\n8 15 22 30\n5\n60 90 98 120 308\n6\n328 769 541 986 215 734\n5\n1000 2000 7000 11000 16000\n2\n2 1\noutput\nCopy\n7\n30\n3\n5000\n1000000000000000000\nNote\nIn the first test case, you can choose\nk=7\n. The array becomes\n[8 mod 7,15 mod 7,22 mod 7,30 mod 7]=[1,1,1,2]\n, which contains exactly\n2\ndistinct values (\n{1,2}\n).\nIn the second test case, you can choose\nk=30\n. The array becomes\n[0,0,8,0,8]\n, which contains exactly\n2\ndistinct values (\n{0,8}\n). Note that choosing\nk=10\nwould also be a valid solution.\nIn the last test case, you can choose\nk=\n10\n18\n. The array becomes\n[2,1]\n, which contains exactly\n2\ndistinct values (\n{1,2}\n). Note that choosing\nk=\n10\n18\n+1\nwould not be valid, because\n1≤k≤\n10\n18\nmust be true.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "number theory",
            "*1200"
        ]
    },
    {
        "title": "A. Distinct Buttons",
        "description": "Deemo - Entrance\n⠀\nYou are located at the point\n(0,0)\nof an infinite Cartesian plane. You have a controller with\n4\nbuttons which can perform one of the following operations:\nU\n: move from\n(x,y)\nto\n(x,y+1)\n;\nR\n: move from\n(x,y)\nto\n(x+1,y)\n;\nD\n: move from\n(x,y)\nto\n(x,y−1)\n;\nL\n: move from\n(x,y)\nto\n(x−1,y)\n.\nUnfortunately, the controller is broken. If you press all the\n4\nbuttons (in any order), the controller stops working. It means that, during the whole trip, you can only press at most\n3\ndistinct buttons (any number of times, in any order).\nThere are\nn\nspecial points in the plane, with integer coordinates\n(\nx\ni\n,\ny\ni\n)\n.\nCan you visit all the special points (in any order) without breaking the controller?\nInput\nEach test contains multiple test cases. The first line contains the number of test cases\nt\n(\n1≤t≤1000\n). The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤100\n) — the number of special points.\nEach of the next\nn\nlines contains two integers\nx\ni\n,\ny\ni\n(\n−100≤\nx\ni\n,\ny\ni\n≤100\n), which represent the special point\n(\nx\ni\n,\ny\ni\n)\n.\nNote that there are no constraints on the sum of\nn\nover all test cases.\nOutput\nFor each test case, output \"YES\" (without quotes), if you can reach all the special points without breaking the controller, and \"NO\" (without quotes) otherwise.\nYou may output each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nExample\ninput\nCopy\n6\n3\n1 -1\n0 0\n1 -1\n4\n-3 -2\n-3 -1\n-3 0\n-3 1\n4\n1 1\n-1 -1\n1 -1\n-1 1\n6\n-4 14\n-9 -13\n-14 5\n14 15\n-8 -4\n19 9\n6\n82 64\n39 91\n3 46\n87 83\n74 21\n7 25\n1\n100 -100\noutput\nCopy\nYES\nYES\nNO\nNO\nYES\nYES\nNote\nIn the first test case, you can move as follows:\nyou start from\n(0,0)\n;\nyou visit the special point\n(\nx\n2\n,\ny\n2\n)=(0,0)\n;\nyou press\nR\n, and you move from\n(0,0)\nto\n(1,0)\n;\nyou press\nD\n, and you move from\n(1,0)\nto\n(1,−1)\n;\nyou visit the special point\n(\nx\n1\n,\ny\n1\n)=(1,−1)\n;\nyou visit the special point\n(\nx\n3\n,\ny\n3\n)=(1,−1)\n.\nTherefore, you can visit all the special points using only the buttons\nR\n,\nD\n, so the controller does not break.\nNote that the special points may coincide.\nIn the second test case, you can show that you can visit all the special points using only the buttons\nU\n,\nD\n,\nL\n.\nIn the third test case, you can show that you must press all the buttons (\nU\n,\nR\n,\nD\n,\nL\n) to visit all the points, so the controller would break.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*800"
        ]
    },
    {
        "title": "G. Lights",
        "description": "In the end of the day, Anna needs to turn off the lights in the office. There are\nn\nlights and\nn\nlight switches, but their operation scheme is really strange. The switch\ni\nchanges the state of light\ni\n, but it also changes the state of some other light\na\ni\n(change the state means that if the light was on, it goes off and vice versa).\nHelp Anna to turn all the lights off using minimal number of switches, or say it is impossible.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Descriptions of test cases follow.\nThe first line of each test case contains the integer\nn\n(\n2≤n≤\n10\n5\n) — the number of lights.\nThe second line of each test case contains the string of\nn\ncharacters, the initial state of the lights. Character \"0\" means that the corresponding light is off, and \"1\" means that it is on.\nThe third line of each test case contains\nn\nintegers\na\ni\n(\n1≤\na\ni\n≤n\n,\na\ni\n≠i\n) — the switch\ni\nchanges the states of light\ni\nand light\na\ni\n.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\nOutput\nFor each test case output the integer\nk\n, the minimal number of switches to use, then in the separate line output the list of\nk\nswitches.\nIf it is impossible to turn off all the lights, output single integer\n−1\n.\nExample\ninput\nCopy\n8\n5\n11101\n4 3 4 2 2\n2\n10\n2 1\n10\n0000000011\n9 10 10 7 10 9 9 9 10 2\n10\n1000111101\n9 3 8 9 2 1 3 7 2 7\n10\n0001101010\n5 7 6 10 8 3 6 6 2 2\n10\n0101100010\n8 7 7 9 9 4 1 4 2 7\n10\n1010111010\n7 9 10 7 7 2 8 6 10 4\n10\n1110000001\n3 10 10 1 10 8 6 3 2 1\noutput\nCopy\n3\n1 5 3 \n-1\n1\n9 \n5\n5 6 10 2 3 \n6\n4 9 5 10 8 7 \n3\n5 4 9 \n6\n1 3 5 9 7 8 \n2\n2 1 ",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "dfs and similar",
            "graphs",
            "greedy",
            "implementation",
            "*2200"
        ]
    },
    {
        "title": "F. Shift and Reverse",
        "description": "Given an array of integers\na\n1\n,\na\n2\n,…,\na\nn\n. You can make two types of operations with this array:\nShift: move the last element of array to the first place, and shift all other elements to the right, so you get the array\na\nn\n,\na\n1\n,\na\n2\n,…,\na\nn−1\n.\nReverse: reverse the whole array, so you get the array\na\nn\n,\na\nn−1\n,…,\na\n1\n.\nYour task is to sort the array in non-decreasing order using the minimal number of operations, or say that it is impossible.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Descriptions of test cases follow.\nThe first line of each test case contains an integer\nn\n(\n1≤n≤\n10\n5\n) — size of the array.\nThe second line of each test case contains\nn\nintegers\na\n1\n,\na\n2\n,…,\na\nn\n(\n1≤\na\ni\n≤\n10\n9\n) — elements of the array.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case output the number\nk\n, the minimal number of operations you need to sort the array. If it is impossible to sort the array using these operations, output\n−1\n.\nExample\ninput\nCopy\n11\n5\n3 2 1 5 4\n5\n1 1 2 1 1\n4\n3 7 10 5\n5\n1 2 3 4 5\n2\n5 1\n3\n3 4 1\n5\n4 1 3 4 4\n3\n5 1 1\n4\n2 5 5 4\n5\n2 2 1 1 2\n2\n5 5\noutput\nCopy\n3\n2\n-1\n0\n1\n1\n3\n1\n2\n2\n0\nNote\nIn the first test case of the example, to sort the array [\n3,2,1,5,4\n] you need to perform\n3\noperations:\nShift to obtain the array [\n4,3,2,1,5\n];\nShift to obtain the array [\n5,4,3,2,1\n];\nReverse to obtain the array [\n1,2,3,4,5\n].\nIn the third test case of the example, it can be shown that it is impossible to sort the array using the given operations.\nIn the seventh test case of the example, to sort the array [\n4,1,3,4,4\n] you need to perform\n3\noperations:\nReverse to obtain the array [\n4,4,3,1,4\n];\nShift to obtain the array [\n4,4,4,3,1\n];\nReverse to obtain the array [\n1,3,4,4,4\n].",
        "time_limit": "2 s",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1800"
        ]
    },
    {
        "title": "E. Good Triples",
        "description": "Given a non-negative integer number\nn\n(\nn≥0\n). Let's say a triple of non-negative integers\n(a,b,c)\nis good if\na+b+c=n\n, and\ndigsum(a)+digsum(b)+digsum(c)=digsum(n)\n, where\ndigsum(x)\nis the sum of digits of number\nx\n.\nFor example, if\nn=26\n, then the pair\n(4,12,10)\nis good, because\n4+12+10=26\n, and\n(4)+(1+2)+(1+0)=(2+6)\n.\nYour task is to find the number of good triples for the given number\nn\n. The order of the numbers in a triple matters. For example, the triples\n(4,12,10)\nand\n(10,12,4)\nare two different triples.\nInput\nThe first line of input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Descriptions of test cases follow.\nThe first and only line of the test case contains one integer\nn\n(\n0≤n≤\n10\n7\n).\nOutput\nFor each test case output one integer, the number of good triples for the given integer\nn\n. Order of integers in a triple matters.\nExample\ninput\nCopy\n12\n11\n0\n1\n2\n3\n4\n5\n3141\n999\n2718\n9999999\n10000000\noutput\nCopy\n9\n1\n3\n6\n10\n15\n21\n1350\n166375\n29160\n1522435234375\n3\nNote\nIn the first example, the good triples are\n(0,0,11)\n,\n(0,1,10)\n,\n(0,10,1)\n,\n(0,11,0)\n,\n(1,0,10)\n,\n(1,10,0)\n,\n(10,0,1)\n,\n(10,1,0)\n,\n(11,0,0)\n.\nIn the second example, there is only one good triple\n(0,0,0)\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "number theory",
            "*1600"
        ]
    },
    {
        "title": "D. Jumping Through Segments",
        "description": "Polycarp is designing a level for a game. The level consists of\nn\nsegments on the number line, where the\ni\n-th segment starts at the point with coordinate\nl\ni\nand ends at the point with coordinate\nr\ni\n.\nThe player starts the level at the point with coordinate\n0\n. In one move, they can move to any point that is within a distance of no more than\nk\n. After their\ni\n-th move, the player must land within the\ni\n-th segment, that is, at a coordinate\nx\nsuch that\nl\ni\n≤x≤\nr\ni\n. This means:\nAfter the first move, they must be inside the first segment (from\nl\n1\nto\nr\n1\n);\nAfter the second move, they must be inside the second segment (from\nl\n2\nto\nr\n2\n);\n...\nAfter the\nn\n-th move, they must be inside the\nn\n-th segment (from\nl\nn\nto\nr\nn\n).\nThe level is considered completed if the player reaches the\nn\n-th segment, following the rules described above. After some thought, Polycarp realized that it is impossible to complete the level with some values of\nk\n.\nPolycarp does not want the level to be too easy, so he asks you to determine the minimum integer\nk\nwith which it is possible to complete the level.\nInput\nThe first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n)—the number of test cases. Descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n)—the number of segments in the level.\nThe following\nn\nlines.\nThe\ni\n-th line contain two integers\nl\ni\nand\nr\ni\n(\n0≤\nl\ni\n≤\nr\ni\n≤\n10\n9\n)—the boundaries of the\ni\n-th segment. Segments may intersect.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer—the minimum value of\nk\nwith which it is possible to complete the level.\nExample\ninput\nCopy\n4\n5\n1 5\n3 4\n5 6\n8 10\n0 1\n3\n0 2\n0 1\n0 3\n3\n3 8\n10 18\n6 11\n4\n10 20\n0 5\n15 17\n2 2\noutput\nCopy\n7\n0\n5\n13\nNote\nIn the third example, the player can make the following moves:\nMove from point\n0\nto point\n5\n(\n3≤5≤8\n);\nMove from point\n5\nto point\n10\n(\n10≤10≤18\n);\nMove from point\n10\nto point\n7\n(\n6≤7≤11\n).\nNote that for the last move, the player could have chosen not to move and still complete the level.",
        "time_limit": "5 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "*1400"
        ]
    },
    {
        "title": "C. Removal of Unattractive Pairs",
        "description": "Vlad found a string\ns\nconsisting of\nn\nlowercase Latin letters, and he wants to make it as short as possible.\nTo do this, he can remove any pair of adjacent characters from\ns\nany number of times, provided they are different. For example, if\ns\n=racoon, then by removing one pair of characters he can obtain the strings coon, roon, raon, and raco, but he cannot obtain racn (because the removed letters were the same) or rcon (because the removed letters were not adjacent).\nWhat is the minimum length Vlad can achieve by applying any number of deletions?\nInput\nThe first line of the input contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. Descriptions of the test cases follow.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the string\ns\n.\nThe second line of each test case contains the string\ns\nconsisting of\nn\nlowercase Latin letters.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single number—the minimum length of the string\ns\n, after removing pairs of adjacent characters with different values.\nExample\ninput\nCopy\n10\n4\naabc\n5\nabaca\n10\navbvvcvvvd\n7\nabcdefg\n5\ndabbb\n8\naacebeaa\n7\nbbbbacc\n6\ndacfcc\n6\nfdfcdc\n9\ndbdcfbbdc\noutput\nCopy\n0\n1\n2\n1\n1\n0\n1\n0\n0\n1\nNote\nIn the first test case of the example, you need to act as follows: \"aabc\"\n→\n\"ac\"\n→\n\"\". Note that with a different order of deletions, the string will not become empty.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "strings",
            "*1200"
        ]
    },
    {
        "title": "B. YetnotherrokenKeoard",
        "description": "Polycarp has a problem — his laptop keyboard is broken.\nNow, when he presses the 'b' key, it acts like an unusual backspace: it deletes the last (rightmost) lowercase letter in the typed string. If there are no lowercase letters in the typed string, then the press is completely ignored.\nSimilarly, when he presses the 'B' key, it deletes the last (rightmost) uppercase letter in the typed string. If there are no uppercase letters in the typed string, then the press is completely ignored.\nIn both cases, the letters 'b' and 'B' are not added to the typed string when these keys are pressed.\nConsider an example where the sequence of key presses was \"ARaBbbitBaby\". In this case, the typed string will change as follows: \"\"\n→\nA\n\"A\"\n→\nR\n\"AR\"\n→\na\n\"ARa\"\n→\nB\n\"Aa\"\n→\nb\n\"A\"\n→\nb\n\"A\"\n→\ni\n\"Ai\"\n→\nt\n\"Ait\"\n→\nB\n\"it\"\n→\na\n\"ita\"\n→\nb\n\"it\"\n→\ny\n\"ity\".\nGiven a sequence of pressed keys, output the typed string after processing all key presses.\nInput\nThe first line of the input data contains an integer\nt\n(\n1≤t≤1000\n), the number of test cases in the test.\nThe following contains\nt\nnon-empty lines, which consist of lowercase and uppercase letters of the Latin alphabet.\nIt is guaranteed that each line contains at least one letter and the sum of the lengths of the lines does not exceed\n10\n6\n.\nOutput\nFor each test case, output the result of processing the key presses on a separate line. If the typed string is empty, then output an empty line.\nExample\ninput\nCopy\n12\nARaBbbitBaby\nYetAnotherBrokenKeyboard\nBubble\nImprobable\nabbreviable\nBbBB\nBusyasaBeeinaBedofBloomingBlossoms\nCoDEBARbIES\ncodeforces\nbobebobbes\nb\nTheBBlackbboard\noutput\nCopy\nity\nYetnotherrokenKeoard\nle\nImprle\nrevile\n\nusyasaeeinaedofloominglossoms\nCDARIES\ncodeforces\nes\n\nhelaoard",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "strings",
            "*1000"
        ]
    },
    {
        "title": "A. Rook",
        "description": "As you probably know, chess is a game that is played on a board with 64 squares arranged in an\n8×8\ngrid. Columns of this board are labeled with letters from a to h, and rows are labeled with digits from 1 to 8. Each square is described by the row and column it belongs to.\nThe rook is a piece in the game of chess. During its turn, it may move any non-zero number of squares horizontally or vertically. Your task is to find all possible moves for a rook on an empty chessboard.\nInput\nThe first line of input contains single integer\nt\n(\n1≤t≤64\n) — the number of test cases. The descriptions of test cases follow.\nEach test case contains one string of two characters, description of the square where rook is positioned. The first character is a letter from a to h, the label of column, and the second character is a digit from 1 to 8, the label of row.\nThe same position may occur in more than one test case.\nOutput\nFor each test case, output descriptions of all squares where the rook can move, in the same format as in the input.\nYou can output squares in any order per test case.\nExample\ninput\nCopy\n1\nd5\noutput\nCopy\nd1\nd2\nb5\ng5\nh5\nd3\ne5\nf5\nd8\na5\nd6\nd7\nc5\nd4",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "implementation",
            "*800"
        ]
    },
    {
        "title": "M. Triangle Construction",
        "description": "You are given a regular\nN\n-sided polygon. Label one arbitrary side as side\n1\n, then label the next sides in clockwise order as side\n2\n,\n3\n,\n…\n,\nN\n. There are\nA\ni\nspecial points on side\ni\n. These points are positioned such that side\ni\nis divided into\nA\ni\n+1\nsegments with equal length.\nFor instance, suppose that you have a regular\n4\n-sided polygon, i.e., a square. The following illustration shows how the special points are located within each side when\nA=[3,1,4,6]\n. The uppermost side is labelled as side\n1\n.\nYou want to create as many non-degenerate triangles as possible while satisfying the following requirements. Each triangle consists of\n3\ndistinct special points (not necessarily from different sides) as its corners. Each special point can only become the corner of at most\n1\ntriangle. All triangles must not intersect with each other.\nDetermine the maximum number of non-degenerate triangles that you can create.\nA triangle is non-degenerate if it has a positive area.\nInput\nThe first line consists of an integer\nN\n(\n3≤N≤200000\n).\nThe following line consists of\nN\nintegers\nA\ni\n(\n1≤\nA\ni\n≤2⋅\n10\n9\n).\nOutput\nOutput a single integer representing the maximum number of non-degenerate triangles that you can create.\nExamples\ninput\nCopy\n4\n3 1 4 6\noutput\nCopy\n4\ninput\nCopy\n6\n1 2 1 2 1 2\noutput\nCopy\n3\ninput\nCopy\n3\n1 1 1\noutput\nCopy\n1\nNote\nExplanation for the sample input/output #1\nOne possible construction which achieves maximum number of non-degenerate triangles can be seen in the following illustration.\nExplanation for the sample input/output #2\nOne possible construction which achieves maximum number of non-degenerate triangles can be seen in the following illustration.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1700"
        ]
    },
    {
        "title": "L. Palindromic Parentheses",
        "description": "Construct a parentheses sequence consisting of\nN\ncharacters such that it is balanced and the length of its longest palindromic subsequence (LPS) is exactly\nK\n. Determine whether such a construction is possible. If there are several possible sequences, construct any of them.\nA parentheses sequence consists of only character ( and ). A parentheses sequence is balanced if each character ( has a corresponding character ) and the pairs of parentheses are properly nested. For example, (), (()), (())(), and ((())()) are balanced. However, )(, ((), and ()) are not balanced.\nA sequence is palindromic if it reads the same backwards as forwards. For example, ((, ), ())(, and (()(( are palindromic. However, (), )(, and (()) are not palindromic.\nA subsequence can be derived from another sequence by removing zero or more characters without changing the order of the remaining characters. For example, (, ))), ())(, and (())() are subsequence of (())(). However, )(( and ((())) are not subsequence of (())().\nThe longest palindromic subsequence (LPS) of a sequence is a subsequence with the maximum number of characters, derived from that sequence and it is palindromic. For example, the LPS of sequence (())() is ())(, which can be obtained by removing the second and sixth characters. Therefore, the length of the LPS of (())() is\n4\n.\nInput\nInput consists of two integers\nN\nK\n(\n2≤N≤2000;1≤K≤N\n).\nN\nis an even number.\nOutput\nIf there is no such parentheses sequence such that it is balanced and the length of its LPS is exactly\nK\n, then output -1.\nOtherwise, output a string of\nN\ncharacters, representing the parentheses sequence. If there are several possible answers, output any of them.\nExamples\ninput\nCopy\n6 4\noutput\nCopy\n(())()\ninput\nCopy\n6 3\noutput\nCopy\n(()())\ninput\nCopy\n4 1\noutput\nCopy\n-1\ninput\nCopy\n14 11\noutput\nCopy\n()((())()())()\nNote\nExplanation for the sample input/output #2\nThe LPS of (()()) is either ((( by removing all ) characters, or ))) by removing all ( characters.\nThe output ((())) also satisfies the requirements.\nExplanation for the sample input/output #3\nThe only possible balanced parentheses sequences are (()) and ()(). The length of the LPS of (()) and ()() are\n2\nand\n3\n, respectively.\nExplanation for the sample input/output #4\nThe LPS of ()((())()())() is )())()())(), which can be obtained by removing the first, fourth, and fifth characters.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "*2500"
        ]
    },
    {
        "title": "K. Deck-Building Game",
        "description": "You are playing a deck-building game with your friend. There are\nN\ncards, numbered from\n1\nto\nN\n. Card\ni\nhas the value of\nA\ni\n.\nYou want to build two decks; one for you and one for your friend. A card cannot be inside both decks, and it is allowed to not use all\nN\ncards. It is also allowed for a deck to be empty, i.e. does not contain any cards.\nThe power of a deck is represented as the bitwise XOR of the value of the cards in the deck. The power of an empty deck is\n0\n.\nThe game is balanced if both decks have the same power.\nDetermine the number of ways to build two decks such that the game is balanced. Two ways are considered different if one of the decks contains at least one different card. Since the answer can be very large, calculate the answer modulo\n998244353\n.\nInput\nThe first line consists of an integer\nN\n(\n2≤N≤100000\n).\nThe following line consists of\nN\nintegers\nA\ni\n(\n1≤\nA\ni\n≤100000\n).\nOutput\nOutput an integer representing the number of ways to build two decks such that the game is balanced. Output the answer modulo\n998244353\n.\nExamples\ninput\nCopy\n4\n16 12 4 8\noutput\nCopy\n9\ninput\nCopy\n4\n1 2 4 8\noutput\nCopy\n1\ninput\nCopy\n2\n1 1\noutput\nCopy\n5\ninput\nCopy\n6\n1 1 1 2 2 2\noutput\nCopy\n169\nNote\nExplanation for the sample input/output #1\nDenote\nS\nand\nT\nas the set of cards in your deck and your friend's deck, respectively. There are\n9\nways to build the decks such that the game is balanced.\nS={}\nand\nT={}\n. Both decks have the power of\n0\n.\nS={2,3,4}\nand\nT={}\n. Both decks have the power of\n0\n.\nS={}\nand\nT={2,3,4}\n. Both decks have the power of\n0\n.\nS={2,4}\nand\nT={3}\n. Both decks have the power of\n4\n.\nS={3}\nand\nT={2,4}\n. Both decks have the power of\n4\n.\nS={2,3}\nand\nT={4}\n. Both decks have the power of\n8\n.\nS={4}\nand\nT={2,3}\n. Both decks have the power of\n8\n.\nS={3,4}\nand\nT={2}\n. Both decks have the power of\n12\n.\nS={2}\nand\nT={3,4}\n. Both decks have the power of\n12\n.\nExplanation for the sample input/output #2\nThe only way to make the game balanced is to have both decks empty.\nExplanation for the sample input/output #3\nThere are\n5\nways to build the decks such that the game is balanced.\nS={}\nand\nT={}\n. Both decks have the power of\n0\n.\nS={1,2}\nand\nT={}\n. Both decks have the power of\n0\n.\nS={}\nand\nT={1,2}\n. Both decks have the power of\n0\n.\nS={1}\nand\nT={2}\n. Both decks have the power of\n1\n.\nS={2}\nand\nT={1}\n. Both decks have the power of\n1\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "divide and conquer",
            "math",
            "*2500"
        ]
    },
    {
        "title": "J. Count BFS Graph",
        "description": "You are currently researching a graph traversal algorithm called the Breadth First Search (BFS). Suppose you have an input graph of\nN\nnodes (numbered from\n1\nto\nN\n). The graph is represented by an adjacency matrix\nM\n, for which node\nu\ncan traverse to node\nv\nif\nM\nu,v\nis\n1\n, otherwise it is\n0\n. Your algorithm will output the order the nodes are visited in the BFS. The pseudocode of the algorithm is presented as follows.\n\n    BFS(M[1..N][1..N]):\n        let A be an empty array\n        let Q be an empty queue\n\n        append 1 to A\n        push 1 to Q\n\n        while Q is not empty:\n            pop the front element of Q into u\n            for v = 1 to N:\n                if M[u][v] == 1 and v is not in A:\n                    append v to A\n                    push v to Q\n\n        return A\nDuring your research, you are interested in the following problem. Given an array\nA\nsuch that\nA\nis a permutation of\n1\nto\nN\nand\nA\n1\n=1\n. How many simple undirected graph with\nN\nnodes and adjacency matrix\nM\nsuch that\nBFS(M)=A\n? Since the answer can be very large, calculate the answer modulo\n998244353\n.\nA simple graph has no self-loop (\nM\ni,i\n=0\nfor\n1≤i≤N\n) and there is at most one edge that connects a pair of nodes. In an undirected graph, if node\nu\nis adjacent to node\nv\n, then node\nv\nis also adjacent to node\nu\n; formally,\nM\nu,v\n=\nM\nv,u\nfor\n1≤u<v≤N\n.\nTwo graphs are considered different if there is an edge that exists in one graph but not the other. In other words, two graphs are considered different if their adjacency matrices are different.\nInput\nThe first line consists of an integer\nN\n(\n2≤N≤5000\n).\nThe second line consists of\nN\nintegers\nA\ni\n. The array\nA\nis a permutation of\n1\nto\nN\nand\nA\n1\n=1\n.\nOutput\nOutput an integer representing the number of simple undirected graphs with\nN\nnodes and adjacency matrix\nM\nsuch that\nBFS(M)=A\n. Since the answer can be very large, output the answer modulo\n998244353\n.\nExamples\ninput\nCopy\n3\n1 2 3\noutput\nCopy\n3\ninput\nCopy\n3\n1 3 2\noutput\nCopy\n1\ninput\nCopy\n5\n1 3 2 4 5\noutput\nCopy\n17\ninput\nCopy\n11\n1 2 3 4 5 6 7 8 9 10 11\noutput\nCopy\n379394847\nNote\nExplanation for the sample input/output #1\nThe following illustration shows all graphs that satisfy the requirements.\nExplanation for the sample input/output #2\nThe only graph that satisfies the requirements is a graph with two edges: one that connects nodes\n1\nand\n3\n, and another one that connects nodes\n3\nand\n2\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "*2100"
        ]
    },
    {
        "title": "I. Contingency Plan 2",
        "description": "You are working as a manager in The ICPC Company. In the company building, there are\nN\ncomputers (numbered from\n1\nto\nN\n). There are\nN−1\ncables, numbered from\n1\nto\nN−1\n, that connect all the computers into a single network. Cable\ni\nconnects computer\nU\ni\nand\nV\ni\n. Each cable can be set into emergency mode, where cable\ni\nonly transfers data from computer\nU\ni\nto computer\nV\ni\n, but not the other way around. During a disaster, it is mandatory for all cables to be in emergency mode.\nThrough your research, you discover a new way to determine the vulnerability of a network. You want to add zero or more new cables to the current network such that it is not vulnerable during a disaster. Your network is not vulnerable if and only if there is exactly one permutation of\n1\nto\nN\nsuch that\nu\nappears before\nv\nin the permutation for all cables that connect computer\nu\nand\nv\n. In other words, it should have exactly one topological order.\nThe following illustration shows examples of not vulnerable networks and vulnerable networks.\nFor the not vulnerable networks, the only permutation that satisfies the requirement for the networks on the left and on the right are\n[1,2,3]\nand\n[3,1,2]\n, respectively. Meanwhile, for the vulnerable networks, there are\n2\npermutations that satisfy the requirement for the network on the left:\n[1,2,3]\nand\n[3,1,2]\n; while there is no permutation that satisfies the requirement for the network on the right.\nYou are interested in the minimum number of new cables that should be added to the current network such that it is not vulnerable during a disaster. Furthermore, you want to know, which pairs of computers should be connected by using the minimum number of cables. If there are several ways to connect, you can connect in any way of your choice. Under the given constraints, it can be proven that there exists a way to make the network not vulnerable.\nInput\nThe first line consists of an integer\nN\n(\n2≤N≤100000\n).\nEach of the next\nN−1\nlines consists of two integers\nU\ni\nV\ni\n(\n1≤\nU\ni\n,\nV\ni\n≤N\n). The input edges form a tree.\nOutput\nThe first line consists of an integer, representing the minimum number of new cables that should be added to the current network such that it is no longer vulnerable during a disaster. Denote this number as\nK\nand the new cables are numbered from\n1\nto\nK\n.\nIf\nK\nis not\n0\n, then output\nK\nlines. Each of the next\nK\nlines consists of two integers\nA\ni\nB\ni\n, representing the computers that are connected by the new cable\ni\n. During a disaster, new cable\ni\nonly transfers data from computer\nA\ni\nto computer\nB\ni\n, but not the other way around. If there exist several solutions, you can output any of them.\nExamples\ninput\nCopy\n3\n1 2\n3 2\noutput\nCopy\n1\n3 1\ninput\nCopy\n3\n1 2\n2 3\noutput\nCopy\n0\ninput\nCopy\n5\n1 2\n1 3\n3 4\n3 5\noutput\nCopy\n2\n2 3\n4 5\nNote\nExplanation for the sample input/output #3\nThe following illustration shows the original network and the new network with the added cables during a disaster. The only permutation that satisfies the requirement is\n[1,2,3,4,5]\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "graph matchings",
            "*2900"
        ]
    },
    {
        "title": "H. Twin Friends",
        "description": "You meet two new friends who are twins. The name of the elder twin is\nA\n, which consists of\nN\ncharacters. While the name of the younger twin is\nB\n, which consists of\nM\ncharacters. It is known that\nN≤M\n.\nYou want to call each of them with a nickname. For the elder twin, you want to pick any permutation of\nA\nas the nickname. For the younger twin, you want to remove exactly\nM−N\ncharacters from any permutation of\nB\n. Denote the nicknames of the elder twin and the younger twin as\nA\n′\nand\nB\n′\n, respectively.\nYou want the nicknames to satisfy the following requirement. For each\ni\nthat satisfies\n1≤i≤N\n,\nB\n′\ni\nmust be equal to either\nA\n′\ni\nor the next letter that follows alphabetically after\nA\n′\ni\n(if such a next letter exists).\nDetermine the number of different pairs of nicknames\n(\nA\n′\n,\nB\n′\n)\nthat satisfy the requirement. Two pairs of nicknames are considered different if at least one of the nicknames are different. As the result might be large, find the answer modulo\n998244353\n.\nInput\nThe first line consists of two integers\nN\nM\n(\n1≤N≤M≤200000\n).\nThe second line consists of a string\nA\nof length\nN\n.\nThe third line consists of a string\nB\nof length\nM\n.\nAll strings consist of only upper-case letters.\nOutput\nOutput a single integer representing number of different pairs\n(\nA\n′\n,\nB\n′\n)\nthat satisfy the requirement, modulo\n998244353\n.\nExamples\ninput\nCopy\n3 4\nAMA\nANAB\noutput\nCopy\n9\ninput\nCopy\n5 8\nBINUS\nBINANUSA\noutput\nCopy\n120\ninput\nCopy\n15 30\nBINUSUNIVERSITY\nBINANUSANTARAUNIVERSITYJAKARTA\noutput\nCopy\n151362308\ninput\nCopy\n4 4\nUDIN\nASEP\noutput\nCopy\n0\nNote\nExplanation for the sample input/output #1\nThe\n9\npairs are:\n(AAM, AAN),\n(AAM, ABN),\n(AAM, BAN),\n(AMA, ANA),\n(AMA, ANB),\n(AMA, BNA),\n(MAA, NAA),\n(MAA, NAB), and\n(MAA, NBA).\nExplanation for the sample input/output #2\nThe\n120\npairs are the pairs where\nA\n′\nis a permutation of BINUS and\nB\n′\n=\nA\n′\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "*2200"
        ]
    },
    {
        "title": "G. Grid Game 2",
        "description": "You are playing \"Grid Game 2\" with your friend. There is a grid with\n10\n9\nrows (numbered from\n1\nto\n10\n9\n) and\n10\n9\ncolumns (numbered from\n1\nto\n10\n9\n). The cell at row\nr\nand column\nc\nis denoted as\n(r,c)\n.\nEach cell can have a colour of either black or white. Initially, there are exactly\nN\nblack cells (numbered from\n1\nto\nN\n). Black cell\ni\nis located at\n(\nR\ni\n,\nC\ni\n)\n. The rest of the cells are white.\nYou and your friend will alternately take turn playing on this grid, and you are playing in the first turn. In one turn, a player will choose a black cell\n(r,c)\n, then toggle cells\n(r−x,c−y)\nfor all\n0≤x,y<min(r,c)\n. If a cell is toggled, then the cell becomes black if it was a white cell, and the cell becomes white if it was a black cell.\nFor example, the following illustration shows how the grid changes after a player chooses a black cell\n(5,4)\nin their turn.\nA player who is unable to play on their turn, i.e. no remaining black cells, loses the game, and the opposing player wins the game. If you and your friend are playing optimally, determine who will win the game.\nInput\nThe first line consists of an integer\nN\n(\n1≤N≤200000\n).\nEach of the next\nN\nlines consists of two integers\nR\ni\nC\ni\n(\n1≤\nR\ni\n,\nC\ni\n≤\n10\n9\n)\n. For\n1≤i<j≤N\n,\n(\nR\ni\n,\nC\ni\n)≠(\nR\nj\n,\nC\nj\n)\n.\nOutput\nOutput FIRST if you will win the game, or SECOND otherwise.\nExamples\ninput\nCopy\n2\n2 3\n2 4\noutput\nCopy\nFIRST\ninput\nCopy\n1\n2 2\noutput\nCopy\nSECOND\ninput\nCopy\n13\n1 1\n1 4\n1 5\n2 1\n2 4\n2 5\n4 1\n4 2\n4 4\n5 1\n5 2\n5 4\n5 5\noutput\nCopy\nSECOND\nNote\nExplanation for the sample input/output #1\nYou can start your move by choosing\n(2,4)\n, whose effect was demonstrated in the following illustration.\nThe remaining black cells are\n(1,3)\nand\n(1,4)\n, each of which will only toggle itself when chosen. Whichever your friend chooses on the next move, the you can choose the remaining black cell.\nExplanation for the sample input/output #2\nYou have only one cell to choose, and will toggle cells\n(1,1)\n,\n(1,2)\n,\n(2,1)\n, and\n(2,2)\n. Your friend and you will alternately choose the remaining black cells with your friend choosing the last black cell.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "games",
            "number theory",
            "*2900"
        ]
    },
    {
        "title": "F. Maximize The Value",
        "description": "You are given a one-based array consisting of\nN\nintegers:\nA\n1\n,\nA\n2\n,⋯,\nA\nN\n. Initially, the value of each element is set to\n0\n.\nThere are\nM\noperations (numbered from\n1\nto\nM\n). Operation\ni\nis represented by\n⟨\nL\ni\n,\nR\ni\n,\nX\ni\n⟩\n. If operation\ni\nis executed, all elements\nA\nj\nfor\nL\ni\n≤j≤\nR\ni\nwill be increased by\nX\ni\n.\nYou have to answer\nQ\nindependent queries. Each query is represented by\n⟨K,S,T⟩\nwhich represents the following task. Choose a range\n[l,r]\nsatisfying\nS≤l≤r≤T\n, and execute operations\nl,l+1,…,r\n. The answer to the query is the maximum value of\nA\nK\nafter the operations are executed among all possible choices of\nl\nand\nr\n.\nInput\nThe first line consists of two integers\nN\nM\n(\n1≤N,M≤100000\n).\nEach of the next\nM\nlines consists of three integers\nL\ni\nR\ni\nX\ni\n(\n1≤\nL\ni\n≤\nR\ni\n≤N;−100000≤\nX\ni\n≤100000\n).\nThe following line consists of an integer\nQ\n(\n1≤Q≤100000\n).\nEach of the next\nQ\nlines consists of three integers\nK\nS\nT\n(\n1≤K≤N;1≤S≤T≤M\n).\nOutput\nFor each query, output in a single line, an integer which represent the answer of the query.\nExamples\ninput\nCopy\n2 6\n1 1 -50\n1 2 -20\n2 2 -30\n1 1 60\n1 2 40\n2 2 10\n5\n1 1 6\n2 1 6\n1 1 3\n2 1 3\n1 1 2\noutput\nCopy\n100\n50\n0\n0\n-20\ninput\nCopy\n5 3\n1 3 3\n2 4 -2\n3 5 3\n6\n1 1 3\n2 1 3\n3 1 3\n3 2 3\n2 2 3\n2 2 2\noutput\nCopy\n3\n3\n4\n3\n0\n-2\nNote\nExplanation for the sample input/output #1\nFor query\n1\n, one of the solutions is to execute operation\n4\nand\n5\n.\nFor query\n2\n, one of the solutions is to execute operation\n4\n,\n5\n, and\n6\n.\nFor query\n3\n, the only solution is to execute operation\n3\n.\nFor query\n4\n, the only solution is to execute operation\n1\n.\nFor query\n6\n, the only solution is to execute operation\n2\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "data structures",
            "sortings",
            "*2100"
        ]
    },
    {
        "title": "E. Merge Not Sort",
        "description": "You are currently researching the Merge Sort algorithm. Merge Sort is a sorting algorithm that is based on the principle of Divide and Conquer. It works by dividing an array into two subarrays of equal length, sorting each subarrays, then merging the sorted subarrays back together to form the final sorted array.\nYou are particularly interested in the merging routine. Common merge implementation will combine two subarrays by iteratively comparing their first elements, and move the smaller one to a new merged array. More precisely, the merge algorithm can be presented by the following pseudocode.\n\n    Merge(A[1..N], B[1..N]):\n        C = []\n        i = 1\n        j = 1\n        while i <= N AND j <= N:\n            if A[i] < B[j]:\n                append A[i] to C\n                i = i + 1\n            else:\n                append B[j] to C\n                j = j + 1 \n        while i <= N:\n            append A[i] to C\n            i = i + 1 \n        while j <= N:\n            append B[j] to C\n            j = j + 1 \n        return C\nDuring your research, you are keen to understand the behaviour of the merge algorithm when arrays\nA\nand\nB\nare not necessarily sorted. For example, if\nA=[3,1,6]\nand\nB=[4,5,2]\n, then\nMerge(A,B)=[3,1,4,5,2,6]\n.\nTo further increase the understanding of the merge algorithm, you decided to work on the following problem. You are given an array\nC\nof length\n2⋅N\nsuch that it is a permutation of\n1\nto\n2⋅N\n. Construct any two arrays\nA\nand\nB\nof the same length\nN\n, such that\nMerge(A,B)=C\n, or determine if it is impossible to do so.\nInput\nThe first line consists of an integer\nN\n(\n1≤N≤1000\n).\nThe following line consists of\n2⋅N\nintegers\nC\ni\n. The array\nC\nis a permutation of\n1\nto\n2⋅N\n.\nOutput\nIf it is impossible to construct two arrays\nA\nand\nB\nof length\nN\nsuch that\nMerge(A,B)=C\n, then output -1.\nOtherwise, output the arrays\nA\nand\nB\nin two lines. The first line consists of\nN\nintegers\nA\ni\n. The second line consists of\nN\nintegers\nB\ni\n. If there are several possible answers, output any of them.\nExamples\ninput\nCopy\n3\n3 1 4 5 2 6\noutput\nCopy\n3 1 6\n4 5 2\ninput\nCopy\n4\n1 2 3 4 5 6 7 8\noutput\nCopy\n2 3 5 7\n1 4 6 8\ninput\nCopy\n2\n4 3 2 1\noutput\nCopy\n-1\nNote\nExplanation for the sample input/output #1\nThe solution\nA=[3,1,4]\nand\nB=[5,2,6]\nis also correct.\nExplanation for the sample input/output #2\nThe solution\nA=[1,2,3,4]\nand\nB=[5,6,7,8]\nis also correct.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "*1900"
        ]
    },
    {
        "title": "D. Spaceship Exploration",
        "description": "In The ICPC Galaxy, there exists a zone filled with asteroids that is unsafe to enter. The map of the galaxy is represented in a 2D Cartesian coordinate system. The zone is in the shape of an\nN\n-sided convex polygon. Each corner is numbered from\n1\nto\nN\n; corner\ni\nis located at\n(\nX\ni\n,\nY\ni\n)\n. At any moment, you should not be inside this polygon; however, it is safe to touch the side of the polygon.\nThere are\nQ\nscenarios (numbered from\n1\nto\nQ\n). In scenario\nj\n, you want to go from a starting point at\n(\nA\nj\n,\nB\nj\n)\nto an ending point at\n(\nC\nj\n,\nD\nj\n)\n. You will be riding on a special spaceship that can only travel in a straight line. First, you set the direction of the spaceship, then the spaceship will start traveling in that direction. During the travel, you are only allowed to change direction at most once. Changing direction means you stop the spaceship, set a new direction, and then start traveling again in the new direction.\nFor each scenario, determine the minimum distance required to travel without being inside of the zone at any moment, or report if it is impossible to reach the ending point.\nInput\nThe first line consists of an integer\nN\n(\n3≤N≤100000\n).\nEach of the next\nN\nlines consists of two integers\nX\ni\nY\ni\n(\n−\n10\n9\n≤\nX\ni\n,\nY\ni\n≤\n10\n9\n). The points form a convex polygon in counterclockwise order. There are no three points which are collinear.\nThe following line consists of an integer\nQ\n(\n1≤Q≤100000\n).\nEach of the next\nQ\nlines consists of four integers\nA\nj\nB\nj\nC\nj\nD\nj\n(\n−\n10\n9\n≤\nA\nj\n,\nB\nj\n,\nC\nj\n,\nD\nj\n≤\n10\n9\n). There are no starting points and ending points inside the zone. However, it is possible for the starting point and the ending point to be at the side of the zone.\nAll the coordinates in the input are integers.\nOutput\nFor each scenario, output the answer in a single line.\nIf it is possible to reach the ending point without being inside the zone at any moment, then output the minimum distance required to travel. Otherwise, output -1.\nYour answer is considered correct if its absolute error or relative error does not exceed\n10\n−6\n. Namely, if your answer is\na\nand the jury's answer is\nb\n, then your answer is accepted if\n|a−b|\nmax(1,|b|)\n≤\n10\n−6\n.\nExamples\ninput\nCopy\n5\n0 2\n2 0\n4 0\n4 4\n2 4\n5\n6 1 6 3\n2 5 0 0\n3 5 3 -1\n1 4 5 4\n3 4 3 0\noutput\nCopy\n2\n5.6055512755\n8.48528137422\n4\n-1\ninput\nCopy\n4\n-10 -9\n10 -9\n10 9\n-10 9\n2\n0 10 0 -10\n-10 -10 -10 -10\noutput\nCopy\n200.9975124224\n0\ninput\nCopy\n8\n-20 -10\n10 -20\n25 -15\n35 -5\n30 10\n15 20\n-25 15\n-30 5\n6\n-15 -15 -15 20\n-30 -5 30 15\n25 20 -5 -20\n-5 25 20 -20\n-30 10 30 -10\n-30 -50 50 0\noutput\nCopy\n59.0857761929\n103.2455532034\n94.7213595500\n101.5640991922\n164.8528137424\n94.3398113206\nNote\nExplanation for the sample input/output #1\nThis sample is depicted in the following illustration.\nDuring scenario\n1\nand\n4\n, you can directly go to the ending point without changing the direction.\nDuring scenario\n2\n, you can go to\n(0,2)\n, then change direction to the ending point.\nDuring scenario\n3\n, you can go to\n(6,2)\n, then change direction to the ending point.\nDuring scenario\n5\n, it can be shown that it is impossible to reach the ending point.",
        "time_limit": "3 seconds",
        "memory_limit": "1024 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "*2800"
        ]
    },
    {
        "title": "C. Cursed Game",
        "description": "You found an antique box in your warehouse and decided to open it. The moment you open the box, it traps you into a cursed game where you are playing against a demon. The game consists of\n333\nrounds and you have to win all rounds in order to escape. The demon also gives you\n999\ncoins that you can use throughout all rounds.\nNote that in this problem, denote cell\n(r,c)\nof a grid as the cell in row\nr\nand column\nc\nof the grid.\nBefore the start of each round, the demon will prepare a secret paper, which can be represented as a grid with\n3\nrows and\n3\ncolumns, both numbered from\n1\nto\n3\n. The demon will secretly put a hole in one or more cells, and you are not aware which cells have a hole in it. Then, the round starts with the demon giving you an odd integer\nN\n(\n3≤N≤33\n).\nWithin each round, you can ask the demon several queries, each costing you one coin. For each query, you are allowed to give the demon your paper, which can be represented as a grid with\nN\nrows and\nN\ncolumns, both numbered from\n1\nto\nN\n. Each cell is coloured either black or white by you.\nFor each of your query, the demon will calculate a binary result grid with\nN−2\nrows and\nN−2\ncolumns, both numbered from\n1\nto\nN−2\n. The value on cell\n(r,c)\nof the result grid is filled as follows.\nThe demon will put the secret paper on top of your paper such that the cell\n(r+i−1,c+j−1)\nof your paper aligns with the cell\n(i,j)\nof the secret paper, for\n1≤i,j≤3\n.\nThe demon can only see the colour of the cell in your paper if the corresponding cell in the secret paper has a hole in it.\nThe value on cell\n(r,c)\nof the result grid is\n1\nif there is an odd number of black cells that it can see through the holes, or\n0\notherwise.\nYou win the round if the result grid consists of only the values\n1\n. Otherwise, the demon will give you the result grid as a feedback, and the round continues.\nIf you have spent all the coins and still did not win all the rounds, then you will be trapped forever. Escape the cursed game!\nInteraction\nEach round is started with an odd integer\nN\n(\n3≤N≤33\n) which can be read through standard input.\nThen, for each query that you give to the demon, you can output\nN\nlines to standard output. Each of the\nN\nlines consists of\nN\ncharacters. The\nc\n-th character of the\nr\n-th line represents the colour of cell\n(r,c)\nin your paper. The character should be 1 if\n(r,c)\nis coloured black, or 0 if coloured white.\nThe demon will reply with one line consisting of a string, which can be read through standard input.\nIf the string is CORRECT, then you win the current round and the next round (if exists) will immediately start.\nIf the string is INCORRECT, then the demon will give you\nN−2\nmore lines which can be read through standard input. Each of the\nN−2\nlines consists of\nN−2\ncharacters, representing the binary result grid as explained in the description.\nThe demon prepares the secret paper before the start of each round. In other words, the grader is NOT adaptive. There will be at least one hole in the secret paper.\nThe total number of queries across all\n333\nrounds should not exceed\n999\n. If you exceed the maximum number of queries, you should terminate your program with\n0\nto receive the verdict Wrong Answer. If you do not terminate, the judging result would be undefined because your program is reading from a closed stream.\nDo not forget to flush output buffers after each output. In C you can use fflush(stdout). In C++ you can use fflush(stdout) or cout « flush. In Java you can use method flush for output stream, for example, System.out.flush(). In Python you can use stdout.flush().\nNote\nSample Interaction #1\nThe following interaction only shows\n2\nrounds. The actual interaction stays until you win all\n333\nrounds or you run out of coins.\nExplanation for the sample interaction #1\nFor the first round, the following illustration shows how the demon finds the value in cell\n(1,1)\nof the result grid for the first and second queries. The grey-colored square represents the secret paper, and the circles represent the holes. In the first query, there are\n4\nblack cells that can be seen through the holes, therefore the value in cell\n(1,1)\nof the result grid is\n0\n. In the second query, there are\n5\nblack cells that can be seen through the holes, therefore the value in cell\n(1,1)\nof the result grid is\n1\n. As the result grid consists of only 1, the first round ends.\nFor the second round, the following illustration shows how the demon find the value in cell\n(2,1)\nof the result grid for the first query. Since there are\n2\nblack cells that can be seen through the holes, the value in cell\n(2,1)\nis\n0\n.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "interactive",
            "*3000"
        ]
    },
    {
        "title": "B. Button Pressing",
        "description": "You are given\nN\nbuttons (numbered from\n1\nto\nN\n) and\nN\nlamps (numbered from\n1\nto\nN\n). Each lamp can either be on or off. Initially, lamp\ni\nis on if\nA\ni\n=1\n, and off if\nA\ni\n=0\n.\nButton\ni\nis connected to lamp\ni−1\n(if\ni>1\n) and lamp\ni+1\n(if\ni<N\n). In one move, you can press a button\ni\nonly if lamp\ni\nis on. When a button is pressed, the state of the lamps connected to this button is toggled. Formally, the lamps will be on if it was off previously, and the lamps will be off if it was on previously. Note that lamp\ni\nis not connected to button\ni\n, thus, the state of lamp\ni\ndoes not change if button\ni\nis pressed.\nAfter zero or more moves, you want lamp\ni\nto be on if\nB\ni\n=1\n, and off if\nB\ni\n=0\n. Determine if it is possible to achieve this task.\nInput\nThis problem has multiple test cases. The first line consists of an integer\nT\n(\n1≤T≤1000\n), which represents the number of test cases. Each test case consists of three lines.\nThe first line of each test case consists of an integer\nN\n(\n3≤N≤200000\n). The sum of\nN\nover all test cases does not exceed\n200000\n.\nThe second line of each test case consists of a string\nA\nof length\nN\n. Each character of\nA\ncan either be 0 or 1. The\ni\n-th character represents the initial state of lamp\ni\n.\nThe third line of each test case consists of a string\nA\nof length\nN\n. Each character of\nB\ncan either be 0 or 1. The\ni\n-th character represents the desired final state of lamp\ni\n.\nOutput\nFor each test case, output YES in a single line if the final state of all lamps can be reached after zero or more moves, or NO otherwise.\nExamples\ninput\nCopy\n2\n4\n0101\n0100\n3\n000\n010\noutput\nCopy\nYES\nNO\ninput\nCopy\n5\n7\n0101011\n1111010\n5\n11111\n00000\n4\n1101\n1101\n6\n101010\n100100\n3\n000\n000\noutput\nCopy\nNO\nNO\nYES\nYES\nYES\nNote\nExplanation for the sample input/output #1\nFor the first test case, by pressing the buttons\n4,2,4,3,1,2\nin sequence, the condition of the buttons changes as:\n0101→0111→1101→1111→1010→1110→0100\n.\nFor the second test case, you are unable to press any button, hence it is impossible to reach the final state.",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "hashing",
            "*2600"
        ]
    },
    {
        "title": "A. Easy As ABC",
        "description": "You are playing a word puzzle. The puzzle starts with a\n3\nby\n3\ngrid, where each cell contains either the letter A, B, or C.\nThe goal of this puzzle is to find the lexicographically smallest possible word of length\n3\n. The word can be formed by choosing three different cells where the cell containing the first letter is adjacent to the cell containing the second letter, and the cell containing the second letter is adjacent to the cell containing the third letter.\nTwo cells are adjacent to each other if they share a border or a corner, as shown in the following illustration. Formally, if\n(r,c)\ndenotes the cell in the\nr\n-th row and\nc\n-th column, then cell\n(r,c)\nis adjacent to cell\n(r,c+1)\n,\n(r−1,c+1)\n,\n(r−1,c)\n,\n(r−1,c−1)\n,\n(r,c−1)\n,\n(r+1,c−1)\n,\n(r+1,c)\n, and\n(r+1,c+1)\n.\nDetermine the lexicographically smallest possible word of length\n3\nthat you can find within the grid.\nA string\ns\nof length\nn\nis lexicographically smaller than string\nt\nof the same length if there exists an integer\n1≤i≤n\nsuch that\ns\nj\n=\nt\nj\nfor all\n1≤j<i\n, and\ns\ni\n<\nt\ni\nin alphabetical order. The following illustration shows some examples on some grids and their the lexicographically smallest possible word of length\n3\nthat you can find within the grids.\nInput\nInput consists of three lines, each containing three letters, representing the puzzle grid. Each letter in the grid can only be either A, B, or C.\nOutput\nOutput the lexicographically smallest possible word of length\n3\nthat you can find within the grid.\nExamples\ninput\nCopy\nBCB\nCAC\nBCB\noutput\nCopy\nABC\ninput\nCopy\nBCB\nCCC\nCCA\noutput\nCopy\nACB\ninput\nCopy\nACA\nCBC\nACA\noutput\nCopy\nABA\ninput\nCopy\nACA\nCAC\nACA\noutput\nCopy\nAAA\ninput\nCopy\nCCC\nCBC\nCCC\noutput\nCopy\nBCC",
        "time_limit": "1 second",
        "memory_limit": "1024 megabytes",
        "tags": [
            "brute force",
            "*1000"
        ]
    },
    {
        "title": "F. Field Should Not Be Empty",
        "description": "You are given a permutation\n†\n†\np\nof length\nn\n.\nWe call index\nx\ngood if for all\ny<x\nit holds that\np\ny\n<\np\nx\nand for all\ny>x\nit holds that\np\ny\n>\np\nx\n. We call\nf(p)\nthe number of good indices in\np\n.\nYou can perform the following operation: pick\n2\ndistinct indices\ni\nand\nj\nand swap elements\np\ni\nand\np\nj\n.\nFind the maximum value of\nf(p)\nafter applying the aforementioned operation exactly once.\n†\n†\nA permutation of length\nn\nis an array consisting of\nn\ndistinct integers from\n1\nto\nn\nin arbitrary order. For example,\n[2,3,1,5,4]\nis a permutation, but\n[1,2,2]\nis not a permutation (\n2\nappears twice in the array), and\n[1,3,4]\nis also not a permutation (\nn=3\nbut there is\n4\nin the array).\nInput\nEach test consists of multiple test cases. The first line of contains a single integer\nt\n(\n1≤t≤2⋅\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤2⋅\n10\n5\n) — the length of the permutation\np\n.\nThe second line of each test case contain\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n1≤\np\ni\n≤n\n) — the elements of the permutation\np\n.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the maximum value of\nf(p)\nafter performing the operation exactly once.\nExample\ninput\nCopy\n5\n5\n1 2 3 4 5\n5\n2 1 3 4 5\n7\n2 1 5 3 7 6 4\n6\n2 3 5 4 1 6\n7\n7 6 5 4 3 2 1\noutput\nCopy\n3\n5\n2\n3\n2\nNote\nIn the first test case,\np=[1,2,3,4,5]\nand\nf(p)=5\nwhich is already maximum possible. But must perform the operation anyway. We can get\nf(p)=3\nby choosing\ni=1\nand\nj=2\nwhich makes\np=[2,1,3,4,5]\n.\nIn the second test case, we can transform\np\ninto\n[1,2,3,4,5]\nby choosing\ni=1\nand\nj=2\n. Thus\nf(p)=5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "divide and conquer",
            "*2600"
        ]
    },
    {
        "title": "E. One-X",
        "description": "In this sad world full of imperfections, ugly segment trees exist.\nA segment tree is a tree where each node represents a segment and has its number. A segment tree for an array of\nn\nelements can be built in a recursive manner. Let's say function\nbuild(v,l,r)\nbuilds the segment tree rooted in the node with number\nv\nand it corresponds to the segment\n[l,r]\n.\nNow let's define\nbuild(v,l,r)\n:\nIf\nl=r\n, this node\nv\nis a leaf so we stop adding more edges\nElse, we add the edges\n(v,2v)\nand\n(v,2v+1)\n. Let\nm=⌊\nl+r\n2\n⌋\n. Then we call\nbuild(2v,l,m)\nand\nbuild(2v+1,m+1,r)\n.\nSo, the whole tree is built by calling\nbuild(1,1,n)\n.\nNow Ibti will construct a segment tree for an array with\nn\nelements. He wants to find the sum of\nlca\n†\n(S)\n, where\nS\nis a non-empty subset of leaves. Notice that there are exactly\n2\nn\n−1\npossible subsets. Since this sum can be very large, output it modulo\n998244353\n.\n†\nlca(S)\n†\nis the number of the least common ancestor for the nodes that are in\nS\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n3\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n18\n) — the length of the array for which the segment tree is built.\nOutput\nFor each test case, output a single integer — the required sum modulo\n998244353\n.\nExample\ninput\nCopy\n5\n2\n3\n4\n5\n53278\noutput\nCopy\n6\n17\n36\n69\n593324855\nNote\nIn the first test case:\nLet's look at all subsets of leaves.\nlca({2})=2\n;\nlca({3})=3\n;\nlca({2,3})=1\n.\nThus, the answer is\n2+3+1=6\n.\nIn the second test case:\nLet's look at all subsets of leaves.\nlca({4})=4\n;\nlca({5})=5\n;\nlca({3})=3\n;\nlca({4,5})=2\n;\nlca({4,3})=1\n;\nlca({5,3})=1\n;\nlca({4,5,3})=1\n;\nThus, the answer is\n4+5+3+2+1+1+1=17\n.",
        "time_limit": "3 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "dp",
            "math",
            "trees",
            "*2400"
        ]
    },
    {
        "title": "D. Cyclic MEX",
        "description": "For an array\na\n, define its cost as\n∑\nn\ni=1\nmex\n†\n([\na\n1\n,\na\n2\n,…,\na\ni\n])\n.\nYou are given a permutation\n‡\n‡\np\nof the set\n{0,1,2,…,n−1}\n. Find the maximum cost across all cyclic shifts of\np\n.\n†\nmex([\nb\n1\n,\nb\n2\n,…,\nb\nm\n])\n†\nis the smallest non-negative integer\nx\nsuch that\nx\ndoes not occur among\nb\n1\n,\nb\n2\n,…,\nb\nm\n.\n‡\n‡\nA permutation of the set\n{0,1,2,...,n−1}\nis an array consisting of\nn\ndistinct integers from\n0\nto\nn−1\nin arbitrary order. For example,\n[1,2,0,4,3]\nis a permutation, but\n[0,1,1]\nis not a permutation (\n1\nappears twice in the array), and\n[0,2,3]\nis also not a permutation (\nn=3\nbut there is\n3\nin the array).\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n5\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤\n10\n6\n) — the length of the permutation\np\n.\nThe second line of each test case contain\nn\ndistinct integers\np\n1\n,\np\n2\n,…,\np\nn\n(\n0≤\np\ni\n<n\n) — the elements of the permutation\np\n.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n10\n6\n.\nOutput\nFor each test case, output a single integer — the maximum cost across all cyclic shifts of\np\n.\nExample\ninput\nCopy\n4\n6\n5 4 3 2 1 0\n3\n2 1 0\n8\n2 3 6 7 0 1 4 5\n1\n0\noutput\nCopy\n15\n5\n31\n1\nNote\nIn the first test case, the cyclic shift that yields the maximum cost is\n[2,1,0,5,4,3]\nwith cost\n0+0+3+3+3+6=15\n.\nIn the second test case, the cyclic shift that yields the maximum cost is\n[0,2,1]\nwith cost\n1+1+3=5\n.",
        "time_limit": "2 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "math",
            "two pointers",
            "*2000"
        ]
    },
    {
        "title": "C. Largest Subsequence",
        "description": "Given is a string\ns\nof length\nn\n. In one operation you can select the lexicographically largest\n†\n†\nsubsequence of string\ns\nand cyclic shift it to the right\n‡\n‡\n.\nYour task is to calculate the minimum number of operations it would take for\ns\nto become sorted, or report that it never reaches a sorted state.\n†\n†\nA string\na\nis lexicographically smaller than a string\nb\nif and only if one of the following holds:\na\nis a prefix of\nb\n, but\na≠b\n;\nIn the first position where\na\nand\nb\ndiffer, the string\na\nhas a letter that appears earlier in the alphabet than the corresponding letter in\nb\n.\n‡\n‡\nBy cyclic shifting the string\nt\n1\nt\n2\n…\nt\nm\nto the right, we get the string\nt\nm\nt\n1\n…\nt\nm−1\n.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n1≤n≤2⋅\n10\n5\n) — the length of the string\ns\n.\nThe second line of each test case contains a single string\ns\nof length\nn\n, consisting of lowercase English letters.\nIt is guaranteed that sum of\nn\nover all test cases does not exceed\n2⋅\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of operations required to make\ns\nsorted, or\n−1\nif it's impossible.\nExample\ninput\nCopy\n6\n5\naaabc\n3\nacb\n3\nbac\n4\nzbca\n15\nczddeneeeemigec\n13\ncdefmopqsvxzz\noutput\nCopy\n0\n1\n-1\n2\n6\n0\nNote\nIn the first test case, the string\ns\nis already sorted, so we need no operations.\nIn the second test case, doing one operation, we will select cb and cyclic shift it. The string\ns\nis now abc which is sorted.\nIn the third test case,\ns\ncannot be sorted.\nIn the fourth test case we will perform the following operations:\nThe lexicographically largest subsequence is zca. Then\ns\nbecomes abzc.\nThe lexicographically largest subsequence is zc. Then\ns\nbecomes abcz. The string becomes sorted.\nThus, we need\n2\noperations.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1400"
        ]
    },
    {
        "title": "B. Begginer's Zelda",
        "description": "You are given a tree\n†\n†\n. In one zelda-operation you can do follows:\nChoose two vertices of the tree\nu\nand\nv\n;\nCompress all the vertices on the path from\nu\nto\nv\ninto one vertex. In other words, all the vertices on path from\nu\nto\nv\nwill be erased from the tree, a new vertex\nw\nwill be created. Then every vertex\ns\nthat had an edge to some vertex on the path from\nu\nto\nv\nwill have an edge to the vertex\nw\n.\nIllustration of a zelda-operation performed for vertices\n1\nand\n5\n.\nDetermine the minimum number of zelda-operations required for the tree to have only one vertex.\n†\n†\nA tree is a connected acyclic undirected graph.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer\nn\n(\n2≤n≤\n10\n5\n) — the number of vertices.\ni\n-th of the next\nn−1\nlines contains two integers\nu\ni\nand\nv\ni\n(\n1≤\nu\ni\n,\nv\ni\n≤n,\nu\ni\n≠\nv\ni\n) — the numbers of vertices connected by the\ni\n-th edge.\nIt is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of\nn\nover all test cases does not exceed\n10\n5\n.\nOutput\nFor each test case, output a single integer — the minimum number of zelda-operations required for the tree to have only one vertex.\nExample\ninput\nCopy\n4\n4\n1 2\n1 3\n3 4\n9\n3 1\n3 5\n3 2\n5 6\n6 7\n7 8\n7 9\n6 4\n7\n1 2\n1 3\n2 4\n4 5\n3 6\n2 7\n6\n1 2\n1 3\n1 4\n4 5\n2 6\noutput\nCopy\n1\n3\n2\n2\nNote\nIn the first test case, it's enough to perform one zelda-operation for vertices\n2\nand\n4\n.\nIn the second test case, we can perform the following zelda-operations:\nu=2,v=1\n. Let the resulting added vertex be labeled as\nw=10\n;\nu=4,v=9\n. Let the resulting added vertex be labeled as\nw=11\n;\nu=8,v=10\n. After this operation, the tree consists of a single vertex.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "greedy",
            "trees",
            "*1100"
        ]
    },
    {
        "title": "A. Constructive Problems",
        "description": "Gridlandia has been hit by flooding and now has to reconstruct all of it's cities. Gridlandia can be described by an\nn×m\nmatrix.\nInitially, all of its cities are in economic collapse. The government can choose to rebuild certain cities. Additionally, any collapsed city which has at least one vertically neighboring rebuilt city and at least one horizontally neighboring rebuilt city can ask for aid from them and become rebuilt without help from the government. More formally, collapsed city positioned in\n(i,j)\ncan become rebuilt if both of the following conditions are satisfied:\nAt least one of cities with positions\n(i+1,j)\nand\n(i−1,j)\nis rebuilt;\nAt least one of cities with positions\n(i,j+1)\nand\n(i,j−1)\nis rebuilt.\nIf the city is located on the border of the matrix and has only one horizontally or vertically neighbouring city, then we consider only that city.\nIllustration of two possible ways cities can be rebuilt by adjacent aid. White cells are collapsed cities, yellow cells are initially rebuilt cities (either by the government or adjacent aid), and orange cells are rebuilt cities after adjacent aid.\nThe government wants to know the minimum number of cities it has to rebuild such that after some time all the cities can be rebuild.\nInput\nEach test consists of multiple test cases. The first line contains a single integer\nt\n(\n1≤t≤\n10\n4\n) — the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers\nn\nand\nm\n(\n2≤n,m≤100\n) — the sizes of Gridlandia.\nOutput\nFor each test case, output a single integer — the minimum number of cities the government needs to rebuild.\nExample\ninput\nCopy\n3\n2 2\n5 7\n3 2\noutput\nCopy\n2\n7\n3\nNote\nIn the first test case, it's enough for the government to rebuild cities\n(1,2)\nand\n(2,1)\n.\nIn the second test case, it's enough for the government to rebuild cities\n(1,4)\n,\n(2,2)\n,\n(3,1)\n,\n(3,6)\n,\n(4,3)\n,\n(5,5)\n,\n(5,7)\n.",
        "time_limit": "1 second",
        "memory_limit": "256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*800"
        ]
    },
    {
        "title": "F. Beautiful Tree",
        "description": "Lunchbox has a tree of size\nn\nrooted at node\n1\n. Each node is then assigned a value. Lunchbox considers the tree to be beautiful if each value is distinct and ranges from\n1\nto\nn\n. In addition, a beautiful tree must also satisfy\nm\nrequirements of\n2\ntypes:\n\"1 a b c\" — The node with the smallest value on the path between nodes\na\nand\nb\nmust be located at\nc\n.\n\"2 a b c\" — The node with the largest value on the path between nodes\na\nand\nb\nmust be located at\nc\n.\nNow, you must assign values to each node such that the resulting tree is beautiful. If it is impossible to do so, output\n−1\n.\nInput\nThe first line contains two integers\nn\nand\nm\n(\n2≤n,m≤2⋅\n10\n5\n).\nThe next\nn−1\nlines contain two integers\nu\nand\nv\n(\n1≤u,v≤n,u≠v\n) — denoting an edge between nodes\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nThe next\nm\nlines each contain four integers\nt\n,\na\n,\nb\n, and\nc\n(\nt∈{1,2}\n,\n1≤a,b,c≤n\n). It is guaranteed that node\nc\nis on the path between nodes\na\nand\nb\n.\nOutput\nIf it is impossible to assign values such that the tree is beautiful, output\n−1\n. Otherwise, output\nn\nintegers, the\ni\n-th of which denotes the value of node\ni\n.\nExamples\ninput\nCopy\n7 5\n1 2\n1 3\n1 4\n3 5\n4 6\n3 7\n1 6 5 1\n2 6 7 3\n1 2 7 1\n1 7 5 7\n2 4 2 2\noutput\nCopy\n1 6 7 5 3 4 2 \ninput\nCopy\n2 2\n1 2\n1 1 2 1\n1 1 2 2\noutput\nCopy\n-1",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "implementation",
            "trees",
            "*2800"
        ]
    },
    {
        "title": "E. Tree Queries",
        "description": "Those who don't work don't eat. Get the things you want with your own power. But believe, the earnest and serious people are the ones who have the last laugh... But even then, I won't give you a present.\n—Santa, Hayate no Gotoku!\nSince Hayate didn't get any Christmas presents from Santa, he is instead left solving a tree query problem.\nHayate has a tree with\nn\nnodes.\nHayate now wants you to answer\nq\nqueries. Each query consists of a node\nx\nand\nk\nother additional nodes\na\n1\n,\na\n2\n,…,\na\nk\n. These\nk+1\nnodes are guaranteed to be all distinct.\nFor each query, you must find the length of the longest simple path starting at node\nx\n†\nafter removing nodes\na\n1\n,\na\n2\n,…,\na\nk\nalong with all edges connected to at least one of nodes\na\n1\n,\na\n2\n,…,\na\nk\n.\n†\n†\nA simple path of length\nk\nstarting at node\nx\nis a sequence of distinct nodes\nx=\nu\n0\n,\nu\n1\n,…,\nu\nk\nsuch that there exists a edge between nodes\nu\ni−1\nand\nu\ni\nfor all\n1≤i≤k\n.\nInput\nThe first line contains two integers\nn\nand\nq\n(\n1≤n,q≤2⋅\n10\n5\n) — the number of nodes of the tree and the number of queries.\nThe following\nn−1\nlines contain two integers\nu\nand\nv\n(\n1≤u,v≤n\n,\nu≠v\n) — denoting an edge between nodes\nu\nand\nv\n. It is guaranteed that the given edges form a tree.\nThe following\nq\nlines describe the queries. Each line contains the integers\nx\n,\nk\nand\na\n1\n,\na\n2\n,…,\na\nk\n(\n1≤x≤n\n,\n0≤k<n\n,\n1≤\na\ni\n≤n\n) — the starting node, the number of removed nodes and the removed nodes.\nIt is guaranteed that for each query,\nx,\na\n1\n,\na\n2\n,…,\na\nk\nare all distinct.\nIt is guaranteed that the sum of\nk\nover all queries will not exceed\n2⋅\n10\n5\n.\nOutput\nFor each query, output a single integer denoting the answer for that query.\nExamples\ninput\nCopy\n7 7\n1 2\n1 3\n3 4\n2 5\n2 6\n6 7\n2 0\n2 1 1\n2 2 1 6\n3 1 4\n3 1 1\n5 0\n5 2 1 6\noutput\nCopy\n3\n2\n1\n4\n1\n4\n1\ninput\nCopy\n4 4\n1 2\n1 3\n2 4\n2 1 3\n3 1 4\n2 1 4\n2 3 1 3 4\noutput\nCopy\n1\n2\n2\n0\nNote\nIn the first example, the tree is as follows:\nIn the first query, no nodes are missing. The longest simple path starting from node\n2\nis\n2→1→3→4\n. Thus, the answer is\n3\n.\nIn the third query, nodes\n1\nand\n6\nare missing and the tree is shown below. The longest simple path starting from node\n2\nis\n2→5\n. Thus, the answer is\n1\n.",
        "time_limit": "4 seconds",
        "memory_limit": "512 megabytes",
        "tags": [
            "data structures",
            "dfs and similar",
            "graphs",
            "implementation",
            "trees",
            "*2500"
        ]
    }
]