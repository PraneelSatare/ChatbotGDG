{
    "solution": "2036C - Anya and 1100Idea: m3tr0 HintWith each query, to track the change in the presence of “1100” in a row, you don't have to go through the entire row — you can check just a few neighboring cells. TutorialFirst, in a naive way, let's count count — the number of times “1100” occurs in s.Then for each of q queries we will update count: consider the substring s[max(1,i−3);min(i+3,n)] before changing si and find before — the number of times that “1100” occurs in it. Then update si=v and similarly find after — the number of times that “1100” occurs in s[max(1,i−3);min(i+3,n)] after applying the query.Thus, by doing count=count+(after−before), we get the number of times that “1100” occurs in s after the query is applied. If count>0, the answer to the query is “YES”, otherwise it is “NO”.Complexity: O(|s|+q) Solution (m3tr0)#include <cstdio>\n#include <cstring>\n\nusing namespace std;\ntypedef long long l;\n\nchar buf[1000000];\nl n;\n\nbool check_1100(l i) {\n\tif (i < 0) return false;\n\tif (i >= n - 3) return false;\n\tif (buf[i] == '1' && buf[i + 1] == '1' && buf[i + 2] == '0' && buf[i + 3] == '0') return true;\n\treturn false;\n}\n\nvoid solve() {\n\tscanf(\"%s\", buf);\n\tn = strlen(buf);\n\tl count = 0;\n\tfor (l i = 0; i < n; i++)\n\t\tif (check_1100(i)) count++;\n\t\n\tl q; scanf(\"%lld\", &q);\n\twhile (q--) {\n\t\tl i, v; scanf(\"%lld %lld\", &i, &v); i--;\n\t\tif (buf[i] != '0' + v) {\n\t\t    bool before = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);\n\t\t    buf[i] = '0' + v;\n\t\t    bool after = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);\n\t\t    count += after - before;\n\t\t}\n\t\tprintf(count ? \"YES\\n\" : \"NO\\n\");\n\t}\n}\n\nint main() {\n\tl t; scanf(\"%lld\", &t);\n\twhile (t--) solve();\n}\n"
}