{
    "solution": "1992D - Test of LoveIdea: ArSarapkinPreparation: K1o0n TutorialIn this problem, there are two main solutions: dynamic programming and greedy algorithm.Dynamic programming solution: dpi − the minimum number of meters that need to be swum to reach the i-th cell. The base case of the dynamic programming is dp0=0. Then, the update rule is: dpi=minimum of{dpi−1+1min(dpj)if Ai='W'for all j,where:max(0,i—m)≤j<i and Aj='L' Solution complexity: O(nm).Greedy algorithm solution: If we can jump, we want to jump to the shore if possible. If we can't, we want to jump to any log ahead to jump from it later. If we can't, we jump as far as possible to avoid crocodiles and swim as little as possible.Solution complexity: O(n). Solution (greedy)def run() -> None:\n    n,m,k = map(int, input().split())\n    A = input()\n    logs = [i for i in range(n) if A[i] == \"L\"]\n    logs.append(n+1)\n    i = -1\n    next_log = 0\n    while i < n-1:\n        if m >= logs[next_log] - i:\n            i = logs[next_log]\n        else:\n            i+=m\n            if i > n-1:\n                print(\"YES\")\n                return\n            while i < n and i < logs[next_log]:\n                if A[i] != \"C\" and k > 0:\n                    i+=1\n                    k-=1\n                else:\n                    print(\"NO\")\n                    return\n        next_log +=1\n    print(\"YES\")\n \nfor _ in range(int(input())):\n    run() Solution (DP)#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, k; \n        cin >> n >> m >> k;\n        string s;\n        cin >> s;\n        vector<int> dp(n + 2, -1);\n        dp[0] = k;\n        for (int i = 1; i <= n + 1; i++) {\n            if (i != n + 1 && s[i - 1] == 'C') \n                continue;\n            for (int t = 1; t <= m; t++)\n                if (i - t >= 0 && (i - t == 0 || s[i - t - 1] == 'L'))\n                    dp[i] = max(dp[i], dp[i - t]);\n            if (i > 1 && s[i - 2] == 'W') \n                dp[i] = max(dp[i], dp[i - 1] - 1);\n        }\n        if (dp[n + 1] >= 0) \n            cout << \"YES\\n\";\n        else \n            cout << \"NO\\n\";\n    }\n}"
}