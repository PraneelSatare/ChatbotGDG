967B - Watering SystemIt's obvious that we should block several largest holes. Let's first sort them. After that, let's iterate through the number of blocked holes, maintaining the sum of sizes of non-blocked holes S. With the value S it is easy to compute if the flow from the first hole is large enough or not. Just output the number of blocked pipes at the first moment when the flow is large enough. The complexity is O(n). 925A - Stairs and ElevatorsFirst thing to mention is that we can use no more than one stairs or elevator per query. Indeed, optimal path is always a few sections horizontally, then a stair of elevator, then a few sections horizontally.Then, we can note that we can always use one of the nearest stairs/elevators to start/finish. Using this fact, we can binary search in the sequence of stairs/elevators to find the optimal one, and choose the optimum between using a stairs and an elevator. Don't forget about the case where you don't have to reach any stairs/elevators.The complexity is O(qlogn). 925B - Resource DistributionSuppose that the load of the first service was divided among k1 servers and the load of the second service was divided among k2 servers. In such case first service will be running on k1 servers of resource at least p1=⌈x1/k1⌉ and second service will be run on k2 servers of resource at least p2=⌈x2/k2⌉. Suppose that p1≤p2, the remaining case will be dealt in the similar way. Remove all servers that have less than p1 resources, we are not going to use them. We may consider only assignments in which any server assigned to the first service has at most as many resources as any server assigned to the second service (otherwise we may swap them and the answer will still be correct). In such manner we may show that the first service may be assigned to the first k1 servers having at least p1 resource units and the second service may be assigned to the last k2 servers in ascending order of available resources.Finally notice that if we fix k1, the optimal value of k2 is minimum such that the last k2 servers have at least p2 resource units. Calculate the minimum possible k2 in linear time, after that try each possible value of k1 and check if the first k1 servers having at least p1 resource units do not intersect with the last k2 servers (it may be checked in a single binary search).We got a solution with running time of O(nlogn). 925C - Big SecretLet's assume that we've found a suitable permutation of all numbers, except all occurences of the number 1. When can we insert the 1's so that the new arrangement of numbers is again good? We can see that the XOR of all numbers before any occurence of the number 1 must be even, so there should an even number of odd numbers before it.Suppose that there are x 1's in the input, and y odd numbers greater than 1. If x>y+1, then in any arrangement there is going to be a pair of 1's such that there are no odd numbers between them, hence the condition above cannot hold for both of them simultaneously. On the other hand, if x≤y+1, then it is possible to insert the 1's into any permutation of greater numbers. Indeed, we can place one instance of 1 at the start, and then place remaining 1's immediately after greater odd numbers.Note that this argument works just as well if we consider numbers in the range [2k,2k+1) as "1's", and numbers in [2k+1,∞) as "numbers greater than 1". Note further that it doesn't matter how exactly we insert the "1's" since number of available gaps doesn't depend on that. Hence, we can go as follows: group the numbers by their leading bits. Make an empty list for the answer, and process the numbers in groups by decreasing of their leading bits. Suppose there are x numbers with leading bit k, and y greater numbers that have 1 in the k-th bit. If x>y+1, then there is no answer. Otherwise, insert the numbers from the current group as described above.The complexity of this solution is O(nlogA), where A is the largest value among the numbers in the input. 925D - Aztec CatacombsLet us formualate a problem in terms of graph theory and make some observation. Denote the start and the finish vertices as s and t.Observation 1. If vertices s and t are connected with a simple path consisting of k edges, then by the statement of the problem Indiana Johns may use it leading us to the answer of length k. Thus, the answer does not exceed d where d is the length of the shortest path between s and t if s and t are connected and ∞ otherwise. Let us call path consisting only of the original edges of the graph trivial and the paths including originally non-existent edges non-trivial.Observation 2. The length of any non-trivial path is at least 4. Indeed, let s=v0−→e1v2−→e2⋯−→ekvk=t be the valid path in which some of the edges ei is missing in the original graph. Notice that the edge e1 may not be missing as by the moment we follow it, nothing was flipped yet, and e2 also may not be missing as it requires e2 to be same with e1 which was just flipped. Also note that e3 may not be the last edge in our path because otherwise it must be missing in the original graph (since the path is non-trivial), and we did not visit vertex v2 yet as v2≠v1 and v2≠v0=1. Thus, k≥4.Observation 3. If d≤4, then the answer is d. It immediately follows from two previous observations: shortest trivial path has the length of d and shortest non-trivial has the length of at least 4.Наблюдение 4. If d≥4 and there exists a vertex v2 at the distance of 2 from v0=s, then there exists a non-trivial path of length 4. Indeed, v0→v1→v2→v0→t is such path where v1 is a vertex through which the path of length 2 between v0 and v2 passes. Finally, note that v2 and v0 are not initially connected (otherwise the distance between v0 and v2 would be 1), hence when we visit v2, the edge v2→v0 is present. Similarly, by the moment of second visit of vertex v0 originally missing edge v0→t appears.Observation 5. Any non-trivial path of length 4 looks exactly as described in an observation 4, first two initially existent edges, then newly appeared edge leading to s and finally newly appeared edge leading to t. It immediately follows from the explanation of the observation 2.Observation 6. If d≥4 and there no vertex v2 located at the distance 2 from s, then s is connected with all vertices in its connected component and this component does not contain t.Observation 7. If, under conditions of the previous observation, it we remove vertex s, then all the vertices initially adjacent to it will be distributed into several connected components. If all connected components are cliques, there are no valid paths. Indeed, after first transition we get into some clique and then we may only move inside it and it keeps shrinking until we get to an isolated vertex from which we can not go anywhere.Observation 8. If any of the connected components adjacent with s is not a clique, then the shortest valid non-trivial path has a length of 5. Indeed, consider a connected component C initially connected with s that is not a clique. It is not a clique, hence it contains a vertex v1 of degree less than |C|−1. This vertex is not connected with a whole component C, thus there are vertices v2,v3∈C such that v3 is not connected with v1, while v1 and v2 are connected and v2 and v3 are also connected with an edge. It means that there is a non-trivial path v0→v1→v2→v3→v1→t. The observations above cover all possible cases in this problem and also yield a solution working in linear time in terms of a size of the original graph. 925E - May HolidaysIn terms of trees we have a rooted tree whose vertices may be activated and deactivated, and each vertex has a limit for the number of deactivated vertices among its descendants. We are required to switch the state of some vertex, and after each query we report the number of activated vertices unsatisfied vertices. Let the balance of a vertex be equal to the difference between its limit of deactivated descendants and the actual number of deactivated vertices among its descendants. In such terms we are interested in the number of activated vertices with the negative balance.Let's utilize the idea of sqrt-optimization. Consider a block of k consecutive queries, let us answer all of them. Suppose this query affects the state of vertices v1,v2,…,vl (l≤k), let us call such vertices interesting. Then, during the current query block, the balance will change only for the vertices that have at least one interesting vertex in its subtree.Let's perform a classical trick of building the condensed tree containing the given interesting vertices. Namely, sort all the interesting vertices in order of their visit when doing DFS, and add all vertices of form lca(vi,vi+1) for all 1≤i<l to the set of interesting vertices. After such procedure all vertices whose balance may change may be splitted into O(k) vertical paths each of which ends in an interesting vertex. Now we are going to consider separately the interesting vertices and the interior vertices of all paths between interesting vertices. In each of the paths the balance of all vertices is changed simultaneously, thus we may sort all the vertices in each path by balance and then group all vertices having the same balance together. Introduce a pointer that initially stands at the first satisfied group (with non-negative balance). When the balance of all groups is changed by 1, instead of actually changing the value of balance we may just shift the pointer by at most one position to the left or to the right (artificially changing the origin) and accounting at most one group the pointer has passed in the answer. On each query we have to perform such an operation with every path and interesting vertex that is located above the queried vertex. Since each vertex and each path is processed in O(1), processing a single query takes O(k) time and processing all queries inside a block takes O(k2) time. It is possible to build all paths and groups in running time of a single DFS plus sort time (std::sort or counting sort) for grouping vertices of equal balance. This part of solution takes O(n) per each query block or O(nlogn) depending on used sorting algorithm.If we use count sort, the resulting complexity will be O(mk(k2+n)), finally we can take k=Θ(n−−√) and get O(mn−−√) running time. 925F - Parametric CirculationFirst, let's use the classical reduction of lr-circulation problem to the maximum flow problem. Consider a network G′=(V∪{s,t},E′) where for each e=uv∈E there are three edges:  e0=uv with capacity ce0=re−le  e1=sv with capacity ce1=le  e2=ut with capacity ce2=le Statement: it is possible to provide a bisection between s−t flows of value ∑e∈Ele in G′ and lr-circulations in G. Indeed, consider a flow f′ in G′, that saturates all edges going from s (and all the edges leading into t at the same time). Let fe=f′e0+le. Notice that it is a correct circulation: for any vertex v ∑e∈δ+(v)fe=∑e∈δ+(v)f′e0+∑e∈δ+le=∑e∈δ+(v)f′e0+∑e∈δ+fe1=∑e∈δ−(v)f′e0+∑e∈δ−fe2=∑e∈δ−(v)f′e0+∑e∈δ−le=∑e∈δ−(v)fewhere the middle equation is immediately following from the conservation condition for any vertex from V for a flow f′.On the other hand, the obtained circulation is indeed an lr-circulation because of how we got values of f′e. By performing all the steps in the reverse direction, we may recover a maximum flow in G′ by any lr-circulation that finishes our proof.Now we are going to answer the following question: we have a parametric network G′(t) in which all capacities linearly depend on t, we have to find the probability that G′ allows a flow that saturates all edges from the source under condition that t is sampled from U[0,1].Let us show that the set of t that allow existence of a sought flow is a segment. It follows from the fact that the value maxflow(t) of a maximum flow in G′(t) is concave: suppose f′(t1) is a an admissible flow in G′(t1) and f′(t2) is an admissible flow in G′t2. Then it is easy to see that λf′(t1)+(1−λ)f′(t2) is an admissible flow in G′(λt1+(1−λ)t2) for any λ∈[0,1] (as all the constraints on variables f′e are linear inequalities), from which immediately follows that maxflow(λt1+(1−λ)t2)≥λmaxflow(t1)+(1−λ)maxflow(t2).Denote suml(t)=∑e∈El(t). Let us notices that gap(t)=suml(t)−maxflow(t)≥0 for any t and we are interested in precisely those values of t, such that gap(t)=0. Thus, the sought values of t form a segment as the function gap(t) is convex.The remaining part of the solution is very simple: find a minimum of a convexvalue gap(t) over a segment [0,1]. If it is non-zero, then the answer is 0. Otherwise, we can locate the boundaries of an answer segment using two binary searches and print the difference between them.While implementing such a solution, one may face several difficulties arising from the precision issues, so we will provide two observations that may help you deal with them.One may notice that maxflow(t) is actually a piecewise linear function, all pieces of which have the integer slope. Actually, maxflow(t)=mincut(t)=mincut Ccost(C,t), and the cost of any fixed cut in G′(t) is a linear function of t with an integer slope. Thus, maxflow(t) is a lower envelope of a family of linear functions with integer slopes. The similar fact holds for a function gap(t) also. And we are interested in a horizontal segment in gap(t) which may be found using the binary search over a sign of a derivative gap′(t). Finally notice that calculating a derivative gap′(t) may be done by finding a maximum flow and adding up all slopes of capacities of the edges defining a minimum cut restricting given maximum flow (since exactly this cut provides a linear constraint defining a segment of a function gap(t), which a point t belongs to).An alternative observation — consider only the points t such that t=k107 where k is integer. If we keep only such points on the sought segment, its length will decrease by no more than 2⋅10−7 which is allowed by a required answer precision. Finally, we can multiply all be and de by 107 and consider t to be an integer between 0 and 107 which allows you to implement a solution that only uses integer data types.We get a solution with a running time of O(maxflow⋅logprec−1) where prec is a required precision equal to 10−6 under conditions of a given problem and maxflow is a running time of your favourite maximum flow algorithm. Practically you could use Dinic algorithm or Edmonds-Karp algorithm with capacity scaling.