{
    "solution": "1324C - Frog JumpsThe only observation we need is that we don't need to jump left at all. This only decreases our position so we have less freedom after the jump to the left. Then, to minimize d, we only need to jump between the closest 'R' cells. So, if we build the array b=[0,r1,r2,…,rk,n+1], where ri is the position of the i-th 'R' cell from left to right (1-indexed), then the answer is maxi=0kbi+1−bi.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<int> pos;\n\t\tpos.push_back(0);\n\t\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\t\tif (s[i] == 'R') pos.push_back(i + 1);\n\t\t}\n\t\tpos.push_back(s.size() + 1);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < int(pos.size()) - 1; ++i) {\n\t\t\tans = max(ans, pos[i + 1] - pos[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
}