{
    "solution": "1958A - 1-3-5There are two main ways to solve this problem: brute force and casework.To solve this problem with brute force, you can use three nested loops to iterate on the number of coins of each type from 0 to n, check if they give exactly n burles in total, and update the answer. This can be optimized in many different ways, like iterating only on the number of coins worth 3 and 5 burles and calculating the number of coins worth 1 burle in O(1). However, the approach with three nested loops works in O(n3) and is fast enough.The solution with casework basically works because of an observation that if n is big enough (8 or greater), it can always be expressed as the sum of 3's and/or 5's. So, we can get the answers for nâ‰¤7 by hand and if n>7, jsut output 0. This observation is kinda intuitive, but if you want a proof, you can use Chicken McNugget Theorem (in my opinion, one of the coolest names for a math topic!) Solution (PavelKunyavskiy)fun main() {\n    val ans = IntArray(101) { Int.MAX_VALUE }\n    ans[0] = 0\n    for (i in ans.indices) {\n        for ((d, c) in listOf(1 to 1, 3 to 0, 5 to 0)) {\n            if (i + d in ans.indices) ans[i + d] = minOf(ans[i + d], ans[i] + c)\n        }\n    }\n    repeat(readInt()) {\n        println(ans[readInt()])\n    }\n}\n\nprivate fun readInt() = readln().toInt()\nprivate fun readLongs() = readStrings().map { it.toLong() }\nprivate fun readStrings() = readln().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }"
}