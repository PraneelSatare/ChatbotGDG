{
    "solution": "1635C - Differential SortingFirst of all, if an−1>an, then the answer is −1 since we can't change the last two elements.If an≥0, there exists a simple solution: perform the operation (i,n−1,n) for each 1≤i≤n−2.Otherwise, the answer exists if and only if the initial array is sorted. Proof: Assume that an<0 and we can sort the array after m>0 operations. Consider the last operation we performed (xm,ym,zm). Since all elements should be negative after the last operation, so azm<0 should hold before the last operation. But axm=aym−azm>aym after this, so the array isn't sorted in the end. By contradiction, we have proved that we can't perform any operations as long as an<0. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector <int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        if (a[n - 2] > a[n - 1]) {\n            cout << -1 << endl;\n        } else {\n            if (a[n - 1] < 0) {\n                if (is_sorted(a.begin(), a.end())) {\n                    cout << 0 << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            } else {\n                cout << n - 2 << endl;\n                for (int i = 1; i <= n - 2; ++i) {\n                    cout << i << ' ' << n - 1 << ' ' << n << endl;\n                }\n            }\n        }\n    }\n}"
}