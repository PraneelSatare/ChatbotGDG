{
    "solution": "1481B - New ColonyThe two key observation here is that if one boulder fall into the collection system all later boulders will fall into the collection system too and the number of boulders that will end up at any mountain is too small (Hence it will be at most (n−1)⋅(100−1)).So we can simulate all boulders throwing until one boulder fall into the collection system, this will take at most O(100⋅n). code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define fast ios::sync_with_stdio(false);cin.tie(0);\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n\tfast\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tvector<int> a(n);\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tint mx = *max_element(all(a));\n\t\tif(n * mx < k){\n\t\t\tcout << -1 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = n+1;\n\t\tfor(int b=0;b<k;b++){\n\t\t\tint to = -2;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tif(a[i] < a[i+1]){\n\t\t\t\t\tto = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = to + 1;\n\t\t\tif(to == -2)break;\n\t\t\ta[to]++;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\t\n}Author: Warawreh "
}