{
    "solution": "1843D - Apple TreeLet cntv be the number of vertices from which an apple can fall if it is in the vertex v. Then the answer to the query is cntvâ‹…cntu.Note that the value of cntv is equal to the number of leaves in the subtree of vertex v. Then, these values can be computed using the DFS or BFS. The value cnt for a vertex will be equal to 1 if this vertex is a leaf, otherwise it will be equal to the sum of these values for all children of the vertex.Total complexity: O(n+q). Solution#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nvector<vector<int>> g;\nvector<ll> cnt;\n \nvoid dfs(int v, int p) {\n    if (g[v].size() == 1 && g[v][0] == p) {\n        cnt[v] = 1;\n    } else {\n        for (auto u : g[v]) {\n            if (u != p) {\n                dfs(u, v);\n                cnt[v] += cnt[u];\n            }\n        }\n    }\n}\n \nvoid solve() {\n    int n, q;\n    cin >> n;\n \n    g.assign(n, vector<int>());\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n \n    cnt.assign(n, 0);\n    dfs(0, -1);\n \n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int c, k;\n        cin >> c >> k;\n        c--; k--;\n \n        ll res = cnt[c] * cnt[k];\n        cout << res << '\\n';\n    }\n}\n \nsigned main() {\n    int tests;\n    cin >> tests;\n    while (tests--) {\n        solve();\n    }\n \n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n66\n\n\n\n Good task \n\n    \n\n\n410\n\n\n\n Average task \n\n    \n\n\n53\n\n\n\n Bad task \n\n    \n\n\n40\n\n\n\n "
}