{
    "solution": "1935B - Informatics in MACIdea: AndreyPavlov  Preparation: AndreyPavlov, i_love_penguins  Editorial: AndreyPavlov HintsHint 1What is the minimum k that can be in a division? Hint 2Suppose MEX(x,y)=MEX(y+1,z), what can be said about MEX(x,z)? TutorialSuppose we correctly divided the array into k>2 segments — (1,r1),(l2,r2),…,(lk,rk). Then, note that we can merge first two subsegments, as the numbers from 0 to mex−1 are encountered in these two segments and the number mex is not encountered in them. Therefore, if there is a division into k>2 segments, then there is also for k−1 segments.Therefore, it is sufficient to check whether there is a division of the array into k=2 segments, which can be done in O(n) by precalcing MEX on the prefixes and suffixes, then we need to find some i for which MEX(1,i)=MEX(i+1,n). Implementation on C++/* Includes */\n#include <bits/stdc++.h>\n \n/* Using libraries */\nusing namespace std;\n\n/* Defines */\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define vc vector\n#define pii pair <int, int>\n#define int long long\n \nvoid solve () {\n    int n;\n    cin >> n;\n    vc <int> a(n);\n    vc <int> cnt1(n + 1), cnt2(n + 1);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        cnt2[a[i]]++;\n    }\n    int mex1 = 0, mex2 = 0;\n    while (cnt2[mex2])\n        ++mex2;\n    for (int i = 0; i < n; ++i) {\n        cnt1[a[i]]++;\n        if (--cnt2[a[i]] == 0 && mex2 > a[i]) {\n            mex2 = a[i];\n        }\n        while (mex2 && !cnt2[mex2 - 1])\n            --mex2;\n        while (cnt1[mex1])\n            ++mex1;\n        if (mex1 == mex2) {\n            cout << \"2\\n\";\n            cout << 1 << \" \" << i + 1 << \"\\n\";\n            cout << i + 2 << \" \" << n << \"\\n\";\n            return;\n        }\n    }\n    cout << \"-1\\n\";\n}\n\nsigned main() {\n    fast;\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n} Implementation on Pythondef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    cur_mex = 0\n    cur_have = [0] * (n + 1)\n    for el in a:\n        cur_have[el] += 1\n    while cur_have[cur_mex]:\n        cur_mex += 1\n\n    another_mex = 0\n    another_have = [0] * (n + 1)\n    for i in range(n):\n        cur_have[a[i]] -= 1\n        if cur_have[a[i]] == 0 and cur_mex > a[i]:\n            cur_mex = a[i]\n\n        another_have[a[i]] += 1\n        while another_have[another_mex]:\n            another_mex += 1\n\n        if cur_mex == another_mex:\n            print(2)\n            print(\"1 \" + str(i + 1))\n            print(str(i + 2) + \" \" + str(n))\n            return\n\n    print(-1)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
}