{
    "solution": "1343C - Alternating SubsequenceFirstly, let's extract maximum by inclusion segments of the array that consists of the numbers with the same sign. For example, if the array is [1,1,2,−1,−5,2,1,−3] then these segments are [1,1,2], [−1,−5], [2,1] and [−3]. We can do it with any \"two pointers\"-like algorithm. The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block. And as we want to maximize the sum, we need to take the maximum element from each block.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tauto sgn = [&](int x) {\n\t\tif (x > 0) return 1;\n\t\telse return -1;\n\t};\n\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tlong long sum = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint cur = a[i];\n\t\t\tint j = i;\n\t\t\twhile (j < n && sgn(a[i]) == sgn(a[j])) {\n\t\t\t\tcur = max(cur, a[j]);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tsum += cur;\n\t\t\ti = j - 1;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
}