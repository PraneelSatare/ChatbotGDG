{
    "solution": "989B - A Tide of RiverscapeOur very first observation is that when p≤n2, the answer can never be \"No\".Under this case, find any dot si=\".\". At least one of si−p and si+p exists because p≤n2 and 1≤i≤n. We want to make si different from this character. In case this character is \"0\" or \"1\", replace the dot the other way round. In case it's a dot, replace the two dots differently with \"0\" and \"1\". After that, fill the remaining dots arbitrarily, and we obtain a valid answer.If p>n2, we'd like to find a dot with a similiar property. That is, si=\".\", and si−p or si+p exists. Go over all dots, try find one, and carry out the same operation as above. If no such dot exists, the answer is \"No\".Bonus. Prove the time complexity of the seemingly-brute-force solution below.Bonus. In case the answer is \"Yes\", find the lexicographically smallest string that fulfill the requirements.Bonus. Solve the bonus challenge with n≤105. (Estimated difficulty: Div. 2 C) Noam's C++ solution#include <bits/stdc++.h>\n#define endl '\\n'\n#define fast ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define finish(x) return cout << x << endl, 0\nusing namespace std;\n\nstring s, t;\nint n, p;\n\nbool isperiod() {\n\tfor (int i = p; i < n; i++)\n\t\tif (t[i] != t[i - p]) return false;\n\treturn true;\n}\n\nint main() {\n\tfast;\n\tcin >> n >> p >> s;\n\n\t// attempt 1\n\tt = s;\n\tfor (auto &i : t)\n\t\tif (i == '.') i = '0';\n\tif (!isperiod()) finish(t);\n\n\t// attempt 2\n\tint i = 0;\n\twhile (i < n && s[i] != '.') i++;\n\tif (i + p < n) {\n\t\tt[i] = '1';\n\t\tfinish(t);\n\t}\n\ti = n - 1;\n\twhile (i >= 0 && s[i] != '.') i--;\n\tif (i - p >= 0) {\n\t\tt[i] = '1';\n\t\tfinish(t);\n\t}\n\n\tfinish(\"No\");\n} Python solution for the original problem as well as for the last challengen, p = map(int, input().split())\ns = input()\n\nt = s.replace('.', '0')\n\nif all(t[i] == t[i + p] for i in range(n - p)):\n    rmost = -1\n    for r in range(p - 1, -1, -1):\n        x = s[r::p].rfind('.')\n        if x != -1 and s[r::p] != '.':\n            rmost = max(rmost, x * p + r)\n    if rmost == -1:\n        print('No')\n    else:\n        print(t[:rmost] + '1' + t[(rmost + 1):])\nelse:\n    print(t) C++ seemingly-brute-force solution#include <algorithm>\n#include <cstdio>\n\nstatic const int MAXN = 2005;\n\nstatic int n, p;\nstatic char s[MAXN];\n\nstatic int dots_ct = 0, dots[MAXN];\n\nint main()\n{\n    scanf(\"%d%d%s\", &n, &p, s);\n\n    for (int i = 0; i < n; ++i) if (s[i] == '.') {\n        dots[dots_ct++] = i;\n        s[i] = '0';\n    }\n\n    for (int i = 1; i <= (1 << std::min(dots_ct, 19)); ++i) {\n        bool is_period = true;\n        for (int j = 0; j < n - p; ++j)\n            if (s[j] != s[j + p]) { is_period = false; break; }\n        if (!is_period) {\n            puts(s);\n            return 0;\n        }\n        for (int j = 0; j <= __builtin_ctz(i); ++j)\n            s[dots[j]] ^= 1;\n    }\n\n    puts(\"No\");\n    return 0;\n} "
}