{
    "solution": "1478B - Nezzar and Lucky NumberFor any given d, We can observe the following:   10d to 10d+9 contains d as one of its digit  Let k=10d+9 be the upper bound of such range For every number x>k, we can keep reducing x by d, x will eventually fall into the range mentioned above, which contains d as digit. Therefore, for numbers x>k, they are always achievable. For x≤k−10, as k<=109, we can run a standard knapsack dynamicprogramming solution, where dp[x] indicates if x is achievable. dp[x] is achievable, if and only if one of the following is true:   x=0  For some y<x, dp[y] is true and x−y contains d as digit Iterating for every x, all dp[x] for x<k can be computed with O(k) per state (as we only need to consider y<k.Besides dynamic programming solution, brute force solutions with enough optimization should also pass the test cases easily.Time complexity: O((10d)2) per test case. Solution#include<bits/stdc++.h>\nusing namespace std;\n \nconst int maxn=207;\nint t,d,q;\nbool dp[maxn];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>t;\n    while (t--){\n        memset(dp,0,sizeof(dp));\n        dp[0]=1;\n        cin>>q>>d;\n        if (!d) d+=10;\n        int mx=d*10;\n        for (int i=0;10*i+d<=mx;++i){\n            for (int j=0;10*i+d+j<=mx;++j){\n                dp[10*i+d+j]|=dp[j];\n            }\n        }\n        while (q--){\n            int u;\n            cin>>u;\n            if (u>=mx||dp[u]) cout<<\"YES\\n\";\n            else cout<<\"NO\\n\";\n        }\n    }\n    return 0;\n}"
}