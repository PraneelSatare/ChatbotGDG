1691B - Shoe ShufflingWe can observe that the number of pairs of shoes greater than their size is limited for any student. So if student j wears shoes that are greater than their size, then some student i who has a size greater than student j will compromise their size. So say a valid shuffling exists where a student gets shoes of size greater than their own, i.e., student j got shoes of student i where si>sj. Then, for all pairs of shoes of size sj, one pair will go to a student whose size is smaller than sj. This chain will continue until a student with shoe size s1 gets a pair of shoes greater than theirs, and then there will exist a pair of shoes of size s1 that no student can wear. Thus, if a valid shuffling, every student must get shoes of the same size as their own.Hence, a valid shuffling exists if more than one student has the same size shoes for all shoe sizes. A valid shuffling can be generated by rearranging students' shoes with the same shoe size such that no one gets their shoes. This can be done in multiple ways, for example, cyclic rotation. C++ Code#include <bits/stdc++.h>

using namespace std;

#define ll long long
typedef vector<ll> vll;
#define io                            \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL)

int main()
{
    io;
    ll tc;
    cin >> tc;
    while (tc--)
    {
        ll n;
        cin >> n;
        vll s(n), p(n);
        for (ll i = 0; i < n; ++i)
            cin >> s[i];

        ll l = 0, r = 0;
        bool ans = true;
        for (ll i = 0; i < n; ++i)
            p[i] = i + 1;

        while (r < n)
        {
            while (r < n - 1 and s[r] == s[r + 1]) // get range [l,r] with equal values
                ++r;
            if (l == r)
                ans = false;
            else
                rotate(p.begin() + l, p.begin() + r, p.begin() + r + 1); // rotate right in range [l,r]
            l = r + 1;
            ++r;
        }
        if (ans)
        {
            for (auto &x : p)
                cout << x << " ";
            cout << endl;
        }
        else
            cout << -1 << endl;
    }
    return 0;
}