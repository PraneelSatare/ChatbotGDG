1713B - Optimal ReductionLet's call M=max(a1,a2,…,an).The problem asks us to make all its elements become 0 in some operations. And for each operation, we subtract each elements in an subarray by 1. Thus, every largest elements of the array have to be decreased in at least M operations. And also because of that, min(f(p)) over all permutations p of a is never less than M.Every permutations p of a such that f(p)=M have the same construction. That is, they can be divided into 2 subarrays where the left subarray is sorted in non-decreasing order, and the right subarray is sorted in non-increasing order. In other words, the elements of the array should form a mountain. Why?This is how to perform the operations: assign l equal to the index of the leftmost element whose value is not 0, and assign r equal to the index of the rightmost element whose value is also not 0, then subtract each element al,al+1,…,ar by 1. Repeat the operation until all elements become 0. The thing is each element of the array is always greater or equal than every elements in the left side or the right side of it so it can never become negative at some point of performing the operations. Besides, all the largest elements are also included in each operation that we perform, which mean we've achieved the goal to make all elements of the array become 0 in M operations.So how to check whether f(a)=M or not? Well, we can define preLen equal to the length of the longest prefix which is sorted in non-decreasing order. Then define sufLen equal to the length of the longest suffix which is sorted in non-increasing order. If preLen+sufLen≥n, the answer is YES.Time complexity: O(n) Solution#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;

int n, a[N];

int main() {
    int tc;
    for (cin >> tc; tc--; ) {
        cin >> n;
        for (int i = 1; i <= n; i++)
            cin >> a[i];

        int preLen = 1;
        while (preLen < n && a[preLen] <= a[preLen + 1])
            preLen++;

        int sufLen = 1;
        while (sufLen < n && a[n-sufLen] >= a[n-sufLen + 1])
            sufLen++;

        if (preLen + sufLen >= n)
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }
} Feedback Didn't solve 

    


125



 Good problem 

    


347



 Average problem 

    


81



 Bad problem 

    


66



 