{
    "solution": "1006B - Polycarp's PracticeThe maximum possible total profit you can obtain is the sum of the k largest values of the given array. This is obvious because we can always separate these k maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array. I suggest the following: extract k largest values of the given array and place a separator right after each of them (except the rightmost one).Overall complexity is O(nlogn). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin); \n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> res(n);\n\tvector<int> a(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> res[i].first;\n\t\ta[i] = res[i].first;\n\t\tres[i].second = i + 1;\n\t}\n\t\n\tsort(res.begin(), res.end());\n\treverse(res.begin(), res.end());\n\tsort(res.begin(), res.begin() + k, [&](pair<int, int> a, pair<int, int> b) { return a.second < b.second; });\n\t\n\tint lst = 0, sum = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t    sum += *max_element(a.begin() + lst, a.begin() + res[i].second);\n\t\tlst = res[i].second;\t\n\t}\n\tsum += *max_element(a.begin() + lst, a.end());\n\tcout << sum << endl;\n\t\n\n\tlst = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t\tcout << res[i].second - lst << \" \";\n\t\tlst = res[i].second;\t\n\t}\n\tcout << n - lst << endl;\n\t\n\treturn 0;\n}"
}