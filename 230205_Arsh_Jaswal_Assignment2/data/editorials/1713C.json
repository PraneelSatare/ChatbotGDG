{
    "solution": "1713C - Build PermutationFirst, let's prove that the answer always exists. Let's call the smallest square number that is not smaller than k is h. Therefore h≤2⋅k, which means h−k≤k. Proof. So we can fill pi=h−i for (h−k≤i≤k). Using this method we can recursively reduce k to h−k−1, then all the way down to −1.We can prove that h−k≥0, as h≥k.Time complexity: O(n) Solution#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, ans[N];\n\nvoid recurse(int r) {\n\tif (r < 0) return;\n\tint s = sqrt(2*r); s *= s;\n\tint l = s - r; recurse(l - 1);\n\tfor (; l <= r; l++, r--) {\n\t\tans[l] = r; ans[r] = l;\n\t}\n}\n\nint main() {\n\tint tc; cin >> tc;\n\twhile (tc--) {\n\t\tcin >> n; recurse(n - 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << ans[i] << ' ';\n\t\tcout << '\\n';\n\t}\n} Feedback Didn't solve \n\n    \n\n\n272\n\n\n\n Good problem \n\n    \n\n\n614\n\n\n\n Average problem \n\n    \n\n\n58\n\n\n\n Bad problem \n\n    \n\n\n90\n\n\n\n "
}