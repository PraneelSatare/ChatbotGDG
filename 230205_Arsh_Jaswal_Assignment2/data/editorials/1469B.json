{
    "solution": "1469B - Red and BlueDenote pi as the sum of first i elements of r, and qj as the sum of first j elements of b. These values can be calculated in O(n+m) with prefix sums.The first solution is to use dynamic programming. Let dpi,j be the maximum value of f(a) if we placed the first i elements of r and the first j elements of b. Transitions can be performed in O(1): we either place an element from r (then we go to dpi+1,j and update it with max(dpi,j,pi+1+qj)), or place an element from b (then we go to dpi,j+1 and update it with max(dpi,j,pi+qj+1)). The answer is stored in dpn,m, and this solution works in O(nm).The second solution: observe that the sum of several first elements of a is the sum of several first elements of r and several first elements of b. So each prefix sum of a (and the answer itself) is not greater than maxni=0pi+maxmj=0pj. It's easy to show how to obtain exactly this answer: let k be the value of i such that pi is maximized, and l be the value of j such that qj is maximized. Let's place the first k elements of r, then the first l elements of b (so the current sum is exactly maxni=0pi+maxmj=0pj), and place all of the remaining elements in any possible order. So, the answer is maxni=0pi+maxmj=0pj. This solution works in O(n+m). Solution 1 (Ne0n25)#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> r(n);\n\tfor (int &x : r) cin >> x;\n\tint m;\n\tcin >> m;\n\tvector<int> b(m);\n\tfor (int &x : b) cin >> x;\n\tpartial_sum(r.begin(), r.end(), r.begin());\n\tpartial_sum(b.begin(), b.end(), b.begin());\n\tcout << max(0, *max_element(r.begin(), r.end())) + max(0, *max_element(b.begin(), b.end())) << '\\n';\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n} Solution 2 (pikmike)for _ in range(int(input())):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\tm = int(input())\n\tb = [int(x) for x in input().split()]\n\tdp = [[-10**9 for j in range(m + 1)] for i in range(n + 1)]\n\tdp[0][0] = 0\n\tans = 0\n\tfor i in range(n + 1):\n\t\tfor j in range(m + 1):\n\t\t\tif i < n:\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + a[i])\n\t\t\tif j < m:\n\t\t\t\tdp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + b[j])\n\t\t\tans = max(ans, dp[i][j])\n\tprint(ans)"
}