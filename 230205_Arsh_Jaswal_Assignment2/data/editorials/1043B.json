{
    "solution": "1043B — Lost Array TutorialFirst, let's observe that we can replace array ai with array bi = ai  -  ai - 1, because all we care about are differences between neighboring elements. Now, we can see that our lost array can have length d if and only if for every j such that j  +  d  ≤  n, bj  =  bj + d. So we can iterate over every possible d from 1 to n and check if it is correct in O(n). Complexity of whole algorithm is O(n2). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1007;\n\nint n;\nint in[N];\n\nbool ok(int d){\n\tfor(int i = 0; i + d < n; ++i)\n\t\tif(in[i + 1] - in[i] != in[i + d + 1] - in[i + d])\n\t\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &in[i]);\n\t\n\tvector <int> res;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(ok(i))\n\t\t\tres.push_back(i);\n\t\n\tprintf(\"%d\\n\", res.size());\n\tfor(int v: res)\n\t\tprintf(\"%d \", v);\n\treturn 0;\n}Author: Anadi"
}