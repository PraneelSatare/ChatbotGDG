{
    "solution": "1073B - Vasya and BooksLet's maintain the pointer pos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pos is 0 (if we store the array 0-indexed). We will process the array B in the order b1,b2,â€¦bn. If the current book bi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pos until the equality apos=bi is satisfied, while marking all the intermediate books in the array u. After that, the answer for the book bi will be the number of marked books in the u array (including itself).Since the pointer pos shifts n times at total, we get a solution with an O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}"
}