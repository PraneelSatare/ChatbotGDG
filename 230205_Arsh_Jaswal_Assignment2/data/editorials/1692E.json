{
    "solution": "1692E - Binary DequeNote that the remaining array is a subarray of the original array. There are many ways to approach the problem. Here is one solution, which the main solution uses:Compute prefix sums on the array, so we can find out the value of al+⋯+ar quickly. Let's iterate through the left endpoint l from 1 to n. Afterwards, we can binary search on the smallest value of r such that al+⋯+ar=s, since this sum is strictly increasing.The time complexity is O(nlogn). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\n\nll query(int l, int r, vector<ll>& p) {\n    return p[r] - (l ? p[l - 1] : 0);\n}\n\nvoid solve() {  \n    int n, s; cin >> n >> s;\n    vector<ll> a(n), p(n);\n    forn(i, n) {\n        cin >> a[i];\n        p[i] = a[i];\n        if(i) p[i] += p[i - 1];\n    }\n\n    int ans = INT_MAX;\n\n    for(int i = 0; i < n; ++i) {\n        int l = i, r = n - 1, pos = -1;\n        while(l <= r) {\n            int mid = l + r >> 1;\n            if(query(i, mid, p) <= s) {\n                pos = mid;\n                l = mid + 1;\n            } else r = mid - 1;\n        }\n        if(pos == -1 || query(i, pos, p) != s) continue;\n        ans = min(ans, n - (pos - i + 1));\n    }\n\n    cout << (ans == INT_MAX ? -1 : ans) << \"\\n\";\n} \n     \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}   "
}