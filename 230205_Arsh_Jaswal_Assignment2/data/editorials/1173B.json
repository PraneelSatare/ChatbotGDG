{
    "solution": "1173B - Nauuo and ChessIdea: furry Tutorial m≥⌊n2⌋+1 Consider the chess pieces 1 and n.∵⎧⎩⎨|r1−rn|+|c1−cn|≥n−1|r1−rn|≤m−1|c1−cn|≤m−1∴m−1+m−1≥n−1∴m≥n+12∵m is an integer∴m≥⌊n2⌋+1  m can be ⌊n2⌋+1 If we put the i-th piece on (ri,ci) satisfying ri+ci=i+1, it is a feasible plan, because |ri−rj|+|ci−cj|≥|ri+ci−rj−cj|. Solution#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int n, i, ans;\n\n    scanf(\"%d\", &n);\n    ans = n / 2 + 1;\n\n    printf(\"%d\", ans);\n\n    for (i = 1; i <= ans; ++i) printf(\"\\n%d 1\", i);\n    for (i = 2; i <= n - ans + 1; ++i) printf(\"\\n%d %d\", ans, i);\n\n    return 0;\n}\n1172A - Nauuo and CardsIdea: QAQAutoMaton TutorialFirst, try to finish it without playing any empty cards.If that's not possible, the best choice is to play several empty cards in a row, then play from 1 to n. For a card i, suppose that it is in the pi-th position in the pile (pi=0 if it is in the hand), you have to play at least pi−i+1 empty cards. So the answer will be max{pi−i+1+n}. Solution#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint n, a[N], b[N], p[N], ans;\n\nint main()\n{\n    int i, j;\n\n    scanf(\"%d\", &n);\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", a + i);\n        p[a[i]] = 0;\n    }\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", b + i);\n        p[b[i]] = i;\n    }\n\n    if (p[1])\n    {\n        for (i = 2; p[i] == p[1] + i - 1; ++i);\n        if (p[i - 1] == n)\n        {\n            for (j = i; j <= n && p[j] <= j - i; ++j);\n            if (j > n)\n            {\n                printf(\"%d\", n - i + 1);\n                return 0;\n            }\n        }\n    }\n\n    for (i = 1; i <= n; ++i) ans = max(ans, p[i] - i + 1 + n);\n\n    printf(\"%d\", ans);\n\n    return 0;\n}1172B - Nauuo and CircleIdea: furry TutorialFirst, if we choose a node as the root, then each subtree must be in a continuous arc on the circle. Then, we can use DP to solve this problem.Let fu be the number of plans to draw the subtree of u, then fu=(|son(u)|+[u≠root])!∏v∈son(u)fv — choose a position for each subtree and then u itself, then draw the subtrees. However, instead of choosing the position of the root, we suppose the root is on a certain point on the circle, then rotate the circle, thus get the answer: nfroot.In fact, we don't have to write a DP, the answer is n times the product of the factorial of each node's degree (n∏i=1ndegree[i]!). Solution#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int mod = 998244353;\n\nint n, ans, d[N];\n\nint main()\n{\n    int i, u, v;\n\n    scanf(\"%d\", &n);\n    ans = n;\n\n    for (i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        ans = (ll) ans * (++d[u]) % mod * (++d[v]) % mod;\n    }\n\n    cout << ans;\n\n    return 0;\n}1172C1 - Nauuo and Pictures (easy version) and 1172C2 - Nauuo and Pictures (hard version)Idea: ouuan TutorialFirst, let's focus on a single picture with weight w which Nauuo likes, so we only have to know the sum of the weights of the pictures Nauuo likes (SA=∑i=1nwi[ai=1]) and the sum of the disliked ones (SB=∑i=1nwi[ai=0]) instead of all the n weights.Then, we can use DP to solve this problem.Let fw[i][j][k] be the expected weight of a picture Nauuo likes with weight w after another i visits since SA=j and SB=k.Obviously, fw[0][j][k]=w.The state transition:  The next visit displays the picture we focus on. Probaility: wj+k. Lead to: fw+1[i−1][j+1][k]. The next visit displays a picture Nauuo likes but is not the one we focus on. Probaility: j−wj+k. Lead to: fw[i−1][j+1][k]. The next visit displays a picture Nauuo doesn't like. Probaility: kj+k. Lead to: fw[i−1][j][k−1]. So, fw[i][j][k]=wj+kfw+1[i−1][j+1][k]+j−wj+kfw[i−1][j+1][k]+kj+kfw[i−1][j][k−1].Let gw[i][j][k] be the expected weight of a picture Nauuo doesn't like with weight w after another i visits since SA=j and SB=k. The state transition is similar.Note that i,j,k,m have some relation. In fact we can let f′w[i][j] be fw[m−i−j][SA+i][SB−j] (SA and SB are the initial ones here).But up to now, we can only solve the easy version.To solve the hard version, let's introduce a lemma: fw[i][j][k]=wf1[i][j][k]Proof:Obviously, this is true when i=0.Then, suppose we have already proved fw[i−1][j][k]=wf1[i−1][j][k].f1[i][j][k]=1j+kf2[i−1][j+1][k]+j−1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]=2j+kf1[i−1][j+1][k]+j−1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]=j+1j+kf1[i−1][j+1][k]+kj+kf1[i−1][j][k−1]fw[i][j][k]=wj+kfw+1[i−1][j+1][k]+j−wj+kfw[i−1][j+1][k]+kj+kfw[i−1][j][k−1]=w(w+1)j+kf1[i−1][j+1][k]+w(j−w)j+kf1[i−1][j+1][k]+wkj+kf1[i−1][j][k−1]=w(j+1)j+kf1[i−1][j+1][k]+wkj+kf1[i−1][j][k−1]=wf1[i][j][k]Also, a brief but not so strict proof: the increment in each step is proportional to the expectation.So, we only have to calculate f1[i][j][k] (f′1[i][j]).In conclusion:f′1[i][j]=1 (i+j=m)f′1[i][j]=SA+i+1SA+SB+i−jf′1[i+1][j]+SB−jSA+SB+i−jf′1[i][j+1] (i+j<m)g′1[i][j]=1 (i+j=m)g′1[i][j]=SA+iSA+SB+i−jg′1[i+1][j]+SB−j−1SA+SB+i−jg′1[i][j+1] (i+j<m)If ai=1, the expected weight of the i-th picture is wif′1[0][0], otherwise, the expected weight is wig′1[0][0].Last question: how to calculate the result modulo 998244353?If you don't know how, please read the wiki to learn it.You can calculate and store all the O(m) inverses at first, then you can get an O(n+m2+mlogp) solution instead of O(n+m2logp) (p=998244353 here). Solution#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int M = 3010;\nconst int mod = 998244353;\n\nint qpow(int x, int y) //calculate the modular multiplicative inverse\n{\n\tint out = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = (ll) out * x % mod;\n\t\tx = (ll) x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint n, m, a[N], w[N], f[M][M], g[M][M], inv[M << 1], sum[3];\n\nint main()\n{\n\tint i,j;\n\t\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\t\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", w + i);\n\t\tsum[a[i]] += w[i];\n\t\tsum[2] += w[i];\n\t}\n\t\n\tfor (i = max(0, m - sum[0]); i <= 2 * m; ++i) inv[i] = qpow(sum[2] + i - m, mod - 2);\n\t\n\tfor (i = m; i >= 0; --i)\n\t{\n\t\tf[i][m - i] = g[i][m - i] = 1;\n\t\tfor (j = min(m - i - 1, sum[0]); j >= 0; --j)\n\t\t{\n\t\t\tf[i][j] = ((ll) (sum[1] + i + 1) * f[i + 1][j] + (ll) (sum[0] - j) * f[i][j + 1]) % mod * inv[i - j + m] % mod;\n\t\t\tg[i][j] = ((ll) (sum[1] + i) * g[i + 1][j] + (ll) (sum[0] - j - 1) * g[i][j + 1]) % mod * inv[i - j + m] % mod;\n\t\t}\n\t}\n\t\n\tfor (i = 1; i <= n; ++i) printf(\"%d\\n\", int((ll) w[i] * (a[i] ? f[0][0] : g[0][0]) % mod));\n\t\n\treturn 0;\n}1172D - Nauuo and PortalsIdea: furry TutorialConsider this problem:the person in (i,1) facing right is numbered ai, the person in (1,i) facing bottom is numbered bi. The person numbered pi has to exit the grid from (i,n), the person numbered qi has to exit the grid from (n,i).The original problem can be easily transferred to this problem. And now let's transfer it into an (n−1)×(n−1) subproblem by satisfying the requirement of the first row and the first column.If a1=p1 and b1=q1, you can simply do nothing and get an (n−1)×(n−1) subproblem.Otherwise, you can set a portal consisting of two doors in (x,1) and (1,y) where ax=p1 and by=q1. Swap a1 and ax, b1 and by, then you will get an (n−1)×(n−1) subproblem.Then, you can solve the problem until it changes into a 1×1 one.This problem can be solved in O(n), but the checker needs O(n2). Solution#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1010;\n\nstruct Portal\n{\n\tint x, y, p, q;\n\tPortal(int _x, int _y, int _p, int _q): x(_x), y(_y), p(_p), q(_q) {}\n};\nvector<Portal> ans;\nint n, a[N], b[N], c[N], d[N], ra[N], rb[N], rc[N], rd[N];\n\nint main()\n{\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", b + i);\n\t\trb[b[i]] = i;\n\t}\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tra[a[i]] = i;\n\t}\n\tfor (i = 1; i <= n; ++i) c[i] = d[i] = rc[i] = rd[i] = i;\n\t\n\tfor (i = 1; i < n; ++i)\n\t{\n\t\tif (c[i] == ra[i] && d[i] == rb[i]) continue;\n\t\tans.push_back(Portal(i, rc[ra[i]], rd[rb[i]], i));\n\t\tint t1 = c[i];\n\t\tint t2 = d[i];\n\t\tswap(c[i], c[rc[ra[i]]]);\n\t\tswap(d[i], d[rd[rb[i]]]);\n\t\tswap(rc[ra[i]], rc[t1]);\n\t\tswap(rd[rb[i]], rd[t2]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans.size());\n\tfor (auto k : ans) printf(\"%d %d %d %d\\n\", k.x, k.y, k.p, k.q);\n\t\n\treturn 0;\n}1172E - Nauuo and ODTIdea: ODT TutorialFor each color, we can try to maintain the number of simple paths that do not contain such color.If we can maintain such information, we can easily calculate the number of simple paths that contain a certain color, thus get the answer.For each color, we delete all nodes that belong to such color, thus splitting the tree into some clusters (here we define a \"cluster\" as a connected subgraph of the original tree).By maintaining ∑cluster size2, we can get the number of simple paths that do not contain such color.For each color we try to maintain the same information, add them together, and get the answer.So now the problem is: a white tree  reverse the color of a node ( white <-> black ) output ∑cluster size2 This problem can be solved by many data structures like top tree, link/cut tree or heavy path decomposition.Let's use the link/cut tree for example.You can maintain the size of each subtree and the sum of size2 of each node's sons. Link/cut one node with its father (choose a node as the root and make the tree a rooted-tree first) when its color changes. In this way, the real clusters are the ones that are still connected after deleting the top node of a cluster in the link/cut tree. Update ∑cluster size2 while linking/cutting.link:cut: Solution#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 400010;\n\nstruct Node\n{\n    int fa, ch[2], siz, sizi;\n    ll siz2i;\n    ll siz2() { return (ll) siz * siz; }\n} t[N];\n\nbool nroot(int x);\nvoid rotate(int x);\nvoid Splay(int x);\nvoid access(int x);\nint findroot(int x);\nvoid link(int x);\nvoid cut(int x);\nvoid pushup(int x);\n\nvoid add(int u, int v);\nvoid dfs(int u);\n\nint head[N], nxt[N << 1], to[N << 1], cnt;\nint n, m, c[N], f[N];\nll ans, delta[N];\nbool bw[N];\nvector<int> mod[N][2];\n\nint main()\n{\n    int i, j, u, v;\n    ll last;\n\n    scanf(\"%d%d\", &n, &m);\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", c + i);\n        mod[c[i]][0].push_back(i);\n        mod[c[i]][1].push_back(0);\n    }\n\n    for (i = 1; i <= n + 1; ++i) t[i].siz = 1;\n\n    for (i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n        add(v, u);\n    }\n\n    for (i = 1; i <= m; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        mod[c[u]][0].push_back(u);\n        mod[c[u]][1].push_back(i);\n        c[u] = v;\n        mod[v][0].push_back(u);\n        mod[v][1].push_back(i);\n    }\n\n    f[1] = n + 1;\n    dfs(1);\n\n    for (i = 1; i <= n; ++i) link(i);\n\n    for (i = 1; i <= n; ++i)\n    {\n        if (!mod[i][0].size())\n        {\n            delta[0] += (ll)n * n;\n            continue;\n        }\n        if (mod[i][1][0])\n        {\n            delta[0] += (ll)n * n;\n            last = (ll)n * n;\n        } else\n            last = 0;\n        for (j = 0; j < mod[i][0].size(); ++j)\n        {\n            u = mod[i][0][j];\n            if (bw[u] ^= 1)\n                cut(u);\n            else\n                link(u);\n            if (j == mod[i][0].size() - 1 || mod[i][1][j + 1] != mod[i][1][j])\n            {\n                delta[mod[i][1][j]] += ans - last;\n                last = ans;\n            }\n        }\n        for (j = mod[i][0].size() - 1; ~j; --j)\n        {\n            u = mod[i][0][j];\n            if (bw[u] ^= 1)\n                cut(u);\n            else\n                link(u);\n        }\n    }\n\n    ans = (ll) n * n * n;\n    for (i = 0; i <= m; ++i)\n    {\n        ans -= delta[i];\n        printf(\"%I64d \", ans);\n    }\n\n    return 0;\n}\n\nbool nroot(int x) { return x == t[t[x].fa].ch[0] || x == t[t[x].fa].ch[1]; }\n\nvoid rotate(int x)\n{\n    int y = t[x].fa;\n    int z = t[y].fa;\n    int k = x == t[y].ch[1];\n    if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x;\n    t[x].fa = z;\n    t[y].ch[k] = t[x].ch[k ^ 1];\n    t[t[x].ch[k ^ 1]].fa = y;\n    t[x].ch[k ^ 1] = y;\n    t[y].fa = x;\n    pushup(y);\n    pushup(x);\n}\n\nvoid Splay(int x)\n{\n    while (nroot(x))\n    {\n        int y = t[x].fa;\n        int z = t[y].fa;\n        if (nroot(y)) (x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? rotate(x) : rotate(y);\n        rotate(x);\n    }\n}\n\nvoid access(int x)\n{\n    for (int y = 0; x; x = t[y = x].fa)\n    {\n        Splay(x);\n        t[x].sizi += t[t[x].ch[1]].siz;\n        t[x].sizi -= t[y].siz;\n        t[x].siz2i += t[t[x].ch[1]].siz2();\n        t[x].siz2i -= t[y].siz2();\n        t[x].ch[1] = y;\n        pushup(x);\n    }\n}\n\nint findroot(int x)\n{\n    access(x);\n    Splay(x);\n    while (t[x].ch[0]) x = t[x].ch[0];\n    Splay(x);\n    return x;\n}\n\nvoid link(int x)\n{\n    int y = f[x];\n    Splay(x);\n    ans -= t[x].siz2i + t[t[x].ch[1]].siz2();\n    int z = findroot(y);\n    access(x);\n    Splay(z);\n    ans -= t[t[z].ch[1]].siz2();\n    t[x].fa = y;\n    Splay(y);\n    t[y].sizi += t[x].siz;\n    t[y].siz2i += t[x].siz2();\n    pushup(y);\n    access(x);\n    Splay(z);\n    ans += t[t[z].ch[1]].siz2();\n}\n\nvoid cut(int x)\n{\n    int y = f[x];\n    access(x);\n    ans += t[x].siz2i;\n    int z = findroot(y);\n    access(x);\n    Splay(z);\n    ans -= t[t[z].ch[1]].siz2();\n    Splay(x);\n    t[x].ch[0] = t[t[x].ch[0]].fa = 0;\n    pushup(x);\n    Splay(z);\n    ans += t[t[z].ch[1]].siz2();\n}\n\nvoid pushup(int x)\n{\n    t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + t[x].sizi + 1;\n}\n\nvoid add(int u, int v)\n{\n    nxt[++cnt] = head[u];\n    head[u] = cnt;\n    to[cnt] = v;\n}\n\nvoid dfs(int u)\n{\n    int i, v;\n    for (i = head[u]; i; i = nxt[i])\n    {\n        v = to[i];\n        if (v != f[u])\n        {\n            f[v] = u;\n            dfs(v);\n        }\n    }\n}1172F - Nauuo and BugIdea: rushcheyo TutorialAt first, let's solve this problem in O(nnlogn−−−−−√).Let's split our array into blocks by B integers, and let's find a function, f(x)= which value you will get at the end of the current block if you will start with x. With simple induction, you can prove that this function is a piece-wise linear, and it has O(B) segments, so you can build it iteratively in O(B2) time for each block, so the preprocessing took O(nB).And to answer the query, you can keep the current value of x and then find with binary search by that piece-wise linear function the f(x) for the current block.With a good choice of B, this solution will work in O(nnlogn−−−−−√).Ok, but then how to solve it in O(nlog+qlog2)?Lemma: each segment of this piece-wise linear function has length at least p.You can prove it with simple induction.And then, with this lemma, it is possible by two functions f(x) of size n and g(x) of size m find the new function h(x)=g(f(x)), in the O(n+m), you can do it with two pointers, similar to the previous iterative method, but adding a several points to the function each time, best way to understand it is to check the indendent solution :) Solution#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1000005;\nconst ll inf = (ll)1e16;\nint n, m, P, a[N];\nll sum[N];\nvector<ll> func[N << 2];\n\nvector<ll> merge(int l, int r, int mid, const vector<ll> &f, const vector<ll> &g) {\n\tll suml = sum[mid] - sum[l - 1], sumr = sum[r] - sum[mid];\n\tvector<ll> ret(f.size() + g.size() - 1, inf);\n\tfor (int i = 0, j = 0; i < (int)f.size(); ++i) {\n\t\tll xl = f[i], xr = (i + 1 == (int)f.size() ? inf : f[i + 1] - 1), yl = xl + suml - (ll)i * P, yr = xr + suml - (ll)i * P;\n\t\twhile (j > 0 && g[j] > yl) --j;\n\t\twhile (j < (int)g.size() && (j == 0 || g[j] <= yl)) ++j;\n\t\t--j;\n\t\tfor (; j < (int)g.size() && g[j] <= yr; ++j)\n\t\t\tret[i + j] = min(ret[i + j], max(xl, g[j] - suml + (ll)i * P));\n\t}\n\tret[0] = -inf;\n\treturn ret;\n}\nvoid build(int u, int l, int r) {\n\tif (l == r) {\n\t\tfunc[u].push_back(-inf);\n\t\tfunc[u].push_back(P - a[l]);\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(u << 1, l, mid);\n\tbuild(u << 1 | 1, mid + 1, r);\n\tfunc[u] = merge(l, r, mid, func[u << 1], func[u << 1 | 1]);\n}\nll query(int u, int l, int r, int ql, int qr, ll now) {\n\tif (l >= ql && r <= qr)\n\t\treturn now + sum[r] - sum[l - 1] - (ll)P * (upper_bound(func[u].begin(), func[u].end(), now) - func[u].begin() - 1);\n\tint mid = l + r >> 1;\n\tif (qr <= mid)\n\t\treturn query(u << 1, l, mid, ql, qr, now);\n\tif (ql > mid)\n\t\treturn query(u << 1 | 1, mid + 1, r, ql, qr, now);\n\treturn query(u << 1 | 1, mid + 1, r, ql, qr, query(u << 1, l, mid, ql, qr, now));\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &P);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i), sum[i] = sum[i - 1] + a[i];\n\tbuild(1, 1, n);\n\tfor (int l, r; m--;) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tprintf(\"%I64d\\n\", query(1, 1, n, l, r, 0));\n\t}\n\treturn 0;\n}We had prepared a problem similar to "
}