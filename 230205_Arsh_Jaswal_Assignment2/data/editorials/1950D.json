{
    "solution": "1950D - Product of Binary DecimalsFirst, let's make precompute list of all binary decimals at most 105. You can do it in many ways, for example iterating through all numbers up to 105 and checking if each is a binary decimal.Let's call a number good if it can be represented as the product of binary decimals. For each test case, we will write a simple recursive function. n is good if:   n=1, or  ni is good, for some binary decimal i>1.  We can check by hand (or code) that the number of binary decimals is not more than 32, so the solution should not take too long in practice even without memoization. You can test it locally on all 105 inputs to check. This is enough to solve the problem; see the implementation for more details.Even if your implementation is slightly too slow, there are not many good numbers; you can simply precompute them all locally and hardcode them to get a solution that works in O(1). Here is a long string of text so that there is a horizontal line separating sections. For the curious: we will compute an upper bound on the complexity, given by the (rather loose) recurrence T(n)≤2T(⌊n10⌋)+4T(⌊n100⌋)+26T(⌊n1000⌋). By the Akra-Bazzi method, T(n)∈O(nlog10α)=O⎛⎝⎜nlog10(2+395−316881√√3+395+316881√√33)⎞⎠⎟≈O(n0.635), where α is the (unique) real number satisfying α3=2α2+4α+26. This is probably fast enough, and this is still a very large overestimate.A more accurate estimate can be made by picking the solution to α5=2α4+4α3+8α2+16α+2, which gives a bound O(n0.587). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 100'007;\nconst int MOD = 1'000'000'007;\n\nvector<int> binary_decimals;\n\nbool ok(int n) {\n\tif (n == 1) {return true;}\n\tbool ans = false;\n\tfor (int i : binary_decimals) {\n\t\tif (n % i == 0) {\n\t\t\tans |= ok(n / i);\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tcout << (ok(n) ? \"YES\\n\" : \"NO\\n\");\t\n}\n\nint main() {\n\tfor (int i = 2; i < MAX; i++) {\n\t\tint curr = i;\n\t\tbool bad = false;\n\t\twhile (curr) {\n\t\t\tif (curr % 10 > 1) {bad = true; break;}\n\t\t\tcurr /= 10;\n\t\t}\n\t\tif (!bad) {binary_decimals.push_back(i);}\n\t}\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}"
}