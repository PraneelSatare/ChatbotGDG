{
    "solution": "1311B - WeirdSortThe simple simulation works here: while there is at least one inversion (such a pair of indices i and i+1 that a[i]>a[i+1]) we can fix, let's fix it (we can fix this inversion if iâˆˆp). If there are inversions but we cannot fix any of them, the answer is \"NO\". Otherwise, the answer is \"YES\".There is also a O(nlogn) solution: it is obvious that we have some segments in which we can change the order of elements as we want. And it is also obvious that we cannot move elements between these \"allowed\" segments. So, each of them is independent of each other. We can just find all these segments of indices using two pointers and sort them independently. Then we just need to check if the array becomes sorted.Time complexity is O(n2) or O(nlogn). Solution (n^2)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> p(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tp[pos - 1] = 1;\n\t\t}\n\t\twhile (true) {\n\t\t\tbool ok = false;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (p[i] && a[i] > a[i + 1]) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tswap(a[i], a[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tok &= a[i] <= a[i + 1];\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n} Solution (n log n)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> p(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tp[pos - 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (p[i] == 0) continue;\n\t\t\tint j = i;\n\t\t\twhile (j < n && p[j]) ++j;\n\t\t\tsort(a.begin() + i, a.begin() + j + 1);\n\t\t\ti = j;\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tok &= a[i] <= a[i + 1];\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}\n"
}