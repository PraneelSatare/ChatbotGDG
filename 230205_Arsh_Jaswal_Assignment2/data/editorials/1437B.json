{
    "solution": "1437B - Reverse Binary StringsWe need to make our string alternating, i. e. si≠si+1. When we reverse substring sl…sr, we change no more than two pairs sl−1,sl and sr,sr+1. Moreover, one pair should be a consecutive pair 00 and other — 11. So, we can find lower bound to our answer as maximum between number of pairs of 00 and number of pairs of 11. And we can always reach this lower bound, by pairing 00 with 11 or with left/right border of s. Another way to count the answer is next: suppose we want to make string 0101..., then let's transform s to 1 + s + 0. For example, if s= 0110, we will get 101100. We claim that after this transformation, we will have equal number of 00 and 11, so the answer is the number of consecutive pairs of the same character divided by two. The answer is the minimum between answers for 1 + s + 0 and 0 + s + 1. Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int INF = int(1e9);\n\nint n;\nstring s;\n\ninline bool read() {\n\tif(!(cin >> n >> s))\n\t\treturn false;\n\treturn true;\n}\n\nint cntSame(const string &s) {\n\tint ans = 0;\n\tfore (i, 1, sz(s))\n\t\tans += (s[i - 1] == s[i]);\n\tassert(ans % 2 == 0);\n\treturn ans / 2;\n}\n\ninline void solve() {\n\tint ans = INF;\n\tfore (k, 0, 2) {\n\t\tans = min(ans, cntSame(string(1, '0' + k) + s + string(1, '1' - k)));\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}"
}