{
    "solution": "1536B - Prinzessin der VerurteilungIdea: MagentaCobraPreparation: MagentaCobraVideo editorial Hint 1Pigeonhole principle Hint 2What is the longest the answer can be? SolutionLet’s brute force check all substrings of length <= 3 and print the lexicographically smallest one that doesn’t appear as a substring in the input. We can guarantee that we will come across the answer due to the pigeonhole principle. There are at most n+n−1+n−2=3n−3 possible substrings of length 3 or shorter in the input. There exist 26+262+263=18278 total substrings of length 3 or shorter. It is impossible for the input to contain all 18278 substrings, as 3n−3<18278 for n≤1000.Final runtime looks something like O(18278n) or O(n) depending on how you implement substring checking. Implementation in Java by hu_tao//stan hu tao\n//come to K-expo!!!\n//watch me get carried in nct ridin\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class FischlPog\n{\n    public static void main(String hi[]) throws Exception\n    {\n        ArrayList<String> ls = new ArrayList<String>();\n        for(int a=0; a < 26; a++)\n            ls.add(get(a)+\"\");\n        for(int a=0; a < 26; a++)\n            for(int b=0; b < 26; b++)\n                ls.add(get(a)+\"\"+get(b));\n        for(int a=0; a < 26; a++)\n            for(int b=0; b < 26; b++)\n                for(int c=0; c < 26; c++)\n                    ls.add(get(a)+\"\"+get(b)+\"\"+get(c));\n        Collections.sort(ls, (x,y) -> {\n            int len1 = x.length();\n            int len2 = y.length();\n            if(len1 != len2)\n                return len1-len2;\n            return x.compareTo(y);\n        });\n        //assume multitests exist\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            int N = Integer.parseInt(infile.readLine());\n            String input = infile.readLine();\n            HashSet<String> substrings = new HashSet<String>();\n            for(int len=1; len <= 3; len++)\n                for(int i=0; i < N-len+1; i++)\n                    substrings.add(input.substring(i, i+len));\n            for(int i=0; i < ls.size(); i++)\n                if(!substrings.contains(ls.get(i)))\n                {\n                    sb.append(ls.get(i)+\"\\n\");\n                    break;\n                }\n        }\n        System.out.print(sb);\n    }\n    public static char get(int a)\n    {\n        return (char)(a+'a');\n    }\n} Implementation in Kotlin by Tlatoanifun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val s = readLine()!!\n        for (length in 1..n) {\n            var mex = \"\"\n            var answer: String? = null\n            fun recur() {\n                if (mex.length == length) {\n                    if (mex !in s) {\n                        answer = mex\n                    }\n                } else {\n                    for (chara in 'a'..'z') {\n                        mex += chara\n                        recur()\n                        if (answer != null) {\n                            return\n                        }\n                        mex = mex.substring(0 until mex.lastIndex)\n                    }\n                }\n            }\n            recur()\n            if (answer != null) {\n                println(answer)\n                break\n            }\n        }\n    }\n} Implementation in C++ by 1-gon#include <bits/stdc++.h>\n \n#define ll long long\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define vi vector<int>\n#define pii pair<int, int>\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\nusing namespace std;\ntemplate<typename T>\nusing minpq = priority_queue<T, vector<T>, greater<T>>;\n \nvoid solve() {\n    int n;\n    string s;\n    cin >> n >> s;\n    set<string> se;\n    rep(i, 0, n) {\n        string ss;\n        for(int k = 0; k < 5 && i + k < n; k++) {\n            ss.push_back(s[i + k]);\n            se.insert(ss);\n        }\n    }\n    rep(len, 1, 6) {\n        string t(len, 'a');\n        while(true) {\n            if(se.count(t) == 0) {\n                cout << t << '\\n';\n                return;\n            }\n            int idx = len - 1;\n            while(idx >= 0 && t[idx] == 'z') {\n                t[idx] = 'a';\n                idx--;\n            }\n            if(idx < 0) break;\n            t[idx]++;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int te;\n    cin >> te;\n    while(te--) solve();\n} Implementation in Haskell by Tlatoaniimport Data.List (intercalate, tails, isPrefixOf, head)\nimport Control.Monad (replicateM)\nimport Data.Maybe (fromJust, listToMaybe, catMaybes)\n\nmain = do t <- read <$> getLine\n          replicateM t solve\n\nsolve = do getLine\n           s <- getLine\n           putStrLn (leastNonSubstring s)\n\nleastNonSubstring s = head $ catMaybes [leastOfLength l | l <- [1..]]\n  where leastOfLength l = helper \"\" l\n        helper prefix 0 | isSubstring prefix s = Nothing\n                        | otherwise            = Just prefix\n        helper prefix l = listToMaybe $ catMaybes [helper (prefix ++ [letter]) (l - 1) | letter <- ['a'..'z']]\n\nisSubstring s t = any id (map (isPrefixOf s) (tails t)) "
}