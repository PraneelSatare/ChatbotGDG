{
    "solution": "1015C - Songs CompressionIf we will no compress songs, the sum of the sizes will be equal ∑i=1nai. Let it be sum. Now, if we will compress the j-th song, how do sum will change? It will decrease by aj−bj. This suggests that the optimal way to compress the songs is the compress it in non-increasing order of aj−bj. Let's create the array d of size n, where dj=aj−bj. Let's sort it in non-increasing order, and then iterate over all j from 1 to n. If at the current step sum≤m, we print j−1 and terminate the program. Otherwise we set sum:=sum−dj. After all we have to check again if sum≤m then print n otherwise print \"-1\".Time complexity is O(nlogn) because of sorting. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pair<int, int>> a(n);\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tsum += a[i].first;\n\t}\n\t\n\tsort(a.begin(), a.end(), [&](pair<int, int> a, pair<int, int> b) { return a.first - a.second > b.first - b.second; });\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (sum <= m) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum -= a[i].first - a[i].second;\n\t}\n\t\n\tif (sum <= m)\n\t\tcout << n << endl;\n\telse\n\t\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
}