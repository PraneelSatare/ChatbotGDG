{
    "solution": "1999D - Slavic's ExamLet's use a greedy strategy with two pointers, one at the start of s (called i) and one at the start of t (called j). At each step, advance i by 1. If si=?, then we set it to tj and increment j. If si=tj then we also increment j (because there is a match).It works because if there is ever a question mark, it never makes it worse to match the current character in t earlier than later. The complexity is O(n). Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int test_cases; cin >> test_cases;\n    while(test_cases--) {\n        string s, t; cin >> s >> t;\n    \tint idx = 0;\n    \n    \tfor(int i = 0; i < (int)s.size(); ++i) {\n    \t\tif(s[i] == '?') {\n    \t\t\tif(idx < (int)t.size()) s[i] = t[idx++];\n    \t\t\telse s[i] = 'a';\n    \t\t} else if(s[i] == t[idx]) ++idx;\n    \t}\n    \tif(idx >= t.size()) cout << \"YES\\n\" << s << \"\\n\";\n    \telse cout << \"NO\\n\";\n    }\n}"
}