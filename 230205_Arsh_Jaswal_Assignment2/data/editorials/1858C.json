{
    "solution": "1858C - Yet Another Permutation ProblemIt is impossible to get di=gcd(ai,a(imodn)+1)>⌊n2⌋: otherwise, at least one of the numbers in a would be divisible by di and would be greater than di at the same time, so it would be at least 2⋅di, which is greater than n. Therefore, the maximum possible score is no more than ⌊n2⌋. Actually, we can always get a score equal to ⌊n2⌋.How do we get such score? Let's set a1=1. After that, we put the powers of 2 less or equal n sequentially. Then we put 3 and powers of 2 multiplied by 3, then 5 and so on (for example, for n=12, we will get an array a=[1,2,4,8,3,6,12,5,10,7,9,11]). Then, for each number ai=x≤⌊n2⌋, the next number will be a(imodn)+1=x⋅2≤n. Their gcd will be exactly x, so there will be a pair of adjacent elements of a with greatest common divisor equal to x for all 1≤x≤⌊n2⌋. Code#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int cur = 0;\n        for (int i = 1; i <= n; i += 2) {\n            for (int j = i; j <= n; j *= 2) {\n                a[cur++] = j;\n            }\n        }\n        for (int i = 0; i<n; ++i) {\n            cout << a[i] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
}