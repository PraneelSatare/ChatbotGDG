{
    "solution": "1362B - Johnny and His HobbiesConsider i-th least significant bit (0 indexed). If it is set in k, but not in s, it will be set in k⊕s. Hence k⊕s≥2i.Consider such minimal positive integer m, that 2m>s holds for all s∈S. k cannot have the i-th bit set for any i≥m. From this follows that k<2m. So there are only 2m feasible choices of k. We can verify if a number satisfies the condition from the statement in O(n) operations. This gives us a solution with complexity O(n⋅2m). Note that in all tests m is at most 10.There is also another solution possible. It uses the observation that if k satisfies the required conditions, then for every s∈S there exists such t∈S (t≠s) , that t⊕s=k. This gives us n−1 feasible choices of k and thus the complexity of this solution is O(n2). Solution//O(n * maxA) solution\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1025;\n\nint n;\nint in[N];\nbool is[N];\n\nbool check(int k){\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!is[in[i] ^ k])\n\t\t\treturn false;\n\treturn true;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < N; ++i)\n\t\tis[i] = false;\n\t\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", &in[i]);\n\t\tis[in[i]] = true;\n\t}\n\t\n\tfor(int k = 1; k < 1024; ++k)\n\t\tif(check(k)){\n\t\t\tprintf(\"%d\\n\", k);\n\t\t\treturn;\n\t\t}\n\t\n\tputs(\"-1\");\n}\n\nint main(){\n\tint cases;\n\tscanf(\"%d\", &cases);\n\t\n\twhile(cases--)\n\t\tsolve();\n\treturn 0;\n}\n"
}