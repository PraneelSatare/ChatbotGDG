{
    "solution": "1955B - Progressive SquareSince c>0 and d>0, the elements of the square increase starting from the top left corner. Thus, a1,1 is the minimum element in the square, and consequently in the found elements.Given n, c, d, and the found a1,1, we will reconstruct the square. It remains to check that the given numbers in the input form the same square. The easiest way is to sort both arrays of numbers and check for equality. The complexity of the solution is O(n2â‹…logn). Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define all(x) (x).begin(), (x).end()\n \nusing ll = signed long long int;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n \nvoid solve() {\n    int n;\n    ll c, d;\n    cin >> n >> c >> d;\n    vl a(n * n);\n    for (int i = 0; i < n * n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    vl b(n * n);\n    b[0] = a[0];\n    for (int i = 1; i < n; ++i) {\n        b[i] = b[i - 1] + c;\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            b[i * n + j] = b[(i - 1) * n + j] + d;\n        }\n    }\n    sort(all(b));\n    cout << (a == b ? \"YEs\" : \"nO\") << '\\n';\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n"
}