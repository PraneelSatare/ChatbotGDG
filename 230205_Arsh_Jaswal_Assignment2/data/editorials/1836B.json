{
    "solution": "1836B - AstrophysicistsNote that in the perfect world, we'd give each astrophysicist precisely ⌊G−12⌋, and we'd spare N⋅⌊G−12⌋ silver coins. Unfortunately, two things may happen:   First, we may run out of money. This is an easy case; it is enough to output K⋅G if it is less than ⌊G−12⌋.  Second, we may have some money left. It turns out that an acceptable solution is to give everything to one astrophysicist. The intuition behind it is simple — we are only interested in bonus sizes modulo G, and by decreasing the bonus of one astrophysicist, we can get at most 1 from another one, and by increasing it, we lose ⌊G−12⌋. In both cases, it is not worth changing the value.Thus, we got a formula to calculate in O(1). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \nint main()\n{\n\tint t;\n\tscanf (\"%d\", &t);\n\twhile (t--) {\n\t\tlong long n, k, g;\n\t\tscanf (\"%lld %lld %lld\", &n, &k, &g);\n \n\t\tlong long stolen = min((g - 1) / 2 * n, k * g);\n\t\tlong long rest = (k * g - stolen) % g;\n \n\t\tif (rest > 0) {\n\t\t    stolen -= (g - 1) / 2;\n\t\t    long long last = ((g - 1) / 2 + rest) % g;\n \n\t\t    if (last * 2 < g) {\n\t\t        stolen += last;\n\t\t    } else {\n\t\t        stolen -= g - last;\n\t\t    }\n\t\t}\n \n\t\tprintf (\"%lld\\n\", stolen);\n\t}\n}"
}