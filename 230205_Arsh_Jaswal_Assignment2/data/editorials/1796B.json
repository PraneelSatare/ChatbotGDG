{
    "solution": "1796B - Asterisk-Minor TemplateWhat's the reason behind authors specifically asking for templates that have less or equal asterisks than letters? Well, without that the problem would be kind of trivial. A template \"*\" is matched by every string, so it would always work.Hmm, let's try to make something similar to that template then. We basically have to find some part of that occurs in both strings that we can use letters on to get some freedom to use asterisks.There are some easy cases. If the first letters of both strings are the same, then the template can be that letter followed by an asterisk. There's a symmetrical case for the last letter.By studying the examples, you can also notice the final case: a common substring of both strings of length at least two surrounded by two asterisks. Moreover, since we only use two asterisks, we can find a substring of length exactly two (which always exists if a longer common substring exists).Turns out, that's it. If a template exists, one of these three kinds also exists.This is not that hard to show. If the first two kinds don't work, then you have to use asterisks on both sides of the template. In order for the template with asterisks on both sides to work, there have to be adjacent letters in it at least once (otherwise, it's like \"*a*a*a*\", and there are more asterisks than letters). And since at least one such substring exists, we can just remove everything other than this substring and the asterisks on the sides.Overall complexity: O(|a|â‹…|b|) per testcase. Solution (awoo)for _ in range(int(input())):\n    a = input()\n    b = input()\n    if a[0] == b[0]:\n        print(\"YES\")\n        print(a[0] + \"*\")\n        continue\n    if a[-1] == b[-1]:\n        print(\"YES\")\n        print(\"*\" + a[-1])\n        continue\n    for i in range(len(b) - 1):\n        if (b[i] + b[i + 1]) in a:\n            print(\"YES\")\n            print(\"*\" + b[i] + b[i + 1] + \"*\")\n            break\n    else:\n        print(\"NO\")"
}