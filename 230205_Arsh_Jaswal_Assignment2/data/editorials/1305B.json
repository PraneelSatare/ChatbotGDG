{
    "solution": "1305B - Kuroni and Simple StringsWe claim that the answer is always 0 or 1. First, note we can't apply any operations if and only if each '(' symbol is left from each ')' symbol, so that the string looks as ')))(((((('.Let a1,a2,…,ap be the indexes of symbols '(' in the string, and b1,b2,…,bq be the indexes of symbols ')' in the string. Let i be the largest index for which ai<bq−i+1. We claim that we can delete subsequence {a1,a2,…,ai,bq−i+1,…,bq−1,bq}, and won't be able to apply any operation to the resulting string. Indeed, suppose that in the resulting string some '(' symbol will be to the left from some ')' symbol, say they were ak and bl in out sequences. Then we must have k>i and l<q−i+1, as they weren't deleted yet. So, we get that bi+1≤bk<bl≤bq−i, so i wasn't maximal.In other words, just pick brackets greedily from ends, forming as large simple string as you can. Asymptotics O(|s|). Solution (Ari, C++)Submission link: 72364435 Source code in plain text#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tvector<int> le, ri;\n\tint l = 0, r = s.size() - 1;\n\twhile(l < r) {\n\t\twhile(l < s.size() && s[l] == ')')\n\t\t\tl++;\n\t\twhile(r >= 0 && s[r] == '(')\n\t\t\tr--;\n\t\tif(l < s.size() && r >= 0 && l < r) {\n\t\t\tle.push_back(l + 1);\n\t\t\tri.push_back(r + 1);\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t}\n\tif(le.empty()) {\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"1\\n\";\n\tcout << 2 * le.size() << '\\n';\n\tfor(auto x : le)\n\t\tcout << x << \" \";\n\treverse(ri.begin(), ri.end());\n\tfor(auto x : ri)\n\t\tcout << x << \" \";\n\tcout << '\\n';\n} Solution (Akikaze, Java 8)Submission link: 72364561 Source code in plain textimport java.io.*;\nimport java.util.*;\n\npublic class JavAki {\n\tpublic static Scanner sc = new Scanner(System.in);\n\n\tpublic static String s;\n\n\tpublic static void Input() {\n\t\ts = sc.next();\n\t}\n\n\tpublic static void Solve() {\n\t\tArrayList<Integer> oList = new ArrayList<>();\n\t\tArrayList<Integer> cList = new ArrayList<>();\n\t\tfor (int i=0; i<s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') oList.add(i);\n\t\t\tif (s.charAt(i) == ')') cList.add(i);\n\t\t}\n\n\t\tArrayList<Integer> removal = new ArrayList<>();\n\t\tint oPtr = 0, cPtr = cList.size() - 1;\n\t\twhile (oPtr < oList.size() && cPtr >= 0) {\n\t\t\tif (oList.get(oPtr) > cList.get(cPtr)) break;\n\t\t\tremoval.add(oList.get(oPtr)); removal.add(cList.get(cPtr));\n\t\t\toPtr++; cPtr--;\n\t\t}\n\n\t\tCollections.sort(removal);\n\t\tif (removal.size() == 0) System.out.println(0);\n\t\telse {\n\t\t\tSystem.out.println(1); System.out.println(removal.size());\n\t\t\tfor (int x: removal) System.out.print((x+1) + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInput(); Solve();\n\t}\n} Solution (Akikaze, Python 3)Submission link: 72364606 Source code in plain textstring = input()\noList, cList = [], []\nfor i in range(len(string)):\n\tif string[i] == '(': oList.append(i)\n\tif string[i] == ')': cList.append(i)\n\noPtr, cPtr = 0, len(cList)-1\nremoval = []\nwhile oPtr < len(oList) and cPtr >= 0:\n\tif oList[oPtr] > cList[cPtr]: break\n\tremoval.append(oList[oPtr])\n\tremoval.append(cList[cPtr])\n\toPtr += 1\n\tcPtr -= 1\n\nremoval.sort()\nif len(removal) == 0: print(0)\nelse: print('1\\n{}\\n{}'.format(len(removal), ' '.join([str(x+1) for x in removal])))"
}