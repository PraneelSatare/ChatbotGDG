{
    "solution": "1946B - Maximum SumLet's denote s as the sum of the original array and x as the sum of the subarray with the maximum sum from the original array.We solve the problem when k equals 1. In this case, we need to find the subarray of the array with the maximum sum and insert this sum anywhere in the array, so the answer is s+x. Now, let k be 2. In this case, there is already a value where we insert the sum of the subarray with the maximum sum. Then we can increase the sum of the subarray with the maximum sum by no more than x (we can increase it by x simply by inserting it into the subarray with the maximum sum), and obtain the sum of the subarray with the maximum sum 2⋅x. Then insert it anywhere in the array, thus obtaining the sum of the final array equal to s+x+2⋅x. Similarly, for any k, the sum of the subarray with the maximum sum is initially x, then 2⋅x, then 4⋅x, …, 2k−1⋅x, then the answer is equal to s+x+2⋅x+⋯+2k−1⋅x=s+2k⋅x−x. Solution#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int P = 1e9 + 7;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    int S = 0, sum = 0;\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        cur += a[i];\n        cur = max(cur, 0LL);\n        S = max(S, cur);\n    }\n    sum = (sum % P + P) % P;\n    S = S % P;\n    int t = 1;\n    for (int i = 0; i < k; i++) {\n        t = t * 2 % P;\n    }\n    int ans = (sum + S * t - S + P) % P;\n    cout << ans << '\\n';\n}\n\n\nsigned main() {\n    //cout << fixed << setprecision(20);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1, G = 1;\n    //cin >> G;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}author: dope, developer: dope"
}