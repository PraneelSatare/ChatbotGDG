{
    "solution": "1529B - Sifid и странные подпоследовательностиIt's easy to prove that a strange subsequence can't contain more than one positive element.So it's optimal to pick all of the non-positive elements, now we can pick at most one positive element.Assume x is the minimum positive element in the array. We can pick x if no two elements in the already picked set such as a and b exist in a way that |a−b|<x. To check this, we just have to sort the already picked elements and see the difference between adjacent pairs. complexity: O(nlogn) official solution// khodaya khodet komak kon\n// Nightcall - London Grammer\n# include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define lc                                              id << 1\n# define rc                                              id << 1 | 1\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 1e5 + 10;\nconst int xm = - 20 + 10;\nconst int sq = 320;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;//998244353;\nconst int base = 257;\n \nint qq, n, a[xn], ans, mn;\nbool flag;\n \nint main(){\n\tios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \n\tcin >> qq;\n\twhile (qq --){\n\t\tcin >> n, ans = 0;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tcin >> a[i], ans += (a[i] <= 0);\n\t\tsort(a + 1, a + n + 1), mn = inf;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tif (a[i] > 0)\n\t\t\t\tmn = min(mn, a[i]);\n\t\tflag = (mn < inf);\n\t\tfor (int i = 2; i <= n; ++ i)\n\t\t\tif (a[i] <= 0)\n\t\t\t\tflag &= (a[i] - a[i - 1] >= mn);\n\t\tif (flag)\n\t\t\tcout << ans + 1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n \n\treturn 0;\n}"
}