{
    "solution": "1304B - Самый длинный палиндромLet's define rev(S) as the reversed string of a string S. There are two cases when we choose K strings to make a palindrome string S1+S2+⋯+SK:   If K is even, for every integer X (1≤X≤K2), SX=rev(SK−X+1).  if K is odd, SK+12 must be palindrome. Also for every integer X (1≤X≤K−12), SX=rev(SK−X+1). In either case we want to find as many pairs of strings as possible such that one is the reverse of the other. It is also clear that if T is a palindrome string then rev(T)=T. We cannot make a pair of T and rev(T) because all strings in the input are distinct.Therefore, for each string we need to find if there is another string that is its reverse. If there exists one, put them on the left / right end respectively. If there are one or more strings that are palindrome themselves, pick any one of them and put it in the middle.Time complexity: O(n2m) if we implement it naively. O(nmlogn) is possible if we use a data structure that provides O(logn) search such as std::set in C++. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100;\nstring s[MAX_N];\n\nint main()\n{\n\tset<string> dict;\n\tint n, m, i;\n\tcin >> n >> m;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> s[i];\n\t\tdict.insert(s[i]);\n\t}\n\tvector<string> left, right;\n\tstring mid;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstring t = s[i];\n\t\treverse(t.begin(), t.end());\n\t\tif (t == s[i])\n\t\t\tmid = t;\n\t\telse if (dict.find(t) != dict.end())\n\t\t{\n\t\t\tleft.push_back(s[i]);\n\t\t\tright.push_back(t);\n\t\t\tdict.erase(s[i]);\n\t\t\tdict.erase(t);\n\t\t}\n\t}\n\tcout << left.size() * m * 2 + mid.size() << endl;\n\tfor (string x : left)\n\t\tcout << x;\n\tcout << mid;\n\treverse(right.begin(), right.end());\n\tfor (string x : right)\n\t\tcout << x;\n\tcout << endl;\n}"
}