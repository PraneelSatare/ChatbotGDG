{
    "solution": "1741C - Minimize the ThicknessLet's iterate over the length of the first segment of the split. Having fixed it, we actually fixed the sum that needs to be collected on all other segments. Since each element must belong to exactly one segment, we can build other segments greedily. If we have found a solution, we will remember the length of the longest segment in it and try to update the answer. We have n possible lengths of the first segment, for each of which we greedily built the answer for n. Thus, the asymptotics of the solution will be O(n2). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2020;\n\nint n;\nint arr[MAXN];\n\nint go(int i, int sum) {\n\tif (i == n) return 0;\n\tfor (int j = i + 1, cur = 0; j <= n; ++j) {\n\t\tcur += arr[j - 1];\n\t\tif (cur > sum) return n;\n\t\tif (cur == sum) return max(j - i, go(j, sum));\n\t}\n\treturn n;\n}\n\nint solve() {\n\tint ans = n;\n\tfor (int len = 1, sum = 0; len < n; ++len) {\n\t\tsum += arr[len - 1];\n\t\tans = min(ans, go(0, sum));\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> arr[i];\n\t\tcout << solve() << endl;\n\t}\n}"
}