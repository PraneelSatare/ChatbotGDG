{
    "solution": "1899B — 250 Thousand Tons of TNTIdea: zwezdinv, development: zwezdinv. EditorialSolution #1:Since k is a divisor of n, there are O(3√n) such k. We can enumerate all k, calculate a given value in O(n), and take the maximum of them. Total complexity — O(n⋅3√n).Solution #2:Without using the fact that k is a divisor of n, we can simply loop over k and then calculate the values using prefix sums, and at the end check that there are exactly k elements in each segment. Such a solution works in O(n1+n2+n3+⋯+nn)=O(nlogn). Solution#include<bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n#define all(x) x.begin(), x.end()\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    ll ans = -1;\n    for (int d = 1; d <= n; ++d) {\n        if (n % d == 0) {\n            ll mx = -1e18, mn = 1e18;\n            for (int i = 0; i < n; i += d) {\n                ll sm = 0;\n                for (int j = i; j < i + d; ++j) {\n                    sm += a[j];\n                }\n                mx = max(mx, sm);\n                mn = min(mn, sm);\n            }\n            ans = max(ans, mx - mn);\n        }\n    }\n    cout << ans << '\\n';\n}\n \nint32_t main() {\n    int t;\n    cin >> t;\n    while (t--) solve();\n}"
}