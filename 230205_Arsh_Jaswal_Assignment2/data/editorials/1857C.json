{
    "solution": "1857C - Assembly via MinimumsSuppose we have an array a that we want to construct, with elements a1,a2,…,an. To simplify the process, let's assume that the elements of a are sorted in non-decreasing order, meaning a1≤a2≤⋯≤an.Let's start with a1. Since the elements of a are sorted, the pairs (a1,a2),(a1,a3),…,(a1,an) will have a1 as the smallest element in each pair. Therefore, the number of occurrences of a1 in array b will be n−1.Moving on to a2, we already know that a1 appears n−1 times in b. Since the elements of a are sorted, all pairs involving a2 will have a2 as the second smallest element. This means a2 will appear n−2 times in array b.We continue this process for each element ai in a. The number of occurrences of ai in array b will be n−i.We can't determine the exact value of an , because it won't be written to array b. Therefore, for an we can choose any number in the range [an−1;109]. In case there are multiple elements bi in array b that satisfy the condition for a particular ai, we choose the smallest bi. This greedy approach works, because we are constructing a in non-decreasing order.The complexity is O(n2logn). Code C++#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;cin>>t;\n    while(t--)\n    {\n        int n;cin>>n;\n        int m=n*(n-1)/2,b[m];\n        for(int i=0;i<m;i++)cin>>b[i];\n        sort(b,b+m);\n        for(int i=0;i<m;i+=--n)cout<<b[i]<<' ';\n        cout<<\"1000000000\\n\";\n    }\n} Code Pythonfor _ in range(int(input())):\n    n=int(input())\n    l=sorted(map(int,input().split()))\n    j=0\n    for i in range(n-1,0,-1):\n        print(l[j],end=' ')\n        j+=i\n    print(l[-1]) Rate the problem Good task \n\n    \n\n\n572\n\n\n\n Average task \n\n    \n\n\n67\n\n\n\n Bad task \n\n    \n\n\n42\n\n\n\n Didn't solve \n\n    \n\n\n67\n\n\n\n "
}