{
    "solution": "1409C - Yet Another Array RestorationThe only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression. After that, we can fix the first element start, fix the difference d, construct the array [start,start+d,start+2d,…,start+d⋅(n−1)], check if x and y are in this array and, if yes, update the answer with start+d⋅(n−1). This is O(n3) solution.There are faster solutions, though. Other author's solution is O(ny√) but I didn't want to make this problem harder, so I allowed O(n3) solutions.It is obvious that the difference of the progression is some divisor of y−x. Let it be d. Let's add some elements starting from y \"to the left\" (y,y−d,y−2d and so on) and stop if we reach n elements or the next element is less than 1. If we didn't find x among these elements, just skip this difference, it is useless for us. Otherwise, if we have less than n elements, let's add y+d,y+2d,y+3d and so on until we get n elements. And then update the answer with the maximum element of the array.There is also a solution in O(n+y√) with some greedy observations :) Solution (Gassa)// Author: Ivan Kazmenko (gassa@mail.ru)\nmodule solution;\nimport std.algorithm;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nimport std.string;\n\nvoid main ()\n{\n\tauto tests = readln.strip.to !(int);\n\tforeach (test; 0..tests)\n\t{\n\t\tint n, x, y;\n\t\treadf !(\" %s %s %s\") (n, x, y);\n\t\tauto answer = int.max.repeat (n).array;\n\t\tforeach (start; 1..51)\n\t\t{\n\t\t\tforeach (d; 1..51)\n\t\t\t{\n\t\t\t\tauto a = iota (start, start + d * n, d).array;\n\t\t\t\tif (a.canFind (x) && a.canFind (y))\n\t\t\t\t{\n\t\t\t\t\tif (answer.back > a.back)\n\t\t\t\t\t{\n\t\t\t\t\t\tanswer = a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twritefln !(\"%(%s %)\") (answer);\n\t}\n} Solution (vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, x, y;\n\t\tcin >> n >> x >> y;\n\t\tvector<int> ans;\n\t\tfor (int d = 1; d <= y - x; ++d) {\n\t\t\tif ((y - x) % d != 0) continue;\n\t\t\tvector<int> res;\n\t\t\tbool foundx = false;\n\t\t\tint cur = y;\n\t\t\tint need = n;\n\t\t\twhile (cur >= 1 && need > 0) {\n\t\t\t\tres.push_back(cur);\n\t\t\t\tfoundx |= cur == x;\n\t\t\t\t--need;\n\t\t\t\tcur -= d;\n\t\t\t}\n\t\t\tcur = y;\n\t\t\twhile (need > 0) {\n\t\t\t\tcur += d;\n\t\t\t\tres.push_back(cur);\n\t\t\t\t--need;\n\t\t\t}\n\t\t\tsort(res.begin(), res.end());\n\t\t\tif (need == 0 && foundx) {\n\t\t\t\tif (ans.empty() || ans.back() > res.back()) {\n\t\t\t\t\tans = res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(!ans.empty());\n\t\tfor (auto it : ans) cout << it << \" \";\n\t\tcout << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n} Solution (Rox)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int tcs;\n    cin >> tcs;\n\n    while (tcs--) {\n        int n, x, y;\n        cin >> n >> x >> y;\n        int diff = y - x;\n        for (int delta = 1; delta <= diff; ++delta) {\n            if (diff % delta) continue;\n            if (diff / delta + 1 > n) continue;\n            int k = min((y - 1) / delta, n - 1);\n            int a0 = y - k * delta;\n            for (int i = 0; i < n; ++i) {\n                cout << (a0 + i * delta) << ' ';\n            }\n            cout << endl;\n            break;\n        }\n    }\n}"
}