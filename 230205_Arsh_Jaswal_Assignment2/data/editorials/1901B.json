{
    "solution": "1901B - Chip and RibbonAt first, let's change the statement a bit: instead of teleporting our chip into cell x, we create a new chip in cell x (it means that the chip does not disappear from the cell where it was located). And when we want to move a chip, we move any chip to the next cell. Then, ci will be the number of times a chip appeared in the cell i, and the problem will be the same: ensure the condition on each ci by \"creating\" the minimum number of chips.Let's look at value of c1. If c1>1, we have to create at least c1−1 new chips in cell 1. Let's create that number of chips in that cell.Then, let's see how we move chips from the cell i to the cell (i+1). If ci≥ci+1, then all chips that appeared in the cell (i+1) could be moved from the i-th cell, so we don't need to create any additional chips in that cell.But if ci<ci+1, then at least ci+1−ci chips should be created in the cell (i+1), since we can move at most ci chips from the left.So, for every i from 2 to n, we have to create max(0,ci−ci−1) chips in the i-th cell; and the number of times we create a new chip in total is c1−1+∑i=2nmax(0,ci−ci−1). Solution (Roms)#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 200'000;\n \nint t;\n \nint main() {\n    cin >> t;\n    for (int tc = 0; tc < t; ++tc) {\n        int n;\n        cin >> n;\n        vector <int> cnt(n);\n        long long res = 0;\n        int cur = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> cnt[i];\n            if (cnt[i] > cur) \n                res += cnt[i] - cur;\n            cur = cnt[i];\n        }\n        \n        cout << res - 1 << endl;\n    }\n    return 0;\n}"
}