{
    "solution": "1637B - MEX and ArrayWe show, that replacing a segment of length $$$k$$$ ($$$k > 1$$$) with segments of length $$$1$$$ does not decrease the cost of the partition. Consider two cases:  The segment does not contain $$$0$$$.  The segment contains $$$0$$$. In the first case the contribution of the segment equals to $$$1$$$ (because $$$mex = 0$$$), but the contribution of $$$k$$$ segments of length $$$1$$$ equals to $$$k$$$. So the cost increased. In the second case the contribution of the segment equals to $$$1 + mex <= 1 + k$$$, but the contribution of the segments of length $$$1$$$ would be at least $$$1 + k$$$, so the cost has not decreased.Then it is possible to replace all segments of length more than $$$1$$$ by segments of length $$$1$$$ and not decrease the cost. So the value of the array $$$b_1, b_2, \\ldots, b_k$$$ equals to $$$\\sum_{i=1}^{k}{(1 + mex(\\{b_i\\}))}$$$ = $$$k$$$ + (the number of zeros in the array).To calculate the total $$$value$$$ of all subsegments, you need to calculate the total length of all subsegments and the contribution of each $$$0$$$. The total length of all subsegments equals to $$$\\frac{n \\cdot (n + 1) \\cdot (n + 2)}{6}$$$. The contribution of a zero in the position $$$i$$$ equals to $$$i \\cdot (n - i + 1)$$$. This solution works in $$$O(n)$$$, but it could be implemented less efficiently.There is also another solution, which uses dynamic programming: let $$$dp_{l, r}$$$ is the value of the array $$$a_l, a_{l + 1}, \\ldots, a_r$$$. Then $$$dp_{l, r} = max(1 + mex(\\{a_l, a_{l + 1}, \\ldots, a_r\\}), \\max_{c = l}^{r - 1} (dp_{l, c} + dp_{c + 1, r}))$$$. This solution can be implemented in $$$O(n^3)$$$ or in $$$O(n^4)$$$. Solution#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto& u : a)\n            cin >> u;\n \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += (i + 1) * (n - i);\n            if (a[i] == 0)\n                ans += (i + 1) * (n - i);\n        }\n        cout << ans << '\\n';\n    }\n}"
}