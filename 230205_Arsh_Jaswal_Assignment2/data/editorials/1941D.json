{
    "solution": "1941D - Rudolf and the Ball GameLet's introduce a set of unique elements q, initially containing a single element x — the index of the first player who started the game. For each i from 1 to m, we will update q in such a way as to maintain the set of players who could have the ball after the i-th throw. For each element qj of the set q, we will remove qj from q, and also:   if ci=\"0\" or ci=\"?\", add to q the element ((qj+ri−1) mod n+1) — the index of the player who will receive the ball in case of a clockwise throw;  if ci=\"1\" or ci=\"?\", add to q the element ((qj−ri−1+n) mod n+1) — the index of the player who will receive the ball in case of a counterclockwise throw. The term n before the mod operation is necessary to obtain a positive argument of this operation. Otherwise, in some programming languages, the mod function will return a negative result, which does not correspond to the semantics of the problem.  The operation u mod v denotes the remainder of the division of u by v. It should be noted that it is not needed to store duplicates in q — one index of the thrower is sufficient for the correct calculation of the players who could have received their throw.After the m-th iteration of the described cyclic process, the set q will contain the desired indices of all players who could have the ball at the end of the game.At each iteration of the loop, the power of q does not exceed n, and a total of exactly m iterations will be performed. Thus, the asymptotic complexity of the algorithm is of the order O(n∗m). Solution#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int t; cin >> t;\n    while (t--) {\n        int n, m, a; cin >> n >> m >> a;\n        set <int> q[2];\n        int ix = 0;\n        q[ix].insert(a);\n        while (m--) {\n            int x; char ch; cin >> x >> ch;\n            while (!q[ix].empty()) {\n                int u = *(q[ix].begin());\n                q[ix].erase(u);\n                if (ch == '?' || ch == '0') {\n                    q[ix ^ 1].insert((u + x - 1) % n + 1);\n                }\n                if (ch == '?' || ch == '1') {\n                    q[ix ^ 1].insert((u - x - 1 + n) % n + 1);\n                }\n            }\n            ix ^= 1;\n        }\n        cout << q[ix].size() << '\\n';\n        for (auto& x : q[ix]) {\n            cout << x << ' ';\n        }\n        cout << '\\n';\n    }\n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n66\n\n\n\n Good task \n\n    \n\n\n384\n\n\n\n Average task \n\n    \n\n\n35\n\n\n\n Bad task \n\n    \n\n\n35\n\n\n\n "
}