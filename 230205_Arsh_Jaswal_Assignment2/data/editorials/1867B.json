{
    "solution": "1867B — XOR PalindromesAuthor: ace5 TutorialFirstly, a string is a palindrome if and only if for any i (1≤i≤n) si=sn−i+1 (because when reversed, si becomes sn−i+1).We can divide the characters into pairs, where each pair consists of si and sn−i+1. If si=sn−i+1, then we need to have li=ln−i+1 in order to obtain equal elements after XOR. Therefore, either li=ln−i+1=0 (with 0 ones) or li=ln−i+1=1 (with 2 ones). If si≠sn−i+1, then li≠ln−i+1 must hold (1 one in any case). Additionally, if n is odd, then ln/2+1 can be either 0 or 1 (with 0 or 1 ones).We can iterate over the number of pairs where li=ln−i+1 will have two ones, as well as whether there will be a one in the center or not. This way, we can obtain all possible numbers of ones in l, i.e., all good i.Time Complexity: O(n) per test case. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        string t(n+1,'0');\n        int ans = 0;\n        int max_1 = 0;\n        int max_2 = 0;\n        for(int i = 0;i <= n/2-1;++i)\n        {\n            if(s[i] == s[n-i-1])\n                max_2++;\n            else\n                ans++;\n        }\n        if(n%2 == 1)\n            max_1++;\n        for(int j = 0;j <= max_2;++j)\n        {\n            for(int k = 0;k <= max_1;++k)\n            {\n                t[ans + j*2 + k] = '1';\n            }\n        }\n        cout << t << \"\\n\";\n    }\n}"
}