{
    "solution": "1392C - Omkar and WaterslideCall the initial array a. We claim that the answer is ∑max(ai−ai+1,0) over the entire array of supports (call this value ans). Now let's show why.First, notice that in a nondecreasing array, ans=0. So, the problem is now to apply operations to the array such that ans=0.Now, let's see how applying one operation affects ans. Perform an operation on an arbitrary nondecreasing subarray that begins at index i and ends at index j. Note that the differences of elements within the subarray stay the same, so the only two pairs of elements which affect the sum are ai−1,ai and aj,aj+1.Let's initially look at the pair ai−1,ai. If ai−1≤ai (or if i=1), applying an operation would not change ans. But, if ai−1/gtai, applying an operation would decrease ans by 1.Now let's look at the pair aj,aj+1. If aj≤aj+1 (or if j=n), applying an operation would not change ans. But, if aj>aj+1, applying an operation would increase ans by 1.We have now shown that we can decrease ans by at most 1 with each operation, showing that it is impossible to make his supports able to hold the waterslide in fewer than ∑max(ai−ai+1,0) over the initial array. Now, let's construct a solution that applies exactly ∑max(ai−ai+1,0) operations to make the array valid.Consider applying operations to each suffix of length j until the suffix of length j+1 is nondecreasing. Since operations are applied iff an−j+1<an−j, and each operation decreases an−j+1<an−j by 1, the total number of operations would just be the sum of max(0,an−j−an−j+1), which is equal to ∑max(ai−ai+1,0) over the entire array. Solution (Kotlin) by Tlatoaniimport kotlin.math.max\n\nfun main() {\n    for (c in 1..readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val hs = readLine()!!.split(\" \").map { it.toLong() }\n        var answer = 0L\n        for (j in 1 until n) {\n            answer += max(0L, hs[j - 1] - hs[j])\n        }\n        println(answer)\n    }\n} Solution (Java) by qlf9import java.util.*;\nimport java.io.*;\n\npublic class OmkarAndWaterslide {\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(f.readLine());\n        while(t-->0){\n            int n = Integer.parseInt(f.readLine());\n            long[] arr = new long[n];\n            StringTokenizer st = new StringTokenizer(f.readLine());\n            for(int i = 0; i < n; i++){\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n            long ans = 0;\n            for(int i = 0; i < n-1; i++){\n                ans+=Math.max(0, arr[i]-arr[i+1]);\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n} Solution (C++) by tfg#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint t;\n\tstd::cin >> t;\n\twhile(t--) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tlong long last = 0;\n\t\tlong long ans = 0;\n\t\twhile(n--) {\n\t\t\tlong long x;\n\t\t\tstd::cin >> x;\n\t\t\tx += ans;\n\t\t\tif(x >= last) {\n\t\t\t\tlast = x;\n\t\t\t} else {\n\t\t\t\tans += last &mdash; x;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << '\\n';\n\t}\n}Idea: qlf9Preparation: qlf9 "
}