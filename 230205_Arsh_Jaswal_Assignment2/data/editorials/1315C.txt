1315C - Restoring PermutationThis problem has a greedy solution. As you know the bi, which is equal to min(a2i−1,a2i), then one of a2i−1,a2i should be equal to bi. Which one? Of course, a2i−1, because we want to get the lexicographically minimal answer, and we want to place a smaller number before the larger number.So, we know that a1=b1, a3=b2, a5=b3, and so on, so we know all elements of the permutation with odd indices. What number should be placed at a2? We know that a2≥a1 (as a1≠a2, and b1=min(a1,a2)). So, let's take the a2=x for minimal possible x such that x≥a1 and x≠a1,x≠a3,…,x≠a2n−1. If there is no such x (if all numbers greater than a1 are already used), there is no appropriate permutation. Otherwise, we should take a2=x and resume the process.The question is, why do we can place the minimal not used integer each time? Suppose there is another optimal answer a′1,a′2,…,a′2n, and we get a1,a2,…,a2n or we didn't get any permutation by our greedy algorithm. As these two sequences are different, there is the first k such that a′2k≠a2k. As we tried to take the minimal possible a2k, there are two options:   a2k>a′2k. This is impossible as we tried to take the minimal possible a2k, contradiction;  a2k<a′2k. As a′ is «optimal correct» answer, we didn't finish our sequence a. Let's see, where is the number a2k in the sequence a′. It should be on some position 2l, where l>k (as 2k is the first difference between the sequences). But we can swap a′2k and a′2l and get smaller, but still correct sequence a", so a′ is not optimal. Contradiction.  1310A - RecommendationsIn this problem we have an array a1,…,an, we can increase each ai by one with cost ti, and we want to make all ai different with minimal total cost.Let's sort ai in a non-decreasing way (and permute the t in a corresponding way). Let's see at the minimal number, a1. If it is unique, e.g. a1≠a2, then we don't need to change a1 — it is already unique, and it can't get equal to something else if we don't increase it. In this case, we can just skip a1 and solve the smaller problem without a1.Otherwise, suppose there is some j>1 such that a1=a2=…=aj. Obviously, we should leave at most one of them with the current value, and increase other j−1 numbers by one. Which one should be not increased? We shouldn't increase the al (1≤l≤j) with the maximal tl because it minimizes the total cost. So, we should remove the maximal value tl among all elements with minimal al, and increase all other by one. This effectively reduces our problem to the smaller one, decreasing n by one.This gives us a O(n2) solution — n times we discard one minimum from the array and increase all other minimums by one. We can further optimize it by using a multiset of values tl for all minimal al and its sum. At each iteration, we should (probably) add some values to a multiset, if the number of minimums in array increases, discard one maximum from multiset and add the current sum to the answer. Continue the process until the array becomes empty. This is an O(nlogn) solution. 1310B - Double EliminationThe main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket, exactly one player will win all matches in the upper bracket, and exactly one player will win all matches in the lower bracket. We can define this set of players (in 0-indexation instead of 1-indexation from statement) as [a⋅2t;(a+1)⋅2t) for some 1≤t≤n, 0≤a<2n2t. For each fixed t the players with different values of id2t don't play with each other, and their upper and lower brackets are independent.For each of these sets of players, we are interested only in a number of interesting matches between them, and if the winner of their upper and lower brackets are the teams that are we're fans of. This leads us to the dynamic programming solution: dp[l…r][fup][flower] — the maximal number of matches between teams with indices in [l;r), if fup∈{0,1} is 1 if the we're fans of winner of upper bracket, and flower∈{0,1} is 1 if the we're fans of winner of lower bracket. Again, l…r is the special segment: l=a⋅2t,r=(a+1)⋅2t−1 for some 1≤t≤n, 0≤a<2n2t.dp[l…r][fup][flower] can be recalculated from dp[l…l+r2][flup][fllower] and dp[l+r2…r][frup][frlower] — we just iterate over all possible flup,fllower,frup,frlower, and the results of all three matches (one in the upper bracket and two in the lower bracket).In the end, we use dp[0…2n][fup][flower] to count the result with the last, grand-finals match.This solution works in something like O(2n⋅27) because there are 2n interesting segments. 1310C - Au Pont RougeLet's list all distinct substrings, sort them and make a binary search. Now, we need to count number of ways to make minimal string no more then given one. Let's count inverse value — number of wat to make minimal string greater. It could be done by quadratic dynamic programming dppos,count — number of ways to split suffix starting at pos to count string all of which are greater then given value. Let's find first position where suffix differs which given string. If next character in suffix is smaller, no part can start here and answer is zero. Otherwise, any longer part is acceptable, so we need to find ∑i>lcp(S,s[pos:])dpi,count−1, which can be done in O(1) time by suffix sums and precalculating lcp for all pairs of suffixes. Later can by done by another quadratic dynamic programming. lcp of two suffix is equal to 0 if first letter differs, and equal to lcp of two smaller suffixes +1 otherwise.  1310D - TourismThere are two different solutions possible. First, one is to fix all even vertices in the path. It can be done in O(nk/2−1) time. If it's done, we need to join them by the minimal path of length 2, not going through these vertices. It can be done by precalculating 6 minimal paths of length 2 between each pair of vertices and ignoring no more than 5 best ones until good one found. Another solution is a randomized one. Let's color all vertices in 2 colors in a random way. We can find the best path which is consistent with given coloring in O(k⋅E) time using dynamic programming. With probability 1512 best path overall is consistent with coloring. So, if one repeats this operation 512⋅20 time, probability of fail would be about (511512)512⋅20≈e−20≈2⋅10−9.  1310E - Strange FunctionThe solution of the task consists of three cases:  k=1. For fixed n f(a) can be equal to any partition of n. We need to count the number of arrays b1,b2,…,bm, such that b1≥b2≥…≥bm and m∑i=1bi≤n. This can be done by simple dp in O(n2) (or even faster, much faster). k=2. When the array b1≥b2≥…≥bm can be equal to value of f2(a) for some |a|≤n? When there exists some array c1,…,cl such that l∑i=1ci≤n, and f(c)=b. The values of b are the numbers of occurences of numbers in c, so we need to minimize m∑i=1bivi, where vi — the unique numbers in c. To minimize this sum we should take v1=1,…,vm=m, so we need m∑i=1bii≤n. This can be done by simple dp: dp[val][j][sum] — the number of prefixes of b such that we already took j elements to b, all elements on prefix are greater than or equal to val, and the j∑i=1bii=sum.This dp can look like it is O(n3), but it is actually O(n2logn), because there is a limitation val⋅j≤n, and there are O(nlogn) such pairs. There is also a subquadratic solution. k≥3. We can notice that in the array f2(a) there are at most O(√2n) elements. We can use this fact to bruteforce all possible answers — candidates for the answer are the partitions of numbers not exceeding √2n=64, there are few millions of them. How to check if the array b1≥b2≥…≥bm can be the falue of fk(a)? It happens that we can make k−2 iterations of the unfolding algorithm from case k=2 and get the «minimal» possible array a, and check, if it contains no more than n elements. This part works in O(P(√2n)). 1310F - Bad CryptographyOne of the well-known algorithms for the discrete logarithm problem is baby step giant step algorithm based on the meet in the middle idea. It can solve the problem in O(√|F|) time, which is definitely too much for the field of size 264. Multiplicative group of field has size F=264−1=3⋅5⋅17⋅257⋅641⋅65537⋅6700417. We can see, that all numbers in this factoring are not too big. Let's try to find an answer modulo each of these primes. If we do that, we can restore the answer by the Chinese remainder theorem, and we are done. Let p be one of divisors. So, if x=k∗p+y is answer, than akp+y=b, than akF+yFp=bFp. aF is equal to 1, so problem is equivalent to searching such an y, that (aFp)y=bFp, which is discrete logarithm problem on multiplicative subgroup of size p. So it can be solved using O(√p) multiplications, which is about 6000 multiplications total for all values of p. If one of the discrete logarithms not exists, the total answer obviously not exists. Another corner case, that both values in subproblem can be equal to 1. That means, that any value for this module is good. Also, this means, that a and b both have a smaller period, so any of these values would lead us to the correct answer. Another part of problem is making multiplication fast enough. The first idea is to cache multiplications for powers of 2. This solution works for about 5 seconds in my implementation, and probably can be squeezed in time limit with some hacks. But multiplication can be done asymptotically faster. Let's a=a1⋅P+a2, b=b1⋅P+b2 is decomposition to first and second half of bits (in fact P is equal to power in multiply_powers_of_2 function). Then a⊙b=(a1⋅P+a2)⋅(b1⋅P+b2)=(a1⊙P⊕a2)⊙(b1⊙P⊕b2)=(a1⊙b1)⊙(P⊙P)⊕(a2⊙b2)⊕((a1⊙b2)⊕(a2⊙b1))⊙P. As in Karatsuba algroithm, this 4 products can be reduce for 3, if one notice, that (a1⊙b2)⊕(a2⊙b1)=(a1⊕a2)⊙(b1⊕b2)⊕(a1⊙b1)⊕(a2⊙b2). The only diffrenece is instead of shift for multiplying on P⋅P we need to do one more multiplication. But P⊙P=P⊕P2. We can multiply by them separately. Multiplying on P is easy. The other one is multiplying on the power of 2, which can be done by the naive algorithm in linear time. On the other hand, we can just call multiply for the second one recursively, and it will work fast enough because most of the branches will lead to multiplying on zero. Also, to make things fast, one can precompute all multiplications for numbers smaller than 256. This makes multiplication about 5 times faster than naive approach. 