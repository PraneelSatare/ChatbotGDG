{
    "solution": "1873E - Building an AquariumWe need to find the maximum height with a certain upper bound — this is a tell-tale sign of binary search. If you don't know what that is, you should read this Codeforces EDU article.For a given value of h, in the i-th column we will need h−ai units of water if h≥ai, or 0 units otherwise. (This is equal to max(h−ai,0), why?) So we can compute the amount of water for all n columns by simply iterating through and summing the total amount of water needed for each column, and see if it's not larger than x.Then you can binary search on the optimal value of h. The model solution uses the starting bounds l=0, r=2ai+ε, because the optimal height could be ai+x. So the complexity is O(nlogai) per testcase. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nvoid solve() {\n\tint n;\n\tlong long x;\n\tcin >> n >> x;\n\tlong long a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tlong long lo = 0, hi = 2'000'000'007;\n\twhile (lo < hi) {\n\t\tlong long mid = lo + (hi - lo + 1) / 2;\n\t\tlong long tot = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttot += max(mid - a[i], 0LL);\n\t\t}\n\t\tif (tot <= x) {lo = mid;} \n\t\telse {hi = mid - 1;}\n\t}\n\tcout << lo << endl;\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n\n"
}