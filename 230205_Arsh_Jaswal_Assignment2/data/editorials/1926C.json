{
    "solution": "1926C - Vlad and a Sum of Sum of DigitsLet's denote S(x) as the sum of digits of number x. Since n≤2⋅105, for a single test case, we can brute force S(1)+S(2)+S(3)+⋯+S(n) and output the answer. However, since the number of test cases is large, we can't compute this value for n each time. This needs a standard idea of precomputation: we will compute the answer for each value from 1 to n and store it in an array ans: ans(n)=S(n)+ans(n−1). Then to answer each test case we just output ans(n). No math is needed!The precomputation takes O(nlogn) time (it takes O(logn) time to find sum of digits), but now we can answer queries in O(1) per test case, so overall the complexity is O(nlogn+t). Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nint res[MAX];\n \nint S(int x) {\n\tint res = 0;\n\twhile (x) {\n\t\tres += (x % 10);\n\t\tx /= 10;\n\t}\n\treturn res;\n}\n \nvoid solve() {\n\tint x;\n\tcin >> x;\n\tcout << res[x] << '\\n';\n}\n \nint main() {\n\tres[0] = 0;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tres[i] = res[i - 1] + S(i);\n\t}\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n"
}