{
    "solution": "960A - Check the stringTraverse the string once and check if the ASCII value of all characters is greater than or equal or the ASCII value of the previous character. This ensures that the string does not have a,b,c in wrong order.Also, while traversing the string, keep three separate counters for the number of 'a', 'b' and 'c' along.Now, do a simple check on the condition for the count of 'c'.The hack case for many solutions was to check that the count of 'a' is atleast 1 and the count of 'b' is atleast 1.Set by : vntshh Setter's solution#include<bits/stdc++.h>\n#define rep(i,start,lim) for(lld i=start;i<lim;i++)\n#define repd(i,start,lim) for(lld i=start;i>=lim;i--)\n#define scan(x) scanf(\"%lld\",&x)\n#define print(x) printf(\"%lld \",x)\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define br printf(\"\\n\")\n#define sz(a) lld((a).size())\n#define YES printf(\"YES\\n\")\n#define NO printf(\"NO\\n\")\n#define all(c) (c).begin(),(c).end()\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define EPS         (double)1e-10\n#define MOD         1000000007\n#define PI          3.14159265358979323\nusing namespace std;\ntypedef long double ldb;\ntypedef long long lld;\nlld powm(lld base,lld exp,lld mod=MOD) {lld ans=1;while(exp){if(exp&1) ans=(ans*base)%mod;exp>>=1,base=(base*base)%mod;}return ans;}\nlld ctl(char x,char an='a') {return (lld)(x-an);}\nchar ltc(lld x,char an='a') {return (char)(x+an);}\n#define bit(x,j) ((x>>j)&1)\ntypedef vector<lld> vlld;\ntypedef pair<lld,lld> plld;\ntypedef map<lld,lld> mlld;\ntypedef set<lld> slld;\n#define sync ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define mxm(a,b) a = max(a,b)\n#define mnm(a,b) a = min(a,b)\n#define endl '\\n'\n#define fre freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout);\n#define N 1000005\nint main()\n{\n    //sync;\n    string s;\n    map<char,lld> m;\n    cin>>s;\n    lld k = sz(s);\n    string tmp = \"\";\n    tmp += s[0];\n    rep(i,1,k) if(s[i]!=s[i-1]) tmp+=s[i];\n    rep(i,0,k) m[s[i]]++;\n    if(tmp != \"abc\") return 0*NO;\n    if(m['c']!=m['a'] and m['c']!=m['b']) return 0*NO;\n    if(m['a']>=1 and m['b']>=1) return 0*YES;\n    else return 0*NO;\n    return 0;\n} "
}