1706B - Making TowersWhen can two blocks of the same color form two consecutive elements of a tower? Formally, if we have two blocks of the same color at indices i and j such that i<j, how can we tell if it is possible to place them at (xi,yi) and (xi,yi+1) respectively?As it turns out, they can be placed like this if and only if i and j have different parities. First, if they have the same parity, it is impossible to place them this way. Note that xi+yi must have a different parity from xi+1+yi+1, since these sums must differ by exactly 1. So, if i and j have the same parity, then xi+yi must also have the same parity as xj+yj. But we want them to be vertically adjacent, which is not possible if their parities must be the same. So, it is impossible to make two blocks with indices of the same parity adjacent to each other.Next, there is a valid construction if you want to put blocks i and j together when they have different parities. Say that block i will go at position (xi,yi) and block j goes at position (xi,yi+1). If j=i+1, then we are done. Now, let's say that j=i+3. Then, we can place block i+1 at (xi+1,yi) and block j−1 at position (xi+1,yi+1). What if j=i+5? Then we can do the same as the previous case, and then put block i+2 at (xi+2,yi) and block j−2 at (xi+2,yi+1). Essentially, we are making the blocks between i and j into a horizontal line extending out for j−i−12 blocks then coming back in.If there are already blocks to the right of (xi,yi), then we can do the same construction but extending out to the left. Note that since we cannot move down, at least one of the right and left side must be open.There are two ways we can go from here:First, there is a DP solution. Let's imagine the naive O(n2) dp: We say that dp[i][c] is the maximum size of a tower with color c, such that the last block placed was at index i. The transitions look like this: dp[i][ci]=maxj<i,j≢i(mod2)(dp[j][ci]+1). We check all j<i such that j and i have different parities, then see if adding a block to this tower makes a better solution. To optimize it, we can notice that for the first DP dimension (index), only the parity of the index matters  — for each color, we just need to keep track of the maximum dp[i][c] for even and odd i.We will iterate through all blocks ai, maintaining dp[p][c], which contains the maximum size of a tower with color c, where the last block included in the tower had an index with parity p (p=0 indicates an even index, p=1 indicates an odd index). If the current index is even, we set dp[0][ci]=max(dp[0][ci],dp[1][ci]+1). If it is odd, we set dp[1][ci]=max(dp[1][ci],dp[0][ci]+1). The solution runs in linear time.Alternatively, there's a greedy solution. After selecting a block, the next block selected must always have the opposite parity. Therefore, it makes sense to greedily select the first block of the same color with opposite parity, since it will never improve the answer if we select a later block. For each color, we start from the first block and iterate through, adding each block to the sequence if and only if it has a different parity from the last one. CodeSolution 1 (BucketPotato): 164798955Solution 2 (BucketPotato): 164799024Problem C Solution