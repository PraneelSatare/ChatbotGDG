{
    "solution": "2044D - Harder ProblemProblem Credits: cry, vgoofficial  Analysis: macaquedev Solution Observe that if you have an array where all elements are unique, they will all have frequency 1, therefore they can all be classified as the mode. Therefore, it follows that the strategy for the construction is to just construct an array where for each prefix, the last element of this prefix appears in the array at least once. An easy way of doing is this is such:For each element ai, if this value has appeared previously in the array (you can use a set to check this), set bi equal to some random integer that isn't used elsewhere in the list a, and keep going. Otherwise, set bi=ai. Code (C++)#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    while(tt--)\n    {\n        int n;\n        cin>>n;\n        vector<int> a(n+1),b(n);\n        for(int i=0;i<n;i++)\n        {\n            int x;\n            cin>>x;\n            if(!a[x])\n            {\n                b[i]=x;\n                a[x]=1;\n            }\n        }\n        queue<int> q;\n        for(int i=1;i<=n;i++)\n            if(!a[i])\n                q.push(i);\n        for(int i=0;i<n;i++)\n        {\n            if(!b[i])\n            {\n                b[i]=q.front();\n                q.pop();\n            }\n        }\n        for(int i=0;i<n;i++)\n            cout<<b[i]<<\" \\n\"[i==n-1];\n    }\n    return 0;\n}"
}