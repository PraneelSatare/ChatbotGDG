{
    "solution": "1559C - Mocha and HikingIf a1=1, then the path [(n+1)→1→2→⋯→n] is valid.If an=0, then the path [1→2→⋯→n→(n+1)] is valid.Otherwise, since a1=0∧an=1, there must exists an integer i (1≤i<n) where ai=0∧ai+1=1, then the path [1→2→⋯→i→(n+1)→(i+1)→(i+2)→⋯n] is valid.This is a step to prove that there always exists an Hamiltonian path in a tournament graph. solution#include <bits/stdc++.h>\n#define maxn 100086\n\nusing namespace std;\n\nint t, n;\nint a[maxn];\n\nvoid solve(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i++) scanf(\"%d\", &a[i]);\n\tif(a[1]){\n\t\tprintf(\"%d \", n + 1);\n\t\tfor(int i = 1;i <= n;i++) printf(\"%d \", i);\n\t\treturn;\n\t}\n\tfor(int i = 1;i < n;i++){\n\t\tif(!a[i] && a[i + 1]){\n\t\t\tfor(int j = 1;j <= i;j++) printf(\"%d \", j);\n\t\t\tprintf(\"%d \", n + 1);\n\t\t\tfor(int j = i + 1;j <= n;j++) printf(\"%d \", j);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++) printf(\"%d \", i);\n\tprintf(\"%d \", n + 1);\n}\n\nint main(){\n    scanf(\"%d\", &t);\n    while(t--) solve(), puts(\"\");\n}\n "
}