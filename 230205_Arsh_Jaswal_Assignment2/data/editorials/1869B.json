{
    "solution": "1869B - 2D TravelingFirst of all, it's easy to see that if there are no major cities, the minimum value of the total cost should be |xa−xb|+|ya−yb| — the optimal choice is to fly directly from city a to city b.Claim. Piggy will pass through a maximum of 2 major cities.Proof. If he passes through 3 or more major cities in a row, then he can fly directly from the first one to the last one. If he passes through 2 major cities and passes an ordinary city between them, the cost must be higher than flying directly between these two major cities. So the optimal choice always consists of no more than 2 major cities, and they are in a row.Thus, you can express the optimal choice as a(→s)(→t)→b, where s and t are both major cities. If you naively enumerate s and t, the total complexity of the solution will be O(k2). But after seeing that s and t work independently, we can enumerate them separately. The total complexity decreases to O(n+k). Implementation#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n, k, s, t; cin >> n >> k >> s >> t;\n\tvector<int> x(n + 1), y(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\tll ans = llabs(x[s] - x[t]) + llabs(y[s] - y[t]);\n\tll mins = LLONG_MAX / 2, mint = LLONG_MAX / 2;\n\tfor (int i = 1; i <= k; i++) {\n\t\tmins = min(mins, llabs(x[s] - x[i]) + llabs(y[s] - y[i]));\n\t\tmint = min(mint, llabs(x[t] - x[i]) + llabs(y[t] - y[i]));\n\t}\n\tans = min(ans, mins + mint);\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Rate the problem Amazing problem: \n\n    \n\n\n102\n\n\n\n Good problem: \n\n    \n\n\n366\n\n\n\n Average problem: \n\n    \n\n\n74\n\n\n\n Bad problem: \n\n    \n\n\n32\n\n\n\n Didn't solve: \n\n    \n\n\n31\n\n\n\n "
}