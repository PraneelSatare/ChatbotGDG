{
    "solution": "1594C - Make Them EqualIf the whole string is equal to c then you don't need to make any operations.In order to find if it is possible with exactly 1 operation, we can pass through every x and count all the letters c that are divisible by x. This takes O(|s|log|s|) time complexity.If for some x all its multiples are c then the answer is 1 operation with that x.If all the above conditions don't hold you can always make 2 operations and make all the elements equal.One possible way is with x=|s| and x=|s|−1.After the first operation only the last element of s is not c thus if we use x=|s|−1 since gcd(|s|,|s|−1)=1 then |s| is not divisible by |s|−1 and it will become equal to c.Time complexity: O(|s|log|s|) per test case. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e9+7;\nconst ll MOD = 998244353;\ntypedef pair<ll,ll> ii;\n#define iii pair<ll,ii>\n#define f(i,a,b) for(int i = a;i < b;i++)\n#define pb push_back\n#define vll vector<ll>\n#define F first\n#define S second\n#define all(x) (x).begin(), (x).end()\nint main(void){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        ll n;\n        cin>>n;\n        char c;\n        cin>>c;\n        string s;\n        cin>>s;\n        vector<int>ans;\n        bool ok = true;\n        for(auto x:s){\n            if(x != c){\n                ok = false;\n            }\n        }\n        if(!ok){\n            f(i,1,n+1){\n                ok = true;\n                f(j,i,n+1){\n                    ok &= (s[j-1] == c);\n                    j += i-1;\n                }\n                if(ok){\n                    ans.pb(i);\n                    break;\n                }\n            }\n            if(!ok){\n                ans.pb(n);\n                ans.pb(n-1);\n            }\n        }\n        cout<<ans.size()<<\"\\n\";\n        for(auto x:ans){\n            cout<<x<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n}"
}