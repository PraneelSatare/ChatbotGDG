{
    "solution": "1384A - Common PrefixesThe problem asks to find n+1 strings such that LCP(si,si+1)=ai for all i (1≤i≤n). A way to solve this problem is the following:  Set s1= \"aaaa...aaaaaaa\" (ie. 200 times 'a').  For i such that (1≤i≤n) set si+1:=si and then flip (ai+1)-th character of si+1 (ie. if it was 'a' put 'b' otherwise 'a'). So for each i:   si and si+1 will have exactly ai common characters from the prefix.  The (ai+1)-th character of si+1 is different than (ai+1)-th character of si (this character always exists since 0≤ai≤50 and each string has length exactly 200).  Therefore the LCP is ai as desired. Time complexity: O(n) per testcase C++ solution#include <iostream>\n\n#define endl '\\n'\n\nusing namespace std;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n\n    string s(200, 'a');\n    cout << s << endl;\n\n    for (int i = 0; i < n; ++i)\n    {\n        int u;\n        cin >> u;\n        s[u] = s[u] == 'a' ? 'b' : 'a';\n        cout << s << endl;\n    }\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n\n    for (int i = 0; i < t; ++i)\n    {\n        solve();\n    }\n\n    return 0;\n} Python solutionimport sys\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n    \n        mx = max(a)\n        ans = [ 'a' * (mx + 1) ] * (n + 1)\n    \n        for i, x in enumerate(a):\n            who = 'a' if ans[i][x] == 'b' else 'b'\n            ans[i + 1] = ans[i][:x] + who + ans[i][x + 1:]\n    \n        print('\\n'.join(ans))    \n\nmain()Problem idea: dcordbSolution idea: dcordb and Devil "
}