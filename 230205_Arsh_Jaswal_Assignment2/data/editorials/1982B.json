{
    "solution": "1982B - Collatz ConjectureLet's write down what happens in the problem and try to speed it up. The first observation: we will perform operations until $$$x \\neq 1$$$, after which the answer can be found using the formula $$$ans = 1 + k\\,\\%\\,(y - 1)$$$. Indeed, after $$$x$$$ becomes equal to $$$1$$$, if we continue applying operations to it, it will change as follows:$$$$$$ 1 \\to 2 \\to ... \\to (y - 1) \\to 1 \\to 2 \\to ... \\to (y - 1) \\to 1 \\to ... $$$$$$The second optimization is to group the operations that only add one, so instead of $$$1$$$ we will add the next value to $$$x$$$ in one action $$$min(k, \\lceil \\frac{x}{y} \\rceil \\cdot y - x)$$$. After this (if we added at least $$$1$$$), we should try to divide the number by $$$y$$$ (if it is divisible).If we use these two optimizations, our solution will work in $$$O(\\log x)$$$ for one set of input data, since in one action $$$x$$$ decreases to $$$\\lceil \\frac{x + 1}{y} \\rceil$$$, and therefore $$$x$$$ becomes $$$1$$$ in no more than $$$O(\\log x)$$$ actions. Solution (FelixArg)#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve(){\n\tlong long x, y, k;\n\tcin >> x >> y >> k;\n\twhile (k > 0 && x != 1) {\n\t\tlong long ost = (x / y + 1) * y - x;\n                ost = max(1ll, ost);\n                ost = min(ost, k);\n                x += ost;\n\t\twhile (x % y == 0) {\n\t\t\tx /= y;\n\t\t}\n\t\tk -= ost;\n\t}\n\tcout << x + k % (y - 1) << '\\n';\n}\n \nint main()\n{\n#ifdef FELIX\n\tauto _clock_start = chrono::high_resolution_clock::now();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n \n\tint tests = 1;\n\tcin >> tests;\n\tfor (int test = 0; test < tests; test++){\n\t\tsolve();\n\t}\n \n#ifdef FELIX\n\tcerr << \"Executed in \" << chrono::duration_cast<chrono::milliseconds>(\n\t\tchrono::high_resolution_clock::now()\n\t\t\t- _clock_start).count() << \"ms.\" << endl;\n#endif\n\treturn 0;\n}"
}