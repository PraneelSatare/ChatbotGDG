{
    "solution": "1370B - GCD CompressionKey Idea:It is always possible to form n−1 pairs of elements such that their gcd is divisible by 2.Solution:We can pair up the odd numbers and even numbers separately so that the sum of numbers in each pair is divisible by 2. Note that we can always form n−1 pairs in the above manner because in the worst case, we would discard one odd number and one even number from a. If we discarded more than one even or odd numbers, we could instead form another pair with even sum.Time Complexity: O(n) Code\n#include < bits/stdc++.h >\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define int long long\n\nconst int N = 2e5 + 5;\n\nint n;\nint a[N];\n\nint32_t main()\n{\n\tIOS;\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tcin >> n;\n\t\tvector< int > even, odd;\n\t\tfor(int i = 1; i <= 2 * n; i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tif(a[i] % 2)\n\t\t\t\todd.push_back(i);\n\t\t\telse\n\t\t\t\teven.push_back(i);\n\t\t}\n\t\tvector< pair< int, int > > ans;\n\t\tfor(int i = 0; i + 1 < odd.size(); i += 2)\n\t\t\tans.push_back({odd[i], odd[i + 1]});\n\t\tfor(int i = 0; i + 1 < even.size(); i += 2)\n\t\t\tans.push_back({even[i], even[i + 1]});\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n\treturn 0;\n}This problem was prepared by Ashishgup and ridbit10"
}