{
    "solution": "1610B - Kalindrome ArrayIf the array is already a palindrome the answer is Yes. Otherwise, let's find the minimum i that ai≠an+1−i.We can prove that we have to remove either ai or an+1−i in order the make the array palindrome.Imagine it's possible to make the array palindrome by removing all appearances of x. x≠ai,an+1−iThe number of appearances of x before i is equal to the number of appearances of x after n+1−i. So in order to make the array palindrome, ai must be equal to an+1−i.So we just have to check if the array will be palindrome after removing all appearances of ai or after removing all appearances of an+1−i.Time complexity: O(n) Implementation//khodaya khodet komak kon\n# include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define lc                                              id << 1\n# define rc                                              id << 1 | 1\n# define fast_io                                         ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 2e5 + 10;\nconst int xm = - 20 + 10;\nconst int sq = 320;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst ld eps = 1e-15;\nconst int mod = 998244353;\nconst int base = 257;\n \nint qq, n, m, a[xn], b[xn];\nbool ans;\n \nvoid check(int x){\n\tm = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (a[i] != x)\n\t\t\tb[++ m] = a[i];\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (b[i] != b[m + 1 - i])\n\t\t\treturn;\n\tans = true;\n}\n \nint main(){\n\tfast_io;\n \n\tcin >> qq;\n\twhile (qq --){\n\t\tcin >> n, ans = true;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tcin >> a[i];\n\t\tfor (int i = 1; i <= n; ++ i){\n\t\t\tif (a[i] != a[n + 1 - i]){\n\t\t\t\tans = false;\n\t\t\t\tcheck(a[i]);\n\t\t\t\tcheck(a[n + 1 - i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n \n\treturn 0;\n}\n"
}