{
    "solution": "1006C - Three Parts of the ArraySince the given array consists of positive integers, for each value of a, there can be at most one value of c such that sum1=sum3. We can use binary search on the array of prefix sums of d to find the correct value of c, given that it exists. If it does exist and a+c≤n, this is a candidate solution so we store it. Alternatively, we can use the two pointers trick – when a increases, c cannot decrease. Be careful to use 64 bit integers to store sums.Overall complexity is O(nlogn) or O(n).  Solution (Vovuh, set)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\t\n\tset<long long> sum;\n\tlong long l = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tl += a[i];\n\t\tsum.insert(l);\n\t}\n\t\n\tlong long ans = 0;\n\tlong long r = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tsum.erase(l);\n\t\tl -= a[i];\n\t\tr += a[i];\n\t\tif (sum.count(r))\n\t\t\tans = max(ans, r);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n} Solution (ivan100sic, two pointers)#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nint n;\nint a[200005];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\n\tint i = 0, j = n+1;\n\tll zi = 0, zj = 0, solidx = 0;\n\twhile (i < j) {\n\t\tif (zi < zj)\n\t\t\tzi += a[++i];\n\t\telse if (zi > zj)\n\t\t\tzj += a[--j];\n\t\telse {\n\t\t\tsolidx = i;\n\t\t\tzi += a[++i];\n\t\t\tzj += a[--j];\n\t\t}\n\t}\n\t\n\tcout << accumulate(a+1, a+solidx+1, 0ll); // here\n}"
}