{
    "solution": "1333B - Kind AntonFirst of all, note that we can add an element with index i to an element with index j iff i<j. This means that the element an cannot be added to any other element because there is no index j>n in the array. This is why we can first equalize the elements an and bn. If an=bn, they are already equal. If an<bn, then we need to have element equal to 1 along the elements a with indexes {1,...,n−1}. For an>bn, we need to have −1 along these elements. After the elements with index n become equal, we can go to the element with index n−1 and do the same. Then indexes n−2, n−3, ..., 1. You can implement this idea yourself!Final time complexity: O(n) Solution C++#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n    vector<int> good(2, 0);\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > b[i] && !good[0]) {\n            cout << \"NO\\n\";\n            return;\n        } else if (a[i] < b[i] && !good[1]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        if (a[i] == -1) good[0] = 1;\n        if (a[i] == 1) good[1] = 1;\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    int t; cin >> t;\n    while(t--) {\n        solve();\n    }\n} "
}