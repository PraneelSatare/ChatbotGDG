{
    "solution": "2029B - ReplacementAuthor: wyrqwqFirst Blood: Benq at 00:02:30 Hint(01 or 10 exists) ‚ü∫ (both 0 and 1 exist). SolutionEach time we do an operation, if s consists only of 0 or 1, we surely cannot find any valid indices. Otherwise, we can always perform the operation successfully. In the i-th operation, if ti=0, we actually decrease the number of 1-s by 1, and vice versa. Thus, we only need to maintain the number of 0-s and 1-s in s. If any of them falls to 0 before the last operation, the answer is NO, otherwise, the answer is YES.Time complexity: O(n) per test case. Code (C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\nusing ll = long long;\n\nconst int _N = 1e5 + 5;\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s, t; cin >> s >> t;\n\tint cnt0 = count(all(s), '0'), cnt1 = n - cnt0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (cnt0 == 0 || cnt1 == 0) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tif (t[i] == '1') cnt0--;\n\t\telse cnt1--;\n\t}\n\tcout << \"YES\" << '\\n';\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Python 3)for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    one = s.count(\"1\")\n    zero = s.count(\"0\")\n    ans = \"YES\"\n    for ti in input():\n        if one == 0 or zero == 0:\n            ans = \"NO\"\n            break\n        one -= 1\n        zero -= 1\n        if ti == \"1\":\n            one += 1\n        else:\n            zero += 1\n    print(ans) Rate the Problem Amazing problem: \n\n    \n\n\n64\n\n\n\n Good problem: \n\n    \n\n\n214\n\n\n\n Average problem: \n\n    \n\n\n26\n\n\n\n Bad problem: \n\n    \n\n\n46\n\n\n\n Didn't solve: \n\n    \n\n\n21\n\n\n\n "
}