{
    "solution": "1957B - A BIT of a ConstructionThe case n=1 needs to be handled separately, as we can only output k itself.For n>1, we make the following observations. Let x be the position of the most significant bit in k, that is 2x≤k<2x+1. From this, we learn that the bitwise OR of the sequence cannot have more than x+1 set bits because that would make the sum greater than 2x+1.Now, having x+1 bits set in the bitwise OR of the sequence is only possible if k=2x+1−1 (or k=111…12). Any k less than this cannot have x+1 bits set in the bitwise OR of the sequence, as otherwise the sum would exceed k. However, we can always set x bits, as we can always have one number in the sequence as 2x−1 (which has exactly x bits set). Using these observations, we get our solution as 2x−1,k−(2x−1),0,0,0,…,0. This ensures that we have at least x bits set in the bitwise OR, and additionally also handles the case where x+1 bits can be set, while maintaining the sum. Rate this problem \n\n\n\n303\n\n\n\n\n\n Great Problem \n\n\n\n251\n\n\n\n\n\n Ok Problem \n\n\n\n54\n\n\n\n\n\n Bad Problem \n\n\n\n57\n\n\n\n\n\n Didn't solve  C++ Code#include <bits/stdc++.h>\n\nusing namespace std;\n \nint main(){\n    int t; \n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        if (n == 1) {\n            a[0] = k;\n        }\n        else {\n            int msb = 0;\n            // find the msb of k\n            for (int i = 0; i < 31; i++) {\n                if (k & (1 << i)) {\n                    msb = i;\n                }\n            }\n            a[0] = (1 << msb) - 1;\n            a[1] = k - a[0];\n            for (int i = 2; i < n; i++) {\n                a[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cout << a[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}"
}