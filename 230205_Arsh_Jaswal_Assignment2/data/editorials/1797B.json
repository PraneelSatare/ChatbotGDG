{
    "solution": "1797B - Li Hua and PatternWe can calculate the minimum needed operations kmin easily by enumerating through the cells and performing an operation if the color of the cell is different from the targeted cell. Obviously, if k<kmin, the problem has no solution.Otherwise, there are two cases:  If 2∣n, the solution exists if and only if 2∣(k−kmin), as we must perform two operations each time to meet the requirement.  If 2∤n, the solution always exists, as we can perform the remaining operations at the center of the pattern. Time complexity: O(n2). Solution (rui_er)//By: OIer rui_er\n#include <bits/stdc++.h>\n#define rep(x,y,z) for(int x=(y);x<=(z);x++)\n#define per(x,y,z) for(int x=(y);x>=(z);x--)\n#define debug(format...) fprintf(stderr, format)\n#define fileIO(s) do{freopen(s\".in\",\"r\",stdin);freopen(s\".out\",\"w\",stdout);}while(false)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e3+5;\n \nint T, n, k, a[N][N];\ntemplate<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}\ntemplate<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}\n \nint main() {\n\tfor(scanf(\"%d\", &T);T;T--) {\n\t\tscanf(\"%d%d\", &n, &k);\n\t\trep(i, 1, n) rep(j, 1, n) scanf(\"%d\", &a[i][j]);\n\t\tint diff = 0;\n\t\trep(i, 1, n) rep(j, 1, n) if(a[i][j] != a[n+1-i][n+1-j]) ++diff;\n\t\tdiff /= 2;\n\t\tif(diff > k) puts(\"NO\");\n\t\telse {\n\t\t\tk -= diff;\n\t\t\tif(n & 1) puts(\"YES\");\n\t\t\telse if(k & 1) puts(\"NO\");\n\t\t\telse puts(\"YES\");\n\t\t}\n\t}\n\treturn 0;\n}"
}