{
    "solution": "1328C - Ternary XORLet's iterate from left to right over the digits of x. If the current digit is either 0 or 2 then we can set ai=bi=0 or ai=bi=1 correspondingly. There are no better choices. And if the current digit xi is 1 then the optimal choise is to set ai=1 and bi=0. What happens after the first occurrence of 1? Because of this choice a is greater than b even if all remaining digits in b are 2. So for each j>i set aj=0 and bj=xj and print the answer. The case without 1 is even easier and in fact we handle it automatically. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring x;\n\t\tcin >> n >> x;\n\t\tstring a(n, '0'), b(n, '0');\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (x[i] == '1') {\n\t\t\t\ta[i] = '1';\n\t\t\t\tb[i] = '0';\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tb[j] = x[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ta[i] = b[i] = '0' + (x[i] - '0') / 2;\n\t\t\t}\n\t\t}\n\t\tcout << a << endl << b << endl;\n\t}\n\t\n\treturn 0;\n}"
}