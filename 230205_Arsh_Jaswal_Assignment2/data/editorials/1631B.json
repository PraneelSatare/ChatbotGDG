{
    "solution": "1631B - Fun with Even SubarraysAuthor: humbertoyusta Hint 1It is not possible to modify an using the given operation. Hint 2Think about the leftmost x such that ax≠an. SolutionFor simplicity, let b1,b2,...,bn=an,an−1,...,a1 (let b be a reversed). The operation transforms to select a subarray [l,r] of length 2⋅k, so k=r−l+12, then for all i such that 0≤i<k, set bl+k+i=bl+i.b1 can not be changed with the given operation. That reduces the problem to make all elements equal to b1.Let x be the rightmost index such that for all 1≤i≤x, bi=b1 holds.The problem will be solved when x=n.If an operation is applied with l+k>x+1, bx+1 will not change and x will remain the same.The largest range with l+k≤x+1 is [1,2⋅x], applying an operation to it will lead to bx+1,bx+2,...,b2⋅x=b1,b2,...,bx, so x will become at least 2⋅x and there is not any other range that will lead to a bigger value of x.If 2⋅x>n, it is possible to apply the operation on [x−(n−x)+1,n], after applying it bx+1,...,bn=bx−(n−x)+1,...,bx and all elements will become equal.The problem can now be solved by repeatedly finding x and applying the operation on [1,2⋅x] or on [x−(n−x)+1,n] if 2⋅x>n. Since x will become at least 2⋅x in each operation but the last one, the naive implementation will take O(nlogn), however, it is easy to implement it in O(n). Code O(nlogn)#include<bits/stdc++.h>\nusing namespace std;\n\nint find_rightmost_x(vector<int> &b){\n    int n = (int)b.size() - 1;\n\n    int x = 1;\n    while( x + 1 <= n && b[x+1] == b[1] )\n        x ++;\n\n    return x;\n}\n\nvoid apply(vector<int> &b,int l,int r){\n    int k = ( r - l + 1 ) / 2;\n    for(int i=0; i<k; i++)\n        b[l+k+i] = b[l+i];\n}\n\nint main(){\n\n    int tc;\n    cin >> tc;\n    while( tc-- ){\n\n        int n;\n        cin >> n;\n\n        vector<int> a(n+1);\n        for(int i=1; i<=n; i++)\n            cin >> a[i];\n\n        vector<int> b = a;\n        reverse(b.begin()+1,b.end());\n\n        int ans = 0;\n        while( find_rightmost_x(b) != n ){\n            int x = find_rightmost_x(b);\n            if( 2 * x > n ){\n                apply(b,x-(n-x)+1,n);\n                ans ++;\n            }\n            else{\n                apply(b,1,2*x);\n                ans ++;\n            }\n        }\n        cout << ans << '\\n';\n    }\n\n\n    return 0;\n} Code O(n)#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int tc;\n    cin >> tc;\n    while(tc--)\n    {\n        int n;\n        cin >> n;\n\n        vector<int> a(n+1);\n        for(int i=1; i<=n; i++)\n            cin >> a[i];\n\n        vector<int> b = a;\n        reverse(b.begin()+1,b.end());\n\n        int ans = 0, x = 1;\n\n        while( x < n )\n        {\n            if( b[x+1] == b[1] ){\n                x ++;\n                continue;\n            }\n            ans ++;\n            x *= 2;\n        }\n\n        cout << ans << '\\n';\n    }\n\n    return 0;\n}"
}