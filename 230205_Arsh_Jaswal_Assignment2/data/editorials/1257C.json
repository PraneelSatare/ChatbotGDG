{
    "solution": "1257C - Dominated SubarrayAt first, let's prove that the shortest dominated subarray has pattern like v,c1,c2,…,ck,v with k≥0 and dominated by value v. Otherwise, we can decrease its length by erasing an element from one of its ends which isn't equal to v and it'd still be dominated.Now we should go over all pairs of the same numbers and check its subarrays... Or not? Let's look closely at the pattern: if v and all ci are pairwise distinct then the pattern is dominated subarray itself. Otherwise, we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on.What does it mean? It means that the answer is just the shortest pattern we can find. And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number. We can do it by iterating over current position i and keeping track of the last occurrence of each number in some array lst[v]. Then the current distance is i−lst[a[i]]+1.The total complexity is O(n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define sz(a) int((a).size())\n\nint n;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\treturn true;\n}\n\ninline void solve() {\n\tint ans = n + 5;\n\tvector<int> lst(n + 1, -1);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(lst[a[i]] != -1)\n\t\t\tans = min(ans, i - lst[a[i]] + 1);\n\t\tlst[a[i]] = i;\n\t}\n\tif(ans > n)\n\t\tans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}"
}