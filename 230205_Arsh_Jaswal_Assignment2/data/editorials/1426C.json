{
    "solution": "1426C - Increase and CopyIt is pretty intuitive that we firstly need to do all increments and only then copy numbers (because otherwise we can swap the order of moves and the sum will not decrease). You could notice that the answer does not exceed O(n−−√) so we can just iterate from 1 to ⌊n−−√⌋ and fix the number we will copy. Let it be x. Then we need x−1 moves to obtain it and also need ⌈n−xx⌉ moves to get the enough number of copies. So, we can update the answer with this number of moves.Time complexity: O(n−−√) per test case.Actually, the required number is always pretty near to ⌊n−−√⌋ so it is enough to try a few options in range [⌊n−−√⌋−5;⌊n−−√⌋+5] to get the optimal answer. This is O(1) solution. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tint ans = 1e9;\n\t\tfor (int x = 1; x * x <= n; ++x) {\n\t\t\tans = min(ans, x - 1 + ((n - x) + x - 1) / x);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n Solution 2#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long double EPS = 1e-9;\n\nlong long f(long long x)\n{                                                        \n\tlong long z = sqrtl(x);\n\tlong long ans = 1e18;\n\tfor(int i = -5; i <= 5; i++)\n\t{\n\t \tlong long z2 = z - i;\n\t \tif(z2 > x || z2 < 1)\n\t \t\tcontinue;\n\t \tans = min(ans, z2 - 2 + (x + z2 - 1) / z2);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n \tint t;\n \tcin >> t;\n \tfor(int i = 0; i < t; i++)\n \t{\n \t \tlong long x;\n \t \tcin >> x;\n \t \tcout << f(x) << endl;\n \t}\n}"
}