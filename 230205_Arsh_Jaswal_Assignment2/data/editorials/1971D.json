{
    "solution": "1971D - Binary CutFirst, note that it's always optimal to divide the string into \"blocks\" of equal values; there is no use having two strings 111|11 when we can just have 11111 and use fewer pieces.Now note that to sort the string, we need all blocks of 0 to come before all blocks of 1. The only way that two blocks can join is if we have a block of 0s before a block of 1s, and we can have at most one such block. That is, all strings look like: (blocks of 0s)0...1≤1joined block of 0s and 1s(blocks of 1s)So the answer is the number of blocks, but we should subtract 1 if a substring 01 exists (because then we can make the center block above). The time complexity is O(|s|).For example, for the string 111000110, we can use three pieces: 111|00011|0→0|00011|111. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint res = 1;\n\tbool ex = false;\n\tfor (int i = 0; i + 1 < (int)(s.size()); i++) {\n\t\tres += (s[i] != s[i + 1]);\n\t\tex |= (s[i] == '0' && s[i + 1] == '1');\n\t}\n\tcout << res - ex << '\\n';\n}\n \nint main() {\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n"
}