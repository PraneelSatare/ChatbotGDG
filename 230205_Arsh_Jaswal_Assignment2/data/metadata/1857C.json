{
    "title": "C. Assembly via Minimums",
    "description": "Sasha has an array a of n integers. He got bored and for all i, j (i<j), he wrote down the minimum value of ai and aj. He obtained a new array b of size n⋅(n−1)2.\nFor example, if a= [2,3,5,1], he would write [min(2,3),min(2,5),min(2,1),min(3,5),min(3,1),min(5,1)] = [2,2,1,3,1,1].\nThen, he randomly shuffled all the elements of the array b.\nUnfortunately, he forgot the array a, and your task is to restore any possible array a from which the array b could have been obtained.\nThe elements of array a should be in the range [−109,109].\nThe first line contains a single integer t (1≤t≤200) — the number of test cases.\nThe first line of each test case contains a single integer n (2≤n≤103) — the length of array a.\nThe second line of each test case contains n⋅(n−1)2 integers b1,b2,…,bn⋅(n−1)2 (−109≤bi≤109) — the elements of array b.\nIt is guaranteed that the sum of n over all tests does not exceed 103 and for each array b in the test, there exists an original array.\nFor each test case, output any possible array a of length n.\nIn the first sample, Sasha chose the array [1,3,3], then the array b will look like [min(a1,a2)=1,min(a1,a3)=1,min(a2,a3)=3], after shuffling its elements, the array can look like [1,3,1].\nIn the second sample, there is only one pair, so the array [10,10] is suitable. Another suitable array could be [15,10].",
    "time limit": "time limit per test2 seconds",
    "memory limit": "memory limit per test256 megabytes",
    "tags": [
        "greedy",
        "sortings",
        "*1200"
    ]
}