{
    "265B": {
        "title": "B. Roadside Trees (Simplified Edition)",
        "description": "Squirrel Liss loves nuts. There are n trees (numbered 1 to n from west to east) along a street and there is a delicious nut on the top of each tree. The height of the tree i is hi. Liss wants to eat all nuts.\nNow Liss is on the root of the tree with the number 1. In one second Liss can perform one of the following actions:\nCompute the minimal time (in seconds) required to eat all nuts.\nThe first line contains an integer n (1\u2009\u2009\u2264\u2009\u2009n\u2009\u2264\u2009105) \u2014 the number of trees.\nNext n lines contains the height of trees: i-th line contains an integer hi (1\u2009\u2264\u2009hi\u2009\u2264\u2009104) \u2014 the height of the tree with the number i.\nPrint a single integer \u2014 the minimal time required to eat all nuts in seconds.",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "482A": {
        "title": "A. Diverse Permutation",
        "description": "Permutation p is an ordered set of integers p1,\u2009\u2009\u2009p2,\u2009\u2009\u2009...,\u2009\u2009\u2009pn, consisting of n distinct positive integers not larger than n. We'll denote as n the length of permutation p1,\u2009\u2009\u2009p2,\u2009\u2009\u2009...,\u2009\u2009\u2009pn.\nYour task is to find such permutation p of length n, that the group of numbers |p1\u2009-\u2009p2|,\u2009|p2\u2009-\u2009p3|,\u2009...,\u2009|pn\u2009-\u20091\u2009-\u2009pn| has exactly k distinct elements.\nThe single line of the input contains two space-separated positive integers n, k (1\u2009\u2264\u2009k\u2009<\u2009n\u2009\u2264\u2009105).\nPrint n integers forming the permutation. If there are multiple answers, print any of them.\nBy |x| we denote the absolute value of number x. ",
        "memory limits": "memory limit per test256 megabytes",
        "time limits": "time limit per test1 second",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "482A - Diverse PermutationProblem author gridnevvvitLet's see, what's the solution for some k\u2009=\u2009n\u2009-\u20091:1 10 2 9 3 8 4 7 5 6At the odd indexes we placed increasing sequence 1, 2, 3 .., at the even \u2014 decreasing sequence n,\u2009n\u2009-\u20091,\u2009n\u2009-\u20092,\u2009... First, we must get the permutation the way described above, then get first k numbers from it, and then we should make all other distances be equal to 1.This solution works with O(n).Jury's solution: 8394876483D - Interesting Array / "
    },
    "265A": {
        "title": "A. Colorful Stones (Simplified Edition)",
        "description": "There is a sequence of colorful stones. The color of each stone is one of red, green, or blue. You are given a string s. The i-th (1-based) character of s represents the color of the i-th stone. If the character is \"R\", \"G\", or \"B\", the color of the corresponding stone is red, green, or blue, respectively.\nInitially Squirrel Liss is standing on the first stone. You perform instructions one or more times.\nEach instruction is one of the three types: \"RED\", \"GREEN\", or \"BLUE\". After an instruction c, if Liss is standing on a stone whose colors is c, Liss will move one stone forward, else she will not move.\nYou are given a string t. The number of instructions is equal to the length of t, and the i-th character of t represents the i-th instruction.\nCalculate the final position of Liss (the number of the stone she is going to stand on in the end) after performing all the instructions, and print its 1-based position. It is guaranteed that Liss don't move out of the sequence.\nThe input contains two lines. The first line contains the string s (1\u2009\u2264\u2009|s|\u2009\u2264\u200950). The second line contains the string t (1\u2009\u2264\u2009|t|\u2009\u2264\u200950). The characters of each string will be one of \"R\", \"G\", or \"B\". It is guaranteed that Liss don't move out of the sequence.\nPrint the final 1-based position of Liss in a single line.",
        "tags": [
            "implementation",
            "*800"
        ],
        "solutions": "In this problem you just need to implement what is written in the statement. Make a variable that holds the position of Liss, and simulate the instructions one by one."
    },
    "2050C": {
        "title": "C. Uninteresting Number",
        "description": "You are given a number n with a length of no more than 105.\nYou can perform the following operation any number of times: choose one of its digits, square it, and replace the original digit with the result. The result must be a digit (that is, if you choose the digit x, then the value of x2 must be less than 10).\nIs it possible to obtain a number that is divisible by 9 through these operations?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains the number n, without leading zeros. The length of the number does not exceed 105.\nIt is guaranteed that the sum of the lengths of the numbers across all test cases does not exceed 105.\nFor each test case, output \"YES\" if it is possible to obtain a number divisible by 9 using the described operations, and \"NO\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first example, from the integer 123, it is possible to obtain only 123, 143, 129, and 149, none of which are divisible by 9.\nIn the second example, you need to replace the second digit with its square; then n will equal 342=38\u22c59.\nIn the third example, the integer is already divisible by 9.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "math",
            "*1200"
        ],
        "solutions": "2050C - Uninteresting NumberThe requirement that a digit must remain a digit imposes the following restrictions on transformations: we can transform 0 into 0, 1 into 1, 2 into 4, and 3 into 9. Any other digit squared will exceed 9, therefore, it cannot be transformed. Transformations involving 0 and 1 are useless, leaving us with two possible actions: squaring the digit 2 or the digit 3.We will use the divisibility rule for 9. It states that a number is divisible by 9 if and only if the sum of its digits is divisible by 9. Let's see how the sum of the digits will change with the possible transformations. If we square 2, the sum of the digits increases by 22\u22122=2, and if we square 3, the sum of the digits increases by 32\u22123=6.We will count the number of digits 2 in the number and the number of digits 3 in the number. We can choose how many of the available digits 2 and 3 we will transform. Transforming more than 8 twos and more than 8 threes is pointless because remainders modulo 9 their transformation adds to the sum will repeat.Thus, the final solution looks like this: we calculate the sum of the digits in the number, count the number of digits 2 and 3. We will iterate over how many digits 2 we change (possibly 0, but no more than 8), and how many digits 3 we change (possibly 0, but also no more than 8). Let's say we changed x digits 2 and y digits 3, then the sum of the digits in the number increased by x\u22172+y\u22176. If new sum is divisible by 9, the answer is \"YES\". If such a situation was never reached during the iteration, then the answer is \"NO\". \u041a\u043e\u0434def solve():\n    s = [int(x) for x in list(input())]\n\n    sm = sum(s)\n    twos = s.count(2)\n    threes = s.count(3)\n\n    for i in range(min(10, twos + 1)):\n        for j in range(min(10, threes + 1)):\n            if (sm + i * 2 + j * 6) % 9 == 0:\n                print('YES')\n                return\n    print('NO')\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "2050B": {
        "title": "B. Transfusion",
        "description": "You are given an array a of length n. In one operation, you can pick an index i from 2 to n\u22121 inclusive, and do one of the following actions:\n \nAfter each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?\nFirst line of input consists of one integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nFirst line of each test case consists of one integer n (3\u2264n\u22642\u22c5105).\nSecond line of each test case consists of n integers ai (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n of all test cases doesn't exceed 2\u22c5105.\nFor each test case, print \"YES\" without quotation marks if it is possible to make all the elements equal after any number of operations; otherwise, print \"NO\" without quotation marks.\nYou can print answers in any register: \"yes\", \"YeS\", \"nO\" \u00a0\u2014 will also be considered correct.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "2050B - TransfusionThe main idea of this problem is that these operations only change elements on the positions with the same parity. So, we can solve for elements on odd and even positions independently.Let's make two arrays $$$od$$$ and $$$ev$$$ \u00a0\u2014 the first one will consist of all the elements on the odd positions, and the second one will consist of all the elements on the even positions. Now we can rewrite given operations as: pick any array $$$od$$$ or $$$ev$$$, after that pick any two adjacent elements and subtract $$$1$$$ from one of these elements and add $$$1$$$ to another. In order to make all the elements in array $$$od$$$ equal, the sum of all elements in $$$od$$$ must be divisible by $$$|od|$$$, and also the sum of all the elements in $$$ev$$$ must be divisible by $$$|ev|$$$, where $$$|a|$$$ is the length of array $$$a$$$. And also to make all the elements of the initial array equal, $$$\\frac{sum(od)}{|od|} = \\frac{sum(ev)}{|ev|}$$$ must be satisfied. If all these conditions are satisfied, the answer is \"YES\", otherwise \"NO\". \u041a\u043e\u0434#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for (int &x : a) cin >> x;\n    \n    long long ods = 0, evs = 0;\n    for (int i = 0; i < n; i++) {\n        if (i & 1) ods += a[i];\n        else evs += a[i];\n    }\n    int odc = n / 2, evc = n / 2;\n    if (n & 1) evc++;\n\n    if (ods % odc != 0 || evs % evc != 0 || ods / odc != evs / evc) {\n        cout << \"NO\";\n        return;\n    }\n    cout << \"YES\";\n}\n\nint main() {\n    int TESTS; cin >> TESTS;\n    while (TESTS --> 0) {\n        solve();\n        cout << '\\n';\n    }\n    return 0;\n}"
    },
    "2048C": {
        "title": "C. Kevin and Binary Strings",
        "description": "Kevin discovered a binary string s that starts with 1 in the river at Moonlit River Park and handed it over to you. Your task is to select two non-empty substrings\u2217 of s (which can be overlapped) to maximize the XOR value of these two substrings.\nThe XOR of two binary strings a and b is defined as the result of the \u2295 operation applied to the two numbers obtained by interpreting a and b as binary numbers, with the leftmost bit representing the highest value. Here, \u2295 denotes the bitwise XOR operation.\nThe strings you choose may have leading zeros.\n\u2217A string a is a substring of a string b if a can be obtained from b by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end. \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264103).\nThe only line of each test case contains a binary string s that starts with 1 (1\u2264|s|\u22645000).\nIt is guaranteed that the sum of |s| over all test cases doesn't exceed 5000.\nFor each test case, output four integers l1,r1,l2,r2 (1\u2264l1\u2264r1\u2264|s|, 1\u2264l2\u2264r2\u2264|s|)\u00a0\u2014 in the case the two substrings you selected are sl1sl1+1\u2026sr1 and sl2sl2+1\u2026sr2.\nIf there are multiple solutions, print any of them.\nIn the first test case, we can choose s2=1 and s1s2s3=111, and 1\u2295111=110. It can be proven that it is impossible to obtain a larger result. Additionally, l1=3, r1=3, l2=1, r2=3 is also a valid solution.\nIn the second test case, s1s2s3=100, s1s2s3s4=1000, the result is 100\u22951000=1100, which is the maximum.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "2048C - Kevin and Binary StringsTo maximize the XOR sum of the two substrings, we aim to maximize the number of binary digits in the XOR result. To achieve this, the substring [1,n] must always be selected. Suppose the first character of the other substring is 1. If it is not 1, we can remove all leading zeros.Next, find the position of the first 0 in the string from left to right. We want this position to be flipped to 1, while ensuring that the 1s earlier in the string are not changed to 0s. Therefore, let the position of the first 0 be p. The length of the other substring must be n\u2212p+1. By enumerating the starting position of the other substring and calculating the XOR sum of the two substrings linearly, we can take the maximum value. The time complexity of this approach is O(n2).If the entire string consists only of 1s, selecting [1,n] and [1,1] can be proven to yield the maximum XOR sum among all possible choices.Interesting fact: This problem can actually be solved in O(n) time complexity. Specifically, observe that the other substring needs to satisfy the following conditions: its length is n\u2212p+1, and its first character is 1. Thus, its starting position must be less than p. This implies that the length of the prefix of 1s in the other substring can be chosen from the range [1,p\u22121]. We aim to flip the first segment of 0 s in the original string to 1 s, while ensuring that the 1 immediately after this segment of 0 s remains unchanged. Let the length of the first segment of 0 s be q. Then, the length of the prefix of 1 s in the other substring must be min(p\u22121,q), and the starting position can be determined efficiently.When preparing the contest and selecting problems, we determined that the O(n) solution would be too difficult for a Problem C. Therefore, the problem was designed with an O(n2) data range to make it more accessible."
    },
    "2046A": {
        "title": "A. Swap Columns and Find a Path",
        "description": " \nThere is a matrix consisting of 2 rows and n columns. The rows are numbered from 1 to 2 from top to bottom; the columns are numbered from 1 to n from left to right. Let's denote the cell on the intersection of the i-th row and the j-th column as (i,j). Each cell contains an integer; initially, the integer in the cell (i,j) is ai,j.\nYou can perform the following operation any number of times (possibly zero):\nAfter performing the operations, you have to choose a path from the cell (1,1) to the cell (2,n). For every cell (i,j) in the path except for the last, the next cell should be either (i+1,j) or (i,j+1). Obviously, the path cannot go outside the matrix.\nThe cost of the path is the sum of all integers in all (n+1) cells belonging to the path. You have to perform the operations and choose a path so that its cost is maximum possible.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22645000). The description of the test cases follows. \nEach test case consists of three lines:\nIt is guaranteed that the sum of n over all test cases does not exceed 5000. \nFor each test case, print one integer \u2014 the maximum cost of a path you can obtain.\nHere are the explanations of the first three test cases of the example. The left matrix is the matrix given in the input, the right one is the state of the matrix after several column swaps (possibly zero). The optimal path is highlighted in green.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "2044D": {
        "title": "D. Harder Problem",
        "description": "Given a sequence of positive integers, a positive integer is called a mode of the sequence if it occurs the maximum number of times that any positive integer occurs. For example, the mode of [2,2,3] is 2. Any of 9, 8, or 7 can be considered to be a mode of the sequence [9,9,8,8,7,7]. \nYou gave UFO an array a of length n. To thank you, UFO decides to construct another array b of length n such that ai is a mode of the sequence [b1,b2,\u2026,bi] for all 1\u2264i\u2264n. \nHowever, UFO doesn't know how to construct array b, so you must help her. Note that 1\u2264bi\u2264n must hold for your array for all 1\u2264i\u2264n.\nThe first line contains t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of a.\nThe following line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n numbers b1,b2,\u2026,bn (1\u2264bi\u2264n) on a new line. It can be shown that b can always be constructed. If there are multiple possible arrays, you may print any.\nLet's verify the correctness for our sample output in test case 2.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "2044D - Harder ProblemProblem Credits: cry, vgoofficial  Analysis: macaquedev Solution Observe that if you have an array where all elements are unique, they will all have frequency 1, therefore they can all be classified as the mode. Therefore, it follows that the strategy for the construction is to just construct an array where for each prefix, the last element of this prefix appears in the array at least once. An easy way of doing is this is such:For each element ai, if this value has appeared previously in the array (you can use a set to check this), set bi equal to some random integer that isn't used elsewhere in the list a, and keep going. Otherwise, set bi=ai. Code (C++)#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt;\n    cin>>tt;\n    while(tt--)\n    {\n        int n;\n        cin>>n;\n        vector<int> a(n+1),b(n);\n        for(int i=0;i<n;i++)\n        {\n            int x;\n            cin>>x;\n            if(!a[x])\n            {\n                b[i]=x;\n                a[x]=1;\n            }\n        }\n        queue<int> q;\n        for(int i=1;i<=n;i++)\n            if(!a[i])\n                q.push(i);\n        for(int i=0;i<n;i++)\n        {\n            if(!b[i])\n            {\n                b[i]=q.front();\n                q.pop();\n            }\n        }\n        for(int i=0;i<n;i++)\n            cout<<b[i]<<\" \\n\"[i==n-1];\n    }\n    return 0;\n}"
    },
    "2041E": {
        "title": "E. Beautiful Array",
        "description": "A-Ming's birthday is coming and his friend A-May decided to give him an integer array as a present. A-Ming has two favorite numbers a and b, and he thinks an array is beautiful if its mean is exactly a and its median is exactly b. Please help A-May find a beautiful array so her gift can impress A-Ming.\nThe mean of an array is its sum divided by its length. For example, the mean of array [3,\u22121,5,5] is 12\u00f74=3.\nThe median of an array is its middle element after sorting if its length is odd, or the mean of two middle elements after sorting if its length is even. For example, the median of [1,1,2,4,8] is 2 and the median of [3,\u22121,5,5] is (3+5)\u00f72=4.\nNote that the mean and median are not rounded to an integer. For example, the mean of array [1,2] is 1.5.\nThe only line contains two integers a and b.\nIn the first line, print the length of the array.\nIn the second line, print the elements of the array.\nIf there are multiple solutions, you can print any. It can be proved that, under the constraints of the problem, a solution always exists.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test1024 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "2041B": {
        "title": "B. Bowling Frame",
        "description": "Bowling is a national sport in Taiwan; everyone in the country plays the sport on a daily basis since their youth. Naturally, there are a lot of bowling alleys all over the country, and the competition between them is as intense as you can imagine.\nMaw-Shang owns one such bowling alley. To stand out from other competitors in the industry and draw attention from customers, he decided to hold a special event every month that features various unorthodox bowling rules. For the event this month, he came up with a new version of the game called X-pin bowling. In the traditional 10-pin bowling game, a frame is built out of ten bowling pins forming a triangular shape of side length four. The pin closest to the player forms the first row, and the two pins behind it form the second row, and so on. Unlike the standard version, the game of X-pin bowling Maw-Shang designed allows a much larger number of pins that form a larger frame. The following figure shows a standard 10-pin frame on the left, and on the right it shows a 21-pin frame that forms a triangular shape of side length six which is allowed in the game of X-pin bowling.\nBeing the national sport, the government of Taiwan strictly regulates and standardizes the manufacturing of bowling pins. There are two types of bowling pins allowed, one in black and the other in white, and the bowling alley Maw-Shang owns has w white pins and b black pins. To make this new game exciting for the customers, Maw-Shang wants to build the largest possible frame from these w+b pins. However, even though he is okay with using both colors in building the frame, for aesthetic reasons, Maw-Shang still wants the colors of the pins on the same row to be identical. For example, the following figure shows two possible frames of side length six, but only the left one is acceptable to Maw-Shang since the other one has white and black pins mixed in the third row.\nThe monthly special event is happening in just a few hours. Please help Maw-Shang calculate the side length of the largest frame that he can build from his w+b pins!\nThe first line of the input contains a single integer t, the number of test cases. Each of the following t lines contains two integers w and b, the number of white and black pins, respectively.\nFor each test case, output in a single line the side length k of the largest pin satisfying Maw-Shang's requirement you can build with the given pins.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test1024 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "2040B": {
        "title": "B. Paint a Strip",
        "description": "You have an array of zeros a1,a2,\u2026,an of length n.\nYou can perform two types of operations on it: \nWhat is the minimum number of operations of the first type needed to make all elements of the array equal to one?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nNote that there is no limit on the sum of n over all test cases.\nFor each test case, print one integer\u00a0\u2014 the minimum number of needed operations of first type.\nIn the first test case, you can perform an operation of the 1st type with i=1.\nIn the second test case, you can perform the following sequence of operations:\nIn the third test case, you can perform the following sequence of operations:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "2040B]At each moment of time, the array contains a number of non-intersecting segments consisting only of ones. Using an operation of the first type can increase the number of these segments by 1. Using an operation of the second type decreases the number of these segments by x\u22121, where x\u00a0\u2014 is the number of segments that this operation covers. Therefore, the number of operations of the second type is no more than the number of operations of the first type minus 1.The optimal strategy\u00a0\u2014 is to perform one operation of the first type, and then alternate operations of the first and second types, increasing the number of ones from x to 2\u22c5(x+1) on each such pair of operations. There is no point in doing more operations of the first type on the prefix of operations, since we still must cover no more than two segments of ones with operations of the second type; otherwise, we will reduce the possible number of operations of the second type. Solution C++#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n;\n        cin >> n;\n        for (int ans = 1, cur = 1; ; ans++, cur = cur * 2 + 2) {\n            if (cur >= n) {\n                cout << ans << '\\n';\n                break;\n            }\n        }\n    }\n    \n    return 0;\n} Solution Pythontt = int(input())\nfor _ in range(tt):\n    n = int(input())\n    ans = 1\n    cur = 1\n    while True:\n        if cur >= n:\n            print(ans)\n            break\n        ans += 1\n        cur = cur * 2 + 2 NotesAt some point in the development of this problem, the following alternative statement appeared: we need to minimize the total number of operations of both types. How to solve this problem?"
    },
    "2039C1": {
        "title": "C1. Shohag Loves XOR (Easy Version)",
        "description": "This is the easy version of the problem. The differences between the two versions are highlighted in bold. You can only make hacks if both versions of the problem are solved.\nShohag has two integers x and m. Help him count the number of integers 1\u2264y\u2264m such that x\u2260y and x\u2295y is a divisor\u2217 of either x, y, or both. Here \u2295 is the bitwise XOR operator.\n\u2217The number b is a divisor of the number a if there exists an integer c such that a=b\u22c5c.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two space-separated integers x and m (1\u2264x\u2264106, 1\u2264m\u22641018).\nIt is guaranteed that the sum of x over all test cases does not exceed 107.\nFor each test case, print a single integer\u00a0\u2014 the number of suitable y.\nIn the first test case, for x=6, there are 3 valid values for y among the integers from 1 to m=9, and they are 4, 5, and 7.\nIn the second test case, for x=5, there are 2 valid values for y among the integers from 1 to m=7, and they are 4 and 6.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "2039C1 - Shohag Loves XOR (Easy Version)THOUGHT: Here x>0 and y>0. So x\u2295y is neither equal to x nor y. So x\u2295y is a divisor of x or y and x\u2295y<x or x\u2295y<y.OBSERVATION: Any divisor d of p such that d<p we know that d\u2264\u230ap2\u230b. Also, the highest bits of d and p are different when d\u2264\u230ap2\u230b.THOUGHT: Wait but x\u2295y has the same highest bit as y if y\u22652\u22c5x.CONCLUSION: So if y\u22652\u22c5x, then x\u2295y can not be a divisor of y.THOUGHT: But can it be a divisor of x?OBSERVATION: If y\u22652\u22c5x, then x\u2295y>x because the highest bit in x\u2295y is greater than that in x. So x\u2295y can not be a divisor of x.CONCLUSION: If y\u22652\u22c5x, then x\u2295y can not be a divisor of x or y. So no solution in this case.THOUGHT: Now we need to consider the case when y<2\u22c5x. But x is small in this problem, making it feasible to iterate over all possible values of y.ACTION: Iterate over all possible values of y<2\u22c5x and check if x\u2295y is a divisor of either x or y.Time Complexity: O(x). Code#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n  int x; ll m; cin >> x >> m;\n\n  int ans = 0;\n  for (int y = 1; y <= min(2LL * x, m); y++) {\n    if (x != y and ((x % (x ^ y)) == 0 or (y % (x ^ y) == 0))) {\n      ++ans;\n    }\n  }\n  cout << ans << '\\n';\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n} Rate the Problem Amazing problem: \n\n    \n\n\n264\n\n\n\n Good problem: \n\n    \n\n\n81\n\n\n\n Average problem: \n\n    \n\n\n37\n\n\n\n Bad problem: \n\n    \n\n\n58\n\n\n\n Didn't solve: \n\n    \n\n\n29\n\n\n\n "
    },
    "2039B": {
        "title": "B. Shohag Loves Strings",
        "description": "For a string p, let f(p) be the number of distinct non-empty substrings\u2217 of p.\nShohag has a string s. Help him find a non-empty string p such that p is a substring of s and f(p) is even or state that no such string exists.\n\u2217A string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains a string s (1\u2264|s|\u2264105) consisting of lowercase English letters.\nIt is guaranteed that the sum of the length of s over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print a non-empty string that satisfies the conditions mentioned in the statement, or \u22121 if no such string exists. If there are multiple solutions, output any.\nIn the first test case, we can set p= abaa because it is a substring of s and the distinct non-empty substrings of p are a, b, aa, ab, ba, aba, baa and abaa, so it has a total of 8 distinct substrings which is even.\nIn the second test case, we can only set p= a but it has one distinct non-empty substring but this number is odd, so not valid.\nIn the third test case, the whole string contains 52 distinct non-empty substrings, so the string itself is a valid solution.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "2039B - Shohag Loves StringsAuthor: YouKn0wWho TutorialTutorial is loading... Code#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 3e5 + 9;\nusing ll = long long;\n\nvoid solve() {\n  string s; cin >> s;\n  int n = s.size();\n  for (int i = 0; i + 1 < n; i++) {\n    if (s[i] == s[i + 1]) {\n      cout << s.substr(i, 2) << '\\n';\n      return;\n    }\n  }\n  for (int i = 0; i + 2 < n; i++) {\n    if (s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]) {\n      cout << s.substr(i, 3) << '\\n';\n      return;\n    }\n  }\n  cout << -1 << '\\n';\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t = 1;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n} Rate the Problem Amazing problem: \n\n    \n\n\n306\n\n\n\n Good problem: \n\n    \n\n\n52\n\n\n\n Average problem: \n\n    \n\n\n32\n\n\n\n Bad problem: \n\n    \n\n\n29\n\n\n\n Didn't solve: \n\n    \n\n\n19\n\n\n\n "
    },
    "2037C": {
        "title": "C. Superultra's Favorite Permutation",
        "description": "Superultra, a little red panda, desperately wants primogems. In his dreams, a voice tells him that he must solve the following task to obtain a lifetime supply of primogems. Help Superultra!\nConstruct a permutation\u2217 p of length n such that pi+pi+1 is composite\u2020 over all 1\u2264i\u2264n\u22121. If it's not possible, output \u22121.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\u2020An integer x is composite if it has at least one other divisor besides 1 and x. For example, 4 is composite because 2 is a divisor.\nThe first line contains t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case contains an integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, if it's not possible to construct p, output \u22121 on a new line. Otherwise, output n integers p1,p2,\u2026,pn on a new line.\nIn the first example, it can be shown that all permutation of size 3 contain two adjacent elements whose sum is prime. For example, in the permutation [2,3,1] the sum 2+3=5 is prime.\nIn the second example, we can verify that the sample output is correct because 1+8, 8+7, 7+3, 3+6, 6+2, 2+4, and 4+5 are all composite. There may be other constructions that are correct.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "2037C - Superultra's Favorite PermutationProblem Credits: sum  Analysis: chromate00 Solution Remember that all even numbers greater than 2 are composite. As 1+3>2, any two numbers with same parity sum up to a composite number. Now you only have to find one odd number and one even number that sum up to a composite number. One can manually verify that there is no such pair in n\u22644, but in n=5 there exists (4,5) which sums up to 9, a composite number. Code (Python) for _ in range(int(input())):\n    n = int(input())\n    if n < 5:\n        print(-1)\n        continue\n    for i in range(2,n+1,2):\n        if i != 4:\n            print(i,end=\" \")\n    print(\"4 5\",end=\" \")\n    for i in range(1,n+1,2):\n        if i != 5:\n            print(i, end = \" \")\n    print()"
    },
    "2036C": {
        "title": "C. Anya and 1100",
        "description": "While rummaging through things in a distant drawer, Anya found a beautiful string s consisting only of zeros and ones.\nNow she wants to make it even more beautiful by performing q operations on it.\nEach operation is described by two integers i (1\u2264i\u2264|s|) and v (v\u2208{0,1}) and means that the i-th character of the string is assigned the value v (that is, the assignment si=v is performed).\nBut Anya loves the number 1100, so after each query, she asks you to tell her whether the substring \"1100\" is present in her string (i.e. there exist such 1\u2264i\u2264|s|\u22123 that sisi+1si+2si+3=1100).\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of the test case contains the string s (1\u2264|s|\u22642\u22c5105), consisting only of the characters \"0\" and \"1\". Here |s| denotes the length of the string s.\nThe next line contains an integer q (1\u2264q\u22642\u22c5105) \u2014 the number of queries.\nThe following q lines contain two integers i (1\u2264i\u2264|s|) and v (v\u2208{0,1}), describing the query.\nIt is guaranteed that the sum of |s| across all test cases does not exceed 2\u22c5105. It is also guaranteed that the sum of q across all test cases does not exceed 2\u22c5105.\nFor each query, output \"YES\", if \"1100\" is present in Anya's string; otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solutions": "2036C - Anya and 1100Idea: m3tr0 HintWith each query, to track the change in the presence of \u201c1100\u201d in a row, you don't have to go through the entire row \u2014 you can check just a few neighboring cells. TutorialFirst, in a naive way, let's count count \u2014 the number of times \u201c1100\u201d occurs in s.Then for each of q queries we will update count: consider the substring s[max(1,i\u22123);min(i+3,n)] before changing si and find before \u2014 the number of times that \u201c1100\u201d occurs in it. Then update si=v and similarly find after \u2014 the number of times that \u201c1100\u201d occurs in s[max(1,i\u22123);min(i+3,n)] after applying the query.Thus, by doing count=count+(after\u2212before), we get the number of times that \u201c1100\u201d occurs in s after the query is applied. If count>0, the answer to the query is \u201cYES\u201d, otherwise it is \u201cNO\u201d.Complexity: O(|s|+q) Solution (m3tr0)#include <cstdio>\n#include <cstring>\n\nusing namespace std;\ntypedef long long l;\n\nchar buf[1000000];\nl n;\n\nbool check_1100(l i) {\n\tif (i < 0) return false;\n\tif (i >= n - 3) return false;\n\tif (buf[i] == '1' && buf[i + 1] == '1' && buf[i + 2] == '0' && buf[i + 3] == '0') return true;\n\treturn false;\n}\n\nvoid solve() {\n\tscanf(\"%s\", buf);\n\tn = strlen(buf);\n\tl count = 0;\n\tfor (l i = 0; i < n; i++)\n\t\tif (check_1100(i)) count++;\n\t\n\tl q; scanf(\"%lld\", &q);\n\twhile (q--) {\n\t\tl i, v; scanf(\"%lld %lld\", &i, &v); i--;\n\t\tif (buf[i] != '0' + v) {\n\t\t    bool before = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);\n\t\t    buf[i] = '0' + v;\n\t\t    bool after = check_1100(i - 3) || check_1100(i - 2) || check_1100(i - 1) || check_1100(i);\n\t\t    count += after - before;\n\t\t}\n\t\tprintf(count ? \"YES\\n\" : \"NO\\n\");\n\t}\n}\n\nint main() {\n\tl t; scanf(\"%lld\", &t);\n\twhile (t--) solve();\n}\n"
    },
    "2034B": {
        "title": "B. Rakhsh's Revival",
        "description": "Rostam's loyal horse, Rakhsh, has seen better days. Once powerful and fast, Rakhsh has grown weaker over time, struggling to even move. Rostam worries that if too many parts of Rakhsh's body lose strength at once, Rakhsh might stop entirely. To keep his companion going, Rostam decides to strengthen Rakhsh, bit by bit, so no part of his body is too frail for too long.\nImagine Rakhsh's body as a line of spots represented by a binary string s of length n, where each 0 means a weak spot and each 1 means a strong one. Rostam's goal is to make sure that no interval of m consecutive spots is entirely weak (all 0s).\nLuckily, Rostam has a special ability called Timar, inherited from his mother Rudabeh at birth. With Timar, he can select any segment of length k and instantly strengthen all of it (changing every character in that segment to 1). The challenge is to figure out the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length m.\nThe first line contains an integer t (1\u2264t\u2264104), the number of test cases. \nThe first line of each test case contains three numbers n, m, k (1\u2264m,k\u2264n\u22642\u22c5105). The second line of each test case contains a binary string s of n characters s1s2\u2026sn. (si\u2208{0,1} for 1\u2264i\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length m.\nIn the first test case, we should apply an operation on each 0.\nIn the second test case, s is already ok. \nIn the third test case, we can perform an operation on interval [3,4] to get 001100.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "2034B - Rakhsh's RevivalIdea: MohammadParsaElahimanesh and AmirrzwM \u2014 Preparation: AmShZ SolutionWe will solve the problem using the following approach:  Start from the leftmost spot and move rightwards. Whenever a consecutive segment of m weak spots (i.e., 0's) is found, apply Timar to a segment of length k, starting from the last index of the weak segment. Repeat this process until no segment of m consecutive weak spots remains. The key idea behind this solution is that whenever we encounter a block of m consecutive 0's, we need to strengthen it. Since we can apply Timar to a segment of length k, the optimal strategy is always to apply Timar starting at the last index of the block of m consecutive 0's.Correctness Proof:  For any block of m consecutive 0's, we must apply Timar to at least one index within this block. Hence, the strengthened segment of length k must overlap with the block of weak spots. Suppose an optimal solution exists where Timar is applied to a segment starting leftward within the block. Suppose we shift this segment one step to the right (closer to the end of the block). In that case, the solution remains valid and optimal since it covers all weak spots in the block while reducing unnecessary overlap with already-strengthened areas. By always starting from the last index of a block of m consecutive 0's, this greedy strategy ensures that Timar is used in the minimum number of applications, making it correct and efficient. Implementation# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int xn = 2e5 + 10;\n\nint q, n, m, k, ps[xn];\nstring s;\n\nint main() {\n    cin >> q;\n    while (q --) {\n        cin >> n >> m >> k >> s;\n        fill(ps, ps + n, 0);\n        int ans = 0, cnt = 0, sum = 0;\n        for (int i = 0; i < n; ++ i) {\n            sum += ps[i];\n            if (sum || s[i] == '1') cnt = 0;\n            else {\n                cnt++;\n                if (cnt == m) {\n                    sum++, ans++, cnt = 0;\n                    if (i + k < n) ps[i + k]--;\n                }\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n}"
    },
    "2032B": {
        "title": "B. Medians",
        "description": "You are given an array a=[1,2,\u2026,n], where n is odd, and an integer k.\nYour task is to choose an odd positive integer m and to split a into m subarrays\u2020 b1,b2,\u2026,bm such that:\n\u2020A subarray of the array a of length n is the array [al,al+1,\u2026,ar] for some integers 1\u2264l\u2264r\u2264n.\n\u2021A median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example: median([1,2,5,4,3])=3, median([3,2,1])=2, median([2,1,2,1,2,2,2])=2.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22645000) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n<2\u22c5105, n is odd)\u00a0\u2014 the length of array a and the desired median of the array of medians of all subarrays.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case:\nIn detail, for a valid answer [p1,p2,\u2026,pm]:\nIf there are multiple solutions, you can output any of them.\nIn the first test case, the given partition has m=1 and b1=[1]. It is obvious that median([median([1])])=median([1])=1.\nIn the second test case, the given partition has m=3 and:\nTherefore, median([median([1]),median([2]),median([3])])=median([1,2,3])=2.\nIn the third test case, there is no valid partition for k=3.\nIn the fourth test case, the given partition has m=5 and:\nTherefore, median([median([1,2,3]),median([4,5,6]),median([7,8,9]),median([10,11,12]),median([13,14,15])])=median([2,5,8,11,14])=8.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "2032B - MediansFor n=1 (and k=1 as well), the obvious answer would be not partitioning anything, i.e., partition with 1 subarray being itself.For n>1, we see that k=1 and k=n cannot yield a satisfactory construction. Proof is as follows:  m=1 will yield ans=\u230an+12\u230b, which will never be equal to 1 or n when n\u22653.  If m>1, considering the case of k=1, we see that median(bi)=1 iff i\u22652, and since the original array a is an increasingly-sorted permutation, we can conclude that median(b1)<1. This is not possible.  Similarly, k=n also doesn't work with m>1, as it'll require median(bm)>n. Apart from these cases, any other k can yield an answer with m=3 \u00a0\u2014 a prefix subarray b1, a middle subarray b2 containing k (b2 will be centered at k, of course), and a suffix subarray b3. This way, the answer will be median(b2)=k.The length of b2 can be either 1 or 3, depending on the parity of k (so that b1 and b3 could have odd lengths). In detail: b2 will have length 1 (i.e., [k]) if k is an even integer, and length 3 (i.e., [k\u22121,k,k+1]) if k is an odd integer.Time complexity: O(1). Solution (C++)Submission link: 289291698 Plaintextnamespace solution {\n    bool hasMultipleTests = true;\n\n    int n, k;\n\n    void preprocess() {\n\n    }\n\n    void input(int testcase) {\n        cin >> n >> k;\n    }\n\n    void solve(int testcase) {\n        if (n == 1) {cout << \"1\\n1\\n\"; return;}\n\n        if (k == 1 || k == n) {cout << \"-1\\n\"; return;}\n\n        int p2 = k - k % 2;\n        int p3 = k + 1 + k % 2;\n        cout << \"3\\n1 \" << p2 << \" \" << p3 << endl;\n    }\n} Solution (Python 3)Submission link: 289291693 Plaintextclass Solution:\n    hasMultipleTests = True\n\n    n: int = None\n    k: int = None\n\n    @classmethod\n    def preprocess(cls):\n        pass\n\n    @classmethod\n    def input(cls, testcase):\n        cls.n, cls.k = map(int, input().split())\n\n    @classmethod\n    def solve(cls, testcase):\n        if cls.n == 1: return(print('1\\n1'))\n\n        if cls.k in {1, cls.n}: return(print(-1))\n\n        p2, p3 = cls.k - cls.k % 2, cls.k + 1 + cls.k % 2\n        print(f'3\\n1 {p2} {p3}')\n\n# end Solution Feedback Didn't attempt \n\n    \n\n\n0\n\n\n\n Great problem \n\n    \n\n\n32\n\n\n\n Nice problem \n\n    \n\n\n132\n\n\n\n OK problem \n\n    \n\n\n19\n\n\n\n Bad problem \n\n    \n\n\n7\n\n\n\n Terrible problem \n\n    \n\n\n63\n\n\n\n "
    },
    "2030C": {
        "title": "C. A TRUE Battle",
        "description": "Alice and Bob are playing a game. There is a list of n booleans, each of which is either true or false, given as a binary string \u2217 of length n (where 1 represents true, and 0 represents false). Initially, there are no operators between the booleans.\nAlice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of n\u22121 turns since there are n booleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.\nTo evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false: \n\u2217A binary string is a string that only consists of characters 0 and 1\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string.\nThe second line contains a binary string of length n, consisting of characters 0 and 1\u00a0\u2014 the list of boolean values.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each testcase, output \"YES\" (without quotes) if Alice wins, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first testcase, Alice can place and between the two booleans. The game ends as there are no other places to place operators, and Alice wins because true\u00a0and\u00a0true is true.\nIn the second testcase, Alice can place or between the middle true and the left false. Bob can place and between the middle true and the right false. The statement false\u00a0or\u00a0true\u00a0and\u00a0false is false.\nNote that these examples may not be the best strategies for either Alice or Bob.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "*1100"
        ],
        "solutions": "2030C - \u0418\u0421\u0422\u0418\u041d\u041d\u0410\u042f \u0431\u0438\u0442\u0432\u0430Problem Credits: Proof_by_QED  Analysis: Proof_by_QED Solution Let's understand what Alice wants to do. She wants to separate a statement that evaluates to true between two or's. This guarantees her victory since or is evaluated after all and's.First, if the first or last boolean is true, then Alice instantly wins by placing or between the first and second, or second to last and last booleans.Otherwise, if there are two true's consecutively, Alice can also win. Alice may place or before the first of the two on her first move. If Bob does not put his operator between the two true's, then Alice will put an or between the two true's on her next move and win. Otherwise, Bob does place his operator between the two true's. However, no matter what Bob placed, the two true's will always evaluate to true, so on her second move Alice can just place an or on the other side of the two true's to win.We claim these are the only two cases where Alice wins. This is because otherwise, there does not contain two true's consecutively. Now, whenever Alice places an or adjacent to a true, Bob will respond by placing and after the true, which will invalidate this clause to be false. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        vector<int> v(n);\n        for(int i = 0; i < n; i++) {\n            if(s[i]=='1') v[i]=1;\n        }\n        bool win = false;\n        if(v[0]||v[n-1]) win=true;\n        for(int i = 1; i < n; i++) {\n            if(v[i]&&v[i-1]) win=true;\n        }\n        if(win) cout << \"YES\" << endl;\n        else cout << \"NO\" << endl;\n    }\n}"
    },
    "2029B": {
        "title": "B. Replacement",
        "description": "You have a binary string\u2217 s of length n, and Iris gives you another binary string r of length n\u22121.\nIris is going to play a game with you. During the game, you will perform n\u22121 operations on s. In the i-th operation (1\u2264i\u2264n\u22121):\nIf all the n\u22121 operations are performed successfully, you win.\nDetermine whether it is possible for you to win this game.\n\u2217A binary string is a string where each character is either 0 or 1.\nEach test contains multiple test cases. The first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of s.\nThe second line contains the binary string s of length n (si=0 or 1).\nThe third line contains the binary string r of length n\u22121 (ri=0 or 1).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print \"YES\" (without quotes) if you can win the game, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first test case, you cannot perform the first operation. Thus, you lose the game.\nIn the second test case, you can choose k=1 in the only operation, and after that, s becomes equal to 1. Thus, you win the game.\nIn the third test case, you can perform the following operations: 110_1r1=0\u2192101_r2=0\u219210_r3=1\u21921.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "strings",
            "*1100"
        ],
        "solutions": "2029B - ReplacementAuthor: wyrqwqFirst Blood: Benq at 00:02:30 Hint(01 or 10 exists) \u27fa (both 0 and 1 exist). SolutionEach time we do an operation, if s consists only of 0 or 1, we surely cannot find any valid indices. Otherwise, we can always perform the operation successfully. In the i-th operation, if ti=0, we actually decrease the number of 1-s by 1, and vice versa. Thus, we only need to maintain the number of 0-s and 1-s in s. If any of them falls to 0 before the last operation, the answer is NO, otherwise, the answer is YES.Time complexity: O(n) per test case. Code (C++)#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\n\nusing namespace std;\nusing ll = long long;\n\nconst int _N = 1e5 + 5;\n\nvoid solve() {\n\tint n; cin >> n;\n\tstring s, t; cin >> s >> t;\n\tint cnt0 = count(all(s), '0'), cnt1 = n - cnt0;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (cnt0 == 0 || cnt1 == 0) {\n\t\t\tcout << \"NO\" << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tif (t[i] == '1') cnt0--;\n\t\telse cnt1--;\n\t}\n\tcout << \"YES\" << '\\n';\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Code (Python 3)for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    one = s.count(\"1\")\n    zero = s.count(\"0\")\n    ans = \"YES\"\n    for ti in input():\n        if one == 0 or zero == 0:\n            ans = \"NO\"\n            break\n        one -= 1\n        zero -= 1\n        if ti == \"1\":\n            one += 1\n        else:\n            zero += 1\n    print(ans) Rate the Problem Amazing problem: \n\n    \n\n\n64\n\n\n\n Good problem: \n\n    \n\n\n214\n\n\n\n Average problem: \n\n    \n\n\n26\n\n\n\n Bad problem: \n\n    \n\n\n46\n\n\n\n Didn't solve: \n\n    \n\n\n21\n\n\n\n "
    },
    "2027B": {
        "title": "B. Stalin Sort",
        "description": "Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an O(n) time complexity.\nIt goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array [1,4,2,3,6,5,5,7,7] becomes [1,4,6,7,7] after a Stalin Sort.\nWe define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays\u2217, as many times as is needed.\nGiven an array a of n integers, determine the minimum number of integers which must be removed from the array to make it vulnerable.\n\u2217An array a is a subarray of an array b if a can be obtained from b by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. \nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642000)\u00a0\u2014 the size of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2000.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of integers which must be removed from the array to make it vulnerable.\nIn the first test case, the optimal answer is to remove the numbers 3 and 9. Then we are left with a=[6,4,2,5,2]. To show this array is vulnerable, we can first apply a Stalin Sort on the subarray [4,2,5] to get a=[6,4,5,2] and then apply a Stalin Sort on the subarray [6,4,5] to get a=[6,2], which is non-increasing.\nIn the second test case, the array is already non-increasing, so we don't have to remove any integers.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ],
        "solutions": "2027B - Stalin SortAn array is vulnerable if and only if the first element is the largest. To prove the forward direction, we can trivially perform a single operation on the entire range, which will clearly make it non-increasing. Now, let's prove the reverse direction. Consider any array in which the maximum is not the first element. Note that a Stalin Sort on any subarray will never remove the first element, and also will never remove the maximum. So if the first is not the maximum, this will always break the non-increasing property.Therefore, we just need to find the longest subsequence in which the first element is the largest. This can be done easily in O(n2)\u00a0\u2014 consider each index being the first item in the subsequence, and count all items to the right of it which are smaller or equal to it. Find the maximum over all of these, then subtract this from n.Bonus: Solve this task in O(nlogn). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> A(n);\n        for (int i=0; i<n; i++) cin >> A[i];\n        int best = 0;\n        for (int i=0; i<n; i++) {\n            int curr = 0;\n            for (int j=i; j<n; j++) {\n                if (A[j] <= A[i]) {\n                    curr += 1;\n                }\n            }\n            best = max(best, curr);\n        }\n        cout << n - best << \"\\n\";\n    }\n  return 0;\n}"
    },
    "2025B": {
        "title": "B. Binomial Coefficients, Kind Of",
        "description": "Recently, akshiM met a task that needed binomial coefficients to solve. He wrote a code he usually does that looked like this:\nUnfortunately, he made an error, since the right formula is the following:\nBut his team member keblidA is interested in values that were produced using the wrong formula. Please help him to calculate these coefficients for t various pairs (ni,ki). Note that they should be calculated according to the first (wrong) formula.\nSince values C[ni][ki] may be too large, print them modulo 109+7.\nThe first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of pairs. Next, t pairs are written in two lines.\nThe second line contains t integers n1,n2,\u2026,nt (2\u2264ni\u2264105).\nThe third line contains t integers k1,k2,\u2026,kt (1\u2264ki<ni).\nPrint t integers C[ni][ki] modulo 109+7.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*1100"
        ],
        "solutions": "2025B - Binomial Coefficients, Kind OfIn order to solve the task, just try to generate values and find a pattern. The pattern is easy: C[n][k]=2k for all k\u2208[0,n).The last step is to calculate C[n][k] fast enough. For example, we can precalculate all powers of two in some array p as p[k]=2\u22c5p[k\u22121]mod(109+7) for all k<105 and print the necessary values when asked.Proof:C[n][k]=C[n][k\u22121]+C[n\u22121][k\u22121]= =C[n][k\u22122]+2\u22c5C[n\u22121][k\u22122]+C[n\u22122][k\u22122]= =C[n][k\u22123]+3\u22c5C[n\u22121][k\u22123]+3\u22c5C[n\u22122][k\u22123]+C[n\u22123][k\u22123]= =\u2211i=0j(ji)\u22c5C[n\u2212i][k\u2212j]=\u2211i=0k(ki)\u22c5C[n\u2212i][0]=\u2211i=0k(ki)=2k Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = int(1e9) + 7;\n\nint main() {\n\tint t; cin >> t;\n\tvector<int> ks(t);\n\tfor (int _ = 0; _ < 2; _++)\n\t\tfor (int i = 0; i < t; i++)\n\t\t\tcin >> ks[i];\n\t\n\tvector<int> ans(1 + *max_element(ks.begin(), ks.end()), 1);\n\tfor (int i = 1; i < (int)ans.size(); i++)\n\t\tans[i] = (2LL * ans[i - 1]) % MOD;\n\t\n\tfor (int k : ks)\n\t\tcout << ans[k] << '\\n';\n\treturn 0;\n}"
    },
    "2024B": {
        "title": "B. Buying Lemonade",
        "description": "There is a vending machine that sells lemonade. The machine has a total of n slots. You know that initially, the i-th slot contains ai cans of lemonade. There are also n buttons on the machine, each button corresponds to a slot, with exactly one button corresponding to each slot. Unfortunately, the labels on the buttons have worn off, so you do not know which button corresponds to which slot.\nWhen you press the button corresponding to the i-th slot, one of two events occurs:\nAfter pressing, the can drops out so quickly that it is impossible to track from which slot it fell. The contents of the slots are hidden from your view, so you cannot see how many cans are left in each slot. The only thing you know is the initial number of cans in the slots: a1,a2,\u2026,an.\nDetermine the minimum number of button presses needed to guarantee that you receive at least k cans of lemonade.\nNote that you can adapt your strategy during the button presses based on whether you received a can or not. It is guaranteed that there are at least k cans of lemonade in total in the machine. In other words, k\u2264a1+a2+\u2026+an.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105, 1\u2264k\u2264109)\u00a0\u2014 the number of slots in the machine and the required number of cans of lemonade.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the number of cans in the slots.\nIt is guaranteed that k\u2264a1+a2+\u2026+an, meaning there are at least k cans of lemonade in the machine.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the minimum number of button presses needed to guarantee that you receive at least k cans of lemonade.\nIn the first test case, we can simply press the first button and receive one can of lemonade.\nIn the second test case, we can press each button once and guarantee that we receive 2 cans of lemonade. Note that if we simply press one button twice, we might not be lucky, and that button could correspond to the first slot, in which case we would only receive 1 can of lemonade for two presses.\nIn the third test case, one of the optimal strategies is as follows:\nPress the first button twice. After the first press, a can of lemonade will definitely drop out. Then there are two options:\nIt can be shown that it is impossible to guarantee receiving 4 cans of lemonade with only 4 presses, so the answer is 5.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "sortings",
            "*1100"
        ],
        "solutions": "2024B - Buying LemonadeLet's make a few simple observations about the optimal strategy of actions. First, if after pressing a certain button, no cans have been obtained, there is no point in pressing that button again. Second, among the buttons that have not yet resulted in a failure, it is always advantageous to press the button that has been pressed the least number of times. This can be loosely justified by the fact that the fewer times a button has been pressed, the greater the chance that the next press will be successful, as we have no other information to distinguish these buttons from one another. From this, our strategy clearly emerges: let's sort the array, let a1\u2264a2\u2264\u2026an. In the first action, we will press all buttons a1 times. It is clear that all these presses will yield cans, and in total, we will collect a1\u22c5n cans. If k\u2264a1\u22c5n, no further presses are needed. However, if k>a1\u22c5n, we need to make at least one more press. Since all buttons are still indistinguishable to us, it may happen that this press will be made on the button corresponding to a1 and will be unsuccessful. Next, we will press all remaining buttons a2\u2212a1 times; these presses will also be guaranteed to be successful. After that, again, if k does not exceed the number of cans already collected, we finish; otherwise, we need to make at least one more press, which may hit an empty cell a2. And so on. In total, the answer to the problem will be k+x, where x is the smallest number from 0 to n\u22121 such that the following holds: \u2211i=0x(ai+1\u2212ai)\u22c5(n\u2212i)\u2265k (here we consider a0=0). O(nlogn). "
    },
    "2021B": {
        "title": "B. Maximize Mex",
        "description": "You are given an array a of n positive integers and an integer x. You can do the following two-step operation any (possibly zero) number of times: \nFind the maximum value of the MEX of a if you perform the operations optimally.\nThe MEX (minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22645000). The description of the test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the length of the array and the integer to be used in the operation.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the given array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer: the maximum MEX of a if you perform the operations optimally.\nIn the first test case, the MEX of a is 4 without performing any operations, which is the maximum.\nIn the second test case, the MEX of a is 5 without performing any operations. If we perform two operations both with i=1, we will have the array a=[5,3,4,1,0,2]. Then, the MEX of a will become 6, which is the maximum.\nIn the third test case, the MEX of a is 0 without performing any operations, which is the maximum.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "2021B - Maximize MexFor the MEX to be at least k, then each non-negative integer from 0 to k\u22121 must appear at least once in the array.First, notice that since there are only n elements in the array, there are at most n different values, so the MEX can only be at most n. And since we can only increase an element's value, that means every element with values bigger than n can be ignored.We construct a frequency array freq such that freq[k] is the number of elements in a with value k.Notice that the values just need to appear at least once to contribute to the MEX, so two or more elements with the same value should be split into different values to yield a potentially better result. To find the maximum possible MEX, we iterate each index k in the array freq from 0 to n. In each iteration of k, if we find freq[k]>0, that means it's possible to have the MEX be bigger than k, so we can iterate k to the next value. Before we iterate to the next value, if we find freq[k]>1, that indicates duplicates, so we should do an operation to all except one of those values to change them into k+x, which increases freq[k+x] by freq[k]\u22121 and changes freq[k] into 1. In each iteration of k, if we find freq[k]=0, that means, k is the maximum MEX we can get, and we should end the process.Time complexity for each test case: O(n)C. Adjust The PresentationAuthor: ArvinCiuDeveloper: icebear30, gansixenehEditorial: Pyqe  Tutorial"
    },
    "2020B": {
        "title": "B. Brightness Begins",
        "description": "Imagine you have n light bulbs numbered 1,2,\u2026,n. Initially, all bulbs are on. To flip the state of a bulb means to turn it off if it used to be on, and to turn it on otherwise.\nNext, you do the following:\nAfter performing all operations, there will be several bulbs that are still on. Your goal is to make this number exactly k.\nFind the smallest suitable n such that after performing the operations there will be exactly k bulbs on. We can show that an answer always exists.\n\u2020 An integer x is divisible by y if there exists an integer z such that x=y\u22c5z.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains a single integer k (1\u2264k\u22641018).\nFor each test case, output n\u00a0\u2014 the minimum number of bulbs.\nIn the first test case, the minimum number of bulbs is 2. Let's denote the state of all bulbs with an array, where 1 corresponds to a turned on bulb, and 0 corresponds to a turned off bulb. Initially, the array is [1,1].\nIn the end, there are k=1 bulbs on. We can also show that the answer cannot be less than 2.\nIn the second test case, the minimum number of bulbs is 5. Initially, the array is [1,1,1,1,1]. \nIn the end, there are k=3 bulbs on. We can also show that the answer cannot be smaller than 5.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "2019B": {
        "title": "B. All Pairs Segments",
        "description": "You are given n points on the x axis, at increasing positive integer coordinates x1<x2<\u2026<xn.\nFor each pair (i,j) with 1\u2264i<j\u2264n, you draw the segment [xi,xj]. The segments are closed, i.e., a segment [a,b] contains the points a,a+1,\u2026,b.\nYou are given q queries. In the i-th query, you are given a positive integer ki, and you have to determine how many points with integer coordinates are contained in exactly ki segments.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains two integers n, q (2\u2264n\u2264105, 1\u2264q\u2264105)\u00a0\u2014 the number of points and the number of queries.\nThe second line of each test case contains n integers x1,x2,\u2026,xn (1\u2264x1<x2<\u2026<xn\u2264109)\u00a0\u2014 the coordinates of the n points.\nThe third line of each test case contains q integers k1,k2,\u2026,kq (1\u2264ki\u22641018)\u00a0\u2014 the parameters of the q queries.\nIt is guaranteed that the sum of n over all test cases does not exceed 105, and the sum of q over all test cases does not exceed 105.\nFor each test case, output a single line with q integers: the i-th integer is the answer to the i-th query.\nIn the first example, you only draw the segment [101,200]. No point is contained in exactly 2 segments, and the 100 points 101,102,\u2026,200 are contained in exactly 1 segment.\nIn the second example, you draw 15 segments: [1,2],[1,3],[1,5],[1,6],[1,7],[2,3],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7],[5,6],[5,7],[6,7]. Points 1,7 are contained in exactly 5 segments; points 2,4,6 are contained in exactly 9 segments; points 3,5 are contained in exactly 11 segments.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "2019B - All Pairs SegmentsAuthor: TheScrasse Preparation: TheScrasse Hint 1Can you determine fast how many intervals contain point p? Hint 2The intervals that contain point p are the ones with l\u2264p and r\u2265p. Hint 3Determine how many intervals contain:  point x1; points x1+1,\u2026,x2\u22121; point x2; \u2026 point xn.  SolutionFirst, let's focus on determining how many intervals contain some point x. These intervals are the ones with l\u2264x and x\u2264r.So a point xi<p<xi+1 satisfies x1\u2264p,\u2026,xi\u2264p, and p\u2264xi+1,\u2026,p\u2264xn. It means that you have found xi+1\u2212xi\u22121 points contained in exactly i(n\u2212i) intervals (because there are i possible left endpoints and n\u2212i possible right endpoints).Similarly, the point p=xi is contained in i(n\u2212i+1)\u22121 intervals (you have to remove interval [xi,xi], which you do not draw).So you can use a map that stores how many points are contained in exactly x intervals, and update the map in the positions i(n\u2212i) and i(n\u2212i+1)\u22121.Complexity: O(nlogn)"
    },
    "2014C": {
        "title": "C. Robin Hood in Town",
        "description": "Look around, the rich are getting richer, and the poor are getting poorer. We need to take from the rich and give to the poor. We need Robin Hood!\nThere are n people living in the town. Just now, the wealth of the i-th person was ai gold. But guess what? The richest person has found an extra pot of gold! \nMore formally, find an aj=max(a1,a2,\u2026,an), change aj to aj+x, where x is a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.\nA person is unhappy if their wealth is strictly less than half of the average wealth\u2217. \nIf strictly more than half of the total population n are unhappy, Robin Hood will appear by popular demand.\nDetermine the minimum value of x for Robin Hood to appear, or output \u22121 if it is impossible.\n\u2217The average wealth is defined as the total wealth divided by the total population n, that is, \u2211ain, the result is a real number.\nThe first line of input contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the total population.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the wealth of each person.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the minimum number of gold that the richest person must find for Robin Hood to appear. If it is impossible, output \u22121 instead.\nIn the first test case, it is impossible for a single person to be unhappy.\nIn the second test case, there is always 1 happy person (the richest).\nIn the third test case, no additional gold are required, so the answer is 0.\nIn the fourth test case, after adding 15 gold, the average wealth becomes 254, and half of this average is 258, resulting in 3 people being unhappy.\nIn the fifth test case, after adding 16 gold, the average wealth becomes 315, resulting in 3 people being unhappy.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "2014C - Robin Hood in Town Hint 1Answer is impossible if n less than 3. Hint 2Lets first find minimum no of people that should be unhappy (say K). Hint 3Lets sort A, now average should be more than 2*Ak Hint 4Lets say pot has X gold.Let S be the total gold. 2\u2217Ak<(S+X)/N2\u2217N\u2217Ak<S+X2\u2217N\u2217Ak\u2212S<X2\u2217N\u2217Ak\u2212S+1\u2264X So X should be max(0,2*N*ak-S+1) My submission \u2014 282243282 Video Editorial"
    },
    "2009C": {
        "title": "C. The Legend of Freya the Frog",
        "description": "Freya the Frog is traveling on the 2D coordinate plane. She is currently at point (0,0) and wants to go to point (x,y). In one move, she chooses an integer d such that 0\u2264d\u2264k and jumps d spots forward in the direction she is facing. \nInitially, she is facing the positive x direction. After every move, she will alternate between facing the positive x direction and the positive y direction (i.e., she will face the positive y direction on her second move, the positive x direction on her third move, and so on). \nWhat is the minimum amount of moves she must perform to land on point (x,y)?\nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case contains three integers x, y, and k (0\u2264x,y\u2264109,1\u2264k\u2264109).\nFor each test case, output the number of jumps Freya needs to make on a new line.\nIn the first sample, one optimal set of moves is if Freya jumps in the following way: (0,0) \u2192 (2,0) \u2192 (2,2) \u2192 (3,2) \u2192 (3,5) \u2192 (6,5) \u2192 (6,8) \u2192 (9,8) \u2192 (9,11). This takes 8 jumps.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "2009C - The Legend of Freya the FrogProblem Credits: Proof_by_QED  Analysis: cry Solution Consider the x and y directions separately and calculate the jumps we need in each direction. The number of jumps we need in the x direction is \u2308xk\u2309 and similarily \u2308yk\u2309 in the y direction. Now let's try to combine them to obtain the total number of jumps. Let's consider the following cases:  \u2308yk\u2309\u2265\u2308xk\u2309. In this case, there will need to be \u2308yk\u2309\u2212\u2308xk\u2309 extra jumps in the y direction. While Freya performs these extra jumps, she will choose d=0 for the x direction. In total, there will need to be 2\u22c5\u2308yk\u2309 jumps. \u2308xk\u2309>\u2308yk\u2309. We can use the same reasoning as the previous case, but there's a catch. Since Freya is initially facing the x direction, for the last jump, she does not need to jump in the y direction. In total, there will need to be 2\u22c5\u2308xk\u2309\u22121 jumps.  Code (Python) (ntarsis30)for _ in range(int(input())):\n    x,y,k = map(int,input().split())\n    print(max(2*((x+k-1)//k)-1,2*((y+k-1)//k)))"
    },
    "2008D": {
        "title": "D. Sakurako's Hobby",
        "description": "For a certain permutation p\u2217 Sakurako calls an integer j reachable from an integer i if it is possible to make i equal to j by assigning i=pi a certain number of times.\nIf p=[3,5,6,1,2,4], then, for example, 4 is reachable from 1, because: i=1 \u2192 i=p1=3 \u2192 i=p3=6 \u2192 i=p6=4. Now i=4, so 4 is reachable from 1.\nEach number in the permutation is colored either black or white.\nSakurako defines the function F(i) as the number of black integers that are reachable from i.\nSakurako is interested in F(i) for each 1\u2264i\u2264n, but calculating all values becomes very difficult, so she asks you, as her good friend, to compute this.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (the number 2 appears twice in the array), and [1,3,4] is also not a permutation (n=3, but the array contains 4).\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u00a0\u2014 the number of elements in the array.\nThe second line of each test case contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n) \u00a0\u2014 the elements of the permutation.\nThe third line of each test case contains a string s of length n, consisting of '0' and '1'. If si=0, then the number pi is colored black; if si=1, then the number pi is colored white.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers F(1),F(2),\u2026,F(n).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "dsu",
            "graphs",
            "math",
            "*1100"
        ],
        "solutions": "2008D - Sakurako's HobbyAny permutation can be divided into some number of cycles, so F(i) is equal to the number of black colored elements in the cycle where i is. So, we can write out all cycles in O(n) and memorize for each i the number of black colored elements in the cycle where it is. Solution in C++#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        long long n;\n        cin>>n;\n        long long p[n+1]={0},b[n+1]={0};\n        int us[n+1]={0};\n        for(int i=1;i<=n;i++)\n        {\n            cin>>p[i];\n        }\n        string s;\n        cin >> s;\n        for(int i=1;i<=n;i++)\n        {\n            if(us[i])continue;\n            int sz=0;\n            while(!us[i])\n            {\n                us[i]=1;\n                sz += s[i - 1] == '0';\n                i=p[i];\n            }\n            while(us[i]!=2)\n            {\n                b[i]=sz;\n                us[i]=2;\n                i=p[i];\n            }\n        }\n        for(int i=1;i<=n;i++)\n        {\n            cout<<b[i]<<\" \";\n        }\n        cout<<endl;\n    }\n} Solution in Pythont = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = [0] * (n + 1)\n    us = [0] * (n + 1)\n    p = [k-1 for k in map(int, input().split())]\n    s = input()\n    for i in range(0, n):\n        if us[i]:\n            continue\n        sz = 0\n        while not us[i]:\n            us[i] = 1\n            sz += s[i] == '0'\n            i = p[i]\n        while us[i] != 2:\n            b[i] = sz\n            us[i] = 2\n            i = p[i]\n    print(\" \".join(map(str, b[:-1]))) Rate the problem Didn't solve \n\n    \n\n\n70\n\n\n\n Good task \n\n    \n\n\n427\n\n\n\n Average task \n\n    \n\n\n39\n\n\n\n Bad task \n\n    \n\n\n31\n\n\n\n "
    },
    "2005B2": {
        "title": "B2. The Strict Teacher (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions are the constraints on m and q. In this version, m,q\u2264105. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now m teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from 1 to n, inclusive.\nAt the start, all m teachers and David are in distinct cells. Then they make moves. During each move \nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you q queries on David's position.\nIn the first line of the input, you are given a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers n, m, and q (3\u2264n\u2264109, 1\u2264m,q\u2264105)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given m distinct integers b1,b2,\u2026,bm (1\u2264bi\u2264n)\u00a0\u2014 the cell numbers of the teachers.\nIn the third line of each test case, you are given q integers a1,a2,\u2026,aq (1\u2264ai\u2264n)\u00a0\u2014 David's cell number for every query.\nIt is guaranteed that for any i, j such that 1\u2264i\u2264m and 1\u2264j\u2264q, bi\u2260aj.\nIt is guaranteed that the sum of values of m over all test cases does not exceed 2\u22c5105.\nIt is guaranteed that the sum of values of q over all test cases does not exceed 2\u22c5105.\nFor each test case, output q lines, the i-th of them containing the answer of the i-th query.\nIn the only query of the first example, the student can run to cell 1. It will take the teacher five moves to reach from cell 6 to cell 1, so the answer is 5.\nIn the second query of the second example, the student can just stay at cell 3. The teacher, initially located in cell 4, can reach cell 3 in one move. Therefore, the answer is 1.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "2005B2 - The Strict Teacher (Hard Version) Hint 1We need the nearest teacher on the left side and right side, and then B1 solution works.  Hint 2To find the nearest teachers, you can either use binary search or use lower_bound stl function.My submission \u2014 281146462 Video Editorial"
    },
    "2005B1": {
        "title": "B1. The Strict Teacher (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions are the constraints on m and q. In this version, m=2 and q=1. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now m teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from 1 to n, inclusive.\nAt the start, all m teachers and David are in distinct cells. Then they make moves. During each move \nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you q queries on David's position. Note: this is the easy version, and you are given only one query.\nIn the first line of the input, you are given a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers n, m, and q (3\u2264n\u2264109, m=2, q=1)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given m distinct integers b1,b2,\u2026,bm (1\u2264bi\u2264n)\u00a0\u2014 the cell numbers of the teachers.\nIn the third line of each test case, you are given q integers a1,a2,\u2026,aq (1\u2264ai\u2264n)\u00a0\u2014 David's cell number for every query.\nIt is guaranteed that for any i, j such that 1\u2264i\u2264m and 1\u2264j\u2264q, bi\u2260aj.\nFor each test case, output q lines, the i-th of them containing the answer of the i-th query.\nIn the first example, the student can just stay at cell 2. The teacher, initially located in cell 1, can reach cell 2 in one move. Therefore, the answer is 1.\nIn the second example, the student should just stay at cell 1. The teacher, initially located in cell 3, can reach cell 1 in two moves. Therefore, the answer is 2.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "2005B1 - The Strict Teacher (Easy Version) HintSeparately solve for cases when David is on left side of both the teachers, in between the teachers and right side of both the teachers.My submission \u2014 281147180 Video Editorial"
    },
    "2004C": {
        "title": "C. Splitting Items",
        "description": "Alice and Bob have n items they'd like to split between them, so they decided to play a game. All items have a cost, and the i-th item costs ai. Players move in turns starting from Alice.\nIn each turn, the player chooses one of the remaining items and takes it. The game goes on until no items are left.\nLet's say that A is the total cost of items taken by Alice and B is the total cost of Bob's items. The resulting score of the game then will be equal to A\u2212B.\nAlice wants to maximize the score, while Bob wants to minimize it. Both Alice and Bob will play optimally.\nBut the game will take place tomorrow, so today Bob can modify the costs a little. He can increase the costs ai of several (possibly none or all) items by an integer value (possibly, by the same value or by different values for each item). However, the total increase must be less than or equal to k. Otherwise, Alice may suspect something. Note that Bob can't decrease costs, only increase.\nWhat is the minimum possible score Bob can achieve?\nThe first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. Then t cases follow.\nThe first line of each test case contains two integers n and k (2\u2264n\u22642\u22c5105; 0\u2264k\u2264109)\u00a0\u2014 the number of items and the maximum total increase Bob can make.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial costs of the items.\nIt's guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible score A\u2212B after Bob increases the costs of several (possibly none or all) items.\nIn the first test case, Bob can increase a1 by 5, making costs equal to [6,10]. Tomorrow, Alice will take 10 and Bob will take 6. The total score will be equal to 10\u22126=4, and it's the minimum possible.\nIn the second test case, Bob can't change costs. So the score will be equal to (15+10)\u221212=13, since Alice will take 15, Bob will take 12, and Alice\u00a0\u2014 10.\nIn the third test case, Bob, for example, can increase a1 by 1, a2 by 3, and a3 by 2. The total change is equal to 1+3+2\u22646 and costs will be equal to [4,4,4,4]. Obviously, the score will be equal to (4+4)\u2212(4+4)=0.\nIn the fourth test case, Bob can increase a1 by 3, making costs equal to [9,9]. The score will be equal to 9\u22129=0.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "2004C - Splitting ItemsLet's sort the array in descending order and consider the first two moves of the game.Since Alice goes first, she takes the maximum element in the array (a1). Then, during his turn, Bob takes the second-largest element (a2) to minimize the score difference.Bob can increase his element in advance; however, he cannot make it larger than a1 (since Alice always takes the maximum element in the array). This means that Bob needs to increase his element to min(a1,a2+k). Then the game moves to a similar situation, but without the first two elements and with an updated value of k.Thus, to solve the problem, we can sort the array and then iterate through it while maintaining several values. If the current index is odd (corresponding to Alice's turn), increase the answer by ai. If the current index is even (corresponding to Bob's turn), increase the current value of ai by min(k,ai\u22121\u2212ai), decrease k by that same value, and also subtract the new value of ai from the answer. Solution (adedalic)fun main() {\n    repeat(readln().toInt()) {\n        val (n, k) = readln().split(\" \").map { it.toInt() }\n        val a = readln().split(\" \").map { it.toInt() }.sortedDescending().toIntArray()\n\n        var score = 0L\n        var rem = k\n        for (i in a.indices) {\n            if (i % 2 == 0) {\n                score += a[i]\n            }\n            else {\n                val needed = minOf(rem, a[i - 1] - a[i])\n                a[i] += needed\n                rem -= needed\n                score -= a[i]\n            }\n        }\n        println(score)\n    }\n}"
    },
    "2004B": {
        "title": "B. Game with Doors",
        "description": "There are 100 rooms arranged in a row and 99 doors between them; the i-th door connects rooms i and i+1. Each door can be either locked or unlocked. Initially, all doors are unlocked.\nWe say that room x is reachable from room y if all doors between them are unlocked.\nYou know that: \nHowever, you don't know the exact rooms they are in.\nYou don't want Alice and Bob to be able to reach each other, so you are going to lock some doors to prevent that. What's the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers l and r (1\u2264l<r\u2264100)\u00a0\u2014 the bounds of the segment of rooms where Alice is located.\nThe second line of each test case contains two integers L and R (1\u2264L<R\u2264100) \u2014 the bounds of the segment of rooms where Bob is located.\nFor each test case, print a single integer\u00a0\u2014 the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments.\nIn the first test case, it is sufficient to lock the door between rooms 2 and 3.\nIn the second test case, the following doors have to be locked: (2,3), (3,4), (4,5).\nIn the third test case, the following doors have to be locked: (5,6) and (6,7).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solutions": "2004B - Game with DoorsIdea: BledDest TutorialTutorial is loading... Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int l, r, L, R;\n    cin >> l >> r >> L >> R;\n    int inter = min(r, R) - max(l, L) + 1;\n    int ans = inter - 1;\n    if (inter <= 0) {\n      ans = 1;\n    } else {\n      ans += (l != L);\n      ans += (r != R);\n    }\n    cout << ans << '\\n';\n  }\n}"
    },
    "2003C": {
        "title": "C. Turtle and Good Pairs",
        "description": "Turtle gives you a string s, consisting of lowercase Latin letters.\nTurtle considers a pair of integers (i,j) (1\u2264i<j\u2264n) to be a pleasant pair if and only if there exists an integer k such that i\u2264k<j and both of the following two conditions hold:\nBesides, Turtle considers a pair of integers (i,j) (1\u2264i<j\u2264n) to be a good pair if and only if si=sj or (i,j) is a pleasant pair.\nTurtle wants to reorder the string s so that the number of good pairs is maximized. Please help him!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the string.\nThe second line of each test case contains a string s of length n, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the string s after reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\nIn the first test case, (1,3) is a good pair in the reordered string. It can be seen that we can't reorder the string so that the number of good pairs is greater than 1. bac and cab can also be the answer.\nIn the second test case, (1,2), (1,4), (1,5), (2,4), (2,5), (3,5) are good pairs in the reordered string. efddd can also be the answer.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ],
        "solutions": "2003C - Turtle and Good Pairs Hint 1Try to find bad pairs. Hint 2Some of the bad substring are.- aaaabbbbb- aabb- ab Some of the good substring are.- ababababb- abab  Hint 3Intuitively, we should try to create a string which does not contain equal chars together.My submission \u2014 278156003 Video Editorial"
    },
    "2002C": {
        "title": "C. Black Circles",
        "description": "There are n circles on a two-dimensional plane. The i-th circle is centered at (xi,yi). Initially, all circles have a radius of 0.\nThe circles' radii increase at a rate of 1 unit per second.\nYou are currently at (xs,ys); your goal is to reach (xt,yt) without touching the circumference of any circle (including the moment you reach (xt,yt)). You can move in any direction you want. However, your speed is limited to 1 unit per second.\nPlease determine whether this is possible.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of circles.\nThe next n lines each contain two integers xi, yi (1\u2264xi,yi\u2264109)\u00a0\u2014 the center of each circle.\nThe final line contains four integers xs, ys, xt, yt (1\u2264xs,ys,xt,yt\u2264109)\u00a0\u2014 the coordinates of the starting point and the goal, respectively.\nIt is guaranteed that these n+2 points are distinct.\nIt is guaranteed that the sum of n over all testcases does not exceed 105.\nFor each test case, output YES if it is possible to reach the goal without touching the circle boundaries, and output NO otherwise.\nYou can output Yes and No in any case (for example, strings yEs, yes, Yes, and YES will be recognized as a positive response).\nIn the first test case, a feasible way of movement is as follows. ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "2002C \u2014 Black Circlesidea: Flamire, solution: le0n HintThe problem can't be that hard, find some simple strategy. TutorialWe consider a simple strategy: walk towards the goal in a straight line.If some circle reaches the goal first, it is obvious that we have no chance of succeeding, no matter what path we take.Otherwise, it can be proven that we will not pass any circles on our way to the goal.Suppose we start at A, our goal is B, and we got intercepted by some circle C at the point D. It follows that CD=AD. According to the triangle inequality, CD>CB\u2212DB should hold. Thus, we have CB\u2212DB\u2264AD, which means CB\u2264AB, proof by contradiction.Time complexity: O(n). Solution#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint t, n, x[100011], y[100011], xs, ys, xt, yt;\nll dis(int x1, int y1, int x2, int y2) {\n    return 1ll * (x2 - x1) * (x2 - x1) + 1ll * (y2 - y1) * (y2 - y1);\n}\nint main() {\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        scanf(\"%d\", &n);\n\n        for (int i = 1; i <= n; ++i)\n            scanf(\"%d%d\", x + i, y + i);\n\n        scanf(\"%d%d%d%d\", &xs, &ys, &xt, &yt);\n        bool ok = 1;\n\n        for (int i = 1; i <= n; ++i) {\n            if (dis(xt, yt, x[i], y[i]) <= dis(xt, yt, xs, ys)) {\n                ok = 0;\n                break;\n            }\n        }\n\n        printf(ok ? \"YES\\n\" : \"NO\\n\");\n    }\n\n    fclose(stdin);\n    fclose(stdout);\n    return 0;\n}"
    },
    "2002B": {
        "title": "B. Removals Game",
        "description": "Alice got a permutation a1,a2,\u2026,an of [1,2,\u2026,n], and Bob got another permutation b1,b2,\u2026,bn of [1,2,\u2026,n]. They are going to play a game with these arrays.\nIn each turn, the following events happen in order:\nThe game continues for n\u22121 turns, after which both arrays will have exactly one remaining element: x in the array a and y in the array b.\nIf x=y, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows. \nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105).\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n, all ai are distinct)\u00a0\u2014 the permutation of Alice.\nThe next line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264n, all bi are distinct)\u00a0\u2014 the permutation of Bob.\nIt is guaranteed that the sum of all n does not exceed 3\u22c5105.\nFor each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print Alice; otherwise, print Bob.\nIn the first test case, Bob can win the game by deleting the same element as Alice did.\nIn the second test case, Alice can delete 3 in the first turn, and then in the second turn, delete the element that is different from the one Bob deleted in the first turn to win the game.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*1000"
        ],
        "solutions": "2002B \u2014 Removals Gameidea & solution: xcyle HintFind some conditions that Bob need to win. TutorialA general idea is that it is very difficult for Bob to win. We make some observations regarding the case where Bob wins. It is intuitive to see that for any subarray [Al,Al+1,\u22ef,Ar], the elements' positions in B must also form an interval. If A[l:r] does not form an interval in B, Alice can simply remove elements until only A[l:r] is left, no matter how Bob plays, there must now be an element in A but not in B because of our previous condition. Alice can then remove everything other than this element to win.From here, it is easy to prove by induction that for Bob to win, either A=B or A=rev(B).Time complexity: O(n). Solution#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define pii pair<int, int>\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(s) (int)s.size()\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\nusing namespace std;\nmt19937 Rand(chrono::steady_clock::now().time_since_epoch().count());\nint read() {\n    int x = 0, w = 0;\n    char ch = getchar();\n\n    while (!isdigit(ch))\n        w |= ch == '-', ch = getchar();\n\n    while (isdigit(ch))\n        x = x * 10 + ch - '0', ch = getchar();\n\n    return w ? -x : x;\n}\nint main() {\n    int T = read();\n\n    while (T--) {\n        int n = read();\n        vector<int> a, b;\n        ru(i, 1, n) a.push_back(read());\n        ru(i, 1, n) b.push_back(read());\n\n        if (a == b) {\n            printf(\"Bob\\n\");\n            continue;\n        }\n\n        reverse(a.begin(), a.end());\n\n        if (a == b) {\n            printf(\"Bob\\n\");\n            continue;\n        }\n\n        printf(\"Alice\\n\");\n    }\n\n    return 0;\n}"
    },
    "2000D": {
        "title": "D. Right Left Wrong",
        "description": "Vlad found a strip of n cells, numbered from left to right from 1 to n. In the i-th cell, there is a positive integer ai and a letter si, where all si are either 'L' or 'R'.\nVlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.\nIn one operation, you can choose two indices l and r (1\u2264l<r\u2264n) such that sl = 'L' and sr = 'R' and do the following:\nFor example, consider the following strip:\nYou can first choose l=1, r=2 and add 3+5=8 to your score.\nThen choose l=3, r=6 and add 1+4+3+2=10 to your score.\nAs a result, it is impossible to perform another operation, and the final score is 18.\nWhat is the maximum score that can be achieved?\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the strip.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264105)\u00a0\u2014 the numbers written on the strip.\nThe third line of each test case contains a string s of n characters 'L' and 'R'.\nIt is guaranteed that the sum of the values of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the maximum possible number of points that can be scored.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solutions": "2000D - Right Left WrongNote that since all characters of the selected segment of the string s are erased after applying the operation, the segments we choose cannot overlap. However, they can be nested if we first choose an inner segment and then an outer one.Since all numbers in the array are positive, it is always beneficial to take the largest possible segment in the answer, that is, from the first 'L' to the last 'R'. By choosing this segment, we can only select segments within it. We will continue to choose such segments within the last selected one as long as possible. To quickly find the sums of the segments, we will calculate the prefix sums of the array a. Solutiondef solve():\n    n = int(input())\n    a = [0]\n    for x in input().split():\n        x = int(x)\n        a.append(a[-1] + x)\n    s = input()\n    ans = 0\n    l = 0\n    r = n - 1\n    while r > l:\n        while l < n and s[l] == 'R':\n            l += 1\n        while r >= 0 and s[r] == 'L':\n            r -= 1\n        if l < r:\n            ans += a[r + 1] - a[l]\n            l += 1\n            r -= 1\n    print(ans)\n \nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "2000C": {
        "title": "C. Numeric String Template",
        "description": "Kristina has an array a, called a template, consisting of n integers. She also has m strings, each consisting only of lowercase Latin letters. The strings are numbered from 1 to m. She wants to check which strings match the template.\nA string s is considered to match the template if all of the following conditions are simultaneously satisfied: \nFor example, if a = [3,5,2,1,3], then the string \"abfda\" matches the template, while the string \"afbfa\" does not, since the character \"f\" corresponds to both numbers 1 and 5.\nThe first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe following descriptions are for the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in the array a.\nThe second line of each test case contains exactly n integers ai (\u2212109\u2264ai\u2264109) \u2014 the elements of the array a.\nThe third line of each test case contains a single integer m (1\u2264m\u22642\u22c5105) \u2014 the number of strings to check for template matching.\nFollowing are m strings, each containing a non-empty string sj (1\u2264|sj|\u22642\u22c5105), consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105, and that the sum of the lengths of all strings does not exceed 2\u22c5105.\nFor each test case, output m lines. On the i-th line (1\u2264i\u2264m) output: \nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nThe first test case is explained in the problem statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "strings",
            "*1000"
        ],
        "solutions": "2000C - Numeric String TemplateIdea: myav TutorialTutorial is loading... Solutiondef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    for _ in range(m):\n        m_1 = {}\n        m_2 = {}\n        s = input().strip()\n        if len(s) != n:\n            print(\"NO\")\n            continue\n \n        ok = True\n        for j in range(n):\n            if s[j] not in m_1 and a[j] not in m_2:\n                m_1[s[j]] = a[j]\n                m_2[a[j]] = s[j]\n            elif (s[j] in m_1 and m_1[s[j]] != a[j]) or (a[j] in m_2 and m_2[a[j]] != s[j]):\n                ok = False\n                break\n        print(\"YES\" if ok else \"NO\")\n \nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "1999D": {
        "title": "D. Slavic's Exam",
        "description": "Slavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\nThere exists a string s, which consists of lowercase English letters and possibly zero or more \"?\". \nSlavic is asked to change each \"?\" to a lowercase English letter such that string t becomes a subsequence (not necessarily continuous) of the string s. \nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\nThe first line contains a single integer T (1\u2264T\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single string s (1\u2264|s|\u22642\u22c5105, and s consists only of lowercase English letters and \"?\"-s) \u00a0\u2013 the original string you have.\nThe second line of each test case contains a single string t (1\u2264|t|\u2264|s|, and t consists only of lowercase English letters) \u00a0\u2013 the string that should be a subsequence of string s.\nThe sum of |s| over all test cases doesn't exceed 2\u22c5105, where |x| denotes the length of the string x.\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\nOtherwise, output \"YES\" (without quotes). Then, output one line\u00a0\u2014 the string that respects all conditions.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nIf multiple answers are possible, you can output any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1999D - Slavic's ExamLet's use a greedy strategy with two pointers, one at the start of s (called i) and one at the start of t (called j). At each step, advance i by 1. If si=?, then we set it to tj and increment j. If si=tj then we also increment j (because there is a match).It works because if there is ever a question mark, it never makes it worse to match the current character in t earlier than later. The complexity is O(n). Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int test_cases; cin >> test_cases;\n    while(test_cases--) {\n        string s, t; cin >> s >> t;\n    \tint idx = 0;\n    \n    \tfor(int i = 0; i < (int)s.size(); ++i) {\n    \t\tif(s[i] == '?') {\n    \t\t\tif(idx < (int)t.size()) s[i] = t[idx++];\n    \t\t\telse s[i] = 'a';\n    \t\t} else if(s[i] == t[idx]) ++idx;\n    \t}\n    \tif(idx >= t.size()) cout << \"YES\\n\" << s << \"\\n\";\n    \telse cout << \"NO\\n\";\n    }\n}"
    },
    "1999B": {
        "title": "B. Card Game",
        "description": "Suneet and Slavic play a card game. The rules of the game are as follows:\nSince Suneet and Slavic aren't best friends, you need to calculate the number of ways the game could happen that Suneet would end up as the winner.\nFor a better understanding, please check the notes section.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains 4 integers a1, a2, b1, b2 (1\u2264a1,a2,b1,b2\u226410) where a1 and a2 represent the cards Suneet has, and b1 and b2 represent the cards Slavic has, respectively.\nFor each test case, output a single integer\u00a0\u2014 the number of games Suneet would win considering all possible games.\nConsider the first test case when Slavic starts with the cards that have the values 2 and 6, and Suneet starts with cards that have the values 3 and 8. The game could happen in 4 different ways:\n \n \n ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "*1000"
        ],
        "solutions": "1999B - Card GameFor each test case, we can brute force through all possible games (there are only four of them) and calculate who is the winner of the game by simulating the game. Solutiondef f(a, b):\n    if (a > b): return 1\n    if (a == b): return 0\n    if (a < b): return -1\nfor _ in range(int(input())):\n    a, b, c, d = map(int, input().split())\n    ans = 0\n    if f(a, c) + f(b, d) > 0:\n        ans += 1\n    if f(a, d) + f(b, c) > 0:\n        ans += 1\n    if f(b, c) + f(a, d) > 0:\n        ans += 1\n    if f(b, d) + f(a, c) > 0:\n        ans += 1\n    print(ans)"
    },
    "1998B": {
        "title": "B. Minimize Equal Sum Subarrays",
        "description": "You are given a permutation\u2217 p of length n.\nFind a permutation q of length n that minimizes the number of pairs (i,j) (1\u2264i\u2264j\u2264n) such that pi+pi+1+\u2026+pj=qi+qi+1+\u2026+qj.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains n (1\u2264n\u22642\u22c5105).\nThe following line contains n space-separated integers p1,p2,\u2026,pn (1\u2264pi\u2264n)\u00a0\u2014 denoting the permutation p of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output one line containing any permutation of length n (the permutation q) such that q minimizes the number of pairs.\nFor the first test, there exists only one pair (i,j) (1\u2264i\u2264j\u2264n) such that pi+pi+1+\u2026+pj=qi+qi+1+\u2026+qj, which is (1,2). It can be proven that no such q exists for which there are no pairs.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1998B - Minimize Equal Sum SubarraysProblem Credits: satyam343  Analysis: cry Solution We can always construct a solution such that the number of pairs (i,j) is 1 where the only pair is (1,n). There exists several constructions, such as rotating p once or increment all pi (and pi=n turns into pi=1).Consider the former construction, where q=[p2,p3,...,pn,p1]. For an arbitrarily interval [i,j], p[i..j] and q[i..j] will have exactly 1 element that's different, disregarding ordering. Since we have a permutation and all elements are distinct, the sum in the range will never be the same. The only exception is the entire array, of course. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tvector<int> p(n);\n\t\tfor(int& i: p) cin >> i;\n\t\trotate(p.begin(), p.begin() + 1, p.end());\n\t\tfor(int i: p) cout << i << \" \";\n\t\tcout << \"\\n\";\n\t}\n}"
    },
    "1997C": {
        "title": "C. Even Positions",
        "description": "Monocarp had a regular bracket sequence s of length n (n is even). He even came up with his own way to calculate its cost.\nHe knows that in a regular bracket sequence (RBS), each opening bracket is paired up with the corresponding closing bracket. So he decided to calculate the cost of RBS as the sum of distances between pairs of corresponding bracket pairs.\nFor example, let's look at RBS (())(). It has three pairs of brackets: \nUnfortunately, due to data corruption, Monocarp lost all characters on odd positions s1,s3,\u2026,sn\u22121. Only characters on even positions (s2,s4,\u2026,sn) remain. For example, (())() turned to _(_)_).\nMonocarp wants to restore his RBS by placing brackets on the odd positions. But since the restored RBS may not be unique, he wants to choose one with minimum cost. It's too hard to do for Monocarp alone, so can you help him?\nReminder: A regular bracket sequence is a string consisting of only brackets, such that this sequence, when inserted 1-s and +-s, gives a valid mathematical expression. For example, (), (()) or (()())() are RBS, while ), ()( or ())(() are not.\nThe first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105; n is even)\u00a0\u2014 the length of string s.\nThe second line of each test case contains a string s of length n, where all characters on the odd positions are '_' and all characters on the even positions are either '(' or ')'.\nAdditional constraints: \nFor each test case, print one integer\u00a0\u2014 the minimum cost of the regular bracket sequence that can be obtained from s by replacing '_'-s with brackets.\nIn the first test case, it's optimal to make s equal to (())(). The cost of s will be equal to 3+1+1=5.\nIn the second test case, the only option is to make s equal to () with cost 1.\nIn the third test case, the only possible RBS is ()()()() with cost 1+1+1+1=4.\nIn the fourth test case, it's optimal to make s equal to (())(()) with cost 3+1+3+1=8.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1100"
        ],
        "solutions": "1997C - Even PositionsLet's define a balance of a bracket sequence as the number_of_opening_brackets\u2212number_of_closing_brackets.It's a well-known fact that for RBS the balance of all its prefixes must be greater than or equal to zero and the balance of the whole string must be exactly zero. So, if we want to restore RBS from s we shouldn't break that rule.Next, let's define So as the sum of positions of the opening brackets in RBS and Sc as the sum of positions of the closing brackets in RBS.It turns out that the cost defined in the statement is just Sc\u2212So. Moreover, you can see that Sc\u2212So=2Sc\u2212n(n+1)2. It means that in order to minimize the cost, we should minimize Sc, or we should try to place closing brackets on the smaller positions.The most interesting part is that it's enough to come up with the right strategy. Let's iterate from left to right, maintaining the current balance and place the closing brackets whenever we can:   if the current balance is 0 we can't place a closing bracket, since it will make the balance negative, so we place an opening bracket;  if the current balance is bigger than 0 we place a closing bracket. Since we need to calculate the cost of the RBS, we can replace the balance counter with a stack containing positions of opening brackets that don't have a pair yet. Each time we meet an opening bracket, we'll push its position to the top of the stack, and each time we meet a closing bracket, we'll take one bracket from the top of the stack. The current balance is just the size of the stack.Here is a sketch of the proof, why the strategy above is correct.Firstly, the strategy creates RBS, because after processing a prefix of even length the current balance will be equal to either 0 or 2, while after an odd length prefix it will be always 1. At the start, the balance is 0 and we make it 1, then it either becomes 0 or 2, and in both cases we return it to 1 and so on. Since the last character is always a closing bracket, the total balance will return to 0.Secondly, to prove that the strategy minimizes the cost, we can use a standard technique of proof by contradiction: suppose there is a better answer, look at the first position of the difference: it will be ) in our string and ( in the answer. Then just find the next ) in the answer and swap them. The answer will stay RBS, while Sc will decrease\u00a0\u2014 contradiction. Solution (adedalic)import java.util.LinkedList\n \nfun main() {\n    repeat(readln().toInt()) {\n        val n = readln().toInt()\n        val s = readln()\n \n        var ans = 0L\n        val bracketPositions = LinkedList<Int>()\n        for (i in s.indices) {\n            var c = s[i]\n            if (c == '_') {\n                c = if (bracketPositions.isEmpty()) '(' else ')'\n            }\n            if (c == ')') {\n                ans += i - bracketPositions.pollLast()\n            }\n            else\n                bracketPositions.addLast(i)\n        }\n        println(ans)\n    }\n}"
    },
    "1997B": {
        "title": "B. Make Three Regions",
        "description": "There is a grid, consisting of 2 rows and n columns. Each cell of the grid is either free or blocked.\nA free cell y is reachable from a free cell x if at least one of these conditions holds: \nA connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\nFor example, consider the following layout, where white cells are free, and dark grey cells are blocked:\nThere are 3 regions in it, denoted with red, green and blue color respectively:\nThe given grid contains at most 1 connected region. Your task is to calculate the number of free cells meeting the following constraint:\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of columns.\nThe i-th of the next two lines contains a description of the i-th row of the grid\u00a0\u2014 the string si, consisting of n characters. Each character is either . (denoting a free cell) or x (denoting a blocked cell). \nAdditional constraint on the input: \nFor each test case, print a single integer\u00a0\u2014 the number of cells such that the number of connected regions becomes 3 if this cell is blocked.\nIn the first test case, if the cell (1,3) is blocked, the number of connected regions becomes 3 (as shown in the picture from the statement).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "two pointers",
            "*1100"
        ],
        "solutions": "1997B - Make Three RegionsIdea: BledDest TutorialTutorial is loading... Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<string> s(2);\n    for (auto& x : s) cin >> x;\n    int ans = 0;\n    for (int i = 1; i < n - 1; ++i) {\n      bool ok = true;\n      ok &= (s[0][i] == '.' && s[1][i] == '.');\n      ok &= (s[0][i - 1] != s[1][i - 1]);\n      ok &= (s[0][i + 1] != s[1][i + 1]);\n      ok &= (s[0][i - 1] == s[0][i + 1]);\n      ans += ok;\n    }\n    cout << ans << '\\n';\n  }\n}"
    },
    "1996C": {
        "title": "C. Sort",
        "description": "You are given two strings a and b of length n. Then, you are (forced against your will) to answer q queries.\nFor each query, you are given a range bounded by l and r. In one operation, you can choose an integer i (l\u2264i\u2264r) and set ai=x where x is any character you desire. Output the minimum number of operations you must perform such that sorted(a[l..r])=sorted(b[l..r]). The operations you perform on one query does not affect other queries.\nFor an arbitrary string c, sorted(c[l..r]) denotes the substring consisting of characters cl,cl+1,...,cr sorted in lexicographical order.\nThe first line contains t (1\u2264t\u22641000) \u2013 the number of test cases.\nThe first line of each test case contains two integers n and q (1\u2264n,q\u22642\u22c5105) \u2013 the length of both strings and the number of queries.\nThe following line contains a of length n. It is guaranteed a only contains lowercase latin letters.\nThe following line contains b of length n. It is guaranteed b only contains lowercase latin letters.\nThe following q lines contain two integers l and r (1\u2264l\u2264r\u2264n) \u2013 the range of the query.\nIt is guaranteed the sum of n and q over all test cases does not exceed 2\u22c5105.\nFor each query, output an integer, the minimum number of operations you need to perform in a new line.\nFor the first query, sorted(a[1..5])= abcde and sorted(b[1..5])= abcde, so no operations are necessary.\nFor the second query, you need to set a1= e. Then, sorted(a[1..4])=sorted(b[1..4])= bcde.",
        "time limit": "time limit per test5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ],
        "solutions": "1996C - SortProblem Credits: cry  Analysis: cry Solution For two strings to be the same after sorting, they must have the same occurrences of every possible lowercase letter. To answer the query for a range [l,r], we must ensure that after the operations, cntc=cnt2c must where cntc is the number of times character c occurs in the range for a and cnt2c is defined similarly for b. Both cntc and cnt2c can be obtained by doing prefix sums for character c specifically. Note that since there are only 26 possible c, you can afford to create 26 length n prefix sum arrays.In one operation, you can replace one occurrence of a character c with another character c2. Essentially, you are subtracting one from cntc and adding one to cntc2. Obviously, you must choose c and c2 such that cntc>cnt2c and cntc2<cnt2c2. So, we only have to focus on c or c2 since one decreasing will automatically lead to the other increase. The answer is just the sum of cntc\u2212cnt2c if cntc>cnt2c over all possible lowercase characters c. Code (C++)#include <bits/stdc++.h>\nusing namespace std; \n\nvoid solve(){\n    int n, q;\n    cin >> n >> q;\n\n    vector<vector<int>> pre1(n + 1, vector<int>(26, 0));\n    vector<vector<int>> pre2(n + 1, vector<int>(26, 0));\n\n    for (int i = 1; i <= n; i++){\n        char c;\n        cin >> c;\n        pre1[i][c - 'a']++;\n\n        for (int j = 0; j < 26; j++)\n            pre1[i][j] += pre1[i - 1][j];\n    }\n    for (int i = 1; i <= n; i++){\n        char c;\n        cin >> c;\n        pre2[i][c - 'a']++;\n\n        for (int j = 0; j < 26; j++)\n            pre2[i][j] += pre2[i - 1][j];\n    }\n    while (q--){\n        int l, r;\n        cin >> l >> r;\n\n        int dif = 0;\n\n        for (int c = 0; c < 26; c++){\n            int v1 = pre1[r][c] - pre1[l - 1][c];\n            int v2 = pre2[r][c] - pre2[l - 1][c];\n\n            dif += abs(v1 - v2);\n        }\n        cout << dif / 2 << \"\\n\";\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int tc;\n    cin >> tc;\n\n    while (tc--)\n        solve();\n}"
    },
    "1995B1": {
        "title": "B1. Bouquet (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is that in this version, the flowers are specified by enumeration.\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of n flowers in the store, each of which is characterized by the number of petals, and a flower with k petals costs k coins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has m coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains two integers n, m (1\u2264n\u22642\u22c5105,1\u2264m\u22641018)\u00a0\u2014 the number of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is the number of petals of the i-th flower in the store.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum possible number of petals in the bouquet that the girl can assemble while meeting all the conditions listed above.\nIn the first test case, you can assemble a bouquet with (1,1,2,2),(2,2,3),(1,1),(2,2). The maximum over all valid bouquets not greater than 10 is 7 for (2,2,3). In the third test case, you can assemble a bouquet with only one flower of any type, so the answer is 610. In the fourth test case, you can assemble a bouquet with (4,4,5), which gives you 13 petals, and it is the maximum amount of petals that the girl can buy.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1995B1 - Bouquet (Easy Version) HintFor each number of petals, we can bruteforce the answer for x,x+1 SolutionFirst, we can aggregate number of flowers with x petals into cx (for example, sort the array and then create array of pairs (x,cx), where cx is the length of segment with elements equal to x). Note that \u2211xcx=n. Also note that for every x we won't need more than \u230amx\u230b flowers (otherwise total number of petals will exceed m).Then we iterate through all x. Suppose that we want to assemble a bouquet with x,x+1 petals. We can bruteforce the amount of flowers with x petals in O(cx). If we have 0\u2264k1\u2264min(cx,\u230amx\u230b) flowers with x petals, we already have k1\u2217x petals. There are still m\u2212k1\u2217x coins which we can spend for flowers with x+1 petals. There are at most k2=min(cx+1,\u230am\u2212k1\u2217xx+1\u230b) flowers with x+1 petal we can buy. So we need to find maximum over all such k1\u2217x+k2\u2217(x+1). Total complexity is O(\u2211xcx)=O(n) for finding the maximum and O(nlogn) for sorting. Code272263831"
    },
    "1994B": {
        "title": "B. Fun Game",
        "description": "Vova really loves the XOR operation (denoted as \u2295). Recently, when he was going to sleep, he came up with a fun game.\nAt the beginning of the game, Vova chooses two binary sequences s and t of length n and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers 0 and 1. Vanya can choose integers l,r such that 1\u2264l\u2264r\u2264n, and for all l\u2264i\u2264r simultaneously replace si with si\u2295si\u2212l+1, where si is the i-th element of the sequence s.\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence t from the sequence s. Determine if the game will be interesting for the sequences s and t.\nEach test consists of multiple test cases. The first line contains an integer q (1\u2264q\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the sequences s and t.\nThe second line of each test case contains a binary sequence s of length n.\nThe third line of each test case contains a binary sequence t of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nIn the first test case, Vanya will not be able to change the sequence s with the only possible action of choosing l=r=1.\nIn the second test case, the sequences s and t are already equal.\nIn the third test case, Vanya can act as follows:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1994B - Fun GameIf the string s consists entirely of 0, then obviously no other string can be obtained from it, so the answer is \"Yes\" only if s=t.Otherwise, let i\u00a0\u2014 the index of the first 1 in s. Note that if there is at least one 1 in t at positions [1;i), then the answer is \"No\", since s has 0 at these positions, so some of them must be changed to 1. However, when applying the operation the first 1 from position i can change bits only at positions greater than or equal to i, i.e. it will not be possible to change 0 at positions before i.If there is only 0 at positions [1;i) in t, then it is possible to change any bit on the segment [i;n] in s to any other bit by choosing segments of length i and acting from the end, i.e. the answer is \"Yes\". Code#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    for (int i = 0; i < s.size() && s[i] == '0'; ++i) {\n        if (t[i] != '0') {\n            cout << \"NO\\n\";\n            return;\n        }\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) solve();\n}"
    },
    "1993B": {
        "title": "B. Parity and Sum",
        "description": "Given an array a of n positive integers.\nIn one operation, you can pick any pair of indexes (i,j) such that ai and aj have distinct parity, then replace the smaller one with the sum of them. More formally: \nFind the minimum number of operations needed to make all elements of the array have the same parity.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations required.\nIn the first test case, all integers already have the same parity. Therefore, no operation is needed.\nIn the third test case, we can perform two operations (1,2) and (1,3). The array a transforms as follows: a=[2,3,4]\u27f6[5,3,4]\u27f6[5,3,9].\nIn the fourth test case, an example of an optimal sequence of operations is (1,2), (1,3), (1,4), and (1,4). The array a transforms as follows: a=[3,2,2,8]\u27f6[3,5,2,8]\u27f6[3,5,5,8]\u27f6[11,5,5,8]\u27f6[11,5,5,19].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1993B - Parity and Sum Hint 1Find a way to make all the elements even. Then odd. Hint 2In the worst case, the number of operations required is the number of even elements + 1. Why? SolutionFirst, if all elements already have the same parity, we don't need to do perform any operation.Next, if the array contains both even and odd numbers. In this case, it is impossible to convert all elements to even numbers. Why?If we apply an operation on:  two odd elements, one of them remains odd. two elements of distinct parities, one of them is replaced with their sum, which is an odd number. This implies even if we want to change an odd element to even number, it fails in both ways possible.So we just want to convert all of them to odd numbers. Now come the greedy part:  even+even=even\u27f6 it doesn't reduce the number of even elements, so skip it. odd+odd=even\u27f6 this creates another even number, indeed very awful. even+odd=odd\u27f6 this is great, but only if the sum replaces the even one (which means even<odd). Let's find the largest odd element and call it s. Then traverse each even elements t in non-decreasing order and apply an operation on s and t:  If t<s, s+t becomes largest odd number. Thus, we set s:=s+t. This reduce the number of even element by 1. If t>s, before we do this operation, we need to do another on s and the largest even element to make s the largest in the array. Note that this case only happens at most once. As a result, the answer is the number of even elements (plus 1 if the second case occurs).Time complexity: O(nlogn). Code (python)t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    s = -1\n    v = []\n    for x in a:\n        if x%2 == 0:\n            v.append(x)\n        elif x > s:\n            s = x\n    v.sort()\n\n    if s == -1 or v == []:\n        print(0)\n        continue\n    \n    ans = len(v)\n    for t in v:\n        if t < s:\n            s += t\n        else:\n            ans += 1\n            break\n\n    print(ans)"
    },
    "1992D": {
        "title": "D. Test of Love",
        "description": "ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of 1 meter and a length of n meters.\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from 0 to n+1) ErnKor can swim in the water for no more than k meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the 0 and n+1 meters respectively. The river can be represented as n segments, each with a length of 1 meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows: \nDetermine if ErnKor can reach the right bank.\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains three numbers n,m,k (0\u2264k\u22642\u22c5105, 1\u2264n\u22642\u22c5105, 1\u2264m\u226410)\u00a0\u2014 the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\nThe second line of each test case contains a string a of length n. ai denotes the object located at the i-th meter. (ai\u2208{'W','C','L'})\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nLet's consider examples: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1992D - Test of LoveIdea: ArSarapkinPreparation: K1o0n TutorialIn this problem, there are two main solutions: dynamic programming and greedy algorithm.Dynamic programming solution: dpi \u2212 the minimum number of meters that need to be swum to reach the i-th cell. The base case of the dynamic programming is dp0=0. Then, the update rule is: dpi=minimum of{dpi\u22121+1min(dpj)if\u00a0Ai='W'for all\u00a0j,where:max(0,i\u2014m)\u2264j<i\u00a0and\u00a0Aj='L' Solution complexity: O(nm).Greedy algorithm solution: If we can jump, we want to jump to the shore if possible. If we can't, we want to jump to any log ahead to jump from it later. If we can't, we jump as far as possible to avoid crocodiles and swim as little as possible.Solution complexity: O(n). Solution (greedy)def run() -> None:\n    n,m,k = map(int, input().split())\n    A = input()\n    logs = [i for i in range(n) if A[i] == \"L\"]\n    logs.append(n+1)\n    i = -1\n    next_log = 0\n    while i < n-1:\n        if m >= logs[next_log] - i:\n            i = logs[next_log]\n        else:\n            i+=m\n            if i > n-1:\n                print(\"YES\")\n                return\n            while i < n and i < logs[next_log]:\n                if A[i] != \"C\" and k > 0:\n                    i+=1\n                    k-=1\n                else:\n                    print(\"NO\")\n                    return\n        next_log +=1\n    print(\"YES\")\n \nfor _ in range(int(input())):\n    run() Solution (DP)#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m, k; \n        cin >> n >> m >> k;\n        string s;\n        cin >> s;\n        vector<int> dp(n + 2, -1);\n        dp[0] = k;\n        for (int i = 1; i <= n + 1; i++) {\n            if (i != n + 1 && s[i - 1] == 'C') \n                continue;\n            for (int t = 1; t <= m; t++)\n                if (i - t >= 0 && (i - t == 0 || s[i - t - 1] == 'L'))\n                    dp[i] = max(dp[i], dp[i - t]);\n            if (i > 1 && s[i - 2] == 'W') \n                dp[i] = max(dp[i], dp[i - 1] - 1);\n        }\n        if (dp[n + 1] >= 0) \n            cout << \"YES\\n\";\n        else \n            cout << \"NO\\n\";\n    }\n}"
    },
    "1991B": {
        "title": "B. AND Reconstruction",
        "description": "You are given an array b of n\u22121 integers.\nAn array a of n integers is called good if bi=ai&ai+1 for 1\u2264i\u2264n\u22121, where & denotes the bitwise AND operator.\nConstruct a good array, or report that no good arrays exist.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n\u22121 integers b1,b2,\u2026,bn\u22121 (0\u2264bi<230)\u00a0\u2014 the elements of the array b.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u22121 if no good arrays exist. \nOtherwise, output n space-separated integers a1,a2,\u2026,an (0\u2264ai<230)\u00a0\u2014 the elements of a good array a.\nIf there are multiple solutions, you may output any of them.\nIn the first test case, b=[1]. A possible good array is a=[5,3], because a1&a2=5&3=1=b1.\nIn the second test case, b=[2,0]. A possible good array is a=[3,2,1], because a1&a2=3&2=2=b1 and a2&a3=2&1=0=b2.\nIn the third test case, b=[1,2,3]. It can be shown that no good arrays exist, so the output is \u22121.\nIn the fourth test case, b=[3,5,4,2]. A possible good array is a=[3,7,5,6,3].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1991B - AND Reconstruction IdeaFind minimum possible value of each Ai, then check if it gives you B Video editorial"
    },
    "1990B": {
        "title": "B. Array Craft",
        "description": "For an array b of size m, we define:\nYou are given three integers n, x, and y (x>y). Construct an array a of size n satisfying:\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nFor each test case: \nIt is guaranteed that the sum of n over all test cases will not exceed 105.\nFor each test case, output n space-separated integers a1,a2,\u2026,an in a new line.\nIn the second test case, \nThus, the array a=[1,\u22121,1,1] is considered correct.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1989B": {
        "title": "B. Substring and Subsequence",
        "description": "You are given two strings a and b, both consisting of lowercase Latin letters. \nA subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string. A substring of a string is a contiguous subsequence of that string.\nFor example, consider the string abac:\nYour task is to calculate the minimum possible length of the string that contains a as a substring and b as a subsequence.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a string a (1\u2264|a|\u2264100), consisting of lowercase Latin letters.\nThe second line of each test case contains a string b (1\u2264|b|\u2264100), consisting of lowercase Latin letters.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible length of the string that contains a as a substring and b as a subsequence.\nIn the examples below, the characters that correspond to the subsequence equal to b are bolded.\nIn the first example, one of the possible answers is caba.\nIn the second example, one of the possible answers is ercf.\nIn the third example, one of the possible answers is mmm.\nIn the fourth example, one of the possible answers is contest.\nIn the fifth example, one of the possible answers is abcdefg.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1200"
        ],
        "solutions": "1989B \u2014 Substring and Subsequence"
    },
    "1987C": {
        "title": "C. Basil's Garden",
        "description": "There are n flowers in a row, the i-th of them initially has a positive height of hi meters.\nEvery second, the wind will blow from the left, causing the height of some flowers to decrease.\nSpecifically, every second, for each i from 1 to n, in this order, the following happens: \nHow many seconds will pass before hi=0 for all 1\u2264i\u2264n for the first time?\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of flowers.\nThe second line of each test case contains n integers h1,h2,\u2026,hn (1\u2264hi\u2264109)\u00a0\u2014 the heights of the flowers.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer\u00a0\u2014 the number of seconds that will pass before hi=0 for all 1\u2264i\u2264n. \nIn the first test case, the flower heights change as follows: [1,1,2]\u2192[1,1,1]\u2192[1,1,0]\u2192[1,0,0]\u2192[0,0,0].\nIn the second test case, the flower heights change as follows: [3,1]\u2192[2,0]\u2192[1,0]\u2192[0,0].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1200"
        ],
        "solutions": "1987C - Basil's GardenFirst, let's try to find when hn will first be equal to zero. The answer is clearly hn.Suppose for some 2\u2264i\u2264n we know that hi will first become equal to zero at time ti (tn=hn). If at some point in time, hi\u22121 was equal to hi (at the start of the second and before they are both equal to zero), ti\u22121 is equal to ti+1. Since after that point in time, if hi decreases, hi\u22121 must decrease in the next second. If hi\u22121 is never equal to hi (until they hit zero), hi\u22121 must always be strictly greater than hi. This means that hi\u22121 will keep decreasing every second until it hits zero, so ti\u22121 is equal to hi\u22121 in this case.Examples:   The array [2,3,1,1,1] changes as follows: [2,3,1,1,1]\u2192[2,2,1,1,0]\u2192[2,1,1,0,0]\u2192 [1,1,0,0,0]\u2192[1,0,0,0,0]\u2192[0,0,0,0,0]. If we focus on the first two elements, they change as follows: [2,3]\u2192[2,2]\u2192[2,1]\u2192[1,1]\u2192[1,1]\u2192[1,0]\u2192[0,0].  The array [4,1,1] changes as follows: [4,1,1]\u2192[3,1,0]\u2192[2,0,0]\u2192[1,0,0]\u2192[0,0,0]. Let's combine the two cases. If initially hi\u22121\u2264hi holds, hi\u22121 will become equal to hi at some point in time, so ti\u22121=ti+1. Else, hi\u22121>hi, so ti\u22121=hi\u22121. Combining the two, we get ti\u22121=max(hi\u22121,ti+1).Since we know tn=hn, we can easily calculate all the other values of ti by iterating from n\u22121 to 1. The answer to the problem is t1, since ti\u22121\u2265ti+1 for all 2\u2264i\u2264n.Complexity: O(n) Solution#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define allr(x) (x).rbegin(), (x).rend()\n\nconst char nl = '\\n';\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    vector<int> h(n);\n    for (auto &x: h) cin >> x;\n    \n    int ans = h[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        ans = max(ans + 1, h[i]);\n    }\n\n    cout << ans << nl;\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n    \n    int T;\n    cin >> T;\n    while (T--) solve();\n} Feedback Good problem \n\n    \n\n\n387\n\n\n\n Average problem \n\n    \n\n\n42\n\n\n\n Bad problem \n\n    \n\n\n317\n\n\n\n "
    },
    "1987B": {
        "title": "B. K-Sort",
        "description": "You are given an array of integers a of length n. \nYou can apply the following operation any number of times (maybe, zero): \nFind the minimum number of coins needed to make a non-decreasing. That is, a1\u2264a2\u2264\u2026\u2264an.\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of coins needed to make a non-decreasing.\nIn the first test case, a is already sorted, so you don't have to spend any coins.\nIn the second test case, the optimal sequence of operations is: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1987B - K-SortSuppose that after all of the operations, the value at index $$$i$$$ has been increased by $$$b_i$$$. Notice that our cost can be factored into two parts: $$$k$$$ is responsible for how many elements we choose, and $$$1$$$ is responsible for how many operations we apply.Since we have to apply at least $$$\\max(b_i)$$$ operations, and over all operations we select a total of $$$\\sum{b_i}$$$ elements, we have to pay at least $$$\\sum{b_i} + \\max(b_i)$$$ coins. This bound is also achievable, if on the $$$m$$$-th operation (numbered from $$$1$$$ to $$$\\max(b_i)$$$) we select all indices with $$$b_i \\ge m$$$.Suppose the resulting array is sorted ($$$a_1 + b_1 \\le a_2 + b_2 \\le \\ldots \\le a_n + b_n$$$). Then, $$$a_i + b_i \\le a_j + b_j$$$ must hold for all $$$1 \\le i \\le j \\le n$$$. Using $$$b_i \\ge 0$$$, we get $$$a_j + b_j \\ge a_i + b_i \\ge a_i \\implies b_j \\ge a_i - a_j$$$ for all $$$1 \\le i \\le j$$$. If we define $$$p_j := max(a_1, \\ldots, a_j)$$$, we get $$$b_j \\ge p_j - a_j$$$. This gives the lower bounds $$$\\sum{b_i} \\ge \\sum(p_i - a_i)$$$ and $$$\\max(b_i) \\ge \\max(p_i - a_i)$$$. Setting $$$b_i := p_i - a_i$$$ achieves them, so the answer to our problem is $$$\\sum(p_i - a_i) + \\max(p_i - a_i)$$$ coins.Complexity: $$$\\mathcal{O}(n)$$$Note: it's possible to simulate the process on the values of $$$b$$$ (described above) in $$$\\mathcal{O}(n \\log n)$$$. Solution#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define allr(x) (x).rbegin(), (x).rend()\n\nconst char nl = '\\n';\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    vector<int> a(n);\n    for (int i = 0; i < n; i++) cin >> a[i];\n    \n    ll pref_max = 0, s = 0, mx = 0;\n    for (int i = 0; i < n; i++) {\n        pref_max = max(pref_max, (ll) a[i]);\n        \n        ll d = pref_max - a[i];\n        s += d;\n        mx = max(mx, d);\n    }\n    \n    cout << s + mx << nl;\n}\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n    \n    int T;\n    cin >> T;\n    while (T--) {\n        solve();\n    }\n} Feedback Good problem \n\n    \n\n\n357\n\n\n\n Average problem \n\n    \n\n\n60\n\n\n\n Bad problem \n\n    \n\n\n46\n\n\n\n "
    },
    "1986C": {
        "title": "C. Update Queries",
        "description": "Let's consider the following simple problem. You are given a string s of length n, consisting of lowercase Latin letters, as well as an array of indices ind of length m (1\u2264indi\u2264n) and a string c of length m, consisting of lowercase Latin letters. Then, in order, you perform the update operations, namely, during the i-th operation, you set sindi=ci. Note that you perform all m operations from the first to the last.\nOf course, if you change the order of indices in the array ind and/or the order of letters in the string c, you can get different results. Find the lexicographically smallest string s that can be obtained after m update operations, if you can rearrange the indices in the array ind and the letters in the string c as you like.\nA string a is lexicographically less than a string b if and only if one of the following conditions is met:\nEach test consists of several sets of input data. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains two integers n and m (1\u2264n,m\u2264105)\u00a0\u2014 the length of the string s and the number of updates.\nThe second line of each set of input data contains a string s of length n, consisting of lowercase Latin letters.\nThe third line of each set of input data contains m integers ind1,ind2,\u2026,indm (1\u2264indi\u2264n)\u00a0\u2014 the array of indices ind.\nThe fourth line of each set of input data contains a string c of length m, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n over all sets of input data does not exceed 2\u22c5105. Similarly, the sum of m over all sets of input data does not exceed 2\u22c5105.\nFor each set of input data, output the lexicographically smallest string s that can be obtained by rearranging the indices in the array ind and the letters in the string c as you like.\nIn the first set of input data, you can leave the array ind and the string c unchanged and simply perform all operations in that order.\nIn the second set of input data, you can set the array ind=[1,1,4,2] and c= \"zczw\". Then the string s will change as follows: meow\u2192zeow\u2192ceow\u2192ceoz\u2192cwoz.\nIn the third set of input data, you can leave the array ind unchanged and set c= \"admn\". Then the string s will change as follows: abacaba\u2192abacaba\u2192abdcaba\u2192abdcmba\u2192abdcmbn.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1986C \u2014 Update Queries"
    },
    "1986B": {
        "title": "B. Matrix Stabilization",
        "description": "You are given a matrix of size n\u00d7m, where the rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right. The element at the intersection of the i-th row and the j-th column is denoted by aij.\nConsider the algorithm for stabilizing matrix a:\nIn this problem, cells (a,b) and (c,d) are considered neighbors if they share a common side, i.e., |a\u2212c|+|b\u2212d|=1.\nYour task is to output the matrix a after the stabilization algorithm has been executed. It can be shown that this algorithm cannot run for an infinite number of iterations.\nEach test consists of multiple sets of input data. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of sets of input data. This is followed by their description.\nThe first line of each set of input data contains two integers n and m (1\u2264n,m\u2264100,n\u22c5m>1)\u00a0\u2014 the number of rows and columns of matrix a. \nThe next n lines describe the corresponding rows of the matrix. The i-th line contains m integers ai1,ai2,\u2026,aim (1\u2264aij\u2264109).\nIt is guaranteed that the sum of n\u22c5m over all sets of input data does not exceed 2\u22c5105.\nFor each set of input data, output n lines with m numbers in each line\u00a0\u2014 the values of the cells of matrix a after the stabilization algorithm.\nIn the first set of input data, the algorithm will select the cell (1,1) twice in a row and then terminate. \nIn the second set of input data, there is no cell whose value is strictly greater than the values of all neighboring cells.\nIn the third set of input data, the algorithm will select the cell (2,2) and then terminate. \nIn the fourth set of input data, the algorithm will select the cell (1,1) three times and then the cell (2,3) twice.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1986B \u2014 Matrix Stabilization"
    },
    "1985E": {
        "title": "E. Secret Box",
        "description": "Ntarsis has a box B with side lengths x, y, and z. It lies in the 3D coordinate plane, extending from (0,0,0) to (x,y,z). \nNtarsis has a secret box S. He wants to choose its dimensions such that all side lengths are positive integers, and the volume of S is k. He can place S somewhere within B such that: \nS is magical, so when placed at an integer location inside B, it will not fall to the ground. \nAmong all possible ways to choose the dimensions of S, determine the maximum number of distinct locations he can choose to place his secret box S inside B. Ntarsis does not rotate S once its side lengths are selected.\nThe first line consists of an integer t, the number of test cases (1\u2264t\u22642000). The description of the test cases follows.\nThe first and only line of each test case contains four integers x,y,z and k (1\u2264x,y,z\u22642000, 1\u2264k\u2264x\u22c5y\u22c5z).\nIt is guaranteed the sum of all x, sum of all y, and sum of all z do not exceed 2000 over all test cases.\nNote that k may not fit in a standard 32-bit integer data type.\nFor each test case, output the answer as an integer on a new line. If there is no way to select the dimensions of S so it fits in B, output 0.\nFor the first test case, it is optimal to choose S with side lengths 2, 2, and 2, which has a volume of 2\u22c52\u22c52=8. It can be shown there are 8 ways to put S inside B.\nThe coordinate with the least x, y, and z values for each possible arrangement of S are: \nThe arrangement of S with a coordinate of (0,0,0) is depicted below:\nFor the second test case, S with side lengths 2, 3, and 3 are optimal.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "math",
            "*1200"
        ],
        "solutions": "1985E - Secret BoxProblem Credits: cry  Analysis: cry SolutionSince the side lengths of S has to multiply to k, all three side lengths of S has to be divisors of k. Let's denote the side lengths of S along the x, y, and z axes as a, b, and c respectively. For S to fit in B , a\u2264x, b\u2264y, and c\u2264z must hold. Because of the low constraints, we can afford to loop through all possible values of a and b, and deduce that c=ka\u22c5b (make sure c\u2264z and c is an integer). To get the amount of ways we can place S, we can just multiply the amount of shifting space along each axes, and that just comes down to (x\u2212a+1)\u22c5(y\u2212b+1)\u22c5(z\u2212c+1). The answer is the maximum among all possible values of a, b, and c . The time complexity is O(n2) where n is at most 2000. Code (C++)#include <iostream>\nusing namespace std;\nusing ll = long long;\n\nint main(){\n\tint t; cin >> t;\n\twhile(t--){\n\t\tll x, y, z, k; cin >> x >> y >> z >> k;\n\t\tll ans = 0;\n\t\tfor(int a = 1; a <= x; a++){\n\t\t\tfor(int b = 1; b <= y; b++){\n\t\t\t\tif(k % (a * b)) continue;\n\t\t\t\tll c = k / (a * b);\n\t\t\t\tif(c > z) continue;\n\t\t\t\tll ways = (ll)(x - a + 1) * (y - b + 1) * (z - c + 1);\n\t\t\t\tans = max(ans, ways);\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}"
    },
    "1985C": {
        "title": "C. Good Prefixes",
        "description": "Alex thinks some array is good if there exists some element that can be represented as the sum of all other elements (the sum of all other elements is 0 if there are no other elements). For example, the array [1,6,3,2] is good since 1+3+2=6. Furthermore, the array [0] is also good. However, the arrays [1,2,3,4] and [1] are not good.\nAlex has an array a1,a2,\u2026,an. Help him count the number of good non-empty prefixes of the array a. In other words, count the number of integers i (1\u2264i\u2264n) such that the length i prefix (i.e. a1,a2,\u2026,ai) is good.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output a single integer \u2014 the number of good non-empty prefixes of the array a.\nIn the fourth test case, the array has five prefixes: \nAs you can see, three of them are good, so the answer is 3.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1985C - Good PrefixesProblem Credits: sum  Analysis: cry SolutionThe only element that can be the sum of all other elements is the maximum element, since all elements are positive. Therefore, for each prefix i from 1 to n, check if sum(a1,a2,...,ai)\u2212max(a1,a2,...,ai)=max(a1,a2,...,ai). The sum and max of prefixes can be tracked with variables outside the loop. Code (C++)#include <iostream>\nusing namespace std;\n\nint main(){\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n; cin >> n;\n\t\tint a[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tlong long sum = 0;\n\t\tint mx = 0, ans = 0;;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t\tmx = max(mx, a[i]);\n\t\t\tif(sum - mx == mx) \n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
    },
    "1984B": {
        "title": "B. Large Addition",
        "description": "A digit is large if it is between 5 and 9, inclusive. A positive integer is large if all of its digits are large.\nYou are given an integer x. Can it be the sum of two large positive integers with the same number of digits?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer x (10\u2264x\u22641018).\nFor each test case, output YES if x satisfies the condition, and NO otherwise.\nYou can output YES and NO in any case (for example, strings yES, yes, and Yes will be recognized as a positive response).\nIn the first test case, we can have 658+679=1337.\nIn the second test case, it can be shown that no numbers of equal length and only consisting of large digits can add to 200.\nIn the third test case, we can have 696969+696969=1393938.\nIn the fourth test case, we can have 777+657=1434.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1984B - Large AdditionProblem Credits: flamestorm Analysis: null_aweSolution 1 Hint 1What must the first (largest) digit be? Hint 2What must the other non-unit digits be? Hint 3What must the last digit be? SolutionBecause every digit is large, every two digits being added together will carry to the next digit. The two addends have the same length, so the sum must be one greater in length, with the largest digit equal to 1.For all other digits except for the units digit, we have the value to be the sum of two large digits, plus 1 being carried over from the previous column. This makes the acceptable range of values be from 1 to 9, inclusive.For the units digit, there is no previous column to carry over a 1, so the acceptable range of values is from 0 to 8, inclusive. Code (C++)#include <iostream>\nusing namespace std;\n \n#define ll long long\n \nvoid solve() {\n  ll n; cin >> n;\n  n = n - n % 10 + (n % 10 + 1) % 10;\n  while (n > 9) {\n    if (n % 10 == 0) {\n      cout << \"NO\\n\";\n      return;\n    }\n    n /= 10;\n  }\n  cout << (n == 1 ? \"YES\\n\" : \"NO\\n\");\n}\n \nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(NULL);\n  int t; cin >> t;\n  for (int i = 0; i < t; ++i) solve();\n  return 0;\n}\n\n"
    },
    "1983B": {
        "title": "B. Corner Twist",
        "description": "You are given two grids of numbers a and b, with n rows and m columns. All the values in the grid are 0, 1 or 2.\nYou can perform the following operation on a any number of times: \nNote that the operation only changes the values of the corners of the picked subrectangle.\nIs it possible to convert the grid a into grid b by applying the above operation any number of times (possibly zero)?\nThe first line contains an integer t, the number of testcases (1\u2264t\u2264250).\nFor each testcase:\nThe first line contains two integers n and m, the number of rows and columns in the grid (2\u2264n,m\u2264500).\nEach of the next n lines contain m characters \u2014 the j-th character of the i-th line represents ai,j.\nEach of the next n lines contain m characters \u2014 the j-th character of the i-th line represents bi,j (0\u2264ai,j,bi,j\u22642).\nIt is guaranteed that the sum of n over all test cases and the sum of m over all test cases do not exceed 500.\nFor each test case print \"YES\" (without quotes) if it is possible to convert grid a into grid b and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first testcase, grid a can be converted into b in the following manner:\n000000000\u21d2102000201\u21d2102012222\u21d2102102102\u21d2111102120\u21d2111111111\nHere, in each operation, the top-right and bottom-left corners highlighted by a box are incremented by 2 modulo 3, while the top-left and bottom-right corners are incremented by 1 modulo 3.\nIn the fourth testcase, it can be proven that it is not possible to convert grid a into grid b using the above-mentioned operations any number of times.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1983B - Corner TwistNotice how the operations affect each row and column. The problem offers a really simple solution: the sum of each row and each column modulo 3 needs to remain constant throughout all the operations. It is easy to see that this is a necessary condition. Let's prove that this is sufficient as well.Notice that using the 2x2 versions of the operations defined in the statement, i.e., addition of 1221 or 2112 along the corners of a 2x2 square can be used to generate the same result as the operation applied on any rectangle. For instance, we can combine two 2x2 operations sideways to get a 2x3 operation:122+11+221\u2261120021(mod3) Let the grid a and b have n rows and m columns, you can iterate over i thorugh 1\u2026n\u22121 and for i's each iteration, j through 1\u2026m\u22121.   If a[i][j]+1\u2261b[i][j](mod3), add 1221 to the subrectange of a starting at a[i[j]. If a[i][j]+2\u2261b[i][j](mod3), add 2112 to the subrectange of a starting at a[i[j]. Make no changes otherwise. We see that it is always possible to make all the elements in the first n\u22121 rows and m\u22121 columns equal using this method. Note that the sum of each row and each column stays constant after each operation. If b is derived from a using these operations, then all the values for the remaining n+m\u22121 elements of the grid can be uniquely determined using the row and column sums and need to be equal. Hence, proving sufficiency. Implementation (C++)269329137 Implementation (Python)269329083 Feedback \n\n\n\n278\n\n\n\n\n\n Good problem \n\n\n\n29\n\n\n\n\n\n Average problem \n\n\n\n397\n\n\n\n\n\n Bad problem \n\n\n\n59\n\n\n\n\n\n Did not solve "
    },
    "1982C": {
        "title": "C. Boring Day",
        "description": "On another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.\nEgor has a deck of n cards, the i-th card from the top has a number ai written on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between l and r, inclusive, the round is won; otherwise, it is lost. \nEgor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.\nEach test consists of several test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains three integers n, l, and r (1\u2264n\u2264105, 1\u2264l\u2264r\u2264109).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the numbers on the cards from top to bottom.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output a single number\u00a0\u2014 the maximum number of rounds Egor can win.\nIn the first test case, Egor can win 3 rounds:\nIn the second test case, Egor cannot win any rounds, no matter how hard he tries.\nIn the third test case, you can take one card in each round, then the first and third rounds will be losing, and the second round will be winning.\nIn the fourth test case, you can take two cards in each round and always win.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "two pointers",
            "*1200"
        ],
        "solutions": "1982C - Boring DaySolution 1:Let dp[i]\u00a0\u2014 the maximum number of rounds won by Egor for the first i elements (top cards). It is possible to come up with a solution in O(n2) right now. For each state of the dynamic programming i, you can either skip the next card (not take it in any winning segment), or iterate over the length of the segment that will start with the next card. If you calculate prefix sums and compute the sum over a segment in O(1), the solution works exactly in O(n2).Let's try to optimize the transitions in such a dynamic.First, it can be noticed that all ai are positive, which means that the sum of the segment (a,b) will be less than (a,b+1). This means that the first suitable segment (with a sum \u2265l) can be found using binary search or two pointers.Secondly, if the segment has a suitable sum (from l to r), it does not make sense to increase its length, as this can only worsen the answer.Thus, for each state of the dynamic programming, there are only O(1) transitions, so the entire problem can be solved in O(n) or O(nlogn).Solution 2:Let's try to solve the problem greedily. Let's look for a segment (a,b) in the prefix such that the sum of all its elements is not less than l and not greater than r, and among all such segments, we will take the segment with the minimum b. After that, we will consider that the array starts from the (b+1)-th element and continue to search for the next segment in the same way.How to find (a,b)? Let's start by finding the minimum prefix k (which is also the segment (1,k)) such that the sum of the elements in it is \u2265l. If this sum is also not greater than r, then this prefix is the segment we need (a,b). Otherwise, we know that the sum of the elements in any subsegment of this prefix that does not contain the last element ak is less than l, so we can try to find a subsegment that ends at k, for this, we can iterate over the left boundary from 1 to k. At the same time, the sum of the elements in the iterated segment will decrease and it may happen again that at some point it becomes <l, in this case, we already know that we will not find the required segment with the right boundary k, so it needs to be increased (again until the sum becomes \u2265l). By repeating these actions, we will either find the required segment (a,b), or the right boundary will become equal to n. The algorithm is nothing but \"two pointers\", we keep two boundaries l and r and move them only to the right, so in total, this all works in O(n). Solution 1 (FelixArg)#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int inf = 1000000007;\n \nvoid solve(){\n\tint n, l, r;\n\tcin >> n >> l >> r;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> a[i];\n\t}\n \n\tvector<long long> pref(n + 1);\n\tfor (int i = 0; i < n; i++){\n\t\tpref[i + 1] = pref[i] + a[i];\n\t}\n \n\tvector<int> dp(n + 1);\n\tint s = 0;\n\tint j = -1;\n\tfor (int i = 0; i < n; i++){\n\t\tdp[i + 1] = max(dp[i + 1], dp[i]);\n\t\tif (j < i){\n\t\t\tj = i;\n\t\t\ts = 0;\n\t\t}\n\t\twhile(j < n && s < l){\n\t\t\ts += a[j++];\n\t\t}\n\t\tif (s >= l && s <= r){\n\t\t\tdp[j] = max(dp[j], dp[i] + 1);\n\t\t}\n\t\ts -= a[i];\n\t}\n \n\tcout << dp[n] << '\\n';\n}\n \nint main()\n{\n#ifdef FELIX\n\tauto _clock_start = chrono::high_resolution_clock::now();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint tests = 1;\n\tcin >> tests;\n\tfor (int test = 0; test < tests; test++){\n\t\tsolve();\n\t}\n#ifdef FELIX\n\tcerr << \"Executed in \" << chrono::duration_cast<chrono::milliseconds>(\n\t\tchrono::high_resolution_clock::now()\n\t\t\t- _clock_start).count() << \"ms.\" << endl;\n#endif\n\treturn 0;\n} Solution 2 (74TrAkToR)t = int(input())\nfor T in range(t):\n\tn, l, r = map(int, input().split())\n\ta = [int(x) for x in input().split()]\n\tans = 0\n\tcur = 0\n\tL, R = 0, 0\n\twhile L < n:\n\t\twhile R < n and cur < l:\n\t\t\tcur += a[R]\n\t\t\tR += 1\n\t\tif l <= cur and cur <= r:\n\t\t\tans += 1\n\t\t\tL = R\n\t\t\tcur = 0\n\t\telse:\n\t\t\tcur -= a[L]\n\t\t\tL += 1\n\tprint(ans)"
    },
    "1982B": {
        "title": "B. Collatz Conjecture",
        "description": "Recently, the first-year student Maxim learned about the Collatz conjecture, but he didn't pay much attention during the lecture, so he believes that the following process is mentioned in the conjecture:\nThere is a variable x and a constant y. The following operation is performed k times: \nFor example, if the number x=16, y=3, and k=2, then after one operation x becomes 17, and after another operation x becomes 2, because after adding one, x=18 is divisible by 3 twice.\nGiven the initial values of x, y, and k, Maxim wants to know what is the final value of x.\nEach test consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe only line of each test case contains three integers x, y, and k (1\u2264x,k\u2264109, 2\u2264y\u2264109)\u00a0\u2014 the initial variable, constant and the number of operations.\nFor each test case, output a single integer\u00a0\u2014 the number obtained after applying k operations.\nIn the first test case, there is only one operation applied to x=1, resulting in x becoming 2.\nIn the second test case, for x=2, within one operation, one is added to x and it's divided by y=3, resulting in x becoming 1.\nIn the third test case, x changes as follows:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1982B - Collatz ConjectureLet's write down what happens in the problem and try to speed it up. The first observation: we will perform operations until $$$x \\neq 1$$$, after which the answer can be found using the formula $$$ans = 1 + k\\,\\%\\,(y - 1)$$$. Indeed, after $$$x$$$ becomes equal to $$$1$$$, if we continue applying operations to it, it will change as follows:$$$$$$ 1 \\to 2 \\to ... \\to (y - 1) \\to 1 \\to 2 \\to ... \\to (y - 1) \\to 1 \\to ... $$$$$$The second optimization is to group the operations that only add one, so instead of $$$1$$$ we will add the next value to $$$x$$$ in one action $$$min(k, \\lceil \\frac{x}{y} \\rceil \\cdot y - x)$$$. After this (if we added at least $$$1$$$), we should try to divide the number by $$$y$$$ (if it is divisible).If we use these two optimizations, our solution will work in $$$O(\\log x)$$$ for one set of input data, since in one action $$$x$$$ decreases to $$$\\lceil \\frac{x + 1}{y} \\rceil$$$, and therefore $$$x$$$ becomes $$$1$$$ in no more than $$$O(\\log x)$$$ actions. Solution (FelixArg)#include <bits/stdc++.h>\n \nusing namespace std;\n \nvoid solve(){\n\tlong long x, y, k;\n\tcin >> x >> y >> k;\n\twhile (k > 0 && x != 1) {\n\t\tlong long ost = (x / y + 1) * y - x;\n                ost = max(1ll, ost);\n                ost = min(ost, k);\n                x += ost;\n\t\twhile (x % y == 0) {\n\t\t\tx /= y;\n\t\t}\n\t\tk -= ost;\n\t}\n\tcout << x + k % (y - 1) << '\\n';\n}\n \nint main()\n{\n#ifdef FELIX\n\tauto _clock_start = chrono::high_resolution_clock::now();\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n \n\tint tests = 1;\n\tcin >> tests;\n\tfor (int test = 0; test < tests; test++){\n\t\tsolve();\n\t}\n \n#ifdef FELIX\n\tcerr << \"Executed in \" << chrono::duration_cast<chrono::milliseconds>(\n\t\tchrono::high_resolution_clock::now()\n\t\t\t- _clock_start).count() << \"ms.\" << endl;\n#endif\n\treturn 0;\n}"
    },
    "1979C": {
        "title": "C. Earning on Bets",
        "description": "You have been offered to play a game. In this game, there are n possible outcomes, and for each of them, you must bet a certain integer amount of coins. In the event that the i-th outcome turns out to be winning, you will receive back the amount of coins equal to your bet on that outcome, multiplied by ki. Note that exactly one of the n outcomes will be winning.\nYour task is to determine how to distribute the coins in such a way that you will come out ahead in the event of any winning outcome. More formally, the total amount of coins you bet on all outcomes must be strictly less than the number of coins received back for each possible winning outcome.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226450)\u00a0\u2014 the number of outcomes.\nThe second line of each test case contains n integers k1,k2,\u2026,kn (2\u2264ki\u226420)\u00a0\u2014 the multiplier for the amount of coins if the i-th outcome turns out to be winning.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \u22121 if there is no way to distribute the coins as required. Otherwise, output n integers x1,x2,\u2026,xn (1\u2264xi\u2264109)\u00a0\u2014 your bets on the outcomes.\nIt can be shown that if a solution exists, there is always a solution that satisfies these constraints.\nIf there are multiple suitable solutions, output any of them.\nIn the first test case, the coins can be distributed as follows: 27 coins on the first outcome, 41 coins on the second outcome, 12 coins on the third outcome. Then the total amount of coins bet on all outcomes is 27+41+12=80 coins. If the first outcome turns out to be winning, you will receive back 3\u22c527=81 coins, if the second outcome turns out to be winning, you will receive back 2\u22c541=82 coins, if the third outcome turns out to be winning, you will receive back 7\u22c512=84 coins. All these values are strictly greater than 80.\nIn the second test case, one way is to bet one coin on each of the outcomes.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "constructive algorithms",
            "number theory",
            "*1200"
        ],
        "solutions": "1979C - Earning on Bets HintTry to come up with a condition for the existence of an answer. SolutionLet S be the total amount of coins placed on all possible outcomes. Then, if the coefficient for winning is ki, we have to place more than Ski on this outcome.We can obtain the following inequality:  \u2211ni=1Ski<S.Dividing both sides by S, we obtain the necessary and sufficient condition for the existence of an answer:  \u2211ni=11ki<1.This check can be performed by reducing all fractions to a common denominator. Notice that the numerators of the reduced fractions correspond to the required bets on the outcomes. Code#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\nint lcm(int a, int b) {\n    return a * b / gcd(a, b);\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    \n    vector <int> k(n);\n    for (int i = 0; i < n; i++) {\n        cin >> k[i];\n    }\n    \n    int z = 1;\n    for (int i = 0; i < n; i++) {\n        z = lcm(z, k[i]);\n    }\n    \n    int suma = 0;\n    for (int i = 0; i < n; i++) {\n        suma += z / k[i];\n    }\n    \n    if (suma < z) {\n        for (int i = 0; i < n; i++) {\n            cout << z / k[i] << \" \";\n        }\n        cout << \"\\n\";\n    } else {\n        cout << -1 << \"\\n\";\n    }\n}\n\nsigned main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}"
    },
    "1979B": {
        "title": "B. XOR Sequences",
        "description": "You are given two distinct non-negative integers x and y. Consider two infinite sequences a1,a2,a3,\u2026 and b1,b2,b3,\u2026, where\nHere, x\u2295y denotes the bitwise XOR operation of integers x and y.\nFor example, with x=6, the first 8 elements of sequence a will look as follows: [7,4,5,2,3,0,1,14,\u2026]. Note that the indices of elements start with 1.\nYour task is to find the length of the longest common subsegment\u2020 of sequences a and b. In other words, find the maximum integer m such that ai=bj,ai+1=bj+1,\u2026,ai+m\u22121=bj+m\u22121 for some i,j\u22651.\n\u2020A subsegment of sequence p is a sequence pl,pl+1,\u2026,pr, where 1\u2264l\u2264r.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers x and y (0\u2264x,y\u2264109,x\u2260y)\u00a0\u2014 the parameters of the sequences.\nFor each test case, output a single integer\u00a0\u2014 the length of the longest common subsegment.\nIn the first test case, the first 7 elements of sequences a and b are as follows:\na=[1,2,3,4,5,6,7,\u2026]\nb=[0,3,2,5,4,7,6,\u2026]\nIt can be shown that there isn't a positive integer k such that the sequence [k,k+1] occurs in b as a subsegment. So the answer is 1.\nIn the third test case, the first 20 elements of sequences a and b are as follows:\na=[56,59,58,61,60,63,62,49,48,51,50,53,52,55,54,41, 40, 43, 42,45,\u2026]\nb=[36,39,38,33,32,35,34,45,44,47,46,41, 40, 43, 42,53,52,55,54,49,\u2026]\nIt can be shown that one of the longest common subsegments is the subsegment [41,40,43,42] with a length of 4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1000"
        ],
        "solutions": "1979B - XOR Sequences HintLook at samples. SolutionConsider two numbers v and u such that x\u2295v=y\u2295u. Then consider the numbers x\u2295(v+1) and y\u2295(u+1). Let's look at the last bit of v and u. Possible scenarios:  Both bits are equal to 0 \u2014 adding one will change the bits at the same positions, therefore x\u2295(v+1)=y\u2295(u+1); Both bits are equal to 1 \u2014 adding one will change the bits at the same positions and also add one to the next bit, therefore we can similarly consider the next bit; Bits are different \u2014 adding one to the zero bit will only change one bit, while the subsequent bit of the other number will be changed. This means that x\u2295(v+1)\u2260y\u2295(u+1). It is clear that we need to maximize the number of zeros in the maximum matching suffix of u and v. Obviously, this number is equal to the maximum matching suffix of x and y. Let k be the length of the maximum matching suffix of x and y, then the answer is 2k.This can be calculated in O(logC) time for one test case, where C is the limit on x and y. Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int a, b;\n        cin >> a >> b;\n        \n        for (int i = 0; i < 30; i++) {\n            if ((a & (1 << i)) != (b & (1 << i))) {\n                cout << (1ll << i) << \"\\n\";\n                break;\n            }\n        }\n    }\n}"
    },
    "1977B": {
        "title": "B. Binary Colouring",
        "description": "You are given a positive integer x. Find any array of integers a0,a1,\u2026,an\u22121 for which the following holds: \nIt can be proven that under the constraints of the problem, a valid array always exists.\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single positive integer x (1\u2264x<230).\nFor each test case, output two lines.\nOn the first line, output an integer n (1\u2264n\u226432)\u00a0\u2014 the length of the array a0,a1,\u2026,an\u22121.\nOn the second line, output the array a0,a1,\u2026,an\u22121.\nIf there are multiple valid arrays, you can output any of them.\nIn the first test case, one valid array is [1], since (1)\u22c520=1.\nIn the second test case, one possible valid array is [0,\u22121,0,0,1], since (0)\u22c520+(\u22121)\u22c521+(0)\u22c522+(0)\u22c523+(1)\u22c524=\u22122+16=14.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1977B - Binary Colouring TutorialWe will iterate over the prefix of i bits and construct a correct answer for the number formed by the prefix bits of the number x. We are interested in considering only the one bits, as they are the only ones that affect the value of the number x.If we have already placed a one at position i in the answer, we need to somehow add 2i to the number. To do this, we simply zero out the i-th bit in the answer and set it at i+1 \u2014 this will add 2\u22c52i=2i+1.Now, the i-th position in the answer holds 0.Let's consider what we placed at position i\u22121 in the answer. If it's 0, then everything is fine; we just place 1 at position i. If it's 1, we have a situation of [1 1], which we correct by making it [-1 0 1] \u2014 placing \u22121 at i\u22121, leaving 0 at i, and placing 1 at i+1. This will add 2i to the sum because 2i+2i\u22121=2i+1\u22122i\u22121. The remaining case is when i\u22121 holds \u22121, but this is impossible because our forward operations only place ones, and \u22121 is placed behind.The final time complexity is O(log(x)) per test case. Author's code#include \"bits/stdc++.h\"\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\nmt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n \n/// Actual code starts here\nconst int N = 100005;\n \nvoid solve() {\n    ll x;\n    cin >> x;\n    vector<int> res(31, 0);\n    for (int i = 0; i < 30; i++) {\n        if (1ll & (x >> i)) {\n            if (res[i]) {\n                res[i + 1] = 1;\n                res[i] = 0;\n            } else if (i > 0) {\n                if (res[i - 1] == 1) {\n                    res[i + 1] = 1;\n                    res[i - 1] = -1;\n                } else {\n                    res[i] = 1;\n                }\n            } else if (i == 0) {\n                res[i] = 1;\n            }\n        }\n    }\n    cout << 31 << '\\n';\n    for (int i = 0; i <= 30; i++) {\n        cout << res[i] << ' ';\n    }\n    cout << '\\n';\n}\n \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int tt = 1;\n    cin >> tt;\n    while (tt--)\n        solve();\n}\n Feedback Good problem \n\n    \n\n\n344\n\n\n\n Average problem \n\n    \n\n\n25\n\n\n\n Bad problem \n\n    \n\n\n209\n\n\n\n "
    },
    "1976B": {
        "title": "B. Increase/Decrease/Copy",
        "description": "You are given two integer arrays: array aa of length nn and array bb of length n+1n+1.\nYou can perform the following operations any number of times in any order: \nYour task is to calculate the minimum number of aforementioned operations (possibly zero) required to transform the array aa into the array bb. It can be shown that under the constraints of the problem, it is always possible.\nThe first line contains a single integer tt (1\u2264t\u22641041\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input: the sum of nn over all test cases doesn't exceed 2\u22c51052\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum number of operations (possibly zero) required to transform the array aa into the array bb.\nIn the first example, you can transform aa into bb as follows: [2]\u2192[2,2]\u2192[1,2]\u2192[1,3][2]\u2192[2,2]\u2192[1,2]\u2192[1,3].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1976B - Increase/Decrease/CopyLet's fix the index of the element to be copied (denote it as i). For all other elements of the array, the number of required operations is |aj\u2212bj| for all j\u2260i.Consider the case when ai\u2264bi (similar to the case when ai\u2265bi). There are three possible relative location of the desired element bn+1:   if bn+1<ai, you can proceed as follows: copy i-th element, increase an+1 to bn+1 and increase ai to bi, then the number of operations is equal to 1+(bn+1\u2212ai)+(bi\u2212ai);  if ai\u2264bn+1\u2264bi, you can proceed as follows: increase ai to bn+1, copy it, and keep increasing to bi, then the number of operations is equal to (bn+1\u2212ai)+1+(bi\u2212bn+1)=(bi\u2212ai)+1;  if bi<bn+1, you can proceed as follows: increase ai to bi, copy i-th element, and increase an+1 to bn+1, then the number of operations is equal to (bi\u2212ai)+1+(bn+1\u2212bi). As you can see, regardless of the case, |bi\u2212ai| is also added to the answer. So the answer looks like this: \u2211j=1n|bj\u2212aj| plus some extra operations to get bn+1. That extra value is equal to the minimum value of f(i) over all indices i, where f(i) is equal to 1+|bn+1\u2212ai| or 1 or 1+|bn+1\u2212bi| depending on the cases described above. Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nusing li = long long;\n \nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<li> a(n), b(n + 1);\n    for (auto& x : a) cin >> x;\n    for (auto& x : b) cin >> x;\n    li sum = 0, ext = 1e18;\n    for (int i = 0; i < n; ++i) {\n      sum += abs(a[i] - b[i]);\n      ext = min(ext, abs(a[i] - b[n]));\n      ext = min(ext, abs(b[i] - b[n]));\n      if (min(a[i], b[i]) <= b[n] && b[n] <= max(a[i], b[i]))\n        ext = 0;\n    }\n    cout << sum + ext + 1 << '\\n';\n  }\n}"
    },
    "1975C": {
        "title": "C. Chamo and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, Chamo gave her an array a consisting of n positive integers as a gift.\nMocha doesn't like arrays containing different numbers, so Mocha decides to use magic to change the array. Mocha can perform the following three-step operation some (possibly, zero) times: \nSuppose a=[1,2,3,4,5] initially: \nMocha will perform the operation until the array contains only the same number. Mocha wants to know what is the maximum possible value of this number.\n\u2020 The median in an array b of length m is an element that occupies position number \u230am+12\u230b after we sort the elements in non-decreasing order. For example, the median of [3,1,4,1,5] is 3 and the median of [5,25,20,24] is 20.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output the maximum value of the number.\nIn the first test case, a=[1,2]. Mocha can only choose the interval (l,r)=(1,2). The array will be changed to a=[1,1]. Therefore, the answer is 1.\nIn the second test case, Mocha can perform the following operations:\nThe array contains only the same number, which is 4. It can be proven that the maximum value of the final number cannot be greater than 4.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*1200"
        ],
        "solutions": "1975C - Chamo and Mocha's ArrayIdea: Bazoka13 Solution: Bazoka13 Prepared by: Bazoka13 Hint 1If a subarray of length at least 2 contains only the same elements, we can change all elements of the array to that element by operations. Hint 2Suppose the answer is x, we can perform no more than one operation on the original array a so that there is a subarray of length at least 2 that contains only x. Hint 3If we can make all elements of a subarray become x in one operation, then there must be a subarray of length 3 with a median of y (y\u2265x). SolutionRead the hints.If n=2, the answer is the minimum element.If n\u22653, we iterate over all subarrays of length 3, and the answer is the maximum value of the median of all subarrays of length 3. Code#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+10;\nint a[N];\nint main(){\n    int n,t;\n    cin>>t;\n    while(t--){\n        cin>>n;\n        for(int i=1;i<=n;i++) \n            cin>>a[i];\n        if(n==2)cout<<min(a[1],a[2])<<\"\\n\";\n        else{\n            int ans = min(a[1],a[2]);\n            for(int i=1;i<=n-2;i++){\n                vector<int> tmp;\n                for(int k=0;k<=2;k++)\n                    tmp.push_back(a[i+k]);\n                sort(tmp.begin(),tmp.end());\n                ans = max(ans,tmp[1]);\n            }\n            cout<<ans<<\"\\n\";\n        }\n    }\n}"
    },
    "1975B": {
        "title": "B. 378QAQ and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, 378QAQ gave her an array a consisting of n positive integers as a gift.\nMocha thinks that a is beautiful if there exist two numbers i and j (1\u2264i,j\u2264n, i\u2260j) such that for all k (1\u2264k\u2264n), ak is divisible\u2020 by either ai or aj.\nDetermine whether a is beautiful.\n\u2020 x is divisible by y if there exists an integer z such that x=y\u22c5z.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output \"Yes\" if array a is beautiful, and output \"No\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nIn the first test case, any two numbers in the array are coprime, so the answer is \"No\".\nIn the second test case, we can pick i=2 and j=1. Since every number in the array is divisible by ai=1, the answer is \"Yes\".\nIn the third test case, we can pick i=3 and j=5. 2 and 4 is divisible by ai=2 while 3, 6 and 12 is divisible by aj=3, so the answer is \"Yes\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1975B - 378QAQ and Mocha's ArrayIdea: Bazoka13 Solution: Bazoka13 Prepared by: Bazoka13 Hint 1How to solve the problem if we only need to find a number i(1\u2264i\u2264n) such that ak is divisible by ai for all k(1\u2264k\u2264n)? Hint 2We only need to check whether all elements are divisible by the minimum element of the array. SolutionRead the hints.Suppose the minimum element of a is x. Then we iterate over a, if an element is not divisible by x, then we add it to b (b is initially empty).If b is still empty after iterating a, the answer is yes. If b isn't empty, we check whether all elements of b are divisible by the minimum element of b. If so, the answer is yes. Otherwise, the answer is no. Code#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N = 1e5+10;\nint a[N];\nint main(){\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        int fl=0;\n        for(int i=1;i<=n;i++){\n            cin>>a[i];\n            if(a[i]==1)fl=1;\n        }\n        if(fl)cout<<\"Yes\\n\";\n        else{\n            sort(a+1,a+1+n);\n            vector<int> b;\n            for(int i=2;i<=n;i++){\n                if(a[i]%a[1])b.push_back(a[i]);\n            }\n            sort(b.begin(),b.end());\n            n = b.size();\n            for(int j=1;j<n;j++){\n                if(b[j]%b[0]){\n                    fl=1;\n                    break;\n                }\n            }\n            if(!fl)cout<<\"Yes\\n\";\n            else cout<<\"No\\n\";\n        }\n\n    }\n}"
    },
    "1971D": {
        "title": "D. Binary Cut",
        "description": "You are given a binary string\u2020\u2020. Please find the minimum number of pieces you need to cut it into, so that the resulting pieces can be rearranged into a sorted binary string.\nNote that: \n\u2020 A binary string is a string consisting of characters 0 and 1. A sorted binary string is a binary string such that all characters 0 come before all characters 1.\nThe first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single string s (1\u2264|s|\u2264500) consisting of characters 0 and 1, where |s| denotes the length of the string s.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of pieces needed to be able to rearrange the string into a sorted binary string.\nThe first test case is pictured in the statement. It can be proven that you can't use fewer than 3 pieces.\nIn the second and third test cases, the binary string is already sorted, so only 1 piece is needed.\nIn the fourth test case, you need to make a single cut between the two characters and rearrange them to make the string 01.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "strings",
            "*1100"
        ],
        "solutions": "1971D - Binary CutFirst, note that it's always optimal to divide the string into \"blocks\" of equal values; there is no use having two strings 111|11 when we can just have 11111 and use fewer pieces.Now note that to sort the string, we need all blocks of 0 to come before all blocks of 1. The only way that two blocks can join is if we have a block of 0s before a block of 1s, and we can have at most one such block. That is, all strings look like: (blocks of\u00a00s)0...1\ue152\ue153\ue151\ue150\ue154\ue154\ue154\ue154\u22641joined block of\u00a00s and\u00a01s(blocks of\u00a01s)So the answer is the number of blocks, but we should subtract 1 if a substring 01 exists (because then we can make the center block above). The time complexity is O(|s|).For example, for the string 111000110, we can use three pieces: 111|00011|0\u21920|00011|111. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint res = 1;\n\tbool ex = false;\n\tfor (int i = 0; i + 1 < (int)(s.size()); i++) {\n\t\tres += (s[i] != s[i + 1]);\n\t\tex |= (s[i] == '0' && s[i + 1] == '1');\n\t}\n\tcout << res - ex << '\\n';\n}\n \nint main() {\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n"
    },
    "1970A1": {
        "title": "A1. Balanced Shuffle (Easy)",
        "description": "A parentheses sequence is a string consisting of characters \"(\" and \")\", for example \"(()((\".\nA balanced parentheses sequence is a parentheses sequence which can become a valid mathematical expression after inserting numbers and operations into it, for example \"(()(()))\".\nThe balance of a parentheses sequence is defined as the number of opening parentheses \"(\" minus the number of closing parentheses \")\". For example, the balance of the sequence \"(()((\" is 3.\nA balanced parentheses sequence can also be defined as a parentheses sequence with balance 0 such that each of its prefixes has a non-negative balance.\nWe define the balanced shuffle operation that takes a parentheses sequence and returns a parentheses sequence as follows: first, for every character of the input sequence, we compute the balance of the prefix of the sequence before that character and write those down in a table together with the positions of the characters in the input sequence, for example:\n\n\nThen, we sort the columns of this table in increasing order of prefix balance, breaking ties in decreasing order of position. In the above example, we get:\n\n\nThe last row of this table forms another parentheses sequence, in this case \"()(()())\". This sequence is called the result of applying the balanced shuffle operation to the input sequence, or in short just the balanced shuffle of the input sequence.\nYou are given a balanced parentheses sequence. Print its balanced shuffle.\nThe only line of input contains a string s consisting only of characters \"(\" and \")\". This string is guaranteed to be a non-empty balanced parentheses sequence with its length not exceeding 500000.\nPrint the parentheses sequence t\u00a0\u2014 the balanced shuffle of s.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1000"
        ],
        "solutions": "1970A1 - Balanced Shuffle (Easy)The problem statement describes exactly what needs to be done, so we just need to implement it carefully, using a O(nlogn) sorting algorithm from the standard library.If you're using Python for this problem, the time limit can be a bit tight so you might need to optimize a bit. For example, tuples are much faster than custom classes in Python, so the following passes in 0.5s:s = input()a = []b = 0for i in range(len(s)):  a.append((b, -i, s[i]))  if s[i] == '(':    b += 1  else:    b -= 1a.sort()print(\".join(x[2] for x in a)) A2 - Balanced Unshuffle (Medium)"
    },
    "1969B": {
        "title": "B. Shifts and Sorting",
        "description": "Let's define a cyclic shift of some string s as a transformation from s1s2\u2026sn\u22121sn into sns1s2\u2026sn\u22121. In other words, you take one last character sn and place it before the first character while moving all other characters to the right.\nYou are given a binary string s (a string consisting of only 0-s and/or 1-s).\nIn one operation, you can choose any substring slsl+1\u2026sr (1\u2264l<r\u2264|s|) and cyclically shift it. The cost of such operation is equal to r\u2212l+1 (or the length of the chosen substring).\nYou can perform the given operation any number of times. What is the minimum total cost to make s sorted in non-descending order?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains a binary string s (2\u2264|s|\u22642\u22c5105; si\u2208 {0, 1})\u00a0\u2014 the string you need to sort.\nAdditional constraint on the input: the sum of lengths of strings over all test cases doesn't exceed 2\u22c5105.\nFor each test case, print the single integer\u00a0\u2014 the minimum total cost to make string sorted using operation above any number of times.\nIn the first test case, you can choose the whole string and perform a cyclic shift: 10 \u2192 01. The length of the substring is 2, so the cost is 2.\nIn the second test case, the string is already sorted, so you don't need to perform any operations.\nIn the third test case, one of the optimal strategies is the next: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1969B - Shifts and SortingLet's look at the operation as the following: you choose (l,r), erase the element at position r and then insert it before the element at position l. We can also interpret the cost of such operation as the following: you pay 1 for the element at position r you \"teleport\" to the left and 1 for each element you teleport through (element inside segment [l,r\u22121]).Now let's look at two indices x<y where ax=1 and ay=0. Since at the end, all zeroes should be before ones, you have to move ay to the left of ax. But the only thing that moves to the left is element ar, so you have to make at least one operation ending at ay.What does it mean? It means:   for every 0 that has at least one 1 from the left, you have to pay at least 1 for teleporting it to the left;  for every 1, if there are c 0-s to the right, you have to pay at least c, since each zero should be teleported through this 1. The thoughts above gave us the lower bound on the answer, and it's not hard to come up with some constructive algorithms that will give us exactly that cost.To calculate the lower bound, you just need to maintain some info while iterating from left to right: for example, the number of 0-s and 1-s to the left of the current position and the total number of 0-s in s. It's enough to check: is there any 1 to the left of the current position, and how many 0-s are to the right.Instead of calculating the lower bound itself, you can also implement one of the algorithms that reach that lower bound, and it may be even a little easier. Solution (adedalic)fun main() {\n    repeat(readln().toInt()) {\n        val s = readln().map { it.code - '0'.code }\n        val zeroes = s.count { it == 0 }\n        val cnt = intArrayOf(0, 0)\n        var ans = 0L\n        for (c in s) {\n            cnt[c]++\n            if (c == 0)\n                ans += if (cnt[1] > 0) 1 else 0\n            else\n                ans += (zeroes - cnt[0])\n        }\n        println(ans)\n    }\n}"
    },
    "1968C": {
        "title": "C. Assembly via Remainders",
        "description": "You are given an array x2,x3,\u2026,xn. Your task is to find any array a1,\u2026,an, where: \nHere cmodd denotes the remainder of the division of the integer c by the integer d. For example 5mod2=1, 72mod3=0, 143mod14=3.\nNote that if there is more than one a which satisfies the statement, you are allowed to find any.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264500)\u00a0\u2014 the number of elements in a.\nThe second line of each test case contains n\u22121 integers x2,\u2026,xn (1\u2264xi\u2264500)\u00a0\u2014 the elements of x.\nIt is guaranteed that the sum of values n over all test cases does not exceed 2\u22c5105.\nFor each test case output any a1,\u2026,an (1\u2264ai\u2264109) which satisfies the statement.\nIn the first test case a=[3,5,4,9] satisfies the conditions, because: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "number theory",
            "*1000"
        ],
        "solutions": "1968C - Assembly via RemaindersNotice that ((a+b)moda)=b for 0\u2264b<a. So we may try to generate a sequence with b=xi.Let us take a1=1000, because 1000 is larger than any of xi. Then, we can take ai as ai\u22121+xi, since ((ai\u22121+xi)modai\u22121)=xi will be hold.The maximal value of a will be at most 1000+500n what is smaller than 109. Implementation#include<iostream>\nusing namespace std;\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tint S=1000;\n\t\tcout<<S<<\" \";\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tS+=x;\n\t\t\tcout<<S<<\" \";\n\t\t}\n\t\tcout<<\"\\n\";\n\t}\n} Rate the problem Didn't solve \n\n    \n\n\n55\n\n\n\n Good task \n\n    \n\n\n334\n\n\n\n Average task \n\n    \n\n\n53\n\n\n\n Bad task \n\n    \n\n\n32\n\n\n\n "
    },
    "1966B": {
        "title": "B. Rectangle Filling",
        "description": "There is an n\u00d7m grid of white and black squares. In one operation, you can select any two squares of the same color, and color all squares in the subrectangle between them that color.\nFormally, if you select positions (x1,y1) and (x2,y2), both of which are currently the same color c, set the color of all (x,y) where min(x1,x2)\u2264x\u2264max(x1,x2) and min(y1,y2)\u2264y\u2264max(y1,y2) to c.\nThis diagram shows a sequence of two possible operations on a grid:\nIs it possible for all squares in the grid to be the same color, after performing any number of operations (possibly zero)?\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264500)\u00a0\u2014 the number of rows and columns in the grid, respectively.\nEach of the next n lines contains m characters 'W' and 'B'\u00a0\u2014 the initial colors of the squares of the grid. \nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 3\u22c5105.\nFor each test case, print \"YES\" if it is possible to make all squares in the grid the same color, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first example, it is impossible to ever change the color of any square with an operation, so we output NO.\nThe second example is the case pictured above. As shown in that diagram, it is possible for all squares to be white after two operations, so we output YES.\nIn the third and fourth examples, all squares are already the same color, so we output YES.\nIn the fifth example we can do everything in two operations. First, select positions (2,1) and (1,4) and color all squares with 1\u2264x\u22642 and 1\u2264y\u22644 to white. Then, select positions (2,1) and (3,4) and color all squares with 2\u2264x\u22643 and 1\u2264y\u22644 to white. After these two operations all squares are white.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solutions": "1966B - Rectangle FillingIf either pair of opposite corners is the same color, then we can choose those corners to make everything the same color in one operation.Otherwise, we have four cases for the colors of the corners:  Notice that these are all essentially rotations of each other, so we can only consider the first case by symmetry:  If any of the squares in the first row are black, then we can color everything black in two operations:  In the same way, if any of the squares in the last row are white, then we can color everything white in two operations.Otherwise, the grid looks like this:  Notice that no matter how many operations we do, all squares in the top row will remain white, and all squares in the bottom row will remain black, so we can never make everything the same color.So, considering the four cases from earlier, the solution is:NO if all squares in the top row are the same color, all squares in the bottom row are the same color, and these two colors are differentNO if all squares in the leftmost column are the same color, all squares in the rightmost column are the same color, and these two colors are differentYES otherwiseComplexity: O(nm) Codet = int(input())\n\nfor tc in range(t):\n    n, m = map(int, input().split())\n    gr = []\n\n    for i in range(n):\n        gr.append(input())\n\n    ans = \"YES\"\n\n    if gr[0][0] != gr[n - 1][m - 1]:\n\n        impossible = True\n        for j in range(m - 1):\n            if gr[0][j] != gr[0][j + 1] or gr[n - 1][j] != gr[n - 1][j + 1]:\n                impossible = False\n\n        if impossible:\n            ans = \"NO\"\n\n        impossible = True\n        for i in range(n - 1):\n            if gr[i][0] != gr[i + 1][0] or gr[i][m - 1] != gr[i + 1][m - 1]:\n                impossible = False\n\n        if impossible:\n            ans = \"NO\"\n\n    print(ans)"
    },
    "1958A": {
        "title": "A. 1-3-5",
        "description": "In Berland, coins of worth 1, 3 and 5 burles are commonly used (burles are local currency).\nEva has to pay exactly n burles in a shop. She has an infinite amount of coins of all three types. However, she doesn't like to pay using coins worth 1 burle \u2014 she thinks they are the most convenient to use.\nHelp Eva to calculate the minimum number of coins worth 1 burle she has to use, if she has to pay exactly n burles. Note that she can spend any number of coins worth 3 and/or 5 burles.\nThe first line contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nEach test case consists of one line, containing one integer n (1\u2264n\u2264100).\nFor each test case, print one integer \u2014 the minimum number of 1-burle coins Eva has to use.\nIn the first test case, Eva should use 1 coin worth 1 burle, and 2 coins worth 3 burles.\nIn the second test case, Eva should use 1 coin worth 3 burles and 1 coin worth 5 burles.\nIn the third test case, Eva should use 14 coins worth 3 burles.\nIn the fourth test case, Eva should use 2 coins worth 1 burle.\nIn the fifth test case, Eva should use 2 coins worth 3 burles and 1 coin worth 5 burles.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*1100"
        ],
        "solutions": "1958A - 1-3-5There are two main ways to solve this problem: brute force and casework.To solve this problem with brute force, you can use three nested loops to iterate on the number of coins of each type from 0 to n, check if they give exactly n burles in total, and update the answer. This can be optimized in many different ways, like iterating only on the number of coins worth 3 and 5 burles and calculating the number of coins worth 1 burle in O(1). However, the approach with three nested loops works in O(n3) and is fast enough.The solution with casework basically works because of an observation that if n is big enough (8 or greater), it can always be expressed as the sum of 3's and/or 5's. So, we can get the answers for n\u22647 by hand and if n>7, jsut output 0. This observation is kinda intuitive, but if you want a proof, you can use Chicken McNugget Theorem (in my opinion, one of the coolest names for a math topic!) Solution (PavelKunyavskiy)fun main() {\n    val ans = IntArray(101) { Int.MAX_VALUE }\n    ans[0] = 0\n    for (i in ans.indices) {\n        for ((d, c) in listOf(1 to 1, 3 to 0, 5 to 0)) {\n            if (i + d in ans.indices) ans[i + d] = minOf(ans[i + d], ans[i] + c)\n        }\n    }\n    repeat(readInt()) {\n        println(ans[readInt()])\n    }\n}\n\nprivate fun readInt() = readln().toInt()\nprivate fun readLongs() = readStrings().map { it.toLong() }\nprivate fun readStrings() = readln().split(\" \")\nprivate fun readInts() = readStrings().map { it.toInt() }"
    },
    "1957B": {
        "title": "B. A BIT of a Construction",
        "description": "Given integers n and k, construct a sequence of n non-negative (i.e. \u22650) integers a1,a2,\u2026,an such that \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105, 1\u2264k\u2264109)\u00a0\u2014 the number of non-negative integers to be printed and the sum respectively.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a sequence a1,a2,\u2026,an on a new line that satisfies the conditions given above.\nIf there are multiple solutions, print any of them.\nIn the first test case, we have to print exactly one integer, hence we can only output 5 as the answer.\nIn the second test case, we output 1,2 which sum up to 3, and 1|2=(11)2 has two 1s in its binary representation, which is the maximum we can achieve in these constraints.\nIn the fourth test case, we output 3,1,1,32,2,12 which sum up to 51, and 3|1|1|32|2|12=(101111)2 has five 1s in its binary representation, which is the maximum we can achieve in these constraints.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1957B - A BIT of a ConstructionThe case n=1 needs to be handled separately, as we can only output k itself.For n>1, we make the following observations. Let x be the position of the most significant bit in k, that is 2x\u2264k<2x+1. From this, we learn that the bitwise OR of the sequence cannot have more than x+1 set bits because that would make the sum greater than 2x+1.Now, having x+1 bits set in the bitwise OR of the sequence is only possible if k=2x+1\u22121 (or k=111\u202612). Any k less than this cannot have x+1 bits set in the bitwise OR of the sequence, as otherwise the sum would exceed k. However, we can always set x bits, as we can always have one number in the sequence as 2x\u22121 (which has exactly x bits set). Using these observations, we get our solution as 2x\u22121,k\u2212(2x\u22121),0,0,0,\u2026,0. This ensures that we have at least x bits set in the bitwise OR, and additionally also handles the case where x+1 bits can be set, while maintaining the sum. Rate this problem \n\n\n\n303\n\n\n\n\n\n Great Problem \n\n\n\n251\n\n\n\n\n\n Ok Problem \n\n\n\n54\n\n\n\n\n\n Bad Problem \n\n\n\n57\n\n\n\n\n\n Didn't solve  C++ Code#include <bits/stdc++.h>\n\nusing namespace std;\n \nint main(){\n    int t; \n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        if (n == 1) {\n            a[0] = k;\n        }\n        else {\n            int msb = 0;\n            // find the msb of k\n            for (int i = 0; i < 31; i++) {\n                if (k & (1 << i)) {\n                    msb = i;\n                }\n            }\n            a[0] = (1 << msb) - 1;\n            a[1] = k - a[0];\n            for (int i = 2; i < n; i++) {\n                a[i] = 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            cout << a[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}"
    },
    "1955B": {
        "title": "B. Progressive Square",
        "description": "A progressive square of size n is an n\u00d7n matrix. Maxim chooses three integers a1,1, c, and d and constructs a progressive square according to the following rules:\nai+1,j=ai,j+c\nai,j+1=ai,j+d\nFor example, if n=3, a1,1=1, c=2, and d=3, then the progressive square looks as follows:\n(1473695811)\nLast month Maxim constructed a progressive square and remembered the values of n, c, and d. Recently, he found an array b of n2 integers in random order and wants to make sure that these elements are the elements of that specific square.\nIt can be shown that for any values of n, a1,1, c, and d, there exists exactly one progressive square that satisfies all the rules.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains three integers n, c, and d (2\u2264n\u2264500, 1\u2264c,d\u2264106)\u00a0\u2014 the size of the square and the values of c and d as described in the statement.\nThe second line of each test case contains n\u22c5n integers b1,b2,\u2026,bn\u22c5n (1\u2264bi\u2264109)\u00a0\u2014 the elements found by Maxim.\nIt is guaranteed that the sum of n2 over all test cases does not exceed 25\u22c5104.\nFor each test case, output \"YES\" in a separate line if a progressive square for the given n, c, and d can be constructed from the array elements a, otherwise output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "implementation",
            "sortings",
            "*1000"
        ],
        "solutions": "1955B - Progressive SquareSince c>0 and d>0, the elements of the square increase starting from the top left corner. Thus, a1,1 is the minimum element in the square, and consequently in the found elements.Given n, c, d, and the found a1,1, we will reconstruct the square. It remains to check that the given numbers in the input form the same square. The easiest way is to sort both arrays of numbers and check for equality. The complexity of the solution is O(n2\u22c5logn). Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define all(x) (x).begin(), (x).end()\n \nusing ll = signed long long int;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n \nvoid solve() {\n    int n;\n    ll c, d;\n    cin >> n >> c >> d;\n    vl a(n * n);\n    for (int i = 0; i < n * n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    vl b(n * n);\n    b[0] = a[0];\n    for (int i = 1; i < n; ++i) {\n        b[i] = b[i - 1] + c;\n    }\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            b[i * n + j] = b[(i - 1) * n + j] + d;\n        }\n    }\n    sort(all(b));\n    cout << (a == b ? \"YEs\" : \"nO\") << '\\n';\n}\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n"
    },
    "1954C": {
        "title": "C. Long Multiplication",
        "description": "You are given two integers x and y of the same length, consisting of digits from 1 to 9.\nYou can perform the following operation any number of times (possibly zero): swap the i-th digit in x and the i-th digit in y.\nFor example, if x=73 and y=31, you can swap the 2-nd digits and get x=71 and y=33.\nYour task is to maximize the product of x and y using the aforementioned operation any number of times. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer x (1\u2264x<10100).\nThe second line of each test case contains a single integer y (1\u2264y<10100).\nAdditional constraint on input: the integers x and y consist only of digits from 1 to 9.\nFor each test case, print two lines\u00a0\u2014 the first line should contain the number x after performing the operations; similarly, the second line should contain the number y after performing the operations. If there are multiple answers, print any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1954C - Long MultiplicationThere are two observations to solve the problem:   applying the operation does not change the sum of the numbers;  the smaller the difference of the numbers, the greater their product (the proof is given below). Proof: let's denote the sum of the numbers as s, the smallest number as s2\u2212a and the largest number as s2+a. Then the product is equal to (s2\u2212a)(s2+a)=(s2)2\u2212a2. We can see that, the smaller a (the half of difference), the larger the product.In order to get the minimum difference, we can use the following algorithm: let i be the smallest index (the most significant digit) such that xi\u2260yi and set the maximum digit among xi and yi to the number x and smallest to the number y; thus x is definitely greater than y, then the less significant digits should be the maximum possible for the number y (i.\u2009e. the inequality xj\u2264yj must hold for all j>i). Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    string x, y;\n    cin >> x >> y;\n    int n = x.size();\n    bool f = false;\n    for (int i = 0; i < n; ++i) {\n      if ((x[i] > y[i]) == f) swap(x[i], y[i]);\n      f |= (x[i] != y[i]);\n    }\n    cout << x << '\\n' << y << '\\n';\n  }\n}"
    },
    "1954B": {
        "title": "B. Make It Ugly",
        "description": "Let's call an array a beautiful if you can make all its elements the same by using the following operation an arbitrary number of times (possibly, zero): \nYou are given a beautiful array a1,a2,\u2026,an. What is the minimum number of elements you have to remove from it in order for it to stop being beautiful? Swapping elements is prohibited. If it is impossible to do so, then output -1.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105).\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nAdditional constraints on the input:\nFor each test case, output a single integer\u00a0\u2014 the minimum number of elements you have to remove from the array a in order for it to stop being beautiful. If it is impossible, then output -1.\nIn the first testcase, it is impossible to modify the array in such a way that it stops being beautiful. An array consisting of identical numbers will remain beautiful no matter how many numbers we remove from it.\nIn the second testcase, you can remove the number at the index 5, for example.\nThe resulting array will be [1,2,1,2]. Let's check if it is beautiful. Two operations are available: \nThus, the array [1,2,1,2] is not beautiful.\nIn the fourth testcase, you can remove the first three elements, for example. The resulting array [5,3,3,3] is not beautiful.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1954B - Make It UglyIdea: BledDest TutorialTutorial is loading... Solution (awoo)for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    lst = -1\n    ans = n\n    for i in range(n):\n        if a[i] != a[0]:\n            ans = min(ans, i - lst - 1)\n            lst = i\n    ans = min(ans, n - lst - 1)\n    if ans == n:\n        print(-1)\n    else:\n        print(ans)"
    },
    "1951B": {
        "title": "B. Battle Cows",
        "description": "There are n cows participating in a coding tournament. Cow i has a Cowdeforces rating of ai (all distinct), and is initially in position i. The tournament consists of n\u22121 matches as follows: \nYou are the owner of cow k. For you, winning the tournament is not important; rather, you want your cow to win in as many matches as possible. As an acquaintance of the tournament organizers, you can ask them to swap the position of your cow with another cow only once, or you can choose to do nothing.\nFind the maximum number of wins your cow can achieve.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (2\u2264n\u2264105,1\u2264k\u2264n)\u00a0\u2014 the number of cows and your cow's index.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the Cowdeforces rating of the cows. It is guaranteed that ai's are pairwise different.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print one integer: the maximum number of wins cow k can achieve if you choose to swap (or do nothing) optimally.\nIn the first test case, it is optimal to do nothing. Let a\u2032 be the Cowdeforces rating of the cows in the original order (with your cow's rating bolded), then \nIn the second test case, it is optimal to swap your cow to position 3. Then, let a\u2032 be the Cowdeforces rating of the cows in the order after the swap. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "*1200"
        ],
        "solutions": "1951B - Battle Cows inserted, before being further switched to D as it was still too hard. Rate this problemYay \n\n    \n\n\n179\n\n\n\n\n\n Meh \n\n    \n\n\n38\n\n\n\n\n\n Nay \n\n    \n\n\n336\n\n\n\n\n\n Banger song \n\n    \n\n\n31\n\n\n\n"
    },
    "1950D": {
        "title": "D. Product of Binary Decimals",
        "description": "Let's call a number a binary decimal if it is a positive integer and all digits in its decimal notation are either 0 or 1. For example, 1010111 is a binary decimal, while 10201 and 787788 are not.\nGiven a number n, you are asked whether or not it is possible to represent n as a product of some (not necessarily distinct) binary decimals.\nThe first line contains a single integer t (1\u2264t\u22645\u22c5104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u2264105).\nFor each test case, output \"YES\" (without quotes) if n can be represented as a product of binary decimals, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\", and \"Yes\" will be recognized as a positive response).\nThe first five test cases can be represented as a product of binary decimals as follows: ",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solutions": "1950D - Product of Binary DecimalsFirst, let's make precompute list of all binary decimals at most 105. You can do it in many ways, for example iterating through all numbers up to 105 and checking if each is a binary decimal.Let's call a number good if it can be represented as the product of binary decimals. For each test case, we will write a simple recursive function. n is good if:   n=1, or  ni is good, for some binary decimal i>1.  We can check by hand (or code) that the number of binary decimals is not more than 32, so the solution should not take too long in practice even without memoization. You can test it locally on all 105 inputs to check. This is enough to solve the problem; see the implementation for more details.Even if your implementation is slightly too slow, there are not many good numbers; you can simply precompute them all locally and hardcode them to get a solution that works in O(1). Here is a long string of text so that there is a horizontal line separating sections. For the curious: we will compute an upper bound on the complexity, given by the (rather loose) recurrence T(n)\u22642T(\u230an10\u230b)+4T(\u230an100\u230b)+26T(\u230an1000\u230b). By the Akra-Bazzi method, T(n)\u2208O(nlog10\u03b1)=O\u239b\u239d\u239cnlog10(2+395\u2212316881\u221a\u221a3+395+316881\u221a\u221a33)\u239e\u23a0\u239f\u2248O(n0.635), where \u03b1 is the (unique) real number satisfying \u03b13=2\u03b12+4\u03b1+26. This is probably fast enough, and this is still a very large overestimate.A more accurate estimate can be made by picking the solution to \u03b15=2\u03b14+4\u03b13+8\u03b12+16\u03b1+2, which gives a bound O(n0.587). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 100'007;\nconst int MOD = 1'000'000'007;\n\nvector<int> binary_decimals;\n\nbool ok(int n) {\n\tif (n == 1) {return true;}\n\tbool ans = false;\n\tfor (int i : binary_decimals) {\n\t\tif (n % i == 0) {\n\t\t\tans |= ok(n / i);\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tcout << (ok(n) ? \"YES\\n\" : \"NO\\n\");\t\n}\n\nint main() {\n\tfor (int i = 2; i < MAX; i++) {\n\t\tint curr = i;\n\t\tbool bad = false;\n\t\twhile (curr) {\n\t\t\tif (curr % 10 > 1) {bad = true; break;}\n\t\t\tcurr /= 10;\n\t\t}\n\t\tif (!bad) {binary_decimals.push_back(i);}\n\t}\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}"
    },
    "1948B": {
        "title": "B. Array Fix",
        "description": "You are given an integer array a of length n.\nYou can perform the following operation any number of times (possibly zero): take any element of the array a, which is at least 10, delete it, and instead insert the digits that element consisted of in the same position, in order they appear in that element.\nFor example:\nYour task is to determine whether it is possible to make a sorted in non-descending order using the aforementioned operation any number of times (possibly zero). In other words, you have to determine if it is possible to transform the array a in such a way that a1\u2264a2\u2264\u22ef\u2264ak, where k is the current length of the array a.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nEach test case consists of two lines:\nFor each test case, print YES if it is possible to make a sorted in non-decreasing order using the aforementioned operation; otherwise, print NO.\nYou can print each letter in any case. For example, yes, Yes, YeS will all be recognized as a positive answer.\nIn the first example, you can split the first element, then the array becomes [1,2,3,45,67].\nIn the second example, there is no way to get a sorted array.\nIn the third example, the array is already sorted.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1948B - Array FixThe key to solving the problem is the following observation: if ai>ai+1, then the i-th element should always be split (since it is the only way to decrease the element compared with ai+1).This observation allows us to solve the problem greedily as follows: iterate on the array a from right to left, keeping track of the list of elements we processed; if the current element is greater than the last element in our list, we have to split it (and add the digits it consists of to the list); otherwise, we don't have to split it (because it might forbid some of the next elements and force them to split as well).After that, we have to make sure we obtained a sorted array (because, for example, a number like 98 will break the sorted order if we split it, and we didn't check that). But since we maintained the list of elements we processed, that's quite easy, because that list is the resulting array a in reversed order. Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& x : a) cin >> x;\n    vector<int> b({a[n - 1]});\n    for (int i = n - 2; i >= 0; --i) {\n      if (a[i] > b.back()) {\n        b.push_back(a[i] % 10);\n        b.push_back(a[i] / 10);\n      } else {\n        b.push_back(a[i]);\n      }\n    }\n    cout << (is_sorted(b.rbegin(), b.rend()) ? \"YES\" : \"NO\") << '\\n';\n  }\n}"
    },
    "1946B": {
        "title": "B. Maximum Sum",
        "description": "You have an array a of n integers.\nYou perform exactly k operations on it. In one operation, you select any contiguous subarray of the array a (possibly empty) and insert the sum of this subarray anywhere in the array.\nYour task is to find the maximum possible sum of the array after k such operations.\nAs this number can be very large, output the answer modulo 109+7.\nReminder: the remainder of a number x modulo p is the smallest non-negative y such that there exists an integer q and x=p\u22c5q+y.\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers n and k (1\u2264n,k\u22642\u22c5105)\u00a0\u2014 the length of the array a and the number of operations, respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109)\u00a0\u2014 the array a itself.\nIt is guaranteed that the sum of the values of n and k for all test cases does not exceed 2\u22c5105.\nFor each test, output a single integer\u00a0\u2014 the maximum sum of the array that can be obtained after k operations modulo 109+7.\nIn the first test case, it is advantageous to take an empty subarray of the array twice and insert the sum of the empty subarray (zero) anywhere, then the sum of the resulting array will be (\u22124)+(\u22127)+0+0=\u221211, modulo 109+7 this is 999999996.\nIn the second test case, it is advantageous to take the sum of the entire array three times and place it anywhere in the array, then one of the possible sequences of actions: [2,2,8] \u2192 [2,2,8,12] \u2192 [2,2,8,12,24] \u2192 [2,2,8,12,24,48], the sum of the final array is 2+2+8+12+24+48=96.\nIn the fourth test case, it is advantageous to take a subarray of the array consisting of the first three numbers (i.e. consisting of the numbers 4,\u22122 and 8) and insert its sum at the beginning of the array, thereby obtaining the array [10,4,\u22122,8,\u221212,9], the sum of this array is 17.\nIn the seventh test case, it will always be advantageous for us to take an empty subarray of the array. In this case, the sum of the resulting array will not differ from the sum of the original. The answer will be the sum of the original array, taken modulo\u00a0\u2014 42, because (\u22126\u22c5(109+7)+42=\u22126000000000).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1946B - Maximum SumLet's denote s as the sum of the original array and x as the sum of the subarray with the maximum sum from the original array.We solve the problem when k equals 1. In this case, we need to find the subarray of the array with the maximum sum and insert this sum anywhere in the array, so the answer is s+x. Now, let k be 2. In this case, there is already a value where we insert the sum of the subarray with the maximum sum. Then we can increase the sum of the subarray with the maximum sum by no more than x (we can increase it by x simply by inserting it into the subarray with the maximum sum), and obtain the sum of the subarray with the maximum sum 2\u22c5x. Then insert it anywhere in the array, thus obtaining the sum of the final array equal to s+x+2\u22c5x. Similarly, for any k, the sum of the subarray with the maximum sum is initially x, then 2\u22c5x, then 4\u22c5x, \u2026, 2k\u22121\u22c5x, then the answer is equal to s+x+2\u22c5x+\u22ef+2k\u22121\u22c5x=s+2k\u22c5x\u2212x. Solution#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int P = 1e9 + 7;\n\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)\n        cin >> a[i];\n    int S = 0, sum = 0;\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n        sum += a[i];\n        cur += a[i];\n        cur = max(cur, 0LL);\n        S = max(S, cur);\n    }\n    sum = (sum % P + P) % P;\n    S = S % P;\n    int t = 1;\n    for (int i = 0; i < k; i++) {\n        t = t * 2 % P;\n    }\n    int ans = (sum + S * t - S + P) % P;\n    cout << ans << '\\n';\n}\n\n\nsigned main() {\n    //cout << fixed << setprecision(20);\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T = 1, G = 1;\n    //cin >> G;\n    cin >> T;\n    while (T--)\n        solve();\n    return 0;\n}author: dope, developer: dope"
    },
    "1945C": {
        "title": "C. Left and Right Houses",
        "description": "In the village of Letovo, there are n houses. The villagers decided to build a big road that will divide the village into left and right sides. Each resident wants to live on either the right or the left side of the street, which is described as a sequence a1,a2,\u2026,an, where aj=0 if the resident of the j-th house wants to live on the left side of the street; otherwise, aj=1.\nThe road will pass between two houses. The houses to the left of it will be declared the left-side, and the houses to the right will be declared the right-side. More formally, let the road pass between houses i and i+1. Then the houses at positions between 1 and i will be on the left side of the street, and at positions between i+1 and n will be on the right side. The road also may pass before the first and after the last house; in this case, the entire village is declared to be either the right or left side, respectively.\nTo make the design fair, it was decided to lay the road so that at least half of the residents on each side of the village are satisfied with the choice. That is, among x residents on one side, at least \u2308x2\u2309 should want to live on that side, where \u2308x\u2309 denotes rounding up a real number x.\nDetermine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible. Formally, among all suitable positions i, minimize |n2\u2212i|.\nIf there are multiple suitable positions i with the minimum |n2\u2212i|, output the smaller one.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22642\u22c5104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u22643\u22c5105). The next line of each test case contains a string a of length n, consisting only of 0 and 1.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, output a single number i\u00a0\u2014 the position of the house after which the road should be laid (if it should be laid before the first house, output 0). We can show that the answer always exists.\nLet's consider the first example of input data.\nIf we lay the road after the first house, there will be one house a1=1 on the left side of the street, the resident of which would like to live on the right side of the street. Then 0 out of 1 residents on the even side will be satisfied with the choice, which means that the road cannot be laid after house 1.\nIf we lay the road after the second house, 1 out of 2 residents on the left side (with preferences a1=1, a2=0) and 1 out of 1 resident on the right side (with preference a3=1) will be satisfied with the choice. More than half of the residents on each side are satisfied with the choice, which means that the road can be laid after house 2. We can show that this is the optimal answer.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "*1200"
        ],
        "solutions": "1945C - Left and Right HousesAccording to the statement, to the left of the road there should be no less elements ai such that ai=0 than such that ai=1, and to the right of the road there should be no less elements ai than such that ai=1 than such that ai=0.We will consider each position of the road and check the compliance with the road design condition. To do this, we will use the prefix sum method to access the number of 1's in the suffix in O(1) (the number of such i that i>x and ai=1 for any x). We will also maintain the count of 0's among the elements to the left of the road and the optimal answer. If the road position x is suitable and it is closer to the middle than the most optimal answer found before, we will update it (and will not forget to increase the count of 0 if the next element ax+1=0).It is convenient to double the distance to the middle of the village: instead of \u2223\u2223n2\u2212i\u2223\u2223, consider it as 2\u2223\u2223n2\u2212i\u2223\u2223=|n\u22122\u22c5i|. This way, we can get rid of calculations in non-integer numbers.Complexity: O(n) Solutionfor case in range(int(input())):\n    n = int(input())\n    a = input()\n    suf_cnt = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suf_cnt[i] = suf_cnt[i + 1] + (a[i] == '1')\n    pref_cnt = 0\n     \n    opt_ans = -1\n    opt_dist = n * 2\n    threshold = (n + 1) // 2\n     \n    for i in range(n + 1):\n        if pref_cnt >= (i + 1) // 2 and suf_cnt[i] >= (n - i + 1) // 2 and abs(n - 2 * i) < opt_dist:\n            opt_dist = abs(n - 2 * i)\n            opt_ans = i\n        if i != n:\n            pref_cnt += (a[i] == '0')\n     \n    print(opt_ans)\n"
    },
    "1944B": {
        "title": "B. Equal XOR",
        "description": "You are given an array a of length 2n, consisting of each integer from 1 to n exactly twice.\nYou are also given an integer k (1\u2264k\u2264\u230an2\u230b).\nYou need to find two arrays l and r each of length 2k such that: \nIt can be proved that at least one pair of l and r always exists. If there are multiple solutions, you may output any one of them.\n\u2020 A sequence x is a subset of a sequence y if x can be obtained by deleting several (possibly none or all) elements of y and rearranging the elements in any order. For example, [3,1,2,1], [1,2,3], [1,1] and [3,2] are subsets of [1,1,2,3] but [4] and [2,2] are not subsets of [1,1,2,3].\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains 2 integers n and k (2\u2264n\u22645\u22c5104, 1\u2264k\u2264\u230an2\u230b).\nThe second line contains 2n integers a1,a2,\u2026,a2n (1\u2264ai\u2264n). It is guaranteed that every integer from 1 to n occurs exactly twice in a.\nIt is guaranteed that the sum of n over all test cases does not exceed 5\u22c5104.\nFor each test case, output two lines. \nOn the first line of output, output 2k integers l1,l2,\u2026,l2k.\nOn the second line of output, output 2k integers r1,r2,\u2026r2k.\nIf there are multiple solutions, you may output any one of them.\nIn the first test case, we choose l=[2,1] and r=[2,1]. [2,1] is a subset of [a1,a2] and [2,1] is a subset of [a3,a4], and 2\u22951=2\u22951=3.\nIn the second test case, 6\u22954=1\u22953=2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "*1100"
        ],
        "solutions": "1944B - Equal XORIdea : satyam343Preparation : satyam343Editorial : Dominater069 Hint 1Group numbers according to how many times they occur in a[1...n]. Hint 2The group of numbers having 0 occurrences in a[1...n] is of the same size as the group of numbers having 2 occurences in a[1...n]. Hint 3Try to use the 0 and 2 occurrence numbers first, and then if we still need more, we can use the 1 occurence numbers. Remember that we have to form sequences of size 2\u22c5k which is even. SolutionWe can append any 2 occurrence numbers to our sequence l and any 0 occurrence numbers to our sequence r without any issue because the xor value will cancel out. We do this while our sequence sizes are less than 2\u22c5k. At the end of this process, l and r will have the same size due to Hint 2.Now, we use as many 1 occurrence numbers appending to both l and r as needed. Since we append to both sequences, the xor value of the 2 sequences will be the same.If we had to solve for odd sequence sizes, we could take a 1 occurrence number at the very start to make it even, and then run the same process, but if there are no 1 occurrence numbers at all, we fail with this method. Code#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int t; cin >> t;\n    while (t--){\n        int n, k; \n        cin >> n >> k; \n        k = 2 * k;\n        \n        vector <int> a(2 * n), occ(n + 1, 0);\n        \n        for (auto &x : a) cin >> x;\n        for (int i = 0; i < n; i++) occ[a[i]]++;\n        \n        vector <int> g0, g1, g2;\n        for (int i = 1; i <= n; i++){\n            if (occ[i] == 0) g0.push_back(i);\n            else if (occ[i] == 1) g1.push_back(i);\n            else g2.push_back(i);\n        }\n        \n        int v = 0;\n        for (auto x : g2){\n            if (v < k){\n                v += 2;\n                cout << x << \" \" << x << \" \";\n            }\n        }\n        for (auto x : g1){\n            if (v < k){\n                v++;\n                cout << x << \" \";\n            }\n        }\n        cout << \"\\n\";\n        \n        v = 0;\n        for (auto x : g0){\n            if (v < k){\n                v += 2;\n                cout << x << \" \" << x << \" \";\n            }\n        }\n        for (auto x : g1){\n            if (v < k){\n                v++;\n                cout << x << \" \";\n            }\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}"
    },
    "1942B": {
        "title": "B. Bessie and MEX",
        "description": "Farmer John has a permutation p1,p2,\u2026,pn, where every integer from 0 to n\u22121 occurs exactly once. He gives Bessie an array a of length n and challenges her to construct p based on a. \nThe array a is constructed so that ai = MEX(p1,p2,\u2026,pi)\u2212pi, where the MEX of an array is the minimum non-negative integer that does not appear in that array. For example, MEX(1,2,3)=0 and MEX(3,1,0)=2.\nHelp Bessie construct any valid permutation p that satisfies a. The input is given in such a way that at least one valid p exists. If there are multiple possible p, it is enough to print one of them.\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the lengths of p and a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212n\u2264ai\u2264n)\u00a0\u2014 the elements of array a.\nIt is guaranteed that there is at least one valid p for the given data.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers on a new line, the elements of p.\nIf there are multiple solutions, print any of them.\nIn the first case, p=[0,1,4,2,3] is one possible output.\na will then be calculated as a1=MEX(0)\u22120=1, a2=MEX(0,1)\u22121=1, a3=MEX(0,1,4)\u22124=\u22122, a4=MEX(0,1,4,2)\u22122=1, a5=MEX(0,1,4,2,3)\u22123=2.\nSo, as required, a will be [1,1,\u22122,1,2].",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1942B - Bessie and MEXProblem Credits: buffering Analysis: bufferingSolution 1 Hint 1We will construct the solution forward. Hint 2Separate the ai's given into negative and positive cases. What does this tell us about the MEX? SolutionWe can find p1,p2,...,pn in order, looking at positive and negative cases. Note that ai\u22600 because pi would equal MEX(p1\u2026pi), which can never happen.  If ai>0, then MEX(p1,p2,...pi) must increase from MEX(p1,p2,...pi\u22121), so we know pi must equal MEX(p1,p2,...pi\u22121). Otherwise, the MEX stays the same, so pi is just simply MEX(p1,p2,...pi\u22121) \u2014 ai. Thus, we can just maintain the MEX and find each pi as we go forward. Here's more justification about specific differences leading to specific MEX changesThere are only 2 things the MEX can do: increase or stay the same (it can never decrease since larger prefixes contain smaller ones).  In the case of a positive difference, consider what would happen if the MEX stayed the same. Since the difference is positive, the MEX would have to be greater than the current value, which is impossible because that value had to appear earlier on in the prefix. Since the MEX is calculated on a permutation that can\u2019t happen. So the MEX has to increase.   In the case of a negative value, the MEX has to be less than the current value. But if it increased that means the current value changed its the MEX, meaning its the MEX is now at least (current value + 1) and it is actually greater. So it has to stay the same. Note that this is also a way to show p is always unique. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n; cin >> n;\n\tvector<int> a(n);\n\tfor(int& i: a) cin >> i;\n\tvector<int> p(n), has(n + 1);\n\tint mex = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(a[i] >= 0){\n\t\t\tp[i] = mex;\n\t\t}\n\t\telse{\n\t\t\tp[i] = mex - a[i];\n\t\t}\n\t\thas[p[i]] = true;\n\t\twhile(has[mex]) mex++;\n\t}\n\tfor(int i: p) cout << i << \" \";\n\tcout << \"\\n\";\n}\n\nint main(){\n\tcin.tie(0) -> sync_with_stdio(0);\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n}\n\n/*   /\\_/\\\n*   (= ._.)\n*   / >  \\>\n*/Solution 2 Hint 1We will construct the solution backwards. Hint 2The MEX is determined at the last index, since all of 0,1\u2026n\u22121 appear in p. SolutionRead the hints.Since we know the MEX of the last position is n, then n\u2212pn=an. From this equation, we can find that pn=n\u2212an. Now, because we know pn, we can determine the MEX of the first n\u22121 numbers. Like how we found pn, we can do a similar process for finding pn\u22121. Doing this for i=n,n\u22121\u20261 will get us a valid answer p.Note that this is also a way to show p is always unique."
    },
    "1941D": {
        "title": "D. Rudolf and the Ball Game",
        "description": "Rudolf and Bernard decided to play a game with their friends. n people stand in a circle and start throwing a ball to each other. They are numbered from 1 to n in the clockwise order.\nLet's call a transition a movement of the ball from one player to his neighbor. The transition can be made clockwise or counterclockwise.\nLet's call the clockwise (counterclockwise) distance from player y1 to player y2 the number of transitions clockwise (counterclockwise) that need to be made to move from player y1 to player y2. For example, if n=7 then the clockwise distance from 2 to 5 is 3, and the counterclockwise distance from 2 to 5 is 4.\nInitially, the ball is with the player number x (players are numbered clockwise). On the i-th move the person with the ball throws it at a distance of ri (1\u2264ri\u2264n\u22121) clockwise or counterclockwise. For example, if there are 7 players, and the 2nd player, after receiving the ball, throws it a distance of 5, then the ball will be caught by either the 7th player (throwing clockwise) or the 4th player (throwing counterclockwise). An illustration of this example is shown below.\nThe game was interrupted after m throws due to unexpected rain. When the rain stopped, the guys gathered again to continue. However, no one could remember who had the ball. As it turned out, Bernard remembered the distances for each of the throws and the direction for some of the throws (clockwise or counterclockwise).\nRudolf asks you to help him and based on the information from Bernard, calculate the numbers of the players who could have the ball after m throws.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,m,x (2\u2264n\u22641000, 1\u2264m\u22641000, 1\u2264x\u2264n) \u2014 the number of players, the number of throws made, and the number of the player who threw the ball first, respectively.\nThe next m lines contain information about each throw in order. Each of them contains an integer ri (1\u2264ri\u2264n\u22121) \u2014 the distance at which the i-th throw was made, and a symbol ci, equal to '0', '1', or '?':\nIt is guaranteed that the sum n\u22c5m (n multiplied by m) over all test cases does not exceed 2\u22c5105.\nFor each test case, output two lines.\nIn the first line, output the number of players k (1\u2264k\u2264n) who could have the ball at the end of the game.\nIn the next line, output k numbers bi (1\u2264bi\u2264n) \u2014 the numbers of the players in increasing order. All numbers must be different.\nBelow is an illustration of three throws for the first test case. The arrows denote possible throw directions. Players who could have the ball after the throw are highlighted in gray.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "implementation",
            "*1200"
        ],
        "solutions": "1941D - Rudolf and the Ball GameLet's introduce a set of unique elements q, initially containing a single element x \u2014 the index of the first player who started the game. For each i from 1 to m, we will update q in such a way as to maintain the set of players who could have the ball after the i-th throw. For each element qj of the set q, we will remove qj from q, and also:   if ci=\"0\" or ci=\"?\", add to q the element ((qj+ri\u22121)\u00a0mod\u00a0n+1) \u2014 the index of the player who will receive the ball in case of a clockwise throw;  if ci=\"1\" or ci=\"?\", add to q the element ((qj\u2212ri\u22121+n)\u00a0mod\u00a0n+1) \u2014 the index of the player who will receive the ball in case of a counterclockwise throw. The term n before the mod operation is necessary to obtain a positive argument of this operation. Otherwise, in some programming languages, the mod function will return a negative result, which does not correspond to the semantics of the problem.  The operation u\u00a0mod\u00a0v denotes the remainder of the division of u by v. It should be noted that it is not needed to store duplicates in q \u2014 one index of the thrower is sufficient for the correct calculation of the players who could have received their throw.After the m-th iteration of the described cyclic process, the set q will contain the desired indices of all players who could have the ball at the end of the game.At each iteration of the loop, the power of q does not exceed n, and a total of exactly m iterations will be performed. Thus, the asymptotic complexity of the algorithm is of the order O(n\u2217m). Solution#include <iostream>\n#include <set>\n\nusing namespace std;\n\nint main()\n{\n    int t; cin >> t;\n    while (t--) {\n        int n, m, a; cin >> n >> m >> a;\n        set <int> q[2];\n        int ix = 0;\n        q[ix].insert(a);\n        while (m--) {\n            int x; char ch; cin >> x >> ch;\n            while (!q[ix].empty()) {\n                int u = *(q[ix].begin());\n                q[ix].erase(u);\n                if (ch == '?' || ch == '0') {\n                    q[ix ^ 1].insert((u + x - 1) % n + 1);\n                }\n                if (ch == '?' || ch == '1') {\n                    q[ix ^ 1].insert((u - x - 1 + n) % n + 1);\n                }\n            }\n            ix ^= 1;\n        }\n        cout << q[ix].size() << '\\n';\n        for (auto& x : q[ix]) {\n            cout << x << ' ';\n        }\n        cout << '\\n';\n    }\n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n66\n\n\n\n Good task \n\n    \n\n\n384\n\n\n\n Average task \n\n    \n\n\n35\n\n\n\n Bad task \n\n    \n\n\n35\n\n\n\n "
    },
    "1941B": {
        "title": "B. Rudolf and 121",
        "description": "Rudolf has an array a of n integers, the elements are numbered from 1 to n.\nIn one operation, he can choose an index i (2\u2264i\u2264n\u22121) and assign:\nRudolf can apply this operation any number of times. Any index i can be used zero or more times.\nCan he make all the elements of the array equal to zero using this operation?\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe first line of each case contains a single integer n (3\u2264n\u22642\u22c5105)\u00a0\u2014 the number of elements in the array.\nThe second line of each case contains n integers a1,a2,\u2026,an (0\u2264aj\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of the values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if it is possible to make all the elements of the array zero using the described operations. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first example, the original array is [1,3,5,5,2], to make all its elements zero, Rudolf can act as follows:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1941B - Rudolf and 121Author: Vladosiya TutorialTutorial is loading... Solutiondef solve():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    for i in range(n - 2):\n        if a[i] < 0:\n            print('NO')\n            return\n        op = a[i]\n        a[i] -= op\n        a[i + 1] -= 2 * op\n        a[i + 2] -= op\n    if a[-1] != 0 or a[-2] != 0:\n        print('NO')\n    else:\n        print('YES')\n    \n\nfor _ in range(int(input())):\n    solve() Rate the problem Didn't solve \n\n    \n\n\n139\n\n\n\n Good task \n\n    \n\n\n359\n\n\n\n Average task \n\n    \n\n\n56\n\n\n\n Bad task \n\n    \n\n\n153\n\n\n\n "
    },
    "1935B": {
        "title": "B. Informatics in MAC",
        "description": "In the Master's Assistance Center, Nyam-Nyam was given a homework assignment in informatics.\nThere is an array a of length n, and you want to divide it into k>1 subsegments\u2020 in such a way that the MEX\u2021 on each subsegment is equal to the same integer.\nHelp Nyam-Nyam find any suitable division, or determine that it does not exist.\n\u2020A division of an array into k subsegments is defined as k pairs of integers (l1,r1),(l2,r2),\u2026,(lk,rk) such that li\u2264ri and for each 1\u2264j\u2264k\u22121, lj+1=rj+1, and also l1=1 and rk=n. These pairs represent the subsegments themselves.\n\u2021MEX of an array is the smallest non-negative integer that does not belong to the array.\nFor example: \nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai<n) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u22121 if a suitable division does not exist.\nOtherwise, on the first line, output an integer k (2\u2264k\u2264n) \u2014 the number of subsegments in the division.\nThen output k lines \u2014 the division into subsegments. The i-th line should contain two integers li and ri (1\u2264li\u2264ri\u2264n) \u2014 the boundaries of the i-th subsegment.\nThe following conditions must be satisfied:\nIf there are multiple possible solutions, output any of them.\nIn the first test case, the array a can be divided into 2 subsegments with boundaries [1,1] and [2,2]: \nIn the second test case, it can be proven that the required division does not exist.\nIn the third test case, the array a can be divided into 3 subsegments with boundaries [1,3], [4,5], [6,8]: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1200"
        ],
        "solutions": "1935B - Informatics in MACIdea: AndreyPavlov  Preparation: AndreyPavlov, i_love_penguins  Editorial: AndreyPavlov HintsHint 1What is the minimum k that can be in a division? Hint 2Suppose MEX(x,y)=MEX(y+1,z), what can be said about MEX(x,z)? TutorialSuppose we correctly divided the array into k>2 segments \u2014 (1,r1),(l2,r2),\u2026,(lk,rk). Then, note that we can merge first two subsegments, as the numbers from 0 to mex\u22121 are encountered in these two segments and the number mex is not encountered in them. Therefore, if there is a division into k>2 segments, then there is also for k\u22121 segments.Therefore, it is sufficient to check whether there is a division of the array into k=2 segments, which can be done in O(n) by precalcing MEX on the prefixes and suffixes, then we need to find some i for which MEX(1,i)=MEX(i+1,n). Implementation on C++/* Includes */\n#include <bits/stdc++.h>\n \n/* Using libraries */\nusing namespace std;\n\n/* Defines */\n#define fast ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define vc vector\n#define pii pair <int, int>\n#define int long long\n \nvoid solve () {\n    int n;\n    cin >> n;\n    vc <int> a(n);\n    vc <int> cnt1(n + 1), cnt2(n + 1);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        cnt2[a[i]]++;\n    }\n    int mex1 = 0, mex2 = 0;\n    while (cnt2[mex2])\n        ++mex2;\n    for (int i = 0; i < n; ++i) {\n        cnt1[a[i]]++;\n        if (--cnt2[a[i]] == 0 && mex2 > a[i]) {\n            mex2 = a[i];\n        }\n        while (mex2 && !cnt2[mex2 - 1])\n            --mex2;\n        while (cnt1[mex1])\n            ++mex1;\n        if (mex1 == mex2) {\n            cout << \"2\\n\";\n            cout << 1 << \" \" << i + 1 << \"\\n\";\n            cout << i + 2 << \" \" << n << \"\\n\";\n            return;\n        }\n    }\n    cout << \"-1\\n\";\n}\n\nsigned main() {\n    fast;\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n} Implementation on Pythondef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    cur_mex = 0\n    cur_have = [0] * (n + 1)\n    for el in a:\n        cur_have[el] += 1\n    while cur_have[cur_mex]:\n        cur_mex += 1\n\n    another_mex = 0\n    another_have = [0] * (n + 1)\n    for i in range(n):\n        cur_have[a[i]] -= 1\n        if cur_have[a[i]] == 0 and cur_mex > a[i]:\n            cur_mex = a[i]\n\n        another_have[a[i]] += 1\n        while another_have[another_mex]:\n            another_mex += 1\n\n        if cur_mex == another_mex:\n            print(2)\n            print(\"1 \" + str(i + 1))\n            print(str(i + 2) + \" \" + str(n))\n            return\n\n    print(-1)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "1934B": {
        "title": "B. Yet Another Coin Problem",
        "description": "You have 5 different types of coins, each with a value equal to one of the first 5 triangular numbers: 1, 3, 6, 10, and 15. These coin types are available in abundance. Your goal is to find the minimum number of these coins required such that their total value sums up to exactly n.\nWe can show that the answer always exists.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264109)\u00a0\u2014 the target value.\nFor each test case, output a single number\u00a0\u2014 the minimum number of coins required.\nIn the first test case, for n=1, the answer is 1 since only one 1 value coin is sufficient. 1=1\u22c51.\nIn the fourth test case, for n=5, the answer is 3, which can be achieved using two 1 value coins and one 3 value coin. 5=2\u22c51+1\u22c53.\nIn the seventh test case, for n=12, the answer is 2, which can be achieved using two 6 value coins.\nIn the ninth test case, for n=16, the answer is 2, which can be achieved using one 1 value coin and one 15 value coin or using one 10 value coin and one 6 value coin. 16=1\u22c51+1\u22c515=1\u22c56+1\u22c510.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1934B \u2014 Yet Another Coin Problem Solution 1HintAt max how many 1, 3, 6, 10 are required? SolutionFact: You will never need more than 2 ones, 1 threes, 4 sixes and 2 tens.Reason: For 1: Suppose if you used k > 2 ones, then you could have used one 3 and k \u2014 3 ones. For 3: Suppose if you used k > 1 threes, then you could have used one 6 and k \u2014 2 threes.For 6: Suppose if you used k > 4 sixes, then you could have used two 15's and k \u2014 5 sixes.For 10: Suppose if you used k > 2 tens, then you could have used two 15's and k \u2014 3 tens.now since bound on their count is less, we can bruteforce on these count. Code (C++)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int testcases;\n    cin >> testcases;\n    for (int t = 1; t <= testcases; t++)\n    {\n        int n;\n        cin >> n;\n        int ans = 1e9;\n        for(int ones = 0; ones <= 2; ones++){\n            for(int threes = 0; threes <= 1; threes++){\n                for(int sixes = 0; sixes <= 4; sixes++){\n                    for(int tens = 0; tens <= 2; tens++){\n                        int brute_sum = 1*ones + 3*threes + 6*sixes + 10*tens;\n                        if(brute_sum <= n && (n-brute_sum)%15 == 0){\n                            ans = min(ans, ones + threes + sixes + tens + (n-brute_sum)/15);\n                        }\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n} Solution 2HintWhen will the greedy logic of choosing the higher-valued coin first work?  SolutionFact 1: If coins of value 1, 3, 6 and 15 were only present the greedy logic of selecting the higher valued first would work.Reason: We use coins of value one at most 2 times, coins of value three at most 1 time, coins of value six at most 2 times (if it was used 3 times, it would be better to use two coins 15+3) But we can't use the coin of value 3 and both coins of value 6 simultaneously, because we would prefer just using 15.It means that these coins may sum up to 1+1+3+6=11 or 1+1+6+6=14 at max. So, we may use the value 15 greedily, because the remaining part is less than 15. When we are left with only the values 1, 3, and 6, greedily solving is obviously correct, because each coin is a divisor of the next coin. Fact 2: We don't need more than 2 ten coins.Reason: Better to use 2 fifteen coins instead of 3 ten coins.Using the above two facts it can be shown that the answer will have k<3 ten coin, therefore, answer = min(answer(n\u221210\u2217k)+k assuming 1, 3, 6 and 15 coins are only present).  Code (C++)#include<bits/stdc++.h>\n \nusing namespace std;\n \nint getAns(int n){\n    int ans=0;\n    ans+=n/15;\n    n%=15;\n    ans+=n/6;\n    n%=6;\n    ans+=n/3;\n    n%=3;\n    ans+=n;\n    return ans;\n}\n \nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n \n    int testcases;\n    cin>>testcases;\n    for(int i=1;i<=testcases;i++){\n        int n;cin>>n;\n        if(n<10){\n            cout<<getAns(n)<<endl;\n        }else if(n<20){\n            cout<<min(getAns(n),getAns(n-10)+1)<<endl;\n        }else{\n            cout<<min({getAns(n),getAns(n-10)+1,getAns(n-20)+2})<<endl;\n        }\n    }\n}"
    },
    "1933D": {
        "title": "D. Turtle Tenacity: Continual Mods",
        "description": "Given an array a1,a2,\u2026,an, determine whether it is possible to rearrange its elements into b1,b2,\u2026,bn, such that b1modb2mod\u2026modbn\u22600.\nHere xmody denotes the remainder from dividing x by y. Also, the modulo operations are calculated from left to right. That is, xmodymodz=(xmody)modz. For example, 2024mod1000mod8=(2024mod1000)mod8=24mod8=0.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if it is possible, \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first test case, rearranging the array into b=[1,2,3,4,5,6] (doing nothing) would result in 1mod2mod3mod4mod5mod6=1. Hence it is possible to achieve the goal.\nIn the second test case, the array b must be equal to [3,3,3,3,3], which would result in 3mod3mod3mod3mod3=0. Hence it is impossible to achieve the goal.\nIn the third test case, rearranging the array into b=[3,2,2] would result in 3mod2mod2=1. Hence it is possible to achieve the goal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "sortings",
            "*1200"
        ],
        "solutions": "1933D - Turtle Tenacity: Continual ModsSort the array in non-decreasing order. Now, assume a1\u2264a2\u2264\u2026\u2264an.If a1\u2260a2, the minimum is unique. Therefore, place a1 at the front, and the result after all modulo operations is just a1>0. Hence the answer is yes for this case.If a1=a2 and there exists some element ax such that ax\u2261\u03380(moda1), then a possible solution is rearranging the array to [ax,a1,a2,\u2026,ax\u22121,ax+1,\u2026,an]. Since axmoda1<a1, axmoda1 is the minimum among the other elements and the result after all modulo operations equals axmoda1>0. Hence the answer is yes for this case.Otherwise (if all elements are multiples of the minimum) the answer is no, because any element modulo the minimum equals 0, and at least one of the minimums must not be the first element. So after passing through two minimums we are guaranteed to get a 0. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        int n;\n        cin >> n;\n        int a[n];\n        for(int i=0; i<n; i++) cin >> a[i];\n        sort(a, a + n);\n        if(a[0] != a[1]) {\n            cout << \"YES\\n\";\n        }\n        else {\n            bool PASS = 0;\n            for(int i=1; i<n; i++) {\n                if(a[i] % a[0] != 0) PASS = 1;\n            }\n            if(PASS) cout << \"YES\\n\";\n            else cout << \"NO\\n\";\n        }\n    }\n}"
    },
    "1933C": {
        "title": "C. Turtle Fingers: Count the Values of k",
        "description": "You are given three positive integers a, b and l (a,b,l>0). \nIt can be shown that there always exists a way to choose non-negative (i.e. \u22650) integers k, x, and y such that l=k\u22c5ax\u22c5by. \nYour task is to find the number of distinct possible values of k across all such ways.\nThe first line contains the integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe following t lines contain three integers, a, b and l (2\u2264a,b\u2264100, 1\u2264l\u2264106)\u00a0\u2014 description of a test case.\nOutput t lines, with the i-th (1\u2264i\u2264t) line containing an integer, the answer to the i-th test case.\nIn the first test case, a=2,b=5,l=20. The possible values of k (and corresponding x,y) are as follows: \nIn the second test case, a=2,b=5,l=21. Note that l=21 is not divisible by either a=2 or b=5. Therefore, we can only set x=0,y=0, which corresponds to k=21.\nIn the third test case, a=4,b=6,l=48. The possible values of k (and corresponding x,y) are as follows: ",
        "time limit": "time limit per test5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1933C - Turtle Fingers: Count the Values of kIdea: dbsbs, prepared: dbsbs, snowysecret TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nvoid solve(int tc){\n    int a, b, l;\n    cin >> a >> b >> l;\n    set<int> ans;\n    for(int i = 0; i <= 34; ++i){\n        int x = l;\n        bool fail = false;\n        for(int _ = 0; _ < i; ++_){\n            if(x % a){\n                fail = true;\n                break;\n            }\n            x /= a;\n        }\n        if(fail) break;\n        while(true){\n            ans.insert(x);\n            if(x % b) break;\n            x /= b;\n        }\n    }\n    cout << ans.size();\n}\n \nbool multi = true;\n \nsigned main() {\n    int t = 1;\n    if (multi)cin >> t;\n    for (int i = 1; i <= t; ++i) {\n        solve(i);\n        cout << \"\\n\";\n    }\n    return 0;\n}"
    },
    "1932B": {
        "title": "B. Chaya Calendar",
        "description": "The Chaya tribe believes that there are n signs of the apocalypse. Over time, it has been found out that the i-th sign occurs every ai years (in years ai, 2\u22c5ai, 3\u22c5ai, \u2026).\nAccording to the legends, for the apocalypse to happen, the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on. That is, if the i-th sign occurred in the year x, the tribe starts waiting for the occurrence of the (i+1)-th sign, starting from the year x+1.\nIn which year will the n-th sign occur and the apocalypse will happen?\nThe first line of the input contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the number of signs.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the periodicities of the signs.\nFor each test case, output a single integer\u00a0\u2014 the year in which all n signs will occur.\nIn the first set of input data of the example:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "number theory",
            "*1100"
        ],
        "solutions": "1932B - Chaya CalendarThe tribe will wait for the first sign in year a1. They will expect the second event in some year x>a1, which is divisible by a2, this will happen after a2\u2212a1moda2 years. Let's maintain the number cur of the year in which the i-th sign occurred, then the (i+1)-th will occur in the year cur+ai+1\u2212curmodai+1. Since this is the smallest year number divisible by ai+1, which is strictly greater than cur. Solutiondef solve():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    cur = 0\n    for e in a:\n        cur += e - cur % e\n    print(cur)\n \n \nfor _ in range(1, int(input()) + 1):\n    solve()"
    },
    "1931C": {
        "title": "C. Make Equal Again",
        "description": "You have an array a of n integers. \nYou can no more than once apply the following operation: select three integers i, j, x (1\u2264i\u2264j\u2264n) and assign all elements of the array with indexes from i to j the value x. The price of this operation depends on the selected indices and is equal to (j\u2212i+1) burles. \nFor example, the array is equal to [1,2,3,4,5,1]. If we choose i=2,j=4,x=8, then after applying this operation, the array will be equal to [1,8,8,8,5,1].\nWhat is the least amount of burles you need to spend to make all the elements of the array equal?\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of input test cases. The descriptions of the test cases follow.\nThe first line of the description of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the size of the array.\nThe second line of the description of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 array elements.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer \u2014 the minimum number of burles that will have to be spent to make all the elements of the array equal. It can be shown that this can always be done.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1931C - Make Equal AgainIf all the elements of the arrays are equal, then nothing additional needs to be done, and the answer is 0. Otherwise, you need to apply the assignment operation on the segment alone.Our goal is to choose the shortest possible segment, which means to exclude as many elements as possible from the beginning and end of the segment. Note that we can exclude only equal elements, and then assign a value equal to the excluded elements on the segment. Let's find the lengths of the maximum prefix and suffix consisting of equal elements. Let's denote by k the number of excluded elements, by k1 \u2014 the length of the maximum suitable prefix, by k2 \u2014 the maximum suitable suffix. Then if a0=an\u22121, then k=k1+k2 (exclude both prefix and suffix), otherwise k=max(k1,k2) (exclude the longer one).The answer is n\u2212k \u2014 all non-excluded elements must be replaced so that they become equal to the excluded one. Solutiondef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    i1 = 0\n    i2 = 0\n    while i1 < n and a[i1] == a[0]:\n        i1 += 1\n    while i2 < n and a[n - i2 - 1] == a[n - 1]:\n        i2 += 1\n    res = n\n    if a[0] == a[n - 1]:\n        res -= i1\n        res -= i2\n    else:\n        res -= max(i1, i2)\n    print(max(0, res))\n \n \nt = int(input())\n \n \nfor i in range(t):\n    solve()"
    },
    "1930B": {
        "title": "B. Permutation Printing",
        "description": "You are given a positive integer n.\nFind a permutation\u2020 p of length n such that there do not exist two distinct indices i and j (1\u2264i,j<n; i\u2260j) such that pi divides pj and pi+1 divides pj+1.\nRefer to the Notes section for some examples.\nUnder the constraints of this problem, it can be proven that at least one p exists.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output p1,p2,\u2026,pn.\nIf there are multiple solutions, you may output any one of them.\nIn the first test case, p=[4,1,2,3] is a valid permutation. However, the permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and j=3. Then p1=1 divides p3=3 and p2=2 divides p4=4. Note that the permutation p=[3,4,2,1] is also not a valid permutation as we can choose i=3 and j=2. Then p3=2 divides p2=4 and p4=1 divides p3=2.\nIn the second test case, p=[1,2,3] is a valid permutation. In fact, all 6 permutations of length 3 are valid.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solutions": "1930B - Permutation PrintingIdea: satyam343Editorial: satyam343 Hint 1For integers x (\u230an2\u230b<x\u2264n), there does not exist integer y (y>x) such that y is divisible by x. SolutionConsider the permutation p such that p=[1,n,2,n\u22121,\u2026\u2308n+12\u2309]. It is valid. Why? ProofWe have max(pa,pa+1)>\u230an2\u230b for all 1\u2264a<n\u22121. So we cannot ever have a pair of integers (a,b) such that:  1\u2264a<n\u22121 1\u2264b<n a\u2260b pa divides pb and pa+1 divides pb+1 Now, we just need to check for a=n\u22121. First of all, notice that pa does not divide p1.There does not exist an integer b (2\u2264b<n\u22121) such that pa+1 divides pb+1 as 2\u22c5pa+1\u2265n and pc+1<n for all c (2\u2264c<n\u22121).Note that we covered all possible pairs of indices and did not find two distinct indices i and j (1\u2264i,j<n; i\u2260j) such that pi divides pj and pi+1 divides pj+1. Code#include <bits/stdc++.h>     \nusing namespace std;\n#define ll long long\nvoid solve(){ \n    ll n; cin>>n;\n    ll l=1,r=n;\n    for(ll i=1;i<=n;i++){\n        if(i&1){\n            cout<<l<<\" \";\n            l++;\n        }\n        else{\n            cout<<r<<\" \";\n            r--;\n        }\n    }\n    cout<<\"\\n\";\n    return;  \n}                                       \nint main()                                                                               \n{       \n    ios_base::sync_with_stdio(false);                         \n    cin.tie(NULL);                               \n    #ifndef ONLINE_JUDGE                   \n    freopen(\"input.txt\", \"r\", stdin);                                           \n    freopen(\"output.txt\", \"w\", stdout);      \n    freopen(\"error.txt\", \"w\", stderr);                        \n    #endif     \n    ll test_cases=1;                 \n    cin>>test_cases;\n    while(test_cases--){\n        solve();\n    }\n    cout<<fixed<<setprecision(10);\n    cerr<<\"Time:\"<<1000*((double)clock())/(double)CLOCKS_PER_SEC<<\"ms\\n\"; \n}  video editorial by aryanc403"
    },
    "1928B": {
        "title": "B. Equalize",
        "description": "Vasya has two hobbies\u00a0\u2014 adding permutations\u2020 to arrays and finding the most frequently occurring element. Recently, he found an array a and decided to find out the maximum number of elements equal to the same number in the array a that he can obtain after adding some permutation to the array a.\nMore formally, Vasya must choose exactly one permutation p1,p2,p3,\u2026,pn of length n, and then change the elements of the array a according to the rule ai:=ai+pi. After that, Vasya counts how many times each number occurs in the array a and takes the maximum of these values. You need to determine the maximum value he can obtain.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single number\u00a0\u2014 the maximum number of elements equal to the same number after the operation of adding a permutation.\nIn the first test case, it is optimal to choose p=[2,1]. Then after applying the operation, the array a will be [3,3], in which the number 3 occurs twice, so the answer is 2.\nIn the second test case, one of the optimal options is p=[2,3,1,4]. After applying the operation, the array a will be [9,4,5,5]. Since the number 5 occurs twice, the answer is 2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1928B - Equalize SolutionSuppose we already know the permutation that needs to be added. Let's consider the elements that will become equal after the addition. Notice that among them there cannot be equal elements, because among the numbers we are adding, there are no duplicates. Thus, only a set of numbers among which there are no equal ones, and the difference between the maximum and minimum does not exceed n\u22121, can become equal. It is easy to see that any set of numbers satisfying these conditions can be equalized, and any set of numbers that became equal after adding the permutation satisfies these constraints.So let's sort the array, remove the equal elements from it. After that, we can use two pointers to find the maximum length subarray where the difference between the maximum and minimum does not exceed n\u22121. The answer will be the length of such a subarray. The complexity of the solution is O(nlogn). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    a.resize(unique(a.begin(), a.end()) - a.begin());\n    int pnt = 0, ans = 0;\n    for (int i = 0; i < a.size(); i++) {\n        while(a[i] - a[pnt] >= n) {\n            pnt++;\n        }\n        ans = max(ans, i - pnt + 1);\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n    int t = 1;\n    cin >> t;\n    for (int i = 0; i < t; ++i) {\n        solve();\n    }\n    return 0;\n}"
    },
    "1927C": {
        "title": "C. Choose the Different Ones!",
        "description": "Given an array a of n integers, an array b of m integers, and an even number k.\nYour task is to determine whether it is possible to choose exactly k2 elements from both arrays in such a way that among the chosen elements, every integer from 1 to k is included.\nFor example:\nNote that you are not required to find a way to choose the elements\u00a0\u2014 your program should only check whether it is possible to choose the elements in the required way.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains three integers n, m, and k (1\u2264n,m\u22642\u22c5105, 2\u2264k\u22642\u22c5min(n,m), k is even)\u00a0\u2014 the length of array a, the length of array b, and the number of elements to be chosen, respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the elements of array a.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bj\u2264106)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of values n and m over all test cases in a test does not exceed 4\u22c5105.\nOutput t lines, each of which is the answer to the corresponding test case. As the answer, output \"YES\" if it is possible to choose k2 numbers from each array in such a way that among the chosen elements, every integer from 1 to k is included. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first test case of the example, it is possible to choose elements equal to 2, 3, and 6 from array a and elements equal to 1, 4, and 5 from array b. Thus, all numbers from 1 to k=6 are included among the chosen elements.\nIn the second test case of the example, it can be shown that it is not possible to choose exactly three elements from each array in the required way.\nIn the third test case of the example, it is possible to choose elements equal to 1 and 3 from array a and elements equal to 2 and 4 from array b. Thus, all numbers from 1 to k=4 are included among the chosen elements.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1927C - Choose the Different Ones!Notice that elements with a value greater than k are not relevant to us. Let's divide the values into three categories:  Occurring only in array a;  occurring only in array b;  occurring in both arrays. The answer will be NO if any of the following conditions are met:  the number of values of the first type is greater than k2 (this implies that we cannot select all such elements);  the number of values of the second type is greater than k2 (this implies that we cannot select all such elements);  the total number of values of all three types is less than k (this implies that some values do not occur in either of the arrays). Otherwise, the answer is YES. Solutiondef solve():\n    n, m, k = map(int, input().split())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    cnt = [0] * (k + 1)\n    for e in a:\n        if e <= k:\n            cnt[e] |= 1\n    for e in b:\n        if e <= k:\n            cnt[e] |= 2\n    c = [0] * 4\n    for e in cnt:\n        c[e] += 1\n    if c[1] > k // 2 or c[2] > k // 2 or c[1] + c[2] + c[3] != k:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n \n \nfor _ in range(int(input())):\n    solve()"
    },
    "1926C": {
        "title": "C. Vlad and a Sum of Sum of Digits",
        "description": "Please note that the time limit for this problem is only 0.5 seconds per test.\nVladislav wrote the integers from 1 to n, inclusive, on the board. Then he replaced each integer with the sum of its digits.\nWhat is the sum of the numbers on the board now?\nFor example, if n=12 then initially the numbers on the board are: 1,2,3,4,5,6,7,8,9,10,11,12. Then after the replacement, the numbers become: 1,2,3,4,5,6,7,8,9,1,2,3. The sum of these numbers is 1+2+3+4+5+6+7+8+9+1+2+3=51. Thus, for n=12 the answer is 51.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the largest number Vladislav writes.\nFor each test case, output a single integer\u00a0\u2014 the sum of the numbers at the end of the process.",
        "time limit": "time limit per test0.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*1200"
        ],
        "solutions": "1926C - Vlad and a Sum of Sum of DigitsLet's denote S(x) as the sum of digits of number x. Since n\u22642\u22c5105, for a single test case, we can brute force S(1)+S(2)+S(3)+\u22ef+S(n) and output the answer. However, since the number of test cases is large, we can't compute this value for n each time. This needs a standard idea of precomputation: we will compute the answer for each value from 1 to n and store it in an array ans: ans(n)=S(n)+ans(n\u22121). Then to answer each test case we just output ans(n). No math is needed!The precomputation takes O(nlogn) time (it takes O(logn) time to find sum of digits), but now we can answer queries in O(1) per test case, so overall the complexity is O(nlogn+t). Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nint res[MAX];\n \nint S(int x) {\n\tint res = 0;\n\twhile (x) {\n\t\tres += (x % 10);\n\t\tx /= 10;\n\t}\n\treturn res;\n}\n \nvoid solve() {\n\tint x;\n\tcin >> x;\n\tcout << res[x] << '\\n';\n}\n \nint main() {\n\tres[0] = 0;\n\tfor (int i = 1; i < MAX; i++) {\n\t\tres[i] = res[i - 1] + S(i);\n\t}\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n"
    },
    "1925B": {
        "title": "B. A Balanced Problemset?",
        "description": "Jay managed to create a problem of difficulty x and decided to make it the second problem for Codeforces Round #921. \nBut Yash fears that this problem will make the contest highly unbalanced, and the coordinator will reject it. So, he decided to break it up into a problemset of n sub-problems such that the difficulties of all the sub-problems are a positive integer and their sum is equal to x. \nThe coordinator, Aleksey, defines the balance of a problemset as the GCD of the difficulties of all sub-problems in the problemset. \nFind the maximum balance that Yash can achieve if he chooses the difficulties of the sub-problems optimally.\nThe first line of input contains a single integer t (1\u2264t\u2264103) denoting the number of test cases.\nEach test case contains a single line of input containing two integers x (1\u2264x\u2264108) and n (1\u2264n\u2264x).\nFor each test case, print a single line containing a single integer denoting the maximum balance of the problemset Yash can achieve.\nFor the first test case, one possible way is to break up the problem of difficulty 10 into a problemset having three problems of difficulties 4, 2 and 4 respectively, giving a balance equal to 2.\nFor the second test case, there is only one way to break up the problem of difficulty 5 into a problemset of 5 problems with each problem having a difficulty 1 giving a balance equal to 1.",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1923B": {
        "title": "B. Monsters Attack!",
        "description": "You are playing a computer game. The current level of this game can be modeled as a straight line. Your character is in point 0 of this line. There are n monsters trying to kill your character; the i-th monster has health equal to ai and is initially in the point xi.\nEvery second, the following happens:\nCan you survive and kill all n monsters without letting any of them reach your character?\nThe first line of the input contains one integer t (1\u2264t\u22643\u22c5104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input: the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, print YES if you can kill all n monsters before they reach your character, or NO otherwise.\nYou can output each letter of the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will all be recognized as positive responses.\nIn the first example, you can act as follows:\nIn the second example, you can fire only 1 bullet, so you can kill only one of the two monsters during the 1-st second. Then, the remaining monster moves closer and kills your character.",
        "time limit": "time limit per test2.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1923B - Monsters Attack!Let's look at monsters at distance of 1 (i.\u2009e. in positions 1 and \u22121). We must kill them in the 1-st second, so their total hp (let denote it as s1) should not exceed k. If this condition is not met, the answer is NO. Otherwise, we can say that there are k\u2212s1 bullets left unused during the first second (let denote it as lft). Now let's look at the monsters at a distance of 2. We must kill them no later than the 2-nd second. We have k bullets for the 2-nd second plus lft unused bullets from the 1-st second, so total hp of monsters at distance 2 should not exceed k+lft. We can see that the situation is similar to the 1-st second, if the condition is not met, then the answer is NO, otherwise we move on to the next distance with the updated value of lft.If all n seconds are considered and all conditions are met, then the answer is YES.Therefore, we got a solution that works in O(n). Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n), x(n);\n    for (auto& it : a) cin >> it;\n    for (auto& it : x) cin >> it;\n    vector<long long> s(n + 1);\n    for (int i = 0; i < n; ++i) s[abs(x[i])] += a[i];\n    bool ok = true;\n    long long lft = 0;\n    for (int i = 1; i <= n; ++i) {\n      lft += k - s[i];\n      ok &= (lft >= 0);\n    }\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n  }\n}"
    },
    "1922B": {
        "title": "B. Forming Triangles",
        "description": "You have $$$n$$$ sticks, numbered from $$$1$$$ to $$$n$$$. The length of the $$$i$$$-th stick is $$$2^{a_i}$$$.\nYou want to choose exactly $$$3$$$ sticks out of the given $$$n$$$ sticks, and form a non-degenerate triangle out of them, using the sticks as the sides of the triangle. A triangle is called non-degenerate if its area is strictly greater than $$$0$$$.\nYou have to calculate the number of ways to choose exactly $$$3$$$ sticks so that a triangle can be formed out of them. Note that the order of choosing sticks does not matter (for example, choosing the $$$1$$$-st, $$$2$$$-nd and $$$4$$$-th stick is the same as choosing the $$$2$$$-nd, $$$4$$$-th and $$$1$$$-st stick). \nThe first line contains one integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) \u2014 the number of test cases.\nEach test case consists of two lines:\nAdditional constraint on the input: the sum of $$$n$$$ over all test cases does not exceed $$$3 \\cdot 10^5$$$.\nFor each test case, print one integer \u2014 the number of ways to choose exactly $$$3$$$ sticks so that a triangle can be formed out of them.\nIn the first test case of the example, any three sticks out of the given $$$7$$$ can be chosen.\nIn the second test case of the example, you can choose the $$$1$$$-st, $$$2$$$-nd and $$$4$$$-th stick, or the $$$1$$$-st, $$$3$$$-rd and $$$4$$$-th stick.\nIn the third test case of the example, you cannot form a triangle out of the given sticks with lengths $$$2$$$, $$$4$$$ and $$$8$$$.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1922B - Forming TrianglesAt first, let's figure out which sticks can be used to make a triangle. Let's denote the length of the longest stick as 2s0, the shortest stick as 2s2 and the middle stick as 2s1 (in other words, s is an array of length 3, consisting of three sticks for a triangle, sorted in non-ascending order). Important fact: s0==s1. It's true because if s0>s1, then 2s0\u22652s1+2s2 and the triangle is degenerate. At the same time, the value of the s2 can be any integer from 0 to s0.So all we have to do is calculate the number of triples of sticks such that there are two or three maximums in the triple. Let's create an array cnt, where cnti is the number of sticks of length 2i, and the array sumCnt, where sumCnti is the number of sticks no longer than 2i. Now let's iterate over the length of the longest stick in the triangle (denote it as m). Then there are two cases:   All three sticks in a triangle are equal. Then the number of such triangles can be computed with a binomial coefficient: cntm\u2217(cntm\u22121)\u2217(cntm\u22122)6;  Only two sticks are equal (and have the same length). Then the number of such triangles is cntm\u2217(cntm\u22121)2\u22c5sumCntm\u22121.  Solution (Roms)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint t;\n \nint main() {\n    cin >> t;\n    for (int tc = 0; tc < t; ++tc) {\n        int n;\n        cin >> n;\n        map<int, int> numOfLens;\n        for (int i = 0; i < n; ++i){\n            int x;\n            cin >> x;\n            ++numOfLens[x];\n        }\n        \n        long long res = 0;\n        int sum = 0;\n        for (auto it : numOfLens) {\n            long long cnt = it.second;\n            if(cnt >= 3)\n                res += cnt * (cnt - 1) * (cnt - 2) / 6;\n            if(cnt >= 2)\n                res += cnt * (cnt - 1) / 2 * sum;\n            sum += cnt;\n        }\n        \n        cout << res << endl;\n    }\n    return 0;\n}"
    },
    "1921D": {
        "title": "D. Very Different Array",
        "description": "Petya has an array ai of n integers. His brother Vasya became envious and decided to make his own array of n integers.\nTo do this, he found m integers bi (m\u2265n), and now he wants to choose some n integers of them and arrange them in a certain order to obtain an array ci of length n.\nTo avoid being similar to his brother, Vasya wants to make his array as different as possible from Petya's array. Specifically, he wants the total difference D=\u2211ni=1|ai\u2212ci| to be as large as possible.\nHelp Vasya find the maximum difference D he can obtain.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains two integers n and m (1\u2264n\u2264m\u22642\u22c5105).\nThe second line of each test case contains n integers ai (1\u2264ai\u2264109). The third line of each test case contains m integers bi (1\u2264bi\u2264109).\nIt is guaranteed that in a test, the sum of m over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the maximum total difference D that can be obtained.\nIn the first example, Vasya can, for example, create the array (1,5,7,2). Then the total difference will be D=|6\u22121|+|1\u22125|+|2\u22127|+|4\u22122|=5+4+5+2=16.\nIn the second example, all the integers available to Vasya are equal to 1, so he can only create the array (1,1,1), for which the difference D=0.\nIn the third example, Vasya can, for example, create the array (5,4,3,2,1). Then the total difference will be D=|1\u22125|+|2\u22124|+|3\u22123|+|4\u22122|+|5\u22121|=4+2+0+2+4=12.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1921D - Very Different ArrayLet's sort the array a in ascending order, and the array b in descending order. Notice that small elements of array a need to be matched with large elements of array b and vice versa. Thus, for some k, we need to take a prefix of array b of length k and a suffix of length n\u2212k, and form array c from them. We iterate over the value of k from 0 to n, and each time k changes by 1, only one element of array c changes, so we can recalculate the value of D in O(1). We select the maximum value of D from the obtained values to get the answer. This solution works in O(n) time plus the initial sorting in O(nlogn).There are other ways to solve the problem in the same time complexity. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nstruct test {\n   void solve() {\n        int n, m;\n        cin >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) cin >> b[i];\n        sort(a.begin(), a.end());\n        sort(b.rbegin(), b.rend());\n        vector<int> c(n);\n        long long s = 0;\n        for (int i = 0; i < n; i++) {\n            c[i] = b[m &mdash; n + i];\n            s += abs(c[i] &mdash; a[i]);\n        }\n        long long res = 0;\n        for (int k = 0; k <= n; k++) {\n            res = max(res, s);\n            if (k < n) {\n                s -= abs(c[k] &mdash; a[k]);\n                c[k] = b[k];\n                s += abs(c[k] &mdash; a[k]);\n            }\n        }\n        cout << res << \"\\n\";\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        test().solve();\n    }\n    return 0;\n}"
    },
    "1920B": {
        "title": "B. Summation Game",
        "description": "Alice and Bob are playing a game. They have an array a1,a2,\u2026,an. The game consists of two steps:\nAlice wants to maximize the sum of elements of the array while Bob wants to minimize it. Find the sum of elements of the array after the game if both players play optimally.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers n, k, and x (1\u2264n\u22642\u22c5105, 1\u2264x,k\u2264n) \u2014 the number of elements in the array, the limit on the number of elements of the array that Alice can remove, and the limit on the number of elements of the array that Bob can multiply \u22121 to.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641000) \u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output a single integer \u2014 the sum of elements of the array after the game if both players play optimally.\nIn the first test case, it is optimal for Alice to remove the only element of the array. Then, the sum of elements of the array is 0 after the game is over.\nIn the second test case, it is optimal for Alice to not remove any elements. Bob will then multiply 4 by \u22121. So the final sum of elements of the array is 3+1+2\u22124=2.\nIn the fifth test case, it is optimal for Alice to remove 9,9. Bob will then multiply 5,5,3 by \u22121. So the final sum of elements of the array is \u22125\u22125\u22123+3+3+2=\u22125.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1920B - Summation Game Hint 1What is the optimal strategy for Bob? Hint 2It is optimal for Bob to negate the x largest elements of the array. So what should Alice do? SolutionIt is optimal for Bob to negate the x largest elements of the array. So in order to minimize the damage Bob will do, Alice should always remove some number of largest elements. To solve the problem, we can sort the array and iterate over i (0\u2264i\u2264k) where i is the number of elements Alice removes. For each i, we know that Alice will remove the i largest elements of the array and Bob will then negate the x largest remaining elements. So the sum at the end can be calculated quickly with prefix sums. The time complexity is O(nlogn) because of sorting. Code#include <bits/stdc++.h>\nusing namespace std; \n\nvoid solve(){\n    int n, k, x;\n    cin >> n >> k >> x;\n    \n    int A[n + 1] = {};\n    for (int i = 1; i <= n; i++)\n        cin >> A[i];\n    \n    sort(A + 1, A + n + 1, greater<int>());\n\n    for (int i = 1; i <= n; i++)\n        A[i] += A[i - 1];\n    \n    int ans = -1e9;\n    for (int i = 0; i <= k; i++)\n        ans = max(ans, A[n] - 2 * A[min(i + x, n)] + A[i]);\n    \n    cout<<ans<<\"\\n\";\n}\n\nint main(){\n    ios_base::sync_with_stdio(0); cin.tie(0); \n    int tc; \n    cin >> tc;\n    \n    while (tc--) \n        solve();\n}"
    },
    "1917B": {
        "title": "B. Erase First or Second Letter",
        "description": "You are given a string s of length n. Let's define two operations you can apply on the string:\nYour task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains n (1\u2264n\u2264105) \u2014 the length of the string.\nThe second line of each test case contains the string s. It is guaranteed that the string only contains lowercase letters of the English alphabet.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer: the number of distinct non-empty strings you can get.\nIn the first test case, we can get the following strings: a, aa, aaa, aaaa, aaaaa.\nIn the third test case, for example, the word ba can be reached in the following way:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "dp",
            "strings",
            "*1100"
        ],
        "solutions": "1917B - Erase First or Second LetterAuthor: _LeMur_  Preparation: _LeMur_  Editorial: zidder  Official solution: 238752759  Hint 1Do we need to use the first operation after the second operation? Hint 2Try to fix the number of the applied first operation. How many different strings can be obtained? Hint 3When can two reached strings be the same? Hint 4Try to consider the first occurrence for each letter. SolutionLet's first see, that applying the second operation and then the first is equivalent to applying the first operation twice. In the former case the string will become s1s2s3\u2026sn\u2192s1s3\u2026sn\u2192s3\u2026sn, and in the latter case: s1s2s3\u2026sn\u2192s2s3\u2026sn\u2192s3\u2026sn. As we are concerned with only the number of distinct resulting strings, let's assume that the second operation is never done before the first operation. This means we do op1 first operations (possibly zero) and then op2 second operations (possibly zero).Let's now find the result of applying i of the first and then j of the second operations. It's easy to see, that the result is si+1si+j+2si+j+3\u2026sn.The only remaining question is in which cases two sequences of operations such that the first operation always comes before the second result in the same string. Consider for the (i1,j1) pair, the resulting string is the same as for the (i2,j2) pair. We can see that i1+j1=i2+j2, because the number of erased letters should be the same to get strings of the same length. Next, si1+1=si2+1 as those are the first letters of two resulting equal strings. It's easy to see that these conditions are also sufficient for the result to be the same string.If after applying the first operation op1 times the first letter is not its first occurrence, then any subsequent result could have been achieved by less operations of the first type by removing first character until reaching that letter and then by removing the second character until we reach op1 operations in total. This means we need to consider using the second operation only at the first occurrence of the letter.The final solution can look like this: for each letter a\u2026z find it's first occurrence. If the letter is found, any number of second type operations lead to a different result. Thus we can just calculate the number of second operations that is valid and add that to the answer."
    },
    "1916C": {
        "title": "C. Training Before the Olympiad",
        "description": "Masha and Olya have an important team olympiad coming up soon. In honor of this, Masha, for warm-up, suggested playing a game with Olya:\nThere is an array $$$a$$$ of size $$$n$$$. Masha goes first, and the players take turns. Each move is described by the following sequence of actions:\n$$$\\bullet$$$ If the size of the array is $$$1$$$, the game ends.\n$$$\\bullet$$$ The player who is currently playing chooses two different indices $$$i$$$, $$$j$$$ ($$$1 \\le i, j \\le |a|$$$), and performs the following operation\u00a0\u2014 removes $$$a_i$$$ and $$$a_j$$$ from the array and adds to the array a number equal to $$$\\lfloor \\frac{a_i + a_j}{2} \\rfloor \\cdot 2$$$. In other words, first divides the sum of the numbers $$$a_i$$$, $$$a_j$$$ by $$$2$$$ rounding down, and then multiplies the result by $$$2$$$.\nMasha aims to maximize the final number, while Olya aims to minimize it.\nMasha and Olya decided to play on each non-empty prefix of the initial array $$$a$$$, and asked for your help.\nFor each $$$k = 1, 2, \\ldots, n$$$, answer the following question. Let only the first $$$k$$$ elements of the array $$$a$$$ be present in the game, with indices $$$1, 2, \\ldots, k$$$ respectively. What number will remain at the end with optimal play by both players?\nThe first line contains an integer $$$t$$$ ($$$1 \\leq t \\leq 10^4$$$)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer $$$n$$$ ($$$1 \\le n \\le 10^5$$$)\u00a0\u2014 the size of the array.\nThe second line contains $$$n$$$ integers $$$a_1,a_2, \\ldots,a_n$$$ ($$$1 \\leq a_i \\leq 10^9$$$)\u00a0\u2014 the array on which Masha and Olya play.\nIt is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$10^5$$$.\nFor each test case, output $$$n$$$ integers. The $$$k$$$-th of these numbers should be equal to the number that will remain at the end with optimal play by both players, on the array consisting of the first $$$k$$$ elements of the array $$$a$$$.\nIn the third test case, for a prefix of length $$$1$$$, the answer is $$$3$$$. For a prefix of length $$$2$$$, Masha has only one move, so the answer is $$$12$$$. For a prefix of length $$$3$$$, Masha has three possible moves: she chooses $$$3$$$ and $$$10$$$, then the final number is $$$22$$$, $$$3$$$ and $$$11$$$, then the final number is $$$24$$$, $$$10$$$ and $$$11$$$, then the final number is $$$22$$$, so Masha will choose $$$3$$$ and $$$11$$$ and get $$$24$$$.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1916C - Training Before the OlympiadNote that our operation replaces two numbers with their sum if they are of the same parity, and with their sum \u22121 otherwise. Therefore, the second player needs to perform as many operations as possible where an even and an odd number are used. Also, note that on any move of the second player, there will be at least one even number that the first player made on the previous move. Then our task for the first player is to remove two odd numbers as often as possible. It can also be observed that the number of odd numbers in the array does not decrease, which means all operations with two odd numbers will go before operations with two even numbers. And after each such move, the second player will remove one odd number from the array. That is, in two moves, the number of odd numbers decreases by 3. Let's consider all possible remainders of the number of odd numbers modulo 3. If the remainder is 0, then the answer is sum\u2212cnt3, where sum is the sum of all numbers. If the remainder modulo is 1, then two situations are possible: when the size of the array is 1\u00a0\u2014 then the answer is the single number in the array. Otherwise, at the moment when there is 1 odd number left, there will be one more move of player number 2, which means he will reduce the total sum once more, and the answer will be sum\u2212\u230acnt3\u230b\u22121. If the remainder modulo is 2, then the number of moves when the second player reduces the sum does not change, so the answer is sum\u2212\u230acnt3\u230b.author: OR_LOVe, developer: zwezdinv "
    },
    "1916B": {
        "title": "B. Two Divisors",
        "description": "A certain number 1\u2264x\u2264109 is chosen. You are given two integers a and b, which are the two largest divisors of the number x. At the same time, the condition 1\u2264a<b<x is satisfied.\nFor the given numbers a, b, you need to find the value of x.\n\u2020 The number y is a divisor of the number x if there is an integer k such that x=y\u22c5k.\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe only line of each test cases contains two integers a, b (1\u2264a<b\u2264109).\nIt is guaranteed that a, b are the two largest divisors for some number 1\u2264x\u2264109.\nFor each test case, output the number x, such that a and b are the two largest divisors of the number x.\nIf there are several answers, print any of them.\nFor the first test case, all divisors less than 6 are equal to [1,2,3], among them the two largest will be 2 and 3.\nFor the third test case, all divisors less than 33 are equal to [1,3,11], among them the two largest will be 3 and 11.\nFor the fifth test case, all divisors less than 20 are equal to [1,2,4,5,10], among them the two largest will be 5 and 10.\nFor the sixth test case, all divisors less than 12 are equal to [1,2,3,4,6], among them the two largest will be 4 and 6.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1916B - Two DivisorsFirst case: $$$b \\mod a = 0$$$.In this case, $$$b = a \\cdot p$$$, where $$$p$$$ is the smallest prime factor of $$$x$$$. Then $$$x = b \\cdot p = b \\cdot \\frac{b}{a}$$$.Second case: $$$b \\mod a \\neq 0$$$.In this case, $$$b = \\frac{x}{p}, a = \\frac{x}{q}$$$, where $$$p, q$$$ are the two smallest prime factors of $$$x$$$. Then $$$\\gcd(a, b) = \\frac{x}{p \\cdot q}, x = b \\cdot p = b \\cdot \\frac{a}{\\gcd(a, b)}$$$.author: sadness, developer: marzipan "
    },
    "1914D": {
        "title": "D. Three Activities",
        "description": "Winter holidays are coming up. They are going to last for n days.\nDuring the holidays, Monocarp wants to try all of these activities exactly once with his friends: \nMonocarp knows that, on the i-th day, exactly ai friends will join him for skiing, bi friends will join him for a movie and ci friends will join him for board games.\nMonocarp also knows that he can't try more than one activity in a single day.\nThus, he asks you to help him choose three distinct days x,y,z in such a way that the total number of friends to join him for the activities (ax+by+cz) is maximized.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the duration of the winter holidays in days.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for skiing on the i-th day.\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for a movie on the i-th day.\nThe fourth line contains n integers c1,c2,\u2026,cn (1\u2264ci\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for board games on the i-th day.\nThe sum of n over all testcases doesn't exceed 105.\nFor each testcase, print a single integer\u00a0\u2014 the maximum total number of friends that can join Monocarp for the activities on three distinct days.\nIn the first testcase, Monocarp can choose day 2 for skiing, day 1 for a movie and day 3 for board games. This way, a2=10 friends will join him for skiing, b1=10 friends will join him for a movie and c3=10 friends will join him for board games. The total number of friends is 30.\nIn the second testcase, Monocarp can choose day 1 for skiing, day 4 for a movie and day 2 for board games. 30+20+25=75 friends in total. Note that Monocarp can't choose day 1 for all activities, because he can't try more than one activity in a single day.\nIn the third testcase, Monocarp can choose day 2 for skiing, day 3 for a movie and day 7 for board games. 19+19+17=55 friends in total.\nIn the fourth testcase, Monocarp can choose day 1 for skiing, day 4 for a movie and day 9 for board games. 17+19+20=56 friends in total.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1914D - Three ActivitiesThe main idea of the problem is that almost always you can take the maximum in each array. And when you can't, you don't need to look at a lot of smaller numbers. In particular, it is enough to consider the three largest numbers from each array.Let's show the correctness of this for the first array. There always exists an optimal answer in which one of the three largest numbers is taken from array a. Let's fix some taken elements in arrays b and c. Then at least one of the three positions of the largest elements in a is different from both fixed position.The argument is generalized to all three arrays similarly.Thus, the solution looks as follows. Find the positions of the three maximums in each array and iterate over the answer in 33. Finding three maximums can be done using sorting or in one linear time pass over the array. Solution (awoo)for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\tc = list(map(int, input().split()))\n\t\n\tdef get_best3(a):\n\t\tmx1, mx2, mx3 = -1, -1, -1\n\t\tfor i in range(len(a)):\n\t\t\tif mx1 == -1 or a[i] > a[mx1]:\n\t\t\t\tmx3 = mx2\n\t\t\t\tmx2 = mx1\n\t\t\t\tmx1 = i\n\t\t\telif mx2 == -1 or a[i] > a[mx2]:\n\t\t\t\tmx3 = mx2\n\t\t\t\tmx2 = i\n\t\t\telif mx3 == -1 or a[i] > a[mx3]:\n\t\t\t\tmx3 = i\n\t\treturn (mx1, mx2, mx3)\n\t\n\tans = 0\n\tfor x in get_best3(a):\n\t\tfor y in get_best3(b):\n\t\t\tfor z in get_best3(c):\n\t\t\t\tif x != y and x != z and y != z:\n\t\t\t\t\tans = max(ans, a[x] + b[y] + c[z])\n\tprint(ans)"
    },
    "1914C": {
        "title": "C. Quests",
        "description": "Monocarp is playing a computer game. In order to level up his character, he can complete quests. There are n quests in the game, numbered from 1 to n.\nMonocarp can complete quests according to the following rules: \nNote that Monocarp can complete the same quest multiple times.\nFor each completion, the character gets some amount of experience points: \nMonocarp is a very busy person, so he has free time to complete no more than k quests. Your task is to calculate the maximum possible total experience Monocarp can get if he can complete no more than k quests.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105; 1\u2264k\u22642\u22c5105)\u00a0\u2014 the number of quests and the maximum number of quests Monocarp can complete, respectively.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264103).\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264103).\nAdditional constraint on the input: the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the maximum possible total experience Monocarp can get if he can complete no more than k quests.\nIn the first test case, one of the possible quest completion sequences is as follows: 1,1,2,3,2,4,4; its total experience is equal to 4_+1+3_+1_+1+2_+1=13 (the underlined numbers correspond to the instances when we complete a quest for the first time).\nIn the second test case, one of the possible quest completion sequences is as follows: 1,1; its total experience is equal to 1_+3=4.\nIn the third test case, one of the possible quest completion sequences is as follows: 1,2,2,2,3; its total experience is equal to 3_+2_+3+3+4_=15.",
        "time limit": "time limit per test2.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1914C - QuestsIdea: Roms TutorialTutorial is loading... Solution (Neon)fun main() = repeat(readLine()!!.toInt()) {\n  val (n, k) = readLine()!!.split(\" \").map { it.toInt() }\n  val a = readLine()!!.split(\" \").map { it.toInt() }\n  val b = readLine()!!.split(\" \").map { it.toInt() }\n  var (res, sum, mx) = intArrayOf(0, 0, 0)\n  for (i in 0 until minOf(n, k)) {\n    sum += a[i]\n    mx = maxOf(mx, b[i])\n    res = maxOf(res, sum + mx * (k - i - 1))\n  }\n  println(res)\n}"
    },
    "1913B": {
        "title": "B. Swap and Delete",
        "description": "You are given a binary string s (a string consisting only of 0-s and 1-s).\nYou can perform two types of operations on s: \nYou can perform these operations any number of times and in any order.\nLet's name a string you've got after performing operations above as t. The string t is good if for each i from 1 to |t| ti\u2260si (|t| is the length of the string t). The empty string is always good. Note that you are comparing the resulting string t with the initial string s.\nWhat is the minimum total cost to make the string t good?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t test cases follow.\nThe only line of each test case contains a binary string s (1\u2264|s|\u22642\u22c5105; si\u2208{0, 1})\u00a0\u2014 the initial string, consisting of characters 0 and/or 1.\nAdditional constraint on the input: the total length of all strings s doesn't exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the minimum total cost to make string t good.\nIn the first test case, you have to delete a character from s to get the empty string t. Only then t becomes good. One deletion costs 1 coin.\nIn the second test case, you can, for example, delete the second character from s to get the string 01, and then swap the first and second characters to get the string t = 10. String t is good, since t1\u2260s1 and t2\u2260s2. The total cost is 1 coin.\nIn the third test case, you can, for example, swap s1 with s2, swap s3 with s4, swap s5 with s7, s6 with s8 and s9 with s10. You'll get t = 1010001110. All swap operations are free, so the total cost is 0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "strings",
            "*1000"
        ],
        "solutions": "1913B - Swap and DeleteLet's count the number of 0-s and 1-s in s as cnt0 and cnt1 correspondingly. Since t consists of characters from s then t will contain no more than cnt0 zeros and cnt1 ones.Let's build t greedily, since we always compare t with prefix of s. Suppose the length of t is at least one, it means that t1 must be different from s1, so if s1 = 0 we must set t1 = 1. So let's check that we have at least one 1 (or cnt1>0), take 1 and place it at t1. Case s1 = 1 is the same.After placing t1 we can analogically try to place t2 and so on until we run out of necessary digits or build the whole string of length |s|.We've built the longest possible string t in O(|s|) time, so the answer is |s|\u2212|t|. Solution (adedalic)for _ in range(int(input())):\n    s = input()\n    cnt = [0, 0]\n    for i in range(len(s)):\n        cnt[int(s[i])] += 1\n    for i in range(len(s) + 1):\n        if (i == len(s) or cnt[1 - int(s[i])] == 0):\n            print(len(s) - i)\n            break\n        cnt[1 - int(s[i])] -= 1"
    },
    "1910A": {
        "title": "A. Username",
        "description": "On the official website of Berland, each account has two parameters: username and ID.\nUsername is a string consisting of lowercase Latin letters and/or digits, which contains at least one letter. For example, user0, 1fox1, zzzz are correct usernames, but 1337 and User22 are not. \nThe ID of the account for a given username is generated as follows: a positive integer without leading zeroes is appended to the end of the username. For example, the ID user0125 can be generated by the following usernames: user012, user01, user0; but neither by user nor us.\nYou are given a string s\u00a0\u2014 a valid ID. Your task is to determine any valid username that can generate the given ID. If there are several correct usernames, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a string s (2\u2264|s|\u226450), consisting of lowercase Latin letters and/or digits.\nAdditional constraint on input: there is at least one valid username that can generate the given ID.\nFor each test case on a separate line, print a string\u00a0\u2014 any valid username that can generate the given ID. If there are multiple correct usernames, you can print any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "implementation",
            "*1100"
        ],
        "solutions": "1910A - UsernameThere are many ways to find a valid username. Let's consider one of them.Let's look at the last character of the string. If it is a digit from 1 to 9, then we can take the given string except for the last character as the username. If the last character of the string is 0, then the above method doesn't work because the number appended to the username must be positive and not have leading zeros. Therefore, we have to consider the second character from the end, and we can apply similar reasoning. Thus, we have obtained the following solution: remove all the zeros from the end of the string plus one more character. The remaining string is the answer to the problem.One of the simplest ways to implement it is to use functions like dropLast and dropLastWhile. Solution (PavelKunyavskiy)fun main() {\n    repeat(readInt()) {\n        println(readln().dropLastWhile { it == '0' }.dropLast(1))\n    }\n}\n\nprivate fun readInt() = readln().toInt()"
    },
    "1909B": {
        "title": "B. Make Almost Equal With Mod",
        "description": "You are given an array a1,a2,\u2026,an of distinct positive integers. You have to do the following operation exactly once:\nFind a value of k such that 1\u2264k\u22641018 and the array a1,a2,\u2026,an contains exactly 2 distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such k always exists. If there are multiple solutions, you can print any of them.\n\u2020 a\u00a0mod\u00a0b denotes the remainder after dividing a by b. For example: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641017)\u00a0\u2014 the initial state of the array. It is guaranteed that all the ai are distinct.\nNote that there are no constraints on the sum of n over all test cases.\nFor each test case, output a single integer: a value of k (1\u2264k\u22641018) such that the array a1,a2,\u2026,an contains exactly 2 distinct values at the end of the operation.\nIn the first test case, you can choose k=7. The array becomes [8\u00a0mod\u00a07,15\u00a0mod\u00a07,22\u00a0mod\u00a07,30\u00a0mod\u00a07]=[1,1,1,2], which contains exactly 2 distinct values ({1,2}).\nIn the second test case, you can choose k=30. The array becomes [0,0,8,0,8], which contains exactly 2 distinct values ({0,8}). Note that choosing k=10 would also be a valid solution.\nIn the last test case, you can choose k=1018. The array becomes [2,1], which contains exactly 2 distinct values ({1,2}). Note that choosing k=1018+1 would not be valid, because 1\u2264k\u22641018 must be true.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1909B - Make Almost Equal With ModAuthor: TheScrasse Preparation: TheScrasse Hint 1Find a value of k that works in many cases. Hint 2k=2 works in many cases. What if it does not work? Hint 3If k=2 does not work, either all the numbers are even or all the numbers are odd. Which k can you try now? SolutionLet f(k) be the number of distinct values after the operation, using k.Let's try k=2. It works in all cases, except when either all the numbers are even or all the numbers are odd.Let's generalize. If ai\u00a0mod\u00a0k=x, one of the following holds:  ai\u00a0mod\u00a02k=x; ai\u00a0mod\u00a02k=x+k; It means that, if f(k)=1 (i.e., all the values after the operations are x), either f(2k)=1 (if either all the values become x, or they all become x+k), or f(2k)=2.Therefore, it is sufficient to try k=21,\u2026,257. In fact, f(1)=1 and f(257)=n, so there must exist m<57 such that f(2m)=1 and f(2m+1)\u22601\u27f9f(2m+1)=2.Alternative (more intuitive?) interpretation:  ai\u00a0mod\u00a02j corresponds to the last j digits in the binary representation of ai. There must exist j such that the last j digits make exactly 2 distinct blocks. In the following picture, a=[1005,2005,7005,11005,16005] and k=16: PictureComplexity: O(nlog(maxai))"
    },
    "1907C": {
        "title": "C. Removal of Unattractive Pairs",
        "description": "Vlad found a string ss consisting of nn lowercase Latin letters, and he wants to make it as short as possible.\nTo do this, he can remove any pair of adjacent characters from ss any number of times, provided they are different. For example, if ss=racoon, then by removing one pair of characters he can obtain the strings coon, roon, raon, and raco, but he cannot obtain racn (because the removed letters were the same) or rcon (because the removed letters were not adjacent).\nWhat is the minimum length Vlad can achieve by applying any number of deletions?\nThe first line of the input contains a single integer tt (1\u2264t\u22641041\u2264t\u2264104)\u00a0\u2014 the number of test cases. Descriptions of the test cases follow.\nThe first line of each test case contains a single integer nn (1\u2264n\u22642\u22c51051\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string ss.\nThe second line of each test case contains the string ss consisting of nn lowercase Latin letters.\nIt is guaranteed that the sum of nn over all test cases does not exceed 2\u22c51052\u22c5105.\nFor each test case, output a single number\u2014the minimum length of the string ss, after removing pairs of adjacent characters with different values.\nIn the first test case of the example, you need to act as follows: \"aabc\" \u2192\u2192 \"ac\" \u2192\u2192 \"\". Note that with a different order of deletions, the string will not become empty.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solutions": "1907C - Removal of Unattractive PairsConsider a finite string; obviously, all characters in it are the same, as otherwise, we could remove some pair of characters.If some character occurs in the string more than \u230an2\u230b times, then the final string will always consist only of it, because with one deletion we can only get rid of one occurrence. To minimize the number of these characters, we need to remove one occurrence each time. We can always do this until the string is left with only such a character.Otherwise, we can remove all possible pairs regardless of the order of deletions. Solutionorda = ord('a')\n\ndef solve():\n    n = int(input())\n    cnt = [0] * 26\n    for c in input():\n        cnt[ord(c) - orda] += 1\n    mx = max(cnt)\n    print(max(n % 2, 2 * mx - n))\n\n\nfor _ in range(int(input())):\n    solve()"
    },
    "1907B": {
        "title": "B. YetnotherrokenKeoard",
        "description": "Polycarp has a problem \u2014 his laptop keyboard is broken.\nNow, when he presses the 'b' key, it acts like an unusual backspace: it deletes the last (rightmost) lowercase letter in the typed string. If there are no lowercase letters in the typed string, then the press is completely ignored.\nSimilarly, when he presses the 'B' key, it deletes the last (rightmost) uppercase letter in the typed string. If there are no uppercase letters in the typed string, then the press is completely ignored.\nIn both cases, the letters 'b' and 'B' are not added to the typed string when these keys are pressed.\nConsider an example where the sequence of key presses was \"ARaBbbitBaby\". In this case, the typed string will change as follows: \"\" A\u2192 \"A\" R\u2192 \"AR\" a\u2192 \"ARa\" B\u2192 \"Aa\" b\u2192 \"A\" b\u2192 \"A\" i\u2192 \"Ai\" t\u2192 \"Ait\" B\u2192 \"it\" a\u2192 \"ita\" b\u2192 \"it\" y\u2192 \"ity\".\nGiven a sequence of pressed keys, output the typed string after processing all key presses.\nThe first line of the input data contains an integer t (1\u2264t\u22641000), the number of test cases in the test.\nThe following contains t non-empty lines, which consist of lowercase and uppercase letters of the Latin alphabet.\nIt is guaranteed that each line contains at least one letter and the sum of the lengths of the lines does not exceed 106.\nFor each test case, output the result of processing the key presses on a separate line. If the typed string is empty, then output an empty line.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1907B - YetnotherrokenKeoardIdea: pashka, MikeMirzayanov TutorialTutorial is loading... Solutionfor _ in range(int(input())):\n    s = list(input())\n    n = len(s)\n    upper = []\n    lower = []\n    for i in range(n):\n        if s[i] == 'b':\n            s[i] = ''\n            if lower:\n                s[lower.pop()] = ''\n            continue\n        if s[i] == 'B':\n            s[i] = ''\n            if upper:\n                s[upper.pop()] = ''\n            continue\n        if 'a' <= s[i] <= 'z':\n            lower += [i]\n        else:\n            upper += [i]\n    print(''.join(s))"
    },
    "1906A": {
        "title": "A. Easy As ABC",
        "description": "You are playing a word puzzle. The puzzle starts with a 3 by 3 grid, where each cell contains either the letter A, B, or C.\nThe goal of this puzzle is to find the lexicographically smallest possible word of length 3. The word can be formed by choosing three different cells where the cell containing the first letter is adjacent to the cell containing the second letter, and the cell containing the second letter is adjacent to the cell containing the third letter.\nTwo cells are adjacent to each other if they share a border or a corner, as shown in the following illustration. Formally, if (r,c) denotes the cell in the r-th row and c-th column, then cell (r,c) is adjacent to cell (r,c+1), (r\u22121,c+1), (r\u22121,c), (r\u22121,c\u22121), (r,c\u22121), (r+1,c\u22121), (r+1,c), and (r+1,c+1).\nDetermine the lexicographically smallest possible word of length 3 that you can find within the grid.\nA string s of length n is lexicographically smaller than string t of the same length if there exists an integer 1\u2264i\u2264n such that sj=tj for all 1\u2264j<i, and si<ti in alphabetical order. The following illustration shows some examples on some grids and their the lexicographically smallest possible word of length 3 that you can find within the grids.\nInput consists of three lines, each containing three letters, representing the puzzle grid. Each letter in the grid can only be either A, B, or C.\nOutput the lexicographically smallest possible word of length 3 that you can find within the grid.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test1024 megabytes",
        "tags": [
            "brute force",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1905B": {
        "title": "B. Begginer's Zelda",
        "description": "You are given a tree\u2020. In one zelda-operation you can do follows:\nDetermine the minimum number of zelda-operations required for the tree to have only one vertex.\n\u2020A tree is a connected acyclic undirected graph.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the number of vertices.\ni-th of the next n\u22121 lines contains two integers ui and vi (1\u2264ui,vi\u2264n,ui\u2260vi) \u2014 the numbers of vertices connected by the i-th edge.\nIt is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u2014 the minimum number of zelda-operations required for the tree to have only one vertex.\nIn the first test case, it's enough to perform one zelda-operation for vertices 2 and 4.\nIn the second test case, we can perform the following zelda-operations:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "trees",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1904B": {
        "title": "B. Collecting Game",
        "description": "You are given an array a of n positive integers and a score. If your score is greater than or equal to ai, then you can increase your score by ai and remove ai from the array. \nFor each index i, output the maximum number of additional array elements that you can remove if you remove ai and then set your score to ai. Note that the removal of ai should not be counted in the answer.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output n integers, the i-th of which denotes the maximum number of additional array elements that you can remove if you remove ai from the array and then set your score to ai.\nIn the first test case, the answers are as follows:\nIf we start with i=4, our initial score is a4=4 and a=[20,5,1,2]. We can remove 3 additional elements in the following order: \nIf we start with i=1 we can remove all remaining elements in the array, so the answer is 4.\nIf we start with i=2, we can remove 3 additional elements in the following order: 1, 4, 2.\nIf we start with i=3, we can remove no additional elements.\nIf we start with i=5, we can remove 1 additional element: 1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1904B - Collecting GameIdea: oursaco  Preparation: oursaco  Analysis: lunchbox SolutionLet's sort array a. The answer for the largest element is n\u22121 because the score, which is an, cannot be smaller than any of the other elements. Now, consider the second largest element. The answer is at least n\u22122 because every element that is not greater than an\u22121 can be taken. Then, we check if the score is at least an. This inspires the following solution: first, we find the prefix sum p of array a. We calculate the answer in decreasing order of ai. To calculate the answer for an ai, we find the largest j such that pi\u2265aj and set the answer for i equal to the answer of j. Code#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define pb push_back\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst int MOD = 1e9 + 7;\n\ntemplate<class K> using sset =  tree<K, null_type, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\n\ninline ll ceil0(ll a, ll b) {\n    return a / b + ((a ^ b) > 0 && a % b);\n}\n\nvoid setIO() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n}\n\nint main(){\n    setIO();\n    int T;\n    cin >> T;\n    for(int tt = 1; tt <= T; tt++){\n        int n;\n        cin >> n;\n        pii arr[n + 1];\n        for(int i = 1; i <= n; i++) cin >> arr[i].ff, arr[i].ss = i;\n        sort(arr + 1, arr + n + 1);\n        int nxt[n + 1];\n        ll sum[n + 1];\n        int ans[n + 1];\n        nxt[0] = sum[0] = 0;\n        for(int i = 1; i <= n; i++){\n            if(nxt[i - 1] >= i){\n                nxt[i] = nxt[i - 1];\n                sum[i] = sum[i - 1];\n            } else {\n                sum[i] = sum[i - 1] + arr[i].ff;\n                nxt[i] = i;\n                while(nxt[i] + 1 <= n && sum[i] >= arr[nxt[i] + 1].ff){\n                    nxt[i]++;\n                    sum[i] += arr[nxt[i]].ff;\n                }\n            }\n            ans[arr[i].ss] = nxt[i];\n        }\n        for(int i = 1; i <= n; i++) cout << ans[i] - 1 << \" \";\n        cout << endl;\n    }\n}"
    },
    "1903B": {
        "title": "B. StORage room",
        "description": "In Cyprus, the weather is pretty hot. Thus, Theofanis saw this as an opportunity to create an ice cream company. \nHe keeps the ice cream safe from other ice cream producers by locking it inside big storage rooms. However, he forgot the password. Luckily, the lock has a special feature for forgetful people! \nIt gives you a table M with n rows and n columns of non-negative integers, and to open the lock, you need to find an array a of n elements such that:\nThe lock has a bug, and sometimes it gives tables without any solutions. In that case, the ice cream will remain frozen for the rest of eternity.\nCan you find an array to open the lock? \nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264103)\u00a0\u2014 the size of the hidden array.\nThe next n lines describe the rows of M, line i contains the table values Mi,1,Mi,2,\u2026,Mi,n (0\u2264Mi,j<230).\nIt is guaranteed that Mi,i=0 and Mi,j=Mj,i for all 1\u2264i,j\u2264n.\nIt is also guaranteed that the sum of n over all test cases does not exceed 103.\nFor each test case, if there is a solution print YES and an array that satisfies the property, otherwise print NO.\nIf there are multiple solutions, print any of them.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1903B - StORage roomSolution:Initially, we set all ai=230\u22121 (all bits on).You can through every i,j such that i\u2260j and do ai&=Mi,j and aj&=Mi,j.Then we check if Mi,j=ai|aj for all pairs. If this holds you found the array else the answer is NO.Proof:Initially, all elements have all their bits set on and we remove only the bits that affect our answer. If Mi,j doesn't have a specific bit then definitely neither ai nor aj should have it. If Mi,j has a specific bit on then we don't have to remove anything (in the end we want at least one of ai and aj to have the bit on). Code (C++)#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        int m[n][n];\n        int arr[n];\n        for(int i = 0;i < n;i++){\n            arr[i] = (1<<30) - 1;\n        }\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++){\n                cin>>m[i][j];\n                if(i != j){\n                    arr[i] &= m[i][j];\n                    arr[j] &= m[i][j];\n                }\n            }\n        }\n        bool ok = true;\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < n;j++){\n                if(i != j && (arr[i] | arr[j]) != m[i][j]){\n                    ok = false;\n                }\n            }\n        }\n        if(!ok){\n            cout<<\"NO\\n\";\n        }\n        else{\n            cout<<\"YES\\n\";\n            for(int i = 0;i < n;i++){\n                cout<<arr[i]<<\" \";\n            }\n            cout<<\"\\n\";\n        }\n    }\n} Rate this problemGood \n\n    \n\n\n596\n\n\n\nMid \n\n    \n\n\n52\n\n\n\nBad \n\n    \n\n\n186\n\n\n\n"
    },
    "1902B": {
        "title": "B. Getting Points",
        "description": "Monocarp is a student at Berland State University. Due to recent changes in the Berland education system, Monocarp has to study only one subject\u00a0\u2014 programming.\nThe academic term consists of n days, and in order not to get expelled, Monocarp has to earn at least P points during those n days. There are two ways to earn points\u00a0\u2014 completing practical tasks and attending lessons. For each practical task Monocarp fulfills, he earns t points, and for each lesson he attends, he earns l points.\nPractical tasks are unlocked \"each week\" as the term goes on: the first task is unlocked on day 1 (and can be completed on any day from 1 to n), the second task is unlocked on day 8 (and can be completed on any day from 8 to n), the third task is unlocked on day 15, and so on.\nEvery day from 1 to n, there is a lesson which can be attended by Monocarp. And every day, Monocarp chooses whether to study or to rest the whole day. When Monocarp decides to study, he attends a lesson and can complete no more than 2 tasks, which are already unlocked and not completed yet. If Monocarp rests the whole day, he skips a lesson and ignores tasks.\nMonocarp wants to have as many days off as possible, i.\u00a0e. he wants to maximize the number of days he rests. Help him calculate the maximum number of days he can rest!\nThe first line contains a single integer tc (1\u2264tc\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains four integers n, P, l and t (1\u2264n,l,t\u2264109; 1\u2264P\u22641018)\u00a0\u2014 the number of days, the minimum total points Monocarp has to earn, the points for attending one lesson and points for completing one task.\nIt's guaranteed for each test case that it's possible not to be expelled if Monocarp will attend all lessons and will complete all tasks.\nFor each test, print one integer\u00a0\u2014 the maximum number of days Monocarp can rest without being expelled from University.\nIn the first test case, the term lasts for 1 day, so Monocarp should attend at day 1. Since attending one lesson already gives 5 points (5\u2265P), so it doesn't matter, will Monocarp complete the task or not.\nIn the second test case, Monocarp can, for example, study at days 8 and 9: at day 8 he will attend a lesson for 109 points and complete two tasks for another 5\u22c5108+5\u22c5108 points. And at day 9 he only attends a lesson for another 109 points.\nIn the third test case, Monocarp can, for example, study at day 42: attending a lesson gives him 1 point and solving 2 out of 6 available tasks gives him another 2\u22c510 points.\nIn the fourth test case, Monocarp has to attend all lessons and complete all tasks to get 8\u22c510+2\u22c520=120 points.\nIn the fifth test case, Monocarp can, for example, study at days: 8\u00a0\u2014 one lesson and first and second tasks; 15\u00a0\u2014 one lesson and the third task; 22\u00a0\u2014 one lesson and the fourth task; 29\u00a0\u2014 one lesson and the fifth task; 36\u00a0\u2014 one lesson and the sixth task.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*1100"
        ],
        "solutions": "1902B - Getting PointsFirstly, let c be the total number of tasks in the term. Then c=\u2308n7\u2309=\u230an+67\u230b.Suppose, Monocarp will study exactly k days. How many points will he get? He gets k\u22c5l for attending lessons and, since he can complete at most 2 tasks per day, he will solve no more than min(c,2\u22c5k) tasks. So, in the best possible scenario he will get k\u22c5l+min(c,2k)\u22c5t points.And, actually, it's possible to get exactly that many points. For example, Monocarp can study the last k days of the term: at the n-th day he will complete (c\u22121)-th and c-th tasks, at the (n\u22121)-th day\u00a0\u2014 tasks (c\u22123) and (c\u22122) and so on. It's easy to see that all that tasks will be available at the day Monocarp completes them.In total, we need to find the minimum k such that k\u22c5l+min(c,2k)\u22c5t\u2265P. We can analyze two cases, or perform a Binary Search on k. Solution (adedalic)fun main(args: Array<String>) {\n    repeat(readln().toInt()) {\n        val (n, p, l, t) = readln().split(' ').map { it.toLong() }\n        val cntTasks = (n + 6) / 7\n        \n        fun calc(k: Long) = k * l + minOf(2 * k, cntTasks) * t\n        var lf = 0L\n        var rg = n\n        while (rg - lf > 1) {\n            val mid = (lf + rg) / 2\n            if (calc(mid) >= p)\n                rg = mid\n            else\n                lf = mid\n        }\n        println(n - rg)\n    }\n}"
    },
    "1901B": {
        "title": "B. Chip and Ribbon",
        "description": "There is a ribbon divided into n cells, numbered from 1 to n from left to right. Initially, an integer 0 is written in each cell.\nMonocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the 1-st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions:\nAt the end of each turn, the integer written in the cell with the chip is increased by 1.\nMonocarp's goal is to make some turns so that the 1-st cell contains the integer c1, the 2-nd cell contains the integer c2, ..., the n-th cell contains the integer cn. He wants to teleport the chip as few times as possible.\nHelp Monocarp calculate the minimum number of times he has to teleport the chip. \nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines: \nIt can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence c1,c2,\u2026,cn.\nAdditional constraint on the input: the sum of values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the minimum number of times Monocarp has to teleport the chip.\nIn the first test case of the example, Monocarp can perform the turns as follows:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1901B - Chip and RibbonAt first, let's change the statement a bit: instead of teleporting our chip into cell x, we create a new chip in cell x (it means that the chip does not disappear from the cell where it was located). And when we want to move a chip, we move any chip to the next cell. Then, ci will be the number of times a chip appeared in the cell i, and the problem will be the same: ensure the condition on each ci by \"creating\" the minimum number of chips.Let's look at value of c1. If c1>1, we have to create at least c1\u22121 new chips in cell 1. Let's create that number of chips in that cell.Then, let's see how we move chips from the cell i to the cell (i+1). If ci\u2265ci+1, then all chips that appeared in the cell (i+1) could be moved from the i-th cell, so we don't need to create any additional chips in that cell.But if ci<ci+1, then at least ci+1\u2212ci chips should be created in the cell (i+1), since we can move at most ci chips from the left.So, for every i from 2 to n, we have to create max(0,ci\u2212ci\u22121) chips in the i-th cell; and the number of times we create a new chip in total is c1\u22121+\u2211i=2nmax(0,ci\u2212ci\u22121). Solution (Roms)#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int N = 200'000;\n \nint t;\n \nint main() {\n    cin >> t;\n    for (int tc = 0; tc < t; ++tc) {\n        int n;\n        cin >> n;\n        vector <int> cnt(n);\n        long long res = 0;\n        int cur = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> cnt[i];\n            if (cnt[i] > cur) \n                res += cnt[i] - cur;\n            cur = cnt[i];\n        }\n        \n        cout << res - 1 << endl;\n    }\n    return 0;\n}"
    },
    "1899C": {
        "title": "C. Yarik and Array",
        "description": "A subarray is a continuous part of array.\nYarik recently found an array aa of nn elements and became very interested in finding the maximum sum of a non empty subarray. However, Yarik doesn't like consecutive integers with the same parity, so the subarray he chooses must have alternating parities for adjacent elements.\nFor example, [1,2,3][1,2,3] is acceptable, but [1,2,4][1,2,4] is not, as 22 and 44 are both even and adjacent.\nYou need to help Yarik by finding the maximum sum of such a subarray.\nThe first line contains an integer tt (1\u2264t\u2264104)(1\u2264t\u2264104)\u00a0\u2014 number of test cases. Each test case is described as follows.\nThe first line of each test case contains an integer nn (1\u2264n\u22642\u22c5105)(1\u2264n\u22642\u22c5105)\u00a0\u2014 length of the array.\nThe second line of each test case contains nn integers a1,a2,\u2026,ana1,a2,\u2026,an (\u2212103\u2264ai\u2264103)(\u2212103\u2264ai\u2264103)\u00a0\u2014 elements of the array.\nIt is guaranteed that the sum of nn for all test cases does not exceed 2\u22c51052\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the answer to the problem.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solutions": "1899C \u2014 Yarik and ArrayIdea: meowcneil, development: meowcneil. EditorialThere are \"bad\" positions in the array, i.e., those on which two numbers of the same parity are next to each other. Note that all matching segments cannot contain such positions, in other words, we need to solve the problem of finding a sub segment with maximal sum on some number of non-intersecting sub segments of the array, the boundaries of which are between two neighboring elements of the same parity.The problem of finding a sub segment with maximal sum can be solved using the classical algorithm with keeping minimal prefix sum on the prefix. The problem can be solved in a single pass over the array by simply dropping the keeped values when we are in a bad position.Total complexity \u2014 O(n). Solution#include <iostream>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int ans = a[0];\n    int mn = min(0, a[0]), sum = a[0];\n    for (int i = 1; i < n; ++i) {\n        if (abs(a[i] % 2) == abs(a[i - 1] % 2)) {\n            mn = 0;\n            sum = 0;\n        }\n        sum += a[i];\n        ans = max(ans, sum - mn);\n        mn = min(mn, sum);\n    }\n    cout << ans << endl;\n}\n \nint main() {\n    int tc = 1;\n    cin >> tc;\n    for (int t = 1; t <= tc; t++) {\n        solve();\n    }\n}"
    },
    "1899B": {
        "title": "B. 250 Thousand Tons of TNT",
        "description": "Alex is participating in the filming of another video of BrMeast, and BrMeast asked Alex to prepare 250 thousand tons of TNT, but Alex didn't hear him well, so he prepared n boxes and arranged them in a row waiting for trucks. The i-th box from the left weighs ai tons.\nAll trucks that Alex is going to use hold the same number of boxes, denoted by k. Loading happens the following way:\nUpon loading is completed, each truck must have exactly k boxes. In other words, if at some point it is not possible to load exactly k boxes into the truck, then the loading option with that k is not possible.\nAlex hates justice, so he wants the maximum absolute difference between the total weights of two trucks to be as great as possible. If there is only one truck, this value is 0.\nAlex has quite a lot of connections, so for every 1\u2264k\u2264n, he can find a company such that each of its trucks can hold exactly k boxes. Print the maximum absolute difference between the total weights of any two trucks.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (1\u2264n\u2264150000)\u00a0\u2014 the number of boxes.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the weights of the boxes.\nIt is guaranteed that the sum of n for all test cases does not exceed 150000.\nFor each test case, print a single integer\u00a0\u2014 the answer to the problem.\nIn the first case, we should pick two trucks, so the first one will have only the first box, and the second one will have only the second box.\nIn the second case, we should pick six trucks, so the maximum will be 10, the minimum will be 1, and the answer is 10\u22121=9.\nIn the third case, for any possible k, the trucks will have the same total weight of boxes, so the answer is 0.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solutions": "1899B \u2014 250 Thousand Tons of TNTIdea: zwezdinv, development: zwezdinv. EditorialSolution #1:Since k is a divisor of n, there are O(3\u221an) such k. We can enumerate all k, calculate a given value in O(n), and take the maximum of them. Total complexity \u2014 O(n\u22c53\u221an).Solution #2:Without using the fact that k is a divisor of n, we can simply loop over k and then calculate the values using prefix sums, and at the end check that there are exactly k elements in each segment. Such a solution works in O(n1+n2+n3+\u22ef+nn)=O(nlogn). Solution#include<bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\n#define all(x) x.begin(), x.end()\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) cin >> a[i];\n    ll ans = -1;\n    for (int d = 1; d <= n; ++d) {\n        if (n % d == 0) {\n            ll mx = -1e18, mn = 1e18;\n            for (int i = 0; i < n; i += d) {\n                ll sm = 0;\n                for (int j = i; j < i + d; ++j) {\n                    sm += a[j];\n                }\n                mx = max(mx, sm);\n                mn = min(mn, sm);\n            }\n            ans = max(ans, mx - mn);\n        }\n    }\n    cout << ans << '\\n';\n}\n \nint32_t main() {\n    int t;\n    cin >> t;\n    while (t--) solve();\n}"
    },
    "1894B": {
        "title": "B. Two Out of Three",
        "description": "You are given an array a1,a2,\u2026,an. You need to find an array b1,b2,\u2026,bn consisting of numbers 1, 2, 3 such that exactly two out of the following three conditions are satisfied:\nIf such an array does not exist, you should report it.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases. Each test case is described as follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264100)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264100)\u00a0\u2014 the elements of the array a.\nFor each test case, print -1 if there is no solution. Otherwise, print b1,b2,\u2026,bn\u00a0\u2014 an array consisting of numbers 1, 2, 3 that satisfies exactly two out of three conditions. If there are multiple possible answers, you can print any of them.\nIn the first test case, b=[1,2,3,1,1,1] satisfies condition 1 because for i=4, j=2: ai=aj, bi=1, and bj=2. It also satisfies condition 2 because for i=6, j=3: ai=aj, bi=1, and bj=3. However, it does not satisfy condition 3. In total, exactly two out of three conditions are satisfied.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1894B - Two Out of ThreeBy symmetry, it doesn't matter which two conditions are satisfied. Let's assume it's the conditions (1,2) and (1,3). Then the elements with bi=2 and the elements with bi=3 should not intersect. Therefore, it is sufficient to assign bi=2 and bi=3 to only one element that is common with the elements of the form bi=1 in order to satisfy the conditions (1,2) and (1,3). And these elements must be distinct in order to not satisfy the condition (2,3). Thus, we obtain the necessary condition for the existence of an answer: the array must have at least two elements that occur more than once. It is easy to see that this condition is also sufficient by constructing an example: let x,y be two numbers that occur more than once in the array. Then we can assign ai=x\u2192bi=2 to one of the occurrences, ai=y\u2192bi=3 to one of the occurrence, and assign bi=1 to all other numbers, and this will be a suitable answer. Solution231849397 #include <bits/stdc++.h>\n \nusing namespace std;\nconst int N = 100;\n \nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b(n, 1);\n  vector<vector<int>> inds(N + 1);\n  for (int i = 0; i < n; i++) {\n    inds[a[i]].push_back(i);\n  }\n  int k = 2;\n  for (int x = 1; x <= N; x++) {\n    if ((int) inds[x].size() >= 2) {\n      b[inds[x][0]] = k;\n      k++;\n      if (k > 3) {\n        break;\n      }\n    }\n  }\n  if (k <= 3) {\n    cout << \"-1\\n\";\n  } else {\n    for (int i = 0; i < n; i++) {\n      cout << b[i] << ' ';\n    }\n    cout << '\\n';\n  }\n}\n \nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout.tie(nullptr);\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n} Rate the problem Didnt solve \n\n    \n\n\n63\n\n\n\n Good problem \n\n    \n\n\n352\n\n\n\n Average problem \n\n    \n\n\n141\n\n\n\n Bad problem \n\n    \n\n\n117\n\n\n\n "
    },
    "1891B": {
        "title": "B. Deja Vu",
        "description": "You are given an array a of length n, consisting of positive integers, and an array x of length q, also consisting of positive integers.\nThere are q modification. On the i-th modification (1\u2264i\u2264q), for each j (1\u2264j\u2264n), such that aj is divisible by 2xi, you add 2xi\u22121 to aj. Note that xi (1\u2264xi\u226430) is a positive integer not exceeding 30.\nAfter all modification queries, you need to output the final array.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and q (1\u2264n,q\u2264105) \u2014the length of the array a and the number of queries respectively.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an \u2014 the elements of the array a (1\u2264ai\u2264109).\nThe third line of each test case contains q integers x1,x2,x3,\u2026,xq \u2014 the elements of the array x (1\u2264xi\u226430), which are the modification queries.\nIt is guaranteed that the sum of n and the sum of q across all test cases does not exceed 2\u22c5105.\nFor each test case, output the array after all of the modification queries.\nIn the first test case, the first query will add 2 to the integers in positions 4 and 5. After this addition, the array would be [1,2,3,6,6]. Other operations will not modify the array.\nIn the second test case, the first modification query does not change the array. The second modification query will add 8 to the integer in position 5, so that the array would look like this: [7,8,12,36,56,6,3]. The third modification query will add 2 to the integers in positions 2,3, 4 and 5. The array would then look like this: [7,10,14,38,58,6,3].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1891B - Deja VuLet a number be divisible by 2x. Then after applying the operation it is no longer divisible by 2x. From this we can conclude that if we apply the operation xi, and there is such an operation j<i that xj<xi, then the operation xi does not change the array. So, it is useless and can be simply not processed. Then we will maintain the minimum of the processed x. If the new operation is smaller than the minimum processed one, we will process the operation and update it. Otherwise we just won't do anything. Since the minimum processed will decrease at most 30 times, the time complexity is O(30\u22c5n).  "
    },
    "1886B": {
        "title": "B. Fear of the Dark",
        "description": "Monocarp tries to get home from work. He is currently at the point O=(0,0) of a two-dimensional plane; his house is at the point P=(Px,Py).\nUnfortunately, it is late in the evening, so it is very dark. Monocarp is afraid of the darkness. He would like to go home along a path illuminated by something.\nThankfully, there are two lanterns, located in the points A=(Ax,Ay) and B=(Bx,By). You can choose any non-negative number w and set the power of both lanterns to w. If a lantern's power is set to w, it illuminates a circle of radius w centered at the lantern location (including the borders of the circle).\nYou have to choose the minimum non-negative value w for the power of the lanterns in such a way that there is a path from the point O to the point P which is completely illuminated. You may assume that the lanterns don't interfere with Monocarp's movement.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input:\nFor each test case, print the answer on a separate line \u2014 one real number equal to the minimum value of w such that there is a completely illuminated path from the point O to the point P.\nYour answer will be considered correct if its absolute or relative error does not exceed 10\u22126 \u2014 formally, if your answer is a, and the jury's answer is b, your answer will be accepted if |a\u2212b|max(1,b)\u226410\u22126.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "math",
            "*1200"
        ],
        "solutions": "1886B - Fear of the DarkThere are only two major cases: both points O and P lie inside the same circle, or the point O lies inside one of the circles and P lies inside the other circle.Let's denote the distance between the points P and Q as d(P,Q).Let's look at the first case, when the points O and P lie inside the circle centered at A. In that case, inequalities d(O,A)\u2264R and d(P,A)\u2264R must be satisfied. Therefore, the minimum possible radius for that case is equal to max(d(O,A),d(P,A)). Similarly, for the circle centered at B, the minimum possible radius for that case is equal to max(d(O,B),d(P,B)).Let's look at the second case, when the point O lies inside the circle centered at A and the point P lies inside the circle centered at B. In that case, inequalities d(O,A)\u2264R and d(P,B)\u2264R must be satisfied. But there is one extra constraint: the circles must intersect, because there is should an illuminated path from one circle to another. This adds one more inequality\u00a0\u2014 d(A,B)\u22642R. Therefore, the minimum possible radius for that case is equal to max(d(O,A),d(P,B),d(A,B)2). Similarly, when O lies inside the circle centered at B and P lies inside the circle centered at A, the minimum possible radius for that case is equal to max(d(O,B),d(P,A),d(A,B)2).So the answer to the problem is the minimum among aforementioned cases. Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n  auto dist = [](int x1, int y1, int x2, int y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n  };\n \n  int t;\n  cin >> t;\n  while (t--) {\n    int px, py, ax, ay, bx, by;\n    cin >> px >> py >> ax >> ay >> bx >> by;\n    double pa = dist(px, py, ax, ay), pb = dist(px, py, bx, by);\n    double oa = dist(0, 0, ax, ay), ob = dist(0, 0, bx, by);\n    double ab = dist(ax, ay, bx, by);\n    double ans = 1e9;\n    ans = min(ans, max(pa, oa));\n    ans = min(ans, max(pb, ob));\n    ans = min(ans, max({ab / 2, pa, ob}));\n    ans = min(ans, max({ab / 2, pb, oa}));\n    cout << setprecision(10) << fixed << ans << '\\n';\n  }\n}"
    },
    "1884B": {
        "title": "B. Haunted House",
        "description": "You are given a number in binary representation consisting of exactly n bits, possibly, with leading zeroes. For example, for n=5 the number 6 will be given as 00110, and for n=4 the number 9 will be given as 1001.\nLet's fix some integer i such that 1\u2264i\u2264n. In one operation you can swap any two adjacent bits in the binary representation. Your goal is to find the smallest number of operations you are required to perform to make the number divisible by 2i, or say that it is impossible.\nPlease note that for each 1\u2264i\u2264n you are solving the problem independently.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the binary representation of the number.\nThe second line of each test case contains a string of length n, consisting of 0 and 1,\u00a0\u2014 the binary representation of the number.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, for each 1\u2264i\u2264n output the smallest number of operations required to make the number divisible by 2i, or output \u22121 if it is impossible.\nIn the first test case, we cannot swap any elements, and the number 1 is not divisible by 2.\nIn the second test case, the initial number is 1. It is not divisible by 2, but if we perform the operation, then we obtain the number with binary representation 10, which is equal to 2 in decimal representation, thus, it is divisible by 2. But this number is not divisible by 4 and we cannot obtain any other number using the operations.\nIn the third test case, the initial number is 2. For i=1 we do not have to perform any operations since the initial number is divisible by 2. For i=2 we can perform one operation swapping the first two bits (we would obtain 100 in binary representation, which corresponds to number 4). There is no answer for i=3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solutions": "1884B - Haunted HouseIn order for a number to be divisible by 2i, the last i bits of its binary representation must be equal to 0. For convenience, let's reverse the binary representation of the number so that our operations aim to zero out the first i bits. Let zero be the number of bits equal to 0 in the original string.If i>zero, it is obvious that the answer is \u22121 since our operations do not change the number of zeros and ones in the number. Otherwise, the answer exists, and we will learn how to calculate the minimum number of operations. Consider all j\u2264i, where sj=1. We need to remove these ones from our prefix by replacing them with the nearest zeros after position i. We will traverse the string from left to right, keeping track of the number of ones in our prefix (denoted as cnt) and the sum of their positions (denoted as sum_one). We also need to maintain the sum of the nearest cnt positions of zeros after our element i (denoted as sum_zero). This can be done using a pointer. The answer is sum_zero\u2212sum_one. This is both a lower bound estimate and can be greedily shown how to obtain this answer in such a number of operations.First, let's place all the ones at the end of our prefix. We will place the rightmost one at position i and so on. This can be done in \u2211j=i\u2212cnt+1i(j\u2212pos) operations, where pos is the position of the corresponding one, which in general is actually =\u2212sum_one+\u2211j=i\u2212cnt+1ij. Now we want to place zeros at these positions, and we will do this greedily cnt times, performing \u2211j=i\u2212cnt+1i(pos\u2212j) operations, where pos is the position of 0. Again, the total is =sum_zero\u2212\u2211j=i\u2212cnt+1ij. Our answer is the sum of these two, which is sum_zero\u2212sum_one. "
    },
    "1883C": {
        "title": "C. Raspberries",
        "description": "You are given an array of integers a1,a2,\u2026,an and a number k (2\u2264k\u22645). In one operation, you can do the following:\nFind the minimum number of operations needed to make the product of all the numbers in the array a1\u22c5a2\u22c5\u2026\u22c5an divisible by k.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers n and k (2\u2264n\u2264105, 2\u2264k\u22645) \u2014 the size of the array a and the number k.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u226410).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the minimum number of operations needed to make the product of all the numbers in the array divisible by k.\nIn the first test case, we need to choose the index i=2 twice. After that, the array will be a=[7,5]. The product of all the numbers in the array is 35.\nIn the fourth test case, the product of the numbers in the array is 120, which is already divisible by 5, so no operations are needed.\nIn the eighth test case, we can perform two operations by choosing i=2 and i=3 in any order. After that, the array will be a=[1,6,10]. The product of the numbers in the array is 60.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "math",
            "*1000"
        ],
        "solutions": "1883C - RaspberriesLet's notice that if k=2,3,5, since these are prime numbers, the product of the numbers will be divisible by k if any number in the array is divisible by k. From this, we can conclude that it is advantageous to perform operations only on one number.If k=4, we have several cases, and we need to take the minimum among them. Again, we can perform operations on one number and make it divisible by 4, or we need to perform operations such that there are two even numbers in the array (there is a special case when n=1). To have two even numbers, let's count the number of even numbers in the original array as cnt, and if 2\u2264n, we can say that the answer is max(0,2\u2212cnt). "
    },
    "1881C": {
        "title": "C. Perfect Square",
        "description": "Kristina has a matrix of size n by n, filled with lowercase Latin letters. The value of n is even.\nShe wants to change some characters so that her matrix becomes a perfect square. A matrix is called a perfect square if it remains unchanged when rotated 90\u2218 clockwise once.\nHere is an example of rotating a matrix by 90\u2218:\nIn one operation, Kristina can choose any cell and replace its value with the next character in the alphabet. If the character is equal to \"z\", its value does not change.\nFind the minimum number of operations required to make the matrix a perfect square.\nFor example, if the 4 by 4 matrix looks like this:\nabbabcbbbccbabba\nthen it is enough to apply 1 operation to the letter b, highlighted in bold.\nThe first line of the input contains a single integer t (1\u2264t\u2264102)\u00a0\u2014 the number of test cases.\nThen follows the description of each test case.\nThe first line of each test case contains a single even integer n (2\u2264n\u2264103)\u00a0\u2014 the number of rows and columns in the matrix.\nThen follows n lines, each containing exactly n lowercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 103.\nFor each test case, output a single number on a separate line: the minimum number of operations required for Kristina to obtain a perfect square.\nThe first test case is explained in the problem statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "1881C - Perfect SquareWhen rotating a matrix of size n by n by 90 degrees:   element a[i][j] takes the position of element a[j][n\u22121\u2212i]; element a[n\u22121\u2212j][i] takes the position of element a[i][j]; element a[n\u22121\u2212i][n\u22121\u2212j] takes the position of element a[n\u22121\u2212j][i]. In order for the matrix to be a perfect square, the symbols at all of these positions must be equal. Since we can only maximize a symbol, we do the following:  Among these 4 symbols, let's find the lexicographically maximal one, that is, the one that is in the alphabet not before all the others;  For all characters that are not equal to the maximum, calculate the number of operations that must be applied to them to make them equal to the maximum character. This number of operations is equal to the difference of positions of symbols in the alphabet.  Solution#include <bits/stdc++.h>\n#define all(arr) arr.begin(), arr.end()\n\nusing namespace std;\n\nconst int MAXN = 1010;\n\nint n;\nstring A[MAXN];\n\nint solve() {\n    int ans = 0;\n    for (int i = 0; i * 2 < n; ++i)\n        for (int j = 0; j * 2 < n; ++j) {\n            vector<char> M {A[i][j], A[n - 1 - j][i], A[n - 1 - i][n - 1 - j], A[j][n - 1 - i]};\n            char c = *max_element(all(M));\n            for(char e: M)\n                ans += c - e;\n        }\n    return ans;\n}\n\nint main() {\n    int t; cin >> t;\n    while (t--) {\n        cin >> n;\n        for (int i = 0; i < n; ++i)\n            cin >> A[i];\n        cout << solve() << endl;\n    }\n}"
    },
    "1877C": {
        "title": "C. Joyboard",
        "description": "Chaneka, a gamer kid, invented a new gaming controller called joyboard. Interestingly, the joyboard she invented can only be used to play one game.\nThe joyboard has a screen containing n+1 slots numbered from 1 to n+1 from left to right. The n+1 slots are going to be filled with an array of non-negative integers [a1,a2,a3,\u2026,an+1]. Chaneka, as the player, must assign an+1 with an integer between 0 and m inclusive. Then, for each i from n to 1, the value of ai will be equal to the remainder of dividing ai+1 (the adjacent value to the right) by i. In other words, ai=ai+1modi.\nChaneka wants it such that after every slot is assigned with an integer, there are exactly k distinct values in the entire screen (among all n+1 slots). How many valid ways are there for assigning a non-negative integer into slot n+1?\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe only line of each test case contains three integers n, m, and k (1\u2264n\u2264109; 0\u2264m\u2264109; 1\u2264k\u2264n+1) \u2014 there are n+1 slots, the integer assigned in slot n+1 must not be bigger than m, and there should be exactly k distinct values.\nFor each test case, output a line containing an integer representing the number of valid ways for assigning a non-negative integer into slot n+1.\nIn the first test case, one of the 2 possible ways for Chaneka is to choose an+1=6. If she does that, then: \nIn the second test case, the 1 possible way for Chaneka is to choose an+1=0. If she does that, then a=[0,0,0]. There is only 1 distinct value.\nIn the third test case, there is no possible way for assigning a non-negative integer into slot n+1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1877C - JoyboardThere are only a few cases.   If an+1=0, then every value of ai is 0. So there is only 1 distinct value.  If 1\u2264an+1\u2264n, then there exists an index p (p=an+1) such that ai=an+1 for all indices p+1\u2264i\u2264n+1 and ai=0 for all 1\u2264i\u2264p. So there are 2 distinct values.  If an+1>n and an+1 is divisible by n, then an=0 and all values to the left of that are also 0. So there are 2 distinct values.  If an+1>n and an+1 is not divisible by n, then 1\u2264an\u2264n\u22121. This is is equivalent to case 2, which means that there are 2 distinct values from index 1 to n. So in total, there are 3 distinct values. So the number of ways is as follows:   If k=1, there is always 1 way, since m\u22650.  If k=2 and m\u2264n, there are m ways.  If k=2 and m>n, there are n+\u230am\u2212nn\u230b.  If k=3 and m\u2264n, there are 0 ways.  If k=3 and m>n, there are m\u2212n\u2212\u230am\u2212nn\u230b.  If k>3, there are 0 ways. Time complexity for each test case: O(1)2D/1B. Effects of Anti PimplesAuthor: PyqeDeveloper: Pyqe  Tutorial"
    },
    "1876A": {
        "title": "A. Helmets in Night Light",
        "description": "Pak Chanek is the chief of a village named Khuntien. On one night filled with lights, Pak Chanek has a sudden and important announcement that needs to be notified to all of the n residents in Khuntien.\nFirst, Pak Chanek shares the announcement directly to one or more residents with a cost of p for each person. After that, the residents can share the announcement to other residents using a magical helmet-shaped device. However, there is a cost for using the helmet-shaped device. For each i, if the i-th resident has got the announcement at least once (either directly from Pak Chanek or from another resident), he/she can share the announcement to at most ai other residents with a cost of bi for each share.\nIf Pak Chanek can also control how the residents share the announcement to other residents, what is the minimum cost for Pak Chanek to notify all n residents of Khuntien about the announcement?\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe first line contains two integers n and p (1\u2264n\u2264105; 1\u2264p\u2264105) \u2014 the number of residents and the cost for Pak Chanek to share the announcement directly to one resident.\nThe second line contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264105) \u2014 the maximum number of residents that each resident can share the announcement to.\nThe third line contains n integers b1,b2,b3,\u2026,bn (1\u2264bi\u2264105) \u2014 the cost for each resident to share the announcement to one other resident.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a line containing an integer representing the minimum cost to notify all n residents of Khuntien about the announcement.\nIn the first test case, the following is a possible optimal strategy: \nThe total cost is 9+4+3=16. It can be shown that there is no other strategy with a smaller cost.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1874A": {
        "title": "A. Jellyfish and Game",
        "description": "Jellyfish has n green apples with values a1,a2,\u2026,an and Gellyfish has m green apples with values b1,b2,\u2026,bm.\nThey will play a game with k rounds. For i=1,2,\u2026,k in this order, they will perform the following actions: \nBoth players want to maximize the sum of the values of their apples.\nSince you are one of the smartest people in the world, Jellyfish wants you to tell her the final sum of the value of her apples after all k rounds of the game. Assume that both Jellyfish and Gellyfish play optimally to maximize the sum of values of their apples.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22642000). The description of the test cases follows.\nThe first line of each test case contains three integers, n, m and k (1\u2264n,m\u226450, 1\u2264k\u2264109)\u00a0\u2014 the number of green apples Jellyfish has, the number of green apples Gellyfish has and the number of rounds of the game respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the values of Jellyfish's green apples.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bi\u2264109)\u00a0\u2014 the values of Gellyfish's green apples.\nDo note that the sum of n and m over all test cases are both not bounded.\nFor each test case, output a single integer\u00a0\u2014 the final sum of the values of Jellyfish's apples.\nIn the first test case, Jellyfish will swap the apple of value 1 and 4.\nIn the second test case, both players will swap the two apples 10,000 times.\nIn the fourth test case, Jellyfish will do nothing.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1874A - Jellyfish and Game TutorialLet us define min(a) to be the minimum value of a in the current round, max(a) to be the maximum value of a in the current round, min(b) to be the minimum value of b in the current round, max(b) to be the maximum value of b in the current round, MIN to be the minimum value of all the apples, MAX to be the maximum value of all the apples.By greedy and induction, we would come to the following conclusion:  If Jellyfish is the one operating this round: If min(a)<max(b), she will swap this two apples, otherwise she will do nothing. If Gellyfish is the one operating this round: If max(a)>min(b), he will swap this two apples, otherwise she will do nothing. We consider who MAX and MIN will belong to after the first round.In the first round:  If max(a)<max(b), MAX=max(b). And because min(a)<max(b), Jellyfish will swap this two apples. So MAX belongs to Jellyfish. If max(a)>max(b), MAX=max(a). If min(a)=max(a), then min(a)>max(b), Jellyfish will do nothing. Otherwise Jellyfish won't swap the apple with value MAX. In conclusion MAX belongs to Jellyfish We can also show that MIN belongs to Gellyfish, and the proof is symmetric with the above.So in the second round, min(b)=MIN,max(a)=MAX, We have MIN<MAX. So Gellyfish will swap this two apples, in the third round, min(a)=MIN,max(b)=MAX, Jellyfish will swap this two apples.So after the first round, the game will go two rounds at a time, with two people swapping two apples with the minimum value and the maximum value back and forth.So we only need to know the answer for k=1 and k=2.Time complexity: O(n+m) per test case.Memory complexity: O(n+m) per test case. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000 + 5;\nint n = 0, m = 0, k = 0, x = 0, y = 0, a[N] = {}, b[N] = {};\n\ninline void solve(){\n\tscanf(\"%d %d %d\", &n, &m, &k); k --;\n\tfor(int i = 0 ; i < n ; i ++) scanf(\"%d\", &a[i]);\n\tfor(int i = 0 ; i < m ; i ++) scanf(\"%d\", &b[i]);\n\tx = y = 0;\n\tfor(int i = 1 ; i < n ; i ++) if(a[i] < a[x]) x = i;\n\tfor(int i = 1 ; i < m ; i ++) if(b[i] > b[y]) y = i;\n\tif(b[y] > a[x]) swap(a[x], b[y]);\n\tif(k & 1){\n\t\tx = 0, y = 0;\n\t\tfor(int i = 1 ; i < n ; i ++) if(a[i] > a[x]) x = i;\n\t\tfor(int i = 1 ; i < m ; i ++) if(b[i] < b[y]) y = i;\n\t\tswap(a[x], b[y]);\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < n ; i ++) ans += a[i];\n\tprintf(\"%lld\\n\", ans);\n\t\n}\n\nint T = 0;\n\nint main(){\n\tscanf(\"%d\", &T);\n\tfor(int i = 0 ; i < T ; i ++) solve();\n\treturn 0;\n}\n1875C - Jellyfish and Green Apple TutorialFirstly, if n\u2265m, we can make the problem transform n<m by giving each person an apple at a time until there are not enough apples.We can calculate the mass of apples that each person ends up with as nm.Since it's cut in half every time, if mgcd(n,m) is not an integral power of 2, there's no solution.Since the number of apple pieces is added to exactly 1 for each cut, So we just need to minimize the final number of apple pieces.As the problem is transformed, nm is less than 1, and mgcd(n,m) is an integral power of 2. So we can uniquely find a set of positive integers S satisfying nm=\u2211i\u2208S12i. And this method can be proven to be optimal, if we find another multiset T satisfying S\u2260T, for every element x that appears twice or more, We can make the answer better by removing two x at a time from T and adding one x\u22121 to T. By repeating this process, eventually T will become S.We can use std::__builtin_popcount() to get |S|, the answer is m\u00d7|S|\u2212n.Time complexity: O(logm) per test case.Memory complexity: O(1) per test case. Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n = 0, m = 0;\n\ninline void solve(){\n\tscanf(\"%d %d\", &n, &m); n %= m;\n\tint a = n / __gcd(n, m), b = m / __gcd(n, m);\n\tif(__builtin_popcount(b) > 1) printf(\"-1\\n\");\n\telse printf(\"%lld\\n\", 1ll * __builtin_popcount(a) * m - n);\n}\n\nint T = 0;\n\nint main(){\n\tscanf(\"%d\", &T);\n\tfor(int i = 0 ; i < T ; i ++) solve();\n\treturn 0;\n}\n1875D - Jellyfish and Mex TutorialWe only care about the operation before MEX(a) reaches 0, because after that, m will never change.Lemma. Before MEX(a) reaches 0, we will choose a positive integer x at a time that satisfies x<MEX(a), and delete all x from a, the MEX(a) will become x.Proof. Because if x>MEX(a), we can place this operation after the MEX(a) becomes 0, if we don't delete all of x, MEX(a) won't change, we can also put this operation later.So before MEX(a) reaches 0, the x we delete is non-increasing.It means we can solve this problem by dynamic programming. Let dpi represents when MEX(a)=i, and we haven't delete any x satisfying x<i,the minimum value of m.Let ci represents the number of times i appears in a, the transition is: \u2200j<i,dpj\u2190dpi+i\u00d7(cj\u22121)+j.Time complexity: O(n2) per test case.Memory complexity: O(n) per test case. Code#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll N = 5000 + 5, Inf = 0x3f3f3f3f3f3f3f3f;\nll n = 0, m = 0, a[N] = {}, dp[N] = {};\n\ninline void init(){\n\tfor(ll i = 0 ; i <= n ; i ++) a[i] = 0, dp[i] = Inf;\n\tn = m = 0;\n}\n\ninline void solve(){\n\tscanf(\"%lld\", &n);\n\tfor(ll i = 1, x = 0 ; i <= n ; i ++){\n\t\tscanf(\"%lld\", &x);\n\t\tif(x < n) a[x] ++;\n\t}\n\twhile(a[m]) m ++;\n\tdp[m] = 0;\n\tfor(ll i = m ; i >= 1 ; i --) for(ll j = 0 ; j < i ; j ++) dp[j] = min(dp[j], dp[i] + i * a[j]);\n\tprintf(\"%lld\\n\", dp[0] - m);\n}\n\nll T = 0;\n\nint main(){\n\tmemset(dp, 0x3f, sizeof(dp));\n\tscanf(\"%lld\", &T);\n\tfor(ll i = 0 ; i < T ; i ++) init(), solve();\n\treturn 0;\n}\n"
    },
    "1873E": {
        "title": "E. Building an Aquarium",
        "description": "You love fish, that's why you have decided to build an aquarium. You have a piece of coral made of n columns, the i-th of which is ai units tall. Afterwards, you will build a tank around the coral as follows: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two positive integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the number of columns of the coral and the maximum amount of water you can use.\nThe second line of each test case contains n space-separated integers ai (1\u2264ai\u2264109)\u00a0\u2014 the heights of the coral.\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single positive integer h (h\u22651)\u00a0\u2014 the maximum height the tank can have, so you need at most x units of water to fill up the tank.\nWe have a proof that under these constraints, such a value of h always exists.\nThe first test case is pictured in the statement. With h=4 we need 8 units of water, but if h is increased to 5 we need 13 units of water, which is more than x=9. So h=4 is optimal.\nIn the second test case, we can pick h=4 and add 3 units to each column, using a total of 9 units of water. It can be shown that this is optimal.\nIn the third test case, we can pick h=2 and use all of our water, so it is optimal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "sortings",
            "*1100"
        ],
        "solutions": "1873E - Building an AquariumWe need to find the maximum height with a certain upper bound\u00a0\u2014 this is a tell-tale sign of binary search. If you don't know what that is, you should read this Codeforces EDU article.For a given value of h, in the i-th column we will need h\u2212ai units of water if h\u2265ai, or 0 units otherwise. (This is equal to max(h\u2212ai,0), why?) So we can compute the amount of water for all n columns by simply iterating through and summing the total amount of water needed for each column, and see if it's not larger than x.Then you can binary search on the optimal value of h. The model solution uses the starting bounds l=0, r=2ai+\u03b5, because the optimal height could be ai+x. So the complexity is O(nlogai) per testcase. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200'007;\nconst int MOD = 1'000'000'007;\n \nvoid solve() {\n\tint n;\n\tlong long x;\n\tcin >> n >> x;\n\tlong long a[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tlong long lo = 0, hi = 2'000'000'007;\n\twhile (lo < hi) {\n\t\tlong long mid = lo + (hi - lo + 1) / 2;\n\t\tlong long tot = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttot += max(mid - a[i], 0LL);\n\t\t}\n\t\tif (tot <= x) {lo = mid;} \n\t\telse {hi = mid - 1;}\n\t}\n\tcout << lo << endl;\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}\n\n"
    },
    "1872D": {
        "title": "D. Plus Minus Permutation",
        "description": "You are given 3 integers\u00a0\u2014 n, x, y. Let's call the score of a permutation\u2020 p1,\u2026,pn the following value:\n(p1\u22c5x+p2\u22c5x+\u2026+p\u230anx\u230b\u22c5x)\u2212(p1\u22c5y+p2\u22c5y+\u2026+p\u230any\u230b\u22c5y)\nIn other words, the score of a permutation is the sum of pi for all indices i divisible by x, minus the sum of pi for all indices i divisible by y.\nYou need to find the maximum possible score among all permutations of length n.\nFor example, if n=7, x=2, y=3, the maximum score is achieved by the permutation [2,6_,1_,7_,5,4__,3] and is equal to (6+7+4)\u2212(1+4)=17\u22125=12.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (the number 2 appears twice in the array) and [1,3,4] is also not a permutation (n=3, but the array contains 4).\nThe first line of input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follows the description of each test case.\nThe only line of each test case description contains 3 integers n, x, y (1\u2264n\u2264109, 1\u2264x,y\u2264n).\nFor each test case, output a single integer\u00a0\u2014 the maximum score among all permutations of length n.\nThe first test case is explained in the problem statement above.\nIn the second test case, one of the optimal permutations will be [12,11,2_,4,8,9__,10,6,1_,5,3,7__]. The score of this permutation is (9+7)\u2212(2+9+1+7)=\u22123. It can be shown that a score greater than \u22123 can not be achieved. Note that the answer to the problem can be negative.\nIn the third test case, the score of the permutation will be (p1+p2+\u2026+p9)\u2212p9. One of the optimal permutations for this case is [9,8,7,6,5,4,3,2,1], and its score is 44. It can be shown that a score greater than 44 can not be achieved.\nIn the fourth test case, x=y, so the score of any permutation will be 0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solutions": "1872D - Plus Minus PermutationLet's call a number red if it is divisible by x.Let's call a number blue if it is divisible by y.Let's call a number purple if it is both red and blue at the same time.The score of a permutation, by definition, is the sum of pi for all red numbers i from 1 to n, minus the sum of pi for all blue numbers i from 1 to n.It is easy to see that pi at purple indices i does not affect the score of the permutation: they are included in the sum once with a plus sign and once with a minus sign.Therefore, the score of the permutation is the sum of pi for \"red but not purple indices\" minus the sum of pi for \"blue but not purple indices\".Notice that the set of \"red but not purple indices\" and the set of \"blue but not purple indices\" cannot intersect, because if they had a common index, it would be purple.Therefore, it is obviously optimal to place the largest numbers possible on \"red but not purple indices\" and the smallest numbers possible on \"blue but not purple indices\".To calculate the number of indices that are \"red but not purple\", we can calculate the number of red indices and subtract the number of purple indices.The number of red indices is \u230anx\u230b, and the number of blue indices is calculated similarly.To calculate the number of purple indices, we need to notice that the condition \"index is divisible by both x and y\" is equivalent to \"index is divisible by lcm(x,y)\", where lcm denotes the least common multiple. Therefore, the number of purple indices is \u230anlcm(x,y)\u230b.Let R be the number of \"red but not purple\" indices, and let B be the number of \"blue but not purple\" indices. Then it is not difficult to see that the maximum score is (n+(n\u22121)+\u2026+(n\u2212(R\u22121))\u2212(1+2+\u2026+B).To quickly find this sum, we can use the formula for the sum of an arithmetic progression: l+(l+1)+\u2026+r=(l+r)\u22c5(r\u2212l+1)2 Solution222362817"
    },
    "1872C": {
        "title": "C. Non-coprime Split",
        "description": "You are given two integers l\u2264r. You need to find positive integers a and b such that the following conditions are simultaneously satisfied:\nor report that they do not exist.\ngcd(a,b) denotes the greatest common divisor of numbers a and b. For example, gcd(6,9)=3, gcd(8,9)=1, gcd(4,2)=2.\nThe first line of the input contains an integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThen the descriptions of the test cases follow.\nThe only line of the description of each test case contains 2 integers l,r (1\u2264l\u2264r\u2264107).\nFor each test case, output the integers a,b that satisfy all the conditions on a separate line. If there is no answer, instead output a single number \u22121.\nIf there are multiple answers, you can output any of them.\nIn the first test case, 11\u22646+9\u226415, gcd(6,9)=3, and all conditions are satisfied. Note that this is not the only possible answer, for example, {4,10},{5,10},{6,6} are also valid answers for this test case.\nIn the second test case, the only pairs {a,b} that satisfy the condition 1\u2264a+b\u22643 are {1,1},{1,2},{2,1}, but in each of these pairs gcd(a,b) equals 1, so there is no answer.\nIn the third sample test, gcd(14,4)=2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1872C - Non-coprime Split  Tutorial  Tutorial is loading... Solution222362796"
    },
    "1870B": {
        "title": "B. Friendly Arrays",
        "description": "You are given two arrays of integers \u2014 a1,\u2026,an of length n, and b1,\u2026,bm of length m. You can choose any element bj from array b (1\u2264j\u2264m), and for all 1\u2264i\u2264n perform ai=ai|bj. You can perform any number of such operations.\nAfter all the operations, the value of x=a1\u2295a2\u2295\u2026\u2295an will be calculated. Find the minimum and maximum values of x that could be obtained after performing any set of operations.\nAbove, | is the bitwise OR operation, and \u2295 is the bitwise XOR operation.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. This is followed by the description of the test cases.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u22642\u22c5105) \u2014 the sizes of arrays a and b.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u2014 the array a.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (0\u2264bi\u2264109) \u2014 the array b.\nIt is guaranteed that the sum of values of n and m across all test cases does not exceed 2\u22c5105.\nFor each test case, output 2 numbers: the minimum and maximum possible values of x after performing any set of operations.\nIn the first test case, if we apply the operation with element b1=1, the array a will become [1,1], and x will be 0. If no operations are applied, then x=1.\nIn the second test case, if no operations are applied, then x=2. If we apply the operation with b1=1, then a=[1,1,3], and x=3.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1870B - Friendly Arrays TutorialNote that after performing the operation on bj, which has some bit set to 1, this bit will become 1 for all numbers in a (and will remain so, as a bit cannot change from 1 to 0 in the result of an OR operation). If n is even, then in the final XOR, this bit will become 0, as it will be equal to the XOR of an even number of ones. If n is odd, then this bit will be 1 in the final XOR.Therefore, if n is even, by performing the operation on bj, we set all the bits that are 1 in bj to 0 in the final XOR. If n is odd, we do the opposite and set these bits to 1. So, if n is even, the XOR does not increase when applying the operation, which means that to obtain the minimum possible XOR, we need to apply the operation to all the numbers in b, and the maximum XOR will be the original XOR. For odd n, it is the opposite: the minimum is the original XOR, and the maximum is obtained after applying the operation to all elements in b.To apply the operation to all elements in b, it is sufficient to calculate their bitwise OR and apply the operation to the array a with it."
    },
    "1869B": {
        "title": "B. 2D Traveling",
        "description": "Piggy lives on an infinite plane with the Cartesian coordinate system on it.\nThere are n cities on the plane, numbered from 1 to n, and the first k cities are defined as major cities. The coordinates of the i-th city are (xi,yi).\nPiggy, as a well-experienced traveller, wants to have a relaxing trip after Zhongkao examination. Currently, he is in city a, and he wants to travel to city b by air. You can fly between any two cities, and you can visit several cities in any order while travelling, but the final destination must be city b.\nBecause of active trade between major cities, it's possible to travel by plane between them for free. Formally, the price of an air ticket f(i,j) between two cities i and j is defined as follows:\nf(i,j)={0,if cities\u00a0i\u00a0and\u00a0j\u00a0are both major cities|xi\u2212xj|+|yi\u2212yj|,otherwise\nPiggy doesn't want to save time, but he wants to save money. So you need to tell him the minimum value of the total cost of all air tickets if he can take any number of flights.\nThe first line of input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains four integers n, k, a and b (2\u2264n\u22642\u22c5105, 0\u2264k\u2264n, 1\u2264a,b\u2264n, a\u2260b) \u2014 the number of cities, the number of major cities and the numbers of the starting and the ending cities.\nThen n lines follow, the i-th line contains two integers xi and yi (\u2212109\u2264xi,yi\u2264109) \u2014 the coordinates of the i-th city. The first k lines describe major cities. It is guaranteed that all coordinates are pairwise distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer \u2014 the minimum value of the total price of all air tickets.\nIn the first test case:\nThe optimal way to choose the flights is: 3\u21921\u21922\u21925, which will cost 3+0+1=4. Note that the flight 1\u21922 costs 0, because both city 1 and 2 are major cities.\nIn the second test case, since there are only 2 cities, the only way is to take a flight from city 1 to 2.\nIn the third test case, since city 2 and 4 are both major cities, Piggy can directly take a flight from city 2 to 4, which costs 0.\nIn the fourth test case, Piggy can choose to take the following flights: 3\u21922\u21921, and the cost is 11+11=22.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "math",
            "shortest paths",
            "sortings",
            "*1100"
        ],
        "solutions": "1869B - 2D TravelingFirst of all, it's easy to see that if there are no major cities, the minimum value of the total cost should be |xa\u2212xb|+|ya\u2212yb| \u2014 the optimal choice is to fly directly from city a to city b.Claim. Piggy will pass through a maximum of 2 major cities.Proof. If he passes through 3 or more major cities in a row, then he can fly directly from the first one to the last one. If he passes through 2 major cities and passes an ordinary city between them, the cost must be higher than flying directly between these two major cities. So the optimal choice always consists of no more than 2 major cities, and they are in a row.Thus, you can express the optimal choice as a(\u2192s)(\u2192t)\u2192b, where s and t are both major cities. If you naively enumerate s and t, the total complexity of the solution will be O(k2). But after seeing that s and t work independently, we can enumerate them separately. The total complexity decreases to O(n+k). Implementation#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n, k, s, t; cin >> n >> k >> s >> t;\n\tvector<int> x(n + 1), y(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\tll ans = llabs(x[s] - x[t]) + llabs(y[s] - y[t]);\n\tll mins = LLONG_MAX / 2, mint = LLONG_MAX / 2;\n\tfor (int i = 1; i <= k; i++) {\n\t\tmins = min(mins, llabs(x[s] - x[i]) + llabs(y[s] - y[i]));\n\t\tmint = min(mint, llabs(x[t] - x[i]) + llabs(y[t] - y[i]));\n\t}\n\tans = min(ans, mins + mint);\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n} Rate the problem Amazing problem: \n\n    \n\n\n102\n\n\n\n Good problem: \n\n    \n\n\n366\n\n\n\n Average problem: \n\n    \n\n\n74\n\n\n\n Bad problem: \n\n    \n\n\n32\n\n\n\n Didn't solve: \n\n    \n\n\n31\n\n\n\n "
    },
    "1867B": {
        "title": "B. XOR Palindromes",
        "description": "You are given a binary string s of length n (a string that consists only of 0 and 1). A number x is good if there exists a binary string l of length n, containing x ones, such that if each symbol si is replaced by si\u2295li (where \u2295 denotes the bitwise XOR operation), then the string s becomes a palindrome.\nYou need to output a binary string t of length n+1, where ti (0\u2264i\u2264n) is equal to 1 if number i is good, and 0 otherwise.\nA palindrome is a string that reads the same from left to right as from right to left. For example, 01010, 1111, 0110 are palindromes.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains a binary string s of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single line containing a binary string t of length n+1 - the answer to the problem.\nConsider the first example. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "strings",
            "*1100"
        ],
        "solutions": "1867B \u2014 XOR PalindromesAuthor: ace5 TutorialFirstly, a string is a palindrome if and only if for any i (1\u2264i\u2264n) si=sn\u2212i+1 (because when reversed, si becomes sn\u2212i+1).We can divide the characters into pairs, where each pair consists of si and sn\u2212i+1. If si=sn\u2212i+1, then we need to have li=ln\u2212i+1 in order to obtain equal elements after XOR. Therefore, either li=ln\u2212i+1=0 (with 0 ones) or li=ln\u2212i+1=1 (with 2 ones). If si\u2260sn\u2212i+1, then li\u2260ln\u2212i+1 must hold (1 one in any case). Additionally, if n is odd, then ln/2+1 can be either 0 or 1 (with 0 or 1 ones).We can iterate over the number of pairs where li=ln\u2212i+1 will have two ones, as well as whether there will be a one in the center or not. This way, we can obtain all possible numbers of ones in l, i.e., all good i.Time Complexity: O(n) per test case. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        string t(n+1,'0');\n        int ans = 0;\n        int max_1 = 0;\n        int max_2 = 0;\n        for(int i = 0;i <= n/2-1;++i)\n        {\n            if(s[i] == s[n-i-1])\n                max_2++;\n            else\n                ans++;\n        }\n        if(n%2 == 1)\n            max_1++;\n        for(int j = 0;j <= max_2;++j)\n        {\n            for(int k = 0;k <= max_1;++k)\n            {\n                t[ans + j*2 + k] = '1';\n            }\n        }\n        cout << t << \"\\n\";\n    }\n}"
    },
    "1864B": {
        "title": "B. Swap and Reverse",
        "description": "You are given a string s of length n consisting of lowercase English letters, and an integer k. In one step you can perform any one of the two operations below:\nYou can make as many steps as you want (possibly, zero). Your task is to find the lexicographically smallest string you can obtain after some number of steps. \nA string a is lexicographically smaller than a string b of the same length if and only if the following holds: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k<n\u2264105).\nThe second line of each test case contains the string s of length n consisting of lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the lexicographically smallest string after doing some (possibly, zero) steps.\nIn the first test case, we can obtain the string \"aimn\" using the following operations:\nIt can be proven that we cannot obtain any string lexicographically smaller than \"aimn\". Therefore, \"aimn\" is the answer.\nIn the second test case, we can obtain the string \"aandp\" using the following operations:\nIt can be proven that we cannot obtain any string lexicographically smaller than \"aandp\". Therefore, \"aandp\" is the answer.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "strings",
            "*1100"
        ],
        "solutions": "1864B-Swap and ReverseIdea : Amir_Parsa, chromate00 TutorialBy the first kind of operation, we already know that every odd index (same for the even ones) can be swapped with each other freely. Therefore, let us write down the values of the indices modulo 2. For example, if n is 10, the indices modulo 2 are [1,0,1,0,1,0,1,0,1,0]. Now, we consider the two cases.  When k is odd. We can find out that after reversing any subarray of length k, the indices modulo 2 do not change. So in this case, any series of the second operation is identical to some series of the first operation. Therefore, you should sort the odd indices and the even indices separately, and output the result of merging them into one string.  When k is even. Let us observe how we can swap two adjacent indices in this case. First, reverse [i,i+k\u22121], and then reverse [i+1,i+k]. If we do this on [1,0,1,0,1,0,1,0,1,0], assuming i=1 and k=6, the indices modulo 2 turn into [0,1,0,1,0,1,1,0,1,0], and then [0,1,1,0,1,0,1,0,1,0]. Using these two steps and some series of the first operation, we can see that we can swap any two adjacent indices as a result. And such a series of operation is always possible, as k<n. Therefore, we can sort the entire string, and output the result. solution#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    \n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n, k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n        vector<char> odd, even;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                even.pb(s[i]);\n            } else {\n                odd.pb(s[i]);\n            }\n        }\n        sort(all(even));\n        sort(all(odd));\n        string ans1 = \"\";\n        for (int i = 0, j = 0; i < sz(even) || j < sz(odd); ++i, ++j) {\n            if (i < sz(even)) {\n                ans1 += even[i];\n            }\n            if (j < sz(odd)) {\n                ans1 += odd[i];\n            }\n        }\n        if (k % 2 == 0) {\n            sort(all(s));\n            cout << s << \"\\n\";\n            continue;\n        }\n        cout << ans1 << \"\\n\";\n    }\n\n}\n\n bonusTry to solve the problem if n=k was allowed."
    },
    "1863C": {
        "title": "C. MEX Repetition",
        "description": "You are given an array a1,a2,\u2026,ana1,a2,\u2026,an of pairwise distinct integers from 00 to nn. Consider the following operation:\nHere MEXMEX of a collection of integers c1,c2,\u2026,cmc1,c2,\u2026,cm is defined as the smallest non-negative integer xx which does not occur in the collection cc. For example, MEX(0,2,2,1,4)=3MEX(0,2,2,1,4)=3 and MEX(1,2)=0MEX(1,2)=0.\nPrint the array after applying kk such operations.\nEach test contains multiple test cases. The first line contains the number of test cases tt (1\u2264t\u22641051\u2264t\u2264105). The description of the test cases follows.\nThe first line of each test case contains two integers nn and kk (1\u2264n\u22641051\u2264n\u2264105, 1\u2264k\u22641091\u2264k\u2264109).\nThe second line contains nn pairwise distinct integers a1,a2,\u2026,ana1,a2,\u2026,an (0\u2264ai\u2264n0\u2264ai\u2264n) representing the elements of the array before applying the operations.\nIt is guaranteed that the sum of nn over all test cases does not exceed 105105.\nFor each test case, print all nn elements of the array after applying kk operations.\nIn the first test case, here is the entire process:\nThus, the array becomes [1][1] after two operations.\nIn the second test case, the array changes as follows during one operation: [0_,1,3]\u2192[2,1_,3]\u2192[2,0,3_]\u2192[2,0,1][0\u2013,1,3]\u2192[2,1\u2013,3]\u2192[2,0,3\u2013]\u2192[2,0,1].\nIn the third test case, the array changes as follows during one operation: [0_,2]\u2192[1,2_]\u2192[1,0][0\u2013,2]\u2192[1,2\u2013]\u2192[1,0]. And during the second operation: [1_,0]\u2192[2,0_]\u2192[2,1][1\u2013,0]\u2192[2,0\u2013]\u2192[2,1].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1863C - MEX RepetitionAppend the initial array a1,\u2026,an with an+1=MEX(a1,\u2026,an). It is easy to see that a1,\u2026,an+1 is a permutation of 0,1,\u2026,n. In this case setting ai=MEX(a1,\u2026,an) is basically equivalent ai=an+1, but after this the new MEX(a1,\u2026,an) is changed. In fact, it becomes equal to the old value of ai, since this value is not now present in the array.In other words, performing the operation on ai is equivalent to swapping ai and an+1. Performing the operation on i=1,2,\u2026,n can be viewed as n swaps. It means that the array changes from [a1,a2,\u2026,an+1] to [an+1,a1,a2,\u2026,an], i. e. we simply perform the cyclic shift to the right.To finish up the solution, first, calculate an+1=MEX(a1,\u2026,an) (you can do so, for example, by setting an+1=n(n+1)2\u2212\u2211i=1nai). Second, calculate k%(n+1) and then perform the cyclic shift in O(n)."
    },
    "1863B": {
        "title": "B. Split Sort",
        "description": "You are given a permutation\u2020 p1,p2,\u2026,pn of integers 1 to n.\nYou can change the current permutation by applying the following operation several (possibly, zero) times:\nFor example, if the permutation used to be [6,4,3,5,2,1] and you choose x=4, then you will first write down [3,2,1], then append this with [6,4,5]. So the initial permutation will be replaced by [3,2,1,6,4,5].\nFind the minimum number of operations you need to achieve pi=i for i=1,2,\u2026,n. We can show that it is always possible to do so.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). The description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u2264100000).\nThe second line of each test case contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n). It is guaranteed that p1,p2,\u2026,pn is a permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 100000.\nFor each test case, output the answer on a separate line.\nIn the first test case, n=1 and p1=1, so there is nothing left to do.\nIn the second test case, we can choose x=2 and we immediately obtain p1=1, p2=2.\nIn the third test case, we can achieve the minimum number of operations in the following way:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1863B - Split Sort SolutionTutorial is loading..."
    },
    "1862C": {
        "title": "C. Flower City Fence",
        "description": "Anya lives in the Flower City. By order of the city mayor, she has to build a fence for herself.\nThe fence consists of n planks, each with a height of ai meters. According to the order, the heights of the planks must not increase. In other words, it is true that ai\u2265aj for all i<j.\nAnya became curious whether her fence is symmetrical with respect to the diagonal. In other words, will she get the same fence if she lays all the planks horizontally in the same order.\nFor example, for n=5, a=[5,4,3,2,1], the fence is symmetrical. Because if all the planks are laid horizontally, the fence will be [5,4,3,2,1], as shown in the diagram.\n On the left is the fence [5,4,3,2,1], on the right is the same fence laid horizontally \nBut for n=3, a=[4,2,1], the fence is not symmetrical. Because if all the planks are laid horizontally, the fence will be [3,2,1,1], as shown in the diagram.\n On the left is the fence [4,2,1], on the right is the same fence laid horizontally \nHelp Anya and determine whether her fence is symmetrical.\nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. \nThe description of the test cases follows.\nThe first line of a test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the fence.\nThe second line of a test case contains n integers a1\u2265a2\u2265a3\u2265\u22ef\u2265an (1\u2264ai\u2264109)\u00a0\u2014 the heights of the planks.\nThe sum of the values of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if the fence is symmetrical, otherwise output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be accepted as a positive answer.\nIn the first and second test cases of the example, the fence is symmetrical.\nIn the third test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [3,2,1,1].\nIn the fourth test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [1,1].\nIn the fifth and sixth test cases of the example, the fence is symmetrical.\nIn the seventh test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [2,1,1,1,1,1].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1862C - Flower City FenceObviously, if a1\u2260n, then this fence is not symmetric, because the fence a has a length of n, while the horizontally laid fence has a length of a1\u2260n.Now let's build a fence b using horizontal boards that would match the original fence a. And let's check if the arrays a and b are equal. If they are equal, then the fence is symmetric; otherwise, it is not. There won't be any memory issues since all ai\u2264n, which means the length of array b does not exceed n. Solution#include <iostream>\n#include <vector>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n + 1);\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i];\n        }\n        if (a[1] != n) {\n            cout << \"NO\" << '\\n';\n            continue;\n        }\n        vector<int> b;\n        for (int i = n; i >= 1; i--) {\n            while (b.size() < a[i]) {\n                b.push_back(i);\n            }\n        }\n        bool meow = true;\n        for (int i = 1; i <= n; i++) {\n            if (a[i] != b[i - 1]) {\n                cout << \"NO\" << '\\n';\n                meow = false;\n                break;\n            }\n        }\n        if (meow) {\n            cout << \"YES\" << '\\n';\n        }\n    }\n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n130\n\n\n\n Good task \n\n    \n\n\n532\n\n\n\n Average task \n\n    \n\n\n49\n\n\n\n Bad task \n\n    \n\n\n126\n\n\n\n "
    },
    "1861B": {
        "title": "B. Two Binary Strings",
        "description": "You are given two strings a and b of equal length, consisting of only characters 0 and/or 1; both strings start with character 0 and end with character 1. \nYou can perform the following operation any number of times (possibly zero): \nFormally, you choose one of these two strings (let the chosen string be s), then pick two integers l and r such that 1\u2264l<r\u2264|s| and sl=sr, then replace every character si such that l<i<r with sl.\nFor example, if the chosen string is 010101, you can transform it into one of the following strings by applying one operation:\nYou have to determine if it's possible to make the given strings equal by applying this operation any number of times.\nThe first line contains a single integer t (1\u2264t\u22642000) \u00a0\u2014 the number of test cases.\nEach test case consists of two lines: \nAdditional constraints on the input: \nFor each test case, print YES if it is possible to make the strings equal. Otherwise, print NO. You can print each letter in any register.\nIn the first test case, we can perform the following operations: \nIn the second test case, the strings are already equal.\nIn the third test case, we can perform the following operations: \nIn the fourth and fifth test cases, it's impossible to make the given strings equal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "*1000"
        ],
        "solutions": "1861B - Two Binary StringsIf the answer is YES, we can always bring both strings to the form 00\u202601\u202611 (some prefix consists of zeros, some suffix consists of ones, and all zeroes are before all ones). It's true because after we make both strings equal, we can apply another operation with l=i,r=|a|, where i is the minimum index where both strings have 1 after we made them equal. For example, in the first test case, the strings are equal to 01110001 after applying all operations considered in the statement. We can turn them into the string 01111111 by applying operation with l=2,r=8.Okay, now let's try to find out when we can transform a string into the form 00\u20260011\u202611. We claim that it's possible to transform the string s into the form \"i first elements are zeroes, all the remaining elements are ones\" if and only if si=0 and si+1=1:  if si=0 and si+1=1, we can apply two operations with l=1,r=i and l=i+1,r=|s|, and the string turns into the form \"i first elements are zeroes, all the remaining elements are ones\";  however, if that's not the case, then either si=si+1, or si=1 and si+1=0. In the former case, we need to change one of these two elements; but since they are equal and adjacent, every operation on them will affect them both, so it's impossible to change only one of them. In the latter case, we need to set either si to 0 or si+1 to 1 first; and when we do it, the elements become equal, and every operation on them will affect them both. So, it's impossible to bring the string into the form \"i first elements are zeroes, all the remaining elements are ones\". So, the answer is YES if there is an index i such that ai=bi=0 and ai+1=bi+1=1. Otherwise, the answer is NO. Solution (Roms)#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    for (int tc = 0; tc < t; ++tc) {\n        string a, b;\n        cin >> a >> b;\n        bool ok = false;\n        for (int i = 0; i + 1 < a.size(); ++i) {\n            if (a[i] == b[i] && a[i] == '0' && a[i + 1] == b[i + 1] && a[i + 1] == '1') {\n                ok = true;\n            }\n        }\n        \n        if (ok) \n            puts(\"YES\");\n        else\n            puts(\"NO\");\n    }\n    return 0;\n}"
    },
    "1860B": {
        "title": "B. Fancy Coins",
        "description": "Monocarp is going to make a purchase with cost of exactly m burles.\nHe has two types of coins, in the following quantities: \nMonocarp wants to make his purchase in such a way that there's no change\u00a0\u2014 the total worth of provided coins is exactly m. He can use both regular and fancy coins. However, he wants to spend as little fancy coins as possible.\nWhat's the smallest total number of fancy coins he can use to make a purchase?\nThe first line contains a single integer t (1\u2264t\u22643\u22c5104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains four integers m,k,a1 and ak (1\u2264m\u2264108; 2\u2264k\u2264108; 0\u2264a1,ak\u2264108)\u00a0\u2014 the cost of the purchase, the worth of the second type of coin and the amounts of regular coins of both types, respectively.\nFor each testcase, print a single integer\u00a0\u2014 the smallest total number of fancy coins Monocarp can use to make a purchase.\nIn the first testcase, there are no regular coins of either type. Monocarp can use 2 fancy coins worth 1 burle and 3 fancy coins worth 3 (since k=3) burles to get 11 total burles with 5 total fancy coins.\nIn the second testcase, Monocarp has a lot of regular coins of both types. He can use 11 regular coins worth 1 burle, for example. Notice that Monocarp doesn't have to minimize the total number of used coins. That way he uses 0 fancy coins.\nIn the third testcase, Monocarp can use 5 regular coins worth 1 burle and 1 regular coin worth 3 burles. That will get him to 8 total burles when he needs 11. So, 1 fancy coin worth 3 burles is enough.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1860B - Fancy CoinsThere are two ways to approach this problem: a mathematical way and an algorithmic way.Approach 1Let's start by looking at the possible ways to represent m burles with our coins. For example, we could try to use as many coins of value k as possible: then, the number of coins of value k will be \u230amk\u230b, and the number of coins of value 1 will be mmodk.Now suppose it's not optimal to use that many coins of value k; what if it's better to use more coins of value 1 and fewer coins of value k? Well, we can still start with using \u230amk\u230b coins of value k and mmodk coins of value 1, and then try to replace one coin of value k with k coins of value 1 several times (maybe zero).How many times should we do this, and when should we stop to get an optimal solution? Well, firstly, let's make sure that we have already taken as many regular coins as possible. Then, if we have at least k leftover coins of value 1 which are regular (not fancy), and we have taken at least one fancy coin of value k, it's better to replace that coin. It's easy to see that there's no need for any replacements if that's not the case: if we don't have k regular coins which are currently unused, then at least one of the replacement coins will be fancy; and if the coin of value k we want to replace is not fancy, why replacing it at all?So, we could write a while-loop that keeps track how many coins of which types we have taken, and replaces one fancy coin of value k with k regular coins of value 1 until it's impossible. Unfortunately, this is too slow. But instead of running this loop, we can calculate the number of times we make that replacement in O(1): it is the minimum of the number of regular coins of value 1 we aren't using, divided by k, and the number of fancy coins of value k we are using.So, the outline of the solution is the following:  start by taking as many coins of value k as possible, and calculate how many coins of which value we have taken;  calculate how many regular and fancy coins of both types we have taken;  calculate how many \"replacements\" (discard one fancy coin of value k, add k regular coins of value 1) we can make. Approach 2The second approach also starts with analyzing how many coins of value 1 and how many coins of value k we can take. The minimum number of coins of value k we can take is 0, and the maximum number of such coins is \u230amk\u230b.Let f(x) denote the number of fancy coins we use, if we take exactly x coins of value k. This function can easily be calculated because we know how many coins of both types we take, if x is fixed. We need to find the minimum of this function on [0,\u230amk\u230b].How does f(x+1)\u2212f(x) behave? The meaning of going from f(x) to f(x+1) is just replacing k coins of value 1 with one coin of value k. When we increase x, obviously, we should try to discard fancy coins of value 1 first, then regular coins of value 1 (and the number of fancy coins we will discard will never increase when we increase x). Similarly, we should try to take regular coins of value k first, then fancy ones (and the number of fancy coins we take will never decrease when we increase x). So, the value of f(x+1)\u2212f(x) does not decrease when x increases.All of this means that the minimum value of f(x) can be found using ternary search. Solution 1 (BledDest)#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main()\n{\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tint m, k, a1, ak;\n\t\tcin >> m >> k >> a1 >> ak;\n\t\tint taken_k = m / k;\n\t\tint taken_1 = m % k;\n\t\tint taken_fancy_1 = max(0, taken_1 - a1);\n\t\tint left_regular_1 = max(0, a1 - taken_1);\n\t\tint taken_fancy_k = max(0, taken_k - ak);\n\t\tint to_replace = min(left_regular_1 / k, taken_fancy_k);\n\t\tint ans = taken_fancy_1 + taken_fancy_k - to_replace;\n\t\tcout << ans << endl;\n\t}\n} Solution 2 (BledDest)#include<bits/stdc++.h>\n \nusing namespace std;\n \nint main()\n{\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tint m, k, a1, ak;\n\t\tcin >> m >> k >> a1 >> ak;\n\t\t// function which calculates the number of fancy coins taken\n\t\t// if we take exactly x coins of value k\n\t\tauto f = [m, k, a1, ak](int x)\n\t\t{\n\t\t\tint taken_1 = m - k * x;\n\t\t\treturn max(0, taken_1 - a1) + max(0, x - ak);\n\t\t};\n\t\t\n\t\tint lf = 0;\n\t\tint rg = m / k;\n\t\twhile(rg - lf > 2)\n\t\t{\n\t\t\tint mid = (lf + rg) / 2;\n\t\t\tif(f(mid) < f(mid + 1))\n\t\t\t\trg = mid + 1;\n\t\t\telse\n\t\t\t\tlf = mid;\n\t\t}\n\t\tint ans = 1e9;\n\t\tfor(int i = lf; i <= rg; i++) ans = min(ans, f(i));\n\t\tcout << ans << endl;\n\t}\n}"
    },
    "1859C": {
        "title": "C. Another Permutation Problem",
        "description": "Andrey is just starting to come up with problems, and it's difficult for him. That's why he came up with a strange problem about permutations\u2020 and asks you to solve it. Can you do it?\nLet's call the cost of a permutation p of length n the value of the expression:\nFind the maximum cost among all permutations of length n.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u226430) \u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single integer n (2\u2264n\u2264250) \u2014 the length of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 500.\nFor each test case, output a single integer \u2014 the maximum cost among all permutations of length n.\nIn the first test case, the permutation with the maximum cost is [2,1]. The cost is equal to 2\u22c51+1\u22c52\u2212max(2\u22c51,1\u22c52)=2+2\u22122=2.\nIn the second test case, the permutation with the maximum cost is [1,2,4,3]. The cost is equal to 1\u22c51+2\u22c52+4\u22c53+3\u22c54\u22124\u22c53=17.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1859C - Another Permutation Problem HintsHint 1What if we fix the maximum element in the resulting array? Hint 2Try using greedy. Hint 3Optimize the log factor away by noticing a certain fact. TutorialLet's fix the maximum element in an array \u2014 let it be M. Now, let's iterate from n to 1. Let the current chosen number be i. I claim that if we maintain the remaining available numbers to multiply by, then it is optimal to take the maximum such number x that x\u2217i\u2264M. Proof: let's say that this is not correct. Then, let's say that we pair i with another number x1, and x gets paired with some other number i1. Then, i1<i, because it was chosen later, and x1<x (otherwise i\u2217x1>M). Now let's swap x with x1. The sum is increased by i\u2217x\u2212i\u2217x1\u2212i1\u2217x+i1\u2217x1=(i\u2212i1)(x\u2212x1)>0, and all of the numbers are less or equal to M.Now the task can be solved in O(N3logN) by simply iterating on the maximum from N2 to 1, while maintaining the remaining numbers with a set. In order to squeeze it in the TL, you can only consider such maximums that they can be represented as i\u2217j,1\u2264i,j\u2264n.In order to optimize it to O(N3), let's notice that for each number x, it can be paired with any number from 1 to Mx. Now just maintain a stack of all available elements at the current moment, add all numbers that possible, and pop the maximum number for all i from 1 to N. Author's code#include <iostream>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <vector>\nusing namespace std;\nvoid solve() {\n\tint N = 0; cin >> N;\n\tint ans = 0;\n\tvector<int> pr;\n\tpr.assign(N * N, -1);\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 1; j <= N; ++j) {\n\t\t\tpr[i * j - 1] = 1;\n\t\t}\n\t}\n\tfor (int mx = N * N; mx >= 1; --mx) {\n\t\tif (pr[mx - 1] == -1) continue;\n\t\tvector<vector<int>> a;\n\t\tint curans = -mx;\n\t\tbool br = false;\n\t\ta.assign(N, vector<int>());\n\t\tfor (int j = N; j >= 1; --j) {\n\t\t\tint num = min(mx / j, N);\n\t\t\tif (num < 1) {\n\t\t\t\tbr = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta[num - 1].push_back(j);\n\t\t}\n\t\tif (br) break;\n\t\tstack<int> s;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ts.push(i + 1);\n\t\t\tbool brk = false;\n\t\t\tfor (auto x : a[i]) {\n\t\t\t\tif (s.empty()) {\n\t\t\t\t\tbrk = true; break;\n\t\t\t\t}\n\t\t\t\tcurans += s.top() * x;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\tif (brk) break;\n\t\t}\n\t\tans = max(ans, curans);\n\t}\n\tcout << ans << \"\\n\";\n}\n \nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t = 0; cin >> t;\n\twhile (t--) solve();\n\treturn 0;\n}\n"
    },
    "1859B": {
        "title": "B. Olya and Game with Arrays",
        "description": "Artem suggested a game to the girl Olya. There is a list of n arrays, where the i-th array contains mi\u22652 positive integers ai,1,ai,2,\u2026,ai,mi.\nOlya can move at most one (possibly 0) integer from each array to another array. Note that integers can be moved from one array only once, but integers can be added to one array multiple times, and all the movements are done at the same time.\nThe beauty of the list of arrays is defined as the sum \u2211ni=1minmij=1ai,j. In other words, for each array, we find the minimum value in it and then sum up these values.\nThe goal of the game is to maximize the beauty of the list of arrays. Help Olya win this challenging game!\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u226425000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226425000) \u2014 the number of arrays in the list.\nThis is followed by descriptions of the arrays. Each array description consists of two lines.\nThe first line contains a single integer mi (2\u2264mi\u226450000) \u2014 the number of elements in the i-th array.\nThe next line contains mi integers ai,1,ai,2,\u2026,ai,mi (1\u2264ai,j\u2264109) \u2014 the elements of the i-th array.\nIt is guaranteed that the sum of mi over all test cases does not exceed 50000.\nFor each test case, output a single line containing a single integer \u2014 the maximum beauty of the list of arrays that Olya can achieve.\nIn the first test case, we can move the integer 3 from the second array to the first array. Then the beauty is min(1,2,3)+min(4)=5. It can be shown that this is the maximum possible beauty.\nIn the second test case, there is only one array, so regardless of the movements, the beauty will be min(100,1,6)=1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1859B - Olya and Game with Arrays HintsHint 1Do all numbers in a single array really matter? Hint 2If only the first minimum and the second minimum matter, what is the only way to increase a single array's beauty? Hint 3What can we say about the array which will have the smallest number in the end? TutorialTo increase the answer for each array separately, it is necessary to move the minimum to another array. Then, notice that it is optimal to move all the minimums to one array. Let's figure out which array. After moving the minimum from an array, the second minimum in the original array becomes the new minimum. Then, it is easy to notice that it is optimal to move all the minimums to the array with the smallest second minimum. After all the movements, we will have one array where the minimum element is the smallest number among all the arrays, and n\u22121 arrays where the minimum element is the second minimum in the original array.Therefore, the answer to the problem will be M+K\u2212S, where M is the minimum element among all the arrays, K is the sum of all the second minimums, and S is the smallest second minimum. Author's code#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n \nusing namespace std;\n \n#define all(v) v.begin(), v.end()\n \ntypedef long long ll;\n \nconst int INF = 1e9 + 7;\n \nvoid solve() {\n    int n;\n    cin >> n;\n \n    int minn = INF;\n    vector<int> min2;\n    for (int i = 0 ; i < n ; i++) {\n        int m;\n        cin >> m;\n        vector<int> v(m);\n        for (auto &el : v) cin >> el;\n \n        int minel = *min_element(all(v));\n        minn = min(minn, minel);\n        v.erase(find(all(v), minel));\n        min2.push_back(*min_element(all(v)));\n    }\n    cout << minn + (ll) accumulate(all(min2), 0ll) - *min_element(all(min2)) << \"\\n\";\n}\n \nsigned main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n \n#ifdef LOCAL\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n \n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n \n    return 0;\n}\n"
    },
    "1858C": {
        "title": "C. Yet Another Permutation Problem",
        "description": "Alex got a new game called \"GCD permutations\" as a birthday present. Each round of this game proceeds as follows:\nAlex has already played several rounds so he decided to find a permutation a1,a2,\u2026,an such that its score is as large as possible.\nRecall that gcd(x,y) denotes the greatest common divisor (GCD) of numbers x and y, and xmody denotes the remainder of dividing x by y.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of one line containing a single integer n (2\u2264n\u2264105).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print n distinct integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the permutation with the largest possible score.\nIf there are several permutations with the maximum possible score, you can print any one of them.\nIn the first test case, Alex wants to find a permutation of integers from 1 to 5. For the permutation a=[1,2,4,3,5], the array d is equal to [1,2,1,1,1]. It contains 2 distinct integers. It can be shown that there is no permutation of length 5 with a higher score.\nIn the second test case, Alex wants to find a permutation of integers from 1 to 2. There are only two such permutations: a=[1,2] and a=[2,1]. In both cases, the array d is equal to [1,1], so both permutations are correct.\nIn the third test case, Alex wants to find a permutation of integers from 1 to 7. For the permutation a=[1,2,3,6,4,5,7], the array d is equal to [1,1,3,2,1,1,1]. It contains 3 distinct integers so its score is equal to 3. It can be shown that there is no permutation of integers from 1 to 7 with a score higher than 3.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1858C - Yet Another Permutation ProblemIt is impossible to get di=gcd(ai,a(imodn)+1)>\u230an2\u230b: otherwise, at least one of the numbers in a would be divisible by di and would be greater than di at the same time, so it would be at least 2\u22c5di, which is greater than n. Therefore, the maximum possible score is no more than \u230an2\u230b. Actually, we can always get a score equal to \u230an2\u230b.How do we get such score? Let's set a1=1. After that, we put the powers of 2 less or equal n sequentially. Then we put 3 and powers of 2 multiplied by 3, then 5 and so on (for example, for n=12, we will get an array a=[1,2,4,8,3,6,12,5,10,7,9,11]). Then, for each number ai=x\u2264\u230an2\u230b, the next number will be a(imodn)+1=x\u22c52\u2264n. Their gcd will be exactly x, so there will be a pair of adjacent elements of a with greatest common divisor equal to x for all 1\u2264x\u2264\u230an2\u230b. Code#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int cur = 0;\n        for (int i = 1; i <= n; i += 2) {\n            for (int j = i; j <= n; j *= 2) {\n                a[cur++] = j;\n            }\n        }\n        for (int i = 0; i<n; ++i) {\n            cout << a[i] << \" \";\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
    },
    "1857C": {
        "title": "C. Assembly via Minimums",
        "description": "Sasha has an array a of n integers. He got bored and for all i, j (i<j), he wrote down the minimum value of ai and aj. He obtained a new array b of size n\u22c5(n\u22121)2.\nFor example, if a= [2,3,5,1], he would write [min(2,3),min(2,5),min(2,1),min(3,5),min(3,1),min(5,1)] = [2,2,1,3,1,1].\nThen, he randomly shuffled all the elements of the array b.\nUnfortunately, he forgot the array a, and your task is to restore any possible array a from which the array b could have been obtained.\nThe elements of array a should be in the range [\u2212109,109].\nThe first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264103)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n\u22c5(n\u22121)2 integers b1,b2,\u2026,bn\u22c5(n\u22121)2 (\u2212109\u2264bi\u2264109)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of n over all tests does not exceed 103 and for each array b in the test, there exists an original array.\nFor each test case, output any possible array a of length n.\nIn the first sample, Sasha chose the array [1,3,3], then the array b will look like [min(a1,a2)=1,min(a1,a3)=1,min(a2,a3)=3], after shuffling its elements, the array can look like [1,3,1].\nIn the second sample, there is only one pair, so the array [10,10] is suitable. Another suitable array could be [15,10].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1857C - Assembly via MinimumsSuppose we have an array a that we want to construct, with elements a1,a2,\u2026,an. To simplify the process, let's assume that the elements of a are sorted in non-decreasing order, meaning a1\u2264a2\u2264\u22ef\u2264an.Let's start with a1. Since the elements of a are sorted, the pairs (a1,a2),(a1,a3),\u2026,(a1,an) will have a1 as the smallest element in each pair. Therefore, the number of occurrences of a1 in array b will be n\u22121.Moving on to a2, we already know that a1 appears n\u22121 times in b. Since the elements of a are sorted, all pairs involving a2 will have a2 as the second smallest element. This means a2 will appear n\u22122 times in array b.We continue this process for each element ai in a. The number of occurrences of ai in array b will be n\u2212i.We can't determine the exact value of an , because it won't be written to array b. Therefore, for an we can choose any number in the range [an\u22121;109]. In case there are multiple elements bi in array b that satisfy the condition for a particular ai, we choose the smallest bi. This greedy approach works, because we are constructing a in non-decreasing order.The complexity is O(n2logn). Code C++#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;cin>>t;\n    while(t--)\n    {\n        int n;cin>>n;\n        int m=n*(n-1)/2,b[m];\n        for(int i=0;i<m;i++)cin>>b[i];\n        sort(b,b+m);\n        for(int i=0;i<m;i+=--n)cout<<b[i]<<' ';\n        cout<<\"1000000000\\n\";\n    }\n} Code Pythonfor _ in range(int(input())):\n    n=int(input())\n    l=sorted(map(int,input().split()))\n    j=0\n    for i in range(n-1,0,-1):\n        print(l[j],end=' ')\n        j+=i\n    print(l[-1]) Rate the problem Good task \n\n    \n\n\n572\n\n\n\n Average task \n\n    \n\n\n67\n\n\n\n Bad task \n\n    \n\n\n42\n\n\n\n Didn't solve \n\n    \n\n\n67\n\n\n\n "
    },
    "1857B": {
        "title": "B. Maximum Rounding",
        "description": "Given a natural number x. You can perform the following operation: \nNote that the positions are numbered from right to left, starting from zero. If the number has k digits, it is considered that the digit at the k-th position is equal to 0.\nThe rounding is done as follows: \n \n \nYour task is to make x as large as possible, if you can perform the operation as many times as you want.\nFor example, if x is equal to 3451, then if you choose consecutively: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of positive integer x with a length of up to 2\u22c5105. It is guaranteed that there are no leading zeros in the integer.\nIt is guaranteed that the sum of the lengths of all integers x over all test cases does not exceed 2\u22c5105.\nFor each set of input data, output the maximum possible value of x after the operations. The number should not have leading zeros in its representation.\nIn the first sample, it is better not to perform any operations.\nIn the second sample, you can perform one operation and obtain 10.\nIn the third sample, you can choose k=1 or k=2. In both cases the answer will be 100.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1857B - Maximum RoundingAuthor: SashaT9, prepared: FBI, Esestree TutorialTutorial is loading... Code C++#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int t;cin>>t;\n    while(t--)\n    {\n        string s;cin>>s;\n        s='0'+s;\n        int p=s.size();\n        for(int i=s.size()-1;i>=0;i--)\n        {\n            if(s[i]>='5')s[i-1]++,p=i;\n        }\n        for(int i=(s[0]=='0');i<s.size();i++)\n        {\n            cout<<(i>=p?'0':s[i]);\n        }\n        cout<<\"\\n\";\n    }\n} Code Pythonfor i in range(int(input())):\n    s=[0]+[*map(int,list(input()))]\n    k=len(s)\n    for i in range(len(s)-1,0,-1):\n        if s[i]>4:s[i-1]+=1;k=i\n    if s[0]!=0:print(s[0],end='')\n    s=[*map(str,s)]\n    print(''.join(s[1:k]+['0']*(len(s)-k))) Rate the problem Good task \n\n    \n\n\n221\n\n\n\n Average task \n\n    \n\n\n82\n\n\n\n Bad task \n\n    \n\n\n524\n\n\n\n Didn't solve \n\n    \n\n\n45\n\n\n\n "
    },
    "1853B": {
        "title": "B. Fibonaccharsis",
        "description": "Ntarsis has received two integers n and k for his birthday. He wonders how many fibonacci-like sequences of length k can be formed with n as the k-th element of the sequence. \nA sequence of non-decreasing non-negative integers is considered fibonacci-like if fi=fi\u22121+fi\u22122 for all i>2, where fi denotes the i-th element in the sequence. Note that f1 and f2 can be arbitrary.\nFor example, sequences such as [4,5,9,14] and [0,1,1] are considered fibonacci-like sequences, while [0,0,0,1,1], [1,2,1,3], and [\u22121,\u22121,\u22122] are not: the first two do not always satisfy fi=fi\u22121+fi\u22122, the latter does not satisfy that the elements are non-negative.\nImpress Ntarsis by helping him with this task.\nThe first line contains an integer t (1\u2264t\u22642\u22c5105), the number of test cases. The description of each test case is as follows.\nEach test case contains two integers, n and k (1\u2264n\u22642\u22c5105, 3\u2264k\u2264109).\nIt is guaranteed the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output an integer, the number of fibonacci-like sequences of length k such that the k-th element in the sequence is n. That is, output the number of sequences f of length k so f is a fibonacci-like sequence and fk=n. It can be shown this number is finite.\nThere are 4 valid fibonacci-like sequences for n=22, k=4:\nFor n=3, k=9, it can be shown that there are no fibonacci-like sequences satisfying the given conditions.\nFor n=55, k=11, [0,1,1,2,3,5,8,13,21,34,55] is the only fibonacci-like sequence.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1200"
        ],
        "solutions": "1853B - FibonaccharsisProblem Credits: ntarsis30, cryAnalysis: cry Hint 1Can a sequence involving n, which is up to 105, really have up to 109 terms?  SolutionThe terms of the fibonacci sequence will increase exponentially. This is quite intuitive, but mathematically, fibonnaci-like sequences will increase at a rate of phi to the power of n, where phi (the golden ratio) is about 1.618. Thus, the maximum number of terms a sequence can have before it reaches 109, or the maximum value of n, is pretty small (around logn). Instead of trying to fix the first two elements of the sequence and counting how many sequences s will have sk=n, note that we already have n fixed. If we loop over the k\u22121th element of the sequence, the sequence is still fixed. If we know the xth element and x\u22121th element of s, we can find that sx\u22122=sx\u2212sx\u22121. Thus, we can just go backwards and simulate for k iterations in O(logn) since k is small, breaking at any point if the current sequence is not fibonnaci-like (there are negative elements or it is not strictly increasing). Otherwise, we add 1 to our answer. The time complexity is O(n\u22c5logn). Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin >> T;\n    \n    while (T--) {\n \n        int n; int k;\n        cin >> n >> k;\n     \n        int ans = 0;\n     \n        for (int i = 1; i <= n; i++) {\n            int second = n; //xth element where x is k\n            int first = i; //fixing x-1th element where x is k-1\n            bool valid_seq = true;\n            for (int j = 0; j < k - 2; j++) {\n                //for s_x and s_x-1, s_x-2 = s_x - s_x-1\n                int fx = first;\n                first = second - fx;\n                second = fx;\n                valid_seq &= first <= second;\n                valid_seq &= min(first, second) >= 0;\n                if (!valid_seq) break; //break if the sequence is not fibonacci-like\n            }\n            if (valid_seq) ans++;\n        }\n \n        cout << ans << endl;\n    }\n \n}Bonus: Solve for n,k\u2264109 Bonus SolutionAnalysis by awesomeguy856f[k]=Fk\u22122f[0]+Fk\u22121f[1]By the Extended Euclidean Algorithm, we can find one integral solution for this equation, since gcd(Fk\u22122,Fk\u22121)=1|f[k]. Let this solution be (f[0],f[1])=(x,y). Then all other integral solutions are in the form (x+cFk\u22121,y\u2212cFk\u22122), for c\u2208Z so we can find all valid solutions by binary search on Unable to parse markup [type=CF_MATHJAX] and f[1]>f[0], or just by some calculations. "
    },
    "1851C": {
        "title": "C. Tiles Comeback",
        "description": "Vlad remembered that he had a series of n tiles and a number k. The tiles were numbered from left to right, and the i-th tile had colour ci.\nIf you stand on the first tile and start jumping any number of tiles right, you can get a path of length p. The length of the path is the number of tiles you stood on.\nVlad wants to see if it is possible to get a path of length p such that: \nFor example, let n=14, k=3.\nThe colours of the tiles are contained in the array c = [1,2,1,1,7,5,3,3,1,3,4,4,2,4]. Then we can construct a path of length 6 consisting of 2 blocks:\nc1\u2192c3\u2192c4\u2192c11\u2192c12\u2192c14\nAll tiles from the 1-st block will have colour 1, from the 2-nd block will have colour 4.\nIt is also possible to construct a path of length 9 in this example, in which all tiles from the 1-st block will have colour 1, from the 2-nd block will have colour 3, and from the 3-rd block will have colour 4.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105)\u2014the number of tiles in the series and the length of the block.\nThe second line of each test case contains n integers c1,c2,c3,\u2026,cn (1\u2264ci\u2264n) \u2014 the colours of the tiles.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output on a separate line: \nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as positive response).\nIn the first test case, you can jump from the first tile to the last tile;\nThe second test case is explained in the problem statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1851C - Tiles ComebackSince the path must start in the first tile and end in the last tile, it is enough to construct a path consisting of 1 or 2 blocks of length k to solve the problem.If c1=cn, then we need to check that there are k\u22122 tiles of colour c0 between the first and the last tile. If this condition is satisfied, then the tiles that are found together with the first and the last tile form the path p, and the answer is \u2014 YES. Otherwise \u2014 the answer is NO.If c1\u2260cn we can solve the problem by the method of two pointers: let's move from the two ends of the array c to the middle, counting the number of tiles of colour c1 on the left and tiles of colour cn on the right. If the pointers meet no later than k tiles of the desired colours are found on both sides, the answer is \u2014 YES, otherwise \u2014 NO. Solution#include \"bits/stdc++.h\"\nusing namespace std;\n\nbool solve(){\n    int n, k;\n    cin >> n >> k;\n    vector<int>c(n);\n    for(int i = 0; i < n; i++) cin >> c[i];\n    int left = 0, right = 0, i = 0, j = n - 1;\n    int k_left = k, k_right = k;\n\n    if (c[0] == c[n - 1]){\n        k_left = k / 2;\n        k_right = k - k_left;\n    }\n    for(; i < n && left < k_left; i++){\n        if(c[i] == c[0]) left++;\n    }\n    for(; j >= 0 && right < k_right; j--){\n        if(c[j] == c[n - 1]) right++;\n    }\n    return (i - 1) < (j + 1);\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        cout << (solve() ? \"YES\" : \"NO\") << \"\\n\";\n    }\n\n}"
    },
    "1850E": {
        "title": "E. Cardboard for Pictures",
        "description": "Mircea has n pictures. The i-th picture is a square with a side length of si centimeters. \nHe mounted each picture on a square piece of cardboard so that each picture has a border of w centimeters of cardboard on all sides. In total, he used c square centimeters of cardboard. Given the picture sizes and the value c, can you find the value of w?\nPlease note that the piece of cardboard goes behind each picture, not just the border.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two positive integers n (1\u2264n\u22642\u22c5105) and c (1\u2264c\u22641018)\u00a0\u2014 the number of paintings, and the amount of used square centimeters of cardboard.\nThe second line of each test case contains n space-separated integers si (1\u2264si\u2264104)\u00a0\u2014 the sizes of the paintings.\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nAdditional constraint on the input: Such an integer w exists for each test case.\nPlease note, that some of the input for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor each test case, output a single integer\u00a0\u2014 the value of w (w\u22651) which was used to use exactly c squared centimeters of cardboard.\nThe first test case is explained in the statement.\nFor the second test case, the chosen w was 2, thus the only cardboard covers an area of c=(2\u22c52+6)2=102=100 squared centimeters.\nFor the third test case, the chosen w was 4, which obtains the covered area c=(2\u22c54+2)2\u00d75=102\u00d75=100\u00d75=500 squared centimeters.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1850E - Cardboard for PicturesThe key idea is to binary search on the answer. If you don't know what that is, you should read this Codeforces EDU article. Let's make a function f(x), which tells us the total area of cardboard if we use a width of x. Then you can see that we can calculate f(x) in O(n) time as (a1+2x)2+(a2+2x)2+\u22ef+(an+2x)2, because the side length of the i-th cardboard is ai+2x.So this means that now we can binary search on the answer: let's find the largest w so that f(w)\u2264c. The maximum theoretical value of w can be seen not to exceed 109, since c is not more than 1018 (you can set an even lower bound).A quick note about implementation: the value of f(x) can exceed 64-bit numbers, so you need to exit the function as soon as you get a value greater than c, or else you risk overflow.So the time complexity is O(nlog(109)) per test case, which is equal to O(n) with some constant factor. It's not that big to make it fail.You can also use the quadratic formula, but be careful about implementation of square root and precision issues. Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \n#define int long long\n \nvoid solve() {\n    int n, c; cin >> n >> c;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) cin >> a[i];\n    int l = 1, r = 1e9;\n    while(l <= r) {\n        int mid = l + (r - l) / 2;\n        int sumall = 0;\n        for(int i = 0; i < n; ++i) {\n            sumall += (a[i] + 2 * mid) * (a[i] + 2 * mid);\n            if(sumall > c) break;\n        }\n        if(sumall == c) {\n            cout << mid << \"\\n\";\n            return;\n        }\n        if(sumall > c) {\n            r = mid - 1;\n        } else {\n            l = mid + 1;\n        }\n    }\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}\n\n"
    },
    "1849B": {
        "title": "B. Monsters",
        "description": "Monocarp is playing yet another computer game. And yet again, his character is killing some monsters. There are n monsters, numbered from 1 to n, and the i-th of them has ai health points initially.\nMonocarp's character has an ability that deals k damage to the monster with the highest current health. If there are several of them, the one with the smaller index is chosen. If a monster's health becomes less than or equal to 0 after Monocarp uses his ability, then it dies.\nMonocarp uses his ability until all monsters die. Your task is to determine the order in which monsters will die.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and k (1\u2264n\u22643\u22c5105; 1\u2264k\u2264109)\u00a0\u2014 the number of monsters and the damage which Monocarp's ability deals.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial health points of monsters.\nThe sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print n integers\u00a0\u2014 the indices of monsters in the order they die. \nIn the first example, the health points change as follows: [1,2,3_]\u2192[1,2_,1]\u2192[1_,0,1]\u2192[\u22121,0,1_]\u2192[\u22121,0,\u22121]. The monster that is going to take damage the next time Monocarp uses his ability is underlined.\nIn the second example, the health points change as follows: [1_,1]\u2192[\u22122,1_]\u2192[\u22122,\u22122].\nIn the third example, the health points change as follows: [2,8_,3,5]\u2192[2,5_,3,5]\u2192[2,2,3,5_]\u2192[2,2,3_,2]\u2192[2_,2,0,2]\u2192[\u22121,2_,0,2]\u2192[\u22121,\u22121,0,2_]\u2192[\u22121,\u22121,0,\u22121]. ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1849B - MonstersLet's simulate the game process until the number of health points of each monster becomes k or less. Then we can consider that the i-th monster has aimodk health instead of ai (except for the case when ai is divisible by k, then the remaining health is k, not 0).Now, the health points of all monsters are from 1 to k, so each time we damage a monster, we kill it. Therefore, monsters with k health points will die first, then the ones with k\u22121 health points, and so on. So, let's sort the monsters by their remaining health points in descending order (don't forget that, if two monsters have the same health, then they should be compared by index). And the order you get after sorting is the answer to the problem. Solution (Neon)#include <bits/stdc++.h>\n \nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (auto &x : a) {\n      cin >> x;\n      x %= k;\n      if (!x) x = k;\n    }\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    stable_sort(ord.begin(), ord.end(), [&](int i, int j) {\n      return a[i] > a[j];\n    });\n    for (auto &x : ord) cout << x + 1 << ' ';\n    cout << endl;\n  }\n}\n"
    },
    "1848B": {
        "title": "B. Vika and the Bridge",
        "description": "In the summer, Vika likes to visit her country house. There is everything for relaxation: comfortable swings, bicycles, and a river.\nThere is a wooden bridge over the river, consisting of n planks. It is quite old and unattractive, so Vika decided to paint it. And in the shed, they just found cans of paint of k colors.\nAfter painting each plank in one of k colors, Vika was about to go swinging to take a break from work. However, she realized that the house was on the other side of the river, and the paint had not yet completely dried, so she could not walk on the bridge yet.\nIn order not to spoil the appearance of the bridge, Vika decided that she would still walk on it, but only stepping on planks of the same color. Otherwise, a small layer of paint on her sole will spoil the plank of another color. Vika also has a little paint left, but it will only be enough to repaint one plank of the bridge.\nNow Vika is standing on the ground in front of the first plank. To walk across the bridge, she will choose some planks of the same color (after repainting), which have numbers 1\u2264i1<i2<\u2026<im\u2264n (planks are numbered from 1 from left to right). Then Vika will have to cross i1\u22121,i2\u2212i1\u22121,i3\u2212i2\u22121,\u2026,im\u2212im\u22121\u22121,n\u2212im planks as a result of each of m+1 steps.\nSince Vika is afraid of falling, she does not want to take too long steps. Help her and tell her the minimum possible maximum number of planks she will have to cross in one step, if she can repaint one (or zero) plank a different color while crossing the bridge.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105)\u00a0\u2014 the number of planks in the bridge and the number of different colors of paint.\nThe second line of each test case contains n integers c1,c2,c3,\u2026,cn (1\u2264ci\u2264k)\u00a0\u2014 the colors in which Vika painted the planks of the bridge.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum possible maximum number of planks that Vika will have to step over in one step.\nIn the first test case, Vika can repaint the plank in the middle in color 1 and walk across the bridge without stepping over any planks.\nIn the second test case, Vika can repaint the plank in the middle in color 2 and walk across the bridge, stepping over only one plank each time.\nIn the third test case, Vika can repaint the penultimate plank in color 2 and walk across the bridge, stepping only on planks with numbers 2 and 5. Then Vika will have to step over 1, 2 and 1 plank each time she steps, so the answer is 2.\nIn the fourth test case, Vika can simply walk across the bridge without repainting it, stepping over two planks each time, walking on planks of color 3.\nIn the fifth test case, Vika can simply walk across the bridge without repainting it, without stepping over any planks.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1848B - Vika and the BridgeIn a single linear pass through the array, let's calculate, for each color, the lengths of the two maximum steps between planks of that color. To do this, we will maintain when we last encountered that color.Now we need to consider that we can repaint one of the planks. Let's say we repaint a plank in color c. It is easy to notice that we should repaint the plank in the middle of the longest step between planks of color c. After all, if we don't repaint such a plank, we will still have to make that longest step.Therefore, the answer for a fixed color will be the maximum of two values: half the length of the longest step between planks of that color, and the length of the second largest step between planks of that color.Knowing the answer for each individual color, we can determine the answer to the problem. To do this, we just need to take the minimum of the answers for all colors. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> c(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> c[i];\n        }\n        vector<int> last(k, -1);\n        vector<int> max_step(k), max2_step(k);\n        for (int i = 0; i < n; ++i) {\n            int step = i - last[c[i] - 1];\n            if (step > max_step[c[i] - 1]) {\n                max2_step[c[i] - 1] = max_step[c[i] - 1];\n                max_step[c[i] - 1] = step;\n            } else if (step > max2_step[c[i] - 1]) {\n                max2_step[c[i] - 1] = step;\n            }\n            last[c[i] - 1] = i;\n        }\n        for (int i = 0; i < k; ++i) {\n            int step = n - last[i];\n            if (step > max_step[i]) {\n                max2_step[i] = max_step[i];\n                max_step[i] = step;\n            } else if (step > max2_step[i]) {\n                max2_step[i] = step;\n            }\n        }\n        int ans = 1e9;\n        for (int i = 0; i < k; ++i) {\n            ans = min(ans, max((max_step[i] + 1) / 2, max2_step[i]));\n        }\n        cout << ans - 1 << \"\\n\";\n    }\n    return 0;\n}"
    },
    "1847B": {
        "title": "B. Hamon Odyssey",
        "description": "Jonathan is fighting against DIO's Vampire minions. There are n of them with strengths a1,a2,\u2026,an. \nDenote (l,r) as the group consisting of the vampires with indices from l to r. Jonathan realizes that the strength of any such group is in its weakest link, that is, the bitwise AND. More formally, the strength level of the group (l,r) is defined as f(l,r)=al&al+1&al+2&\u2026&ar. Here, & denotes the bitwise AND operation. \nBecause Jonathan would like to defeat the vampire minions fast, he will divide the vampires into contiguous groups, such that each vampire is in exactly one group, and the sum of strengths of the groups is minimized. Among all ways to divide the vampires, he would like to find the way with the maximum number of groups.\nGiven the strengths of each of the n vampires, find the maximum number of groups among all possible ways to divide the vampires with the smallest sum of strengths.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of vampires.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the individual strength of each vampire.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum number of groups among all possible ways to divide the vampires with the smallest sum of strengths.\nIn the first test case, the optimal way is to take all the n vampires as a group. So, f(1,3)=1&2&3=0.\nIn the second test case, the optimal way is to make 2 groups, (2,3,1) and (5,2). So, f(1,3)+f(4,5)=(2&3&1)+(5&2)=0+0=0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "two pointers",
            "*1000"
        ],
        "solutions": "1847B - Hamon OdysseyThere are two cases in this problem. First, if f(1,n)>0, then maximum number of groups becomes 1. This is because there are some bits set in all the elements. Now, if we divide the array in more than one group, then these bits are taken more than once which will not give smallest AND. Second case is when f(1,n)=0. This means the smallest AND is 0. Now, we need to greedily divide the array into subarrays such that the AND of each subarray should be 0. We keep taking elements in the subarray until the AND becomes 0. When AND becomes 0, we take remaining elements in the next subarray. If the last subarray has AND more than 0, then we need to merge that subarray with the previous subarray.Time complexity - O(n). solution#include <iostream>\n#include <vector>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long \n#define pb(e) push_back(e)\n#define sv(a) sort(a.begin(),a.end())\n#define sa(a,n) sort(a,a+n)\n#define mp(a,b) make_pair(a,b)\n#define all(x) x.begin(),x.end()\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tint arr[n];\n\tfor(int i = 0; i < n; i++)cin >> arr[i];\n\tint cur = arr[0];\n\tint part = 1;\n\tfor(int i = 0; i < n; i++){\n\t\tcur &= arr[i];\n\t\tif(cur == 0){\n\t\t\tif(i == n-1)break;\n\t\t\tpart++;\n\t\t\tcur = arr[i + 1];\n\t\t}\n\t}\n\tif(cur != 0)part--;\n\tpart = max(part,1);\n\tcout << part << '\\n';\n}\n\nint main(){\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\n\tint t;cin >> t;while(t--)\n\tsolve();\n\treturn 0;\n}"
    },
    "1846D": {
        "title": "D. Rudolph and Christmas Tree",
        "description": "Rudolph drew a beautiful Christmas tree and decided to print the picture. However, the ink in the cartridge often runs out at the most inconvenient moment. Therefore, Rudolph wants to calculate in advance how much green ink he will need.\nThe tree is a vertical trunk with identical triangular branches at different heights. The thickness of the trunk is negligible.\nEach branch is an isosceles triangle with base d and height h, whose base is perpendicular to the trunk. The triangles are arranged upward at an angle, and the trunk passes exactly in the middle. The base of the i-th triangle is located at a height of yi.\nThe figure below shows an example of a tree with d=4,h=2 and three branches with bases at heights [1,4,5].\nHelp Rudolph calculate the total area of the tree branches.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,d,h (1\u2264n,d,h\u22642\u22c5105)\u00a0\u2014 the number of branches, the length of the base, and the height of the branches, respectively.\nThe second line of each test case contains n integers yi (1\u2264yi\u2264109,y1<y2<...<yn) \u2014 the heights of the bases of the branches.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single real number on a separate line \u2014 the total area of the tree branches. The answer will be considered correct if its absolute or relative error does not exceed 10\u22126.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "geometry",
            "math",
            "*1200"
        ],
        "solutions": "1846D - Rudolph and Christmas TreeLet's consider the triangles in ascending order of yi. Let the current triangle have index i. There are two cases:  The triangle does not intersect with the (i+1)-th triangle (yi+1\u2212yi\u2265h). In this case, we simply add the area of the triangle to the answer. The area will be d\u22c5h2. The triangle intersects with the (i+1)-th triangle (yi+1\u2212yi<h). We can add to the answer the area of the figure that does not belong to the intersection and move on to the next triangle. Note that this figure is a trapezoid with a lower base d and height h\u2032=yi+1\u2212yi. The upper base can be found based on the similarity of triangles. The heights of the triangles are in the ratio k=h\u2212h\u2032h. Then the upper base dtop=d\u22c5k. The area of the trapezoid is h\u2032\u22c5d+dtop2. Time complexity is O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.precision(10); cout.setf(ios::fixed);\n    int ttt;\n    cin >> ttt;\n    while (ttt--) {\n        int n, d, h;\n        cin >> n >> d >> h;\n        vector<int> y(n);\n        for(int i = 0; i < n; i++){\n            cin >> y[i];\n        }\n        long double ans = (long double)d * h / 2.0;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (y[i + 1] >= y[i] + h) ans += (long double)d * h / 2.0;\n            else{\n                long double d2 = (long double)d * (y[i] + h - y[i + 1]) / h;\n                long double nh = y[i + 1] - y[i];\n                ans += (d + d2) / 2.0 * nh;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n Rate the problem Didn't solve \n\n    \n\n\n17\n\n\n\n Good task \n\n    \n\n\n324\n\n\n\n Average task \n\n    \n\n\n48\n\n\n\n Bad task \n\n    \n\n\n94\n\n\n\n "
    },
    "1846C": {
        "title": "C. Rudolf and the Another Competition",
        "description": "Rudolf has registered for a programming competition that will follow the rules of ICPC. The rules imply that for each solved problem, a participant gets 1 point, and also incurs a penalty equal to the number of minutes passed from the beginning of the competition to the moment of solving the problem. In the final table, the participant with the most points is ranked higher, and in case of a tie in points, the participant with the lower penalty is ranked higher.\nIn total, n participants have registered for the competition. Rudolf is a participant with index 1. It is known that m problems will be proposed. And the competition will last h minutes.\nA powerful artificial intelligence has predicted the values ti,j, which represent the number of minutes it will take for the i-th participant to solve the j-th problem.\nRudolf realized that the order of solving problems will affect the final result. For example, if h=120, and the times to solve problems are [20,15,110], then if Rudolf solves the problems in the order:\nRudolf became interested in what place he will take in the competition if each participant solves problems in the optimal order based on the predictions of the artificial intelligence. It will be assumed that in case of a tie in points and penalty, Rudolf will take the best place.\nThe first line contains an integer t (1\u2264t\u2264103) \u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,m,h (1\u2264n\u22c5m\u22642\u22c5105,1\u2264h\u2264106) \u2014 the number of participants, the number of problems, and the duration of the competition, respectively.\nThen there are n lines, each containing m integers ti,j (1\u2264ti,j\u2264106) \u2014 the number of minutes it will take for the i-th participant to solve the j-th problem.\nThe sum of n\u22c5m over all test cases does not exceed 2\u22c5105.\nFor each test case, output an integer \u2014 Rudolf's place in the final table if all participants solve problems in the optimal order.\nIn the first example, Rudolf will get 2 points and 50 penalty minutes. The second participant will solve only one problem and get 1 point and 90 penalty minutes. And the third participant will solve all 3 problems and get 3 points and 240 penalty minutes. Thus, Rudolf will take the second place.\nIn the second example, both participants will get 1 point and 30 penalty minutes. In case of a tie in points, Rudolf gets the better position, so he will take the first place.\nIn the third example, Rudolf is the only participant, so he will take the first place.\nIn the fourth example, all participants can solve two problems with penalty of 25=8+(8+9), 24=7+(7+10) and 26=8+(8+10), respectively, thanks to the penalty, the second participant gets the first place, and Rudolf gets the second.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dp",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1846C - Rudolf and the Another CompetitionAuthor: vladmart Hint 1What is the optimal order of task solving? Hint 2t1 \u2264 t2 \u2264 t3 \u2264 ... \u2264 tm  TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int ttt;\n    cin >> ttt;\n    while(ttt--){\n        int n, m, h;\n        cin >> n >> m >> h;\n        pair<int, long long> rud;\n        int ans = 1;\n        for(int i = 0; i < n; i++){\n            vector<int> cur(m);\n            for(int j = 0; j < m; j++){\n                cin >> cur[j];\n            }\n            std::sort(cur.begin(), cur.end());\n            int task_cnt = 0;\n            long long penalty = 0, sum = 0;\n            for(int j = 0; j < m; j++){\n                if (sum + cur[j] > h) break;\n                sum += cur[j];\n                penalty += sum;\n                task_cnt++;\n            }\n            if (i){\n                if (make_pair(-task_cnt, penalty) < rud) ans++;\n            } else rud = {-task_cnt, penalty};\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n Rate the problem Didn't solve \n\n    \n\n\n33\n\n\n\n Good task \n\n    \n\n\n261\n\n\n\n Average task \n\n    \n\n\n97\n\n\n\n Bad task \n\n    \n\n\n131\n\n\n\n "
    },
    "1844B": {
        "title": "B. Permutations & Primes",
        "description": "You are given a positive integer n.\nIn this problem, the MEX of a collection of integers c1,c2,\u2026,ck is defined as the smallest positive integer x which does not occur in the collection c. \nThe primality of an array a1,\u2026,an is defined as the number of pairs (l,r) such that 1\u2264l\u2264r\u2264n and MEX(al,\u2026,ar) is a prime number. \nFind any permutation of 1,2,\u2026,n with the maximum possible primality among all permutations of 1,2,\u2026,n. \nNote: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers: a permutation of 1,2,\u2026,n that achieves the maximum possible primality.\nIf there are multiple solutions, print any of them.\nIn the first test case, there are 3 pairs (l,r) with 1\u2264l\u2264r\u22642, out of which 2 have a prime MEX(al,\u2026,ar): \nIn the second test case, MEX(1)=2 is prime, so the primality is 1.\nIn the third test case, the maximum possible primality is 8.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solutions": "1844B - Permutations & PrimesThe cases n\u22642 can be handled separately. For n\u22653, any construction with a1=2,a\u230a(n+1)/2\u230b=1,an=3 is optimal. We can prove this as follows: Note that since 2 and 3 are both prime, any (l,r) with l\u2264\u230an+12\u230b\u2264r has a prime MEX(al,\u2026,ar) except for possibly (l,r)=(1,n), where MEX(a1,\u2026,an)=n+1. Therefore the primality of this array is \u230an+12\u230b\u22c5\u2308n+12\u2309\u2212[n+1\u00a0is not prime], where [P]=1 if proposition P is true and 0 if P is false. On the other hand, for any permutation of 1,\u2026,n, let k be the index with ak=1. The primality of this array cannot exceed k(n+1\u2212k)\u2212[n+1\u00a0is not prime], since any pair (l,r) with prime MEX(al,\u2026,ar)\u22652 must satisfy l\u2264k\u2264r, and additionally MEX(a1,\u2026,an)=n+1 no matter what the permutation is. The function f(k)=k(n+1\u2212k) is a quadratic which is maximized at k=\u230an+12\u230b, so k(n+1\u2212k)\u2212[n+1\u00a0is not prime]\u2264\u230an+12\u230b\u22c5\u2308n+12\u2309\u2212[n+1\u00a0is not prime] as required.The time complexity is O(n) (note that we don't even need to sieve for primes!). Implementation#include <bits/stdc++.h>\nusing namespace std;\n\nint a[200000];\nint main() {\n    int i;\n    int t,n;\n    scanf(\"%d\",&t);\n    while (t--) {\n        scanf(\"%d\",&n);\n        if (n == 1) printf(\"1\\n\");\n        else if (n == 2) printf(\"1 2\\n\");\n        else {\n            int c = 4;\n            fill(a,a+n,0);\n            a[0] = 2,a[n/2] = 1,a[n-1] = 3;\n            for (i = 0; i < n; i++) {\n                if (a[i] == 0) a[i] = c++;\n            }\n            for (i = 0; i < n; i++) printf(\"%d%c\",a[i],(i == n-1) ? '\\n':' ');\n        }\n    }\n    return 0;\n}"
    },
    "1843D": {
        "title": "D. Apple Tree",
        "description": "Timofey has an apple tree growing in his garden; it is a rooted tree of nn vertices with the root in vertex 11 (the vertices are numbered from 11 to nn). A tree is a connected graph without loops and multiple edges.\nThis tree is very unusual\u00a0\u2014 it grows with its root upwards. However, it's quite normal for programmer's trees.\nThe apple tree is quite young, so only two apples will grow on it. Apples will grow in certain vertices (these vertices may be the same). After the apples grow, Timofey starts shaking the apple tree until the apples fall. Each time Timofey shakes the apple tree, the following happens to each of the apples:\nLet the apple now be at vertex uu.\nIt can be shown that after a finite time, both apples will fall from the tree.\nTimofey has qq assumptions in which vertices apples can grow. He assumes that apples can grow in vertices xx and yy, and wants to know the number of pairs of vertices (aa, bb) from which apples can fall from the tree, where aa\u00a0\u2014 the vertex from which an apple from vertex xx will fall, bb\u00a0\u2014 the vertex from which an apple from vertex yy will fall. Help him do this.\nThe first line contains integer tt (1\u2264t\u22641041\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains integer nn (2\u2264n\u22642\u22c51052\u2264n\u22642\u22c5105)\u00a0\u2014 the number of vertices in the tree.\nThen there are n\u22121n\u22121 lines describing the tree. In line ii there are two integers uiui and vivi (1\u2264ui,vi\u2264n1\u2264ui,vi\u2264n, ui\u2260viui\u2260vi)\u00a0\u2014 edge in tree.\nThe next line contains a single integer qq (1\u2264q\u22642\u22c51051\u2264q\u22642\u22c5105)\u00a0\u2014 the number of Timofey's assumptions.\nEach of the next qq lines contains two integers xixi and yiyi (1\u2264xi,yi\u2264n1\u2264xi,yi\u2264n)\u00a0\u2014 the supposed vertices on which the apples will grow for the assumption ii.\nIt is guaranteed that the sum of nn does not exceed 2\u22c51052\u22c5105. Similarly, It is guaranteed that the sum of qq does not exceed 2\u22c51052\u22c5105.\nFor each Timofey's assumption output the number of ordered pairs of vertices from which apples can fall from the tree if the assumption is true on a separate line.\nIn the first example: \nFor the second example, there are 44 of possible pairs of vertices from which apples can fall: (2,3),(2,2),(3,2),(3,3)(2,3),(2,2),(3,2),(3,3). For the second assumption, there is only one possible pair: (2,3)(2,3). For the third assumption, there are two pairs: (3,2),(3,3)(3,2),(3,3).",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "dp",
            "math",
            "trees",
            "*1200"
        ],
        "solutions": "1843D - Apple TreeLet cntv be the number of vertices from which an apple can fall if it is in the vertex v. Then the answer to the query is cntv\u22c5cntu.Note that the value of cntv is equal to the number of leaves in the subtree of vertex v. Then, these values can be computed using the DFS or BFS. The value cnt for a vertex will be equal to 1 if this vertex is a leaf, otherwise it will be equal to the sum of these values for all children of the vertex.Total complexity: O(n+q). Solution#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nvector<vector<int>> g;\nvector<ll> cnt;\n \nvoid dfs(int v, int p) {\n    if (g[v].size() == 1 && g[v][0] == p) {\n        cnt[v] = 1;\n    } else {\n        for (auto u : g[v]) {\n            if (u != p) {\n                dfs(u, v);\n                cnt[v] += cnt[u];\n            }\n        }\n    }\n}\n \nvoid solve() {\n    int n, q;\n    cin >> n;\n \n    g.assign(n, vector<int>());\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n \n    cnt.assign(n, 0);\n    dfs(0, -1);\n \n    cin >> q;\n    for (int i = 0; i < q; i++) {\n        int c, k;\n        cin >> c >> k;\n        c--; k--;\n \n        ll res = cnt[c] * cnt[k];\n        cout << res << '\\n';\n    }\n}\n \nsigned main() {\n    int tests;\n    cin >> tests;\n    while (tests--) {\n        solve();\n    }\n \n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n66\n\n\n\n Good task \n\n    \n\n\n410\n\n\n\n Average task \n\n    \n\n\n53\n\n\n\n Bad task \n\n    \n\n\n40\n\n\n\n "
    },
    "1842B": {
        "title": "B. Tenzing and Books",
        "description": "Tenzing received 3n books from his fans. The books are arranged in 3 stacks with n books in each stack. Each book has a non-negative integer difficulty rating.\nTenzing wants to read some (possibly zero) books. At first, his knowledge is 0.\nTo read the books, Tenzing will choose a non-empty stack, read the book on the top of the stack, and then discard the book. If Tenzing's knowledge is currently u, then his knowledge will become u|v after reading a book with difficulty rating v. Here | denotes the bitwise OR operation. Note that Tenzing can stop reading books whenever he wants.\nTenzing's favourite number is x. Can you help Tenzing check if it is possible for his knowledge to become x?\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264n\u2264105, 0\u2264x\u2264109)\u00a0\u2014 the number of books in each stack and Tenzing's favourite number.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u00a0\u2014 the difficulty rating of the books in the first stack, from top to bottom.\nThe third line of each test case contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264109) \u00a0\u2014 the difficulty rating of the books in the second stack, from top to bottom.\nThe fourth line of each test case contains n integers c1,c2,\u2026,cn (0\u2264ci\u2264109) \u00a0\u2014 the difficulty rating of the books in the third stack, from top to bottom.\nIt is guaranteed that the sum of n does not exceed 105.\nFor each test case, output \"Yes\" (without quotes) if Tenzing can make his knowledge equal to x, and \"No\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nFor the first test case, Tenzing can read the following 4 books: \nAfter reading all books, Tenzing's knowledge is 7.\nFor the third test case, Tenzing can read 0 books to make his final knowledge equals to 0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1842B - Tenzing and Books TutorialObserve the bitwise OR: if a bit of the knowledge changes to 1, it will never become 0.It tells us, if a book has difficulty rating y, and x|y\u2260x, Tenzing will never read this book because it will change a 0 bit in x to 1.We called a number y valid if x|y=x. For each sequence, we can find a longest prefix of it such that all numbers in this prefix are valid. Find the bitwise OR of the three prefix and check whether it equals to x.Time complexity: O(n) per test case. Alternative SolutionA naive approach is to enumerate the prefixes of the three stacks, which is an enumeration of n3. For each stack, the bitwise OR of the prefix has at most 31 different values (including empty prefix), because the bitwise OR of the prefix is non-decreasing, and each change will increase the number of 1s in binary. Since the number of 1s in binary cannot exceed 30, it can be changed at most 30 times. Therefore, the enumeration is reduced to min(n,31)3. In the worst case, the time complexity is O(\u2211n\u2217312). Code#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, x, a[100000];\n        cin >> n >> x;\n        int s = 0;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < n; j++) cin >> a[j];\n            for (int j = 0; j < n; j++) {\n                if ((x | a[j]) != x) break;\n                s |= a[j];\n            }\n        }\n        if (s == x) cout << \"YES\\n\";\n        else cout << \"NO\\n\";\n    }\n} Alternative Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, x, ai;\n        cin >> n >> x;\n        vector<int> pre[3];\n        for (int i = 0; i < 3; i++) {\n            int s = 0;\n            pre[i].push_back(s);\n            for (int j = 0; j < n; j++) {\n                cin >> ai;\n                if ((s | ai) != s)\n                    s |= ai, pre[i].push_back(s);\n            }\n        }\n        bool ans = 0;\n        for (int A : pre[0]) for (int B : pre[1]) for (int C : pre[2])\n            ans |= (A | B | C) == x;\n        cout << (ans ? \"YES\\n\" : \"NO\\n\");\n    }\n}"
    },
    "1841B": {
        "title": "B. Keep it Beautiful",
        "description": "The array [a1,a2,\u2026,ak] is called beautiful if it is possible to remove several (maybe zero) elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non-descending order.\nIn other words, the array [a1,a2,\u2026,ak] is beautiful if there exists an integer i\u2208[0,k\u22121] such that the array [ai+1,ai+2,\u2026,ak\u22121,ak,a1,a2,\u2026,ai] is sorted in non-descending order.\nFor example:\nNote that any array consisting of zero elements or one element is beautiful.\nYou are given an array a, which is initially empty. You have to process q queries to it. During the i-th query, you will be given one integer xi, and you have to do the following:\nAfter each query, report whether you appended the given integer xi, or not.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines. The first line contains one integer q (1\u2264q\u22642\u22c5105) \u2014 the number of queries. The second line contains q integers x1,x2,\u2026,xq (0\u2264xi\u2264109).\nAdditional constraint on the input: the sum of q over all test cases does not exceed 2\u22c5105).\nFor each test case, print one string consisting of exactly q characters. The i-th character of the string should be 1 if you appended the integer during the i-th query; otherwise, it should be 0.\nConsider the first test case of the example. Initially, the array is [].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1841B - Keep it BeautifulFirst, notice that the given operation is a cyclic shift of the array. So we can treat the array as cyclic, meaning element n is a neighbor of element 1.Let's try to rephrase the condition for the beautiful array. What does it mean for the array to be sorted? For all j from 1 to n\u22121, aj\u2264aj+1 should hold. If they do, then you can choose i=0 (leave the array as is).What if there are such j that aj>aj+1? If there is only one such j, then we might still be able to fix the array: choose i=j. However, that will make a pair an and a1 cyclically shift into the array. So an\u2264a1 should hold.If there are at least two such j or just one but an>a1, then we can show that it's impossible to make the array sorted. Since there are at least two pairs of neighboring elements that are not sorted, at least one of them will still be in the array after any cyclic shift.Thus, we can maintain the number of such j that aj>aj+1 and check if an>a1 every time if the count is exactly 1.Overall complexity: O(q) per testcase. Solution (awoo)for _ in range(int(input())):\n\tq = int(input())\n\ta = []\n\tcnt = 0\n\tfor x in map(int, input().split()):\n\t\tnw_cnt = cnt + (len(a) > 0 and a[-1] > x)\n\t\tif nw_cnt == 0 or (nw_cnt == 1 and x <= a[0]):\n\t\t\ta.append(x)\n\t\t\tcnt = nw_cnt\n\t\t\tprint('1', end=\"\")\n\t\telse:\n\t\t\tprint('0', end=\"\")\n\tprint()"
    },
    "1840C": {
        "title": "C. Ski Resort",
        "description": "Dima Vatrushin is a math teacher at school. He was sent on vacation for n days for his good work. Dima has long dreamed of going to a ski resort, so he wants to allocate several consecutive days and go skiing. Since the vacation requires careful preparation, he will only go for at least k days.\nYou are given an array a containing the weather forecast at the resort. That is, on the i-th day, the temperature will be ai degrees.\nDima was born in Siberia, so he can go on vacation only if the temperature does not rise above q degrees throughout the vacation.\nUnfortunately, Dima was so absorbed in abstract algebra that he forgot how to count. He asks you to help him and count the number of ways to choose vacation dates at the resort.\nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n, k, q (1\u2264n\u22642\u22c5105, 1\u2264k\u2264n, \u2212109\u2264q\u2264109)\u00a0\u2014 the length of the array a, the minimum number of days at the resort, and the maximum comfortable temperature for Dima.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an (\u2212109\u2264ai\u2264109)\u00a0\u2014 the temperature at the ski resort.\nThe sum of all n values over all test cases does not exceed 2\u22c5105.\nOutput t integers, each of which is the answer to the corresponding test case\u00a0\u2014 the number of ways for Dima to choose vacation dates at the resort.\nIn the first test case of the example, Dima can go on any day, so the suitable dates for him are [1], [2], [3], [1, 2], [2, 3], [1, 2, 3].\nIn the second and fourth test cases of the example, Dima cannot go on any day due to the high temperature, so there are no suitable dates.\nIn the third test case of the example, Dima can only go on the dates [1, 2, 3].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "two pointers",
            "*1000"
        ],
        "solutions": "1840C - Ski ResortTo simplify the task, let's replace all numbers in the array a. If the value of ai is greater than q, then replace it with 0. Otherwise, replace it with 1.Now Dima can go on this day if ai=1. Therefore, we need to consider segments consisting only of 1.Note that if the segment consists of less than k ones, then Dima will not be able to go on these dates, so the segment can be ignored.For all remaining segments, we need to calculate the number of ways for Dima to choose travel dates on this segment. And for a segment of length l, the number of ways to choose a trip of at least length k is (l\u2212k+2l\u2212k).The answer to the problem will be the sum of the number of ways to choose travel dates for all segments. SolutiontestCases = int(input())\n \nfor testCase in range(testCases):\n    n, k, q = map(int, input().split(' '))\n    a = list(map(int, input().split(' ')))\n    \n    ans = 0\n    len = 0\n    for i in range(n):\n        if a[i] <= q:\n            len += 1\n        else:\n            if len >= k:\n                ans += (len - k + 1) * (len - k + 2) // 2\n            len = 0\n    \n    if len >= k:\n        ans += (len - k + 1) * (len - k + 2) // 2\n    print(ans) Rate the problem Didn't solve \n\n    \n\n\n76\n\n\n\n Good task \n\n    \n\n\n728\n\n\n\n Average task \n\n    \n\n\n117\n\n\n\n Bad task \n\n    \n\n\n43\n\n\n\n "
    },
    "1840B": {
        "title": "B. Binary Cafe",
        "description": "Once upon a time, Toma found himself in a binary cafe. It is a very popular and unusual place.\nThe cafe offers visitors k different delicious desserts. The desserts are numbered from 0 to k\u22121. The cost of the i-th dessert is 2i coins, because it is a binary cafe! Toma is willing to spend no more than n coins on tasting desserts. At the same time, he is not interested in buying any dessert more than once, because one is enough to evaluate the taste.\nIn how many different ways can he buy several desserts (possibly zero) for tasting?\nThe first line of the input contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThen follows t lines, each of which describes one test case.\nEach test case is given on a single line and consists of two integers n and k (1\u2264n,k\u2264109)\u00a0\u2014 the number of coins Toma is willing to spend and the number of desserts in the binary cafe.\nOutput t integers, the i-th of which should be equal to the answer for the i-th test case\u00a0\u2014 the number of ways to buy desserts for tasting.\nVariants for 1st sample: {}, {1}\nVariants for 2nd sample: {}, {1}\nVariants for 3rd sample: {}, {1}, {2}\nVariants for 4th sample: {}, {1}, {2}, {1, 2}",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "math",
            "*1100"
        ],
        "solutions": "1840B - Binary CafeIdea: diskoteka, preparation: diskoteka TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nint32_t main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n        k = min(k, 30);\n        cout << min(n, (1 << k) - 1) + 1 << \"\\n\";\n    }\n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n207\n\n\n\n Good task \n\n    \n\n\n524\n\n\n\n Average task \n\n    \n\n\n64\n\n\n\n Bad task \n\n    \n\n\n639\n\n\n\n "
    },
    "1839B": {
        "title": "B. Lamps",
        "description": "You have n lamps, numbered by integers from 1 to n. Each lamp i has two integer parameters ai and bi.\nAt each moment each lamp is in one of three states: it may be turned on, turned off, or broken.\nInitially all lamps are turned off. In one operation you can select one lamp that is turned off and turn it on (you can't turn on broken lamps). You receive bi points for turning lamp i on. The following happens after each performed operation: \nPlease note that broken lamps never count as turned on and that after a turned on lamp breaks, you still keep points received for turning it on.\nYou can perform an arbitrary number of operations.\nFind the maximum number of points you can get.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of lamps.\nEach of the next n lines contains two integers ai and bi (1\u2264ai\u2264n,1\u2264bi\u2264109)\u00a0\u2014 parameters of the i-th lamp.\nIt is guaranteed that sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the maximum number of points you can get.\nIn first test case n=4. One of ways to get the maximum number of points is as follows: \nYour receive 13+2=15 points in total. It can be shown that this is the maximum number of points you can get, so the answer for the first test case is 15.\nIn the second test case, one of the ways to get the maximum number of points is as follows:\nYou receive 2+5+4+3=14 points in total. It can be shown that this is the maximum number of points you can get.\nIn the third test case, one of the ways to get the maximum number of points is as follows:\nYou receive 4+4+3+4+5=20 points in total. It can be shown that this is the maximum number of points you can get.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1839B - LampsLet's denote number of lamps with ai=k as ck. If ck\u2265k and you turn k lamps with ai=k lamps on, all ck of them will break and you will not be able to receive points for the other ck\u2212k lamps. If we denote values bi for all i such that ai=k as dk,1,dk,2,\u2026,dk,ck (dk,1\u2265dk,2\u2265\u2026\u2265dk,ck), then you can't get more than sk=dk,1+dk,2+\u2026+dk,min(ck,k) points for lamps with ai=k.So, the total number of points is not bigger than s1+s2+\u2026+sn.This bound can always be achieved in the following way: while there is at least one lamp that is not turned on and not broken, turn on the one with minimum ai (if there are multiple lamps with minimum ai, choose the one with maximum bi).This works because if at least k lamps are turned on, then all lamps with ai<k are already broken."
    },
    "1838B": {
        "title": "B. Minimize Permutation Subarrays",
        "description": "You are given a permutation p of size n. You want to minimize the number of subarrays of p that are permutations. In order to do so, you must perform the following operation exactly once:\nFor example, if p=[5,1,4,2,3] and we choose i=2, j=3, the resulting array will be [5,4,1,2,3]. If instead we choose i=j=5, the resulting array will be [5,1,4,2,3].\nWhich choice of i and j will minimize the number of subarrays that are permutations?\nA permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nAn array a is a subarray of an array b if a can be obtained from b by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u22642\u22c5105)\u00a0\u2014 the size of the permutation.\nThe next line of each test case contains n integers p1,p2,\u2026pn (1\u2264pi\u2264n, all pi are distinct)\u00a0\u2014 the elements of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output two integers i and j (1\u2264i,j\u2264n) \u00a0\u2014 the indices to swap in p.\nIf there are multiple solutions, print any of them.\nFor the first test case, there are four possible arrays after the swap: \nFor the third sample case, after we swap elements at positions 2 and 5, the resulting array is [1,4,2,5,3]. The only subarrays that are permutations are [1] and [1,4,2,5,3]. We can show that this is minimal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1838B - Minimize Permutation SubarraysLet idxx be the position of the element x in p, and consider what happens if idxn is in between idx1 and idx2. Notice that any subarray of size greater than 1 that is a permutation must contain idx1 and idx2. So it must also contain every index in between, including idxn. Therefore, n is an element of the permutation subarray, so it must be of size at least n, and therefore must be the whole array. Therefore, if idxn is in between idx1 and idx2, the only subarrays that are permutations are [idx1,idx1] and [1,n]. These two subarrays will always be permutations, so this is minimal.To achieve this, we have 3 cases:  If idxn lies in between idx1 and idx2, swap idx1 and idx2.  If idxn<idx1,idx2, swap idxn with the smaller of idx1, idx2.  If idxn>idx1,idx2, swap idxn with the larger of idx1, idx2. In all three of these cases, after the swap, idxn will lie in between idx1 and idx2, minimizing the number of permutation subarrays.Complexity: O(n) Code#include <bits/stdc++.h>\nusing namespace std;\n#define N 200010\n\nint idx[N];\n\nint main() {\n\n    int t; cin >> t;\n    for(int tc = 1; tc <= t; ++tc) {\n\n        int n; cin >> n;\n\n        for(int i = 1; i <= n; ++i) {\n            int x; cin >> x;\n            idx[x] = i;\n        }\n\n        if(idx[n] < min(idx[1], idx[2])) {\n            cout << idx[n] << ' ' << min(idx[1], idx[2]) << '\\n';\n        } else if(idx[n] > max(idx[1], idx[2])) {\n            cout << idx[n] << ' ' << max(idx[1], idx[2]) << '\\n';\n        } else {\n            cout << idx[1] << ' ' << idx[2] << '\\n';\n        }\n    }\n}"
    },
    "1837C": {
        "title": "C. Best Binary String",
        "description": "You are given a string s consisting of the characters 0, 1 and/or ?. Let's call it a pattern.\nLet's say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. For example, 0010 matches ?01?, but 010 doesn't match 1??, ??, or ????.\nLet's define the cost of the binary string as the minimum number of operations of the form \"reverse an arbitrary contiguous substring of the string\" required to sort the string in non-descending order.\nYou have to find a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u22643\u22c5104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains the string s (1\u2264|s|\u22643\u22c5105) consisting of characters 0, 1, and/or ?.\nThe sum of the string lengths over all test cases does not exceed 3\u22c5105.\nFor each test case, print a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.\nIn the first test case of the example, the cost of the resulting string is 0.\nIn the second test case, the cost of the resulting string is 2: we can reverse the substring from the 1-st character to the 5-th character, and we obtain the string 00101. Then we reverse the substring from the 3-rd to the 4-th character, and we obtain the string 00011, which is sorted in non-descending order.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1837C - Best Binary StringFirst of all, let's try solving an easier problem \u2014 suppose we have a binary string, how many operations of the form \"reverse a substring\" do we have to perform so that it is sorted? To solve this problem, we need to consider substrings of the form 10 in the string (i.\u2009e. situations when a zero immediately follows a one). Sorted binary strings should not contain any such substrings, so our goal is to reduce the number of such strings to zero.Let's try to analyze how can we reduce the number of substrings equal to 10 by reversing a substring. Suppose that we want to \"remove\" a particular substring 10 from the string without causing any new ones to appear. We can reverse the substring that consists of the block of ones and the block of zeroes adjacent to each other; that way, after reversing the substring, these two blocks will be swapped; the block of zeroes will either merge with the block of zeroes to the left, or move to the beginning of the string; the block of ones will either merge with the block of ones to the right, or move to the end of the string. For example, if, in the string 0011101, you reverse the substring from the 3-rd to the 6-th position, you get 0001111, and you reduce the number of substrings 10 by one.What if we want to reduce this number by more than one in just one operation? Unfortunately, this is impossible. Suppose we want to affect two substrings 10 with one reverse operation. There will be a substring 01 between them, so, after reversing, it will turn into 10, and we'll reduce the number of substrings 10 only by one. The same when we try to affect three, four or more substrings 10. So, we can reduce the number of substrings 10 only by one in one operation. So, the answer to the problem \"count the number of operations required to sort the binary string\" is just the number of substrings 10.Okay, back to the original problem. Now we want to replace every question mark so that the resulting string contains as few substrings 10 as possible. You can use dynamic programming of the form dpi,j \u2014 the minimum number of substrings if we considered i first characters of the string and the last of them was j. Or you can try the following greedy instead: go through the string from left to right, and whenever you encounter a question mark, replace it with the same character as the previous character in the string (if the string begins with a question mark, it should be replaced with 0). That way, you will create as few \"blocks\" of characters as possible, so the number of times when a block of 1's changes into a block of 0's will be as small as possible. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    char x = '0';\n    for (auto& c : s) {\n      if (c == '?') c = x;\n      x = c;\n    }\n    cout << s << '\\n';\n  }\n}"
    },
    "1836B": {
        "title": "B. Astrophysicists",
        "description": "In many, many years, far, far away, there will be a launch of the first flight to Mars. To celebrate the success, n astrophysicists working on the project will be given bonuses of a total value of k gold coins.\nYou have to distribute the money among the astrophysicists, and to make it easier, you have to assign bonuses in silver coins. Each gold coin is worth g silver coins, so you have to distribute all k\u22c5g silver coins among n people.\nUnfortunately, the company has some financial troubles right now. Therefore, instead of paying the number of silver coins written on the bonus, they decided to round this amount to the nearest integer number of gold coins.\nThe rounding procedure is as follows. If an astrophysicist has bonus equal to x silver coins, and we denote r=xmodg, then: \nYou aim to distribute the bonuses so that the company saves as many silver coins due to rounding as possible. Please note that there is always a distribution in which the company spends no more than k\u22c5g silver coins.\nIn the first line of input, there is one integer t (1\u2264t\u2264104) denoting the number of test cases.\nEach of the following t lines describes one test case and contains three integers n, k, g (1\u2264n\u2264109, 0\u2264k\u2264109, 2\u2264g\u2264109) \u2014 respectively the number of astrophysicists in the company, total number of gold coins to assign and the number of silver coins that one gold coin corresponds to.\nIn a separate line for each test case, output a single integer \u2014 the maximum number of silver coins that could be saved due to rounding.\nIn the first test case, one of the optimal assignments could be the following:\nIn the second test case, we could have the following assignment: \nIf the bonuses are assigned to 7 silver coins for both astrophysicists, then the company would have to pay an additional gold coin to cover the bonuses.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1836B - AstrophysicistsNote that in the perfect world, we'd give each astrophysicist precisely \u230aG\u221212\u230b, and we'd spare N\u22c5\u230aG\u221212\u230b silver coins. Unfortunately, two things may happen:   First, we may run out of money. This is an easy case; it is enough to output K\u22c5G if it is less than \u230aG\u221212\u230b.  Second, we may have some money left. It turns out that an acceptable solution is to give everything to one astrophysicist. The intuition behind it is simple \u2014 we are only interested in bonus sizes modulo G, and by decreasing the bonus of one astrophysicist, we can get at most 1 from another one, and by increasing it, we lose \u230aG\u221212\u230b. In both cases, it is not worth changing the value.Thus, we got a formula to calculate in O(1). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \nint main()\n{\n\tint t;\n\tscanf (\"%d\", &t);\n\twhile (t--) {\n\t\tlong long n, k, g;\n\t\tscanf (\"%lld %lld %lld\", &n, &k, &g);\n \n\t\tlong long stolen = min((g - 1) / 2 * n, k * g);\n\t\tlong long rest = (k * g - stolen) % g;\n \n\t\tif (rest > 0) {\n\t\t    stolen -= (g - 1) / 2;\n\t\t    long long last = ((g - 1) / 2 + rest) % g;\n \n\t\t    if (last * 2 < g) {\n\t\t        stolen += last;\n\t\t    } else {\n\t\t        stolen -= g - last;\n\t\t    }\n\t\t}\n \n\t\tprintf (\"%lld\\n\", stolen);\n\t}\n}"
    },
    "1834C": {
        "title": "C. Game with Reversing",
        "description": "Alice and Bob are playing a game. They have two strings S and T of the same length n consisting of lowercase latin letters. Players take turns alternately, with Alice going first.\nOn her turn, Alice chooses an integer i from 1 to n, one of the strings S or T, and any lowercase latin letter c, and replaces the i-th symbol in the chosen string with the character c.\nOn his turn, Bob chooses one of the strings S or T, and reverses it. More formally, Bob makes the replacement S:=rev(S) or T:=rev(T), where rev(P)=PnPn\u22121\u2026P1.\nThe game lasts until the strings S and T are equal. As soon as the strings become equal, the game ends instantly.\nDefine the duration of the game as the total number of moves made by both players during the game. For example, if Alice made 2 moves in total, and Bob made 1 move, then the duration of this game is 3.\nAlice's goal is to minimize the duration of the game, and Bob's goal is to maximize the duration of the game.\nWhat will be the duration of the game, if both players play optimally? It can be shown that the game will end in a finite number of turns.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the strings S and T.\nThe second line of each test case contains a string S of length n consisting of lowercase latin letters.\nThe third line of each test case contains a string T of length n consisting of lowercase latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single number on a separate line\u00a0\u2014 the duration of the described game, if both players play optimally.\nIn the first test case, in her turn, Alice can replace the third symbol of the string S with x. After that, both strings will become equal to \"abxde\" and the game will end after one move. Since Alice's goal is to finish the game in as few moves as possible, this move will be one of her optimal first moves, and the final answer will be 1.\nIn the second test case, in her turn, Alice can replace the fifth symbol of the string T with h. After this move, S= \"hello\", T= \"olleh\". Then Bob makes his turn. In his turn, he must reverse one of the strings. If Bob chooses the string S, then after his turn both strings will be equal to \"olleh\", and if he chooses the string T, then after his turn both strings will be equal to \"hello\". Thus, after the presented first move of Alice, the game will definitely end in 2 moves. It can be shown that there is no strategy for Alice to finish the game in less than 2 moves, with both players playing optimally. The final answer is 2.\nIn the third test case, in her first move, Alice can replace the second symbol of the string S with c. After this move, S= \"ac\", T= \"cd\". Then Bob makes his turn. If Bob reverses the string S, then after his turn S= \"ca\", T= \"cd\". Then it is easy to see that in this case Alice can definitely finish the game on the 3-rd move, by replacing the second symbol of the string T with a, after which both strings will become equal to \"ca\". If Bob reverses the string T, then after his turn S= \"ac\", T= \"dc\". In this case, Alice can also definitely finish the game on the 3rd move, by replacing the first symbol of the string S with d, after which both strings will become equal to \"dc\". Thus, Alice can definitely finish the game in 3 moves regardless of Bob's moves. It can be shown that the game cannot end in less than 3 moves, with both players playing optimally.\nIn the fifth test case, the strings S and T are equal, so the game will end without starting, in 0 moves.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solutions": "1834C - Game with ReversingLet's show that the specific choice of a turn by Bob (which of the strings to reverse) does not affect Alice's strategy and therefore the answer to the problem.Reversing the string twice does not change anything \u2192 we are only interested in the parity of the number of reverses for both strings.If Bob made an even number of moves in total, then the parity of the number of moves made by Bob with string s coincides with the parity of the number of moves made by Bob with string t\u2192 pairs of characters at the same indices, after all reverses, will be (s1,t1),(s2,t2),\u2026,(sn,tn), possibly in reverse order, but it doesn't matter. Here s1,\u2026,sn and t1,\u2026,tn are the original indices of the strings, which do not change with reversing.If Bob made an odd number of moves, then exactly one of the strings will be reversed, and the pairs of characters in the same indices will be: (s1,tn),(s2,tn\u22121),\u2026,(sn,t1) (or in reverse order).That is, the specific pairs of corresponding characters are determined only by the parity of the total number of moves made by Bob, and it does not matter which specific moves were made.Therefore, Alice can choose one of two strategies: Make s1=t1,s2=t2,\u2026,sn=tn, and fix the end of the game when the number of moves made by Bob is even. Make s1=tn,s2=tn\u22121,\u2026,sn=t1, and fix the end of the game when the number of moves made by Bob is odd.Let's count cnt\u00a0\u2014 the number of indices where s and t differ, and cntrev\u00a0\u2014 the number of indices where s and rev(t) differ.For the first strategy, Alice must make at least cnt moves herself, and it is also necessary that the number of moves made by Bob is even \u2192 it is easy to see that for this strategy the game will last 2\u22c5cnt\u2212cnt%2 moves.For the second strategy, everything is roughly similar: the game will last 2\u22c5cntrev\u2212(1\u2212cntrev%2) moves, but the case cntrev=0 needs to be handled separately.And the answer to the problem will be the minimum of these two values. Asymptotic: O(n). "
    },
    "1834B": {
        "title": "B. Maximum Strength",
        "description": "Fedya is playing a new game called \"The Legend of Link\", in which one of the character's abilities is to combine two materials into one weapon. Each material has its own strength, which can be represented by a positive integer x. The strength of the resulting weapon is determined as the sum of the absolute differences of the digits in the decimal representation of the integers at each position.\nFormally, let the first material have strength X=\u00afx1x2\u2026xn, and the second material have strength Y=\u00afy1y2\u2026yn. Then the strength of the weapon is calculated as |x1\u2212y1|+|x2\u2212y2|+\u2026+|xn\u2212yn|. If the integers have different lengths, then the shorter integer is padded with leading zeros.\nFedya has an unlimited supply of materials with all possible strengths from L to R, inclusive. Help him find the maximum possible strength of the weapon he can obtain.\nAn integer C=\u00afc1c2\u2026ck is defined as an integer obtained by sequentially writing the digits c1,c2,\u2026,ck from left to right, i.e. 10k\u22121\u22c5c1+10k\u22122\u22c5c2+\u2026+ck.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains two integers L and R (1\u2264L\u2264R<10100)\u00a0\u2014 the decimal representation of the integers representing the minimum and maximum strength of the materials that Fedya has. It is guaranteed that the integers L and R do not contain leading zeros.\nNote that the input data may not fit into standard 32-bit or 64-bit integer data types.\nFor each test case print one integer\u00a0\u2014 the maximum possible strength of the weapon that Fedya can obtain from the given materials.\nIn the first test case, the weapon made from materials with strengths 53 and 57 will have the maximum possible strength: |5\u22125|+|3\u22127|=4.\nIn the second test case, the maximum strength is achieved with materials with strengths 190 and 209: |1\u22122|+|9\u22120|+|0\u22129|=19.\nIn the fourth test case, there is only one valid strength, so the answer is 0.\nIn the sixth test case, the maximum strength is achieved with materials with strengths 1909 and 90: |1\u22120|+|9\u22120|+|0\u22129|+|9\u22120|=28. Note that the shorter integer was padded with leading zeros.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1834B - Maximum Strength was authored by jury of the olympiad, and prepared by TheEvilBird"
    },
    "1832C": {
        "title": "C. Contrast Value",
        "description": "For an array of integers [a1,a2,\u2026,an], let's call the value |a1\u2212a2|+|a2\u2212a3|+\u22ef+|an\u22121\u2212an| the contrast of the array. Note that the contrast of an array of size 1 is equal to 0.\nYou are given an array of integers a. Your task is to build an array of b in such a way that all the following conditions are met:\nWhat is the minimum possible size of the array b?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105)\u00a0\u2014 the size of the array a.\nThe second line contains n integers a1,a2,\u22c5,an (0\u2264ai\u2264109)\u00a0\u2014 elements of the array itself.\nThe sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible size of the array b.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1832C - Contrast ValueLet's rephrase the problem in the following form: let the elements of the array be points on a coordinate line. Then the absolute difference between two adjacent elements of the array can be represented as the distance between two points, and the contrast of the entire array is equal to the total distance to visit all points in the given order.In this interpretation, it becomes obvious that removing any set of points does not increase contrast. Since the resulting contrast should be equal to the original one, we can only remove elements from the array that do not decrease the contrast.First of all, let's look at consecutive equal elements, it is obvious that you can delete all of them except one, and the contrast of the array will not change. In some languages, you can use a standard function to do this \u2014 for example, in C++ you can use unique.After that, let's look at such positions i that ai\u22121<ai<ai+1; you can delete the i-th element, because |ai\u22121\u2212ai|+|ai\u2212ai+1|=|ai\u22121\u2212ai+1|. Similarly, for positions i, where ai\u22121>ai>ai+1, the element can be removed. In all other cases, removing the element will decrease the contrast. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& x : a) cin >> x;\n    n = unique(a.begin(), a.end()) - a.begin();\n    int ans = n;\n    for (int i = 0; i + 2 < n; ++i) {\n      ans -= (a[i] < a[i + 1] && a[i + 1] < a[i + 2]);\n      ans -= (a[i] > a[i + 1] && a[i + 1] > a[i + 2]);\n    }\n    cout << ans << '\\n';\n  }\n}"
    },
    "1832B": {
        "title": "B. Maximum Sum",
        "description": "You are given an array a1,a2,\u2026,an, where all elements are different.\nYou have to perform exactly k operations with it. During each operation, you do exactly one of the following two actions (you choose which to do yourself):\nYou have to calculate the maximum possible sum of elements in the resulting array.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines: \nAdditional constraint on the input: the sum of n does not exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the maximum possible sum of elements in the resulting array.\nIn the first testcase, applying the first operation produces the following outcome: \n21 is the best answer.\nIn the second testcase, it's optimal to first erase two minimums, then a maximum.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1832B - Maximum SumIdea: BledDest TutorialTutorial is loading... Solution (awoo)for _ in range(int(input())):\n\tn, k = map(int, input().split())\n\ta = sorted(list(map(int, input().split())))\n\tans = 0\n\tpr = [0] * (n + 1)\n\tfor i in range(n):\n\t\tpr[i + 1] = pr[i] + a[i]\n\tfor i in range(k + 1):\n\t\tans = max(ans, pr[n - (k - i)] - pr[2 * i])\n\tprint(ans)"
    },
    "1831B": {
        "title": "B. Array merging",
        "description": "You are given two arrays a and b both of length n.\nYou will merge\u2020 these arrays forming another array c of length 2\u22c5n. You have to find the maximum length of a subarray consisting of equal values across all arrays c that could be obtained.\n\u2020 A merge of two arrays results in an array c composed by successively taking the first element of either array (as long as that array is nonempty) and removing it. After this step, the element is appended to the back of c. We repeat this operation as long as we can (i.e. at least one array is nonempty).\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a and b.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5n)\u00a0\u2014 the elements of array a.\nThe third line of each test case contains n integers b1,b2,\u2026,bn (1\u2264bi\u22642\u22c5n)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum length of a subarray consisting of equal values across all merges.\nIn the first test case, we can only make c=[2,2], thus the answer is 2.\nIn the second test case, since all values are distinct, the answer must be 1.\nIn the third test case, the arrays c we can make are [1,2,1,2], [1,2,2,1], [2,1,1,2], [2,1,2,1]. We can see that the answer is 2 when we choose c=[1,2,2,1]. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1831B \u2014 Array MergingAuthor: tibinyte2006 HintsHint 1When we merge two arrays a and b, we can force the resulting array to have [al1,al1+1,\u2026,ar1,bl2,bl2+1,\u2026,br1] as a subarray, for some 1\u2264l1\u2264r1\u2264n and 1\u2264l2\u2264r2\u2264n. Hint 2If al1=bl1, then we can achieve a contiguous sequence of (r1\u2212l1+1)+(r2\u2212l2+1) equal elements in the resulting array. SolutionLet maxa(x) be the length of the longest subarray from a containing only elements equal to x. If x doesn't appear in a, then maxa(x)=0.Similarly, let maxb(x) be the length of the longest subarray from b containing only elements equal to x. If x doesn't appear in b, then maxb(x)=0.maxa and maxb can be computed in O(N) by scanning the array while updating current maximal subarray.When merging two arrays, it is possible to force a particular subarray [al1,al1+1,\u2026,ar1] to be adjacent to another particular subarray [bl2,bl2+1,\u2026,br2] in the merged array. ProofWe can construct the merged array as follows:  [a1,a2,\u2026,al1\u22121]+[b1,b2,\u2026,bl2\u22121]+[al1,al1+1,\u2026,ar1,bl2,bl2+1,\u2026,br2]+[\u2026]If al1=bl2, then the merged array will have a subarray consisting of (r1\u2212l1+1)+(r2\u2212l2+1) equal elements.Therefore, the answer is equal to:  max2\u22c5ni=1(maxa(i)+maxb(i))Time complexity per testcase: O(N). Code (tibinyte, C++)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint32_t main()\n{\n    cin.tie(nullptr)->sync_with_stdio(false);\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int n;\n        cin >> n;\n        vector<int> a(n + 1);\n        vector<int> b(n + 1);\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> a[i];\n        }\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> b[i];\n        }\n        vector<int> fa(n + n + 1);\n        vector<int> fb(n + n + 1);\n        int p = 1;\n        for (int i = 2; i <= n; ++i)\n        {\n            if (a[i] != a[i - 1])\n            {\n                fa[a[i - 1]] = max(fa[a[i - 1]], i - p);\n                p = i;\n            }\n        }\n        fa[a[n]] = max(fa[a[n]], n - p + 1);\n\n        p = 1;\n        for (int i = 2; i <= n; ++i)\n        {\n            if (b[i] != b[i - 1])\n            {\n                fb[b[i - 1]] = max(fb[b[i - 1]], i - p);\n                p = i;\n            }\n        }\n        fb[b[n]] = max(fb[b[n]], n - p + 1);\n\n        int ans = 0;\n        for (int i = 1; i <= n + n; ++i)\n        {\n            ans = max(ans, fa[i] + fb[i]);\n        }\n\n        cout << ans << '\\n';\n    }\n}\n Rate problemGood problem \n\n    \n\n\n654\n\n\n\nOk problem \n\n    \n\n\n114\n\n\n\nBad problem \n\n    \n\n\n97\n\n\n\nDidn't solve it, idk \n\n    \n\n\n62\n\n\n\n"
    },
    "1829E": {
        "title": "E. The Lakes",
        "description": "You are given an n\u00d7m grid a of non-negative integers. The value ai,j represents the depth of water at the i-th row and j-th column. \nA lake is a set of cells such that:\nThe volume of a lake is the sum of depths of all the cells in the lake.\nFind the largest volume of a lake in the grid.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,m (1\u2264n,m\u22641000)\u00a0\u2014 the number of rows and columns of the grid, respectively.\nThen n lines follow each with m integers ai,j (0\u2264ai,j\u22641000)\u00a0\u2014 the depth of the water at each cell.\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 106.\nFor each test case, output a single integer\u00a0\u2014 the largest volume of a lake in the grid.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "dsu",
            "graphs",
            "implementation",
            "*1100"
        ],
        "solutions": "1829E - The LakesWe can approach this problem using Depth First Search (DFS) or Breadth First Search (BFS) on the given grid.The idea is to consider each cell of the grid as a potential starting point for a lake, and explore all the cells reachable from it by only moving up, down, left or right, without stepping on any cell with depth 0. If we reach a dead end, or a cell with depth 0, we backtrack and try another direction.During this exploration, we keep track of the sum of depths of all the cells that we have visited. This sum gives us the volume of the current lake. When we have explored all the reachable cells from a starting point, we compare the volume of this lake with the maximum volume found so far, and update the maximum if necessary.To implement this approach, we can use a nested loop to iterate through all the cells of the grid. For each cell, we check if its depth is greater than 0, and if it has not already been visited in a previous lake. If these conditions are satisfied, we start a DFS/BFS from this cell, and update the maximum volume found so far. See the implementation for more details.The time complexity is O(mn). Solution#include <bits/stdc++.h>\n#define startt ios_base::sync_with_stdio(false);cin.tie(0);\ntypedef long long  ll;\nusing namespace std;\n#define vint vector<int>\n#define all(v) v.begin(), v.end()\n#define MOD 1000000007\n#define MOD2 998244353\n#define MX 1000000000\n#define MXL 1000000000000000000\n#define PI (ld)2*acos(0.0)\n#define pb push_back\n#define sc second\n#define fr first\n#define endl '\\n'\n#define ld long double\n#define NO cout << \"NO\" << endl\n#define YES cout << \"YES\" << endl\n\nint n, m;\nbool vis[1005][1005];\nint a[1005][1005];\n\nint dfs(int i, int j)\n{\n    vis[i][j] = true;\n    int ans = a[i][j];\n    if(i != 0 && a[i-1][j] != 0 && !vis[i-1][j])\n    {\n        ans+=dfs(i-1, j);\n    }\n    if(i != n-1 && a[i+1][j] != 0 && !vis[i+1][j])\n    {\n        ans+=dfs(i+1, j);\n    }\n    if(j != 0 && a[i][j-1] != 0 && !vis[i][j-1])\n    {\n        ans+=dfs(i, j-1);\n    }\n    if(j != m-1 && a[i][j+1] != 0 && !vis[i][j+1])\n    {\n        ans+=dfs(i, j+1);\n    }\n    return ans;\n}\n\nvoid solve()\n{\n    cin >> n >> m;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            vis[i][j] = false;\n            cin >> a[i][j];\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(!vis[i][j] && a[i][j] != 0)\n            {\n                ans = max(ans, dfs(i, j));\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint32_t main(){\n    startt\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}"
    },
    "1829D": {
        "title": "D. Gold Rush",
        "description": "Initially you have a single pile with n gold nuggets. In an operation you can do the following: \nOne possible move is to take a pile of size 6 and split it into piles of sizes 2 and 4, which is valid since 4 is twice as large as 2. \nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n and m (1\u2264n,m\u2264107)\u00a0\u2014 the starting and target pile sizes, respectively.\nFor each test case, output \"YES\" if you can make a pile of size exactly m, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first test case is pictured in the statement. We can make a pile of size 4.\nIn the second test case, we can perform the following operations: {9}\u2192{6,3}\u2192{4,2,3}. The pile that is split apart is colored red before each operation.\nIn the third test case, we can't perform a single operation.\nIn the fourth test case, we can't end up with a larger pile than we started with.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "implementation",
            "*1000"
        ],
        "solutions": "1829D - Gold RushIdea: flamestorm TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool ok(int n, int m) {\n\tif (n == m) {return true;}\n\telse if (n % 3 != 0) {return false;}\n\telse {return (ok(n / 3, m) || ok(2 * n / 3, m));}\n}\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tcout << (ok(n, m) ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}"
    },
    "1827A": {
        "title": "A. Counting Orders",
        "description": "You are given two arrays a and b each consisting of n integers. All elements of a are pairwise distinct.\nFind the number of ways to reorder a such that ai>bi for all 1\u2264i\u2264n, modulo 109+7.\nTwo ways of reordering are considered different if the resulting arrays are different.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a and b.\nThe second line of each test case contains n distinct integers a1, a2, \u2026, an (1\u2264ai\u2264109)\u00a0\u2014 the array a. It is guaranteed that all elements of a are pairwise distinct.\nThe second line of each test case contains n integers b1, b2, \u2026, bn (1\u2264bi\u2264109)\u00a0\u2014 the array b.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the number of ways to reorder array a such that ai>bi for all 1\u2264i\u2264n, modulo 109+7.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1827A - Counting OrdersIdea: Mike4235  Preparation: thenymphsofdelphi Hint 1Sort the array b, and fix the values from an to a1. SolutionFirst, we can sort the array b, as it does not change the answer.Let's try to choose the values of a from an to a1. How many ways are there to choose the value of ai?The new ai must satisfies ai>bi. But some of the candidates are already chosen as aj for some j>i. However, since aj>bj\u2265bi, we know that there are exactly (n\u2212i) candidates already chosen previously by all values of j>i. So, there are (number of k such that ak>bi) \u2212(n\u2212i) ways to choose the value of ai.We can use two pointers or binary search to efficiently find the (number of k such that ak>bi) for all i.Time complexity: O(nlogn). Implementation#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\n\nstruct testcase{\n    testcase(){\n        int n; cin >> n;\n        vector<int> a(n);\n        for (int i=0; i<n; i++) cin >> a[i];\n        sort(a.begin(), a.end());\n        vector<int> b(n);\n        for (int i=0; i<n; i++) cin >> b[i];\n        sort(b.begin(), b.end(), greater<>());\n        ll result = 1;\n        for (int i=0; i<n; i++){\n            int geq_count = a.size() - (upper_bound(a.begin(), a.end(), b[i]) - a.begin());\n            result = result * max(geq_count - i, 0) % MOD;\n        }\n        cout << result << \"\\n\";\n    }\n};\n\nsigned main(){\n    cin.tie(0)->sync_with_stdio(0);\n    int t; cin >> t;\n    while (t--) testcase();\n}"
    },
    "1826B": {
        "title": "B. Lunatic Never Content",
        "description": "You have an array aa of nn non-negative integers. Let's define f(a,x)=[a1modx,a2modx,\u2026,anmodx]f(a,x)=[a1modx,a2modx,\u2026,anmodx] for some positive integer xx. Find the biggest xx, such that f(a,x)f(a,x) is a palindrome.\nHere, amodxamodx is the remainder of the integer division of aa by xx.\nAn array is a palindrome if it reads the same backward as forward. More formally, an array aa of length nn is a palindrome if for every ii (1\u2264i\u2264n1\u2264i\u2264n) ai=an\u2212i+1ai=an\u2212i+1.\nThe first line contains a single integer tt (1\u2264t\u22641051\u2264t\u2264105) \u2014 the number of test cases.\nThe first line of each test case contains a single integer nn (1\u2264n\u22641051\u2264n\u2264105).\nThe second line of each test case contains nn integers aiai (0\u2264ai\u22641090\u2264ai\u2264109).\nIt's guaranteed that the sum of all nn does not exceed 105105.\nFor each test case output the biggest xx, such that f(a,x)f(a,x) is a palindrome. If xx can be infinitely large, output 00 instead.\nIn the first example, f(a,x=1)=[0,0]f(a,x=1)=[0,0] which is a palindrome.\nIn the second example, f(a,x=2)=[1,0,1,0,0,1,0,1]f(a,x=2)=[1,0,1,0,0,1,0,1] which is a palindrome.\nIt can be proven that in the first two examples, no larger xx satisfies the condition.\nIn the third example, f(a,x)=[0]f(a,x)=[0] for any xx, so we can choose it infinitely large, so the answer is 00.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1826B - Lunatic Never ContentFor the sequence to be a palindrome, it has to satisfy bi=bn\u2212i+1. In our case bi=ai(modx). We can rewrite the palindrome equation as ai(modx)=an\u2212i+1(modx). Moving all the terms to the left we get ai\u2212an\u2212i+1\u22610(modx), which basically says x divides ai\u2212an\u2212i+1.Now, how to find the biggest x, which satisfies all such conditions? Greatest common divisor of course! We just need to calculate the GCD of the numbers ai\u2212an\u2212i+1 for all i.This results in a O(n+log(109)) solution, since computing the gcd of n numbers up to 109 takes exactly this much time.A useful assumption here is that GCD(x,0)=x for any number x. This holds true for standard template library implementations. And do not forget that this function should work correctly for negative numbers too. An easy trick here is to just use the absolute value of ai\u2212an\u2212i+1.\u0421++ Implementation: 204718497"
    },
    "1826A": {
        "title": "A. Trust Nobody",
        "description": "There is a group of n people. Some of them might be liars, who always tell lies. Other people always tell the truth. The i-th person says \"There are at least li liars amongst us\". Determine if what people are saying is contradictory, or if it is possible. If it is possible, output the number of liars in the group. If there are multiple possible answers, output any one of them.\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100).\nThe second line of each test case contains n integers li (0\u2264li\u2264n) \u2014 the number said by the i-th person.\nIt's guaranteed that the sum of all n does not exceed 104.\nFor each test case output a single integer. If what people are saying is contradictory, output \u22121. Otherwise, output the number of liars in the group. If there are multiple possible answers, output any one of them.\nIn the first example, the only possible answer is that the second person is a liar, so the answer is 1 liar.\nIn the second example, it can be proven that we can't choose the liars so that all the requirements are satisfied.\nIn the third example, everybody tells the truth, so the answer is 0 liars.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1826A - Trust Nobody Hint1Check each number of liars independently. Hint2How to check, whether there are exactly x liars? SolutionTutorial is loading...\u0421++ Implementation: 204718333"
    },
    "1825B": {
        "title": "B. LuoTianyi and the Table",
        "description": "LuoTianyi gave an array b of n\u22c5m integers. She asks you to construct a table a of size n\u00d7m, filled with these n\u22c5m numbers, and each element of the array must be used exactly once. Also she asked you to maximize the following value:\nThis means that we consider n\u22c5m subtables with the upper left corner in (1,1) and the bottom right corner in (i,j) (1\u2264i\u2264n, 1\u2264j\u2264m), for each such subtable calculate the difference of the maximum and minimum elements in it, then sum up all these differences. You should maximize the resulting sum.\nHelp her find the maximal possible value, you don't need to reconstruct the table itself.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264200) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and m (2\u2264n,m\u2264100) \u2014 the number of rows and columns of the table.\nThe second line of each test case contains n\u22c5m integers b1,b2,\u2026,bn\u22c5m (\u2212105\u2264bi\u2264105) \u2014 the numbers you can put in the table.\nNote, that integers in the array b can be negative.\nIt is guaranteed that the sum of n\u22c5m over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the maximal value, that can be obtained.\nIn the first test case, the table is follows:\n\n\nIn the subtable with the bottom right corner in (1,1), the difference of the maximal and minimal elements is 4\u22124=0.\nIn the subtable with the bottom right corner in (1,2), the difference of the maximal and minimal elements is 4\u22121=3.\nIn the subtable with the bottom right corner in (2,1), the difference of the maximal and minimal elements is 4\u22121=3.\nIn the subtable with the bottom right corner in (2,2), the difference of the maximal and minimal elements is 4\u22121=3.\nThen the maximum possible value is 0+3+3+3=9.\nIn the second test case, all elements are equal, so all differences are 0, and the answer is 0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1822D": {
        "title": "D. Super-Permutation",
        "description": "A permutation is a sequence n integers, where each integer from 1 to n appears exactly once. For example, [1], [3,5,2,1,4], [1,3,2] are permutations, while [2,3,2], [4,3,1], [0] are not.\nGiven a permutation a, we construct an array b, where bi=(a1+a2+\u00a0\u2026\u00a0+ai)modn.\nA permutation of numbers [a1,a2,\u2026,an] is called a super-permutation if [b1+1,b2+1,\u2026,bn+1] is also a permutation of length n.\nGrisha became interested whether a super-permutation of length n exists. Help him solve this non-trivial problem. Output any super-permutation of length n, if it exists. Otherwise, output \u22121.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nEach test case consists of a single line containing one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the desired permutation.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output in a separate line:\nIf there are several suitable permutations, output any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1822D - Super-PermutationLet k be the position of the number n in the permutation a, that is, ak=n, then if k>1, then bk=(bk\u22121+ak)modn=bk\u22121 therefore, b is not a permutation, so k=1. Now note that if n>1 is odd, then bn=(a1\u00a0+\u00a0a2\u00a0+\u00a0\u2026\u00a0+\u00a0an)modn=(1+2+\u00a0\u2026\u00a0+n)modn=n\u22c5(n+1)2modn=0=b1. So there is no answer.If n is even, then one possible example would be a=[n,\u00a01,\u00a0n\u22122,\u00a03,\u00a0n\u22124,\u00a05,\u00a0\u2026,\u00a0n\u22121,\u00a02], since then b=[0,\u00a01,\u00a0n\u22121,\u00a02,\u00a0n\u22122,\u00a03,\u00a0n\u22123,\u00a0\u2026,\u00a0n2]. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int q;\n    cin >> q;\n    while (q--) {\n        int n;\n        cin >> n;\n        if (n == 1) {\n            cout << \"1\\n\";\n            continue;\n        }\n        if (n % 2) {\n            cout << \"-1\\n\";\n        } else {\n            for (int i = 0; i < n; ++i) {\n                if (i % 2) {\n                    cout << i << \" \";\n                } else {\n                    cout << n - i << \" \";\n                }\n            }\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n} Rate the problem Didn't solve \n\n    \n\n\n160\n\n\n\n Good task \n\n    \n\n\n290\n\n\n\n Average task \n\n    \n\n\n55\n\n\n\n Bad task \n\n    \n\n\n466\n\n\n\n "
    },
    "1821B": {
        "title": "B. Sort the Subarray",
        "description": "Monocarp had an array a consisting of n integers. He has decided to choose two integers l and r such that 1\u2264l\u2264r\u2264n, and then sort the subarray a[l..r] (the subarray a[l..r] is the part of the array a containing the elements al,al+1,al+2,\u2026,ar\u22121,ar) in non-descending order. After sorting the subarray, Monocarp has obtained a new array, which we denote as a\u2032.\nFor example, if a=[6,7,3,4,4,6,5], and Monocarp has chosen l=2,r=5, then a\u2032=[6,3,4,4,7,6,5].\nYou are given the arrays a and a\u2032. Find the integers l and r that Monocarp could have chosen. If there are multiple pairs of values (l,r), find the one which corresponds to the longest subarray.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraints on the input:\nFor each test case, print two integers \u2014 the values of l and r (1\u2264l\u2264r\u2264n). If there are multiple answers, print the values that correspond to the longest subarray. If there are still multiple answers, print any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ],
        "solutions": "1821B - Sort the SubarrayLet's find the leftmost and the rightmost position in which the arrays a and a\u2032 differ. Since only the elements in the chosen subsegment might change, the subarray we sorted should contain these two positions.Let's start with the subarray from the leftmost \"different\" position to the rightmost one, and then expand it to get the longest subarray which meets the conditions. Suppose we want to expand it to the left. Let the current left border be L; how to decide if we can make it L\u22121 or less? If a\u2032L<aL\u22121, then we cannot include L\u22121 in the subarray we sort, since otherwise the order of these two elements would have changed. Otherwise, aL\u22121 is not greater than any element in the subarray we have chosen, so we can include it and reduce L by 1. We do this until it's impossible to reduce L further.The same goes for the right border: we expand it to the right until we find an element which is less than the previous element, and we cannot include this element in the subarray. Solution (BledDest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<int> a(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tvector<int> a1(n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\", &a1[i]);\n\t\tint diffl = -1, diffr = -1;\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(a[j] != a1[j])\n\t\t\t{\n\t\t\t\tdiffr = j;\n\t\t\t\tif(diffl == -1)\n\t\t\t\t\tdiffl = j;\n\t\t\t}\n\t\t}\n\t\twhile(diffl > 0 && a1[diffl - 1] <= a1[diffl])\n\t\t\tdiffl--;\n\t\twhile(diffr < n - 1 && a1[diffr + 1] >= a1[diffr])\n\t\t\tdiffr++;\n\t\tprintf(\"%d %d\\n\", diffl + 1, diffr + 1);\n\t}\n}\n"
    },
    "1820B": {
        "title": "B. JoJo's Incredible Adventures",
        "description": "Did you think there was going to be a JoJo legend here? But no, that was me, Dio!\nGiven a binary string s of length n, consisting of characters 0 and 1. Let's build a square table of size n\u00d7n, consisting of 0 and 1 characters as follows.\nIn the first row of the table write the original string s. In the second row of the table write cyclic shift of the string s by one to the right. In the third row of the table, write the cyclic shift of line s by two to the right. And so on. Thus, the row with number k will contain a cyclic shift of string s by k to the right. The rows are numbered from 0 to n\u22121 top-to-bottom.\nIn the resulting table we need to find the rectangle consisting only of ones that has the largest area.\nWe call a rectangle the set of all cells (i,j) in the table, such that x1\u2264i\u2264x2 and y1\u2264j\u2264y2 for some integers 0\u2264x1\u2264x2<n and 0\u2264y1\u2264y2<n.\nRecall that the cyclic shift of string s by k to the right is the string sn\u2212k+1\u2026sns1s2\u2026sn\u2212k. For example, the cyclic shift of the string \"01011\" by 0 to the right is the string itself \"01011\", its cyclic shift by 3 to the right is the string \"01101\".\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first and the only line of each test case contains a single binary string s (1\u2264|s|\u22642\u22c5105), consisting of characters 0 and 1.\nIt is guaranteed that the sum of string lengths |s| over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum area of a rectangle consisting only of ones. If there is no such rectangle, output 0.\nIn the first test case, there is a table 1\u00d71 consisting of a single character 0, so there are no rectangles consisting of ones, and the answer is 0.\nIn the second test case, there is a table 1\u00d71, consisting of a single character 1, so the answer is 1.\nIn the third test case, there is a table:\nIn the fourth test case, there is a table:\nIn the fifth test case, there is a table:\nRectangles with maximum area are shown in bold.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "strings",
            "two pointers",
            "*1100"
        ],
        "solutions": "1820B - JoJo's Incredible AdventuresFirst of all, consider the cases if the given string consists only of ones and only of zeros. It's easy to see that answers for these cases are n2 and 0.In all other cases let's split all strings into segments that consist only of ones. Also if the first and the last characters of the string equals to \"1\", these two characters will be in one segment. In other words, the pair of ones will lay inside one group if there exists some cyclic shift that these two ones are consecutive. Let the maximum length of such segment be equal to k. Then it can be shown that the answer equals to \u230ak+12\u230b\u22c5\u2308k+12\u2309.We will proof this fact in such way. If there exists some rectangle of size a\u00d7b. Considering its first row, we can see that it has a+b\u22121 consecutive ones. But it means that a+b\u2264k+1. Without loss of generality, if a\u2264b, we can do the following replacements: a=\u230ak+12\u230b\u2212\u03bb, b=\u2308k+12\u2309+\u03bb. It means that ab=\u2308k+12\u2309\u22c5\u230ak+12\u230b\u2212\u03bb2\u2264\u2308k+12\u2309\u22c5\u230ak+12\u230b.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        string s; cin >> s; s += s;\n        int k = 0, z = 0;\n        for (char c : s) {\n            z = c == '1' ? z+1 : 0;\n            k = max(k, z);\n        }\n        const int n = s.size() / 2;\n\n        if (k > n) {\n            cout << (ll)n*n << '\\n';\n        } else {\n            const ll side_a = (k+1)/2;\n            const ll side_b = (k+2)/2;\n            cout << side_a * side_b << '\\n';\n        }\n    }\n}"
    },
    "1816B": {
        "title": "B. Grid Reconstruction",
        "description": "Consider a 2\u00d7n2\u00d7n grid, where nn is an even integer. You may place the integers 1,2,\u2026,2n1,2,\u2026,2n on the grid, using each integer exactly once.\nA path is a sequence of cells achieved by starting at (1,1)(1,1), then repeatedly walking either downwards or to the right, and stopping when (2,n)(2,n) is reached. The path should not extend beyond the grid.\nThe cost of a path is the alternating sum of the numbers written on the cells in a path. That is, let the numbers written on the cells be a1,a2,\u2026,aka1,a2,\u2026,ak (in the order that it is visited), the cost of the path is a1\u2212a2+a3\u2212a4+\u2026=\u2211ki=1ai\u22c5(\u22121)i+1a1\u2212a2+a3\u2212a4+\u2026=\u2211ki=1ai\u22c5(\u22121)i+1.\nConstruct a way to place the integers 1,2,\u2026,2n1,2,\u2026,2n on the grid, such that the minimum cost over all paths from (1,1)(1,1) to (2,n)(2,n) is maximized. If there are multiple such grids that result in the maximum value, output any of them.\nThe first line contains a single integer tt (1\u2264t\u226410001\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first and the only line of each test case contains a single integer nn (2\u2264n\u22641052\u2264n\u2264105, nn is even) \u2014 the number of the columns in the grid.\nIt is guaranteed that the sum of nn over all test cases does not exceed 105105.\nFor each test case, output 22 lines, each containing nn integers \u2014 the desired grid. If there are multiple solutions, output any of them.\nIn the first test case, there are only two paths from cell (1,1)(1,1) to cell (2,2)(2,2). Their costs are 3\u22121+4=63\u22121+4=6 and 3\u22122+4=53\u22122+4=5. Then the minimum cost is 55, which is the maximum possible value.\nIn the second test case, there are four paths from cell (1,1)(1,1) to cell (2,4)(2,4). Their costs are 8\u22121+5\u22123+7=168\u22121+5\u22123+7=16, 8\u22122+5\u22123+7=158\u22122+5\u22123+7=15, 8\u22122+6\u22123+7=168\u22122+6\u22123+7=16, and 8\u22122+6\u22124+7=158\u22122+6\u22124+7=15. Then the minimum value is 1515, which is the maximum possible value.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1816B - Grid Reconstruction HintConsider the parity (odd/even) of i+j. What do you observe? EditorialObserve that ai,j will be added if (i+j) is even, and will be subtracted otherwise. This forms a checkered pattern.Obviously, it is optimal for all values that will be added to be strictly larger than all values that will be subtracted. Also, the difference between the value of adjacent grids should be almost equal (by some definition of almost).We construct array a as follows:  a1,1=2n\u22121 and a2,n=2n For 2\u2264i\u2264n and i is even, a1,i=i and a2,i\u22121=i\u22121 For 2\u2264i\u2264n and i is odd, a1,i=n+i\u22121 and a2,i\u22121=n+(i\u22121)\u22121 For example, when n=10, the output will be 19 2 12 4 14 6 16 8 18 10\n1 11 3 13 5 15 7 17 9 20 Insights on how to find the construction(This is a very informal proof. See \"Proof\" below for a formal proof.)First of all, due to the checkered pattern, a1,1,a2,2,a1,3,\u22ef,a2,n should be filled with n+1,n+2,n+3,\u22ef,2n, and a2,1,a1,2,a2,3,\u22ef,a1,n should be filled with 1,2,3,\u22ef,n. In particular, a1,1 and a2,n should be 2n\u22121 and 2n.Next, as we are trying to maximise the minimum, the difference between paths shouldn't be large (since the minimum path will be smaller if the difference is larger). Notice that a path consists of a prefix of a1 and a suffix of a2, and the difference between 2 adjacent paths is \u00b1(a1,k\u2212a2,k\u22121) (depending on the parity of k). It is optimal for the difference to be as small as possible (which is 1).Finally, it is optimal that a1,k\u2212a2,k\u22121 stays constant in the whole array. If they are different, the difference between 2 paths (not adjacent) will be larger than 1, which is suboptimal. ProofConsider the cost of the top right path and bottom left path.The cost of the top right path is a1,1\u2212a1,2+a1,3\u2212\u22ef\u2212a1,n+a2,n.The cost of the bottom right path is a1,1\u2212a2,1+a2,2\u2212a2,3+...+a2,n.Summing both values, we geta1,1+a2,n+((a1,1\u2212a1,2+a1,3\u2212a1,4+...\u2212a1,n)+(\u2212a2,1+a2,2\u2212a2,3+...+a2,n))which is equal toa1,1+a2,n+((a1,1+a2,2+a1,3+a2,4+\u22ef+a2,n)\u2212(a2,1+a1,2+a2,3+a1,4+\u22ef+a1,n))This value attains maximum when a1,1=2n, a2,n=2n\u22121, (a1,1+a2,2+a1,3+a2,4+\u22ef+a2,n)=((n+1)+(n+2)+(n+3)+\u22ef+2n) and (a2,1+a1,2+a2,3+a1,4+\u22ef+a1,n)=(1+2+3+\u22ef+n), which is (2n+(2n\u22121)+((n)((n+1)+2n)2)\u2212((n)(1+n)2))=(n2+4n\u22121).Therefore, the upper bound for the maximum cost is \u230an2+4n\u221212\u230b=12n2+2n\u22121. We will now show that the construction above meets the upper bound.Let Pk be the cost of the path a1,1,a1,2,a1,3,\u22ef,a1,k,a2,k,a2,k+1,\u22ef,a2,n.Observe that Pk\u2212Pk\u22121=(\u22121)k(a1,k\u2212a2,k\u22121)=(\u22121)k, as the paths differ by exactly 2 grids and a1,k\u2212a2,k\u22121=1 (from the above construction).Calculating P,P1=(2n\u22121)\u22122+(n+2)\u22124+(n+4)\u2212\u22ef\u2212(n\u22122)+2n=(2n\u22121)+(n)(n2\u22121)\u2212n+2n=12n2+2n\u22121P2=P1+(\u22121)2=12n2+2nP3=P2+(\u22121)3=12n2+2n\u22121\u22efTherefore, min(P)=12n2+2n\u22121, which achieves the upper bound. Implementation#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        \n        int ans[3][n + 1];\n        \n        ans[1][1] = 2 * n - 1;\n        ans[2][n] = 2 * n;\n\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                ans[1][i] = i;\n                ans[2][i - 1] = i - 1;\n            } else {\n                ans[1][i] = n + (i - 1);\n                ans[2][i - 1] = n + (i - 1) - 1;\n            }\n        }\n\n        for (int i = 1; i <= 2; i++) {\n            for (int j = 1; j <= n; j++) {\n                cout << ans[i][j] << (j == n ? '\\n' : ' ');\n            }\n        }\n    }\n} QuestionCan you find a construction for a n\u00d7n grid (and give a formal proof)? (We don't have a solution)"
    },
    "1811C": {
        "title": "C. Restore the Array",
        "description": "Kristina had an array a of length n consisting of non-negative integers.\nShe built a new array b of length n\u22121, such that bi=max(ai,ai+1) (1\u2264i\u2264n\u22121).\nFor example, suppose Kristina had an array a = [3,0,4,0,5] of length 5. Then she did the following: \nYou only know the array b. Find any matching array a that Kristina may have originally had.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (2\u2264n\u22642\u22c5105) \u2014 the number of elements in the array a that Kristina originally had.\nThe second line of each test case contains exactly n\u22121 non-negative integer \u2014 elements of array b (0\u2264bi\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105, and that array b was built correctly from some array a.\nFor each test case on a separate line, print exactly n non-negative integers \u2014 the elements of the array a that Kristina originally had.\nIf there are several possible answers \u2014 output any of them.\nThe first test case is explained in the problem statement.\nIn the second test case, we can get array b = [2,2,1] from the array a = [2,2,1,1]: \nIn the third test case, all elements of the array b are zeros. Since each bi is the maximum of two adjacent elements of array a, array a can only consist entirely of zeros.\nIn the fourth test case, we can get array b = [0,3,4,4,3] from the array a = [0,0,3,4,3,3] : ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1811C - Restore the ArrayTo solve the problem, you can build an array a as follows   a1=b1  ai=min(bi\u22121,bi) at 2\u2264i\u2264n\u22121  an=bn\u22121 Let's show that from the constructed array a we can get an array B equal to the original array b:   B1=max(a1,a2)=max(b1,min(b1,b2))   If b1>b2, then max(b1,b2)=b1  If b2\u2265b1, then max(b1,b1)=b1 So B1=b1 Bi=max(ai,ai+1)=max(min(bi\u22121,bi),min(bi,bi+1)) at 2\u2264i\u2264n\u22122  If bi+1\u2265bi and bi\u22121\u2265bi, then max(min(bi\u22121,bi),min(bi,bi+1)=min(bi,bi)=bi  If bi+1\u2265bi\u2265bi\u22121, then max(bi\u22121,bi)=bi  If bi\u22121\u2265bi\u2265bi+1, then max(bi,bi+1)=bi By the construction of the array b it is not possible that bi>bi+1 and bi>bi\u22121. So Bi=bi  Bn\u22121=max(an\u22121,an)=max(min(bn\u22122,bn\u22121),bn\u22121)   If bn\u22122>bn\u22122, then max(bn\u22121,bn\u22121)=bn\u22121  If bn\u22121\u2265bn\u22122, then max(bn\u22122,bn\u22121)=bn\u22121  So Bn\u22121=bn\u22121 We get that Bi=bi for 1\u2264i\u2264n\u22121, so B=b and array a is built correctly. Solution#include \"bits/stdc++.h\"\nusing namespace std;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int>b(n-1), a;\n    for(int i = 0; i < n - 1; i++) cin >> b[i];\n    a.emplace_back(b[0]);\n    for(int i = 0; i < n - 2; i++){\n        a.emplace_back(min(b[i], b[i + 1]));\n    }\n    a.emplace_back(b[n - 2]);\n    for(auto &i : a) cout << i << ' ';\n    cout << \"\\n\";\n}\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
    },
    "1811B": {
        "title": "B. Conveyor Belts",
        "description": "Conveyor matrix mn is matrix of size n\u00d7n, where n is an even number. The matrix consists of concentric ribbons moving clockwise.\nIn other words, the conveyor matrix for n=2 is simply a matrix 2\u00d72, whose cells form a cycle of length 4 clockwise. For any natural k\u22652, the matrix m2k is obtained by adding to the matrix m2k\u22122 an outer layer forming a clockwise cycle.\nYou are standing in a cell with coordinates x1,y1 and you want to get into a cell with coordinates x2,y2. A cell has coordinates x,y if it is located at the intersection of the xth row and the yth column.\nStanding on some cell, every second you will move to the cell next in the direction of movement of the tape on which you are. You can also move to a neighboring cell by spending one unit of energy. Movements happen instantly and you can make an unlimited number of them at any time.\nYour task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates x1,y1 to the cell with coordinates x2,y2.\nFor example, n=8 initially you are in a cell with coordinates 1,3 and you want to get into a cell with coordinates 6,4. You can immediately make 2 movements, once you are in a cell with coordinates 3,3, and then after 8 seconds you will be in the right cell.\nThe first line contains an integer t (1\u2264t\u22642\u22c5105) \u2014 the number of test cases.\nThe descriptions of the test cases follow.\nThe description of each test case consists of one string containing five integers n, x1, y1, x2 and y2 (1\u2264x1,y1,x2,y2\u2264n\u2264109) \u2014 matrix size and the coordinates of the start and end cells. It is guaranteed that the number n is even.\nFor each test case, print one integer in a separate line \u2014 the minimum amount of energy that will have to be spent to get from the cell with coordinates x1,y1 to the cell with coordinates x2,y2.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1811B - Conveyor BeltsIdea: Vladosiya, prepared: senjougaharin TutorialTutorial is loading... Solutiondef layer(n, x, y):\n    return min([x, y, n + 1 - x, n + 1 - y])\n\n\ndef solve():\n    n, x1, y1, x2, y2 = map(int, input().split())\n    print(abs(layer(n, x1, y1) - layer(n, x2, y2)))\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "1809B": {
        "title": "B. Points on Plane",
        "description": "You are given a two-dimensional plane, and you need to place n chips on it. \nYou can place a chip only at a point with integer coordinates. The cost of placing a chip at the point (x,y) is equal to |x|+|y| (where |a| is the absolute value of a).\nThe cost of placing n chips is equal to the maximum among the costs of each chip.\nYou need to place n chips on the plane in such a way that the Euclidean distance between each pair of chips is strictly greater than 1, and the cost is the minimum possible.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first and only line of each test case contains one integer n (1\u2264n\u22641018)\u00a0\u2014 the number of chips you need to place.\nFor each test case, print a single integer\u00a0\u2014 the minimum cost to place n chips if the distance between each pair of chips must be strictly greater than 1.\nIn the first test case, you can place the only chip at point (0,0) with total cost equal to 0+0=0.\nIn the second test case, you can, for example, place chips at points (\u22121,0), (0,1) and (1,0) with costs |\u22121|+|0|=1, |0|+|1|=1 and |0|+|1|=1. Distance between each pair of chips is greater than 1 (for example, distance between (\u22121,0) and (0,1) is equal to \u221a2). The total cost is equal to max(1,1,1)=1.\nIn the third test case, you can, for example, place chips at points (\u22121,\u22121), (\u22121,1), (1,1), (0,0) and (0,2). The total cost is equal to max(2,2,2,0,2)=2.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1809B - Points on PlaneSuppose, the answer is k. What's the maximum number of chips we can place? Firstly, the allowed points (x,y) to place chips are such that |x|+|y|\u2264k. We can group them by x-coordinate: for x=k there is only one y=0, for x=k\u22121 possible y are \u22121,0,1; for x=k\u22122 possible y are in segment [\u22122,\u2026,2] and so on. For x=0 possible y are in [\u2212k,\u2026,k]. The negative x-s are the same.Let's calculate the maximum number of chips we can place at each \"row\": for x=k it's 1; for x=k\u22121 there are three y-s, but since we can't place chips at the neighboring y-s, we can place at most 2 chips; for x=k\u22122 we have 5 places, but can place only 3 chips; for x=0 we have 2k+1 places, but can occupy only k+1 points.In total, for x\u2208[0,\u2026,k] we can place at most 1+2+\u22ef+(k+1)=(k+1)(k+2)2 chips. Analogically, for x\u2208[\u2212k,\u2026,\u22121] we can place at most 1+2+\u22ef+k=k(k+1)2 chips.In total, we can place at most (k+1)(k+2)2+k(k+1)2=(k+1)2 chips with cost at most k. Note that (k+1)2 can actually be reached since the distance between chips on the different rows is greater than 1. So, to solve our task, it's enough to find minimum k such that (k+1)2\u2265n that can be done with Binary Search.Or we can calculate k=\u2308n\u2212\u2212\u221a\u2309\u22121. Note that n\u2212\u2212\u221a can lose precision, since n is cast to double before taking the square root (for example, 975461057789971042 transforms to 9.754610577899711\u22c51017=975461057789971100 when converted to double). So you should either cast long long to long double (that consists of 80 bits in some C++ compilers) or check value k+1 as a possible answer. Solution 1 (adedalic)fun main() {\n    repeat(readln().toInt()) {\n        val n = readln().toLong()\n        var l = (-1).toLong()\n        var r = 1e9.toLong()\n        while (r - l > 1) {\n            val mid = (l + r) / 2\n            if (mid * mid >= n)\n                r = mid\n            else\n                l = mid\n        }\n        println(r - 1)\n    }\n} Solution 2 (adedalic)import kotlin.math.sqrt\n\nfun main() {\n    repeat(readln().toInt()) {\n        val n = readln().toLong()\n        var ans = sqrt(n.toDouble()).toLong()\n        while (ans * ans > n)\n            ans--\n        while (ans * ans < n)\n            ans++\n        println(ans - 1)\n    }\n}"
    },
    "1808B": {
        "title": "B. Playing in a Casino",
        "description": "Galaxy Luck, a well-known casino in the entire solar system, introduces a new card game.\nIn this game, there is a deck that consists of n cards. Each card has m numbers written on it. Each of the n players receives exactly one card from the deck.\nThen all players play with each other in pairs, and each pair of players plays exactly once. Thus, if there are, for example, four players in total, then six games are played: the first against the second, the first against the third, the first against the fourth, the second against the third, the second against the fourth and the third against the fourth.\nEach of these games determines the winner in some way, but the rules are quite complicated, so we will not describe them here. All that matters is how many chips are paid out to the winner. Let the first player's card have the numbers a1,a2,\u2026,am, and the second player's card\u00a0\u2014 b1,b2,\u2026,bm. Then the winner of the game gets |a1\u2212b1|+|a2\u2212b2|+\u22ef+|am\u2212bm| chips from the total pot, where |x| denotes the absolute value of x.\nTo determine the size of the total pot, it is necessary to calculate the winners' total winnings for all games. Since there can be many cards in a deck and many players, you have been assigned to write a program that does all the necessary calculations.\nEach test consists of several test cases. The first line contains one integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n\u22c5m\u22643\u22c5105)\u00a0\u2014 the number of cards in the deck and the count of numbers on the one card.\nEach of the following n lines of the test case set contains m integers ci,j (1\u2264ci,j\u2264106)\u00a0\u2014 a description of the i-th card.\nIt is guaranteed that the total n\u22c5m in all tests does not exceed 3\u22c5105.\nFor each test case, print one number\u00a0\u2014 the total amount of winnings from all games.\nConsider the first test case.\nIn the game between the first and second player, the winner receives |1\u22127|+|4\u22129|+|2\u22122|+|8\u22121|+|5\u22124|=19 chips.\nIn the game between the first and third player, the winner receives |1\u22123|+|4\u22128|+|2\u22125|+|8\u22123|+|5\u22121|=18 in chips.\nIn the game between the second and third player, the winner receives |7\u22123|+|9\u22128|+|2\u22125|+|1\u22123|+|4\u22121|=13 chips.\nThe total is 19+18+13=50 chips.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1808B - Playing in a CasinoYou may notice that the problem can be solved independently for each column of the input matrix. The answer is then the sum \u2211i=1n\u2211j=i+1n|ai\u2212aj|, where a\u00a0\u2014 array representing a column.Let's try to calculate this sum for each column. Let's sort all elements of the current column. Let's calculate the answer for some element in the sorted list. The answer for it will be ai\u22c5i\u2212sum, where sum is the sum on the prefix. Why is this so? Because we say that this number is larger than the others and the modulus will then decompose as ai\u2212aj, and this is already easy to count."
    },
    "1807G2": {
        "title": "G2. Subsequence Addition (Hard Version)",
        "description": "The only difference between the two versions is that in this version, the constraints are higher.\nInitially, array a contains just the number 1. You can perform several operations in order to change the array. In an operation, you can select some subsequence\u2020 of a and add into a an element equal to the sum of all elements of the subsequence. \nYou are given a final array c. Check if c can be obtained from the initial array a by performing some number (possibly 0) of operations on the initial array.\n\u2020 A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several (possibly zero, but not all) elements. In other words, select k (1\u2264k\u2264|a|) distinct indices i1,i2,\u2026,ik and insert anywhere into a a new element with the value equal to ai1+ai2+\u22ef+aik.\nThe first line of the input contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u00a0\u2014 the number of elements the final array c should have.\nThe second line of each test case contains n space-separated integers ci (1\u2264ci\u22642\u22c5105) \u00a0\u2014 the elements of the final array c that should be obtained from the initial array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" (without quotes) if such a sequence of operations exists, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nFor the first test case, the initial array a is already equal to [1], so the answer is \"YES\".\nFor the second test case, performing any amount of operations will change a to an array of size at least two which doesn't only have the element 2, thus obtaining the array [2] is impossible and the answer is \"NO\".\nFor the third test case, we can perform the following operations in order to obtain the final given array c:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1807G2 - Subsequence Addition (Hard Version)Let's prove that for an array a that was created by using a number of operations, with a sum of elements s we can add into a any number x (1\u2264x\u2264s).Suppose that it is true that in the array a with some length l we introduce a number x (1\u2264x\u2264suma). Then after introducing we can create using the initial elements of the array any number b (1\u2264b\u2264suma) and using the element x and some subset of the initial elements we can create any number b (x\u2264b\u2264suma+x), and because x\u2264suma we proved that for the new array of length l+1 we can still create any number between 1 and suma+x.Since it is true for the initial array, we can use induction and this fact to prove it is true for all arrays. So we just need to verify if our array satisfies this condition. We should sort the array and check for each i (2\u2264i\u2264n) if ci\u2264\u2211i\u22121j=1cj. Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    if(a[0] != 1) {\n        cout << \"NO\\n\";\n        return;\n    }\n    long long sum = a[0];\n    for(int i = 1; i < n; ++i) {\n        if(sum < a[i]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        sum += a[i];\n    }\n    cout << \"YES\\n\";\n}\n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}"
    },
    "1807G1": {
        "title": "G1. Subsequence Addition (Easy Version)",
        "description": "The only difference between the two versions is that in this version, the constraints are lower.\nInitially, array a contains just the number 1. You can perform several operations in order to change the array. In an operation, you can select some subsequence\u2020 of a and add into a an element equal to the sum of all elements of the subsequence. \nYou are given a final array c. Check if c can be obtained from the initial array a by performing some number (possibly 0) of operations on the initial array.\n\u2020 A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several (possibly zero, but not all) elements. In other words, select k (1\u2264k\u2264|a|) distinct indices i1,i2,\u2026,ik and insert anywhere into a a new element with the value equal to ai1+ai2+\u22ef+aik.\nThe first line of the input contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22645000) \u00a0\u2014 the number of elements the final array c should have.\nThe second line of each test case contains n space-separated integers ci (1\u2264ci\u22645000) \u00a0\u2014 the elements of the final array c that should be obtained from the initial array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 5000.\nFor each test case, output \"YES\" (without quotes) if such a sequence of operations exists, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nFor the first test case, the initial array a is already equal to [1], so the answer is \"YES\".\nFor the second test case, performing any amount of operations will change a to an array of size at least two which doesn't only have the element 2, thus obtaining the array [2] is impossible and the answer is \"NO\".\nFor the third test case, we can perform the following operations in order to obtain the final given array c:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1807G1 - Subsequence Addition (Easy Version)Idea: flamestorm TutorialTutorial is loading... Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n \nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    sort(all(a));\n    if(a[0] != 1) {\n        cout << \"NO\\n\";\n        return;\n    }\n    vector<int> dp(5005, 0);\n    dp[1] = 1;\n    for(int i = 1; i < n; ++i) {\n        if(!dp[a[i]]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        for(int j = 5000; j >= a[i]; --j) {\n            dp[j] |= dp[j - a[i]];\n        }\n    }\n    cout << \"YES\\n\";\n}\n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}\n\n"
    },
    "1804B": {
        "title": "B. Vaccination",
        "description": "Ethan runs a vaccination station to help people combat the seasonal flu. He analyses the historical data in order to develop an optimal strategy for vaccine usage.\nConsider there are n patients coming to the station on a particular day. The i-th patient comes at the moment ti. We know that each of these patients can be asked to wait for no more than w time moments. That means the i-th patient can get vaccine at moments ti,ti+1,\u2026,ti+w.\nVaccines come in packs, each pack consists of k doses. Each patient needs exactly one dose. Packs are stored in a special fridge. After a pack is taken out of the fridge and opened, it can no longer be put back. The lifetime of the vaccine outside the fridge is d moments of time. Thus, if the pack was taken out of the fridge and opened at moment x, its doses can be used to vaccinate patients at moments x,x+1,\u2026,x+d. At moment x+d+1 all the remaining unused doses of this pack are thrown away.\nAssume that the vaccination station has enough staff to conduct an arbitrary number of operations at every moment of time. What is the minimum number of vaccine packs required to vaccinate all n patients?\nThe first line of the input contains the number of test cases t (1\u2264t\u2264104). Then follow t descriptions of the test cases.\nThe first line of each test case contains four integers n, k, d and w (1\u2264n,k\u22642\u22c5105, 0\u2264d,w\u2264106). They are the number of patients, the number of doses per vaccine pack, the number of moments of time the vaccine can live outside the fridge, and the number of moments of time each of the patients can wait, respectively.\nThe second line of each test case contains a non-decreasing sequence t1,t2,\u2026,tn (0\u2264t1\u2264t2\u2264\u2026\u2264tn\u2264106). The i-th element of this sequence is the moment when the i-th patient comes to the vaccination station.\nIt is guaranteed that the sum of n over all test cases won't exceed 2\u22c5105.\nOutput one integer, the minimum number of vaccine packs required to vaccinate all n patients.\nIn the first example, the first pack can be opened at moment 1 to vaccinate patient 1. The vaccine is durable enough to be used at moments 2 and 3 for patients 2 and 3, respectively. Then the staff needs to ask patients 4 and 5 to wait for moment 13. At moment 13 the staff opens the second vaccine pack and serves patients 4 and 5. Finally, the last patient comes at moment 18 and immediately gets the last dose of the second pack while it is still fine.\nIn the second example, the vaccine should be used exactly at the moment it is taken out of the fridge. Moreover, all the patients want to be served at exactly the same moment they come. That means the staff needs to open two packs at moment 3 and use five doses on patients 1, 2, 3, 4, and 5. There will be three doses left ouf of these two packs but they can't be used for patient 6. When patient 6 comes at moment 4 the staff needs to open a new pack just to use only one dose out of it.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1804B - \u0412\u0430\u043a\u0446\u0438\u043d\u0430\u0446\u0438\u044fObservation 1. There exists an optimal answer where each pack of vaccine is used for a consecutive segment of patients. Indeed, if there are three patients a<b<c such that a and c are vaccinated using the dose from one pack and b is vaccinated using the dose from the other pack we can swap the packs used for b and c and the answer will still be valid.Observation 2. It always makes sense to ask new patients to wait as long as possible before opening a new pack.From these two observations we derive a very easy strategy. Consider patients one by one in order of non-decreasing ti. If we consider some patient i and there is an open pack that still valid and still has some doses remaining, use it immediately. If there is no valid open pack of vaccines and there is no one waiting, ask patient i to wait till ti+w moment of time. If there is no valid pack of vaccines, but there is someone already waiting for moment x, ask patient i to wait for moment x as well.As a courtesy to our participants the values of d and w are limited by 106 to avoid a potential overflow of a signed 32-bit integer type. "
    },
    "1802B": {
        "title": "B. Settlement of Guinea Pigs",
        "description": "Dasha loves guinea pigs very much. In this regard, she decided to settle as many guinea pigs at home as possible and developed a plan for the next n days. Every day, she will either buy a new guinea pig or call a doctor to examine all her pets.\nUnfortunately, the store where she was going to buy guinea pigs does not understand them. Therefore, it cannot determine their gender. Dasha can't do it either. The only one who can help is a doctor. \nTo keep guinea pigs, aviaries are needed. Dasha plans to buy them in the same store. Unfortunately, only one species is sold there \u2014 a double aviary. No more than two guinea pigs can live in it.\nSince Dasha does not want to cause moral injury to her pets \u2014 she will not settle two guinea pigs of different genders in one aviary.\nHelp Dasha calculate how many aviaries in the worst case you need to buy so that you can be sure that at no moment of time do two guinea pigs of different genders live in the same aviary.\nAs part of this task, we believe that guinea pigs have only two genders \u2014 male and female.\nThe first line of input data contains one number t (1\u2a7dt\u2a7d105) \u2014 the number of input data sets.\nThe first line of each input data set contains one number n (1\u2a7dn\u2a7d105) \u2014 the number of days Dasha has a plan for.\nThe next line contains n numbers b1,b2,b3,\u2026,bn (1\u2a7dbi\u2a7d2) \u2014 Dasha's plan. If bi=1, then on the ith day, Dasha will buy a new guinea pig. If bi=2, then on the ith day, a doctor will come to Dasha and help determine the sex of all guinea pigs that Dasha already has.\nIt is guaranteed that the sum of n for all input data sets does not exceed 105.\nFor each set of input data, output one number \u2014 the minimum number of aviaries Dasha needs to buy so that no matter what the genders of the pigs turn out to be, we can settle them so that at no point in time do two guinea pigs of different genders live together.\nIn the first set of input data, Dasha needs to put each guinea pig in a separate enclosure, since she does not know their gender.\nIn the second set of input data, Dasha will buy 0 guinea pigs, which means she will need 0 aviaries.\nIn the third set of input data, you even need 3 aviaries to put each guinea pig in a separate aviary before the doctor arrives at the 4th day. When she finds out their gender, at least two guinea pigs will be of the same gender and they can be placed in one aviary, and the third in another aviary. Thus, she will have one free aviary in which she can settle a new guinea pig. So answer is 3.\nIn the fourth set of input data, we show that 4 is the optimal answer. \nTo begin with, we note that the first four guinea pigs can be placed one at a time in an aviary. Then a doctor will come and determine their gender. Among these four guinea pigs there will be at least one pair of the same gender, because: either male guinea pigs are at least 2, or they are not more than 1, which means that the female is at least 3. Now we can put this couple in one aviary, and the other two in separate ones. We will have one more empty aviary where we can put a new pig.\nNow let's show that the answer is at least 4. Let's say that among the first 4 guinea pigs, 3 are female and 1 is male. We need at least 3 aviaries to settle them. Then, when we buy a new guinea pig, we will need another aviary in which we will put it, since we do not know its gender.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1802B - Settlement of Guinea PigsIdea and preparation: Aleks5d SolutionTodo Code#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int known = 0, unknown = 0;\n    int need = 0;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        if (x == 1) ++unknown;\n        else {\n            known += unknown;\n            unknown = 0;\n        }\n        need = max(need, unknown + (known ? known / 2 + 1 : 0));\n    }\n    cout << need << endl;\n}\n\nsigned main() {\n    int t = 1;\n    cin >> t;\n    for (int i = 0; i < t; ++i) {\n        solve();\n    }\n    return 0;\n}"
    },
    "1800D": {
        "title": "D. Remove Two Letters",
        "description": "Dmitry has a string s, consisting of lowercase Latin letters.\nDmitry decided to remove two consecutive characters from the string s and you are wondering how many different strings can be obtained after such an operation.\nFor example, Dmitry has a string \"aaabcc\". You can get the following different strings: \"abcc\"(by deleting the first two or second and third characters), \"aacc\"(by deleting the third and fourth characters),\"aaac\"(by deleting the fourth and the fifth character) and \"aaab\" (by deleting the last two).\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 number of test cases. \nThe descriptions of the test cases follow.\nThe first line of the description of each test case contains an integer n (3\u2264n\u22642\u22c5105).\nThe second line of the description of each test case contains a string s of length n consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case print one integer \u2014 the number of distinct strings that can be obtained by removing two consecutive letters.\nThe first example is explained in the statement.\nIn the third example, the following strings are obtained: \"cdef\", \"adef\", \"abef\", \"abcf\", \"abcd\".\nIn the seventh example, any deletion will result in the string \"aba\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "hashing",
            "strings",
            "*1200"
        ],
        "solutions": "1800D - Remove Two LettersConsider deleting characters with numbers i and i+1, as well as characters with numbers i+1 and i+2. In the first case, the symbol with the number i+2 remains, in the second - i. Symbols with numbers less than i or more than i+2 remain in both cases. Therefore, the same strings will be obtained if the characters with the numbers i and i+2 match. Therefore, we just need to count the number of i:1\u2264i\u2264n\u22122:si=si+2, and subtract this value from n\u22121. Solution#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    int res = n - 1;\n    for (int i = 1; i + 1 < n; ++i) {\n        if (s[i - 1] == s[i + 1]) {\n            res--;\n        }\n    }\n    cout << res << '\\n';\n}\n\nint main(int argc, char* argv[]) {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; ++i) {\n        solve();\n    }\n}"
    },
    "1800C2": {
        "title": "C2. Powering the Hero (hard version)",
        "description": "This is a hard version of the problem. It differs from the easy one only by constraints on n and t.\nThere is a deck of n cards, each of which is characterized by its power. There are two types of cards:\nYou can do the following with the deck:\nYour task is to use such actions to gather an army with the maximum possible total power.\nThe first line of input data contains single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of cards in the deck.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (0\u2264si\u2264109)\u00a0\u2014 card powers in top-down order.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nOutput t numbers, each of which is the answer to the corresponding test case \u2014 the maximum possible total power of the army that can be achieved.\nIn the first sample, you can take bonuses 1 and 2. Both hero cards will receive 3 power. If you take all the bonuses, one of them will remain unused.\nIn the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with 2 and 3 bonuses and get 6 total power.\nIn the fourth sample, you can take bonuses 1, 2, 3, 5 and skip the bonus 6, then the hero 4 will be enhanced with a bonus 3 by 5, and the hero 7 with a bonus 5 by 4. 4+5=9.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1100"
        ],
        "solutions": "1800C2 - Powering the Hero (hard version)Idea: Vladosiya TutorialTutorial is loading... Solutionfrom queue import PriorityQueue\n\n\ndef solve():\n    n = int(input())\n    s = [int(x) for x in input().split()]\n    ans = 0\n    buffs = PriorityQueue()\n    for e in s:\n        if e > 0:\n            buffs.put(-e)\n        elif not buffs.empty():\n            ans -= buffs.get()\n    print(ans)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "1800C1": {
        "title": "C1. Powering the Hero (easy version)",
        "description": "This is an easy version of the problem. It differs from the hard one only by constraints on n and t.\nThere is a deck of n cards, each of which is characterized by its power. There are two types of cards:\nYou can do the following with the deck:\nYour task is to use such actions to gather an army with the maximum possible total power.\nThe first line of input data contains single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases in the test.\nThe first line of each test case contains one integer n (1\u2264n\u22645000)\u00a0\u2014 the number of cards in the deck.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (0\u2264si\u2264109)\u00a0\u2014 card powers in top-down order.\nIt is guaranteed that the sum of n over all test cases does not exceed 5000.\nOutput t numbers, each of which is the answer to the corresponding test case \u2014 the maximum possible total power of the army that can be achieved.\nIn the first sample, you can take bonuses 1 and 2. Both hero cards will receive 3 power. If you take all the bonuses, one of them will remain unused.\nIn the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with 2 and 3 bonuses and get 6 total power.\nIn the fourth sample, you can take bonuses 1, 2, 3, 5 and skip the bonus 6, then the hero 4 will be enhanced with a bonus 3 by 5, and the hero 7 with a bonus 5 by 4. 4+5=9.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1000"
        ],
        "solutions": "1800C1 - Powering the Hero (easy version)Idea: Vladosiya TutorialTutorial is loading... Solutiondef solve():\n    n = int(input())\n    s = [int(x) for x in input().split()]\n    ans = 0\n    buffs = [0] * n\n    for e in s:\n        if e > 0:\n            buffs += [e]\n            j = len(buffs) - 1\n            while buffs[j] < buffs[j - 1]:\n                buffs[j], buffs[j - 1] = buffs[j - 1], buffs[j]\n                j -= 1\n        else:\n            ans += buffs.pop()\n    print(ans)\n\n\nt = int(input())\nfor _ in range(t):\n    solve()"
    },
    "1800B": {
        "title": "B. Count the Number of Pairs",
        "description": "Kristina has a string s of length n, consisting only of lowercase and uppercase Latin letters. For each pair of lowercase letter and its matching uppercase letter, Kristina can get 1 burl. However, pairs of characters cannot overlap, so each character can only be in one pair.\nFor example, if she has the string s = \"aAaaBACacbE\", she can get a burl for the following character pairs: \nKristina wants to get more burles for her string, so she is going to perform no more than k operations on it. In one operation, she can:\nFor example, when k = 2 and s = \"aAaaBACacbE\" it can perform one operation: choose s3 = \"a\" and make it uppercase. Then she will get another pair of s3 = \"A\" and s8 = \"a\"\nFind maximum number of burles Kristina can get for her string.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains two integers n (1\u2264n\u22642\u22c5105) and k (0\u2264k\u2264n) \u2014 the number of characters in the string and the maximum number of operations that can be performed on it.\nThe second line of each test case contains a string s of length n, consisting only of lowercase and uppercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print exactly one integer on a separate line: the maximum number of burles that Kristina can get for her string s.\nThe first test case is explained in the problem statement.\nIn the second test case, it is not possible to get any pair by performing any number of operations.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1000"
        ],
        "solutions": "1800B - Count the Number of PairsIdea: myav TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 26;\n\nvoid solve(){\n    int n, k;\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    vector<int>big(N, 0), small(N, 0);\n    for(auto &i : s){\n        if('A' <= i && 'Z' >= i) big[i - 'A']++;\n        else small[i - 'a']++;\n    }\n    int answer = 0;\n    for(int i = 0; i < N; i++){\n        int pairs = min(small[i], big[i]);\n        answer += pairs;\n        small[i] -=pairs; big[i] -= pairs;\n        int add = min(k, max(small[i], big[i]) / 2);\n        k -= add; answer += add;\n    }\n    cout << answer << endl;\n}\nint main(){\n    int t;\n    cin >> t;\n    while(t--) solve();\n    return 0;\n}"
    },
    "1799B": {
        "title": "B. Equalize by Divide",
        "description": "You are given an array a1,a2,\u2026,an of positive integers.\nYou can make this operation multiple (possibly zero) times:\nIs it possible to make all array elements equal by some sequence of operations (possibly empty)? If yes, print any way to do it in at most 30n operations.\nIt can be proven, that under the problem constraints, if some way exists to make all elements equal, there exists a way with at most 30n operations.\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. Descriptions of test cases follow.\nThe first line of each test case description contains a single integer n (1\u2264n\u2264100).\nThe second line of each test case description contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed, that the sum of n for all test cases does not exceed 1000.\nFor each test case print a single integer q (\u22121\u2264q\u226430n). If q=\u22121, there is no solution, otherwise q is equal to the number of operations.\nIf q\u22650, on the next q lines print two integers i, j (1\u2264i,j\u2264n, i\u2260j) \u2014 descriptions of operations.\nIf there are multiple solutions, you can print any.\nIn the first and second, fourth test cases all numbers are equal, so it is possible to do nothing.\nIn the third test case, it is impossible to make all numbers equal.\nIn the fifth test case: [4,3,2]\u2192[2,3,2]\u2192[2,2,2].\nIn the sixth test case: [3,3,4,4]\u2192[3,3,2,4]\u2192[3,3,2,2]\u2192[2,3,2,2]\u2192[2,2,2,2].\nHere the red numbers are i indices (that will be assigned), blue numbers are j indices.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1799B - Equalize by DivideIf all numbers are equal initially \u2014 we can do nothing.Otherwise if some ai=1, answer do not exist: this ai can't became bigger during operations and all other elements can't be equal to 1 simultaniously, because after the last operation aj>1 (otherwise we can remove this operation).If all ai\u22652, the answer exists and we can simulate such algorithm: let's take i, such that ai is maximum possible and j, such that aj is smallest possible. Make operation with (i,j). Note, that after at most 30n operations all elements will be equal.It is true, because after each operation ai decreases at least by 2 times (and rounded up) and all elements are bounded ax\u22652 after each operation. Each number can't be decreased more than 30 times.Time complexity: O(n2logC), where C=109. "
    },
    "1798B": {
        "title": "B. Three Sevens",
        "description": "Lottery \"Three Sevens\" was held for m days. On day i, ni people with the numbers ai,1,\u2026,ai,ni participated in the lottery.\nIt is known that in each of the m days, only one winner was selected from the lottery participants. The lottery winner on day i was not allowed to participate in the lottery in the days from i+1 to m.\nUnfortunately, the information about the lottery winners has been lost. You need to find any possible list of lottery winners on days from 1 to m or determine that no solution exists.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226450000). The description of the test cases follows.\nThe first line of each test case contains a single integer m (1\u2264m\u226450000)\u00a0\u2014 the number of days in which the lottery was held.\nNext, for each i from 1 to m, follows a two-line block of data.\nThe first line of each block contains a single integer ni (1\u2264ni\u226450000)\u00a0\u2014 the number of lottery participants on day i.\nThe second line of the block contains integers ai,1,\u2026,ai,ni (1\u2264ai,j\u226450000)\u00a0\u2014 lottery participants on day i. It is guaranteed that all the numbers ai,1,\u2026,ai,ni are pairwise distinct.\nIt is guaranteed that the sum of ni over all blocks of all test cases does not exceed 50000.\nFor each test case, if there is no solution, print a single integer \u22121.\nOtherwise, print m integers p1,p2,\u2026,pm (1\u2264pi\u226450000)\u00a0\u2014 lottery winners on days from 1 to m. If there are multiple solutions, print any of them.\nIn the first test case, one of the answers is [8,2,1] since the participant with the number 8 participated on day 1, but did not participate on days 2 and 3; the participant with the number 2 participated on day 2, but did not participate on day 3; and the participant with the number 1 participated on day 3. Note that this is not the only possible answer, for example, [8,9,4] is also a correct answer.\nIn the second test case, both lottery participants participated on both days, so any possible lottery winner on the day 1 must have participated on the day 2, which is not allowed. Thus, there is no correct answer.\nIn the third test case, only one participant participated on days 2, 3, 4, and on day 1 there is only one participant who did not participate in the lottery on days 2,3,4\u00a0\u2014 participant 2, which means [2,1,4,3] is the only correct answer to this test case.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1798B - Three SevensLet's calculate the array last, where lastX is the last day of the lottery in which the person X participated. Then the only day when X could be a winner is the day lastX. Then on the day of i, only the person with lastX=i can be the winner. It is also clear that if there are several such participants for the day i, you can choose any of them as the winner, since these participants cannot be winners on any other days. In total, we need to go through all the days, if for some day there are no participants with last equal to this day, then the answer is \u22121. Otherwise, we choose any participant with lastX=i as the winner on the day of i. SolutionMAX = 50000\nlast = [0] * (MAX + 777)\nfor _ in range(int(input())):\n    m = int(input())\n    a_ = []\n    for day in range(m):\n        n = int(input())\n        a = list(map(int, input().split()))\n        for x in a:\n            last[x] = day\n        a_.append(a)\n    ans = [-1] * m\n    for day in range(m):\n        for x in a_[day]:\n            if last[x] == day:\n                ans[day] = x\n        if ans[day] == -1:\n            print(-1)\n            break\n    else:\n        print(*ans) Rate the problem Didnt solve \n\n    \n\n\n86\n\n\n\n Good problem \n\n    \n\n\n575\n\n\n\n Average problem \n\n    \n\n\n121\n\n\n\n Bad problem \n\n    \n\n\n60\n\n\n\n "
    },
    "1797B": {
        "title": "B. Li Hua and Pattern",
        "description": "Li Hua has a pattern of size n\u00d7n, each cell is either blue or red. He can perform exactly k operations. In each operation, he chooses a cell and changes its color from red to blue or from blue to red. Each cell can be chosen as many times as he wants. Is it possible to make the pattern, that matches its rotation by 180\u2218?\nSuppose you were Li Hua, please solve this problem.\nThe first line contains the single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,k (1\u2264n\u2264103,0\u2264k\u2264109)\u00a0\u2014 the size of the pattern and the number of operations.\nEach of next n lines contains n integers ai,j (ai,j\u2208{0,1})\u00a0\u2014 the initial color of the cell, 0 for blue and 1 for red.\nIt's guaranteed that sum of n over all test cases does not exceed 103.\nFor each set of input, print \"YES\" if it's possible to make the pattern, that matches its rotation by 180\u2218 after applying exactly k of operations, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn test case 1, you can't perform any operation. The pattern after rotation is on the right.\nIn test case 2, you can perform operations on (2,1),(3,2),(3,4). The pattern after operations is in the middle and the pattern after rotation is on the right.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1797B - Li Hua and PatternWe can calculate the minimum needed operations kmin easily by enumerating through the cells and performing an operation if the color of the cell is different from the targeted cell. Obviously, if k<kmin, the problem has no solution.Otherwise, there are two cases:  If 2\u2223n, the solution exists if and only if 2\u2223(k\u2212kmin), as we must perform two operations each time to meet the requirement.  If 2\u2224n, the solution always exists, as we can perform the remaining operations at the center of the pattern. Time complexity: O(n2). Solution (rui_er)//By: OIer rui_er\n#include <bits/stdc++.h>\n#define rep(x,y,z) for(int x=(y);x<=(z);x++)\n#define per(x,y,z) for(int x=(y);x>=(z);x--)\n#define debug(format...) fprintf(stderr, format)\n#define fileIO(s) do{freopen(s\".in\",\"r\",stdin);freopen(s\".out\",\"w\",stdout);}while(false)\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e3+5;\n \nint T, n, k, a[N][N];\ntemplate<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}\ntemplate<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}\n \nint main() {\n\tfor(scanf(\"%d\", &T);T;T--) {\n\t\tscanf(\"%d%d\", &n, &k);\n\t\trep(i, 1, n) rep(j, 1, n) scanf(\"%d\", &a[i][j]);\n\t\tint diff = 0;\n\t\trep(i, 1, n) rep(j, 1, n) if(a[i][j] != a[n+1-i][n+1-j]) ++diff;\n\t\tdiff /= 2;\n\t\tif(diff > k) puts(\"NO\");\n\t\telse {\n\t\t\tk -= diff;\n\t\t\tif(n & 1) puts(\"YES\");\n\t\t\telse if(k & 1) puts(\"NO\");\n\t\t\telse puts(\"YES\");\n\t\t}\n\t}\n\treturn 0;\n}"
    },
    "1796B": {
        "title": "B. Asterisk-Minor Template",
        "description": "You are given two strings a and b, consisting of lowercase Latin letters.\nA template t is string, consisting of lowercase Latin letters and asterisks (character '*'). A template is called asterisk-minor if the number of asterisks in it is less than or equal to the number of letters in it.\nA string s is said to be matching a template t if you can replace each asterisk in t with a string of lowercase Latin letters (possibly, an empty string) so that it becomes equal to s.\nFind an asterisk-minor template such that both a and b match it, or report that such a template doesn't exist. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a string a (1\u2264|a|\u226450, where |a| is the length of a), consisting of lowercase Latin letters.\nThe second line contains a string b (1\u2264|b|\u226450), consisting of lowercase Latin letters.\nFor each testcase, output \"NO\", if there doesn't exist an asterisk-minor template that both a and b match. Otherwise, print \"YES\" in the first line and the template in the second line. If there are multiple answers, print any of them.\nA template should consist only of lowercase Latin letters and asterisks (character '*'). The number of asterisks should be less than or equal to the number of letters.\nIn the first testcase, for a template \"*b\", you can replace the only asterisk with \"aaa\" to get \"aaab\" (which is equal to a) or with \"zzz\" to get \"zzzb\" (which is equal to b).\nIn the third testcase, a template \"*o*\" is not asterisk-minor, as it contains more asterisks than letters. There are no asterisk-minor templates that both a and b match.\nIn the fourth testcase, for a template \"a*a*a*a\", you can replace all asterisks with empty strings to get \"aaaa\" (which is equal to a) or two of them with \"a\" and two of them with an empty string to get \"aaaaaa\" (which is equal to b).\nIn the fifth testcase, there are no asterisks in a template \"abcd\", so only \"abcd\" can match it (which is coincidentally both a and b).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1796B - Asterisk-Minor TemplateWhat's the reason behind authors specifically asking for templates that have less or equal asterisks than letters? Well, without that the problem would be kind of trivial. A template \"*\" is matched by every string, so it would always work.Hmm, let's try to make something similar to that template then. We basically have to find some part of that occurs in both strings that we can use letters on to get some freedom to use asterisks.There are some easy cases. If the first letters of both strings are the same, then the template can be that letter followed by an asterisk. There's a symmetrical case for the last letter.By studying the examples, you can also notice the final case: a common substring of both strings of length at least two surrounded by two asterisks. Moreover, since we only use two asterisks, we can find a substring of length exactly two (which always exists if a longer common substring exists).Turns out, that's it. If a template exists, one of these three kinds also exists.This is not that hard to show. If the first two kinds don't work, then you have to use asterisks on both sides of the template. In order for the template with asterisks on both sides to work, there have to be adjacent letters in it at least once (otherwise, it's like \"*a*a*a*\", and there are more asterisks than letters). And since at least one such substring exists, we can just remove everything other than this substring and the asterisks on the sides.Overall complexity: O(|a|\u22c5|b|) per testcase. Solution (awoo)for _ in range(int(input())):\n    a = input()\n    b = input()\n    if a[0] == b[0]:\n        print(\"YES\")\n        print(a[0] + \"*\")\n        continue\n    if a[-1] == b[-1]:\n        print(\"YES\")\n        print(\"*\" + a[-1])\n        continue\n    for i in range(len(b) - 1):\n        if (b[i] + b[i + 1]) in a:\n            print(\"YES\")\n            print(\"*\" + b[i] + b[i + 1] + \"*\")\n            break\n    else:\n        print(\"NO\")"
    },
    "1793C": {
        "title": "C. Dora and Search",
        "description": "As you know, the girl Dora is always looking for something. This time she was given a permutation, and she wants to find such a subsegment of it that none of the elements at its ends is either the minimum or the maximum of the entire subsegment. More formally, you are asked to find the numbers l and r (1\u2264l\u2264r\u2264n) such that al\u2260min(al,al+1,\u2026,ar), al\u2260max(al,al+1,\u2026,ar) and ar\u2260min(al,al+1,\u2026,ar), ar\u2260max(al,al+1,\u2026,ar).\nA permutation of length n is an array consisting of n distinct integers from 1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 occurs twice in the array) and [1,3,4] is also not a permutation (n=3, but 4 is present in the array).\nHelp Dora find such a subsegment, or tell her that such a subsegment does not exist.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nFor each test case, the first line contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the length of permutation.\nThe second line contains n distinct integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of permutation. \nIt is guarented that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output \u22121 if the desired subsegment does not exist.\nOtherwise, output two indexes l,r such that [al,al+1,\u2026,ar] satisfies all conditions.\nIf there are several solutions, then output any of them.\nIn the first and fourth test cases, it can be shown that there are no desired subsegments.\nIn the second test case, the subsegment [1,4] satisfies all the conditions, because max(a1,a2,a3,a4)=4,min(a1,a2,a3,a4)=1, as we see, all the conditions are met.\nIn the third test case, the subsegment [2,6] also satisfies all the conditions described.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "two pointers",
            "*1200"
        ],
        "solutions": "1793C - Dora and SearchSuppose we want to check whether the entire array satisfies the claim. If this is the case, then we can output the entire array as an answer. Otherwise, one of the two extreme elements does not meet our requirements. From this we can conclude that all segments containing an element that does not meet our requirements will also be incorrect, because this extreme element will remain the minimum/maximum.The algorithm follows from the fact above: let's look at the sub-section [l;r], which is initially equal to [1;n]. If al=min(al,al+1,\u2026,ar) or al=max(al,al+1,\u2026,ar), then we proceed to the segment [l+1;r]. A similar reasoning is also needed for ar. Thus, either after some iterations we will get the required sub-section, or we will get l==r and the answer will be \u22121.Final asymptotics: O(nlogn) or O(n) depending on the implementation. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vi a(n);\n    for (int &i: a)\n        cin >> i;\n    int l = 0, r = n - 1;\n    int mn = 1, mx = n;\n    while (l <= r) {\n        if (a[l] == mn) {\n            l++;\n            mn++;\n        } else if (a[l] == mx) {\n            l++;\n            mx--;\n        } else if (a[r] == mn) {\n            r--;\n            mn++;\n        } else if (a[r] == mx) {\n            r--;\n            mx--;\n        } else {\n            break;\n        }\n    }\n    if(l <= r){\n        cout << l + 1 << \" \" << r + 1 << endl;\n    } else{\n        cout << -1 << endl;\n    }\n}\n\nsigned main() {\n    int q = 1;\n    cin >> q;\n    while (q--)\n        solve();\n    return 0;\n}"
    },
    "1793B": {
        "title": "B. Fedya and Array",
        "description": "For his birthday recently Fedya was given an array a of n integers arranged in a circle, For each pair of neighboring numbers (a1 and a2, a2 and a3, \u2026, an\u22121 and an, an and a1) the absolute difference between them is equal to 1.\nLet's call a local maximum an element, which is greater than both of its neighboring elements. Also call a local minimum an element, which is less than both of its neighboring elements. Note, that elements a1 and an are neighboring elements.\nUnfortunately, Fedya lost an array, but he remembered in it the sum of local maximums x and the sum of local minimums y.\nGiven x and y, help Fedya find any matching array of minimum length.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nEach line of each test case contain two integers x and y (\u2212109\u2264y<x\u2264109) \u2014 the sum of local maximums and the sum of local minimums, respectively.\nFor each test case, in the first line print one integer n \u2014 the minimum length of matching arrays.\nIn the second line print n integers a1,a2,\u2026,an (\u2212109\u2a7dai\u2a7d109) \u2014 the array elements such that the the absolute difference between each pair of neighboring is equal to 1.\nIf there are multiple solutions, print any of them.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nIn the first test case, the local maximums are the numbers at 3,7 and 10 positions, and the local minimums are the numbers at 1,6 and 8 positions. x=a3+a7+a10=2+0+1=3, y=a1+a6+a8=0+(\u22121)+(\u22121)=\u22122.\nIn the second test case, the local maximums are the numbers at 2 and 10 positions, and the local minimums are the numbers at 1 and 3 positions. x=a2+a10=\u22121+5=4, y=a1+a3=\u22122+(\u22122)=\u22124.\nIn the third test case, the local maximums are the numbers at 1 and 5 positions, and the local minimums are the numbers at 3 and 6 positions.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1793B - Fedya and ArrayNote that the local minimums and maximums will alternate, and there will be the same number of them kk. Let's call the ii-th local maximum by aiai, the ii-th local minimum by bibi. Without loss of generality, consider that aiai goes before bibi. To get bibi from aiai we need to write out ai\u2212biai\u2212bi numbers, to get a(i+1)modka(i+1)modk from bibi we need to write out a(i+1)modk\u2212bia(i+1)modk\u2212bi numbers. Thus, (a1\u2212b1)+(a2\u2212b1)+(a2\u2212b2)+\u2026+(ak\u2212bk)+(a1\u2212bk)=(a1\u2212b1)+(a2\u2212b1)+(a2\u2212b2)+\u2026+(ak\u2212bk)+(a1\u2212bk)= =2\u22c5(a1+a2+\u2026+ak)\u22122\u22c5(b1+b2+\u2026+bk)=2\u22c5(A\u2212B)=n=2\u22c5(a1+a2+\u2026+ak)\u22122\u22c5(b1+b2+\u2026+bk)=2\u22c5(A\u2212B)=nThe array [y,y+1,y+2,\u2026,x\u22121,x,x\u22121,x\u22122,\u2026,y+1][y,y+1,y+2,\u2026,x\u22121,x,x\u22121,x\u22122,\u2026,y+1] will satisfy the condition. Code#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nvoid solve() {\n    ll a, b;\n    cin >> a >> b;\n    ll n = 2 * (a - b);\n    cout << n << '\\n';\n    vector<ll> arr(n);\n    int ptr = 0;\n    for (ll c = b; c <= a; ++c) {\n        arr[ptr++] = c;\n    }\n    for (ll c = a - 1; c > b; --c) {\n        arr[ptr++] = c;\n    }\n    for (int i = 0; i < n; ++i) {\n        cout << arr[i] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}"
    },
    "1792B": {
        "title": "B. Stand-up Comedian",
        "description": "Eve is a beginner stand-up comedian. Her first show gathered a grand total of two spectators: Alice and Bob.\nEve prepared a1+a2+a3+a4 jokes to tell, grouped by their type: \nInitially, both spectators have their mood equal to 0. When a spectator hears a joke he/she likes, his/her mood increases by 1. When a spectator hears a joke he/she doesn't like, his/her mood decreases by 1. If the mood of a spectator becomes negative (strictly below zero), he/she leaves.\nWhen someone leaves, Eve gets sad and ends the show. If no one leaves, and Eve is out of jokes, she also ends the show.\nThus, Eve wants to arrange her jokes in such a way that the show lasts as long as possible. Help her to calculate the maximum number of jokes she can tell before the show ends.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains four integers a1,a2,a3,a4 (0\u2264a1,a2,a3,a4\u2264108; a1+a2+a3+a4\u22651)\u00a0\u2014 the number of jokes of each type Eve prepared.\nFor each testcase, print a single integer\u00a0\u2014 the maximum number of jokes Eve can tell before at least one of the spectators leaves or before she runs out of jokes.\nIn the first testcase, Eve only has jokes of the first type. Thus, there's no order to choose. She tells all her jokes, both Alice and Bob like them. Their mood becomes 5. The show ends after Eve runs out of jokes.\nIn the second testcase, Eve only has jokes of the fourth type. Thus, once again no order to choose. She tells a joke, and neither Alice, nor Bob likes it. Their mood decrease by one, becoming \u22121. They both have negative mood, thus, both leave, and the show ends.\nIn the third testcase, first, Eve tells both jokes of the first type. Both Alice and Bob has mood 2. Then she can tell 2 jokes of the third type. Alice's mood becomes 0. Bob's mood becomes 4. Then 4 jokes of the second type. Alice's mood becomes 4. Bob's mood becomes 0. Then another 4 jokes of the third type. Alice's mood becomes 0. Bob's mood becomes 4. Then the remaining joke of the second type. Alice's mood becomes 1. Bob's mood becomes 3. Then one more joke of the third type, and a joke of the fourth type, for example. Alice's mood becomes \u22121, she leaves, and the show ends. \nIn the fourth testcase, Eve should first tell the jokes both spectators like, then the jokes they don't. She can tell 4 jokes of the fourth type until the spectators leave.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1792B - Stand-up ComedianFirst, let Eve tell the jokes of the first type\u00a0\u2014 they will never do any harm. At the same time, let her tell the jokes of the fourth time at the very end\u00a0\u2014 they will not do any good.Types two and three are kind of opposites of each other. If you tell jokes of each of them one after another, then the moods of both spectators don't change. Let's use that to our advantage. Tell the jokes of these types in pairs until one of them runs out. There's a little corner case here, though. If there were no jokes of the first type, then you can't use a single pair because of the spectators leaves after one joke.Finally, try to tell the remaining jokes of the same type before the fourth type. So the construction looks like 1,1,\u2026,1,2,3,2,3,\u2026,2,3,2,2,2,\u2026,2,4,4,4,\u2026,4 with 2 and 3 possibly swapped with each other.Let's recover the answer from that construction. After the first type, both moods are a1. After the alternating jokes, the moods are still the same. After that, one of the spectators will have his/her mood only decreasing until the end. Once it reaches \u22121, the show ends.Thus, Eve can tell a1+min(a2,a3)\u22c52+min(a1+1,abs(a2\u2212a3)+a4) jokes if a1\u22600. Otherwise, it's always 1.Overall complexity: O(1). Solution (awoo)for _ in range(int(input())):\n    a1, a2, a3, a4 = map(int, input().split())\n    if a1 == 0:\n        print(1)\n    else:\n        print(a1 + min(a2, a3) * 2 + min(a1 + 1, abs(a2 - a3) + a4))"
    },
    "1791G1": {
        "title": "G1. Teleporters (Easy Version)",
        "description": "The only difference between the easy and hard versions are the locations you can teleport to.\nConsider the points 0,1,\u2026,n on the number line. There is a teleporter located on each of the points 1,2,\u2026,n. At point i, you can do the following:\nYou have c coins, and you start at point 0. What's the most number of teleporters you can use?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains two integers n and c (1\u2264n\u22642\u22c5105; 1\u2264c\u2264109) \u00a0\u2014 the length of the array and the number of coins you have respectively.\nThe following line contains n space-separated integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the costs to use the teleporters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum number of teleporters you can use.\nIn the first test case, you can move one unit to the right, use the teleporter at index 1 and teleport to point 0, move two units to the right and use the teleporter at index 2. You are left with 6\u22121\u22121\u22122\u22121=1 coins you don't have enough coins to use another teleporter. You have used two teleporters, so the answer is two.\nIn the second test case, you go four units to the right and use the teleporter to go to 0, then go six units right and use the teleporter at index 6 to go to 0. The total cost will be 4+6+6+4=20. You are left with 12 coins, but it is not enough to reach any other teleporter and use it so the answer is 2.\nIn the third test case, you don't have enough coins to use any teleporter, so the answer is zero.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1791G1 - Teleporters (Easy Version)It's easy to see that it's optimal to only move right or to use a portal once we are at it. We can notice that when we teleport back, the problem is independent of the previous choices. We still are at point 0 and have some portals left. Thus, we can just find out the individual cost of each portal, sort portals by individual costs, and take them from smallest to largest by cost as long as we can. The cost of portal i is i+ai (since we pay ai to use it and need i moves to get to it). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvoid solve() {\n    int n, c, ans = 0; cin >> n >> c;\n    priority_queue<int> q;\n    for(int i = 1, x; i <= n; ++i) {\n        cin >> x;\n        q.push(-x - i);\n    }\n    while(!q.empty()) {\n        int x = -q.top(); q.pop();\n        if(x > c) break;\n        ++ans;\n        c -= x;\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}"
    },
    "1791E": {
        "title": "E. Negatives and Positives",
        "description": "Given an array a consisting of n elements, find the maximum possible sum the array can have after performing the following operation any number of times: \nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum possible sum the array can have after performing the described operation any number of times.\nFor the first test case, by performing the operation on the first two elements, we can change the array from [\u22121,\u22121,\u22121] to [1,1,\u22121], and it can be proven this array obtains the maximum possible sum which is 1+1+(\u22121)=1.\nFor the second test case, by performing the operation on \u22125 and 0, we change the array from [1,5,\u22125,0,2] to [1,5,\u2212(\u22125),\u22120,2]=[1,5,5,0,2], which has the maximum sum since all elements are non-negative. So, the answer is 1+5+5+0+2=13.\nFor the third test case, the array already contains only positive numbers, so performing operations is unnecessary. The answer is just the sum of the whole array, which is 1+2+3=6.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1791E - Negatives and PositivesIdea: SlavicG TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    while(t--) {\n        int n; cin >> n;\n        vector<int> a(n);\n        long long sum = 0;\n        int negs = 0;\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i];\n            if(a[i] < 0) {\n                ++negs;\n                a[i] = -a[i];\n            }\n            sum += a[i];\n        }\n        sort(a.begin(), a.end());\n        if(negs & 1) sum -= 2 * a[0];\n        cout << sum << \"\\n\";\n    }\n}"
    },
    "1791D": {
        "title": "D. Distinct Split",
        "description": "Let's denote the f(x) function for a string x as the number of distinct characters that the string contains. For example f(abc)=3, f(bbbbb)=1, and f(babacaba)=3.\nGiven a string s, split it into two non-empty strings a and b such that f(a)+f(b) is the maximum possible. In other words, find the maximum possible value of f(a)+f(b) such that a+b=s (the concatenation of string a and string b is equal to string s).\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string s.\nThe second line contains the string s, consisting of lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum possible value of f(a)+f(b) such that a+b=s.\nFor the first test case, there is only one valid way to split aa into two non-empty strings a and a, and f(a)+f(a)=1+1=2.\nFor the second test case, by splitting abcabcd into abc and abcd we can get the answer of f(abc)+f(abcd)=3+4=7 which is maximum possible.\nFor the third test case, it doesn't matter how we split the string, the answer will always be 2.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1000"
        ],
        "solutions": "1791D - Distinct SplitIdea: SlavicG TutorialTutorial is loading... Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvoid solve() {\n    int n; string s; cin >> n >> s;\n    vector<int> cnt(26, 0), p(26, 0);\n    for(auto x: s) cnt[x - 'a']++;\n    int ans = 0;\n    for(auto x: s) {\n        --cnt[x - 'a'];\n        ++p[x - 'a'];\n        int cur = 0;\n        for(int i = 0; i < 26; ++i) {\n            cur += min(1, cnt[i]) + min(1, p[i]);\n        }\n        ans = max(ans, cur);\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}"
    },
    "1790D": {
        "title": "D. Matryoshkas",
        "description": "Matryoshka is a wooden toy in the form of a painted doll, inside which you can put a similar doll of a smaller size.\nA set of nesting dolls contains one or more nesting dolls, their sizes are consecutive positive integers. Thus, a set of nesting dolls is described by two numbers: s \u2014 the size of a smallest nesting doll in a set and m \u2014 the number of dolls in a set. In other words, the set contains sizes of s,s+1,\u2026,s+m\u22121 for some integer s and m (s,m>0).\nYou had one or more sets of nesting dolls. Recently, you found that someone mixed all your sets in one and recorded a sequence of doll sizes \u2014 integers a1,a2,\u2026,an.\nYou do not remember how many sets you had, so you want to find the minimum number of sets that you could initially have.\nFor example, if a given sequence is a=[2,2,3,4,3,1]. Initially, there could be 2 sets: \nAccording to a given sequence of sizes of nesting dolls a1,a2,\u2026,an, determine the minimum number of nesting dolls that can make this sequence.\nEach set is completely used, so all its nesting dolls are used. Each element of a given sequence must correspond to exactly one doll from some set.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the total number of matryoshkas that were in all sets.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u00a0\u2014 the sizes of the matryoshkas. \nIt is guaranteed that the sum of values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print one integer k \u2014 the minimum possible number of matryoshkas sets.\nThe first test case is described in the problem statement.\nIn the second test case, all matryoshkas could be part of the same set with minimum size s=7.\nIn the third test case, each matryoshka represents a separate set.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1790D - MatryoshkasFirst, for each size, let's count cnts \u2014 the number of dolls of this size.Then, let's create a set, in which for each doll of size s we add the numbers s and s+1. This will allow you to process all the segments, as well as the dimensions adjacent to them.We will iterate over the set in ascending order of size. Let x be the number of matryoshkas of the current size, y \u2014 of the previous one considered (0 at the beginning). If the numbers do not match, then you need to close (if x<y), or open (if x>y) |x\u2212y| segments. It is enough to add only the opening of the segments to the answer. Solution#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    map<int, int> cnt;\n    set<int> b;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n        cnt[a[i]]++;\n        b.insert(a[i]);\n        b.insert(a[i] + 1);\n    }\n    int last = 0;\n    int res = 0;\n    for (auto x: b) {\n        int c = cnt[x];\n        res += max(0, c - last);\n        last = c;\n    }\n    cout << res << '\\n';\n}\n\nint main(int argc, char* argv[]) {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; ++i) {\n        solve();\n    }\n}"
    },
    "1790C": {
        "title": "C. Premutation",
        "description": "A sequence of n numbers is called permutation if it contains all integers from 1 to n exactly once. For example, the sequences [3,1,4,2], [1] and [2,1] are permutations, but [1,2,1], [0,1] and [1,3,4]\u00a0\u2014 are not.\nKristina had a permutation p of n elements. She wrote it on the whiteboard n times in such a way that: \nFor example, suppose Kristina had a permutation p = [4,2,1,3] of length 4. Then she did the following: \nYou know all n of sequences that have been written on the whiteboard, but you do not know the order in which they were written. They are given in arbitrary order. Reconstruct the original permutation from them.\nFor example, if you know the sequences [4,2,1], [4,2,3], [2,1,3], [4,1,3], then the original permutation will be p = [4,2,1,3].\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (3\u2264n\u2264100).\nThis is followed by n lines, each containing exactly n\u22121 integers and describing one of the sequences written out on the whiteboard.\nIt is guaranteed that all sequences could be obtained from some permutation p, and that the sum n2 over all input sets does not exceed 2\u22c5105.\nFor each test case, output on a separate line a permutation p such that the given n sequences could be obtained from it.\nIt is guaranteed that the answer exists and it is the only one. In other words, for each test case the required permutation is sure to exist.\nThe first test case is described in the problem statement.\nIn the second test case, the sequences are written in the correct order.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1790C - PremutationIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include \"bits/stdc++.h\"\nusing namespace std;\nint n;\n\nvoid solve(){\n    cin >> n;\n    vector<vector<int>>perm(n, vector<int>(n - 1));\n    vector<int>p(n, 0);\n    vector<int>cnt(n + 1, 0);\n    for(int i = 0; i < n; i++){\n        p[i] = i + 1;\n        for(int j = 0; j < n - 1; j++){\n            cin >> perm[i][j];\n            if(j == 0) cnt[perm[i][j]]++;\n        }\n    }\n    for(int i = 1; i <= n; i++){\n        if(cnt[i] == n - 1){\n            p[0] = i;\n            break;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(perm[i][0] != p[0]){\n            for(int j = 0; j < n - 1; j++){\n                p[j + 1] = perm[i][j];\n            }\n        }\n    }\n    for(int i = 0; i < n; i++) cout << p[i] << ' ';\n    cout << endl;\n\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
    },
    "1788B": {
        "title": "B. Sum of Two Numbers",
        "description": "The sum of digits of a non-negative integer a is the result of summing up its digits together when written in the decimal system. For example, the sum of digits of 123 is 6 and the sum of digits of 10 is 1. In a formal way, the sum of digits of a=\u221e\u2211i=0ai\u22c510i, where 0\u2264ai\u22649, is defined as \u221e\u2211i=0ai.\nGiven an integer n, find two non-negative integers x and y which satisfy the following conditions.\nIt can be shown that such x and y always exist.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226410000). \nEach test case consists of a single integer n (1\u2264n\u2264109)\nFor each test case, print two integers x and y.\nIf there are multiple answers, print any.\nIn the second test case, the sum of digits of 67 and the sum of digits of 94 are both 13.\nIn the third test case, the sum of digits of 60 is 6, and the sum of digits of 7 is 7.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "probabilities",
            "*1100"
        ],
        "solutions": "1788B - Sum of Two NumbersLet's assume that there is no carry while adding x and y. Denote n=a9\u22efa1a0, x=b9\u22efb1b0, y=c9\u22efc1c0 in decimal system. The condition can be changed as the following condition.- ai=bi+ci for all 0\u2264i\u22649. - Sum of bi and sum of ci should differ by at most 1.If ai is even, let bi=ci=ai/2. Otherwise, let bi and ci be ai+12 or ai\u221212. By alternating between (bi,ci)=(ai+12,ai\u221212) and (bi,ci)=(ai\u221212,ai+12), we can satisfy the condition where sum of bi and sum of ci differ by at most 1.There is an alternative solution. If n is even, divide it into (n2,n2). If remainder of n divided by 10 is not 9, divide it into (n+12,n\u221212). If remainder of n divided by 10 is 9, recursively find an answer for \u230an10\u230b which is (x\u2032,y\u2032) and the answer will be (10x\u2032+4,10y\u2032+5) or (10x\u2032+5,10y\u2032+4) depending on what number has a bigger sum of digits.The following solution has a countertest.1. Trying to find x and y by bruteforce from (1,n\u22121). 2. Trying to find x and y by bruteforce from (n+12,n\u221212)A solution that randomly finds (x,y) passes."
    },
    "1787B": {
        "title": "B. Number Factorization",
        "description": "Given an integer n.\nConsider all pairs of integer arrays a and p of the same length such that n=\u220fapii (i.e. ap11\u22c5ap22\u22c5\u2026) (ai>1;pi>0) and ai is the product of some (possibly one) distinct prime numbers.\nFor example, for n=28=22\u22c571=41\u22c571 the array pair a=[2,7], p=[2,1] is correct, but the pair of arrays a=[4,7], p=[1,1] is not, because 4=22 is a product of non-distinct prime numbers.\nYour task is to find the maximum value of \u2211ai\u22c5pi (i.e. a1\u22c5p1+a2\u22c5p2+\u2026) over all possible pairs of arrays a and p. Note that you do not need to minimize or maximize the length of the arrays.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22641000) \u2014 the number of test cases. \nEach test case contains only one integer n (2\u2264n\u2264109).\nFor each test case, print the maximum value of \u2211ai\u22c5pi.\nIn the first test case, 100=102 so that a=[10], p=[2] when \u2211ai\u22c5pi hits the maximum value 10\u22c52=20. Also, a=[100], p=[1] does not work since 100 is not made of distinct prime factors.\nIn the second test case, we can consider 10 as 101, so a=[10], p=[1]. Notice that when 10=21\u22c551, \u2211ai\u22c5pi=7.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1787B - Number FactorizationFirst, apii is equivalent to the product of a1i for p times, so it is sufficient to set all pi to 1.Decomposite n to some prime factors, greedily choose the most number of distinct prime numbers, the product is the maximum. Solution#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\npair<int, int> s[110];\nint d[110];\nvoid get() {\n\tint n, l = 0, i, c;\n\tcin >> n;\n\tfor (i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tc = 0;\n\t\t\twhile (n % i == 0) c++, n /= i;\n\t\t\ts[++l] = make_pair(c, i);\n\t\t}\n\t}\n\tif (n != 1) s[++l] = make_pair(1, n);\n\tsort(s + 1, s + l + 1), d[l + 1] = 1;\n\tfor (i = l; i >= 1; i--) d[i] = d[i + 1] * s[i].second;\n\tint ans = 0;\n\tfor (i = 1; i <= l; i++) if (s[i].first != s[i - 1].first) ans += d[i] * (s[i].first - s[i - 1].first);\n\tcout << ans << endl;\n}\nsigned main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile (T--) get();\n\treturn 0;\n}"
    },
    "1784A": {
        "title": "A. Monsters (easy version)",
        "description": "This is the easy version of the problem. In this version, you only need to find the answer once. In this version, hacks are not allowed.\nIn a computer game, you are fighting against n monsters. Monster number i has ai health points, all ai are integers. A monster is alive while it has at least 1 health point.\nYou can cast spells of two types:\nDealing 1 damage to a monster reduces its health by 1.\nSpells of type 1 can be cast any number of times, while a spell of type 2 can be cast at most once during the game.\nWhat is the smallest number of times you need to cast spells of type 1 to kill all monsters?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nEach test case consists of two lines. The first line contains a single integer n\u00a0(1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of monsters.\nThe second line contains n integers a1,a2,\u2026,an\u00a0(1\u2264ai\u2264n)\u00a0\u2014 monsters' health points.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the smallest number of times you need to cast spells of type 1 to kill all monsters.\nIn the first test case, the initial health points of the monsters are [3,1,2]. It is enough to cast a spell of type 2: \nSince it is possible to use no spells of type 1 at all, the answer is 0.\nIn the second test case, the initial health points of the monsters are [4,1,5,4,1,1]. Here is one of the optimal action sequences: \nSpells of type 1 are cast 4 times in total. It can be shown that this is the smallest possible number.",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1783B": {
        "title": "B. Matrix of Differences",
        "description": "For a square matrix of integers of size n\u00d7n, let's define its beauty as follows: for each pair of side-adjacent elements x and y, write out the number |x\u2212y|, and then find the number of different numbers among them.\nFor example, for the matrix (1342) the numbers we consider are |1\u22123|=2, |1\u22124|=3, |3\u22122|=1 and |4\u22122|=2; there are 3 different numbers among them (2, 3 and 1), which means that its beauty is equal to 3.\nYou are given an integer n. You have to find a matrix of size n\u00d7n, where each integer from 1 to n2 occurs exactly once, such that its beauty is the maximum possible among all such matrices.\nThe first line contains a single integer t (1\u2264t\u226449)\u00a0\u2013 the number of test cases.\nThe first (and only) line of each test case contains a single integer n (2\u2264n\u226450).\nFor each test case, print n rows of n integers\u00a0\u2014 a matrix of integers of size n\u00d7n, where each number from 1 to n2 occurs exactly once, such that its beauty is the maximum possible among all such matrices. If there are multiple answers, print any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1783B - Matrix of DifferencesThe first step is to notice that beauty doesn't exceed n2\u22121, because the minimum difference between two elements is at least 1, and the maximum difference does not exceed n2\u22121 (the difference between the maximum element n2 and the minimum element 1).At first, finding a matrix with maximum beauty seems to be a quite difficult task. So let's try to find an array of n2 elements of maximum beauty. In this case, it is not difficult to come up with an array of the form [n2,1,n2\u22121,2,n2\u22122,3,\u2026]. In such an array, there are all possible differences from 1 to n2\u22121. So we found an array with the maximum possible beauty.It remains to find a way to \"convert\" the array to the matrix, i.e. to find such a sequence of matrix cells that each two adjacent cells in it are side-adjacent. One of the ways is the following: traverse the first row of the matrix from left to right, go down to the second row, traverse it from right to left, go down to the third row, traverse it from left to right, and so on.Thus, we constructed a matrix with the maximum possible beauty n2\u22121. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    int l = 1, r = n * n, t = 0;\n    forn(i, n) {\n      forn(j, n) {\n        if (t) a[i][j] = l++;\n        else a[i][j] = r--;\n        t ^= 1;\n      }\n      if (i & 1) reverse(a[i].begin(), a[i].end());\n    }\n    forn(i, n) forn(j, n) cout << a[i][j] << \" \\n\"[j == n - 1];\n  }\n}"
    },
    "1781B": {
        "title": "B. Going to the Cinema",
        "description": "A company of n people is planning a visit to the cinema. Every person can either go to the cinema or not. That depends on how many other people will go. Specifically, every person i said: \"I want to go to the cinema if and only if at least ai other people will go, not counting myself\". That means that person i will become sad if: \nIn how many ways can a set of people going to the cinema be chosen so that nobody becomes sad?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nEach test case consists of two lines. The first line contains a single integer n\u00a0(2\u2264n\u22642\u22c5105)\u00a0\u2014 the number of people in the company.\nThe second line contains n integers a1,a2,\u2026,an\u00a0(0\u2264ai\u2264n\u22121)\u00a0\u2014 integers from peoples' claims.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the number of different ways to choose a set of people going to the cinema so that nobody becomes sad.\nIn the first test case, both people want to go to the cinema if and only if the other person goes. There are two valid options: either both people go, or neither of them goes. However, if just one of them goes, both will be sad.\nIn the second test case, everyone has to go to the cinema. In any other case, someone will be sad.\nIn the third test case, there are three valid options: person number 2 goes to the cinema; or persons with indices 2,3,4,7 go; or all eight people go.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1780B": {
        "title": "B. GCD Partition",
        "description": "While at Kira's house, Josuke saw a piece of paper on the table with a task written on it.\nThe task sounded as follows. There is an array a of length n. On this array, do the following:\nThe task is to find such a partition that the score is maximum possible. Josuke is interested in this task but is not strong in computer science. Help him to find the maximum possible score.\n\u2020 A division of an array into k subsegments is k pairs of numbers (l1,r1),(l2,r2),\u2026,(lk,rk) such that li\u2264ri and for every 1\u2264j\u2264k\u22121 lj+1=rj+1, also l1=1 and rk=n. These pairs represent the subsegments.\n\u2021 gcd(b1,b2,\u2026,bk) stands for the greatest common divisor (GCD) of the array b.\nThe first line contains a single number t (1\u2264t\u2264104) \u2014 the number of test cases.\nFor each test case, the first line contains one integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the array a.\nThe second line contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264109) \u2014 the array a itself.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print a single integer \u2014 the maximum score for the optimal partition.\nIn the first test case, you can choose k=2 and split the array into subsegments (1,2) and (3,4).\nThen the score of such a partition will be equal to gcd(a1+a2,a3+a4)=gcd(2+2,1+3)=gcd(4,4)=4.\nIn the fourth test case, you can choose k=3 and split the array into subsegments (1,2),(3,5),(6,6).\nThe split score is gcd(1+2,1+1+1,3)=3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1780B - GCD PartitionIdea: RedMachine-74  Preparation: qualdoom  Editorialist: qualdoom TutorialLet's note that it doesn't make sense for us to divide into more than k=2 subsegments. Let's prove it.Let us somehow split the array a into m>2 subsegments : b1,b2,\u2026,bm. Note that gcd(b1,b2,\u2026,bm)\u2264gcd(b1+b2,b3,\u2026,bm), since if b1 and b2 were multiples of gcd(b1,b2,\u2026,bm), so b1+b2 is also a multiple of gcd(b1,b2,\u2026,bm). This means that we can use b1+b2 instead of b1 and b2, and the answer will not worsen, thus it is always beneficial to use no more than k=2 subsegments.How to find the answer? Let s be the sum of the array a. Let's say prefi=\u2211ij=1aj, then the answer is max1\u2264i<n(gcd(prefi,s\u2212prefi). Implementation (Python)from math import gcd\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    s = 0\n    for i in range(n):\n        s += a[i]\n    ans = 0\n    pref = 0\n    for i in range(n - 1):\n        pref += a[i]\n        ans = max(ans, gcd(pref, s - pref))\n    print(ans) Implementation (\u0421++)#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T = 1;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) cin >> a[i];\n        long long s = accumulate(a.begin(), a.end(), 0ll), cur = 0;\n        long long ans = 1;\n        for (int i = 0; i < n - 1; i++) {\n            cur += a[i], s -= a[i];\n            ans = max(ans, __gcd(s, cur));\n        }\n        cout << ans << \"\\n\";\n    }\n}"
    },
    "1772C": {
        "title": "C. Different Differences",
        "description": "An array a consisting of k integers is strictly increasing if a1<a2<\u22ef<ak. For example, the arrays [1,3,5], [1,2,3,4], [3,5,6] are strictly increasing; the arrays [2,2], [3,7,5], [7,4,3], [1,2,2,3] are not.\nFor a strictly increasing array a of k elements, let's denote the characteristic as the number of different elements in the array [a2\u2212a1,a3\u2212a2,\u2026,ak\u2212ak\u22121]. For example, the characteristic of the array [1,3,4,7,8] is 3 since the array [2,1,3,1] contains 3 different elements: 2, 1 and 3.\nYou are given two integers k and n (k\u2264n). Construct an increasing array of k integers from 1 to n with maximum possible characteristic.\nThe first line contains one integer t (1\u2264t\u2264819) \u2014 the number of test cases.\nEach test case consists of one line containing two integers k and n (2\u2264k\u2264n\u226440).\nFor each test case, print k integers \u2014 the elements of the strictly increasing array a with the maximum possible characteristic. If there are multiple answers, print any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1772C - Different DifferencesWe can transform the problem as follows. Let di=ai+1\u2212ai. We need to find an array [d1,d2,\u2026,dk\u22121] so that the sum of elements in it is not greater than n\u22121, all elements are positive integers, and the number of different elements is the maximum possible.Suppose we need f different elements in d. What can be the minimum possible sum of elements in d? It's easy to see that d should have the following form: [2,3,4,\u2026,f,1,1,1,\u2026,1]. This array contains exactly f different elements, these different elements are as small as possible (so their sum is as small as possible), and all duplicates are 1's. So, if the sum of this array is not greater than n\u22121, then it is possible to have the number of different elements in d equal to f.The rest is simple. We can iterate on f, find the maximum possible f, construct the difference array, and then use it to construct the array a itself. Solution (BledDest)def construct(f, k):\n    return [(i + 2 if i < f - 1 else 1) for i in range(k)]\n\nt = int(input())\nfor i in range(t):\n    k, n = map(int, input().split())\n    ans = 1\n    for f in range(1, k):\n        d = construct(f, k - 1)\n        if sum(d) <= n - 1:\n            ans = f\n    res = [1]\n    d = construct(ans, k - 1)\n    for x in d:\n        res.append(res[-1] + x)\n    print(*res)"
    },
    "1770B": {
        "title": "B. Koxia and Permutation",
        "description": "Reve has two integers n and k.\nLet p be a permutation\u2020 of length n. Let c be an array of length n\u2212k+1 such that ci=max(pi,\u2026,pi+k\u22121)+min(pi,\u2026,pi+k\u22121). Let the cost of the permutation p be the maximum element of c.\nKoxia wants you to construct a permutation with the minimum possible cost.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers p1,p2,\u2026,pn, which is a permutation with minimal cost. If there is more than one permutation with minimal cost, you may output any of them.\nIn the first test case,\nTherefore, the cost is max(6,4,6)=6. It can be proven that this is the minimal cost.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1770B - Koxia and PermutationIdea by m_99 Hint 1For k=1, the cost is always 2n for any permutation. Hint 2For k\u22652, the minimal cost is always n+1. SolutionWhen k=1 every permutation has the same cost.When k\u22652, the minimal cost will be at least n+1. This is because there will always be at least one segment containing the element n in the permutation, contributing n to the \"max\" part of the sum, and the \"min\" part will add at least 1 to the sum.In fact, the cost n+1 is optimal. It can be achieved by ordering the numbers in the pattern [n,1,n\u22121,2,n\u22122,3,n\u22123,4,\u2026].The time complexity is O(n) for each test case. Other careful constructions should also get Accepted. Code (Nanako)#include <iostream>\n#define MULTI int _T; cin >> _T; while(_T--)\nusing namespace std;\ntypedef long long ll;\n \nint n, k;\n \nint main () {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tMULTI {\n\t\tcin >> n >> k;\n\t\tint l = 1, r = n, _ = 1;\n\t\twhile (l <= r) cout << ((_ ^= 1) ? l++ : r--) << ' ';\n\t\tcout << endl;\n\t}\n}"
    },
    "1770A": {
        "title": "A. Koxia and Whiteboards",
        "description": "Kiyora has n whiteboards numbered from 1 to n. Initially, the i-th whiteboard has the integer ai written on it.\nKoxia performs m operations. The j-th operation is to choose one of the whiteboards and change the integer written on it to bj.\nFind the maximum possible sum of integers written on the whiteboards after performing all m operations.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264100).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bi\u2264109).\nFor each test case, output a single integer \u2014 the maximum possible sum of integers written on whiteboards after performing all m operations.\nIn the first test case, Koxia can perform the operations as follows:\nAfter performing all operations, the numbers on the three whiteboards are 4, 5 and 3 respectively, and their sum is 12. It can be proven that this is the maximum possible sum achievable.\nIn the second test case, Koxia can perform the operations as follows:\nThe sum is 4+5=9. It can be proven that this is the maximum possible sum achievable.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solutions": "1770A - Koxia and WhiteboardsIdea by m_99 Hint 1Exactly n items out of of a1,\u2026,an,b1,\u2026,bm will remain on the whiteboard at the end. Hint 2bm will always remain on the board at the end. Hint 3Consider the case where n=2 and m=2. As we mentioned in hint 2, b2 will always be written, but what about b1? SolutionThis problem can be solved naturally with a greedy algorithm \u2014 for i=1,2,\u2026,m, we use bi to replace the minimal value among the current a1,a2,\u2026,an. The time complexity is O(nm) for each test case.Alternatively, we can first add bm to our final sum. For the remaining (n+m\u22121) integers, we can freely pick (n\u22121) out of them and add it to our final sum. This is because if we want a certain ai to remain on the board at the end, we simply do not touch it in the process. If we want a certain bi to remain on the board at the end, then on the ith operation we replace some aj that we do not want at the end by bi.Using an efficient sorting algorithm gives us a O((n+m)log(n+m)) solution, which is our intended solution. Code (m_99)#include <stdio.h>\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define Inf32 1000000001\n#define Inf64 4000000000000000001\n\nint main(){\n\t\n\tint _t;\n\tcin>>_t;\n\t\n\trep(_,_t){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tvector<long long> a(n+m);\n\t\trep(i,n+m)scanf(\"%lld\",&a[i]);\n\t\t\n\t\tsort(a.begin(),a.end()-1);\n\t\treverse(a.begin(),a.end());\n\t\t\n\t\tlong long ans = 0;\n\t\trep(i,n)ans += a[i];\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
    },
    "1769C1": {
        "title": "C1. \u041f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0430 I",
        "description": "\u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 n\u226450 \u0438 ai\u2264100.\n\u0412\u0438\u043a\u0430 \u0437\u0430 \u0432\u0440\u0435\u043c\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0432 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0438 VK \u0443\u0436\u0435 \u0441\u0434\u0435\u043b\u0430\u043b\u0430 n \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u0432\u0435\u0440\u0441\u0438\u0439. i-\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u0431\u044b\u043b \u0441\u0434\u0435\u043b\u0430\u043d \u0432 ai-\u0439 \u0434\u0435\u043d\u044c \u0440\u0430\u0431\u043e\u0442\u044b \u0412\u0438\u043a\u0438 \u0432 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0438. \u0412 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u043d\u0438 \u0412\u0438\u043a\u0430 \u043c\u043e\u0433\u043b\u0430 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432, \u0430 \u0432 \u0434\u0440\u0443\u0433\u0438\u0435\u00a0\u2014 \u043d\u0435 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0438 \u043e\u0434\u043d\u043e\u0433\u043e.\n\u0412\u0438\u043a\u0443 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u044e\u0442 \u0442\u0430\u043a\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0438 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439, \u0447\u0442\u043e \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u044d\u0442\u0438\u0445 \u0434\u043d\u0435\u0439 \u0443 \u043d\u0435\u0451 \u0435\u0441\u0442\u044c \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442. \u0427\u0435\u043c \u0434\u043b\u0438\u043d\u043d\u0435\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u0430\u043c\u044b\u0439 \u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u0442\u0430\u043a\u043e\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a, \u0442\u0435\u043c \u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0441\u043e\u0442\u0440\u0443\u0434\u043d\u0438\u043a\u043e\u043c \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u0435\u0431\u044f \u043e\u0449\u0443\u0449\u0430\u0442\u044c.\n\u041d\u0435\u0434\u0430\u0432\u043d\u043e \u0412\u0438\u043a\u0430 \u043d\u0430\u0448\u043b\u0430 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u0438\u0442\u044c \u0432\u0440\u0435\u043c\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432\u043f\u0435\u0440\u0451\u0434, \u043d\u043e \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 \u0447\u0435\u043c \u043d\u0430 \u0441\u0443\u0442\u043a\u0438. \u0422\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, i-\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u0442\u0435\u043f\u0435\u0440\u044c \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u00ab\u0441\u0434\u0435\u043b\u0430\u043d\u00bb \u043b\u0438\u0431\u043e \u0432 ai-\u0439, \u043b\u0438\u0431\u043e \u0432 (ai+1)-\u0439 \u0434\u0435\u043d\u044c. \u0412\u0440\u0435\u043c\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u0438\u0442\u044c \u043d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e \u043e\u0442 \u0434\u0440\u0443\u0433\u0438\u0445\u00a0\u2014 \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u043c\u043e\u0436\u043d\u043e \u043a\u0430\u043a \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432\u0441\u0435\u043c \u043a\u043e\u043c\u043c\u0438\u0442\u0430\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f, \u0442\u0430\u043a \u0438 \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u0440\u043e\u0432\u043d\u043e \u043d\u0430 \u0434\u0435\u043d\u044c \u0432\u043f\u0435\u0440\u0451\u0434.\n\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u0434\u043b\u0438\u043d\u0443 \u0441\u0430\u043c\u043e\u0433\u043e \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439, \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0443 \u0412\u0438\u043a\u0438 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u043f\u043e\u0441\u043b\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0439 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432.\n\u041a\u0430\u0436\u0434\u044b\u0439 \u0442\u0435\u0441\u0442 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445. \u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e t (1\u2264t\u2264100)\u00a0\u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445. \u0414\u0430\u043b\u0435\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445.\n\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043d\u0430\u0431\u043e\u0440\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n (1\u2264n\u226450)\u00a0\u2014 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432.\n\u0412\u0442\u043e\u0440\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 n \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b a1,a2,\u2026,an \u0432 \u043d\u0435\u0443\u0431\u044b\u0432\u0430\u044e\u0449\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 (1\u2264a1\u2264a2\u2264\u2026\u2264an\u2264100)\u00a0\u2014 \u043d\u043e\u043c\u0435\u0440\u0430 \u0434\u043d\u0435\u0439, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0431\u044b\u043b\u0438 \u0441\u0434\u0435\u043b\u0430\u043d\u044b \u043a\u043e\u043c\u043c\u0438\u0442\u044b.\n\u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043d\u0430\u0431\u043e\u0440\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\u00a0\u2014 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0443\u044e \u0434\u043b\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0434\u043d\u0435\u0439, \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0443 \u0412\u0438\u043a\u0438 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u043f\u043e\u0441\u043b\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0439 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432\u043f\u0435\u0440\u0451\u0434 \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 \u0447\u0435\u043c \u043d\u0430 \u0441\u0443\u0442\u043a\u0438.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u0434\u0430\u0442\u0443 \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432 \u0434\u0435\u043d\u044c 3 \u043d\u0430 \u0434\u0435\u043d\u044c 4, \u0434\u0430\u0442\u0443 \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432 \u0434\u0435\u043d\u044c 4\u00a0\u2014 \u043d\u0430 \u0434\u0435\u043d\u044c 5, \u0430 \u0434\u0430\u0442\u0443 \u043b\u044e\u0431\u043e\u0433\u043e \u0438\u0437 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432 \u0434\u0435\u043d\u044c 6\u00a0\u2014 \u043d\u0430 \u0434\u0435\u043d\u044c 7. \u0422\u043e\u0433\u0434\u0430 \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u0434\u043d\u0435\u0439 4, 5, 6, 7 \u0438 8 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0412\u0438\u043a\u0438 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u0438 \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0438\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0438\u0437 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439 \u0441 \u043a\u043e\u043c\u043c\u0438\u0442\u0430\u043c\u0438\u00a0\u2014 [4;8]\u00a0\u2014 \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0434\u043b\u0438\u043d\u0443 5.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u043b\u0438\u0431\u043e \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432\u0441\u0435 \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u043a\u0430\u043a \u0435\u0441\u0442\u044c, \u043b\u0438\u0431\u043e \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u043a\u0430\u0436\u0434\u044b\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u043d\u0430 \u0434\u0435\u043d\u044c \u0432\u043f\u0435\u0440\u0451\u0434. \u0412 \u043b\u044e\u0431\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0434\u043b\u0438\u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0434\u043d\u0435\u0439 \u0441\u043e\u0441\u0442\u0430\u0432\u0438\u0442 6.\n\u0412 \u0442\u0440\u0435\u0442\u044c\u0435\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0412\u0438\u043a\u0430 \u0441\u0434\u0435\u043b\u0430\u043b\u0430 \u043c\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432, \u043d\u043e \u0432\u0441\u0435 \u0432 \u043e\u0434\u0438\u043d \u0438 \u0442\u043e\u0442 \u0436\u0435 \u0434\u0435\u043d\u044c \u0441 \u043d\u043e\u043c\u0435\u0440\u043e\u043c 10. \u0412 \u043b\u0443\u0447\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0434\u043d\u0435\u0439 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0435\u0442 \u0434\u043b\u0438\u043d\u044b 2\u00a0\u2014 \u0435\u0441\u043b\u0438 \u043a\u0430\u043a\u0438\u0435-\u0442\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043d\u0430 \u0434\u0435\u043d\u044c 10, \u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u043d\u0430 \u0434\u0435\u043d\u044c 11.",
        "time limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u0441\u04422 \u0441\u0435\u043a\u0443\u043d\u0434\u044b",
        "memory limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u043c\u044f\u0442\u0438 \u043d\u0430 \u0442\u0435\u0441\u0442512 \u043c\u0435\u0433\u0430\u0431\u0430\u0439\u0442",
        "tags": [
            "*special problem",
            "brute force",
            "dp",
            "greedy",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1769B1": {
        "title": "B1. \u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 I",
        "description": "\u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u044e\u0442 1000 \u0431\u0430\u0439\u0442.\n\u0412\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u0442\u0435 \u0441 \u043e\u0434\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043d\u0430 \u0434\u0440\u0443\u0433\u043e\u0439 n \u0444\u0430\u0439\u043b\u043e\u0432 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c a1,a2,\u2026,an \u0431\u0430\u0439\u0442. \u0424\u0430\u0439\u043b\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435.\n\u041f\u0440\u0438 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b \u0432\u0438\u0434\u0438\u0442\u0435 \u0434\u0432\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430: \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u043c \u0444\u0430\u0439\u043b\u0435, \u0430 \u0432\u0442\u043e\u0440\u043e\u0439\u00a0\u2014 \u043e\u0431\u0449\u0438\u0439 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e \u0432\u0441\u0435\u043c n \u0444\u0430\u0439\u043b\u0430\u043c. \u041e\u0431\u0430 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442\u0441\u044f \u043e\u043a\u0440\u0443\u0433\u043b\u0451\u043d\u043d\u044b\u043c\u0438 \u0432\u043d\u0438\u0437 \u0434\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430. \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0431\u0430\u0439\u0442\u0430.\n\u0424\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e, \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0439\u0442\u0430 \u043d\u043e\u043c\u0435\u0440 x \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u043d\u043e\u043c\u0435\u0440 i \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u230a100\u22c5xai\u230b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432, \u0430 \u0432\u0442\u043e\u0440\u043e\u0439\u00a0\u2014 \u230a100\u22c5(a1+a2+\u2026+ai\u22121+x)a1+a2+\u2026+an\u230b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432. \u0412 \u0441\u0430\u043c\u043e\u043c \u043d\u0430\u0447\u0430\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 0 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432.\n\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u0432\u0441\u0435 \u0442\u0430\u043a\u0438\u0435 \u0446\u0435\u043b\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 0 \u0434\u043e 100 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e, \u0447\u0442\u043e \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e. \u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u0442\u0438 \u0447\u0438\u0441\u043b\u0430 \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0437\u0430\u0434\u0430\u043d\u043e \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n (1\u2264n\u2264100)\u00a0\u2014 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0437\u0430\u0434\u0430\u043d\u044b n \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b a1,a2,\u2026,an (1\u2264ai\u22641000)\u00a0\u2014 \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u0444\u0430\u0439\u043b\u043e\u0432 \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 \u0432 \u0442\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u043d\u0438 \u0431\u0443\u0434\u0443\u0442 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f.\n\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0432 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u044e\u0449\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u0441\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 0 \u0434\u043e 100 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0442\u0430\u043a\u0438\u0435, \u0447\u0442\u043e \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430 \u043e\u0431\u043e\u0438\u0445 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430\u0445 \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u043c \u0442\u0435\u0441\u0442\u0435 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0432\u0441\u0435\u0433\u043e \u043e\u0434\u0438\u043d \u0444\u0430\u0439\u043b, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u0432\u0441\u0435\u0433\u0434\u0430 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u0442\u0435\u0441\u0442\u0435 \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u0441\u0440\u0430\u0437\u0443 \u0436\u0435 \u0443\u0439\u0434\u0451\u0442 \u0432\u043f\u0435\u0440\u0451\u0434, \u043f\u043e\u0442\u043e\u043c \u0441\u0431\u0440\u043e\u0441\u0438\u0442\u0441\u044f \u0432 \u043d\u043e\u043b\u044c \u0438 \u043d\u0430\u0447\u043d\u0451\u0442 \u0434\u043e\u0433\u043e\u043d\u044f\u0442\u044c \u0432\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u0437\u0430\u043d\u043e\u0432\u043e. \u0412 \u043a\u043e\u043d\u0446\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u044b \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0431\u0443\u0434\u0443\u0442 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043e\u0434\u043d\u043e \u0438 \u0442\u043e \u0436\u0435 \u0447\u0438\u0441\u043b\u043e.",
        "time limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u0441\u04422 \u0441\u0435\u043a\u0443\u043d\u0434\u044b",
        "memory limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u043c\u044f\u0442\u0438 \u043d\u0430 \u0442\u0435\u0441\u0442512 \u043c\u0435\u0433\u0430\u0431\u0430\u0439\u0442",
        "tags": [
            "*special problem",
            "brute force",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1766B": {
        "title": "B. Notepad#",
        "description": "You want to type the string s, consisting of n lowercase Latin letters, using your favorite text editor Notepad#.\nNotepad# supports two kinds of operations: \nCan you type string s in strictly less than n operations?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string s.\nThe second line contains a string s, consisting of n lowercase Latin letters.\nThe sum of n doesn't exceed 2\u22c5105 over all testcases.\nFor each testcase, print \"YES\" if you can type string s in strictly less than n operations. Otherwise, print \"NO\".\nIn the first testcase, you can start with typing \"codef\" (5 operations), then copy \"o\" (1 operation) from an already typed part, then finish with typing \"rces\" (4 operations). That will be 10 operations, which is not strictly less than n. There exist other ways to type \"codeforces\". However, no matter what you do, you can't do less than n operations.\nIn the second testcase, you can type \"labac\" (5 operations), then copy \"aba\" (1 operation), finishing the string in 6 operations.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1766B - Notepad#Why does the problem ask us only to check if we can do less than n operations instead of just asking the minimum amount? That must be making the problem easier, so let's focus our attention on that.What if it was \u2264n instead of <n? Well, then the problem would be trivial. You can type the word letter by letter and be done in n operations. So we only have to save one operation. In order to save at least one operation, we have to use the copy operation and copy more than one character in that.Let's take a closer look at any of the copy operations we do. Basically, it has to be a substring that has at least two non-intersection occurrences in the string. Thus, if the string has any substring that has length at least two that appears at least twice in the string, we can copy it, and the answer will be \"YES\".That's still not enough to solve the problem\u00a0\u2014 we'd have to check all substrings, which is O(n2).Let's think further. Imagine we found a substring that works. Let it have length k. Notice how you can remove its last character, obtaining a substring of length k\u22121, and it will still occure in the same set of positions (possibly, even more occurrences will be found). Remove characters until the substring has length 2. Thus, if any appropriate substring exists, an appropriate substring of length 2 also exists.Finally, we can check if there exists a substring of length 2 that appears at least twice in the string so that the occurrences are at least 2 apart. That can be done with a set/hashset or a map/hashmap. Some implementations might require careful handling of the substrings of kind \"aa\", \"bb\" and similar.Overall complexity: O(n) or O(nlogn) per testcase. Solution (awoo)for _ in range(int(input())):\n\tn = int(input())\n\ts = input()\n\tcur = {}\n\tfor i in range(n - 1):\n\t\tt = s[i:i+2]\n\t\tif t in cur:\n\t\t\tif cur[t] < i - 1:\n\t\t\t\tprint(\"YES\")\n\t\t\t\tbreak\n\t\telse:\n\t\t\tcur[t] = i\n\telse:\n\t\tprint(\"NO\")"
    },
    "1765M": {
        "title": "M. Minimum LCM",
        "description": "You are given an integer n.\nYour task is to find two positive (greater than 0) integers a and b such that a+b=n and the least common multiple (LCM) of a and b is the minimum among all possible values of a and b. If there are multiple answers, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264109).\nFor each test case, print two positive integers a and b\u00a0\u2014 the answer to the problem. If there are multiple answers, you can print any of them.\nIn the second example, there are 8 possible pairs of a and b:\nIn the third example, there are 5 possible pairs of a and b:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1765M - Minimum LCMSuppose a\u2264b. Let's show that if bmoda\u22600, the answer is suboptimal. If bmoda=0, then LCM(a,b)=b, so the answer is less than n. But if bmoda\u22600, then LCM(a,b) is at least 2b, and b is at least n2, so in this case, the answer is at least n.Okay, now we know that in the optimal answer, bmoda=0. This also means that nmoda=0, since n=a+b. So we need to search for a only among the divisors of n, and it is possible to iterate through all of them in O(n0.5). Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    int a = 1;\n    for (int g = 2; g * g <= n; ++g) {\n      if (n % g == 0) {\n        a = n / g;\n        break;\n      }\n    }\n    cout << a << ' ' << n - a << '\\n';\n  }\n}\n "
    },
    "1765E": {
        "title": "E. Exchange",
        "description": "Monocarp is playing a MMORPG. There are two commonly used types of currency in this MMORPG \u2014 gold coins and silver coins. Monocarp wants to buy a new weapon for his character, and that weapon costs n silver coins. Unfortunately, right now, Monocarp has no coins at all.\nMonocarp can earn gold coins by completing quests in the game. Each quest yields exactly one gold coin. Monocarp can also exchange coins via the in-game trading system. Monocarp has spent days analyzing the in-game economy; he came to the following conclusion: it is possible to sell one gold coin for a silver coins (i.\u2009e. Monocarp can lose one gold coin to gain a silver coins), or buy one gold coin for b silver coins (i.\u2009e. Monocarp can lose b silver coins to gain one gold coin).\nNow Monocarp wants to calculate the minimum number of quests that he has to complete in order to have at least n silver coins after some abuse of the in-game economy. Note that Monocarp can perform exchanges of both types (selling and buying gold coins for silver coins) any number of times.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of one line containing three integers n, a and b (1\u2264n\u2264107; 1\u2264a,b\u226450).\nFor each test case, print one integer \u2014 the minimum possible number of quests Monocarp has to complete.\nIn the first test case of the example, Monocarp should complete 4 quests, and then sell 4 gold coins for 100 silver coins.\nIn the second test case, Monocarp should complete 400000 quests, and then sell 400000 gold coins for 10 million silver coins.\nIn the third test case, Monocarp should complete 1 quest, sell the gold coin for 50 silver coins, buy a gold coin for 48 silver coins, and then sell it again for 50 coins. So, he will have 52 silver coins.\nIn the fourth test case, Monocarp should complete 1 quest and then sell the gold coin he has obtained for 50 silver coins.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1000"
        ],
        "solutions": "1765E - ExchangeIdea: BledDest, preparation: BledDest TutorialTutorial is loading... Solution (BledDest)#include <bits/stdc++.h>\n \nusing namespace std;\n\nvoid solve() \n{\n    int n, a, b;\n    cin >> n >> a >> b;\n    int x = (n + a - 1) / a;\n    if(a > b) x = 1;\n    cout << x << endl;\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n        solve();\n}"
    },
    "1763B": {
        "title": "B. Incinerate",
        "description": "To destroy humanity, The Monster Association sent n monsters to Earth's surface. The i-th monster has health hi and power pi.\nWith his last resort attack, True Spiral Incineration Cannon, Genos can deal k damage to all monsters alive. In other words, Genos can reduce the health of all monsters by k (if k>0) with a single attack. \nHowever, after every attack Genos makes, the monsters advance. With their combined efforts, they reduce Genos' attack damage by the power of the \u2020weakest monster \u2021alive. In other words, the minimum pi among all currently living monsters is subtracted from the value of k after each attack.\n\u2020The Weakest monster is the one with the least power.\n\u2021A monster is alive if its health is strictly greater than 0.\nWill Genos be successful in killing all the monsters?\nThe first line of the input contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers, n and k (1\u2264n,k\u2264105) \u2014 the number of monsters and Genos' initial attack damage. Then two lines follow, each containing n integers describing the arrays h and p (1\u2264hi,pi\u2264109).\nIt's guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print the answer \u2014 \"YES\" (without quotes) if Genos could kill all monsters and \"NO\" otherwise.\nIn the first example, after Genos' first attack, h and k will update to: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "implementation",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1763B - IncinerateIdea: og_ Prepared by: og_ Hint 1What if the array p was sorted? Hint 2Is it necessary to decrease the health of each monster manually after every attack? Solution 1Sort the monsters in ascending order of their powers.Now we iterate through the monsters while maintaining the current attack power and the total damage dealt.Only the monsters with health greater than the total damage dealt are considered alive, and every time we encounter such a monster it will be the weakest one at the current time, thus we need to attack until the total damage dealt exceeds the current monster's health while lowering our attack power by its power each time.If we can kill all the monsters in this way, the answer is YES, otherwise it is NO.Time Complexity: O(nlogn) Sort by power solutionCode Author: DreadArceus Solution 2Sort the monsters in ascending order of their health.Now we maintain a count of monsters alive after each attack. This could be achieved by applying upperbound() on h array for each attack. The total damage dealt could be stored and updated in a separate variable.To find the power of the weakest monster alive, we could just precompute the minimum power of monsters in a suffix array. In other words, pi=min(pi,pi+1).Time Complexity: O(nlogn) Sort by health solutionCode Author: og_"
    },
    "1762B": {
        "title": "B. Make Array Good",
        "description": "An array b of m positive integers is good if for all pairs i and j (1\u2264i,j\u2264m), max(bi,bj) is divisible by min(bi,bj).\nYou are given an array a of n positive integers. You can perform the following operation:\nYou have to construct a sequence of at most n operations that will make a good. It can be proven that under the constraints of the problem, such a sequence of operations always exists.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n space-separated integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 representing the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test, output a single integer p (0\u2264p\u2264n) \u2014 denoting the number of operations in your solution. \nIn each of the following p lines, output two space-separated integers \u2014 i and x.\nYou do not need to minimize the number of operations. It can be proven that a solution always exists.\nIn the first test case, array a becomes [5,5,5,5] after the operations. It is easy to see that [5,5,5,5] is good.\nIn the second test case, array a is already good.\nIn the third test case, after performing the operations, array a becomes [10,5,350,5,10], which is good.\nIn the fourth test case, after performing the operations, array a becomes [60,10,20], which is good.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "number theory",
            "sortings",
            "*1100"
        ],
        "solutions": "1762B - Make Array GoodIdea:satyam343 Hint 1Suppose we have a prime number p. Suppose there are two perfect powers of p \u2014 l and r. Now it is easy to see max(l,r) is divisible by min(l,r). Hint 2So now we need to choose some prime number p. Let us start with the smallest prime number p=2. Hint 3Here is one interesting fact. There always exists a power of 2 in the range [x,2x] for any positive integer x. SolutionSuppose f(x) gives the smallest power of 2 which is greater than x.Iterate from i=1 to n and change ai to f(ai) by adding f(ai)\u2212ai to i-th element. Time complexity is O(n\u22c5log(Amax)). Code#include <bits/stdc++.h>     \nusing namespace std;\n#define ll long long\nll f(ll x){\n    ll cur=1;\n    while(cur<=x){\n        cur*=2;\n    }\n    return cur;\n}\nvoid solve(){\n    ll n; cin>>n;\n    cout<<n<<\"\\n\";\n    for(ll i=1;i<=n;i++){\n        ll x; cin>>x;\n        cout<<i<<\" \"<<f(x)-x<<\"\\n\";\n    }\n}\nint main()                                                                                \n{  \n    ios_base::sync_with_stdio(false);                         \n    cin.tie(NULL);  \n    ll t; cin>>t;\n    while(t--){\n        solve();\n    }\n} "
    },
    "1761B": {
        "title": "B. Elimination of a Ring",
        "description": "Define a cyclic sequence of size n as an array s of length n, in which sn is adjacent to s1.\nMuxii has a ring represented by a cyclic sequence a of size n.\nHowever, the ring itself hates equal adjacent elements. So if two adjacent elements in the sequence are equal at any time, one of them will be erased immediately. The sequence doesn't contain equal adjacent elements initially.\nMuxii can perform the following operation until the sequence becomes empty:\nFor example, if ring is [1,2,4,2,3,2], and Muxii erases element 4, then ring would erase one of the elements equal to 2, and the ring will become [1,2,3,2].\nMuxii wants to find the maximum number of operations he could perform.\nNote that in a ring of size 1, its only element isn't considered adjacent to itself (so it's not immediately erased).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the cyclic sequence.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the sequence itself.\nIt's guaranteed that ai\u2260ai+1 for 1\u2264i<n.\nIt's guaranteed that an\u2260a1 when n>1.\nFor each test case, output a single integer\u00a0\u2014 the maximum number of operations Muxii can perform.\nIn the first test case, you can erase the second element first, then erase the remaining elements one by one in any order. In total, you can perform the operation 4 times. Note that if you erase the first element first, then the sequence will be turned into [2,3,2] and then immediately become [2,3].\nIn the second test case, you can erase the first element first, then the sequence becomes [2,1]. Then you can erase all remaining elements one by one in any order.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1761B - Elimination of a RingHintDo we need more than 3 types of elements? Try to solve the problem with ai\u22643.SolutionFirst of all, when there're only 2 types of elements appearing in the sequence, the answer would be n2+1.Otherwise, the conclusion is that we can always reach n operations when there are more than 2 types of elements appearing in the sequence.The proof is given below: When the length of the sequence is greater than 3, there will always be a pair of positions (i,j), such that ai=aj and ai has two different neighboring elements. Then we can erase ai and then the problem is decomposed into a smaller one. If there do not exist such pairs, then we can infer that there exists at least 1 element which appeared only once in the sequence. If there exists such element b, then we can continuously erase all the elements next to b, then erase b at last. When the length n of the sequence is less than 3, it is clear that there will be exactly n operations as well.So we only need to check the number of elements that appeared in the sequence of length n. If the number is 2, the answer will be n2+1. Otherwise, the answer equals n. Author: Jelefy "
    },
    "1760E": {
        "title": "E. Binary Inversions",
        "description": "You are given a binary array\u2020 of length n. You are allowed to perform one operation on it at most once. In an operation, you can choose any element and flip it: turn a 0 into a 1 or vice-versa.\nWhat is the maximum number of inversions\u2021 the array can have after performing at most one operation?\n\u2020 A binary array is an array that contains only zeroes and ones.\n\u2021 The number of inversions in an array is the number of pairs of indices i,j such that i<j and ai>aj.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated positive integers a1, a2,..., an (0\u2264ai\u22641)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum number of inversions the array can have after performing at most one operation.\nFor the first test case, the inversions are initially formed by the pairs of indices (1,2), (1,4), (3,4), being a total of 3, which already is the maximum possible.\nFor the second test case, the inversions are initially formed by the pairs of indices (2,3), (2,4), (2,6), (5,6), being a total of four. But, by flipping the first element, the array becomes 1,1,0,0,1,0, which has the inversions formed by the pairs of indices (1,3), (1,4), (1,6), (2,3), (2,4), (2,6), (5,6) which total to 7 inversions which is the maximum possible.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1760E - Binary InversionsLet's find out how to count the number of binary inversions, without flips. This is the number of 1s that appear before a 0. To do this, iterate through the array and keep a running total k of the number of 1s seen so far. When we see a 0, increase the total inversion count by k, since this 0 makes k inversions: one for each of the 1s before it.Now let's see how to maximize the inversions. Consider the flip 0\u21921. We claim that it is best to always flip the earliest 0 in the array. It's never optimal to flip a later 0, since we have strictly fewer 0s after it to form inversions. Similarly, we should flip the latest 1 in the array.Now recalculate the answer for these two choices for flipping, and pick the maximum. The complexity is O(n). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \nusing ll = long long;\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nll calc(vector<int>& a) {\n    ll zeroes = 0, ans = 0;\n    for(int i = sz(a) - 1; i >= 0; --i) {\n        if(a[i] == 0) ++zeroes;\n        else ans += zeroes;\n    }\n    return ans;\n}\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    forn(i, n) cin >> a[i];\n    ll ans = calc(a);\n    forn(i, n) {\n        if(a[i] == 0) {\n            a[i] = 1;\n            ans = max(ans, calc(a));\n            a[i] = 0;\n            break;\n        }\n    }\n    for(int i = n - 1; i >= 0; --i) {\n        if(a[i] == 1) {\n            a[i] = 0;\n            ans = max(ans, calc(a));\n            a[i] = 1;\n            break;\n        }\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}"
    },
    "1760D": {
        "title": "D. Challenging Valleys",
        "description": "You are given an array a[0\u2026n\u22121] of n integers. This array is called a \"valley\" if there exists exactly one subarray a[l\u2026r] such that:\nHere are three examples:\nThe first image shows the array [3,2,2,1,2,2,3], it is a valley because only subarray with indices l=r=3 satisfies the condition.\nThe second image shows the array [1,1,1,2,3,3,4,5,6,6,6], it is a valley because only subarray with indices l=0,r=2 satisfies the codition.\nThe third image shows the array [1,2,3,4,3,2,1], it is not a valley because two subarrays l=r=0 and l=r=6 that satisfy the condition.\nYou are asked whether the given array is a valley or not.\nNote that we consider the array to be indexed from 0.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers ai (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases is smaller than 2\u22c5105.\nFor each test case, output \"YES\" (without quotes) if the array is a valley, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first three test cases are explained in the statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "1760D - Challenging ValleysIdea: mesanu TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<int> a;\n    for(int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        if(i == 0 || x != a.back())\n        {\n            a.push_back(x);\n        }\n    }\n    int num_valley = 0;\n    for(int i = 0; i < a.size(); i++)\n    {\n        if((i == 0 || a[i-1] > a[i]) && (i == a.size()-1 || a[i] < a[i+1]))\n        {\n            num_valley++;\n        }\n    }\n    if(num_valley == 1)\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n}\n\nint32_t main(){\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}"
    },
    "1759C": {
        "title": "C. Thermostat",
        "description": "Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of a.\nThe thermostat can only be set to a temperature from l to r inclusive, the temperature cannot change by less than x. Formally, in one operation you can reconfigure the thermostat from temperature a to temperature b if |a\u2212b|\u2265x and l\u2264b\u2264r.\nYou are given l, r, x, a and b. Find the minimum number of operations required to get temperature b from temperature a, or say that it is impossible.\nThe first line of input data contains the single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each case contains three integers l, r and x (\u2212109\u2264l\u2264r\u2264109, 1\u2264x\u2264109) \u2014 range of temperature and minimum temperature change.\nThe second line of each case contains two integers a and b (l\u2264a,b\u2264r) \u2014 the initial and final temperatures.\nOutput t numbers, each of which is the answer to the corresponding test case. If it is impossible to achieve the temperature b, output -1, otherwise output the minimum number of operations.\nIn the first example, the thermostat is already set up correctly.\nIn the second example, you can achieve the desired temperature as follows: 4\u219210\u21925.\nIn the third example, you can achieve the desired temperature as follows: 3\u21928\u21922\u21927.\nIn the fourth test, it is impossible to make any operation.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "shortest paths",
            "*1100"
        ],
        "solutions": "1759C - ThermostatFirst let's consider the cases when the answer exists:  If a=b, then the thermostat is already set up and the answer is 0.  else if |a\u2212b|\u2265x, then it is enough to reconfigure the thermostat in 1 operation.  else if exist such temperature c, that |a\u2212c|\u2265x and |b\u2212c|\u2265x, then you can configure the thermostat in 2 operations. If such c exists between l and r, we can chose one of bounds: a\u2192l\u2192b or a\u2192r\u2192b.  we need to make 3 operations if times if we cannot reconfigure through one of the boundaries as above, but we can through both: a\u2192l\u2192r\u2192b or a\u2192r\u2192l\u2192b If we can't get the temperature b in one of these ways, the answer is \u22121. Solutiondef solve():\n    l, r, x = map(int, input().split())\n    a, b = map(int, input().split())\n    if a == b:\n        return 0\n    if abs(a - b) >= x:\n        return 1\n    if r - max(a, b) >= x or min(a, b) - l >= x:\n        return 2\n    if r - b >= x and a - l >= x or r - a >= x and b - l >= x:\n        return 3\n    return -1\n\n\nt = int(input())\nfor _ in range(t):\n    print(solve())"
    },
    "1747C": {
        "title": "C. Swap Game",
        "description": "Alice and Bob are playing a game on an array aa of n positive integers. Alice and Bob make alternating moves with Alice going first.\nIn his/her turn, the player makes the following move:\nDetermine the winner of the game if both players play optimally.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2\u2026an (1\u2264ai\u2264109) \u00a0\u2014 the elements of the array a.\nIt is guaranteed that sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, if Alice will win the game, output \"Alice\". Otherwise, output \"Bob\".\nYou can output each letter in any case. For example, \"alIcE\", \"Alice\", \"alice\" will all be considered identical.\nIn the first testcase, in her turn, Alice can only choose i=2, making the array equal [1,0]. Then Bob, in his turn, will also choose i=2 and make the array equal [0,0]. As a1=0, Alice loses.\nIn the second testcase, once again, players can only choose i=2. Then the array will change as follows: [2,1]\u2192[1,1]\u2192[1,0]\u2192[0,0], and Bob loses.\nIn the third testcase, we can show that Alice has a winning strategy.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "*1200"
        ],
        "solutions": "1747C \u2014 Swap Game Hint 1Divide problem into two different cases. When a1>min(a) and when a1=min(a). Hint 2You do not need more hints to solve the problem. TutorialCase 1: a1>min(a) Alice can force the Bob to always decrease the minimum element by always choosing minimum element of a in her turn. Where as Bob can not do much, all other elements he would swap with would be greater than or equal to min(a). Even if there exists multiple minimums in a, In first move Alice would decrease from a1, hence in this case Alice would always win.Case 2: a1=min(a) In this case optimal startegy for Bob would be to always chhose minimum element of the array, which is a1. Alice would always be swapping the element greater than a1 in her turn, hence in the case Bob would always win Solution// Jai Shree Ram  \n  \n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,n)     for(int i=a;i<n;i++)\n#define ll             long long\n#define int            long long\n#define pb             push_back\n#define all(v)         v.begin(),v.end()\n#define endl           \"\\n\"\n#define x              first\n#define y              second\n#define gcd(a,b)       __gcd(a,b)\n#define mem1(a)        memset(a,-1,sizeof(a))\n#define mem0(a)        memset(a,0,sizeof(a))\n#define sz(a)          (int)a.size()\n#define pii            pair<int,int>\n#define hell           1000000007\n#define elasped_time   1.0 * clock() / CLOCKS_PER_SEC\n\n\n\ntemplate<typename T1,typename T2>istream& operator>>(istream& in,pair<T1,T2> &a){in>>a.x>>a.y;return in;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream& out,pair<T1,T2> a){out<<a.x<<\" \"<<a.y;return out;}\ntemplate<typename T,typename T1>T maxs(T &a,T1 b){if(b>a)a=b;return a;}\ntemplate<typename T,typename T1>T mins(T &a,T1 b){if(b<a)a=b;return a;}\n\n\nint solve(){\n \t\tint n; cin >> n;\n \t\tvector<int> a(n);\n \t\tfor(auto &i:a)cin >> i;\n \t\tsort(a.begin() + 1,a.end());\n \t\tcout << (a[0] > a[1] ? \"Alice\" : \"Bob\") << endl;\n return 0;\n}\nsigned main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    #ifdef SIEVE\n    sieve();\n    #endif\n    #ifdef NCR\n    init();\n    #endif\n    int t=1;cin>>t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
    },
    "1744D": {
        "title": "D. Divisibility by 2^n",
        "description": "You are given an array of positive integers a1,a2,\u2026,an.\nMake the product of all the numbers in the array (that is, a1\u22c5a2\u22c5\u2026\u22c5an) divisible by 2n.\nYou can perform the following operation as many times as you like:\nYou cannot apply the operation repeatedly to a single index. In other words, all selected values of i must be different.\nFind the smallest number of operations you need to perform to make the product of all the elements in the array divisible by 2n. Note that such a set of operations does not always exist.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number test cases.\nThen the descriptions of the input data sets follow.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the length of array a.\nThe second line of each test case contains exactly n integers: a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n values over all test cases in a test does not exceed 2\u22c5105.\nFor each test case, print the least number of operations to make the product of all numbers in the array divisible by 2n. If the answer does not exist, print -1.\nIn the first test case, the product of all elements is initially 2, so no operations needed.\nIn the second test case, the product of elements initially equals 6. We can apply the operation for i=2, and then a2 becomes 2\u22c52=4, and the product of numbers becomes 3\u22c54=12, and this product of numbers is divided by 2n=22=4. \nIn the fourth test case, even if we apply all possible operations, we still cannot make the product of numbers divisible by 2n \u00a0\u2014 it will be (13\u22c51)\u22c5(17\u22c52)\u22c5(1\u22c53)\u22c5(1\u22c54)=5304, which does not divide by 2n=24=16.\nIn the fifth test case, we can apply operations for i=2 and i=4. ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1744D - Divisibility by 2^nLet's notice that if we multiply the numbers a1\u22c5a2\u22c5\u2026\u22c5an, then the power of two of the product is equal to the sum of the powers of two in each of the numbers.Let's calculate the initial sum of the powers of twos in the product. This can be done as follows: let's take the element ai and divide it by 2 as long as we can, while remembering to increase our counter by the number of occurrences of a power of two.Now let's move on to operations and note that choosing the index i will increase the degree of occurrence of two by a fixed number (that is, it does not matter when to apply this operation). Choosing an index i will increment the counter by a number x such that i is divisible by 2x but not by 2x+1\u00a0\u2014 you can find this x, again , by dividing by 2 while we can.Since we want to minimize the number of operations used, at each moment of time we will try to use an index that increases the counter by the largest number. To do this, it is enough to sort the indices by this index of increase and take them greedily from the largest increase to the smallest.We get the solution in O(nlogn+nlogA). "
    },
    "1744C": {
        "title": "C. Traffic Light",
        "description": "You find yourself on an unusual crossroad with a weird traffic light. That traffic light has three possible colors: red (r), yellow (y), green (g). It is known that the traffic light repeats its colors every n seconds and at the i-th second the color si is on.\nThat way, the order of the colors is described by a string. For example, if s=\"rggry\", then the traffic light works as the following: red-green-green-red-yellow-red-green-green-red-yellow- ... and so on.\nMore formally, you are given a string s1,s2,\u2026,sn of length n. At the first second the color s1 is on, at the second \u2014 s2, ..., at the n-th second the color sn is on, at the n+1-st second the color s1 is on and so on.\nYou need to cross the road and that can only be done when the green color is on. \nYou know which color is on the traffic light at the moment, but you don't know the current moment of time. You need to find the minimum amount of time in which you are guaranteed to cross the road.\nYou can assume that you cross the road immediately. \nFor example, with s=\"rggry\" and the current color r there are two options: either the green color will be on after 1 second, or after 3. That way, the answer is equal to 3 \u2014 that is the number of seconds that we are guaranteed to cross the road, if the current color is r.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThen the description of the test cases follows.\nThe first line of each test case contains an integer n and a symbol c (1\u2264n\u22642\u22c5105, c is one of allowed traffic light colors r, y or g)\u2014 the length of the string s and the current color of the traffic light. \nThe second line of each test case contains a string s of the length n, consisting of the letters r, y and g.\nIt is guaranteed that the symbol g is in the string s and the symbol c is in the string s. \nIt is guaranteed, that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output the minimal number of second in which you are guaranteed to cross the road.\nThe first test case is explained in the statement.\nIn the second test case the green color is on so you can cross the road immediately. \nIn the third test case, if the red color was on at the second second, then we would wait for the green color for one second, and if the red light was on at the first second, then we would wait for the green light for two seconds.\nIn the fourth test case the longest we would wait for the green color is if we wait for it starting from the fifth second.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "1744C - Traffic Light \u043f\u0440\u0438\u0434\u0443\u043c\u0430\u043b\u0438 MikeMirzayanov \u0438 RedMachine-74, \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u0438\u043b RedMachine-74"
    },
    "1743C": {
        "title": "C. Save the Magazines",
        "description": "Monocarp has been collecting rare magazines for quite a while, and now he has decided to sell them. He distributed the magazines between n boxes, arranged in a row. The i-th box contains ai magazines. Some of the boxes are covered with lids, others are not. \nSuddenly it started to rain, and now Monocarp has to save as many magazines from the rain as possible. To do this, he can move the lids between boxes as follows: if the i-th box was covered with a lid initially, he can either move the lid from the i-th box to the box (i\u22121) (if it exists), or keep the lid on the i-th box. You may assume that Monocarp can move the lids instantly at the same moment, and no lid can be moved more than once. If a box will be covered with a lid after Monocarp moves the lids, the magazines in it will be safe from the rain; otherwise they will soak.\nYou have to calculate the maximum number of magazines Monocarp can save from the rain.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of the testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of boxes.\nThe second line contains a string of n characters 0 and/or 1. If the i-th character is 1, the i-th box is initially covered with a lid. If the i-th character is 0, the i-th box is initially not covered.\nThe third line contains a sequence of integers a1,a2,\u2026,an (1\u2264ai\u2264104), where ai is the number of magazines in the i-th box.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print one integer\u00a0\u2014 the maximum number of magazines Monocarp can save from the rain.\nIn the first testcase of the example, Monocarp can move the lid from the second box to the first box, so the boxes 1, 3 and 4 are covered, and 10+8+9=27 magazines are saved.\nIn the second testcase, Monocarp can move the lid from the second box to the first box, then from the third box to the second box, then from the fifth box to the fourth box, and then from the sixth box to the fifth box. The boxes 1, 2, 4 and 5 will be covered, so 20+10+30+20=80 magazines can be saved.\nThere are no lids in the third testcase, so it's impossible to save even a single magazine.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "*1100"
        ],
        "solutions": "1743C - Save the MagazinesLet's process the boxes from left to right.Consider the first box. If it has a lid, then you can just add the number of magazines in it to the answer and forget about this box. To be exact, proceed to solve the problem with the first box removed.If it doesn't have a lid, then look at the next box. If it doesn't have a lid too, then this box can never be covered. Remove it and proceed further.If the next box has a lid, then look at the next one. Again, if it doesn't have a lid, then these two first boxes are solved independently of everything else. You can cover exactly one of them. Choose the bigger one and remove them both.To propagate the argument, let's derive a pattern. First, there's a box without a lid. Then some number of boxes with lids in a row. Then a box without a lid again. Among the first box and the box with lids, you can choose exactly one to not be covered. However, that can be any one of them. The best box to be left uncovered is the one with the smallest number of magazines in it.Thus, the solution is the following. As long as the first box has a lid, keep removing the first box and adding it to the answer. Then, as long as there are boxes left, take the first box and the largest number of consecutive boxes with lids after it (that number might be zero). On that segment, find the minimum value and the sum. Add the sum minus the minimum to the answer, remove the entire segment.The removals can be done explicitly with a queue or just a reversed vector or implicitly with maintaining a pointer to the first non-removed box.Overall complexity: O(n). Solution (awoo)for _ in range(int(input())):\n\tn = int(input())\n\ts = '0' + input()\n\ta = [0] + list(map(int, input().split()))\n\tans = 0\n\ti = 0\n\twhile i <= n:\n\t\tmn = a[i]\n\t\tsm = a[i]\n\t\tj = i + 1\n\t\twhile j <= n and s[j] == '1':\n\t\t\tmn = min(mn, a[j])\n\t\t\tsm += a[j]\n\t\t\tj += 1\n\t\tans += sm - mn\n\t\ti = j\n\tprint(ans)"
    },
    "1742E": {
        "title": "E. Scuza",
        "description": "Timur has a stairway with n steps. The i-th step is ai meters higher than its predecessor. The first step is a1 meters higher than the ground, and the ground starts at 0 meters. \nTimur has q questions, each denoted by an integer k1,\u2026,kq. For each question ki, you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length ki. Timur can only climb the j-th step if his legs are of length at least aj. In other words, ki\u2265aj for each step j climbed.\nNote that you should answer each question independently.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,q (1\u2264n,q\u22642\u22c5105)\u00a0\u2014 the number of steps and the number of questions, respectively.\nThe second line of each test case contains n integers (1\u2264ai\u2264109)\u00a0\u2014 the height of the steps.\nThe third line of each test case contains q integers (0\u2264ki\u2264109)\u00a0\u2014 the numbers for each question.\nIt is guaranteed that the sum of n does not exceed 2\u22c5105, and the sum of q does not exceed 2\u22c5105.\nFor each test case, output a single line containing q integers, the answer for each question.\nPlease note, that the answer for some questions won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nConsider the first test case, pictured in the statement. ",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1742E - ScuzaLet's compute the prefix sums of the array a: let bi=a1+\u22ef+ai. Rephrasing the problem: for each question containing an integer k, we need to find the largest ai such that a1,\u2026,ai are all at most k, and then output bi. In other words, max(a1,\u2026,ai)\u2264k.Let's make the prefix maximums of the array: let mi=max(a1,\u2026,ai). Then we need to find the largest i such that mi\u2264k, which is doable using binary search, since the array m is non-decreasing. Once we find the index i, we simply need to output bi.The time complexity is O(nlogn) per testcase. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<long long> pref;\n    pref.push_back(0);\n    vector<int> prefmax;\n    for(int i = 0; i < n; i++)\n    {\n        int x;\n        cin >> x;\n        pref.push_back(pref.back()+x);\n        if(i == 0)\n        {\n            prefmax.push_back(x);\n        }\n        else\n        {\n            prefmax.push_back(max(prefmax.back(), x));\n        }\n    }\n    for(int i = 0; i < q; i++)\n    {\n        int k;\n        cin >> k;\n        int ind = upper_bound(prefmax.begin(), prefmax.end(), k)-prefmax.begin();\n        cout << pref[ind] << \" \";\n    }\n    cout << endl;\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        solve();\n    }\n}"
    },
    "1742D": {
        "title": "D. Coprime",
        "description": "Given an array of n positive integers a1,a2,\u2026,an (1\u2264ai\u22641000). Find the maximum value of i+j such that ai and aj are coprime,\u2020 or \u22121 if no such i, j exist.\nFor example consider the array [1,3,5,2,4,7,7]. The maximum value of i+j that can be obtained is 5+7, since a5=4 and a7=7 are coprime.\n\u2020 Two integers p and q are coprime if the only positive integer that is a divisor of both of them is 1 (that is, their greatest common divisor is 1).\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated positive integers a1, a2,..., an (1\u2264ai\u22641000)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum value of i+j such that i and j satisfy the condition that ai and aj are coprime, or output \u22121 in case no i, j satisfy the condition.\nFor the first test case, we can choose i=j=3, with sum of indices equal to 6, since 1 and 1 are coprime.\nFor the second test case, we can choose i=7 and j=5, with sum of indices equal to 7+5=12, since 7 and 4 are coprime.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "number theory",
            "*1100"
        ],
        "solutions": "1742D - CoprimeIdea: badlad, SlavicG TutorialTutorial is loading... Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\nvector<int> pairs[1001];\nvoid solve() {\n    int n; cin >> n;\n    vector<int> id[1001];\n    for(int i = 1; i <= n; ++i) {\n        int x; cin >> x;\n        id[x].push_back(i);\n    }\n    int ans = -1;\n    for(int i = 1; i <= 1000; ++i) {\n        for(int j: pairs[i]) {\n            if(!id[i].empty() && !id[j].empty()) {\n                ans = max(ans, id[i].back() + id[j].back());\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}   \n \nint32_t main() {\n    for(int i = 1; i <= 1000; ++i) {\n        for(int j = 1; j <= 1000; ++j) {\n            if(__gcd(i, j) == 1) {\n                pairs[i].push_back(j);\n            }\n        }\n    }\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}"
    },
    "1741C": {
        "title": "C. Minimize the Thickness",
        "description": "You are given a sequence a=[a1,a2,\u2026,an] consisting of n positive integers.\nLet's call a group of consecutive elements a segment. Each segment is characterized by two indices: the index of its left end and the index of its right end. Denote by a[l,r] a segment of the sequence a with the left end in l and the right end in r, i.e. a[l,r]=[al,al+1,\u2026,ar].\nFor example, if a=[31,4,15,92,6,5], then a[2,5]=[4,15,92,6], a[5,5]=[6], a[1,6]=[31,4,15,92,6,5] are segments.\nWe split the given sequence a into segments so that: \nFor example, if a = [55,45,30,30,40,100], then such a sequence can be split into three segments: a[1,2]=[55,45], a[3,5]=[30,30,40], a[6,6]=[100]. Each element belongs to exactly segment, the sum of the elements of each segment is 100.\nLet's define thickness of split as the length of the longest segment. For example, the thickness of the split from the example above is 3.\nFind the minimum thickness among all possible splits of the given sequence of a into segments in the required way.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nEach test case is described by two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u22642000) \u2014 the length of the sequence a.\nThe second line of each test case contains exactly n integers: a1,a2,\u2026,an (1\u2264ai\u2264106) \u2014 elements of the sequence a.\nIt is guaranteed that the sum of n for all test cases does not exceed 2000.\nFor each test case, output one integer \u2014 the minimum possible thickness of a split of the sequence a into segments.\nNote that there always exist a split, you can always consider whole sequence as one segment.\nThe split in the first test case is explained in the statement, it can be shown that it is optimal.\nIn the second test case, it is possible to split into segments only by leaving a single segment. Then the thickness of this split is equal to the length of the entire sequence, that is, 4.\nIn the third test case, the optimal split will be [10,55],[35,30],[65]. The thickness of the split equals to 2.\nIn the fourth test case possible splits are:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solutions": "1741C - Minimize the ThicknessLet's iterate over the length of the first segment of the split. Having fixed it, we actually fixed the sum that needs to be collected on all other segments. Since each element must belong to exactly one segment, we can build other segments greedily. If we have found a solution, we will remember the length of the longest segment in it and try to update the answer. We have n possible lengths of the first segment, for each of which we greedily built the answer for n. Thus, the asymptotics of the solution will be O(n2). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2020;\n\nint n;\nint arr[MAXN];\n\nint go(int i, int sum) {\n\tif (i == n) return 0;\n\tfor (int j = i + 1, cur = 0; j <= n; ++j) {\n\t\tcur += arr[j - 1];\n\t\tif (cur > sum) return n;\n\t\tif (cur == sum) return max(j - i, go(j, sum));\n\t}\n\treturn n;\n}\n\nint solve() {\n\tint ans = n;\n\tfor (int len = 1, sum = 0; len < n; ++len) {\n\t\tsum += arr[len - 1];\n\t\tans = min(ans, go(0, sum));\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tcin >> arr[i];\n\t\tcout << solve() << endl;\n\t}\n}"
    },
    "1739B": {
        "title": "B. Array Recovery",
        "description": "For an array of non-negative integers a of size n, we construct another array d as follows: d1=a1, di=|ai\u2212ai\u22121| for 2\u2264i\u2264n.\nYour task is to restore the array a from a given array d, or to report that there are multiple possible arrays. \nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the arrays a and d.\nThe second line contains n integers d1,d2,\u2026,dn (0\u2264di\u2264100)\u00a0\u2014 the elements of the array d.\nIt can be shown that there always exists at least one suitable array a under these constraints.\nFor each test case, print the elements of the array a, if there is only one possible array a. Otherwise, print \u22121.\nIn the second example, there are two suitable arrays: [2,8,5] and [2,8,11].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1739B - Array RecoveryNote that ai=ai\u22121+di or ai=ai\u22121\u2212di. Since there is no upper bound for the values of ai, the case where ai=ai\u22121+di for all i always exists. It remains to check if there are other ways. To do this, it is enough to check whether there is such a position pos that:   pos>1;  dpos\u22600;  the change apos=apos\u22121+dpos to apos=apos\u22121\u2212dpos doesn't result in a negative value of apos. The reason for dpos\u22600 is that for dpos=0 no matter the plus or minus we choose, the array a doesn't change. If you could change at least one sign to minus, that would be another answer. Solution (Neon)for _ in range(int(input())):\n\tn = int(input())\n\tans = [0]\n\tfor x in map(int, input().split()):\n\t\tif x != 0 and ans[-1] - x >= 0:\n\t\t\tprint(-1)\n\t\t\tbreak\n\t\telse:\n\t\t\tans.append(ans[-1] + x)\n\telse:\n\t\tprint(*ans[1:])"
    },
    "1738B": {
        "title": "B. Prefix Sum Addicts",
        "description": "Suppose a1,a2,\u2026,an is a sorted integer sequence of length n such that a1\u2264a2\u2264\u22ef\u2264an. \nFor every 1\u2264i\u2264n, the prefix sum si of the first i terms a1,a2,\u2026,ai is defined by si=i\u2211k=1ak=a1+a2+\u22ef+ai.\nNow you are given the last k terms of the prefix sums, which are sn\u2212k+1,\u2026,sn\u22121,sn. Your task is to determine whether this is possible. \nFormally, given k integers sn\u2212k+1,\u2026,sn\u22121,sn, the task is to check whether there is a sequence a1,a2,\u2026,an such that \nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264105) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe first line of each test case contains two integers n (1\u2264n\u2264105) and k (1\u2264k\u2264n), indicating the length of the sequence a and the number of terms of prefix sums, respectively.\nThe second line of each test case contains k integers sn\u2212k+1,\u2026,sn\u22121,sn (\u2212109\u2264si\u2264109 for every n\u2212k+1\u2264i\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output \"YES\" (without quotes) if it is possible and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first test case, we have the only sequence a=[1,1,1,1,1].\nIn the second test case, we can choose, for example, a=[\u22123,\u22122,\u22121,0,1,2,3].\nIn the third test case, the prefix sums define the only sequence a=[2,1,1], but it is not sorted. \nIn the fourth test case, it can be shown that there is no sequence with the given prefix sums.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1738B - Prefix Sum AddictsIf k=1, it is always possible, so the answer is \"YES\".In the following, we assume that k\u22652. Here, we are given sn\u2212k+1,\u2026,sn. We can resume an\u2212k+2,\u2026,an by letting ai=si\u2212si\u22121 for every n\u2212k+2\u2264i\u2264n.If the known elements of ai cannot form a sorted array, i.e., it does not hold that an\u2212k+2\u2264\u22ef\u2264an, the answer is \"NO\".Note that the sum of the first n\u2212k+1 elements of ai should satisfy that sn\u2212k+1=a1+\u22ef+an\u2212k+1\u2264(n\u2212k+1)an\u2212k+2. If this does not hold, the answer is \"NO\".Having checked that both an\u2212k+2\u2264\u22ef\u2264an and sn\u2212k+1\u2264(n\u2212k+1)an\u2212k+2 hold, we claim that the answer is \"YES\". A possible solution could be ai=\u23a7\u23a9\u23a8\u23aa\u23aa\u23aa\u23aa\u23aa\u23aa\u230asn\u2212k+1n\u2212k+1\u230b,\u2308sn\u2212k+1n\u2212k+1\u2309,1\u2264i\u2264sn\u2212k+1mod(n\u2212k+1),sn\u2212k+1mod(n\u2212k+1)<i\u2264n\u2212k+1. Solution174164900"
    },
    "1736B": {
        "title": "B. Playing with GCD",
        "description": "You are given an integer array aa of length nn. \nDoes there exist an array bb consisting of n+1n+1 positive integers such that ai=gcd(bi,bi+1)ai=gcd(bi,bi+1) for all ii (1\u2264i\u2264n1\u2264i\u2264n)? \nNote that gcd(x,y)gcd(x,y) denotes the greatest common divisor (GCD) of integers xx and yy.\nEach test contains multiple test cases. The first line contains the number of test cases tt (1\u2264t\u22641051\u2264t\u2264105). Description of the test cases follows.\nThe first line of each test case contains an integer nn (1\u2264n\u22641051\u2264n\u2264105) \u2014 the length of the array aa.\nThe second line of each test case contains nn space-separated integers a1,a2,\u2026,ana1,a2,\u2026,an representing the array aa (1\u2264ai\u22641041\u2264ai\u2264104).\nIt is guaranteed that the sum of nn over all test cases does not exceed 105105.\nFor each test case, output \"YES\" if such bb exists, otherwise output \"NO\". You can print each letter in any case (upper or lower).\nIn the first test case, we can take b=[343,343]b=[343,343].\nIn the second test case, one possibility for bb is b=[12,8,6]b=[12,8,6].\nIn the third test case, it can be proved that there does not exist any array bb that fulfills all the conditions.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1736B - Playing with GCD SolutionTake a0=an+1=1.Now take bi=lcm(ai\u22121,ai) for 1\u2264i\u2264n+1. If b gives us a after performing the gcd operations, then the answer is YES, otherwise the answer is NO. (When answer is NO, we would get a case like gcd(bi,bi+1)=k\u22c5ai(where k>1 for some i).Suppose c is some valid array which gives us a. So, ci should be divisible by bi. This means gcd(ci,ci+1)\u2265gcd(bi,bi+1).So, if gcd(bi,bi+1)>ai for any i, we should also have gcd(ci,ci+1)>ai. This implies that c is not valid if b is not valid.Time complexity is O(n\u22c5log(bmax)). Code#include <bits/stdc++.h>     \nusing namespace std;\n#define ll long long\nll lcm(ll a,ll b){\n    ll g=__gcd(a,b);\n    return (a*b/g);\n}\nvoid solve(){\n    ll n; cin>>n;\n    vector<ll> a(n+2,1);\n    for(ll i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    vector<ll> b(n+2,1);\n    for(ll i=1;i<=n+1;i++){\n        b[i]=lcm(a[i],a[i-1]);\n    }\n    for(ll i=1;i<=n;i++){\n        if(__gcd(b[i],b[i+1])!=a[i]){\n            cout<<\"NO\\n\";\n            return;\n        }\n    }\n    cout<<\"YES\\n\";\n}\nint main()                                                                                \n{  \n    ios_base::sync_with_stdio(false);                         \n    cin.tie(NULL);  \n    ll t; cin>>t;\n    while(t--){\n        solve();\n    }\n}  "
    },
    "1734C": {
        "title": "C. Removing Smallest Multiples",
        "description": "You are given a set S, which contains the first n positive integers: 1,2,\u2026,n.\nYou can perform the following operation on S any number of times (possibly zero): \nYou are given a set T, which is a subset of S. Find the minimum possible total cost of operations such that S would be transformed into T. We can show that such a transformation is always possible.\nThe first line of the input contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line contains a single positive integer n (1\u2264n\u2264106).\nThe second line of each test case contains a binary string of length n, describing the set T. The i-th character of the string is '1' if and only if i is an element of T, and '0' otherwise.\nIt is guaranteed that the sum of n over all test cases does not exceed 106. \nFor each test case, output one non-negative integer\u00a0\u2014 the minimum possible total cost of operations such that S would be transformed into T.\nIn the first test case, we shall not perform any operations as S is already equal to T, which is the set {1,2,3,4,5,6}.\nIn the second test case, initially, S={1,2,3,4,5,6,7}, and T={1,2,4,7}. We shall perform the following operations: \nThe total cost is 3+3+5=11. It can be shown that this is the smallest cost possible.\nIn the third test case, initially, S={1,2,3,4} and T={} (empty set). We shall perform 4 operations of k=1 to delete 1, 2, 3, and 4.\nIn the fourth test case, initially, S={1,2,3,4} and T={3}. We shall perform two operations with k=1 to delete 1 and 2, then perform one operation with k=2 to delete 4.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1734C \u2014 Removing Smallest MultiplesOne operation should be used to remove every element not belonging to T.Let v be an element not belonging to T. Suppose a x-cost operation removes value v, then v must be divisible by x. Furthermore, the multiples x,2x,\u22ef(k\u22121)x must have been already removed from S, where we write v=kx.Since removed elements stay removed, the above is only possible if all of x,2x,\u22ef(k\u22121)x does not belong to T.For each v, let f(v) be the smallest integer x satisfying the above condition. As we can always remove v using a v-cost operation, f(v)\u2264v and in particular f(v) exists.The total cost must be at least \u2211i\u2209Tf(i). We claim that this cost can be achieved.To do so, we should remove the required elements in ascending order. When removing v, we assume all w\u2209T with w<v have already been removed. At this state, an f(v)-cost operation would be able to remove v. It remains to find the values f(v). To do so efficiently, we can perform the above process in a bottom-up manner similar to the Sieve of Eratosthenes. Please refer to the code below for implementation details. The overall complexity is n(1+12+13+\u22ef+1n)=\u0398(nlogn). Code in C++#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n    int n;\n    cin >> n;\n    bool a[n + 1];\n    string str;\n    cin >> str;\n    for (int i = 1; i <= n; i++) {\n        a[i] = (str[i - 1] == '1');\n    }\n    long long ans = 0;\n    int cost[n + 1];\n    for (int i = n; i >= 1; i--) {\n        for (int j = i; j <= n; j += i) {\n            if (a[j]) break;\n            cost[j] = i;\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!a[i]) ans += cost[i];\n    }\n    cout << ans << '\\n';\n}\nint main() {\n    int t;\n    cin >> t;\n    while (t--) solve();\n}"
    },
    "1732A": {
        "title": "A. Bestie",
        "description": "You are given an array a consisting of n integers a1,a2,\u2026,an. Friends asked you to make the greatest common divisor (GCD) of all numbers in the array equal to 1. In one operation, you can do the following:\nYou need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to 1.\nEach test consists of multiple test cases. The first line contains an integer t (1\u2264t\u22645000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226420) \u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 the elements of the array.\nFor each test case, output a single integer \u2014 the minimum total cost of operations that will need to be performed so that the GCD of all numbers in the array becomes equal to 1.\nWe can show that it's always possible to do so.\nIn the first test case, the GCD of the entire array is already equal to 1, so there is no need to perform operations.\nIn the second test case, select i=1. After this operation, a1=gcd(2,1)=1. The cost of this operation is 1.\nIn the third test case, you can select i=1, after that the array a will be equal to [1,4]. The GCD of this array is 1, and the total cost is 2.\nIn the fourth test case, you can select i=2, after that the array a will be equal to [3,2,9]. The GCD of this array is 1, and the total cost is 2.\nIn the sixth test case, you can select i=4 and i=5, after that the array a will be equal to [120,60,80,4,5]. The GCD of this array is 1, and the total cost is 3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "constructive algorithms",
            "implementation",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1732A - BestieLet's make an important observation: gcd(n\u22121,n)=1 for any value of n. Moreover, choosing i=n\u22121 and i=n are the cheapest operations. From this we can conclude that the answer is \u22643.Let g be the gcd of all numbers in the array. Then we have the following cases: If g=1, then the operation can be omitted and the answer is 0, Otherwise, let's try the cheapest operation i=n. If gcd(g,n)=1, then the answer is 1. Otherwise, let's try the next cheapest operation, ie i=n\u22121. If gcd(g,n\u22121)=1, then the answer is 2. Otherwise, the answer is 3, since gcd(g,n\u22121,n)=1. "
    },
    "1731B": {
        "title": "B. Kill Demodogs",
        "description": "Demodogs from the Upside-down have attacked Hawkins again. El wants to reach Mike and also kill as many Demodogs in the way as possible.\nHawkins can be represented as an n\u00d7n grid. The number of Demodogs in a cell at the i-th row and the j-th column is i\u22c5j. El is at position (1,1) of the grid, and she has to reach (n,n) where she can find Mike. \nThe only directions she can move are the right (from (i,j) to (i,j+1)) and the down (from (i,j) to (i+1,j)). She can't go out of the grid, as there are doors to the Upside-down at the boundaries. \nCalculate the maximum possible number of Demodogs ans she can kill on the way, considering that she kills all Demodogs in cells she visits (including starting and finishing cells).\nPrint 2022\u22c5ans modulo 109+7. Modulo 109+7 because the result can be too large and multiplied by 2022 because we are never gonna see it again!\n(Note, you firstly multiply by 2022 and only after that take the remainder.)\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains one integer n (2\u2264n\u2264109)\u00a0\u2014 the size of the grid.\nFor each test case, print a single integer\u00a0\u2014 the maximum number of Demodogs that can be killed multiplied by 2022, modulo 109+7.\nIn the first test case, for any path chosen by her the number of Demodogs to be killed would be 7, so the answer would be 2022\u22c57=14154.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1731B - \u0423\u043d\u0438\u0447\u0442\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u0435\u043c\u043e\u0434\u043e\u0433\u043e\u0432To kill the maximum number of demodogs, El can travel in zigzag fashion, i.e. from (1,1) to (1,2) to (2,2) and so on. Thus the answer would be the sum of elements at (1,1), (1,2), (2,2) \u2026 (n,n). i.e. the answer is \u2211i=1ni\u22c5i+\u2211i=1n\u22121i(i+1)=n(n+1)(4n\u22121)6.And the answer you need to print is 2022n(n+1)(4n\u22121)6=337\u22c5n(n+1)(4n\u22121)(mod109+7)Proof:Let killsi,j be the maximum number of kills of all possible paths from (1,1) to (i,j).killsn\u22121,n\u22121\u2265killsi,n\u22121 + number of demodogs from (i+1,n\u22121) to (n\u22121,n\u22121) (\u2200i\u2208[1,n\u22122]).killsn\u22121,n\u22121\u2265killsi,n\u22121+\u2211j=i+1n\u22121j\u22c5(n\u22121)killsn\u22121,n\u22121\u2265killsi,n\u22121+(n\u22121\u2212i)((i+1)(n\u22121)+(n\u22122\u2212i)(n\u22121))2\u00a0(sum of A.P.)killsn\u22121,n\u22121\u2265killsi,n\u22121+(n\u22121\u2212i)(n\u22121)22\u00a0(1)Let killsZ be the number of kills if El travels in zigzag fashion, i.e. she goes to (n,n) after passing through (n\u22121,n\u22121): killsZn,n=killsn\u22121,n\u22121+n(n\u22121)+n\u22c5nLet killsNZ be the maximum number of kills If El goes to (n,n) after passing through (i,n) for some i in range of [1\u2026n\u22121], i.e. El goes from (1,1) to (i,n\u22121) to (i,n) to (n,n): killsNZn,n=killsi,n\u22121+no of demigods from\u00a0(i,n)\u00a0to\u00a0(n,n)killsNZn,n=killsi,n\u22121+\u2211j=inj\u22c5nkillsNZn,n=killsi,n\u22121+(n+1\u2212i)(n+i)n2killsZn,n\u2212killsNZn,n=killsn\u22121,n\u22121+n(n\u22121)+n\u22c5n\u2212killsi,n\u22121\u2212(n+1\u2212i)(n+i)n2\u00a0from\u00a0(1)killsZn,n\u2212killsNZn,n\u2265killsi,n\u22121+(n\u22121\u2212i)(n\u22121)22+n(n\u22121)+n\u22c5n\u2212killsi,n\u22121\u2212(n+1\u2212i)(n+i)n2killsZn,n\u2212killsNZn,n\u22652n2\u22123n\u2212n\u22c5i\u2212i\u221212killsZn,n\u2212killsNZn,n\u22650 since 2n2\u22123n\u2212n\u22c5i\u2212i\u22121\u22650 for all i\u2208[1,n\u22122].In other words, killsZn,n\u2265killsNZn,n Therefore zigzag path guarantees maximum number of demodog kills.Now, the last thing was taking the modulus. Modulus should always be taken after every multiply operation to avoid the overflow. You can refer to modular arithmetic for more details.And the main reason we told you to multiply the answer by 2022 is that we needed to divide it by 6. For division, we have to take inverse modulo in modular arithmetic. So, in order to avoid that, we gave you a multiple of 6, which is 2022. Code186975620"
    },
    "1730C": {
        "title": "C. Minimum Notation",
        "description": "You have a string s consisting of digits from 0 to 9 inclusive. You can perform the following operation any (possibly zero) number of times: \nWhat is the lexicographically smallest string you can get by performing these operations?\nA string a is lexicographically smaller than a string b of the same length if and only if the following holds: \nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then the test cases follow.\nEach test case consists of a single line that contains one string s (1\u2264|s|\u22642\u22c5105) \u2014 the string consisting of digits. Please note that s is just a string consisting of digits, so leading zeros are allowed.\nIt is guaranteed that the sum of lengths of s over all test cases does not exceed 2\u22c5105.\nPrint a single string \u2014 the minimum string that is possible to obtain.\nIn the first test case: \nNothing needs to be done in the second and third test cases.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1730C - Minimum NotationWe leave all suffix minimums by the digits mni (digits less than or equal to the minimum among the digits to the right of them), remove the rest and replace them with min(d+1,9) (using the described operations) and add to lexicographically minimum order on the right (due to the appropriate order of operations, this is possible). The suffix minimums mni should be left, because no matter what digit we leave after mni, it will be no less than mni, and therefore will not improve the answer. The rest must be removed at the end with operations, since there is a number to the right less than this one, i.e. if you remove everything before it (put mni at the current position), the answer will become less than if you leave another digit at this position.Jury solution: 173498569 "
    },
    "1729D": {
        "title": "D. Friends and the Restaurant",
        "description": "A group of n friends decide to go to a restaurant. Each of the friends plans to order meals for xi burles and has a total of yi burles (1\u2264i\u2264n). \nThe friends decide to split their visit to the restaurant into several days. Each day, some group of at least two friends goes to the restaurant. Each of the friends visits the restaurant no more than once (that is, these groups do not intersect). These groups must satisfy the condition that the total budget of each group must be not less than the amount of burles that the friends in the group are going to spend at the restaurant. In other words, the sum of all xi values in the group must not exceed the sum of yi values in the group.\nWhat is the maximum number of days friends can visit the restaurant?\nFor example, let there be n=6 friends for whom x = [8,3,9,2,4,5] and y = [5,3,1,4,5,10]. Then: \nIt can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill.\nSo, the maximum number of groups the friends can split into is 2. Friends will visit the restaurant for a maximum of two days. Note that the 3-rd friend will not visit the restaurant at all.\nOutput the maximum number of days the friends can visit the restaurant for given n, x and y.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the number of friends.\nThe second line of each test case contains exactly n integers x1,x2,\u2026,xn (1\u2264xi\u2264109). The value of xi corresponds to the number of burles that the friend numbered i plans to spend at the restaurant.\nThe third line of each test case contains exactly n integers y1,y2,\u2026,yn (1\u2264yi\u2264109). The value yi corresponds to the number of burles that the friend numbered i has.\nIt is guaranteed that the sum of n values over all test cases does not exceed 105.\nFor each test case, print the maximum number of days to visit the restaurant. If friends cannot form even one group to visit the restaurant, print 0.\nThe first test case in explained in the problem statement.\nIn the second test case, friends cannot form at least one group of two or more people.\nIn the third test case, one way to visit the restaurant in one day is to go in a group of all three friends (1+3+10\u22652+3+7). Note that they do not have the option of splitting into two groups.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1729D - Friends and the RestaurantFirst, we sort the friends in descending order of yi\u2212xi. Now for each friend we know the amount of money he lacks, or vice versa, which he has in excess.In order to maximize the number of days, it is most advantageous for friends to break into pairs. It is the number of groups that matters, not the number of people in the group, so adding a third person to the pair won't improve the answer in any way.Let's solve the problem using two pointers: for the richest friend, find the first friend from the end such that the sum of their values y exceeds the sum of their values x. Then repeat this for all subsequent friends until the pointers meet.If no pair could be formed, or none of the friends has a value x greater than y, then the answer is -1.Otherwise, print the number of pairs formed. Solution#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<ll>x(n), y(n);\n    vector<pair<ll, int>>dif(n);\n\n    for(auto &i : x) cin >> i;\n    for(auto &i: y) cin >> i;\n    for(int i = 0; i < n; i++){\n        dif[i].first = y[i] - x[i];\n        dif[i].second = i;\n    }\n    sort(dif.begin(), dif.end());\n    reverse(dif.begin(), dif.end());\n\n    int j = n - 1, cnt = 0;\n\n    for(int i = 0; i < n; i++){\n        while(j > i && dif[i].first + dif[j].first < 0) j--;\n        if(j <= i) break;\n        cnt++; j--;\n    }\n    cout << cnt << endl;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n}"
    },
    "1729C": {
        "title": "C. Jumping on Tiles",
        "description": "Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string s.\nIn other words, you are given a string s consisting of lowercase Latin letters.\nInitially, Polycarp is on the first tile of the row and wants to get to the last tile by jumping on the tiles. Jumping from i-th tile to j-th tile has a cost equal to |index(si)\u2212index(sj)|, where index(c) is the index of the letter c in the alphabet (for example, index('a')=1, index('b')=2, ..., index('z')=26) .\nPolycarp wants to get to the n-th tile for the minimum total cost, but at the same time make maximum number of jumps.\nIn other words, among all possible ways to get to the last tile for the minimum total cost, he will choose the one with the maximum number of jumps.\nPolycarp can visit each tile at most once.\nPolycarp asks you to help\u00a0\u2014 print the sequence of indices of string s on which he should jump.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nEach test case is given by the string s (2\u2264|s|\u22642\u22c5105), where |s|\u00a0\u2014 is the length of string s. The string s consists of lowercase Latin letters.\nIt is guaranteed that the sum of string lengths s over all test cases does not exceed 2\u22c5105.\nThe answer to each test case consists of two lines.\nIn the first line print two integers cost, m, where cost is the minimum total cost of the path, and m is the maximum number of visited tiles Polycarp can make to get to n-th tiles for the minimum total cost cost (i.e. the number of jumps is m\u22121).\nIn the next line print m different numbers j1,j2,\u2026,jm (1\u2264ji\u2264|s|)\u00a0\u2014 the sequence of indices of the tiles Polycarp will jump on. The first number in the sequence must be 1 (that is, j1=1) and the last number must be the value of |s| (that is, jm=|s|).\nIf there are multiple answers, print any of them.\nIn the first test case, the required path corresponds to the picture:\nIn this case, the minimum possible total cost of the path is achieved. Since index('l')=12, index('o')=15, index('g')=7, index('i')=9, index('c')=3, then the total cost of the path is |12\u22129|+|9\u22127|+|7\u22123|=3+2+4=9.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "strings",
            "*1100"
        ],
        "solutions": "1729C - Jumping on TilesIdea: MikeMirzayanov, Aris TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nvoid solve() {\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    map<char, vector<int>> let_to_ind;\n\n    for (int i = 0; i < n; ++i) {\n        let_to_ind[s[i]].push_back(i);\n    }\n\n    int direction = (s[0] < s[n - 1]) ? 1 : -1;\n    vector<int> ans;\n\n    for (char c = s[0]; c != s[n - 1] + direction; c += direction) {\n        for (auto now : let_to_ind[c]) {\n            ans.push_back(now);\n        }\n    }\n\n    int cost = 0;\n    for (int i = 1; i < ans.size(); i++)\n        cost += abs(s[ans[i]] - s[ans[i - 1]]);\n\n    cout << cost << \" \" << ans.size() << '\\n';\n    for (auto now : ans) {\n        cout << now + 1 << \" \";\n    }\n    cout << '\\n';\n}\nint main() {\n    int tests;\n    cin >> tests;\n    forn(tt, tests) {\n        solve();\n    }\n}"
    },
    "1726B": {
        "title": "B. Mainak and Interesting Sequence",
        "description": "Mainak has two positive integers n and m.\nMainak finds a sequence a1,a2,\u2026,an of n positive integers interesting, if for all integers i (1\u2264i\u2264n), the bitwise XOR of all elements in a which are strictly less than ai is 0. Formally if pi is the bitwise XOR of all elements in a which are strictly less than ai, then a is an interesting sequence if p1=p2=\u2026=pn=0.\nFor example, sequences [1,3,2,3,1,2,3], [4,4,4,4], [25] are interesting, whereas [1,2,3,4] (p2=1\u22600), [4,1,1,2,4] (p1=1\u22951\u22952=2\u22600), [29,30,30] (p2=29\u22600) aren't interesting.\nHere a\u2295b denotes bitwise XOR of integers a and b.\nFind any interesting sequence a1,a2,\u2026,an (or report that there exists no such sequence) such that the sum of the elements in the sequence a is equal to m, i.e. a1+a2\u2026+an=m.\nAs a reminder, the bitwise XOR of an empty sequence is considered to be 0.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line and the only line of each test case contains two integers n and m (1\u2264n\u2264105, 1\u2264m\u2264109) \u2014 the length of the sequence and the sum of the elements.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, if there exists some interesting sequence, output \"Yes\" on the first line, otherwise output \"No\". You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIf the answer is \"Yes\", output n positive integers a1,a2,\u2026,an (ai\u22651), forming an interesting sequence such that a1+a2\u2026+an=m. If there are multiple solutions, output any.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1726B - Mainak and Interesting SequenceLemma: In an interesting sequence a1,a2,\u2026,an, every element other than the largest must have even occurrences.Proof: For the sake of contradiction, assume that for some x (x>0), such than x\u2260maxi=1n{ai}, x appears an odd number of times. Let P(z) denote the bitwise XOR of all elements in a that are less than z. By assumption P(x)=0. Now, since x is not maximum of the sequence a, there exists y in a, such that x<y and there are no other elements t such that x<t<y (in other words, y is the immediate larger element of x in a). Again, P(y)=0 as well by assumption. However, since x appears an odd number of times, we have: 0=P(y)=P(x)\u2295x=0\u2295x=x, which is a contradiction as x must be positive.This gives us an O(n) solution as follows: Case - I: If n>m\u00a0\u2014 It is clearly impossible to construct an interesting sequence with sum equal to m (as integers must be positive). Case - II: n is odd\u00a0\u2014 Create (n\u22121) occurrences of 1, and a single occurrence of (m\u2212n+1). Case - III: n is even, m is even\u00a0\u2014 Create (n\u22122) occurrences of 1 and two occurrences of (m\u2212n+2)/2. Case - IV: n is even, m is odd\u00a0\u2014 No such interesting sequences exist.  Proof: For the sake of contradiction assume that such an interesting sequence, a, exists. Since m is odd, there must be an odd number x that occurs an odd number of times in a. Again since n is even there must be another integer y (different from x) that occurs an also odd number of times. Hence either x or y (whichever is lower) violates the lemma.  ImplementationC++#include<bits/stdc++.h>\nusing namespace std;\n\ninline void test_case(){\n\t\n\tint N, M;\n\tcin >> N >> M;\n\n\tif(((N % 2 == 0) && (M % 2 == 1)) || (M < N)){ // impossible cases, M < N and (M - odd, N - even)\n\t\tcout << \"NO\\n\";\n\t}else if((N % 2) == 1){ // (N - odd)\n\t\tcout << \"YES\\n\";\n\t\tfor(int i = 1; i < N; ++i){\n\t\t\tcout << \"1 \";\n\t\t}\n\t\tcout << M - N + 1 << '\\n';\n\t}else{ // (N - even, M - even)\n\t\tcout << \"YES\\n\";\n\t\tfor(int i = 2; i < N; ++i){\n\t\t\tcout << \"1 \";\n\t\t}\n\t\tcout << (M - N + 2) / 2 << ' ' << (M - N + 2) / 2 << '\\n';\n\t}\n\n}\n\nsigned main(){\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tint test_case_number;\n\tcin>>test_case_number;\n\twhile(test_case_number--)\n\t\ttest_case();\n\t\n\treturn 0;\n} Pythonimport sys\ninput = sys.stdin.readline\n\nt=int(input())\nfor _ in range(t):\n    n,m=map(int,input().split())\n    if n>m or (n%2==0 and m%2==1):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        ans=[]\n        if n%2==1:\n            ans.extend([1]*(n-1)+[m-n+1])\n        else:\n            ans.extend([1]*(n-2)+[(m-n+2)//2]*2)\n        print(*ans,sep=' ') "
    },
    "1725B": {
        "title": "B. Basketball Together",
        "description": "A basketball competition is held where the number of players in a team does not have a maximum or minimum limit (not necessarily 5 players in one team for each match). There are N candidate players in the competition that will be trained by Pak Chanek, the best basketball coach on earth. The i-th candidate player has a power of Pi.\nPak Chanek will form zero or more teams from the N candidate players on the condition that each candidate player may only join in at most one team. Each of Pak Chanek's teams will be sent to compete once with an enemy team that has a power of D. In each match, the team sent is said to defeat the enemy team if the sum of powers from the formed players is strictly greater than D.\nOne of Pak Chanek's skills is that when a team that has been formed plays in a match, he can change the power of each player in the team to be equal to the biggest player power from the team.\nDetermine the maximum number of wins that can be achieved by Pak Chanek.\nThe first line contains two integers N and D (1\u2264N\u2264105, 1\u2264D\u2264109) \u2014 the number of candidate players and the power of the enemy team.\nThe second line contains N integers P1,P2,\u2026,PN (1\u2264Pi\u2264109) \u2014 the powers of all candidate players.\nA line containing an integer representing the maximum number of wins that can be achieved by Pak Chanek.\nThe 1-st team formed is a team containing players 4 and 6. The power of each player in the team becomes 100. So the total power of the team is 100+100=200>180.\nThe 2-nd team formed is a team containing players 1, 2, and 5. The power of each player in the team becomes 90. So the total power of the team is 90+90+90=270>180.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1725B - Basketball TogetherFor a team of c players with a biggest power of b, the total power of the team is b\u00d7c. So for a team with a biggest power of b to win, it needs to have at least \u2308D+1b\u2309 players.For each player i, we can calculate a value f(i) which means a team that has player i as its biggest power needs to have at least f(i) players to win. We can see that the bigger the value of Pi, the smaller the value of f(i).We can also see that if a formed team is said to have a fixed biggest power and a fixed number of players, the powers of the players that are less than the biggest power do not affect the total power of the team. So those players can be anyone.Using the information above, we can form the teams using a greedy method. We iterate through each candidate player starting from the biggest Pi and form new teams with each next biggest candidate player power as each team's biggest power. We do that while maintaining the total number of extra players required to make all formed teams win. We stop once the number of remaining players is not enough for the total number of extra players required.Time complexity: O(NlogN)"
    },
    "1722D": {
        "title": "D. Line",
        "description": "There are n people in a horizontal line, each looking either to the left or the right. Each person counts the number of people in the direction they are looking. The value of the line is the sum of each person's count.\nFor example, in the arrangement LRRLL, where L stands for a person looking left and R stands for a person looking right, the counts for each person are [0,3,2,3,4], and the value is 0+3+2+3+4=12.\nYou are given the initial arrangement of people in the line. For each k from 1 to n, determine the maximum value of the line if you can change the direction of at most k people.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the line.\nThe following line contains a string consisting of n characters, each of which is either L or R, representing a person facing left or right, respectively\u00a0\u2014 the description of the line.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPlease note that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor each test case, output n space-separated non-negative integers\u00a0\u2014 the maximum value of the line if you can change the direction of at most k people for each k from 1 to n, inclusive.\nIn the first test case: \nIn the second test case, it is optimal to only change the direction of the first person for all k from 1 to 5 (that is, make the line RRRLL).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1722D - \u0420\u044f\u0434For each person, let's calculate how much the value will change if they turn around. For example, in the line LRRLL, if the i-th person turns around, then the value of the line will change by +4, \u22122, 0, \u22122, \u22124, respectively. (For instance, if the second person turns around, they see 3 people before and 1 person after, so the value of the line changes by \u22122 if they turn around.)Now note that if a person turns around, it doesn't affect anyone else's value. So the solution is a greedy one: let's sort the array of values in increasing order. Afterwards, we should go from the left to the right, and see if the value will increase if this person turns around; if it does, we should add it to the current total and continue.The time complexity of this solution is O(nlogn) per testcase. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tlong long tot = 0;\n\tvector<long long> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == 'L') {\n\t\t\tv.push_back((n - 1 - i) - i);\n\t\t\ttot += i;\n\t\t}\n\t\telse {\n\t\t\tv.push_back(i - (n - 1 - i));\n\t\t\ttot += n - 1 - i;\n\t\t}\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tfor (int i = 0; i < n; i++) {\n\t\tif (v[i] > 0) {tot += v[i];}\n\t\tcout << tot << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}"
    },
    "1721B": {
        "title": "B. Deadly Laser",
        "description": "The robot is placed in the top left corner of a grid, consisting of n rows and m columns, in a cell (1,1).\nIn one step, it can move into a cell, adjacent by a side to the current one: \nThe robot can't move outside the grid.\nThe cell (sx,sy) contains a deadly laser. If the robot comes into some cell that has distance less than or equal to d to the laser, it gets evaporated. The distance between two cells (x1,y1) and (x2,y2) is |x1\u2212x2|+|y1\u2212y2|.\nPrint the smallest number of steps that the robot can take to reach the cell (n,m) without getting evaporated or moving outside the grid. If it's not possible to reach the cell (n,m), print -1.\nThe laser is neither in the starting cell, nor in the ending cell. The starting cell always has distance greater than d to the laser.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains five integers n,m,sx,sy,d (2\u2264n,m\u22641000; 1\u2264sx\u2264n; 1\u2264sy\u2264m; 0\u2264d\u2264n+m)\u00a0\u2014 the size of the grid, the cell that contains the laser and the evaporating distance of the laser.\nThe laser is neither in the starting cell, nor in the ending cell ((sx,sy)\u2260(1,1) and (sx,sy)\u2260(n,m)). The starting cell (1,1) always has distance greater than d to the laser (|sx\u22121|+|sy\u22121|>d).\nFor each testcase, print a single integer. If it's possible to reach the cell (n,m) from (1,1) without getting evaporated or moving outside the grid, then print the smallest amount of steps it can take the robot to reach it. Otherwise, print -1.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1721B - Deadly LaserFirst, let's determine if it's possible to reach the end at all. If the laser's field doesn't span until any wall, then it's surely possible\u00a0\u2014 just stick to the wall yourself.If it touches at most one wall, it's still possible. If it's the bottom wall or the left wall, then take the path close to the top and the right wall. Vice versa, if it's the top wall or the right wall, then take the path close to the bottom and the left wall.What if both of these paths are locked? That means that the laser touches at least two walls at the same time: the top one and the left one, or the bottom one and the right one. Turns out, it's completely impossible to reach the end in either of these two cases. Just draw a picture and see for yourself.Thus, we can always take at least one of the path sticking to the walls. The distance from the start to the end is |n\u22121|+|m\u22121|, and both of these paths are exactly this long. So the answer is always either -1 or n+m\u22122.To check if the laser touches a wall with its field, you can either use a formula or check every cell adjacent to a wall.Overall complexity: O(1) or O(n+m) per testcase. Solution (awoo)for _ in range(int(input())):\n\tn, m, sx, sy, d = map(int, input().split())\n\tif min(sx - 1, m - sy) <= d and min(n - sx, sy - 1) <= d:\n\t    print(-1)\n\telse:\n\t    print(n + m - 2)"
    },
    "1720C": {
        "title": "C. Corners",
        "description": "You are given a matrix consisting of n rows and m columns. Each cell of this matrix contains 0 or 1.\nLet's call a square of size 2\u00d72 without one corner cell an L-shape figure. In one operation you can take one L-shape figure, with at least one cell containing 1 and replace all numbers in it with zeroes.\nFind the maximum number of operations that you can do with the given matrix.\nThe first line contains one integer t (1\u2264t\u2264500) \u2014 the number of test cases. Then follow the descriptions of each test case.\nThe first line of each test case contains two integers n and m (2\u2264n,m\u2264500) \u2014 the size of the matrix.\nEach of the following n lines contains a binary string of length m \u2014 the description of the matrix.\nIt is guaranteed that the sum of n and the sum of m over all test cases does not exceed 1000.\nFor each test case output the maximum number of operations you can do with the given matrix.\nIn the first testcase one of the optimal sequences of operations is the following (bold font shows l-shape figure on which operation was performed): \nIn the third testcase from the sample we can not perform any operation because the matrix doesn't contain any ones.\nIn the fourth testcase it does not matter which L-shape figure we pick in our first operation. We will always be left with single one. So we will perform 2 operations.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1717B": {
        "title": "B. Madoka and Underground Competitions",
        "description": "Madoka decided to participate in an underground sports programming competition. And there was exactly one task in it:\nA square table of size n\u00d7n, where n is a multiple of k, is called good if only the characters '.' and 'X' are written in it, as well as in any subtable of size 1\u00d7k or k\u00d71, there is at least one character 'X'. In other words, among any k consecutive vertical or horizontal cells, there must be at least one containing the character 'X'.\nOutput any good table that has the minimum possible number of characters 'X', and also the symbol 'X' is written in the cell (r,c). Rows are numbered from 1 to n from top to bottom, columns are numbered from 1 to n from left to right.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first and the only line of each test case contains four integers n, k, r, c (1\u2264n\u2264500,1\u2264k\u2264n,1\u2264r,c\u2264n)\u00a0\u2014 the size of the table, the integer k and the coordinates of the cell, which must contain the character 'X'. It is guaranteed that n is a multiple of k.\nIt is guaranteed that the sum of n over all test cases does not exceed 500.\nFor each test case, output n lines, each consisting of n characters '.' and 'X',\u00a0\u2014 the desired table. If there are several answers, then you can output anyone.\nLet's analyze the first test case.\nThe following tables can be printed as the correct answer:\nNote that the following table is invalid because cell (3,2) does not contain the character 'X': \nIn the second test case, the only correct table is: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1715B": {
        "title": "B. Beautiful Array",
        "description": "Stanley defines the beauty of an array a of length n, which contains non-negative integers, as follows: n\u2211i=1\u230aaik\u230b, which means that we divide each element by k, round it down, and sum up the resulting values.\nStanley told Sam the integer k and asked him to find an array a of n non-negative integers, such that the beauty is equal to b and the sum of elements is equal to s. Help Sam\u00a0\u2014 find any of the arrays satisfying the conditions above.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains integers n, k, b, s (1\u2264n\u2264105, 1\u2264k\u2264109, 0\u2264b\u2264109, 0\u2264s\u22641018).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print \u22121 if such array a does not exist. Otherwise print n non-negative integers a1,a2,\u2026,an (0\u2264ai\u22641018)\u00a0\u2014 the answer.\nIn the first, the second, the fifth and the sixth test cases of the example it is possible to show that such array does not exist.\nIn the third testcase of the example a=[0,0,19]. The sum of elements in it is equal to 19, the beauty of it is equal to (\u230a06\u230b+\u230a06\u230b+\u230a196\u230b)=(0+0+3)=3.\nIn the fourth testcase of the example a=[0,3,3,3,29]. The sum of elements in it is equal to 38, the beauty of it is equal to (0+0+0+0+7)=7.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1715B - Beautiful ArrayTo start with, the sum of the numbers in the array s cannot be less, than k\u22c5b (where k is the number by which we divide, and b is beauty (s\u2265k\u22c5b))It is important, that s\u2264k\u22c5b+(k\u22121)\u22c5n. Let's assume that is not true. Consider the sum of divisible parts of numbers in the array: it obviously does not exceed k\u22c5b, thus the sum of remainders is at least (k\u22121)\u22c5n+1, which means, that at least one of the numbers' remainders is k, which is impossible by definition of the remainder.That way we got the criteria for the existence of the answer: k\u22c5b\u2264s\u2264k\u22c5b+(k\u22121)\u22c5n.If there does exist an answer, then we can use the following algorithm:  Assign k\u22c5b to any of the n cells of the array.  Iterate over all the cells (including the cell from the previous item) and add min(s\u2212sum,k\u22121) to the current cell, where sum is the current sum of the elements.    \u0421++ code: 169162178 Python code: 169161968 "
    },
    "1713C": {
        "title": "C. Build Permutation",
        "description": "A 0-indexed array a of size n is called good if for all valid indices i (0\u2264i\u2264n\u22121), ai+i is a perfect square\u2020.\nGiven an integer n. Find a permutation\u2021 p of [0,1,2,\u2026,n\u22121] that is good or determine that no such permutation exists.\n\u2020 An integer x is said to be a perfect square if there exists an integer y such that x=y2.\n\u2021 An array b is a permutation of an array a if b consists of the elements of a in arbitrary order. For example, [4,2,3,4] is a permutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output n distinct integers p0,p1,\u2026,pn\u22121 (0\u2264pi\u2264n\u22121) \u2014 the permutation p \u2014 if the answer exists, and \u22121 otherwise.\nIn the first test case, we have n=3. The array p=[1,0,2] is good since 1+0=12, 0+1=12, and 2+2=22\nIn the second test case, we have n=4. The array p=[0,3,2,1] is good since 0+0=02, 3+1=22, 2+2=22, and 1+3=22.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "math",
            "*1200"
        ],
        "solutions": "1713C - Build PermutationFirst, let's prove that the answer always exists. Let's call the smallest square number that is not smaller than k is h. Therefore h\u22642\u22c5k, which means h\u2212k\u2264k. Proof. So we can fill pi=h\u2212i for (h\u2212k\u2264i\u2264k). Using this method we can recursively reduce k to h\u2212k\u22121, then all the way down to \u22121.We can prove that h\u2212k\u22650, as h\u2265k.Time complexity: O(n) Solution#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, ans[N];\n\nvoid recurse(int r) {\n\tif (r < 0) return;\n\tint s = sqrt(2*r); s *= s;\n\tint l = s - r; recurse(l - 1);\n\tfor (; l <= r; l++, r--) {\n\t\tans[l] = r; ans[r] = l;\n\t}\n}\n\nint main() {\n\tint tc; cin >> tc;\n\twhile (tc--) {\n\t\tcin >> n; recurse(n - 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcout << ans[i] << ' ';\n\t\tcout << '\\n';\n\t}\n} Feedback Didn't solve \n\n    \n\n\n272\n\n\n\n Good problem \n\n    \n\n\n614\n\n\n\n Average problem \n\n    \n\n\n58\n\n\n\n Bad problem \n\n    \n\n\n90\n\n\n\n "
    },
    "1713B": {
        "title": "B. Optimal Reduction",
        "description": "Consider an array a of n positive integers.\nYou may perform the following operation: \nLet's call f(a) the minimum number of operations needed to change array a into an array of n zeros.\nDetermine if for all permutations\u2020 b of a, f(a)\u2264f(b) is true. \n\u2020 An array b is a permutation of an array a if b consists of the elements of a in arbitrary order. For example, [4,2,3,4] is a permutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 description of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print \"YES\" (without quotes) if for all permutations b of a, f(a)\u2264f(b) is true, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first test case, we can change all elements to 0 in 5 operations. It can be shown that no permutation of [2,3,5,4] requires less than 5 operations to change all elements to 0.\nIn the third test case, we need 5 operations to change all elements to 0, while [2,3,3,1] only needs 3 operations.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solutions": "1713B - Optimal ReductionLet's call M=max(a1,a2,\u2026,an).The problem asks us to make all its elements become 0 in some operations. And for each operation, we subtract each elements in an subarray by 1. Thus, every largest elements of the array have to be decreased in at least M operations. And also because of that, min(f(p)) over all permutations p of a is never less than M.Every permutations p of a such that f(p)=M have the same construction. That is, they can be divided into 2 subarrays where the left subarray is sorted in non-decreasing order, and the right subarray is sorted in non-increasing order. In other words, the elements of the array should form a mountain. Why?This is how to perform the operations: assign l equal to the index of the leftmost element whose value is not 0, and assign r equal to the index of the rightmost element whose value is also not 0, then subtract each element al,al+1,\u2026,ar by 1. Repeat the operation until all elements become 0. The thing is each element of the array is always greater or equal than every elements in the left side or the right side of it so it can never become negative at some point of performing the operations. Besides, all the largest elements are also included in each operation that we perform, which mean we've achieved the goal to make all elements of the array become 0 in M operations.So how to check whether f(a)=M or not? Well, we can define preLen equal to the length of the longest prefix which is sorted in non-decreasing order. Then define sufLen equal to the length of the longest suffix which is sorted in non-increasing order. If preLen+sufLen\u2265n, the answer is YES.Time complexity: O(n) Solution#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, a[N];\n\nint main() {\n    int tc;\n    for (cin >> tc; tc--; ) {\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n\n        int preLen = 1;\n        while (preLen < n && a[preLen] <= a[preLen + 1])\n            preLen++;\n\n        int sufLen = 1;\n        while (sufLen < n && a[n-sufLen] >= a[n-sufLen + 1])\n            sufLen++;\n\n        if (preLen + sufLen >= n)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n} Feedback Didn't solve \n\n    \n\n\n125\n\n\n\n Good problem \n\n    \n\n\n347\n\n\n\n Average problem \n\n    \n\n\n81\n\n\n\n Bad problem \n\n    \n\n\n66\n\n\n\n "
    },
    "1712C": {
        "title": "C. Sort Zero",
        "description": "You are given an array of n positive integers a1,a2,\u2026,an. \nIn one operation you do the following: \nFind the minimum number of operations required to sort the array in non-decreasing order.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains n positive integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print one integer\u00a0\u2014 the minimum number of operations required to sort the array in non-decreasing order.\nIn the first test case, you can choose x=3 for the operation, the resulting array is [0,0,2].\nIn the second test case, you can choose x=1 for the first operation and x=3 for the second operation, the resulting array is [0,0,0,0].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1712C - Sort ZeroAn array is sorted in non-decreasing order if and only if there is no index i such that ai>ai+1. This leads to a strategy: while there is at least one such index i, apply one operation with x=ai.Why is this optimal? Since our operation can only decrease values, and we must decrease ai so that ai>ai+1 is no longer true, this leaves us no choice but to use the operation with x=ai.You can simulate this strategy by maintaining a set of bad indices, since if an index i becomes bad, after you apply an operation with x=ai, it can never become bad again. So in total, there are at most 2\u22c5(n\u22121) operations with the set.Complexity: O(nlogn) or O(n), depending on which set you use.Note: you can solve the problem in O(n) by noticing that if an index i is bad, we need to apply the operation for all unique non-zero values in {a1\u2026ai}. This is also quite a bit shorter to code. Solution#include <bits/stdc++.h>\n \n#define all(x) (x).begin(), (x).end()\n#define allr(x) (x).rbegin(), (x).rend()\n#define gsize(x) (int)((x).size())\n \nconst char nl = '\\n';\ntypedef long long ll;\ntypedef long double ld;\n \nusing namespace std;\n \nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\t\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tint n;\n\t\tcin >> n;\n\t\t\n\t\tvector<int> a(n);\n\t\tmap<int, vector<int>> p;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a[i];\n\t\t\tp[a[i]].push_back(i);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tset<int> ts;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tif (a[i] > a[i + 1]) ts.insert(i);\n\t\t}\n\t\t\n\t\twhile (!ts.empty()) {\n\t\t\tint i = *ts.begin();\n\t\t\tint x;\n\t\t\tif (a[i] > 0) {\n\t\t\t\tx = a[i];\n\t\t\t} else {\n\t\t\t\tx = a[i + 1];\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j: p[x]) {\n\t\t\t\ta[j] = 0;\n\t\t\t\tts.erase(j - 1);\n\t\t\t\tts.erase(j);\n\t\t\t\tif (j > 0 && a[j - 1] > a[j]) ts.insert(j - 1);\n\t\t\t\tif (j + 1 < n && a[j] > a[j + 1]) ts.insert(j);\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t\t\n\t\tcout << ans << nl;\n\t}\n}\nBonus: solve for when ai can also be negative."
    },
    "1708B": {
        "title": "B. Difference of GCDs",
        "description": "You are given three integers n, l, and r. You need to construct an array a1,a2,\u2026,an (l\u2264ai\u2264r) such that gcd(i,ai) are all distinct or report there's no solution.\nHere gcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line contains three integers n, l, r (1\u2264n\u2264105, 1\u2264l\u2264r\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, if there is no solution, print \"NO\" (without quotes). You can print letters in any case (upper or lower).\nOtherwise, print \"YES\" (without quotes). In the next line, print n integers a1,a2,\u2026,an\u00a0\u2014 the array you construct.\nIf there are multiple solutions, you may output any.\nIn the first test case, gcd(1,a1),gcd(2,a2),\u2026,gcd(5,a5) are equal to 1, 2, 3, 4, 5, respectively.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1708B - Difference of GCDsgcd(i,ai)\u2264i. Because all gcd(i,ai) are different, then gcd(i,ai)=i, which means ai is the multiple of i. To check if there is such ai, just check if ai=(\u230al\u22121i\u230b+1)\u22c5i (the minimum multiple of i that is strictly bigger than l\u22121) is less than r.Time complexity O(n) for each test case. CodeBy Imakf #include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr ,__VA_ARGS__)\n#define __FILE(x)\\\n\tfreopen(#x\".in\" ,\"r\" ,stdin);\\\n\tfreopen(#x\".out\" ,\"w\" ,stdout)\n#define LL long long\n\nconst int MX = 1e5 + 23;\nconst LL MOD = 998244353;\n\nint read(){\n\tchar k = getchar(); int x = 0;\n\twhile(k < '0' || k > '9') k = getchar();\n\twhile(k >= '0' && k <= '9') x = x * 10 + k - '0' ,k = getchar();\n\treturn x;\n}\n\nint a[MX];\nvoid solve(){\n\tint n = read() ,l = read() ,r = read();\n\tint ok = 1;\n\tfor(int i = 1 ; i <= n ; ++i){\n\t\ta[i] = ((l - 1) / i + 1) * i;\n\t\tok = ok && a[i] <= r;\n\t}\n\tif(ok){\n\t\tputs(\"YES\");\n\t\tfor(int i = 1 ; i <= n ; ++i)\n\t\t\tprintf(\"%d%c\" ,a[i] ,\" \\n\"[i == n]);\n\t}\n\telse puts(\"NO\");\n}\n\nint main(){\n\tint T = read();\n\tfor(int i = 1 ; i <= T ; ++i){\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
    },
    "1706B": {
        "title": "B. Making Towers",
        "description": "You have a sequence of n colored blocks. The color of the i-th block is ci, an integer between 1 and n.\nYou will place the blocks down in sequence on an infinite coordinate grid in the following way. \nA tower is formed by s blocks such that they are placed at positions (x,y),(x,y+1),\u2026,(x,y+s\u22121) for some position (x,y) and integer s. The size of the tower is s, the number of blocks in it. A tower of color r is a tower such that all blocks in it have the color r.\nFor each color r from 1 to n, solve the following problem independently: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. \nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains n integers c1,c2,\u2026,cn (1\u2264ci\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers. The r-th of them should be the maximum size of an tower of color r you can form by following the given rules. If you cannot form any tower of color r, the r-th integer should be 0.\nIn the first test case, one of the possible ways to form a tower of color 1 and size 3 is: \nThe blocks at positions (0,0), (0,1), and (0,2) all have color 1, forming an tower of size 3.\nIn the second test case, note that the following placement is not valid, since you are not allowed to place block 6 under block 5:\nIt can be shown that it is impossible to form a tower of color 4 and size 3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1706B - Making TowersWhen can two blocks of the same color form two consecutive elements of a tower? Formally, if we have two blocks of the same color at indices i and j such that i<j, how can we tell if it is possible to place them at (xi,yi) and (xi,yi+1) respectively?As it turns out, they can be placed like this if and only if i and j have different parities. First, if they have the same parity, it is impossible to place them this way. Note that xi+yi must have a different parity from xi+1+yi+1, since these sums must differ by exactly 1. So, if i and j have the same parity, then xi+yi must also have the same parity as xj+yj. But we want them to be vertically adjacent, which is not possible if their parities must be the same. So, it is impossible to make two blocks with indices of the same parity adjacent to each other.Next, there is a valid construction if you want to put blocks i and j together when they have different parities. Say that block i will go at position (xi,yi) and block j goes at position (xi,yi+1). If j=i+1, then we are done. Now, let's say that j=i+3. Then, we can place block i+1 at (xi+1,yi) and block j\u22121 at position (xi+1,yi+1). What if j=i+5? Then we can do the same as the previous case, and then put block i+2 at (xi+2,yi) and block j\u22122 at (xi+2,yi+1). Essentially, we are making the blocks between i and j into a horizontal line extending out for j\u2212i\u221212 blocks then coming back in.If there are already blocks to the right of (xi,yi), then we can do the same construction but extending out to the left. Note that since we cannot move down, at least one of the right and left side must be open.There are two ways we can go from here:First, there is a DP solution. Let's imagine the naive O(n2) dp: We say that dp[i][c] is the maximum size of a tower with color c, such that the last block placed was at index i. The transitions look like this: dp[i][ci]=maxj<i,j\u2261\u0338i(mod2)(dp[j][ci]+1). We check all j<i such that j and i have different parities, then see if adding a block to this tower makes a better solution. To optimize it, we can notice that for the first DP dimension (index), only the parity of the index matters \u00a0\u2014 for each color, we just need to keep track of the maximum dp[i][c] for even and odd i.We will iterate through all blocks ai, maintaining dp[p][c], which contains the maximum size of a tower with color c, where the last block included in the tower had an index with parity p (p=0 indicates an even index, p=1 indicates an odd index). If the current index is even, we set dp[0][ci]=max(dp[0][ci],dp[1][ci]+1). If it is odd, we set dp[1][ci]=max(dp[1][ci],dp[0][ci]+1). The solution runs in linear time.Alternatively, there's a greedy solution. After selecting a block, the next block selected must always have the opposite parity. Therefore, it makes sense to greedily select the first block of the same color with opposite parity, since it will never improve the answer if we select a later block. For each color, we start from the first block and iterate through, adding each block to the sequence if and only if it has a different parity from the last one. CodeSolution 1 (BucketPotato): 164798955Solution 2 (BucketPotato): 164799024Problem C Solution"
    },
    "1704C": {
        "title": "C. Virus",
        "description": "There are n houses numbered from 1 to n on a circle. For each 1\u2264i\u2264n\u22121, house i and house i+1 are neighbours; additionally, house n and house 1 are also neighbours.\nInitially, m of these n houses are infected by a deadly virus. Each morning, Cirno can choose a house which is uninfected and protect the house from being infected permanently.\nEvery day, the following things happen in order:\nCirno wants to stop the virus from spreading. Find the minimum number of houses that will be infected in the end, if she optimally choose the houses to protect.\nNote that every day Cirno always chooses a house to protect before the virus spreads. Also, a protected house will not be infected forever.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of test cases follows.\nThe first line of each test case consists of two positive integers n,m (5\u2264n\u2264109, 1\u2264m\u2264min(n,105)) \u2014 the number of houses on the circle, and the number of houses that are initially infected. \nThe second line of each test case consists of m distinct positive integers a1,a2,\u22ef,am (1\u2264ai\u2264n) \u2014 the indices of the houses infected initially.\nIt is guaranteed that the sum of m over all test cases does not exceed 105.\nFor each test case, output an integer on a separate line, which is the minimum number of infected houses in the end.\nIn the first test case:\nAt the start of the first day, house 3, 6, 8 are infected. Choose house 2 to protect.\nAt the start of the second day, house 3, 4, 5, 6, 7, 8, 9 are infected. Choose house 10 to protect.\nAt the start of the third day, no more houses are infected.\nIn the second test case:\nAt the start of the first day, house 2, 5 are infected. Choose house 1 to protect.\nAt the start of the second day, house 2, 3, 4, 5, 6 are infected. No more available houses can be protected.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1704C - VirusFirst, considering it is easier to calculate the number of houses which are not infected, so we focus on it firstly.Conspicuously, if between ai and ai+1 there are x houses (Array a has been sorted.), and the infection will last y days, there will remain x\u22122\u00d7y houses on the end. Simultaneously, every day we can protect at least one house permanently, which indicates that for every distance between ai and ai+1, if x\u22122\u00d7y>0, we have an opportunity to get one house protected. Moreover, the longer uninfected segments have priorities, because we can set two houses to stop the spread of inflection and the loss per day will be prevented. By contrast, for shorter segments, when all the houses in this segment are infected, then there won't be any loss afterwards. In other words, the loss of longer segments will last for longer time if we do not take actions in time. As a result, if we operate the longer segments as early as possible, we can protect more houses. In conclusion, our final strategy can be decribed as following: Sort the uninfected segments of houses according to their length, then the longer the segment is, the earlier we will deal with the houses lying on the side of the segment.  solution#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 500005, inf = 2147483647, M = 1004535809;\nint n, m, a[N], T, k;\nstruct str {\n\tint x, y;\n}t[N];\nint main() {\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tk = 0;\n\t\tscanf(\"%d %d\", &n, &m);\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tsort(a + 1, a + 1 + m);\n\t\tfor (int i = 2; i <= m; ++i)\n\t\t\tt[++k] = { a[i] - a[i - 1] - 1,2 };\n\t\tint num_tmp = a[1] + n - a[m] - 1;\n\t\tif (num_tmp > 0) {\n\t\t\tt[++k] = { num_tmp, 2 };\n\t\t}\n\t\tsort(t + 1, t + 1 + k, [](str a, str b) {return a.x > b.x; });\n\t\tlong long ans = 0, cnt = 0;\n\t\tfor (int i = 1; i <= k; ++i) {\n\t\t    if (t[i].x - cnt * 2 > 0) {\n\t\t      int num_tmp = max(1ll, t[i].x - cnt * 2 - 1);\n\t\t\t  ans += num_tmp;\n\t\t    }\n\t\t    cnt += 2;\n\t\t}\n\t\tprintf(\"%lld\\n\", n - ans);\n\t}\n} "
    },
    "1704B": {
        "title": "B. Luke is a Foodie",
        "description": "Luke likes to eat. There are n piles of food aligned in a straight line in front of him. The i-th pile contains ai units of food. \nLuke will walk from the 1-st pile towards the n-th pile, and he wants to eat every pile of food without walking back. When Luke reaches the i-th pile, he can eat that pile if and only if |v\u2212ai|\u2264x, where x is a fixed integer, and v is Luke's food affinity.\nBefore Luke starts to walk, he can set v to any integer. Also, for each i (1\u2264i\u2264n), Luke can change his food affinity to any integer before he eats the i-th pile.\nFind the minimum number of changes needed to eat every pile of food.\nNote that the initial choice for v is not considered as a change.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nFor each test case, the first line contains two integers, n,x (1\u2264n\u22642\u22c5105, 1\u2264x\u2264109) \u2014 the number of piles, and the maximum difference between the size of a pile and Luke's food affinity, such that Luke can eat the pile.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output an integer on a separate line, which is the minimum number of changes needed.\nIn the first test case, Luke can set v to 5 before he starts to walk. And he can walk straight to eat every piles of food without changing v.\nIn the second test case, Luke can set v to 3 before he starts to walk. And he could change v to 10 before he eats the second pile. After that, he can walk straight to eat remaining food without changing v.\nIn the fourth test case, Luke can set v to 3 before he starts to walk. And he could change v to 8 before he eats the sixth pile. After that, he can walk straight to eat remaining food without changing v.\nIn the fifth test case, Luke can set v to 4 before he starts to walk. And he could change v to 6 before he eats the fourth pile. Then he could change v to 12 before he eats the seventh pile. After that, he can walk straight to eat remaining food without changing v.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1703E": {
        "title": "E. Mirror Grid",
        "description": "You are given a square grid with n rows and n columns. Each cell contains either 0 or 1. \nIn an operation, you can select a cell of the grid and flip it (from 0\u21921 or 1\u21920). Find the minimum number of operations you need to obtain a square that remains the same when rotated 0\u2218, 90\u2218, 180\u2218 and 270\u2218.\nThe picture below shows an example of all rotations of a grid.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the grid.\nThen n lines follow, each with n characters ai,j (0\u2264ai,j\u22641)\u00a0\u2014 the number written in each cell.\nFor each test case output a single integer \u00a0\u2014 the minimum number of operations needed to make the square look the same rotated 0\u2218, 90\u2218, 180\u2218 and 270\u2218.\nIn the first test case, we can perform one operations to make the grid 010111010. Now, all rotations of the square are the same.\nIn the second test case, all rotations of the square are already the same, so we don't need any flips.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "1703E - Mirror GridLet's rotate the grid by 0\u2218, 90\u2218, 180\u2218, and 270\u2218, and mark all cells that map to each other under these rotations. For example, for 4\u00d74 and 5\u00d75 grids, mirror grid must have the following patterns, the same letters denoting equal values:acbabddccddbabcaadcbabefedcfgfcdefebabcdaIn general, we can rotate the grid by 0\u2218, 90\u2218, 180\u2218, and 270\u2218 and see which cells need to have equal values by seeing the positions which each cell maps to.Now to solve the problem, we consider each equal value (each of the letters a, b, c, ... in the above figures) independently, and consider the minimum number of moves to make them all 0 or all 1. The answer is the total across all values. See the implementation for better understanding.The time complexity is O(n2) per testcase. Solution#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve()\n{\n    int n;\n    cin >> n;\n    int a[n][n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n            char c;\n            cin >> c;\n            a[i][j] = c-'0';\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < (n+1)/2; i++)\n    {\n        for(int j = 0; j < n/2; j++)\n        {\n            int nowi = i, nowj = j;\n            int oldnowj = nowj;\n            int sum = a[nowi][nowj];\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            oldnowj = nowj;\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            oldnowj = nowj;\n            nowj = n-nowi-1;\n            nowi = oldnowj;\n            sum+=a[nowi][nowj];\n            ans+=min(sum, 4-sum);\n        }\n    }\n    cout << ans << endl;\n}\n \nint main(){\n    int t;\n    cin>> t;\n    while(t--)\n    {\n        solve();\n    }\n    return 0;\n} "
    },
    "1703D": {
        "title": "D. Double Strings",
        "description": "You are given n strings s1,s2,\u2026,sn of length at most 8. \nFor each string si, determine if there exist two strings sj and sk such that si=sj+sk. That is, si is the concatenation of sj and sk. Note that j can be equal to k.\nRecall that the concatenation of strings s and t is s+t=s1s2\u2026spt1t2\u2026tq, where p and q are the lengths of strings s and t respectively. For example, concatenation of \"code\" and \"forces\" is \"codeforces\".\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of strings.\nThen n lines follow, the i-th of which contains non-empty string si of length at most 8, consisting of lowercase English letters. Among the given n strings, there may be equal (duplicates).\nThe sum of n over all test cases doesn't exceed 105.\nFor each test case, output a binary string of length n. The i-th bit should be 1 if there exist two strings sj and sk where si=sj+sk, and 0 otherwise. Note that j can be equal to k.\nIn the first test case, we have the following: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "strings",
            "*1100"
        ],
        "solutions": "1703D - Double StringsIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 200007;\nconst int MOD = 1000000007;\n \nvoid solve() {\n\tint n;\n\tcin >> n;\n\tstring s[n];\n\tmap<string, bool> mp;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tmp[s[i]] = true;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tbool ok = false;\n\t\tfor (int j = 1; j < s[i].length(); j++) {\n\t\t\tstring pref = s[i].substr(0, j), suff = s[i].substr(j, s[i].length() - j);\n\t\t\tif (mp[pref] && mp[suff]) {ok = true;}\t\n\t\t}\n\t\tcout << ok;\n\t}\n\tcout << '\\n';\n}\n \nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n\t// solve();\n}"
    },
    "1702D": {
        "title": "D. Not a Cheap String",
        "description": "Let s be a string of lowercase Latin letters. Its price is the sum of the indices of letters (an integer between 1 and 26) that are included in it. For example, the price of the string abca is 1+2+3+1=7.\nThe string w and the integer p are given. Remove the minimal number of letters from w so that its price becomes less than or equal to p and print the resulting string. Note that the resulting string may be empty. You can delete arbitrary letters, they do not have to go in a row. If the price of a given string w is less than or equal to p, then nothing needs to be deleted and w must be output.\nNote that when you delete a letter from w, the order of the remaining letters is preserved. For example, if you delete the letter e from the string test, you get tst.\nThe first line of input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test. The following are descriptions of t test cases.\nEach case consists of two lines.\nThe first of them is the string w, it is non-empty and consists of lowercase Latin letters. Its length does not exceed 2\u22c5105.\nThe second line contains an integer p (1\u2264p\u22645200000).\nIt is guaranteed that the sum of string lengths w over all test cases does not exceed 2\u22c5105.\nOutput exactly t rows, the i-th of them should contain the answer to the i-th set of input data. Print the longest string that is obtained from w by deleting letters such that its price is less or equal to p. If there are several answers, then output any of them.\nNote that the empty string \u00a0\u2014 is one of the possible answers. In this case, just output an empty string.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1702D - Not a Cheap StringThe main idea is that it is always better to remove the most expensive symbol. To do this quickly, we will count all the symbols and remove them from the most expensive to the cheapest, counting how many times we have removed each. During the output, we will skip the characters the number of times that we deleted. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        string s;\n        cin >> s;\n        int p;\n        cin >> p;\n        string w(s);\n        sort(w.rbegin(), w.rend());\n        int cost = 0;\n        forn(i, s.length())\n            cost += s[i] - 'a' + 1;\n        map<char,int> del;\n        forn(i, w.length())\n            if (cost > p) {\n                del[w[i]]++;\n                cost -= w[i] - 'a' + 1;\n            }\n        forn(i, s.length()) {\n            if (del[s[i]] > 0) {\n                del[s[i]]--;\n                continue;\n            }\n            cout << s[i];\n        }\n        cout << endl;\n    }\n}"
    },
    "1702C": {
        "title": "C. Train and Queries",
        "description": "Along the railroad there are stations indexed from 1 to 109. An express train always travels along a route consisting of n stations with indices u1,u2,\u2026,un, where (1\u2264ui\u2264109). The train travels along the route from left to right. It starts at station u1, then stops at station u2, then at u3, and so on. Station un\u00a0\u2014 the terminus.\nIt is possible that the train will visit the same station more than once. That is, there may be duplicates among the values u1,u2,\u2026,un.\nYou are given k queries, each containing two different integers aj and bj (1\u2264aj,bj\u2264109). For each query, determine whether it is possible to travel by train from the station with index aj to the station with index bj.\nFor example, let the train route consist of 6 of stations with indices [3,7,1,5,1,4] and give 3 of the following queries: \nIt is possible to travel from station 3 to station 5 by taking a section of the route consisting of stations [3,7,1,5]. Answer: YES. \nYou cannot travel from station 1 to station 7 because the train cannot travel in the opposite direction. Answer: NO. \nIt is not possible to travel from station 3 to station 10 because station 10 is not part of the train's route. Answer: NO. \nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each test case is empty.\nThe second line of each test case contains two integers: n and k (1\u2264n\u22642\u22c5105,1\u2264k\u22642\u22c5105)\u00a0\u2014the number of stations the train route consists of and the number of queries.\nThe third line of each test case contains exactly n integers u1,u2,\u2026,un (1\u2264ui\u2264109). The values u1,u2,\u2026,un are not necessarily different.\nThe following k lines contain two different integers aj and bj (1\u2264aj,bj\u2264109) describing the query with index j.\nIt is guaranteed that the sum of n values over all test cases in the test does not exceed 2\u22c5105. Similarly, it is guaranteed that the sum of k values over all test cases in the test also does not exceed 2\u22c5105\nFor each test case, output on a separate line:\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\nThe first test case is explained in the problem statement.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1100"
        ],
        "solutions": "1702C - Train and QueriesIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include<bits/stdc++.h>\nusing namespace std;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\n\nvoid solve(){\n    int n, k;\n    cin >> n >> k;\n    map<int, pair<int, int>>m;\n    forn(i, n){\n        int u;\n        cin >> u;\n        if(!m.count(u)) {\n            m[u].first = i;\n            m[u].second = i;\n        }\n        else m[u].second = i;\n    }\n    forn(i, k){\n        int a, b;\n        cin >> a >> b;\n        if(!m.count(a) or !m.count(b) or m[a].first > m[b].second) {\n            cout << \"NO\\n\"; //equals = 0 = wrong\n        }\n        else cout << \"YES\\n\";\n    }\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n}"
    },
    "1700B": {
        "title": "B. Palindromic Numbers",
        "description": "During a daily walk Alina noticed a long number written on the ground. Now Alina wants to find some positive number of same length without leading zeroes, such that the sum of these two numbers is a palindrome. \nRecall that a number is called a palindrome, if it reads the same right to left and left to right. For example, numbers 121,66,98989 are palindromes, and 103,239,1241 are not palindromes.\nAlina understands that a valid number always exist. Help her find one!\nThe first line of input data contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases. Next, descriptions of t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264100000) \u2014 the length of the number that is written on the ground.\nThe second line of contains the positive n-digit integer without leading zeroes \u2014 the number itself.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 100000.\nFor each of t test cases print an answer \u2014 a positive n-digit integer without leading zeros, such that the sum of the input integer and this number is a palindrome.\nWe can show that at least one number satisfying the constraints exists. If there are multiple solutions, you can output any of them.\nIn the first test case 99+32=131 is a palindrome. Note that another answer is 12, because 99+12=111 is also a palindrome.\nIn the second test case 1023+8646=9669.\nIn the third test case 385+604=989.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1700B - Palindromic Numbers Let X be the number in input. Consider two cases: first digit of X is 9 and not 9.If the first digit of input number is not 9, we can simply output 9999...999 (n digits) - X. If the first digit is 9, we can output 111...1111 (n+1 digits) - X. It is easy to show that this number will be exactly n-digit.To simplify implementation, we can first find 9999...999 - X by subtracting all digits of X from 9, and than if this number is not n-digit, add 111...1111 - 9999...999 = 11111...1112 to it.Overall complexity will be O(n). "
    },
    "1695B": {
        "title": "B. Circle Game",
        "description": "Mike and Joe are playing a game with some stones. Specifically, they have n piles of stones of sizes a1,a2,\u2026,an. These piles are arranged in a circle.\nThe game goes as follows. Players take turns removing some positive number of stones from a pile in clockwise order starting from pile 1. Formally, if a player removed stones from pile i on a turn, the other player removes stones from pile ((imodn)+1) on the next turn.\nIf a player cannot remove any stones on their turn (because the pile is empty), they lose. Mike goes first.\nIf Mike and Joe play optimally, who will win?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226450) \u00a0\u2014 the number of piles.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u00a0\u2014 the size of the piles.\nFor each test case print the winner of the game, either \"Mike\" or \"Joe\" on its own line (without quotes).\nIn the first test case, Mike just takes all 37 stones on his first turn.\nIn the second test case, Joe can just copy Mike's moves every time. Since Mike went first, he will hit 0 on the first pile one move before Joe does so on the second pile.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "*1000"
        ],
        "solutions": "1695B - Circle GameNote that since all piles are initially nonempty, the game will not end for the first n turns, because on each of those turns, a player will be removing from a nonempty pile. If n is odd, Mike can remove all of the stones from the first pile. Then, on the n+1th turn (the first turn where the game can end), Joe will be forced to remove from the first pile, which is empty. So Mike can always win if n is odd.If n is even, then Mike will only ever remove from the odd piles, and Joe will only ever remove from the even piles. So each player has n/2 piles, and neither can remove from the other's piles. Therefore, it is optimal for each player to remove the minimal possible number of stones at each step, so that they stay in the game for as long as possible.So on each turn, a player removes exactly one stone, and the first pile to become empty will be the pile with the minimal number of stones. If there are multiple minimal piles, it will be the leftmost such pile. So if this pile is on an odd position, Mike will lose (and therefore Joe will win), and otherwise Joe will lose (and Mike will win).Complexity: O(n) Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int num_tests;\n    cin >> num_tests;\n\n    for (int test = 0; test < num_tests; ++test) {\n\n        int n; cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i)\n            cin >> a[i];\n\n        if (n % 2 == 1) {\n            cout << \"Mike\\n\";\n            continue;\n        }\n\n        int smallest = 0;\n        for (int i = 0; i < n; ++i)\n            if (a[i] < a[smallest])\n                smallest = i;\n\n        if (smallest % 2 == 0) cout << \"Joe\\n\";\n        else cout << \"Mike\\n\";\n    }\n} "
    },
    "1694B": {
        "title": "B. Paranoid String",
        "description": "Let's call a binary string T of length m indexed from 1 to m paranoid if we can obtain a string of length 1 by performing the following two kinds of operations m\u22121 times in any order :\nFor example, if T= 001, we can select the substring [T2T3] and perform the first operation. So we obtain T= 01.\nYou are given a binary string S of length n indexed from 1 to n. Find the number of pairs of integers (l,r) 1\u2264l\u2264r\u2264n such that S[l\u2026r] (the substring of S from l to r) is a paranoid string. \nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the size of S.\nThe second line of each test case contains a binary string S of n characters S1S2\u2026Sn. (Si= 0 or Si= 1 for each 1\u2264i\u2264n)\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output the number of pairs of integers (l,r) 1\u2264l\u2264r\u2264n such that S[l\u2026r] (the substring of S from l to r) is a paranoid string. \nIn the first sample, S already has length 1 and doesn't need any operations.\nIn the second sample, all substrings of S are paranoid. For the entire string, it's enough to perform the first operation.\nIn the third sample, all substrings of S are paranoid except [S2S3], because we can't perform any operations on it, and [S1S2S3] (the entire string).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1694B - \u041f\u0430\u0440\u0430\u043d\u043e\u0438\u0434\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430We want to show that a binary string T of length m is paranoid if and only if m=1 or (1<m and S[m]\u2260S[m\u22121]). In the case of S[m\u22121]=S[m]: We can never delete the last two characters because they will always remain equal. So S is not paranoid. In the case of S[m\u22121]\u2260S[m]: If m=2, we can reach our goal by one operation. Otherwise assume that the last character is 0. Now the last three characters are either 010 or 110. In the first case perform the operation on [Sm\u22122,Sm\u22121] and in the second case perform the operation on [Sm\u22121,Sm]. Then the last two characters will be 10 and we can continue this algorithm on the new string until we reach m=1.The number of paranoid substrings of length 1 is equal to n. To count the number of longer substrings, we can fix r from index 2 to n. if S[r]\u2260S[r\u22121] holds, we should add r\u22121 to the answer.complexity: O(n) Implementation# include <bits/stdc++.h>\n\nusing namespace std;\n\nint t, n;\nstring S;\nlong long ans;\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> t;\n\twhile (t --){\n\t\tcin >> n >> S, ans = n;\n\t\tfor (int i = 1; i < n; ++ i)\n\t\t\tif (S[i] != S[i - 1])\n\t\t\t\tans += i;\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
    },
    "1692E": {
        "title": "E. Binary Deque",
        "description": "Slavic has an array of length n consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array. \nWhat is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations? In case the sum s can't be obtained after any amount of operations, you should output -1.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and s (1\u2264n,s\u22642\u22c5105)\u00a0\u2014 the length of the array and the needed sum of elements.\nThe second line of each test case contains n integers ai (0\u2264ai\u22641)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum amount of operations required to have the total sum of the array equal to s, or -1 if obtaining an array with sum s isn't possible.\nIn the first test case, the sum of the whole array is 1 from the beginning, so we don't have to make any operations.\nIn the second test case, the sum of the array is 2 and we want it to be equal to 1, so we should remove the first element. The array turns into [1,0], which has a sum equal to 1.\nIn the third test case, the sum of the array is 5 and we need it to be 3. We can obtain such a sum by removing the first two elements and the last element, doing a total of three operations. The array turns into [0,1,1,1,0,0], which has a sum equal to 3.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solutions": "1692E - Binary DequeNote that the remaining array is a subarray of the original array. There are many ways to approach the problem. Here is one solution, which the main solution uses:Compute prefix sums on the array, so we can find out the value of al+\u22ef+ar quickly. Let's iterate through the left endpoint l from 1 to n. Afterwards, we can binary search on the smallest value of r such that al+\u22ef+ar=s, since this sum is strictly increasing.The time complexity is O(nlogn). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define ll long long\n \n#define       forn(i,n)              for(int i=0;i<n;i++)\n#define          all(v)              v.begin(), v.end()\n#define         rall(v)              v.rbegin(),v.rend()\n \n#define            pb                push_back\n#define          sz(a)               (int)a.size()\n\n\nll query(int l, int r, vector<ll>& p) {\n    return p[r] - (l ? p[l - 1] : 0);\n}\n\nvoid solve() {  \n    int n, s; cin >> n >> s;\n    vector<ll> a(n), p(n);\n    forn(i, n) {\n        cin >> a[i];\n        p[i] = a[i];\n        if(i) p[i] += p[i - 1];\n    }\n\n    int ans = INT_MAX;\n\n    for(int i = 0; i < n; ++i) {\n        int l = i, r = n - 1, pos = -1;\n        while(l <= r) {\n            int mid = l + r >> 1;\n            if(query(i, mid, p) <= s) {\n                pos = mid;\n                l = mid + 1;\n            } else r = mid - 1;\n        }\n        if(pos == -1 || query(i, pos, p) != s) continue;\n        ans = min(ans, n - (pos - i + 1));\n    }\n\n    cout << (ans == INT_MAX ? -1 : ans) << \"\\n\";\n} \n     \nint32_t main() {\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while(t--) {\n        solve();\n    }\n}   "
    },
    "1692D": {
        "title": "D. The Clock",
        "description": "Victor has a 24-hour clock that shows the time in the format \"HH:MM\" (00 \u2264 HH \u2264 23, 00 \u2264 MM \u2264 59). He looks at the clock every x minutes, and the clock is currently showing time s. \nHow many different palindromes will Victor see in total after looking at the clock every x minutes, the first time being at time s?\nFor example, if the clock starts out as 03:12 and Victor looks at the clock every 360 minutes (i.e. every 6 hours), then he will see the times 03:12, 09:12, 15:12, 21:12, 03:12, and the times will continue to repeat. Here the time 21:12 is the only palindrome he will ever see, so the answer is 1.\nA palindrome is a string that reads the same backward as forward. For example, the times 12:21, 05:50, 11:11 are palindromes but 13:13, 22:10, 02:22 are not.\nThe first line of the input contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of each test case follows.\nThe only line of each test case contains a string s of length 5 with the format \"HH:MM\" where \"HH\" is from \"00\" to \"23\" and \"MM\" is from \"00\" to \"59\" (both \"HH\" and \"MM\" have exactly two digits) and an integer x (1\u2264x\u22641440)\u00a0\u2014 the number of minutes Victor takes to look again at the clock.\nFor each test case, output a single integer\u00a0\u2014 the number of different palindromes Victor will see if he looks at the clock every x minutes starting from time s.\nThe first test case is explained in the statement.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solutions": "1692D - The ClockIdea: SlavicG TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a[5] = {600, 60, 0, 10, 1};\nint good[16] = {0, 70, 140, 210, 280, 350, 601, 671, 741, 811, 881, 951, 1202, 1272, 1342, 1412};\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\tint x;\n\tcin >> x;\n\tint tot = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\ttot += (int)(s[i] - '0') * a[i];\n\t}\n\tset<int> t;\n\tfor (int i = 0; i < 2022; i++) {\n\t\tt.insert(tot);\n\t\ttot += x;\n\t\ttot %= 1440;\n\t}\n\tint res = 0;\n\tfor (int i : t) {\n\t\tfor (int j = 0; j < 16; j++) {\n\t\t\tif (good[j] == i) {res++;}\n\t\t}\n\t}\n\tcout << res << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}"
    },
    "1691B": {
        "title": "B. Shoe Shuffling",
        "description": "A class of students got bored wearing the same pair of shoes every day, so they decided to shuffle their shoes among themselves. In this problem, a pair of shoes is inseparable and is considered as a single object.\nThere are n students in the class, and you are given an array s in non-decreasing order, where si is the shoe size of the i-th student. A shuffling of shoes is valid only if no student gets their own shoes and if every student gets shoes of size greater than or equal to their size. \nYou have to output a permutation p of {1,2,\u2026,n} denoting a valid shuffling of shoes, where the i-th student gets the shoes of the pi-th student (pi\u2260i). And output \u22121 if a valid shuffling does not exist.\nA permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of students.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (1\u2264si\u2264109, and for all 1\u2264i<n, si\u2264si+1) \u2014 the shoe sizes of the students.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the answer in a single line using the following format.\nIf a valid shuffling does not exist, print the number \u22121 as the answer.\nIf a valid shuffling exists, print n space-separated integers \u2014 a permutation p of 1,2,\u2026,n denoting a valid shuffling of shoes where the i-th student gets the shoes of the pi-th student. If there are multiple answers, then print any of them.\nIn the first test case, any permutation p of 1,\u2026,n where pi\u2260i would represent a valid shuffling since all students have equal shoe sizes, and thus anyone can wear anyone's shoes.\nIn the second test case, it can be shown that no valid shuffling is possible.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "1691B - Shoe ShufflingWe can observe that the number of pairs of shoes greater than their size is limited for any student. So if student j wears shoes that are greater than their size, then some student i who has a size greater than student j will compromise their size. So say a valid shuffling exists where a student gets shoes of size greater than their own, i.e., student j got shoes of student i where si>sj. Then, for all pairs of shoes of size sj, one pair will go to a student whose size is smaller than sj. This chain will continue until a student with shoe size s1 gets a pair of shoes greater than theirs, and then there will exist a pair of shoes of size s1 that no student can wear. Thus, if a valid shuffling, every student must get shoes of the same size as their own.Hence, a valid shuffling exists if more than one student has the same size shoes for all shoe sizes. A valid shuffling can be generated by rearranging students' shoes with the same shoe size such that no one gets their shoes. This can be done in multiple ways, for example, cyclic rotation. C++ Code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\ntypedef vector<ll> vll;\n#define io                            \\\n    ios_base::sync_with_stdio(false); \\\n    cin.tie(NULL);                    \\\n    cout.tie(NULL)\n\nint main()\n{\n    io;\n    ll tc;\n    cin >> tc;\n    while (tc--)\n    {\n        ll n;\n        cin >> n;\n        vll s(n), p(n);\n        for (ll i = 0; i < n; ++i)\n            cin >> s[i];\n\n        ll l = 0, r = 0;\n        bool ans = true;\n        for (ll i = 0; i < n; ++i)\n            p[i] = i + 1;\n\n        while (r < n)\n        {\n            while (r < n - 1 and s[r] == s[r + 1]) // get range [l,r] with equal values\n                ++r;\n            if (l == r)\n                ans = false;\n            else\n                rotate(p.begin() + l, p.begin() + r, p.begin() + r + 1); // rotate right in range [l,r]\n            l = r + 1;\n            ++r;\n        }\n        if (ans)\n        {\n            for (auto &x : p)\n                cout << x << \" \";\n            cout << endl;\n        }\n        else\n            cout << -1 << endl;\n    }\n    return 0;\n}"
    },
    "1690D": {
        "title": "D. Black and White Stripe",
        "description": "You have a stripe of checkered paper of length n. Each cell is either white or black.\nWhat is the minimum number of cells that must be recolored from white to black in order to have a segment of k consecutive black cells on the stripe?\nIf the input data is such that a segment of k consecutive black cells already exists, then print 0. \nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nNext, descriptions of t test cases follow.\nThe first line of the input contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105). The second line consists of the letters 'W' (white) and 'B' (black). The line length is n.\nIt is guaranteed that the sum of values n does not exceed 2\u22c5105.\nFor each of t test cases print an integer\u00a0\u2014 the minimum number of cells that need to be repainted from white to black in order to have a segment of k consecutive black cells.\nIn the first test case, s=\"BBWBW\" and k=3. It is enough to recolor s3 and get s=\"BBBBW\". This string contains a segment of length k=3 consisting of the letters 'B'.\nIn the second test case of the example s=\"BBWBW\" and k=5. It is enough to recolor s3 and s5 and get s=\"BBBBB\". This string contains a segment of length k=5 consisting of the letters 'B'.\nIn the third test case of the example s=\"BBWBW\" and k=1. The string s already contains a segment of length k=1 consisting of the letters 'B'.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "1690D - Black and White StripeTo obtain a segment of k cells of black color, we need to paint all the white cells of the segment black. Then go through all the segments of length k (there are only n\u2212k) and choose such a segment among them that the number of white cells on it is minimal. You can quickly find out the number of white cells in the segment by prefix sums.  Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n \nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        int n, k;\n        cin >> n >> k;\n        string s;\n        cin >> s;\n        vector<int> w(n + 1);\n        for (int i = 1; i <= n; i++)\n            w[i] = w[i - 1] + int(s[i - 1] == 'W');\n        int result = INT_MAX;\n        for (int i = k; i <= n; i++)\n            result = min(result, w[i] - w[i - k]);\n        cout << result << endl;\n    }\n}"
    },
    "1685A": {
        "title": "A. Circular Local MiniMax",
        "description": "You are given n integers a1,a2,\u2026,an. Is it possible to arrange them on a circle so that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors?\nIn other words, check if there exists a rearrangement b1,b2,\u2026,bn of the integers a1,a2,\u2026,an such that for each i from 1 to n at least one of the following conditions holds:\nTo make sense of the previous formulas for i=1 and i=n, one shall define b0=bn and bn+1=b1.\nThe first line of the input contains a single integer t (1\u2264t\u22643\u22c5104) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105) \u00a0\u2014 the number of integers.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109).\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, if it is not possible to arrange the numbers on the circle satisfying the conditions from the statement, output NO. You can output each letter in any case.\nOtherwise, output YES. In the second line, output n integers b1,b2,\u2026,bn, which are a rearrangement of a1,a2,\u2026,an and satisfy the conditions from the statement. If there are multiple valid ways to arrange the numbers, you can output any of them.\nIt can be shown that there are no valid arrangements for the first and the third test cases.\nIn the second test case, the arrangement [1,8,4,9] works. In this arrangement, 1 and 4 are both smaller than their neighbors, and 8,9 are larger.\nIn the fourth test case, the arrangement [1,11,1,111,1,1111] works. In this arrangement, the three elements equal to 1 are smaller than their neighbors, while all other elements are larger than their neighbors.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1685A - \u0426\u0438\u043a\u043b\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u043b\u043e\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u043c\u0438\u043d\u0438\u043c\u0430\u043a\u0441Let's call bi local minimum if bi\u22121>bi<bi+1 and local maximum if bi\u22121<bi>bi+1. It's clear that in the arrangement satisfying the conditions from the statement, if bi is a local minimum, bi+1 is a local maximum, and vice versa. Local minimums and local maximums will be alternating.Then it's easy to see that such an arrangement can't exist for odd n. Indeed, suppose that the conditions from the statement are satisfied for b1,b2,\u2026,bn. If we suppose that b1 is local minimum, we get that b2 is local maximum, b3 is local minimum, \u2026,, bn is local minimum, b1 is local maximum. Clearly, b1 can't be a local maximum and a local minimum at the same time, leading to a contradiction.Let's now consider the case of even n=2m. Sort the array a, so that a1\u2264a2\u2264\u2026\u2264a2m. Let's show that if ai=ai+m\u22121=x for some 2\u2264i\u2264m\u22121, then there is no arrangement satisfying the conditions from the statement. Indeed, consider such an arrangement: we have m numbers x, and no two of them can be adjacent, so they occupy every second position. In addition, as local maximums and local minimums are alternating, we get that all x are local maximums or all x are local minimums. The first would imply that a2m<x, which isn't possible. The second would imply that a1>x, which isn't possible.It turns out that if there is no such i, the arrangement exists. Indeed, we can arrange numbers on the circle in the following order: (a1,am+1,a2,am+2,\u2026,am,a2m). Here ak<am+k>ak+1 for 1\u2264k\u2264m\u22121, am+k>ak+1<am+k+1 for 1\u2264k\u2264m\u22121, a2m>a1<am+1 and am<a2m>a1. D2D/D1B"
    },
    "1682B": {
        "title": "B. AND Sorting",
        "description": "You are given a permutation p of integers from 0 to n\u22121 (each of them occurs exactly once). Initially, the permutation is not sorted (that is, pi>pi+1 for at least one 1\u2264i\u2264n\u22121). \nThe permutation is called X-sortable for some non-negative integer X if it is possible to sort the permutation by performing the operation below some finite number of times: \nHere & denotes the bitwise AND operation.\nFind the maximum value of X such that p is X-sortable. It can be shown that there always exists some value of X such that p is X-sortable.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases. Description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u00a0\u2014 the length of the permutation.\nThe second line of each test case contains n integers p1,p2,...,pn (0\u2264pi\u2264n\u22121, all pi are distinct) \u00a0\u2014 the elements of p. It is guaranteed that p is not sorted.\nIt is guaranteed that the sum of n over all cases does not exceed 2\u22c5105.\nFor each test case output a single integer \u2014 the maximum value of X such that p is X-sortable.\nIn the first test case, the only X for which the permutation is X-sortable are X=0 and X=2, maximum of which is 2.\nSorting using X=0: \nSorting using X=2: \nIn the second test case, we must swap p1 and p2 which is possible only with X=0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "sortings",
            "*1100"
        ],
        "solutions": "1682B \u2014 AND Sorting HintsHint 1You must have to make at least one swap on the elements which are not at their correct positions initially. So X must be a submask of all elements which are not at their correct positions. Hint 2What is the maximum possible value of X from Hint 1? It is the bitwise AND of all elements which are not at their correct positions. It turns out that this value is achievable too. TutorialWe always have to make at least one swap for the elements which are not at their correct positions. Hence an upper bound of answer would be the bitwise AND of those elements. Let the value be X. It turns out that the given permutation is X-sortable. Proof:First, notice that X would always be present in p. Let posx be the position of X in p initially. Let's say at some point we want to swap two values pi and pj, then pi and pj would always be a supermask of X i.e. pi & X=X and pj & X=X. We can make the following moves to swap pi and pj without disturbing any other element.  Swap values at indices i and posx. Swap values at indices i and j. Swap values at indices j and posx. It can be seen that in every swap the bitwise AND of two values which we are swapping is always X. Hence we can swap any two values which were not at their correct positions, therefore we can sort the permutation p.Overall Complexity: O(n). Solution#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll              long long \n#define pb              push_back\n#define all(v)          v.begin(),v.end()\n#define sz(a)           (ll)a.size()\n#define F               first\n#define S               second\n#define INF             2000000000000000000\n#define popcount(x)     __builtin_popcountll(x)\n#define pll             pair<ll,ll>\n#define pii             pair<int,int>\n#define ld              long double\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y < x) x = y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x < y) x = y; }\n\n#ifdef LOCAL\n#define debug(...) debug_out(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) 2401\n#endif\n\n\nint _runtimeTerror_()\n{\n    int n;\n    cin >> n;\n    int ans = (1 << 30) - 1;\n    for(int i=0;i<n;++i) {\n    \tint x;\n    \tcin >> x;\n    \tif(x != i) {\n    \t\tans &= x;\n    \t}\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initncr();\n    #endif\n    int TESTS = 1;\n    cin >> TESTS;\n    while(TESTS--) {\n        _runtimeTerror_();\n    }\n    return 0;\n}"
    },
    "1681C": {
        "title": "C. Double Sort",
        "description": "You are given two arrays a and b, both consisting of n integers.\nIn one move, you can choose two indices i and j (1\u2264i,j\u2264n; i\u2260j) and swap ai with aj and bi with bj. You have to perform the swap in both arrays.\nYou are allowed to perform at most 104 moves (possibly, zero). Can you make both arrays sorted in a non-decreasing order at the end? If you can, print any sequence of moves that makes both arrays sorted.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the number of elements in both arrays.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the first array.\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264n)\u00a0\u2014 the second array.\nFor each testcase, print the answer. If it's impossible to make both arrays sorted in a non-decreasing order in at most 104 moves, print -1. Otherwise, first, print the number of moves k (0\u2264k\u2264104). Then print i and j for each move (1\u2264i,j\u2264n; i\u2260j).\nIf there are multiple answers, then print any of them. You don't have to minimize the number of moves.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1681C - Double SortImagine that all elements of a are distinct. This way, sorting a in increasing order will fix the order of b.If b turns out sorted in a non-decreasing order, then the answer exists. Otherwise, it doesn't. To obtain the sequence of swaps, you can sort a with any comparison-based sorting algorithm you want: even bubble sort will not exceed the allowed number of swaps.What changes if a has repeated elements? Distinct elements are still ordered among themselves, but now there are also blocks of equal elements. For each block, look into the corresponding values in b. Obviously, these have to be sorted in a non-decreasing order. Rearrange them as they should be.In fact, this is exactly the same as sorting the sequence of pairs (ai,bi) with a default comparator\u00a0\u2014 first by ai, then by bi.Since we fixed the wanted order, we can proceed with the same steps we made in a distinct case.Overall complexity: O(nlogn) or O(n2) per testcase. Solution (awoo)for _ in range(int(input())):\n\tn = int(input())\n\ta = list(map(int, input().split()))\n\tb = list(map(int, input().split()))\n\ttmp = [i for i in range(n)]\n\ttmp.sort(key=lambda i: [a[i], b[i]])\n\tfor i in range(n - 1):\n\t\tif a[tmp[i]] > a[tmp[i + 1]] or b[tmp[i]] > b[tmp[i + 1]]:\n\t\t\tprint(\"-1\")\n\t\t\tbreak\n\telse:\n\t\tans = []\n\t\tfor i in range(n - 1):\n\t\t\tfor j in range(n - 1):\n\t\t\t\tif a[j] > a[j + 1] or b[j] > b[j + 1]:\n\t\t\t\t\ta[j], a[j + 1] = a[j + 1], a[j]\n\t\t\t\t\tb[j], b[j + 1] = b[j + 1], b[j]\n\t\t\t\t\tans.append([j + 1, j + 2])\n\t\tprint(len(ans))\n\t\tfor it in ans:\n\t\t\tprint(*it)"
    },
    "1679B": {
        "title": "B. Stone Age Problem",
        "description": "Once upon a time Mike and Mike decided to come up with an outstanding problem for some stage of ROI (rare olympiad in informatics). One of them came up with a problem prototype but another stole the idea and proposed that problem for another stage of the same olympiad. Since then the first Mike has been waiting for an opportunity to propose the original idea for some other contest... Mike waited until this moment!\nYou are given an array a of n integers. You are also given q queries of two types:\nAfter performing each query you have to calculate the sum of all elements in the array.\nThe first line contains two integers n and q (1\u2264n,q\u22642\u22c5105)\u00a0\u2014 the number of elements in the array and the number of queries, respectively.\nThe second line contains n integers a1,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 elements of the array a.\nEach of the following q lines contains a description of the corresponding query. Description begins with integer t (t\u2208{1,2}) which denotes a type of the query:\nPrint q integers, each on a separate line. In the i-th line print the sum of all elements in the array after performing the first i queries.\nConsider array from the example and the result of performing each query:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "*1200"
        ],
        "solutions": "1679B - Stone Age ProblemAs we want to perform queries fast, we will store some variables: current sum of all elements in the array sum, index of the last query of the second type lastSecondQuery and its value lastSecondQueryValue. For each element of the array we will also store index of the last query of the first type that changed this element lastFirstQuery[i] and its value lastFirstQueryValue[i].Now let's answer the queries. If we are going to perform a query of the first type, we have to know, what the number ai equals now. If lastSecondQuery>lastFirstQuery[i], then ai=lastSecondQueryValue now, and ai=lastFirstQueryValue[i] otherwise. Now let's subtract ai from the sum, change lastFirstQuery[i] and lastFirstQueryValue[i], and add the new value ai to the sum.If we are going to perform a query of the second type, we have to update values lastSecondQuery and lastSecondQueryValue. The new sum of all elements of the array is n\u22c5lastSecondQueryValue.Time complexity: O(n+q)."
    },
    "1676E": {
        "title": "E. Eating Queries",
        "description": "Timur has n candies. The i-th candy has a quantity of sugar equal to ai. So, by eating the i-th candy, Timur consumes a quantity of sugar equal to ai.\nTimur will ask you q queries regarding his candies. For the j-th query you have to answer what is the minimum number of candies he needs to eat in order to reach a quantity of sugar greater than or equal to xj or print -1 if it's not possible to obtain such a quantity. In other words, you should print the minimum possible k such that after eating k candies, Timur consumes a quantity of sugar of at least xj or say that no possible k exists.\nNote that he can't eat the same candy twice and queries are independent of each other (Timur can use the same candy in different queries).\nThe first line of input contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line contains 2 integers n and q (1\u2264n,q\u22641.5\u22c5105)\u00a0\u2014 the number of candies Timur has and the number of queries you have to print an answer for respectively.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264104)\u00a0\u2014 the quantity of sugar in each of the candies respectively.\nThen q lines follow. \nEach of the next q lines contains a single integer xj (1\u2264xj\u22642\u22c5109)\u00a0\u2013 the quantity Timur wants to reach for the given query.\nIt is guaranteed that the sum of n and the sum of q over all test cases do not exceed 1.5\u22c5105.\nFor each test case output q lines. For the j-th line output the number of candies Timur needs to eat in order to reach a quantity of sugar greater than or equal to xj or print -1 if it's not possible to obtain such a quantity.\nFor the first test case:\nFor the first query, Timur can eat any candy, and he will reach the desired quantity.\nFor the second query, Timur can reach a quantity of at least 10 by eating the 7-th and the 8-th candies, thus consuming a quantity of sugar equal to 14.\nFor the third query, there is no possible answer.\nFor the fourth query, Timur can reach a quantity of at least 14 by eating the 7-th and the 8-th candies, thus consuming a quantity of sugar equal to 14.\nFor the second test case:\nFor the only query of the second test case, we can choose the third candy from which Timur receives exactly 3 sugar. It's also possible to obtain the same answer by choosing the fourth candy.",
        "time limit": "time limit per test3.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1676E - Eating QueriesLet's solve the problem with just one query. Greedily, we should pick the candies with the most sugar first, since there is no benefit to picking a candy with less sugar.So the solution is as follows: sort the candies in descending order, and then find the prefix whose sum is \u2265x. This is O(n) per query, which is too slow for us.To speed it up, notice that we just need to find a prefix sum at least x. So if we compute the prefix sums of the reverse-sorted array, we need to find the first element that is at least x.Since all elements of a are positive, the array of prefix sums is increasing. Therefore, you can binary search the first element \u2265x. This solves the problem in logn per query.Total time complexity: O(qlogn+n). Solution#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {  \n    int t; cin >> t;\n    while(t--) {\n        int n, q; cin >> n >> q;\n        vector<long long> a(n), p(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        sort(a.rbegin(), a.rend());\n        for(int i = 0; i < n; ++i) {\n            p[i] = (i ? p[i - 1] : 0) + a[i];\n        }\n    \n        while(q--) {\n            long long x; cin >> x;\n            int l = 1, r = n, ans = -1;\n            while(l <= r) {\n                int mid = (l + r) / 2;\n                if(p[mid - 1] >= x) {\n                    ans = mid;\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n            cout << ans << \"\\n\";\n        }\n    }\n}   "
    },
    "1676D": {
        "title": "D. X-Sum",
        "description": "Timur's grandfather gifted him a chessboard to practice his chess skills. This chessboard is a grid a with n rows and m columns with each cell having a non-negative integer written on it. \nTimur's challenge is to place a bishop on the board such that the sum of all cells attacked by the bishop is maximal. The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked. Help him find the maximal sum he can get.\nThe first line of the input contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains the integers n and m (1\u2264n\u2264200, 1\u2264m\u2264200).\nThe following n lines contain m integers each, the j-th element of the i-th line aij is the number written in the j-th cell of the i-th row (0\u2264aij\u2264106)\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 4\u22c5104.\nFor each test case output a single integer, the maximum sum over all possible placements of the bishop.\nFor the first test case here the best sum is achieved by the bishop being in this position: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1676D - X-\u0441\u0443\u043c\u043c\u0430Idea: mesanu TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tint a[n][m];\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\tint mx = 0;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < m; j++)\n\t\t{\n\t\t\tint now = 0;\n\t\t\tint ci = i, cj = j;\n\t\t\twhile(ci >= 0 && ci < n && cj >= 0 && cj < m)\n\t\t\t{\n\t\t\t\tnow+=a[ci][cj];\n\t\t\t\tci--;\n\t\t\t\tcj--;\n\t\t\t}\n\t\t\tci = i, cj = j;\n\t\t\twhile(ci >= 0 && ci < n && cj >= 0 && cj < m)\n\t\t\t{\n\t\t\t\tnow+=a[ci][cj];\n\t\t\t\tci++;\n\t\t\t\tcj--;\n\t\t\t}\n\t\t\tci = i, cj = j;\n\t\t\twhile(ci >= 0 && ci < n && cj >= 0 && cj < m)\n\t\t\t{\n\t\t\t\tnow+=a[ci][cj];\n\t\t\t\tci--;\n\t\t\t\tcj++;\n\t\t\t}\n\t\t\tci = i, cj = j;\n\t\t\twhile(ci >= 0 && ci < n && cj >= 0 && cj < m)\n\t\t\t{\n\t\t\t\tnow+=a[ci][cj];\n\t\t\t\tci++;\n\t\t\t\tcj++;\n\t\t\t}\n\t\t\tnow-=a[i][j]*3;\n\t\t\tmx = max(mx, now);\n\t\t}\n\t}\n\tcout << mx << endl;\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n}\n"
    },
    "1675C": {
        "title": "C. Detective Task",
        "description": "Polycarp bought a new expensive painting and decided to show it to his n friends. He hung it in his room. n of his friends entered and exited there one by one. At one moment there was no more than one person in the room. In other words, the first friend entered and left first, then the second, and so on.\nIt is known that at the beginning (before visiting friends) a picture hung in the room. At the end (after the n-th friend) it turned out that it disappeared. At what exact moment it disappeared\u00a0\u2014 there is no information.\nPolycarp asked his friends one by one. He asked each one if there was a picture when he entered the room. Each friend answered one of three:\nEveryone except the thief either doesn't remember or told the truth. The thief can say anything (any of the three options).\nPolycarp cannot understand who the thief is. He asks you to find out the number of those who can be considered a thief according to the answers.\nThe first number t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe following is a description of test cases.\nThe first line of each test case contains one string s (length does not exceed 2\u22c5105)\u00a0\u2014 a description of the friends' answers, where si indicates the answer of the i-th friend. Each character in the string is either 0 or 1 or ?.\nThe given regularity is described in the actual situation. In particular, on the basis of answers, at least one friend can be suspected of stealing a painting.\nIt is guaranteed that the sum of string lengths over the entire input data set does not exceed 2\u22c5105.\nOutput one positive (strictly more zero) number\u00a0\u2013 the number of people who could steal the picture based on the data shown.\nIn the first case, the answer is 1 since we had exactly 1 friend.\nThe second case is similar to the first.\nIn the third case, the suspects are the third and fourth friends (we count from one). It can be shown that no one else could be the thief.\nIn the fourth case, we know absolutely nothing, so we suspect everyone.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "1675C - Detective TaskFirst, let's note that we will have a transition from 1 to 0 only once, otherwise it turns out that first the picture disappeared, then it appeared and disappeared back, but we can consider that a friend in the middle, who answered 1 lied to us, but this is not true, because even before him the picture disappeared.So we need to find this transition. Since we can also meet ?, we find the index of the leftmost 0 (in case of absence, we take n\u22121) and mark it as r0, and the index of rightmost 1 (in case of absence, we take 0) and mark as l1. Answer\u00a0\u2013 the number of indices between them (inclusive), because only they could lie. r0\u2212l1+1There could not be a thief to the left of l1, since either the friend under the index l1 lied, or the picture was not stolen before l1. There could not be a thief to the right of r0, since either the painting had already been stolen in the presence of r0's friend, or it was he who lied. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        string s;\n        cin >> s;\n        int n = s.length();\n        vector<bool> a(n + 1);\n        a[0] = true;\n        forn(i, n)\n            a[i + 1] = a[i] && (s[i] == '1' || s[i] == '?');\n        vector<bool> b(n + 1);\n        b[0] = true;\n        for (int i = n - 1; i >= 0; i--)\n            b[n - i] = b[n - i - 1] && (s[i] == '0' || s[i] == '?');\n        int result = 0;\n        forn(i, n)\n            if (a[i] && b[n - i - 1])\n                result++;\n        cout << result << endl;\n    }\n}"
    },
    "1674D": {
        "title": "D. A-B-C Sort",
        "description": "You are given three arrays a, b and c. Initially, array a consists of n elements, arrays b and c are empty.\nYou are performing the following algorithm that consists of two steps: \nCan you make array c sorted in non-decreasing order?\nThe first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains the single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the array a itself.\nIt's guaranteed that the sum of n doesn't exceed 2\u22c5105.\nFor each test, print YES (case-insensitive), if you can make array c sorted in non-decreasing order. Otherwise, print NO (case-insensitive).\nIn the first test case, we can do the following for a=[3,1,5,3]:\nStep 1: \n\nStep 2: \n",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1674D - A-B-C SortLet's look at elements an and an\u22121. After the first step, they will always move to positions b1 and bn (it's up to you to choose: an\u2192b1 and an\u22121\u2192bn or vice versa) because all remaining ai for i<n\u22121 will be placed between an and an\u22121.After the second step, elements b1 and bn will always be placed at positions cn\u22121 and cn (it's also up to you to decide the exact order) because it's easy to see that you first take all bi for 1<i<n and only after that\u00a0\u2014 b1 and bn.In other words, elements an\u22121 and an are moved to positions cn\u22121 and cn. We can analogically prove that each pair (an\u22122i\u22121,an\u22122i) is moved to a pair of positions (cn\u22122i\u22121,cn\u22122i): you first take all elements aj for j>n\u22122i and place them at positions [b1,\u2026,bi] and [bn\u2212i+1,\u2026,bn]; then you move an\u22122i and an\u22122i\u22121; finally you move all remaining elements from a between bi+1 and bn\u2212i. Step 2 just does everything in \"reverse\" order to step 1.It means that array c is basically array a, but you can swap elements in pairs (an\u22122i\u22121,an\u22122i) for i\u22650. And to make a (c) sorted, we can try to sort each pair and check\u00a0\u2014 is it enough to sort the whole array or not. Solution (adedalic)fun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val a = readLine()!!.split(' ').map { it.toInt() }.toIntArray()\n        for (i in (n % 2) until n step 2) {\n            if (a[i] > a[i + 1])\n                a[i] = a[i + 1].also { a[i + 1] = a[i] }\n        }\n        var sorted = true\n        for (i in a.indices)\n            if (i > 0 && a[i - 1] > a[i])\n                sorted = false\n        println(if(sorted) \"YES\" else \"NO\")\n    }\n}"
    },
    "1674C": {
        "title": "C. Infinite Replacement",
        "description": "You are given a string s, consisting only of Latin letters 'a', and a string t, consisting of lowercase Latin letters.\nIn one move, you can replace any letter 'a' in the string s with a string t. Note that after the replacement string s might contain letters other than 'a'.\nYou can perform an arbitrary number of moves (including zero). How many different strings can you obtain? Print the number, or report that it is infinitely large.\nTwo strings are considered different if they have different length, or they differ at some index.\nThe first line contains a single integer q (1\u2264q\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a non-empty string s, consisting only of Latin letters 'a'. The length of s doesn't exceed 50.\nThe second line contains a non-empty string t, consisting of lowercase Latin letters. The length of t doesn't exceed 50.\nFor each testcase, print the number of different strings s that can be obtained after an arbitrary amount of moves (including zero). If the number is infinitely large, print -1. Otherwise, print the number.\nIn the first example, you can replace any letter 'a' with the string \"a\", but that won't change the string. So no matter how many moves you make, you can't obtain a string other than the initial one.\nIn the second example, you can replace the second letter 'a' with \"abc\". String s becomes equal to \"aabc\". Then the second letter 'a' again. String s becomes equal to \"aabcbc\". And so on, generating infinitely many different strings.\nIn the third example, you can either leave string s as is, performing zero moves, or replace the only 'a' with \"b\". String s becomes equal to \"b\", so you can't perform more moves on it.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1674C - Infinite ReplacementIdea: BledDest TutorialTutorial is loading... Solution (awoo)for _ in range(int(input())):\n    s = input()\n    t = input()\n    if t == \"a\":\n        print(1)\n    elif t.count('a') != 0:\n        print(-1)\n    else:\n        print(2**len(s))\n        "
    },
    "1673B": {
        "title": "B. A Perfectly Balanced String?",
        "description": "Let's call a string s perfectly balanced if for all possible triplets (t,u,v) such that t is a non-empty substring of s and u and v are characters present in s, the difference between the frequencies of u and v in t is not more than 1.\nFor example, the strings \"aba\" and \"abc\" are perfectly balanced but \"abb\" is not because for the triplet (\"bb\",'a','b'), the condition is not satisfied.\nYou are given a string s consisting of lowercase English letters only. Your task is to determine whether s is perfectly balanced or not.\nA string b is called a substring of another string a if b can be obtained by deleting some characters (possibly 0) from the start and some characters (possibly 0) from the end of a.\nThe first line of input contains a single integer t (1\u2264t\u22642\u22c5104) denoting the number of testcases.\nEach of the next t lines contain a single string s (1\u2264|s|\u22642\u22c5105), consisting of lowercase English letters.\nIt is guaranteed that the sum of |s| over all testcases does not exceed 2\u22c5105.\nFor each test case, print \"YES\" if s is a perfectly balanced string, and \"NO\" otherwise.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nLet ft(c) represent the frequency of character c in string t.\nFor the first testcase we have \n\nFor the second testcase we have \n\nFor the third testcase we have \n\nIt can be seen that for any substring t of s and any two characters u,v\u2208{a,b,c}, the difference between ft(u) and ft(v) is not more than 1. Hence the string s is perfectly balanced.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1672C": {
        "title": "C. Unequal Array",
        "description": "You are given an array a of length n. We define the equality of the array as the number of indices 1\u2264i\u2264n\u22121 such that ai=ai+1. We are allowed to do the following operation:\nFind the minimum number of operations needed such that the equality of the array is less than or equal to 1.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105) \u2014 the length of array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105\nFor each test case, print the minimum number of operations needed.\nIn the first test case, we can select i=2 and x=2 to form [1,2,2,1,1]. Then, we can select i=3 and x=3 to form [1,2,3,3,1].\nIn the second test case, we can select i=3 and x=100 to form [2,1,100,100,2].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1672C - Unequal ArrayAuthor: maomao90 HintsHint 1If the array is a=[1,1,\u2026,1]. We will need 0 moves if n\u22642 and will need max(n\u22123,1) moves. Hint 2The only way to reduce the number of i such that ai=ai+1 is when ai=ai+1 and ai+2=ai+3, and you apply the operation on ai+1 and ai+2. TutorialSuppose l is the smallest index where al=al+1 and r is the largest index where ar=ar+1. If l=r or l and r does not exist, the condition is already satisfied and we can do 0 operations. Otherwise, the answer is max(1,r\u2212l\u22121). The proof is as follows:  Suppose l+1=r, then, there are 3 elements that are adjacent to each other. Hence, we can just do one operation with i=l and x=\u221e to make the equality of the array 1. Suppose otherwise, then the array will look something like [...,X,X,...,Y,Y,...], with r\u2212l\u22122 elements between the second X and the first Y. Then, we can do operations on i=l+1,l+2,\u2026,r\u22122,r\u22121 to make the equality of the array 1. To see why we need at least r\u2212l\u22121 operations, observe that each operation will cause r\u2212l to decrease by at most 1. This is because if we do not do an operation on i\u2208{l\u22121,l+1,r\u22121,r+1}, then both al=al+1 and ar=ar+1 will still hold. We see that r\u2212l only decreases when do we an operation on i\u2208l+1,r\u22121 and it is not too hard to show that it only decreases by 1 in those cases while r\u2212l>2Hence, we keep doing the operation until r\u2212l=2, which will only require 1 operation to change both pairs and make the equality 1. Solution#include <bits/stdc++.h> \nusing namespace std;\n\ntemplate <class T>\ninline bool mnto(T& a, T b) {return a > b ? a = b, 1 : 0;}\ntemplate <class T>\ninline bool mxto(T& a, T b) {return a < b ? a = b, 1: 0;}\n#define REP(i, s, e) for (int i = s; i < e; i++)\n#define RREP(i, s, e) for (int i = s; i >= e; i--)\ntypedef long long ll;\ntypedef long double ld;\n#define MP make_pair\n#define FI first\n#define SE second\ntypedef pair<int, int> ii;\ntypedef pair<ll, ll> pll;\n#define MT make_tuple\ntypedef tuple<int, int, int> iii;\n#define ALL(_a) _a.begin(), _a.end()\n#define pb push_back\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<ii> vii;\n\n#ifndef DEBUG\n#define cerr if (0) cerr\n#endif\n\n#define INF 1000000005\n#define LINF 1000000000000000005ll\n#define MAXN 200005\n\nint t;\nint n;\nint a[MAXN];\n\nint main() {\n#ifndef DEBUG\n    ios::sync_with_stdio(0), cin.tie(0);\n#endif\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        REP (i, 0, n) {\n            cin >> a[i];\n        }\n        int mn = -1, mx = -1;\n        REP (i, 1, n) {\n            if (a[i] == a[i - 1]) {\n                if (mn == -1) {\n                    mn = i;\n                }\n                mx = i;\n            }\n        }\n        if (mn == mx) {\n            cout << 0 << '\\n';\n        } else {\n            cout << max(1, mx - mn - 1) << '\\n';\n        }\n    }\n    return 0;\n}"
    },
    "1671C": {
        "title": "C. Dolce Vita",
        "description": "Turbulent times are coming, so you decided to buy sugar in advance. There are n shops around that sell sugar: the i-th shop sells one pack of sugar for ai coins, but only one pack to one customer each day. So in order to buy several packs, you need to visit several shops.\nAnother problem is that prices are increasing each day: during the first day the cost is ai, during the second day cost is ai+1, during the third day\u00a0\u2014 ai+2 and so on for each shop i.\nOn the contrary, your everyday budget is only x coins. In other words, each day you go and buy as many packs as possible with total cost not exceeding x. Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.\nEventually, the cost for each pack will exceed x, and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains two integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the number of shops and your everyday budget.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial cost of one pack in each shop.\nIt's guaranteed that the total sum of n doesn't exceed 2\u22c5105.\nFor each test case, print one integer\u00a0\u2014 the total number of packs you will be able to buy until prices exceed your everyday budget.\nIn the first test case, \nIn the second test case, prices are too high even at the first day, so you can't buy anything.\nIn the third test case, you can buy only one pack at day one.\nIn the fourth test case, you can buy 2 packs first 500 days. At day 501 prices are [501,501], so you can buy only 1 pack the next 500 days. At day 1001 prices are [1001,1001] so can't buy anymore. In total, you bought 500\u22c52+500\u22c51=1500 packs.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1671C - Dolce VitaFirstly, note that if we want to buy as many packs as possible, then it's optimal to buy the cheapest packs. In other words, if we sort all packs, we'll always buy a prefix of array a.Next, note that each day we buy some number of packs i\u2208[1,n], so, instead of iterating through the days, we can iterate through the number of packs i and for each i calculate the number of days we'll buy exactly i packs. Since the prices increasing and at day k+1 the price is ai+k, then exists last day ki+1 such that as days 1,2,\u2026,ki+1 we could buy i packs and at days ki+2,ki+3,\u2026 we can't. And we can find ki as maximum possible integer solution to inequation (a1+ki)+\u22ef+(ai+ki)\u2264x or ki=\u230ax\u2212(a1+\u22ef+ai)i\u230b.We can calculate all ki using prefix sums a1+\u22ef+ai in linear time. As a result, we buy   n packs in days (0,k1+1]; n\u22c5(k1+1) in total;  n\u22121 packs in days (k1+1,k2+1]; (n\u22121)\u22c5(k2\u2212k1) in total;  n\u22122 packs in days (k2+1,k3+1]; (n\u22122)\u22c5(k3\u2212k2) in total and so on. The resulting complexity is O(nlogn) because of sort. Solution (adedalic)fun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, x) = readLine()!!.split(' ').map { it.toInt() }\n        val a = readLine()!!.split(' ').map { it.toInt() }.sorted()\n\n        var sum = a.sumOf { it.toLong() }\n        var prevDay = -1L\n        var ans = 0L\n        for (i in n - 1 downTo 0) {\n            val curDay = if (x - sum >= 0) (x - sum) / (i + 1) else -1\n            ans += (i + 1) * (curDay - prevDay)\n            prevDay = curDay\n            sum -= a[i]\n        }\n        println(ans)\n    }\n}"
    },
    "1671B": {
        "title": "B. Consecutive Points Segment",
        "description": "You are given n points with integer coordinates on a coordinate axis OX. The coordinate of the i-th point is xi. All points' coordinates are distinct and given in strictly increasing order.\nFor each point i, you can do the following operation no more than once: take this point and move it by 1 to the left or to the right (i..e., you can change its coordinate xi to xi\u22121 or to xi+1). In other words, for each point, you choose (separately) its new coordinate. For the i-th point, it can be either xi\u22121, xi or xi+1.\nYour task is to determine if you can move some points as described above in such a way that the new set of points forms a consecutive segment of integers, i.\u2009e. for some integer l the coordinates of points should be equal to l,l+1,\u2026,l+n\u22121.\nNote that the resulting points should have distinct coordinates.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of points in the set x.\nThe second line of the test case contains n integers x1<x2<\u2026<xn (1\u2264xi\u2264106), where xi is the coordinate of the i-th point.\nIt is guaranteed that the points are given in strictly increasing order (this also means that all coordinates are distinct). It is also guaranteed that the sum of n does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer \u2014 if the set of points from the test case can be moved to form a consecutive segment of integers, print YES, otherwise print NO.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1671B - Consecutive Points SegmentIdea: vovuh TutorialTutorial is loading... Solution (vovuh)for i in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    print('YES' if x[-1] - x[0] - n + 1 <= 2 else 'NO')"
    },
    "1670B": {
        "title": "B. Dorms War",
        "description": "Hosssam decided to sneak into Hemose's room while he is sleeping and change his laptop's password. He already knows the password, which is a string s of length n. He also knows that there are k special letters of the alphabet: c1,c2,\u2026,ck.\nHosssam made a program that can do the following.\nFor example, suppose the string s is \"abcdef\" and the special characters are 'b' and 'd'. If he runs the program once, the positions 1 and 3 will be deleted as they come before special characters, so the password becomes \"bdef\". If he runs the program again, it deletes position 1, and the password becomes \"def\". If he is wise, he won't run it a third time.\nHosssam wants to know how many times he can run the program on Hemose's laptop without waking him up from the sound of the error message. Can you help him?\nThe first line contains a single integer t (1\u2264t\u2264105) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the initial length of the password.\nThe next line contains a string s consisting of n lowercase English letters \u2014 the initial password.\nThe next line contains an integer k (1\u2264k\u226426), followed by k distinct lowercase letters c1,c2,\u2026,ck \u2014 the special letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print the maximum number of times Hosssam can run the program without displaying the error message, on a new line.\nIn the first test case, the program can run 5 times as follows: iloveslim\u2192ilovslim\u2192iloslim\u2192ilslim\u2192islim\u2192slim\nIn the second test case, the program can run 2 times as follows: joobeel\u2192oel\u2192el\nIn the third test case, the program can run 3 times as follows: basiozi\u2192bioi\u2192ii\u2192i.\nIn the fourth test case, the program can run 5 times as follows: khater\u2192khatr\u2192khar\u2192khr\u2192kr\u2192r\nIn the fifth test case, the program can run only once as follows: abobeih\u2192h\nIn the sixth test case, the program cannot run as none of the characters in the password is a special character.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1670B - Dorms WarLet's consider the non-special characters as '0' and special characters as '1' since they are indistinguishable. So now the problem is that we have a binary string, where each '1' character removes the character before it each time the program is run.The trivial case is when there is only one '1' character, the answer then is just the number of '0' characters before it.But what if there is more than one '1' character? lets take for example when there are two '1' characters as follows: 00000010001\u2192000001001\u21920000101\u219200011\u2192001\u219201\u21921The observation here is that when the first '1' character from the right reached the second '1', it acts as if it just replaced its place, so we can say that each '1' character replaces another '1' as soon as it reaches it.So we can partition the binary string into small partitions where each partition contains only one '1' character that is the rightmost character in the partition.For example, the string 00010000001011 can be partitioned into: (0001),(0000001),(01),(1)We first calculate the amount of time each partition requires to remove all the '0' characters before it, which is basically the number of '0' characters before it. Each partition except for the first partition requires one more second to replace the '1' character in the previous partition.So the answer is the maximum time required among all the partitions. Solutionimport java.io.*;\nimport java.util.StringTokenizer;\n \npublic class B{\n \n \n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int tests = sc.nextInt();\n        for (int test = 0; test < tests; test++) {\n            int n = sc.nextInt();\n            char[] arr = sc.next().toCharArray();\n            int k = sc.nextInt();\n            boolean[] special = new boolean[26];\n            for (int i = 0; i < k; i++)\n                special[sc.next().charAt(0) - 'a'] = true;\n            int idx = -1;\n            for (int i = 0; i < n; i++)\n                if (special[arr[i] - 'a'])\n                    idx = i;\n            int max=0;\n            for(int i=idx-1;i>=0;i--){\n                int j=i;\n                while (j>0&&!special[arr[j]-'a'])\n                    j--;\n                max=Math.max(max,i+1-j);\n                i=j;\n            }\n            pw.println(max);\n        }\n        pw.flush();\n    }\n \n \n    public static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n \n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n \n        public Scanner(String s) throws FileNotFoundException {\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(s)));\n        }\n \n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n \n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n \n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n    }\n}\n"
    },
    "1669G": {
        "title": "G. Fall Down",
        "description": "There is a grid with n rows and m columns, and three types of cells: \nAll stones fall down until they meet the floor (the bottom row), an obstacle, or other stone which is already immovable. (In other words, all the stones just fall down as long as they can fall.)\nSimulate the process. What does the resulting grid look like?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u226450)\u00a0\u2014 the number of rows and the number of columns in the grid, respectively.\nThen n lines follow, each containing m characters. Each of these characters is either '.', '*', or 'o'\u00a0\u2014 an empty cell, a stone, or an obstacle, respectively.\nFor each test case, output a grid with n rows and m columns, showing the result of the process.\nYou don't need to output a new line after each test, it is in the samples just for clarity.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "implementation",
            "*1200"
        ],
        "solutions": "1669G - Fall DownNote that the columns don't affect each other, so we can solve for each column by itself.For each column, go from the bottom to the top, and keep track of the row of the last obstacle seen; call it last. Note that initially, last=n+1, since we treat the floor as the n+1th row of obstacles. Whenever we see a new obstacle, we should update last.Now, if we ever see a stone, we should move it to row last\u22121, since it will be one row above the last obstacle seen (it will fall on top of it). Afterwards, we should also decrease last by 1, because if any future stones fall on top of it, they will land on the row above this stone.This solution works in O(nm). We also accepted slower solutions that run in O(n2m) that simulate each stone falling. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 200007;\nconst int MOD = 1000000007;\n\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tchar g[n + 7][m + 7];\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcin >> g[i][j];\n\t\t}\n\t}\n\tfor (int j = 0; j < m; j++) {\n\t\tint last = n - 1;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tif (g[i][j] == 'o') {last = i - 1;}\n\t\t\telse if (g[i][j] == '*') {swap(g[i][j], g[last][j]); last--;}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tcout << g[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int tt; cin >> tt; for (int i = 1; i <= tt; i++) {solve();}\n    // solve();\n}"
    },
    "1669F": {
        "title": "F. Eating Candies",
        "description": "There are n candies put from left to right on a table. The candies are numbered from left to right. The i-th candy has weight wi. Alice and Bob eat candies. \nAlice can eat any number of candies from the left (she can't skip candies, she eats them in a row). \nBob can eat any number of candies from the right (he can't skip candies, he eats them in a row). \nOf course, if Alice ate a candy, Bob can't eat it (and vice versa).\nThey want to be fair. Their goal is to eat the same total weight of candies. What is the most number of candies they can eat in total?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of candies on the table.\nThe second line of each test case contains n integers w1,w2,\u2026,wn (1\u2264wi\u2264104)\u00a0\u2014 the weights of candies from left to right.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the maximum number of candies Alice and Bob can eat in total while satisfying the condition.\nFor the first test case, Alice will eat one candy from the left and Bob will eat one candy from the right. There is no better way for them to eat the same total amount of weight. The answer is 2 because they eat two candies in total.\nFor the second test case, Alice will eat the first three candies from the left (with total weight 7) and Bob will eat the first three candies from the right (with total weight 7). They cannot eat more candies since all the candies have been eaten, so the answer is 6 (because they eat six candies in total).\nFor the third test case, there is no way Alice and Bob will eat the same non-zero weight so the answer is 0.\nFor the fourth test case, Alice will eat candies with weights [7,3,20] and Bob will eat candies with weights [10,8,11,1], they each eat 30 weight. There is no better partition so the answer is 7.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solutions": "1669F - Eating CandiesIdea: MikeMirzayanov TutorialTutorial is loading... Solutiont = int(input())\nfor test in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    l = 0\n    r = n - 1\n    suml = a[0]\n    sumr = a[n-1]\n    ans = 0\n    while l < r:\n        if suml == sumr:\n            ans = max(ans, l + 1 + n - r)\n\n        if suml <= sumr:\n            l+=1\n            suml+=a[l]\n\n        elif sumr < suml:\n            r-=1\n            sumr+=a[r]\n            \n    print(ans)"
    },
    "1669E": {
        "title": "E. 2-Letter Strings",
        "description": "Given n strings, each of length 2, consisting of lowercase Latin alphabet letters from 'a' to 'k', output the number of pairs of indices (i,j) such that i<j and the i-th string and the j-th string differ in exactly one position.\nIn other words, count the number of pairs (i,j) (i<j) such that the i-th string and the j-th string have exactly one position p (1\u2264p\u22642) such that sip\u2260sjp.\nThe answer may not fit into 32-bit integer type, so you should use 64-bit integers like long long in C++ to avoid integer overflow.\nThe first line of the input contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the number of strings.\nThen follows n lines, the i-th of which containing a single string si of length 2, consisting of lowercase Latin letters from 'a' to 'k'.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print a single integer \u2014 the number of pairs (i,j) (i<j) such that the i-th string and the j-th string have exactly one position p (1\u2264p\u22642) such that sip\u2260sjp. \nPlease note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor the first test case the pairs that differ in exactly one position are: (\"ab\", \"cb\"), (\"ab\", \"db\"), (\"ab\", \"aa\"), (\"cb\", \"db\") and (\"cb\", \"cc\").\nFor the second test case the pairs that differ in exactly one position are: (\"aa\", \"ac\"), (\"aa\", \"ca\"), (\"cc\", \"ac\"), (\"cc\", \"ca\"), (\"ac\", \"aa\") and (\"ca\", \"aa\").\nFor the third test case, the are no pairs satisfying the conditions.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "math",
            "strings",
            "*1200"
        ],
        "solutions": "1669E - 2-Letter StringsIdea: SlavicG TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    while(t--) {\n        int n; cin >> n;\n\n        vector<vector<int>> cnt(12, vector<int>(12, 0));\n        long long ans = 0;\n        \n        for(int i = 0;i < n; ++i) {\n            string s; cin >> s;\n            for(int j = 0;j < 2; ++j) {\n                for(char c = 'a'; c <= 'k'; ++c) {\n                    if(c == s[j]) continue;\n                    string a = s; a[j] = c;\n                    ans += cnt[a[0] - 'a'][a[1] - 'a'];\n                }\n            }\n            ++cnt[s[0] - 'a'][s[1] - 'a'];\n        }\n        cout << ans << \"\\n\";\n    }\n}"
    },
    "1669D": {
        "title": "D. Colorful Stamp",
        "description": "A row of n cells is given, all initially white. Using a stamp, you can stamp any two neighboring cells such that one becomes red and the other becomes blue. A stamp can be rotated, i.e. it can be used in both ways: as BR and as RB.\nDuring use, the stamp must completely fit on the given n cells (it cannot be partially outside the cells). The stamp can be applied multiple times to the same cell. Each usage of the stamp recolors both cells that are under the stamp.\nFor example, one possible sequence of stamps to make the picture BRBBW could be WWWWW\u2192WWRB_W\u2192BR_RBW\u2192BRB_BW. Here W, R, and B represent a white, red, or blue cell, respectively, and the cells that the stamp is used on are marked with an underline.\nGiven a final picture, is it possible to make it using the stamp zero or more times?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the picture.\nThe second line of each test case contains a string s\u00a0\u2014 the picture you need to make. It is guaranteed that the length of s is n and that s only consists of the characters W, R, and B, representing a white, red, or blue cell, respectively.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nOutput t lines, each of which contains the answer to the corresponding test case. As an answer, output \"YES\" if it possible to make the picture using the stamp zero or more times, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first test case is explained in the statement.\nFor the second, third, and fourth test cases, it is not possible to stamp a single cell, so the answer is \"NO\".\nFor the fifth test case, you can use the stamp as follows: WWW\u2192WRB_\u2192BR_B.\nFor the sixth test case, you can use the stamp as follows: WWW\u2192WRB_\u2192RB_B.\nFor the seventh test case, you don't need to use the stamp at all.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "1669D - Colorful StampIdea: flamestorm TutorialTutorial is loading... Solutionfor i in range(int(input())):\n    n = int(input())\n    l = input().split('W')\n    bad = False\n    for s in l:\n    \tb1 = 'R' in s\n    \tb2 = 'B' in s\n    \tif (b1 ^ b2):\n    \t\tbad = True\n    print(\"NO\" if bad else \"YES\")"
    },
    "1659A": {
        "title": "A. Red Versus Blue",
        "description": "Team Red and Team Blue competed in a competitive FPS. Their match was streamed around the world. They played a series of n matches.\nIn the end, it turned out Team Red won r times and Team Blue won b times. Team Blue was less skilled than Team Red, so b was strictly less than r.\nYou missed the stream since you overslept, but you think that the match must have been neck and neck since so many people watched it. So you imagine a string of length n where the i-th character denotes who won the i-th match \u00a0\u2014 it is R if Team Red won or B if Team Blue won. You imagine the string was such that the maximum number of times a team won in a row was as small as possible. For example, in the series of matches RBBRRRB, Team Red won 3 times in a row, which is the maximum.\nYou must find a string satisfying the above conditions. If there are multiple answers, print any.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases.\nEach test case has a single line containing three integers n, r, and b (3\u2264n\u2264100; 1\u2264b<r\u2264n, r+b=n).\nFor each test case, output a single line containing a string satisfying the given conditions. If there are multiple answers, print any.\nThe first test case of the first example gives the optimal answer for the example in the statement. The maximum number of times a team wins in a row in RBRBRBR is 1. We cannot minimize it any further.\nThe answer for the second test case of the second example is RRBRBRBRBR. The maximum number of times a team wins in a row is 2, given by RR at the beginning. We cannot minimize the answer any further.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1659A - Red Versus BlueWe have b B's which divide the string into b+1 regions and we have to place the R's in these regions. By the strong form of the pigeonhole principle, at least one region must have at least \u2308rb+1\u2309 R's. This gives us a lower bound on the answer.Now, we will construct a string whose answer is exactly equal to the lower bound.We place the B's so that they are not adjacent. Then we equally distribute the R's in the b+1 regions.Let p=\u230arb+1\u230b and q=rmod(b+1).We place p R's in each region and an extra R in any q regions. Hence, our answer for the construction is \u2308rb+1\u2309, which is equal to the lower bound.Importantly, r>b, so none of the B's will be consecutive.Time complexity: O(n). Implementation (C++)#include<bits/stdc++.h>\nusing namespace std;\nusing lol=long long int;\n#define endl \"\\n\"\n \nint main()\n{\nios_base::sync_with_stdio(false);\ncin.tie(NULL);\nint _=1;\ncin>>_;\nwhile(_--)\n{\n    int n,r,b;\n    cin>>n>>r>>b;\n    int p=r/(b+1),q=r%(b+1);\n    for(int i=0;i<q;i++)    cout<<string(p+1,'R')<<'B';\n    for(int i=q;i<b;i++)    cout<<string(p,'R')<<'B';\n    cout<<string(p,'R');\n    cout<<endl;\n}\nreturn 0;\n} Implementation (Python)t = int(input())\nfor i in range(t):\n    n, r, b = map(int, input().split())\n    p = r % (b + 1)\n    y = \"\"\n    for j in range(int(r / (b + 1))):\n        y = y + \"R\"\n    ans = \"\"\n    for i in range(b + 1):\n        if i > 0:\n            ans = ans + \"B\"\n        ans = ans + y\n        if p > 0:\n            ans = ans + \"R\"\n            p = p - 1\n    print(ans) Feedback Good problem: \n\n\n\n\n367\n\n\n\n\n\n Average problem: \n\n    \n\n\n64\n\n\n\n Bad problem: \n\n    \n\n\n303\n\n\n\n Did not solve: \n\n    \n\n\n42\n\n\n\n "
    },
    "1657C": {
        "title": "C. Bracket Sequence Deletion",
        "description": "You are given a bracket sequence consisting of n characters '(' and/or )'. You perform several operations with it.\nDuring one operation, you choose the shortest prefix of this string (some amount of first characters of the string) that is good and remove it from the string.\nThe prefix is considered good if one of the following two conditions is satisfied:\nA bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not.\nThe bracket sequence is called palindrome if it reads the same back and forth. For example, the bracket sequences )), (( and )(() are palindromes, while bracket sequences (), )( and ))( are not palindromes.\nYou stop performing the operations when it's not possible to find a good prefix. Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. The next 2t lines describe test cases.\nThe first line of the test case contains one integer n (1\u2264n\u22645\u22c5105) \u2014 the length of the bracket sequence.\nThe second line of the test case contains n characters '(' and/or ')' \u2014 the bracket sequence itself.\nIt is guaranteed that the sum of n over all test cases do not exceed 5\u22c5105 (\u2211n\u22645\u22c5105).\nFor each test case, print two integers c and r \u2014 the number of operations you will perform on the given bracket sequence and the number of characters that remain in the string after performing all operations.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1657C - Bracket Sequence DeletionConsider the first character of the string. If it is '(', then we can remove the first two characters of the string and continue (because the prefix of length 2 will be either a palindrome or a regular bracket sequence). If the first character of the string is ')' then this is a bad case. Of course, the regular bracket sequence can't start with '(', so this prefix should be a palindrome. And what is the shortest palindrome we can get with the first character ')'? It is the closing bracket ')', then some (possibly, zero) amount of opening brackets '(', and another one closing bracket. We can see that we can't find a palindrome shorter than this one because we have to find a pair for the first character. So, if the first character of the string is ')', then we just remove anything until the next character ')' inclusive. To not remove any characters explicitly, we can just use pointers instead. And the last thing is to carefully handle cases when we can't do any operations. Solution (vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n    freopen(\"input.txt\", \"r\", stdin);\n//  freopen(\"output.txt\", \"w\", stdout);\n#endif\n    \n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        string s;\n        cin >> n >> s;\n        int l = 0;\n        int cnt = 0;\n        while (l + 1 < n) {\n            if (s[l] == '(' || (s[l] == ')' && s[l + 1] == ')')) {\n                l += 2;\n            } else {\n                int r = l + 1;\n                while (r < n && s[r] != ')') {\n                    ++r;\n                }\n                if (r == n) {\n                    break;\n                }\n                l = r + 1;\n            }\n            ++cnt;\n        }\n        cout << cnt << ' ' << n - l << '\\n';\n    }\n    \n    return 0;\n}"
    },
    "1656C": {
        "title": "C. Make Equal With Mod",
        "description": "You are given an array of n non-negative integers a1,a2,\u2026,an. You can make the following operation: choose an integer x\u22652 and replace each number of the array by the remainder when dividing that number by x, that is, for all 1\u2264i\u2264n set ai to aimodx.\nDetermine if it is possible to make all the elements of the array equal by applying the operation zero or more times.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) where ai is the i-th element of the array.\nThe sum of n for all test cases is at most 2\u22c5105.\nFor each test case, print a line with YES if you can make all elements of the list equal by applying the operation. Otherwise, print NO.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).\nIn the first test case, one can apply the operation with x=3 to obtain the array [2,2,0,2], and then apply the operation with x=2 to obtain [0,0,0,0].\nIn the second test case, all numbers are already equal.\nIn the fourth test case, applying the operation with x=4 results in the array [1,1,1,1].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "sortings",
            "*1200"
        ],
        "solutions": "1656C - Make Equal With ModNote that, if 1 is not present in the array, we can always make all elements equal to 0 by repeatedly applying the operation with x=max(ai) until all elements become 0, as this operation will set the elements equal to the maximum to 0, while maintaining the others intact. So the answer is YES.If 1 is present and there are no two consecutive numbers in the array, we can similarly apply repeatedly the operation with x=max(ai)\u22121 until all elements become 1, as this operation will set the elements equal to the maximum to 1, while maintaining the others intact. So the answer is again YES.If 1 is present in the array, and there are two consecutive numbers m,m+1 in the array, the answer is NO. Note that if we have a 0 and a 1 in the array, we won't be able to make them equal after any number of operations, and so we cannot have any operation with an x that divides one of the ai's. The rest of operations will cause that m,m+1 remain consecutive (and thus different), meaning that it is impossible to make all the array equal. Code#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef vector<int> vi;\n \n \nint main() {\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvi a(n);\n\t\tfor(int i=0; i < n; ++i) cin >> a[i];\n\t\tsort(a.begin(), a.end());\n\t\tbool one = false;\n\t\tbool consec = false;\n\t\tfor(int i=0; i < n; ++i) {\n\t\t\tif(a[i] == 1) one = true;\n\t\t\tif(i < n-1 && a[i]+1 == a[i+1]) consec = true;\n\t\t}\n \n\t\tcout << ((one && consec) ? \"NO\" : \"YES\") << endl;\n\t}\n \n}\n"
    },
    "1656B": {
        "title": "B. Subtract Operation",
        "description": "You are given a list of n integers. You can perform the following operation: you choose an element x from the list, erase x from the list, and subtract the value of x from all the remaining elements. Thus, in one operation, the length of the list is decreased by exactly 1.\nGiven an integer k (k>0), find if there is some sequence of n\u22121 operations such that, after applying the operations, the only remaining element of the list is equal to k.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n and k (2\u2264n\u22642\u22c5105, 1\u2264k\u2264109), the number of integers in the list, and the target value, respectively.\nThe second line of each test case contains the n integers of the list a1,a2,\u2026,an (\u2212109\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases is not greater that 2\u22c5105.\nFor each test case, print YES if you can achieve k with a sequence of n\u22121 operations. Otherwise, print NO.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).\nIn the first example we have the list {4,2,2,7}, and we have the target k=5. One way to achieve it is the following: first we choose the third element, obtaining the list {2,0,5}. Next we choose the first element, obtaining the list {\u22122,3}. Finally, we choose the first element, obtaining the list {5}. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solutions": "1656B - Subtract OperationNote that, after deleting element $$$a_j$$$, all numbers in the set are of the form $$$a_i - a_j$$$, since the previous substractions are cancelled. Therefore, the final element will be the difference between the last element and the previous element which was erased. So we just need to check if $$$k$$$ is the difference of two elements in the set, which can be done by sorting and using the double pointer technique in $$$O(n \\log n)$$$ time. Code#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, a;\n    \tcin >> n >> a;\n    \tvector<int> v(n);\n    \tfor(int& x : v) cin >> x;\n    \tbool ans = false;\n    \tif(n == 1) ans = (v[0] == a);\n    \telse {\n    \t\tsort(v.begin(), v.end());\n    \t\tint i = 0;\n    \t\tint j = 1;\n    \t\twhile(j < n and i < n) {\n    \t\t\tif(v[i] + abs(a) == v[j]) {\n    \t\t\t\tans = true;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\telse if(v[i] + abs(a) < v[j]) ++i;\n    \t\t\telse ++j;\n    \t\t}\n    \t}\n    \tcout << (ans? \"YES\" : \"NO\") << '\\n';   \n    }\n}"
    },
    "1650C": {
        "title": "C. Weight of the System of Nested Segments",
        "description": "On the number line there are m points, i-th of which has integer coordinate xi and integer weight wi. The coordinates of all points are different, and the points are numbered from 1 to m.\nA sequence of n segments [l1,r1],[l2,r2],\u2026,[ln,rn] is called system of nested segments if for each pair i,j (1\u2264i<j\u2264n) the condition li<lj<rj<ri is satisfied. In other words, the second segment is strictly inside the first one, the third segment is strictly inside the second one, and so on.\nFor a given number n, find a system of nested segments such that:\nFor example, let m=8. The given points are marked in the picture, their weights are marked in red, their coordinates are marked in blue. Make a system of three nested segments:\nThe first line of input data contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of input test cases.\nAn empty line is written before each test case.\nThe first line of each test case contains two positive integers n (1\u2264n\u2264105) and m (2\u22c5n\u2264m\u22642\u22c5105). \nThe next m lines contain pairs of integers xi (\u2212109\u2264xi\u2264109) and wi (\u2212104\u2264wi\u2264104) \u2014 coordinate and weight of point number i (1\u2264i\u2264m) respectively. All xi are different.\nIt is guaranteed that the sum of m values over all test cases does not exceed 2\u22c5105.\nFor each test case, output n+1 lines: in the first of them, output the weight of the composed system, and in the next n lines output exactly two numbers \u00a0\u2014 the indices of the points which are the endpoints of the i-th segment (1\u2264i\u2264n). The order in which you output the endpoints of a segment is not important \u2014 you can output the index of the left endpoint first and then the number of the right endpoint, or the other way around.\nIf there are several ways to make a system of nested segments with minimal weight, output any of them.\nThe first test case coincides with the example from the condition. It can be shown that the weight of the composed system is minimal.\nThe second test case has only 6 points, so you need to use each of them to compose 3 segments.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "hashing",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1650C - Weight of the System of Nested SegmentsWe create a structure that stores for each point its coordinate, weight, and index in the input data. Sort the points array by increasing weight. The sum of weights of the first 2\u22c5n points will be minimal, so we use them to construct a system of n nested segments. We save the weights of the first 2\u22c5n points in the variable sum and remove the remaining m\u22122\u22c5n points from the array. Now sort the points in ascending order of coordinates and form a system of nested segments such that the endpoints of ith segment are points[i] and points[2\u22c5n\u2212i+1] for (1\u2264i\u22642\u22c5n). Thus, the endpoints of the first segment are points[1] and points[2\u22c5n], the endpoints of the nth segment are points[n] and points[n+1].For each test case we first output sum, then \u2014 n pairs of numbers i, j (1\u2264i,j\u2264m) \u2014 the indices under which the endpoints of the current segment were written in the input data. Solution#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nstruct point{\n    int weight, position, id;\n};\n\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<point>points(m);\n\n    forn(i, m) {\n        cin >>  points[i].position >> points[i].weight;\n        points[i].id = i + 1;\n    }\n\n    sort(points.begin(), points.end(), [] (point a, point b){\n        return a.weight < b.weight;\n    });\n\n    int sum = 0;\n    forn(i, m){\n        if(i < 2 * n) sum += points[i].weight;\n        else points.pop_back();\n    }\n\n    sort(points.begin(), points.end(), [] (point a, point b){\n        return a.position < b.position;\n    });\n\n    cout << sum << endl;\n    forn(i, n){\n        cout << points[i].id << ' ' << points[2 * n - i - 1].id << endl;\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
    },
    "1647B": {
        "title": "B. Madoka and the Elegant Gift",
        "description": "Madoka's father just reached 1 million subscribers on Mathub! So the website decided to send him a personalized award\u00a0\u2014 The Mathhub's Bit Button! \nThe Bit Button is a rectangular table with n rows and m columns with 0 or 1 in each cell. After exploring the table Madoka found out that:\nFor example, in the first illustration the red subrectangle is nice, but in the second one it's not, because it's contained in the purple subrectangle.\nHelp Madoka to determine whether the table is elegant.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two positive integers n,m (1\u2264n,m\u2264100).\nThe next n lines contain strings of length m consisting of zeros and ones\u00a0\u2014 the description of the table.\nIt is guaranteed that the sum of the values of n and the sum of the values of m for all test cases do not exceed 777.\nFor each test case print \"YES\" if its table is elegant or print \"NO\" otherwise.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIn the second test case the table is not elegant, because the red and the purple subrectangles are nice and intersect. \nIn the fourth test case the table is not elegant, because the red and the purple subrectangles are nice and intersect. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "graphs",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1641A": {
        "title": "A. Great Sequence",
        "description": "A sequence of positive integers is called great for a positive integer x, if we can split it into pairs in such a way that in each pair the first number multiplied by x is equal to the second number. More formally, a sequence a of size n is great for a positive integer x, if n is even and there exists a permutation p of size n, such that for each i (1\u2264i\u2264n2) ap2i\u22121\u22c5x=ap2i. \nSam has a sequence a and a positive integer x. Help him to make the sequence great: find the minimum possible number of positive integers that should be added to the sequence a to make it great for the number x.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u226420000) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n, x (1\u2264n\u22642\u22c5105, 2\u2264x\u2264106).\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print a single integer\u00a0\u2014 the minimum number of integers that can be added to the end of a to make it a great sequence for the number x.\nIn the first test case, Sam got lucky and the sequence is already great for the number 4 because you can divide it into such pairs: (1,4), (4,16). Thus we can add 0 numbers.\nIn the second test case, you can add numbers 1 and 14 to the sequence, then you can divide all 8 integers into such pairs: (1,2), (1,2), (2,4), (7,14). It is impossible to add less than 2 integers to fix the sequence.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1638B": {
        "title": "B. Odd Swap Sort",
        "description": "You are given an array a1,a2,\u2026,an. You can perform operations on the array. In each operation you can choose an integer i (1\u2264i<n), and swap elements ai and ai+1 of the array, if ai+ai+1 is odd.\nDetermine whether it can be sorted in non-decreasing order using this operation any number of times.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print \"Yes\" or \"No\" depending on whether you can or can not sort the given array.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIn the first test case, we can simply swap 31 and 14 (31+14=45 which is odd) and obtain the non-decreasing array [1,6,14,31].\nIn the second test case, the only way we could sort the array is by swapping 4 and 2, but this is impossible, since their sum 4+2=6 is even.\nIn the third test case, there is no way to make the array non-decreasing.\nIn the fourth test case, the array is already non-decreasing.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1638B - Odd Swap Sort Hint 1Replace the condition \"ai+ai+1 is odd\" with something easier to work with. Hint 2The condition means that we only swap elements of different parity. Now, make some observations. Hint 3What happens if there are some elements ai and aj (i<j) of the same parity, such that ai>aj? Hint 4If such pair exists, the answer is \"NO\". Now consider the array to be a merge between two increasing arrays (one with odd elements, one with even elements). Try to prove that the answer is always \"YES\" in this case. Hint 5What does the Bubble Sort algorithm do here? Does it ever do an illegal swap? TutorialThe condition \"ai+ai+1 is odd\" means that we can only swap elements of different parity. If either the order of even elements or the order of odd elements is not non-decreasing, then it is impossible to sort the sequence. Otherwise, let's prove that it is always possible to sort the sequence. We can for example perform Bubble Sort algorithm. Note that this algorithm only swaps elements ai and ai+1 if ai>ai+1, so it will never swap two elements of the same parity (given our assumption on their order).Time complexity: O(n). Feedback Didn't solve \n\n    \n\n\n330\n\n\n\n Good problem \n\n    \n\n\n1293\n\n\n\n Average problem \n\n    \n\n\n145\n\n\n\n Bad problem \n\n    \n\n\n126\n\n\n\n "
    },
    "1637C": {
        "title": "C. Andrew and Stones",
        "description": "Andrew has n piles with stones. The i-th pile contains ai stones. He wants to make his table clean so he decided to put every stone either to the 1-st or the n-th pile.\nAndrew can perform the following operation any number of times: choose 3 indices 1\u2264i<j<k\u2264n, such that the j-th pile contains at least 2 stones, then he takes 2 stones from the pile j and puts one stone into pile i and one stone into pile k. \nTell Andrew what is the minimum number of operations needed to move all the stones to piles 1 and n, or determine if it's impossible.\nThe input contains several test cases. The first line contains one integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases.\nThe first line for each test case contains one integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the array elements.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 105.\nFor each test case print the minimum number of operations needed to move stones to piles 1 and n, or print \u22121 if it's impossible.\nIn the first test case, it is optimal to do the following: \nIn the second test case, it's impossible to put all stones into piles with numbers 1 and 3: \nIn the third test case, it's optimal to do the following: \nIn the fourth test case, it's impossible to do any operation, and the array doesn't satisfy the statement, so the answer is \u22121.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1637C - Andrew and StonesConsider 2 cases when the answer is \u22121 for sure:   For all 1<i<n: ai=1. In this case, it's not possible to make any operation and not all stones are in piles 1 or n.  n=3 and a2 is odd. Then after any operation this number will remain odd, so it can never become equal to 0. Later it will become clear why these are the only cases where the answer is \u22121. To show it consider the following algorithm:   If all stones are in piles 1 and n then the algorithm is done.  If there is at least one non-zero even element (piles 1 and n don't count), then subtract 2 from it, add 1 to the odd number to the left or to the pile 1 if there's no such number. Similarly add 1 to the odd number to the right or to the pile n if there's no such number. Then continue the algorithm. Note that the number of odd elements after it (piles 1 and n don't count) decreases at least by 1 (if there was any odd number). Also either a new even number has appeared, or the algorithm will be done.  If all remaining non-zero numbers are odd, then there is at least one odd number greater than 1. So let's subtract 2 from this element and add ones similar to the 2-nd case. In this case the number of odd elements decreases at least by 1. From the notes written in the second and third cases, it follows that the algorithm always puts all stones to the piles 1 and n. Also note that if in the initial array the element in position i (1<i<n) was even, then the algorithm did not add any 1 to it, so the number of operations with the center in i equals to ai2. And if ai was odd, the algorithm will add 1 to this element exactly once, so the number of operations with the center in i equals to ai+12.This algorithm is optimal because for each odd number it's necessary to add at least 1 to it and the algorithm adds exactly 1. And from even elements the algorithm can only subtract. It means that the answer to the problem equals to \u2211n\u22121i=2\u2308ai2\u2309. Time complexity is O(n). Solution#include <bits/stdc++.h>\nusing namespace std;\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto &x : a)\n        cin >> x;\n \n    if (*max_element(a.begin() + 1, a.end() - 1) == 1 || (n == 3 && a[1] % 2 == 1)) {\n        cout << \"-1\\n\";\n        return;\n    }\n \n    long long answer = 0;\n    for (int i = 1; i < n - 1; i++)\n        answer += (a[i] + 1) / 2;\n \n    cout << answer << '\\n';\n}\n \nint main() {\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    int tests;\n    cin >> tests;\n    while (tests--)\n        solve();\n}\n"
    },
    "1637B": {
        "title": "B. MEX and Array",
        "description": "Let there be an array b1,b2,\u2026,bk. Let there be a partition of this array into segments [l1;r1],[l2;r2],\u2026,[lc;rc], where l1=1, rc=k, and for any 2\u2264i\u2264c holds that ri\u22121+1=li. In other words, each element of the array belongs to exactly one segment.\nLet's define the cost of a partition as c+c\u2211i=1mex({bli,bli+1,\u2026,bri}), where mex of a set of numbers S is the smallest non-negative integer that does not occur in the set S. In other words, the cost of a partition is the number of segments plus the sum of MEX over all segments. Let's define the value of an array b1,b2,\u2026,bk as the maximum possible cost over all partitions of this array.\nYou are given an array a of size n. Find the sum of values of all its subsegments.\nAn array x is a subsegment of an array y if x can be obtained from y by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe input contains several test cases. The first line contains one integer t (1\u2264t\u226430)\u00a0\u2014 the number of test cases.\nThe first line for each test case contains one integer n (1\u2264n\u2264100)\u00a0\u2014 the length of the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the array elements.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 100.\nFor each test case print a single integer\u00a0\u2014 the answer to the problem.\nIn the second test case: \nThe sum of values over all subsegments equals to 4+3+1+3+2+1=14.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1637B - MEX and ArrayWe show, that replacing a segment of length $$$k$$$ ($$$k > 1$$$) with segments of length $$$1$$$ does not decrease the cost of the partition. Consider two cases:  The segment does not contain $$$0$$$.  The segment contains $$$0$$$. In the first case the contribution of the segment equals to $$$1$$$ (because $$$mex = 0$$$), but the contribution of $$$k$$$ segments of length $$$1$$$ equals to $$$k$$$. So the cost increased. In the second case the contribution of the segment equals to $$$1 + mex <= 1 + k$$$, but the contribution of the segments of length $$$1$$$ would be at least $$$1 + k$$$, so the cost has not decreased.Then it is possible to replace all segments of length more than $$$1$$$ by segments of length $$$1$$$ and not decrease the cost. So the value of the array $$$b_1, b_2, \\ldots, b_k$$$ equals to $$$\\sum_{i=1}^{k}{(1 + mex(\\{b_i\\}))}$$$ = $$$k$$$ + (the number of zeros in the array).To calculate the total $$$value$$$ of all subsegments, you need to calculate the total length of all subsegments and the contribution of each $$$0$$$. The total length of all subsegments equals to $$$\\frac{n \\cdot (n + 1) \\cdot (n + 2)}{6}$$$. The contribution of a zero in the position $$$i$$$ equals to $$$i \\cdot (n - i + 1)$$$. This solution works in $$$O(n)$$$, but it could be implemented less efficiently.There is also another solution, which uses dynamic programming: let $$$dp_{l, r}$$$ is the value of the array $$$a_l, a_{l + 1}, \\ldots, a_r$$$. Then $$$dp_{l, r} = max(1 + mex(\\{a_l, a_{l + 1}, \\ldots, a_r\\}), \\max_{c = l}^{r - 1} (dp_{l, c} + dp_{c + 1, r}))$$$. This solution can be implemented in $$$O(n^3)$$$ or in $$$O(n^4)$$$. Solution#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto& u : a)\n            cin >> u;\n \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += (i + 1) * (n - i);\n            if (a[i] == 0)\n                ans += (i + 1) * (n - i);\n        }\n        cout << ans << '\\n';\n    }\n}"
    },
    "1635C": {
        "title": "C. Differential Sorting",
        "description": "You are given an array a of n elements. \nYour can perform the following operation no more than n times: Select three indices x,y,z (1\u2264x<y<z\u2264n) and replace ax with ay\u2212az. After the operation, |ax| need to be less than 1018.\nYour goal is to make the resulting array non-decreasing. If there are multiple solutions, you can output any. If it is impossible to achieve, you should report it as well.\nEach test contains multiple test cases. The first line will contain a single integer t (1\u2264t\u226410000) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (3\u2264n\u22642\u22c5105) \u2014 the size of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109), the elements of a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print \u22121 in a single line if there is no solution. Otherwise in the first line you should print a single integer m (0\u2264m\u2264n) \u2014 number of operations you performed.\nThen the i-th of the following m lines should contain three integers x,y,z (1\u2264x<y<z\u2264n)\u2014 description of the i-th operation.\nIf there are multiple solutions, you can output any. Note that you don't have to minimize the number of operations in this task.\nIn the first example, the array becomes \n[\u22126,\u22124,2,\u22121,2] after the first operation,\n[\u22126,\u22124,\u22123,\u22121,2] after the second operation.\nIn the second example, it is impossible to make the array sorted after any sequence of operations.\nIn the third example, the array is already sorted, so we don't need to perform any operations.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1635C - Differential SortingFirst of all, if an\u22121>an, then the answer is \u22121 since we can't change the last two elements.If an\u22650, there exists a simple solution: perform the operation (i,n\u22121,n) for each 1\u2264i\u2264n\u22122.Otherwise, the answer exists if and only if the initial array is sorted. Proof: Assume that an<0 and we can sort the array after m>0 operations. Consider the last operation we performed (xm,ym,zm). Since all elements should be negative after the last operation, so azm<0 should hold before the last operation. But axm=aym\u2212azm>aym after this, so the array isn't sorted in the end. By contradiction, we have proved that we can't perform any operations as long as an<0. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector <int> a(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n        }\n        if (a[n - 2] > a[n - 1]) {\n            cout << -1 << endl;\n        } else {\n            if (a[n - 1] < 0) {\n                if (is_sorted(a.begin(), a.end())) {\n                    cout << 0 << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            } else {\n                cout << n - 2 << endl;\n                for (int i = 1; i <= n - 2; ++i) {\n                    cout << i << ' ' << n - 1 << ' ' << n << endl;\n                }\n            }\n        }\n    }\n}"
    },
    "1634C": {
        "title": "C. OKEA",
        "description": "You work for a well-known department store that uses leading technologies and employs mechanistic work\u00a0\u2014 that is, robots!\nThe department you work in sells n\u22c5k items. The first item costs 1 dollar, the second item costs 2 dollars, and so on: i-th item costs i dollars. The items are situated on shelves. The items form a rectangular grid: there are n shelves in total, and each shelf contains exactly k items. We will denote by ai,j the price of j-th item (counting from the left) on the i-th shelf, 1\u2264i\u2264n,1\u2264j\u2264k.\nOccasionally robots get curious and ponder on the following question: what is the mean price (arithmetic average) of items ai,l,ai,l+1,\u2026,ai,r for some shelf i and indices l\u2264r? Unfortunately, the old robots can only work with whole numbers. If the mean price turns out not to be an integer, they break down.\nYou care about robots' welfare. You want to arrange the items in such a way that the robots cannot theoretically break. Formally, you want to choose such a two-dimensional array a that:\nFind out if such an arrangement is possible, and if it is, give any example of such arrangement.\nThe first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (1\u2264n,k\u2264500)\u00a0\u2014 the number of shelves and length of each shelf, respectively.\nIt is guaranteed that the sum n over all test cases does not exceed 500 and the sum k over all test cases does not exceed 500.\nPrint the answer for each test case.\nIf such an arrangement exists, print \"YES\" on a single line. After that, print any example on n lines of k numbers each, one line per shelf. Each number from 1 to n\u22c5k must occur exactly once in the output.\nIf no good arrangement exists, print a single word \"NO\" on its own line.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1634C - OKEAIf k=1, you can put items on the shelves in any order.Otherwise, there are at least 2 items on each shelf. If there are items of different parity on the shelf, it is obvious that there are two neighboring items of different parity, but then the arithmetic mean of these two items won't be whole, which is against the constraints. Therefore, all items on each shelf are of the same parity.Notice that if the number of shelves n is odd, we cannot arrange the items correctly because the number of shelves with even and odd items must be the same (that is, if k\u22652).Let us show that for even n there is always an answer. On i-th shelf we will place items with prices i,i+n,i+2\u22c5n,\u2026,i+n\u22c5(k\u22121). We can use the formula for the sum of an arithmetic progression to compute the sum of prices of a subsegment with coordinates i,l up to i,r:sum=i\u22c5(r\u2212l+1)+n(l\u22121)+n(r\u22121)2\u22c5(r\u2212l+1)=\u00a0=i\u22c5(r\u2212l+1)+n2\u22c5(l+r\u22122)\u22c5(r\u2212l+1)=\u00a0=(r\u2212l+1)\u22c5(i+n2\u22c5(l+r\u22122))The length of the segment (r\u2212l+1) always divides this sum, since n is even. Therefore, this arrangement fits the requirements of the problem.  Solution145468509 def solve():\n    n, k = map(int, input().split())\n    if k == 1:\n        print(\"YES\")\n        for i in range(1, n + 1):\n            print(i)\n        return\n\n    if n % 2 == 1:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    for i in range(1, n + 1):\n        print(*[i for i in range(i, n * k + 1, n)])\n\n\nfor _ in range(int(input())):\n    solve() Rate the problem Didn't solve \n\n    \n\n\n95\n\n\n\n Good problem \n\n    \n\n\n942\n\n\n\n Average problem \n\n    \n\n\n613\n\n\n\n Bad problem \n\n    \n\n\n162\n\n\n\n "
    },
    "1633C": {
        "title": "C. Kill the Monster",
        "description": "Monocarp is playing a computer game. In this game, his character fights different monsters.\nA fight between a character and a monster goes as follows. Suppose the character initially has health hC and attack dC; the monster initially has health hM and attack dM. The fight consists of several steps:\nThe fight ends when someone's health becomes non-positive (i.\u2009e. 0 or less). If the monster's health becomes non-positive, the character wins, otherwise the monster wins.\nMonocarp's character currently has health equal to hC and attack equal to dC. He wants to slay a monster with health equal to hM and attack equal to dM. Before the fight, Monocarp can spend up to k coins to upgrade his character's weapon and/or armor; each upgrade costs exactly one coin, each weapon upgrade increases the character's attack by w, and each armor upgrade increases the character's health by a.\nCan Monocarp's character slay the monster if Monocarp spends coins on upgrades optimally?\nThe first line contains one integer t (1\u2264t\u22645\u22c5104) \u2014 the number of test cases. Each test case consists of three lines:\nThe first line contains two integers hC and dC (1\u2264hC\u22641015; 1\u2264dC\u2264109) \u2014 the character's health and attack;\nThe second line contains two integers hM and dM (1\u2264hM\u22641015; 1\u2264dM\u2264109) \u2014 the monster's health and attack;\nThe third line contains three integers k, w and a (0\u2264k\u22642\u22c5105; 0\u2264w\u2264104; 0\u2264a\u22641010) \u2014 the maximum number of coins that Monocarp can spend, the amount added to the character's attack with each weapon upgrade, and the amount added to the character's health with each armor upgrade, respectively.\nThe sum of k over all test cases does not exceed 2\u22c5105.\nFor each test case, print YES if it is possible to slay the monster by optimally choosing the upgrades. Otherwise, print NO.\nIn the first example, Monocarp can spend one coin to upgrade weapon (damage will be equal to 5), then health during battle will change as follows: (hC,hM)=(25,9)\u2192(25,4)\u2192(5,4)\u2192(5,\u22121). The battle ended with Monocarp's victory.\nIn the second example, Monocarp has no way to defeat the monster.\nIn the third example, Monocarp has no coins, so he can't buy upgrades. However, the initial characteristics are enough for Monocarp to win.\nIn the fourth example, Monocarp has 4 coins. To defeat the monster, he has to spend 2 coins to upgrade weapon and 2 coins to upgrade armor.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1100"
        ],
        "solutions": "1633C - Kill the MonsterFirst of all, let's understand how to solve the problem without upgrades. To do this, it is enough to compare two numbers: \u2308hMdC\u2309 and \u2308hCdM\u2309\u00a0\u2014 the number of attacks that the character needs to kill the monster and the number of attacks that the monster needs to kill the character, respectively. So, if the first number is not greater than the second number, then the character wins.Note that the number of coins is not very large, which means we can iterate over the number of coins that we will spend on weapon upgrades, and the remaining coins will be spent on armor upgrades. After that, we can use the formula described above to check whether the character will win.The complexity of the solution is O(k). Solution (awoo)for _ in range(int(input())):\n    hc, dc = map(int, input().split())\n    hm, dm = map(int, input().split())\n    k, w, a = map(int, input().split())\n    for i in range(k + 1):\n        nhc = hc + i * a\n        ndc = dc + (k - i) * w\n        if (hm + ndc - 1) // ndc <= (nhc + dm - 1) // dm:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")"
    },
    "1632B": {
        "title": "B. Roof Construction",
        "description": "It has finally been decided to build a roof over the football field in School 179. Its construction will require placing n consecutive vertical pillars. Furthermore, the headmaster wants the heights of all the pillars to form a permutation p of integers from 0 to n\u22121, where pi is the height of the i-th pillar from the left (1\u2264i\u2264n).\nAs the chief, you know that the cost of construction of consecutive pillars is equal to the maximum value of the bitwise XOR of heights of all pairs of adjacent pillars. In other words, the cost of construction is equal to max1\u2264i\u2264n\u22121pi\u2295pi+1, where \u2295 denotes the bitwise XOR operation.\nFind any sequence of pillar heights p of length n with the smallest construction cost.\nIn this problem, a permutation is an array consisting of n distinct integers from 0 to n\u22121 in arbitrary order. For example, [2,3,1,0,4] is a permutation, but [1,0,1] is not a permutation (1 appears twice in the array) and [1,0,3] is also not a permutation (n=3, but 3 is in the array).\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe only line for each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the number of pillars for the construction of the roof.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print n integers p1, p2, \u2026, pn \u2014 the sequence of pillar heights with the smallest construction cost.\nIf there are multiple answers, print any of them.\nFor n=2 there are 2 sequences of pillar heights: \nFor n=3 there are 6 sequences of pillar heights: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1632B \u2014 Roof Construction Hint 1The cost of construction is a power of two. Hint 2The cost of construction is 2k, where k is the highest set bit in n\u22121. SolutionLet k be the highest set bit in n\u22121. There will always be a pair of adjacent elements where one of them has the k-th bit set and the other one doesn't, so the cost is at least 2k. A simple construction that reaches it is 2k\u22121, 2k\u22122, \u2026, 0, 2k, 2k+1, \u2026, n\u22121.Time complexity: O(n)Bonus: count the number of permutations with the minimum cost. Solution codes C++ code. Python code. "
    },
    "1631B": {
        "title": "B. Fun with Even Subarrays",
        "description": "You are given an array a of n elements. You can apply the following operation to it any number of times:\nFor example, if a=[2,1,3,4,5,3], then choose l=1 and k=2, applying this operation the array will become a=[3,4,3,4,5,3].\nFind the minimum number of operations (possibly zero) needed to make all the elements of the array equal.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of the array.\nThe second line of each test case consists of n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each line containing the answer to the corresponding test case \u2014 the minimum number of operations needed to make equal all the elements of the array with the given operation.\nIn the first test, all elements are equal, therefore no operations are needed.\nIn the second test, you can apply one operation with k=1 and l=1, set a1:=a2, and the array becomes [1,1] with 1 operation.\nIn the third test, you can apply one operation with k=1 and l=4, set a4:=a5, and the array becomes [4,4,4,4,4].\nIn the fourth test, you can apply one operation with k=1 and l=3, set a3:=a4, and the array becomes [4,2,3,3], then you can apply another operation with k=2 and l=1, set a1:=a3, a2:=a4, and the array becomes [3,3,3,3].\nIn the fifth test, there is only one element, therefore no operations are needed.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1100"
        ],
        "solutions": "1631B - Fun with Even SubarraysAuthor: humbertoyusta Hint 1It is not possible to modify an using the given operation. Hint 2Think about the leftmost x such that ax\u2260an. SolutionFor simplicity, let b1,b2,...,bn=an,an\u22121,...,a1 (let b be a reversed). The operation transforms to select a subarray [l,r] of length 2\u22c5k, so k=r\u2212l+12, then for all i such that 0\u2264i<k, set bl+k+i=bl+i.b1 can not be changed with the given operation. That reduces the problem to make all elements equal to b1.Let x be the rightmost index such that for all 1\u2264i\u2264x, bi=b1 holds.The problem will be solved when x=n.If an operation is applied with l+k>x+1, bx+1 will not change and x will remain the same.The largest range with l+k\u2264x+1 is [1,2\u22c5x], applying an operation to it will lead to bx+1,bx+2,...,b2\u22c5x=b1,b2,...,bx, so x will become at least 2\u22c5x and there is not any other range that will lead to a bigger value of x.If 2\u22c5x>n, it is possible to apply the operation on [x\u2212(n\u2212x)+1,n], after applying it bx+1,...,bn=bx\u2212(n\u2212x)+1,...,bx and all elements will become equal.The problem can now be solved by repeatedly finding x and applying the operation on [1,2\u22c5x] or on [x\u2212(n\u2212x)+1,n] if 2\u22c5x>n. Since x will become at least 2\u22c5x in each operation but the last one, the naive implementation will take O(nlogn), however, it is easy to implement it in O(n). Code O(nlogn)#include<bits/stdc++.h>\nusing namespace std;\n\nint find_rightmost_x(vector<int> &b){\n    int n = (int)b.size() - 1;\n\n    int x = 1;\n    while( x + 1 <= n && b[x+1] == b[1] )\n        x ++;\n\n    return x;\n}\n\nvoid apply(vector<int> &b,int l,int r){\n    int k = ( r - l + 1 ) / 2;\n    for(int i=0; i<k; i++)\n        b[l+k+i] = b[l+i];\n}\n\nint main(){\n\n    int tc;\n    cin >> tc;\n    while( tc-- ){\n\n        int n;\n        cin >> n;\n\n        vector<int> a(n+1);\n        for(int i=1; i<=n; i++)\n            cin >> a[i];\n\n        vector<int> b = a;\n        reverse(b.begin()+1,b.end());\n\n        int ans = 0;\n        while( find_rightmost_x(b) != n ){\n            int x = find_rightmost_x(b);\n            if( 2 * x > n ){\n                apply(b,x-(n-x)+1,n);\n                ans ++;\n            }\n            else{\n                apply(b,1,2*x);\n                ans ++;\n            }\n        }\n        cout << ans << '\\n';\n    }\n\n\n    return 0;\n} Code O(n)#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int tc;\n    cin >> tc;\n    while(tc--)\n    {\n        int n;\n        cin >> n;\n\n        vector<int> a(n+1);\n        for(int i=1; i<=n; i++)\n            cin >> a[i];\n\n        vector<int> b = a;\n        reverse(b.begin()+1,b.end());\n\n        int ans = 0, x = 1;\n\n        while( x < n )\n        {\n            if( b[x+1] == b[1] ){\n                x ++;\n                continue;\n            }\n            ans ++;\n            x *= 2;\n        }\n\n        cout << ans << '\\n';\n    }\n\n    return 0;\n}"
    },
    "1626B": {
        "title": "B. Minor Reduction",
        "description": "You are given a decimal representation of an integer x without leading zeros.\nYou have to perform the following reduction on it exactly once: take two neighboring digits in x and replace them with their sum without leading zeros (if the sum is 0, it's represented as a single 0).\nFor example, if x=10057, the possible reductions are: \nWhat's the largest number that can be obtained?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nEach testcase consists of a single integer x (10\u2264x<10200000). x doesn't contain leading zeros.\nThe total length of the decimal representations of x over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print a single integer\u00a0\u2014 the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.\nThe first testcase of the example is already explained in the statement.\nIn the second testcase, there is only one possible reduction: the first and the second digits.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1100"
        ],
        "solutions": "1626B - Minor ReductionLet's think how a reduction changes the length of x. There are two cases. If two adjacent letters sum up to 10 or greater, then the length doesn't change. Otherwise, the length decreases by one.Obviously, if there exists a reduction that doesn't change the length, then it's better to use it. Which among such reduction should you choose? Well, notice that such a reduction always makes the number strictly smaller (easy to see with some case analysis). Thus, the logical conclusion is to leave the longest possible prefix of x untouched. So, the rightmost such reduction will change the number as little as possible.If all reductions decrease the length, then a similar argument can be applied. The sum will be a single digit, but a digit that is greater than or equal to the left one of the adjacent pair. If it was just greater, it's easy to see that the leftmost such reduction will make the number the largest possible. The equal case adds more case analysis on top of the proof, but the conclusion remains the same: the leftmost reduction is the best one.As an implementation note, since all the reductions are of the same type, the leftmost reduction always includes the first and the second digits.Overall complexity: O(|x|) per testcase. Solution (awoo)for _ in range(int(input())):\n  x = [ord(c) - ord('0') for c in input()]\n  n = len(x)\n  for i in range(n - 2, -1, -1):\n    if x[i] + x[i + 1] >= 10:\n      x[i + 1] += x[i] - 10\n      x[i] = 1\n      break\n  else:\n    x[1] += x[0]\n    x.pop(0)\n  print(''.join([chr(c + ord('0')) for c in x]))"
    },
    "1625B": {
        "title": "B. Elementary Particles",
        "description": "Martians are actively engaged in interplanetary trade. Olymp City, the Martian city known for its spaceport, has become a place where goods from all the corners of our Galaxy come. To deliver even more freight from faraway planets, Martians need fast spaceships.\nA group of scientists conducts experiments to build a fast engine for the new spaceship. In the current experiment, there are n elementary particles, the i-th of them has type ai.\nDenote a subsegment of the particle sequence (a1,a2,\u2026,an) as a sequence (al,al+1,\u2026,ar) for some left bound l and right bound r (1\u2264l\u2264r\u2264n). For instance, the sequence (1\u00a04\u00a02\u00a08\u00a05\u00a07) for l=2 and r=4 has the sequence (4\u00a02\u00a08) as a subsegment. Two subsegments are considered different if at least one bound of those subsegments differs.\nNote that the subsegments can be equal as sequences but still considered different. For example, consider the sequence (1\u00a01\u00a01\u00a01\u00a01) and two of its subsegments: one with l=1 and r=3 and another with l=2 and r=4. Both subsegments are equal to (1\u00a01\u00a01), but still considered different, as their left and right bounds differ.\nThe scientists want to conduct a reaction to get two different subsegments of the same length. Denote this length k. The resulting pair of subsegments must be harmonious, i.\u00a0e. for some i (1\u2264i\u2264k) it must be true that the types of particles on the i-th position are the same for these two subsegments. For example, the pair (1\u00a07\u00a03) and (4\u00a07\u00a08) is harmonious, as both subsegments have 7 on the second position. The pair (1\u00a02\u00a03) and (3\u00a01\u00a02) is not harmonious.\nThe longer are harmonious subsegments, the more chances for the scientists to design a fast engine. So, they asked you to calculate the maximal possible length of harmonious pair made of different subsegments.\nThe first line contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases. The following are descriptions of the test cases.\nThe first line contains an integer n (2\u2264n\u2264150000) \u2014 the amount of elementary particles in the sequence.\nThe second line contains n integers ai (1\u2264ai\u2264150000) \u2014 types of elementary particles.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test, print a single integer, maximal possible length of harmonious pair made of different subsegments. If such pair does not exist, print \u22121 instead.\nThe first test case is shown on the picture below:\nAs you can see from it, you may choose the subsegments (2\u00a01\u00a03\u00a04) and (3\u00a01\u00a05\u00a02), which are a harmonious pair. Their length is equal to 4, so the answer is 4.\nIn the second test case, you need to take two subsegments: one with l=1 and r=5, and one with l=2 and r=6. It's not hard to observe that these segments are a harmonious pair and considered different even though they are both equal to (1\u00a01\u00a01\u00a01\u00a01).\nIn the third test case, you cannot make a harmonious pair, so the answer is \u22121.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1625B - Elementary ParticlesNote the following fact. For each optimal pair of harmonious strings, it's true that the right string ends on the last character.Proof: suppose it's wrong. Then, we can expand the strings to the right by one character, and they will remain harmonious.Now, prove the following statement, that will help us to solve this problem. The statement is as follows: the answer is n\u2212min(v\u2212u) where minimum is over all u and v such that u<v and au=av.Proof: consider two elements u and v such that u<v and au=av. Suppose that they are on the same position in a pair of harmonious substrings. What maximal length these substring may have?From what was proved above, we know that we can expand the strings to the right. Take the first string starting in u and the second string starting with v. Then, we get the strings of length n\u2212v+1 after expanding them.Still, it's not enough. So, we will also expand the strings to the left. So, the total length of the strings will become n\u2212v+u, which is equal to n\u2212(v\u2212u). The smaller v\u2212u, the larger the length.To solve the problem, we need to find a pair of nearest equal elements quickly. We can do the following: store all the positions of each element (i.\u00a0e. all the positions with ai=1, with ai=2 etc.), and then we iterate over ai, go through the pairs of neighboring positions and calculate the minimum. "
    },
    "1624C": {
        "title": "C. Division by Two and Permutation",
        "description": "You are given an array a consisting of n positive integers. You can perform operations on it.\nIn one operation you can replace any element of the array ai with \u230aai2\u230b, that is, by an integer part of dividing ai by 2 (rounding down).\nSee if you can apply the operation some number of times (possible 0) to make the array a become a permutation of numbers from 1 to n\u00a0\u2014that is, so that it contains all numbers from 1 to n, each exactly once.\nFor example, if a=[1,8,25,2], n=4, then the answer is yes. You could do the following:\nThe first line of input data contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of test cases.\nEach test case contains exactly two lines. The first one contains an integer n (1\u2264n\u226450), the second one contains integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nFor each test case, output on a separate line:\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\nThe first test case is explained in the text of the problem statement.\nIn the second test case, it is not possible to get a permutation.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "flows",
            "graph matchings",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1624C - Division by Two and PermutationLet's sort the array a in descending order of the values of its elements. Then let's create a logical array used, where used[i] will have the value true if we already got element i of the permutation we are looking for, and the value false otherwise.We loop through the elements of the array a and assign x=ai. We'll divide x by 2 as long as it exceeds n or as long as used[x] is true.   If it turns out that x=0, then all the numbers that could be obtained from ai have already been obtained before. Since each element of the array a must produce a new value from 1 to n, the answer cannot be constructed \u2014 output NO.  Otherwise, assign used[x] a value of true \u2014 this means that the number x, which is an element of the permutation, we will get exactly from the original number ai. After processing all elements of the array a we can output YES. Solution#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n    int n;\n    cin >> n;\n    vector<int>a(n), used(n + 1, false);\n    for(auto &i : a) cin >> i;\n    sort(a.begin(), a.end(), [] (int a, int b) {\n        return a > b;\n    });\n    bool ok = true;\n    for(auto &i : a){\n        int x = i;\n        while(x > n or used[x])  x /= 2;\n        if(x > 0) used[x] = true;\n        else ok = false;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n\n}\n\nint main(){\n    ios_base :: sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t;\n    cin >> t;\n    while(t--){\n        solve();\n    }\n    return 0;\n}"
    },
    "1623B": {
        "title": "B. Game on Ranges",
        "description": "Alice and Bob play the following game. Alice has a set S of disjoint ranges of integers, initially containing only one range [1,n]. In one turn, Alice picks a range [l,r] from the set S and asks Bob to pick a number in the range. Bob chooses a number d (l\u2264d\u2264r). Then Alice removes [l,r] from S and puts into the set S the range [l,d\u22121] (if l\u2264d\u22121) and the range [d+1,r] (if d+1\u2264r). The game ends when the set S is empty. We can show that the number of turns in each game is exactly n.\nAfter playing the game, Alice remembers all the ranges [l,r] she picked from the set S, but Bob does not remember any of the numbers that he picked. But Bob is smart, and he knows he can find out his numbers d from Alice's ranges, and so he asks you for help with your programming skill.\nGiven the list of ranges that Alice has picked ([l,r]), for each range, help Bob find the number d that Bob has picked.\nWe can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22641000).\nEach of the next n lines contains two integers l and r (1\u2264l\u2264r\u2264n), denoting the range [l,r] that Alice picked at some point.\nNote that the ranges are given in no particular order.\nIt is guaranteed that the sum of n over all test cases does not exceed 1000, and the ranges for each test case are from a valid game.\nFor each test case print n lines. Each line should contain three integers l, r, and d, denoting that for Alice's range [l,r] Bob picked the number d.\nYou can print the lines in any order. We can show that the answer is unique.\nIt is not required to print a new line after each test case. The new lines in the output of the example are for readability only. \nIn the first test case, there is only 1 range [1,1]. There was only one range [1,1] for Alice to pick, and there was only one number 1 for Bob to pick.\nIn the second test case, n=3. Initially, the set contains only one range [1,3]. \nIn the fourth test case, the game was played with n=5. Initially, the set contains only one range [1,5]. The game's turn is described in the following table. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1623B - Game on RangesIf the length of a range [l,r] is 1 (that is, l=r), then d=l=r. Otherwise, if Bob picks a number d, then Alice has to put the sets [l,d\u22121] and [d+1,r] (if existed) back to the set. Thus, there will be a moment that Alice picks the range [l,d\u22121] (if existed), and another moment to pick the range [d+1,r] (if existed) as well.Using the above observation, for each range [l,r], we can iterate the number d from l to r, check if both range [l,d\u22121] (if d>l) and [d+1,r] (if d<r) existed in the Alice's picked ranges. Or in other words, check if these ranges are given in the input.For checking, we can either use set data structures supported in most programming languages or simply use a 2-dimensional array for marking the picked ranges. The time complexity is, therefore, O(n2).  This problem can be solved in O(nlogn) as well, and even O(n) with some black magic like counting sort, but that is not required during the contest. Problem note The game process is actually inspired by Quick sort: the range, picked by Alice, is the sorting range, and the number, picked by Bob, is the pivot. Testers really like sorting. Some of the testers demand order for the input, so they need to do the sorting. But Nah, that is totally not required :) Pascal solution: 140968967. C++ solution: 140968942C. Balanced Stone Heaps Tutorial"
    },
    "1622B": {
        "title": "B. Berland Music",
        "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to pi, where 1\u2264pi\u2264n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that si=0 means that he disliked the i-th song, and si=1 means that he liked it.\nNow the service has to re-evaluate the song ratings in such a way that:\nAmong all valid permutations q find the one that has the smallest value of n\u2211i=1|pi\u2212qi|, where |x| is an absolute value of x.\nPrint the permutation q1,q2,\u2026,qn. If there are multiple answers, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of songs.\nThe second line of each testcase contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n)\u00a0\u2014 the permutation of the predicted ratings.\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print a permutation q\u00a0\u2014 the re-evaluated ratings of the songs. If there are multiple answers such that n\u2211i=1|pi\u2212qi| is minimum possible, you can print any of them.\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. n\u2211i=1|pi\u2212qi|=|1\u22122|+|2\u22121|=2.\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1622B - Berland MusicSince we know that every disliked song should have lower rating than every liked song, we actually know which new ratings should belong to disliked songs and which should belong to the liked ones.The disliked songs take ratings from 1 to the number of zeros in s. The liked songs take ratings from the number of zeros in s plus 1 to n. Thus, we have two independent tasks to solve.Let the disliked songs have ratings d1,d2,\u2026,dk. Their new ratings should be 1,2,\u2026,k. We can show that if we sort the array d, then |d\u20321\u22121|+|d\u20322\u22122|+\u22ef+|d\u2032k\u2212k| will be the lowest possible. The general way to prove it is to show that if the order has any inversions, we can always fix the leftmost of them (swap two adjacent values), and the cost doesn't increase.So the solution can be to sort triples (si,pi,i) and restore q from the order of i in these.Overall complexity: O(nlogn) per testcase. Solution (awoo)for _ in range(int(input())):\n\tn = int(input())\n\tp = [int(x) for x in input().split()]\n\ts = input()\n\tl = sorted([[s[i], p[i], i] for i in range(n)])\n\tq = [-1 for i in range(n)]\n\tfor i in range(n):\n\t\tq[l[i][2]] = i + 1\n\tprint(*q)"
    },
    "1620B": {
        "title": "B. Triangles on a Rectangle",
        "description": "A rectangle with its opposite corners in (0,0) and (w,h) and sides parallel to the axes is drawn on a plane.\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. Also, there are at least two points on every side of a rectangle.\nYour task is to choose three points in such a way that: \nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains two integers w and h (3\u2264w,h\u2264106)\u00a0\u2014 the coordinates of the corner of a rectangle.\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2\u2264k\u22642\u22c5105)\u00a0\u2014 the number of points. Then, k integers x1<x2<\u22ef<xk (0<xi<w)\u00a0\u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2\u2264k\u22642\u22c5105)\u00a0\u2014 the number of points. Then, k integers y1<y2<\u22ef<yk (0<yi<h)\u00a0\u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\nThe total number of points on all sides in all testcases doesn't exceed 2\u22c5105.\nFor each testcase print a single integer\u00a0\u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\nThe points in the first testcase of the example: \nThe largest triangle is formed by points (0,1), (0,6) and (5,4)\u00a0\u2014 its area is 252. Thus, the doubled area is 25. Two points that are on the same side are: (0,1) and (0,6).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1620B - Triangles on a RectangleThe area of a triangle is equal to its base multiplied by its height divided by 2. Let the two points that have to be on the same side of a rectangle form its base. To maximize it, let's choose such two points that are the most apart from each other\u00a0\u2014 the first and the last in the list.Then the height will be determined by the distance from that side to the remaining point. Since there are points on all sides, the points on the opposite side are the furthest. Thus, the height is always one of h or w, depending on whether we picked the horizontal or the vertical side.So we have to check four options to pick the side and choose the best answer among them. Solution (awoo)for _ in range(int(input())):\n  w, h = map(int, input().split())\n  ans = 0\n  for i in range(4):\n    a = [int(x) for x in input().split()][1:]\n    ans = max(ans, (a[-1] - a[0]) * (h if i < 2 else w))\n  print(ans)"
    },
    "1619C": {
        "title": "C. Wrong Addition",
        "description": "Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers a and b using the following algorithm:\nFor example, the numbers a=17236 and b=3465 Tanya adds up as follows:\n+17236034651106911\nAs a result, she gets 1106911.\nYou are given two positive integers a and s. Find the number b such that by adding a and b as described above, Tanya will get s. Or determine that no suitable b exists.\nThe first line of input data contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of a single line containing two positive integers a and s (1\u2264a<s\u22641018) separated by a space.\nFor each test case print the answer on a separate line.\nIf the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.\nIf no suitable number b exists, output -1.\nThe first test case is explained in the main part of the statement.\nIn the third test case, we cannot choose b that satisfies the problem statement.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "1619C - Wrong AdditionLet's compute the answer to the array b, where bk is the digit at the k position in the number we are looking for. Let i be the position of the last digit in number a, j be the position of the last digit in number s. Then denote x=ai, y=sj, and consider the cases:   if x\u2264y, then the sum of ai+bi was exactly si, then bi=y\u2212x.  if x>y, then the sum ai+bi was greater than 9 and we need to look at the next digit of the number s. If there isn't one, we can't get the answer \u2014 we'll output -1. Otherwise we recalculate y=10\u22c5sj\u22121+sj and reduce j by one.  if now y\u226510 and y\u226418, then bi=y\u2212x. Otherwise, we deduce -1, since we cannot get more than 9+9=18 when adding two digits, and the cases where ai+bi<10 have already been considered before.  After considering the cases, reduce i and j by one and repeat the checks as long as i>0 or j>0. In the situation where j=0, but i>0, we will still have uncheked digits of number a, so we will also output -1. Otherwise, we output an array with the answer without leading zeros. Solution#include<bits/stdc++.h>\n#define len(s) (int)s.size()\nusing namespace std;\nusing ll = long long;\n \nvoid solve(){\n    ll a, s;\n    cin >> a >> s;\n    vector<int>b;\n    while(s){\n        int x = a % 10;\n        int y = s % 10;\n        if(x <= y) b.emplace_back(y - x);\n        else{\n            s /= 10;\n            y += 10 * (s % 10);\n            if(x < y && y >= 10 && y <= 19) b.emplace_back(y - x);\n            else{\n                cout << -1 << '\\n';\n                return;\n            }\n        }\n        a /= 10;\n        s /= 10;\n    }\n    if(a) cout << -1 << '\\n';\n    else{\n        while (b.back() == 0) b.pop_back();\n        for(int i = len(b) - 1; i >= 0; i--) cout << b[i];\n        cout << '\\n';\n    }\n}\n \nint main(){\n    ios_base ::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    int t;\n    cin >> t;\n    while (t){\n        solve();\n        t--;\n    }\n    return 0;\n}"
    },
    "1618C": {
        "title": "C. Paint the Array",
        "description": "You are given an array a consisting of n positive integers. You have to choose a positive integer d and paint all elements into two colors. All elements which are divisible by d will be painted red, and all other elements will be painted blue.\nThe coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of d which yields a beautiful coloring, or report that it is impossible.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains one integer n (2\u2264n\u2264100) \u2014 the number of elements of the array.\nThe second line of each testcase contains n integers a1,a2,\u2026,an (1\u2264ai\u22641018).\nFor each testcase print a single integer. If there is no such value of d that yields a beautiful coloring, print 0. Otherwise, print any suitable value of d (1\u2264d\u22641018).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1618C - Paint the ArrayWhat does it mean that no pair of adjacent elements should have the same color? It means that either all elements on odd positions are blue and all elements on even positions are red, or vice versa. So, we need to check these two cases.Let's try to solve a case when we have to find a number d such that a1,a3,\u2026 are divisible by d, and a2,a4,\u2026 are not. What does it mean that d divides all of the numbers a1,a3,\u2026? It means that d divides the gcd(a1,a3,\u2026), where gcd represents the greatest common divisor. Let's calculate this gcd using Euclidean algorithm or some built-in functions in O(n+logA).Okay, now we need to check all divisors of the gcd(a1,a3,\u2026) and find if any of them does not divide a2,a4,\u2026. So, we have to factorize gcd and generate all of its divisors... or do we? In fact, if gcd(a1,a3,\u2026) divides any of the numbers a2,a4,\u2026, then every divisor of gcd also divides that number. So, the only two numbers we have to check as canditates for the answer are gcd(a1,a3,\u2026) and gcd(a2,a4,\u2026). Solution (BledDest)#include <bits/stdc++.h>     \n\nusing namespace std;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    for(int i = 0; i < n; i++)\n    {\n        cin >> a[i];\n    }\n    vector<long long> g(a.begin(), a.begin() + 2);\n    for(int i = 0; i < n; i++)\n    {\n        g[i % 2] = __gcd(g[i % 2], a[i]);\n    }  \n    vector<bool> good(2, true);\n    for(int i = 0; i < n; i++)\n    {\n        good[i % 2] = good[i % 2] && (a[i] % g[(i % 2) ^ 1] > 0);\n    }   \n    long long ans = 0;\n    for(int i = 0; i < 2; i++)\n        if(good[i])\n            ans = max(ans, g[i ^ 1]);\n    cout << ans << endl;\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    for(int i = 0; i < t; i++)\n    {\n        solve();\n    }\n}"
    },
    "1616B": {
        "title": "B. Mirror in the String",
        "description": "You have a string s1s2\u2026sns1s2\u2026sn and you stand on the left of the string looking right. You want to choose an index k (1\u2264k\u2264n) and place a mirror after the k-th letter, so that what you see is s1s2\u2026sksksk\u22121\u2026s1. What is the lexicographically smallest string you can see?\nA string a is lexicographically smaller than a string b if and only if one of the following holds: \nThe first line of input contains one integer t (1\u2264t\u226410000): the number of test cases.\nThe next t lines contain the description of the test cases, two lines per a test case.\nIn the first line you are given one integer n (1\u2264n\u2264105): the length of the string.\nThe second line contains the string s consisting of n lowercase English characters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print the lexicographically smallest string you can see.\nIn the first test case choose k=1 to obtain \"cc\".\nIn the second test case choose k=3 to obtain \"cbaabc\".\nIn the third test case choose k=1 to obtain \"aa\".\nIn the fourth test case choose k=1 to obtain \"bb\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1100"
        ],
        "solutions": "1616B - Mirror in the StringLet's compare s1s2\u2026sksksk\u22121\u2026s1 and s1s2\u2026sk+1sk+1sk\u2026s1. Note that they have a long common prefix s1,s2,\u2026,sk. And the next pair of characters to compare is sk+1 and sk. So, unless s1s2\u2026sksksk\u22121\u2026s1 is a prefix of s1s2\u2026sk+1sk+1sk\u2026s1, it is optimal to choose k+1 if sk+1\u2264sk.Pushing this idea further, we can see that the answer is either s1s1 or s1s2\u2026sksksk\u22121\u2026s1, for the largest k such that sk\u2264sk\u22121. "
    },
    "1614B": {
        "title": "B. Divan and a New Project",
        "description": "The company \"Divan's Sofas\" is planning to build n+1 different buildings on a coordinate line so that: \nLet xi be the coordinate of the i-th building. To get from the building i to the building j, Divan spends |xi\u2212xj| minutes, where |y| is the absolute value of y.\nAll buildings that Divan is going to build can be numbered from 0 to n. The businessman will live in the building 0, the new headquarters of \"Divan's Sofas\". In the first ten years after construction Divan will visit the i-th building ai times, each time spending 2\u22c5|x0\u2212xi| minutes for walking.\nDivan asks you to choose the coordinates for all n+1 buildings so that over the next ten years the businessman will spend as little time for walking as possible.\nEach test contains several test cases. The first line contains one integer number t (1\u2264t\u2264103) \u2014 the number of test cases.\nThe first line of each case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the number of buildings that \"Divan's Sofas\" is going to build, apart from the headquarters.\nThe second line contains the sequence a1,a2,\u2026,an (0\u2264ai\u2264106), where ai is the number of visits to the i-th building.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, on the first line print the number T \u2014 the minimum time Divan will spend walking. \nOn the second line print the sequence x0,x1,\u2026,xn of n+1 integers, where xi (\u2212106\u2264xi\u2264106) is the selected coordinate of the i-th building. It can be shown that an optimal answer exists with coordinates not exceeding 106.\nIf there are multiple answers, print any of them.\nLet's look at the first example.\nDivan will visit the first building a1=1 times, the second a2=2 times and the third a3=3 times. Then one of the optimal solution will be as follows: \nIn total, Divan will spend 4+4+6=14 minutes. It can be shown that it is impossible to arrange buildings so that the businessman spends less time.\nAmong others, x=[1,3,2,0], x=[\u22125,\u22123,\u22126,\u22124] are also correct answers for the first example.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1613C": {
        "title": "C. Poisoned Dagger",
        "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100500 seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the ai-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\nFor example, suppose k=4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of the test case contains two integers n and h (1\u2264n\u2264100;1\u2264h\u22641018)\u00a0\u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\nThe second line contains n integers a1, a2, ..., an (1\u2264ai\u2264109;ai<ai+1), where ai is the second when the i-th attack is performed.\nFor each test case, print a single integer\u00a0\u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\nIn the first example, for k=3, damage is dealt in seconds [1,2,3,5,6,7].\nIn the second example, for k=4, damage is dealt in seconds [2,3,4,5,6,7,10,11,12,13].\nIn the third example, for k=1, damage is dealt in seconds [1,2,4,5,7].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "*1200"
        ],
        "solutions": "1613C - Poisoned DaggerLet's find out the total damage for a fixed value of k. Since the effect of the poison from the i-th attack deals damage min(k,ai+1\u2212ai) seconds for i<n and k seconds for i=n, then the total damage is k+\u2211i=1n\u22121min(k,ai+1\u2212ai). We can see that the higher the value of k, the greater the total sum. So we can do a binary search on k and find the minimum value when the sum is greater than or equal to h. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing li = long long;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    li h;\n    cin >> n >> h;\n    vector<li> a(n);\n    for (li &x : a) cin >> x;\n    li l = 1, r = 1e18;\n    while (l <= r) {\n      li m = (l + r) / 2;\n      li sum = m;\n      for (int i = 0; i < n - 1; ++i) \n        sum += min(m, a[i + 1] - a[i]);\n      if (sum < h) l = m + 1;\n      else r = m - 1;\n    }\n    cout << r + 1 << '\\n';\n  }\n}"
    },
    "1613B": {
        "title": "B. Absent Remainder",
        "description": "You are given a sequence a1,a2,\u2026,an consisting of n pairwise distinct positive integers.\nFind \u230an2\u230b different pairs of integers x and y such that: \nNote that some x or y can belong to multiple pairs.\n\u230ax\u230b denotes the floor function\u00a0\u2014 the largest integer less than or equal to x. x\u00a0mod\u00a0y denotes the remainder from dividing x by y.\nIf there are multiple solutions, print any of them. It can be shown that at least one solution always exists.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the sequence.\nThe second line of each testcase contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106).\nAll numbers in the sequence are pairwise distinct. The sum of n over all testcases doesn't exceed 2\u22c5105.\nThe answer for each testcase should contain \u230an2\u230b different pairs of integers x and y such that x\u2260y, x and y appear in a and x\u00a0mod\u00a0y doesn't appear in a. Print the pairs one after another.\nYou can print the pairs in any order. However, the order of numbers in the pair should be exactly such that the first number is x and the second number is y. All pairs should be pairwise distinct.\nIf there are multiple solutions, print any of them.\nIn the first testcase there are only two pairs: (1,4) and (4,1). \u230a22\u230b=1, so we have to find one pair. 1\u00a0mod\u00a04=1, and 1 appears in a, so that pair is invalid. Thus, the only possible answer is a pair (4,1).\nIn the second testcase, we chose pairs 8\u00a0mod\u00a02=0 and 8\u00a0mod\u00a04=0. 0 doesn't appear in a, so that answer is valid. There are multiple possible answers for that testcase.\nIn the third testcase, the chosen pairs are 9\u00a0mod\u00a05=4 and 7\u00a0mod\u00a05=2. Neither 4, nor 2, appears in a, so that answer is valid.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1000"
        ],
        "solutions": "1613B - Absent RemainderIdea: BledDest TutorialTutorial is loading... Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int &x : a) cin >> x;\n    int mn = *min_element(a.begin(), a.end());\n    for (int i = 0, k = 0; k < n / 2; ++i) if (a[i] != mn) {\n      cout << a[i] << ' ' << mn << '\\n';\n      k += 1;\n    }\n  }\n}"
    },
    "1611C": {
        "title": "C. Polycarp Recovers the Permutation",
        "description": "Polycarp wrote on a whiteboard an array p of length n, which is a permutation of numbers from 1 to n. In other words, in p each number from 1 to n occurs exactly once.\nHe also prepared a resulting array a, which is initially empty (that is, it has a length of 0).\nAfter that, he did exactly n steps. Each step looked like this:\nNote that on the last step, p has a length of 1 and its minimum element is both leftmost and rightmost. In this case, Polycarp can choose what role the minimum element plays. In other words, this element can be added to a both on the left and on the right (at the discretion of Polycarp).\nLet's look at an example. Let n=4, p=[3,1,4,2]. Initially a=[]. Then:\nThus, a possible value of a after n steps could be a=[1,3,2,4].\nYou are given the final value of the resulting array a. Find any possible initial value for p that can result the given a, or determine that there is no solution.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nEach test case consists of two lines. The first of them contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of the array a. The second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of the array a. All elements of the a array are distinct numbers.\nIt is guaranteed that the sum of the values n over all test cases in the test does not exceed 2\u22c5105.\nPrint t lines, each of the lines must contain the answer to the corresponding set of input data: numbers p1,p2,\u2026,pn \u00a0\u2014 any of the possible initial values of the array p, which will lead to the given array a. All elements of p are distinct integers from 1 to n. Thus, if there are several solutions, print any. If there is no solution, then print -1 on the line.\nThe first test case in the example is clarified in the main section of the problem statement. There may be other correct answers for this test set.\nIn the second test case, n=1. Thus, there is only one permutation that can be the answer: p=[1]. Indeed, this is the answer to this test case.\nIn the third test case of the example, no matter what permutation you take as p, after applying the n steps, the result will differ from a=[1,3,5,4,2].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1611C - Polycarp Recovers the PermutationThe maximum element is always added last, so if it is not in the first or last position, then there is no answer.Let us prove that if the permutation has its maximum element in the first or last position, then after n actions we can get an expanded permutation. Indeed, the maximum element will be added last at the desired end, and all the others will be added in reverse order.Then, if the answer exists, it is sufficient to simply unfold the permutation. Solution#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define forn(i, n) for (int i = 0; i < int(n); i++)\n \nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        forn(i, n)\n            cin >> a[i];\n        if (a[0] != n && a[n - 1] != n)\n            cout << -1 << endl;\n        else {\n            for (int i = n - 1; i >= 0; i--)\n                cout << a[i] << \" \";\n            cout << endl;\n        }\n    }\n}"
    },
    "1610B": {
        "title": "B. Kalindrome Array",
        "description": "An array [b1,b2,\u2026,bm] is a palindrome, if bi=bm+1\u2212i for each i from 1 to m. Empty array is also a palindrome.\nAn array is called kalindrome, if the following condition holds:\nIt's possible to select some integer x and delete some of the elements of the array equal to x, so that the remaining array (after gluing together the remaining parts) is a palindrome. \nNote that you don't have to delete all elements equal to x, and you don't have to delete at least one element equal to x.\nFor example : \nYou are given an array [a1,a2,\u2026,an]. Determine if a is kalindrome or not.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 elements of the array.\nIt's guaranteed that the sum of n over all test cases won't exceed 2\u22c5105.\nFor each test case, print YES if a is kalindrome and NO otherwise. You can print each letter in any case.\nIn the first test case, array [1] is already a palindrome, so it's a kalindrome as well.\nIn the second test case, we can choose x=2, delete the second element, and obtain array [1], which is a palindrome.\nIn the third test case, it's impossible to obtain a palindrome.\nIn the fourth test case, you can choose x=4 and delete the fifth element, obtaining [1,4,4,1]. You also can choose x=1, delete the first and the fourth elements, and obtain [4,4,4].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solutions": "1610B - Kalindrome ArrayIf the array is already a palindrome the answer is Yes. Otherwise, let's find the minimum i that ai\u2260an+1\u2212i.We can prove that we have to remove either ai or an+1\u2212i in order the make the array palindrome.Imagine it's possible to make the array palindrome by removing all appearances of x. x\u2260ai,an+1\u2212iThe number of appearances of x before i is equal to the number of appearances of x after n+1\u2212i. So in order to make the array palindrome, ai must be equal to an+1\u2212i.So we just have to check if the array will be palindrome after removing all appearances of ai or after removing all appearances of an+1\u2212i.Time complexity: O(n) Implementation//khodaya khodet komak kon\n# include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define lc                                              id << 1\n# define rc                                              id << 1 | 1\n# define fast_io                                         ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 2e5 + 10;\nconst int xm = - 20 + 10;\nconst int sq = 320;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst ld eps = 1e-15;\nconst int mod = 998244353;\nconst int base = 257;\n \nint qq, n, m, a[xn], b[xn];\nbool ans;\n \nvoid check(int x){\n\tm = 0;\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (a[i] != x)\n\t\t\tb[++ m] = a[i];\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (b[i] != b[m + 1 - i])\n\t\t\treturn;\n\tans = true;\n}\n \nint main(){\n\tfast_io;\n \n\tcin >> qq;\n\twhile (qq --){\n\t\tcin >> n, ans = true;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tcin >> a[i];\n\t\tfor (int i = 1; i <= n; ++ i){\n\t\t\tif (a[i] != a[n + 1 - i]){\n\t\t\t\tans = false;\n\t\t\t\tcheck(a[i]);\n\t\t\t\tcheck(a[n + 1 - i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ans)\n\t\t\tcout << \"YES\" << endl;\n\t\telse\n\t\t\tcout << \"NO\" << endl;\n\t}\n \n\treturn 0;\n}\n"
    },
    "1609B": {
        "title": "B. William the Vigilant",
        "description": "Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment:\nYou are given a string s of length n only consisting of characters \"a\", \"b\" and \"c\". There are q queries of format (pos,c), meaning replacing the element of string s at position pos with character c. After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string \"abc\" as a substring. A valid replacement of a character is replacing it with \"a\", \"b\" or \"c\".\nA string x is a substring of a string y if x can be obtained from y by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nThe first line contains two integers n and q (1\u2264n,q\u2264105), the length of the string and the number of queries, respectively.\nThe second line contains the string s, consisting of characters \"a\", \"b\" and \"c\".\nEach of the next q lines contains an integer i and character c (1\u2264i\u2264n), index and the value of the new item in the string, respectively. It is guaranteed that character's c value is \"a\", \"b\" or \"c\".\nFor each query output the minimal number of characters that would have to be replaced so that the string doesn't contain \"abc\" as a substring.\nLet's consider the state of the string after each query: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1609B - William the VigilantNotice that the answer to this problem is the number of substrings \"abc\"Before starting to process queries let's count the number of substrings \"abc\" in the initial string. Next, notice that changing a character on position pos can only remove one substring \"abc\" and add only one substring \"abc\". To check if either of those changes occurred we only need to look at characters no more than two positions away from pos and see if substring \"abc\" appeared (or disappeared) there.Prepared by AleXman111.Solution: 137274647 "
    },
    "1608B": {
        "title": "B. Build the Permutation",
        "description": "You are given three integers n,a,b. Determine if there exists a permutation p1,p2,\u2026,pn of integers from 1 to n, such that:\nThere are exactly a integers i with 2\u2264i\u2264n\u22121 such that pi\u22121<pi>pi+1 (in other words, there are exactly a local maximums).\nThere are exactly b integers i with 2\u2264i\u2264n\u22121 such that pi\u22121>pi<pi+1 (in other words, there are exactly b local minimums).\nIf such permutations exist, find any such permutation.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe only line of each test case contains three integers n, a and b (2\u2264n\u2264105, 0\u2264a,b\u2264n).\nThe sum of n over all test cases doesn't exceed 105.\nFor each test case, if there is no permutation with the requested properties, output \u22121.\nOtherwise, print the permutation that you are found. If there are several such permutations, you may print any of them.\nIn the first test case, one example of such permutations is [1,3,2,4]. In it p1<p2>p3, and 2 is the only such index, and p2>p3<p4, and 3 the only such index.\nOne can show that there is no such permutation for the third test case.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1608B - Build the PermutationFirst, answer does not exists if a+b+2>n.Second, answer exists if and only if |a\u2212b|\u22641.It happens because between every two consecutive local maximums must be exactly one local minimum. And vice versa, between two consecutive minimums must be exactly one maximum. First case gives b\u2265a\u22121, second\u00a0\u2014 a\u2265b\u22121, both in total gives a\u22121\u2264b\u2264a+1.Lets build answer considering a\u2265b. Otherwise we can build inverse answer: swap a and b, and perform replace pi=n\u2212pi+1.Lets take a+b+2 biggest numbers (i. e. from n downto n\u2212a\u2212b\u22121) and put them consequentially, such numbers on first position and on each second position from first are less then other numbers. It gives that every number, except first and last, are local maximum or local minimum. Rest of the numbers needed to be placed before this sequence in increasing order.Author: TadijaSebez "
    },
    "1607C": {
        "title": "C. Minimum Extraction",
        "description": "Yelisey has an array a of n integers.\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \nThus, after each operation, the length of the array is reduced by 1.\nFor example, if a=[1,6,\u22124,\u22122,\u22124], then the minimum element in it is a3=\u22124, which means that after this operation the array will be equal to a=[1\u2212(\u22124),6\u2212(\u22124),\u22122\u2212(\u22124),\u22124\u2212(\u22124)]=[5,10,2,0].\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain descriptions of the test cases.\nIn the description of each test case, the first line contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the original length of the array a. The second line of the description lists n space-separated integers ai (\u2212109\u2264ai\u2264109)\u00a0\u2014 elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer\u00a0\u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\nIn the first example test case, the original length of the array n=1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a1=10.\nIn the second set of input data, the array will always consist only of zeros.\nIn the third set, the array will be changing as follows: [\u22121,2,0]\u2192[3,1]\u2192[2]. The minimum elements are highlighted with blue. The maximal one is 2.\nIn the fourth set, the array will be modified as [2,10,1,7]\u2192[1,9,6]\u2192[8,5]\u2192[3]. Similarly, the maximum of the minimum elements is 5.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "sortings",
            "*1000"
        ],
        "solutions": "1607C - Minimum ExtractionNote that the order of numbers in the array does not affect anything. If you swap two elements in the original array, the set of elements at each step will not change in any way. Let's sort the original array a and denote it by a0.We denote by ai the state of array a0 after applying i operations of minimum extraction. The minimum element in a0 is a01, so the elements of array a1 will be equal to a1i=a0i+1\u2212a01, and therefore the minimum of them will be a02\u2212a01.Constructing an array a2, we can notice that its elements are equal to a2i=a1i+1\u2212a11. We know that the elements of a1 are the difference between corresponding elements of the array a0 and a01, so a2i=a1i+1\u2212a11=(a0i+2\u2212a01)\u2212(a02\u2212a01)=a0i+2\u2212a02Thus, the elements of the array a2 are the differences between elements of a0 starting with third and a02, the minimum of which is a03\u2212a02. It is not difficult to show in a similar way (for example by induction) that the elements of ac are equal to aci=a0i+c\u2212a0c, the minimum of which is a0c+1\u2212a0c.So the \"candidates\" for the answer are simply differences of adjacent elements of the array a0. Indeed, if we look at a0=[1,4,6,12,13], it will undergo changes as follows: [1,4,6,12,15]\u2192[3,5,11,14]\u2192[2,8,11]\u2192[6,9]\u2192[3]. You can notice that the minimum elements starting with after the first operation are exactly 4\u22121, 6\u22124, 12\u22126 and 15\u221212, respectively.Thus, to solve the problem, it was sufficient to sort the array in ascending order, then take the maximum of the original first element and the differences of all adjacent elements max(a01,maxi=2n(a0i\u2212a0i\u22121)) Solutiont = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = sorted(list(map(int, input().split())))\n    res = a[0]\n    for i in range(n - 1):\n        res = max(res, a[i + 1] - a[i])\n    print(res)"
    },
    "1606B": {
        "title": "B. Update Files",
        "description": "Berland State University has received a new update for the operating system. Initially it is installed only on the 1-st computer.\nUpdate files should be copied to all n computers. The computers are not connected to the internet, so the only way to transfer update files from one computer to another is to copy them using a patch cable (a cable connecting two computers directly). Only one patch cable can be connected to a computer at a time. Thus, from any computer where the update files are installed, they can be copied to some other computer in exactly one hour.\nYour task is to find the minimum number of hours required to copy the update files to all n computers if there are only k patch cables in Berland State University.\nThe first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases.\nEach test case consists of a single line that contains two integers n and k (1\u2264k\u2264n\u22641018) \u2014 the number of computers and the number of patch cables.\nFor each test case print one integer\u00a0\u2014 the minimum number of hours required to copy the update files to all n computers.\nLet's consider the test cases of the example:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1606B - Update FilesLet cur be the current number of computers with the update already installed (initially it is 1). Then, in 1 hour, we can increase cur by min(cur,k). From here we can see that the value of cur will double for the first few hours, and then, when it becomes greater than k, it will begin to increase by exactly k.The process when the number of computers doubles can be modeled using a loop, because the number of doublings does not exceed logn. And after that, we have to increase the answer by \u2308n\u2212curk\u2309 to take the number of additions of k into account.Note that computing \u2308n\u2212curk\u2309 should be done without using fractional data types; to calculate \u2308xy\u2309 in integers, you should divide x+y\u22121 by y using integer division (this will work provided that both x and y are non-negative, and y\u22600). If you use real numbers, this may cause precision issues. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing li = long long;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); \n  int t;\n  cin >> t;\n  while (t--) {\n    li n, k;\n    cin >> n >> k;\n    li ans = 0, cur = 1;\n    while (cur < k) {\n      cur *= 2;\n      ++ans;\n    }\n    if (cur < n) ans += (n - cur + k - 1) / k;\n    cout << ans << '\\n';\n  }\n}"
    },
    "1605B": {
        "title": "B. Reverse Sort",
        "description": "Ashish has a binary string s of length n that he wants to sort in non-decreasing order.\nHe can perform the following operation: \nFind the minimum number of operations required to sort the string in non-decreasing order. It can be proven that it is always possible to sort the given binary string in at most n operations.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22641000) \u00a0\u2014 the length of the binary string s.\nThe second line of each test case contains a binary string s of length n containing only 0s and 1s.\nIt is guaranteed that the sum of n over all test cases does not exceed 1000.\nFor each test case output the following:\nIn the first test case, the binary string is already sorted in non-decreasing order.\nIn the second test case, we can perform the following operation: \n1_ 0 1_ 0_ 0_ \u2192 0_ 0 0_ 1_ 1_ \nIn the third test case, we can perform the following operation:\n0 0 1_ 0 0_ 0_ \u2192 0 0 0_ 0 0_ 1_",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1605B - Reverse SortAny binary string s can be sorted in at most 1 operation!Let the number of 0s in s be cnt0 and the number of 1s in s be cnt1.The first cnt0 positions of the final sorted string will be 0 and the remaining cnt1 positions will be 1 (since it is sorted in non-decreasing order).Key observation: For every 1 that is in the first cnt0 positions of s, there is a 0 that is in the last cnt1 positions of s (Why?).If the string is not already sorted, in one operation pick the subsequence consisting of all 1s among the first cnt0 positions of s as well as all 0s among the last cnt1 positions of s. It can be shown that this will correctly sort the string since the number of such 0s and 1s are equal.Time complexity: O(n)  Solution [c++] (JeevanJyot)#include <bits/stdc++.h>\nusing namespace std;\n \nint32_t main()\n{\n    ios_base::sync_with_stdio(0); \n    cin.tie(0); cout.tie(0);\n    int T; cin >> T;\n    while(T--)\n    {\n        int n; cin >> n;\n        string s; cin >> s;\n        if(is_sorted(s.begin(), s.end()))\n        {\n            cout << 0 << \"\\n\";\n            continue;\n        }\n        \n        string t = s;\n        sort(t.begin(), t.end());\n        cout << 1 << \"\\n\";\n        vector<int> ans;\n        for(int i = 0; i < n; i++)\n        {\n            if(s[i] != t[i])\n                ans.push_back(i+1);\n        }\n        cout << ans.size() << \" \";\n        for(int i = 0; i < ans.size(); i++)\n            cout << ans[i] << \" \\n\"[i+1 == ans.size()];\n    }        \n    return 0;\n} Solution [Kotlin] (ExplodingFreeze)fun main(args: Array<String>) {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val s = readLine()!!\n        if(\"10\" in s) {\n            println(1);\n            val res = s.toCharArray().sorted().withIndex().filter { it.value != s[it.index] }.map { it.index + 1 }\n            println(\"$$${res.size} $$${res.joinToString(\" \")}\");\n        } else {\n            println(0);\n        }\n        \n    }\n} Solution [Python] (AshishGup)q = int(input())\nfor tc in range(q):\n    n = int(input())\n    s = input()\n    t = ''.join(sorted(s))\n    ans = []\n    for i in range(len(s)):\n        if s[i] != t[i]: \n            ans.append(i)\n    val = 1 if len(ans) > 0 else 0\n    print(val)\n    if val > 0:\n        print(len(ans), end = \" \")\n    for elem in range(len(ans)):\n        print(ans[elem] + 1, end = \" \")\n    print()"
    },
    "1604B": {
        "title": "B. XOR Specia-LIS-t",
        "description": "YouKn0wWho has an integer sequence a1,a2,\u2026an. Now he will split the sequence a into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h1,h2,\u2026,hk be the lengths of the longest increasing subsequences of corresponding subarrays.\nFor example, if we split [2,5,3,1,4,3,2,2,5,1] into [2,5,3,1,4], [3,2,2,5], [1], then h=[3,2,1].\nYouKn0wWho wonders if it is possible to split the sequence a in such a way that the bitwise XOR of h1,h2,\u2026,hk is equal to 0. You have to tell whether it is possible.\nThe longest increasing subsequence (LIS) of a sequence b1,b2,\u2026,bm is the longest sequence of valid indices i1,i2,\u2026,ik such that i1<i2<\u2026<ik and bi1<bi2<\u2026<bik. For example, the LIS of [2,5,3,3,5] is [2,3,5], which has length 3.\nAn array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe first line contains a single integer t (1\u2264t\u226410000) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print \"YES\" (without quotes) if it is possible to split into subarrays in the desired way, print \"NO\" (without quotes) otherwise. You can print each letter in any register (upper or lower).\nIn the first test case, YouKn0wWho can split the sequence in the following way: [1,3,4], [2,2], [1,5]. This way, the LIS lengths are h=[3,1,2], and the bitwise XOR of the LIS lengths is 3\u22951\u22952=0.\nIn the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*1100"
        ],
        "solutions": "1604B - XOR Specia-LIS-tWhat happens if we split the sequence into subarrays of length 1?. Yes, if n is even, the bitwise XOR will be 0 as there will be an even number of 1s.If n is odd we can't do the same. But what if there is an index i such that ai\u2265ai+1?What if we use these two indices as a single subarray as it has LIS of length 1 and take other indices as single subarrays? Yeah, again, there will be an even number of 1s which will yield a bitwise XOR of 0. What we are left with are strictly increasing sequences of odd lengths. Notice that any subarray of length l has LIS of length l here. So we need to find a sequence b1,b2,\u2026,bk such that b1+b2+\u2026+bk=n and b1\u2295b2\u2295\u2026\u2295bk=0 where n is odd. Is it possible to find such a sequence? Pause and think.Hint: think about the last bit of each bi. If XOR is 0, then there will be an even number of bis such that its last bit is 1. But then the sum will be even. But here the sum n is odd, which produces a contradiction.So in the last case, it is not possible to find such a split. Code#include<bits/stdc++.h>\nusing namespace std;\n \nint main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  int t; cin >> t;\n  while (t--) {\n    int n; cin >> n;\n    vector<int> a(n + 1);\n    bool inc = true;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n      inc &= a[i] > a[i - 1];\n    }\n    if (n % 2 == 0 or !inc) {\n      cout << \"YES\\n\";\n    }\n    else {\n      cout << \"NO\\n\";\n    }\n  }\n  return 0;\n} "
    },
    "1602B": {
        "title": "B. Divine Array",
        "description": "Black is gifted with a Divine array a consisting of n (1\u2264n\u22642000) integers. Each position in a has an initial value. After shouting a curse over the array, it becomes angry and starts an unstoppable transformation.\nThe transformation consists of infinite steps. Array a changes at the i-th step in the following way: for every position j, aj becomes equal to the number of occurrences of aj in a before starting this step.\nHere is an example to help you understand the process better: \nIn the initial array, we had two 2-s, three 1-s, only one 4 and only one 3, so after the first step, each element became equal to the number of its occurrences in the initial array: all twos changed to 2, all ones changed to 3, four changed to 1 and three changed to 1.\nThe transformation steps continue forever.\nYou have to process q queries: in each query, Black is curious to know the value of ax after the k-th step of transformation.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642000)\u00a0\u2014 the size of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the initial values of array a.\nThe third line of each test case contains a single integer q (1\u2264q\u2264100000)\u00a0\u2014 the number of queries.\nNext q lines contain the information about queries\u00a0\u2014 one query per line. The i-th line contains two integers xi and ki (1\u2264xi\u2264n; 0\u2264ki\u2264109), meaning that Black is asking for the value of axi after the ki-th step of transformation. ki=0 means that Black is interested in values of the initial array.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2000 and the sum of q over all test cases doesn't exceed 100000.\nFor each test case, print q answers. The i-th of them should be the value of axi after the ki-th step of transformation. It can be shown that the answer to each query is unique.\nThe first test case was described ih the statement. It can be seen that: \nFor the second test case, \n\nIt can be seen that: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solutions": "1602B - Divine ArrayIt can be shown that after at most n steps of transformation, array a becomes repetitive. There is even a better lower bound: it can be shown that after at most log(n) steps a becomes repetitive, so we use either of these two facts to simulate the process and answer the queries. "
    },
    "1598C": {
        "title": "C. Delete Two Elements",
        "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.\u2009e. sum divided by n).\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n\u22122) elements is still equal to k.\nYour task is to calculate the number of pairs of positions [i,j] (i<j) such that if the elements on these positions are deleted, the mathematic mean of (n\u22122) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains one integer n (3\u2264n\u22642\u22c5105) \u2014 the number of elements in the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (0\u2264ai\u2264109), where ai is the i-th element of the array.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nPrint one integer \u2014 the number of pairs of positions [i,j] (i<j) such that if the elements on these positions are deleted, the mathematic mean of (n\u22122) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\nIn the first example, any pair of elements can be removed since all of them are equal.\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "math",
            "two pointers",
            "*1200"
        ],
        "solutions": "1598C - Delete Two ElementsFirst of all, instead of the mathematic mean, let's consider the sum of elements. If the mathematic mean is k, then the sum of elements of the array is k\u22c5n. Let's denote the sum of elements in the original array as s. Note s is always an integer.If we remove two elements from the array, the resulting sum of elements should become k\u22c5(n\u22122)=s\u22c5(n\u22122)n. So, the sum of the elements we remove should be exactly 2sn.If 2sn is not an integer, the answer is 0 (to check that, you can simply compare (2s)modn with 0). Otherwise, we have to find the number of pairs (i,j) such that i<j and ai+aj=2sn. This is a well-known problem.To solve it, you can calculate the number of occurrences of each element and store it in some associative data structure (for example, map in C++). Let cntx be the number of occurrences of element x. Then, you should iterate on the element ai you want to remove and check how many elements match it, that is, how many elements give exactly 2sn if you add ai to them. The number of these elements is just cnt2sn\u2212ai. Let's sum up all these values for every element in the array.Unfortunately, this sum is not the answer yet. We need to take care of two things:  if for some index i, 2\u22c5ai=2sn, then ai matches itself, so you have to subtract the number of such elements from the answer;  every pair of elements is counted twice: the first time when we consider the first element of the pair, and the second time \u2014 when we consider the second element of the pair. So, don't forget to divide the answer by 2.  Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int n;\n    scanf(\"%d\", &n);\n    vector<int> a(n);\n    map<int, int> cnt;\n    for (auto &x : a) {\n      scanf(\"%d\", &x);\n      cnt[x] += 1;\n    }\n    long long sum = accumulate(a.begin(), a.end(), 0LL);\n    if ((2 * sum) % n != 0) {\n      puts(\"0\");\n      continue;\n    }\n    long long need = (2 * sum) / n;\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n      int a1 = a[i];\n      int a2 = need - a1;\n      if (cnt.count(a2)) ans += cnt[a2];\n      if (a1 == a2) ans -= 1;\n    }\n    printf(\"%lld\\n\", ans / 2);\n  }\n}"
    },
    "1598B": {
        "title": "B. Groups",
        "description": "n students attended the first meeting of the Berland SU programming course (n is even). All students will be divided into two groups. Each group will be attending exactly one lesson each week during one of the five working days (Monday, Tuesday, Wednesday, Thursday and Friday), and the days chosen for the groups must be different. Furthermore, both groups should contain the same number of students.\nEach student has filled a survey in which they told which days of the week are convenient for them to attend a lesson, and which are not. \nYour task is to determine if it is possible to choose two different week days to schedule the lessons for the group (the first group will attend the lesson on the first chosen day, the second group will attend the lesson on the second chosen day), and divide the students into two groups, so the groups have equal sizes, and for each student, the chosen lesson day for their group is convenient.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThen the descriptions of t testcases follow.\nThe first line of each testcase contains one integer n (2\u2264n\u22641000)\u00a0\u2014 the number of students.\nThe i-th of the next n lines contains 5 integers, each of them is 0 or 1. If the j-th integer is 1, then the i-th student can attend the lessons on the j-th day of the week. If the j-th integer is 0, then the i-th student cannot attend the lessons on the j-th day of the week. \nAdditional constraints on the input: for each student, at least one of the days of the week is convenient, the total number of students over all testcases doesn't exceed 105.\nFor each testcase print an answer. If it's possible to divide the students into two groups of equal sizes and choose different days for the groups so each student can attend the lesson in the chosen day of their group, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes). \nIn the first testcase, there is a way to meet all the constraints. For example, the first group can consist of the first and the third students, they will attend the lessons on Thursday (the fourth day); the second group can consist of the second and the fourth students, and they will attend the lessons on Tuesday (the second day).\nIn the second testcase, it is impossible to divide the students into groups so they attend the lessons on different days.",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1000"
        ],
        "solutions": "1598B - GroupsIdea: fcspartakm TutorialTutorial is loading... Solution (BledDest)t = int(input())\nfor i in range(t):\n    n = int(input())\n    a = [[] for i in range(n)]\n    for j in range(n):\n        a[j] = list(map(int, input().split()))\n    ans = False\n    for j in range(5):\n        for k in range(5):\n            if k != j:\n                cnt1 = 0\n                cnt2 = 0\n                cntno = 0\n                for z in range(n):\n                    if a[z][j] == 1:\n                        cnt1 += 1\n                    if a[z][k] == 1:\n                        cnt2 += 1\n                    if a[z][j] == 0 and a[z][k] == 0:\n                        cntno += 1\n                if cnt1 >= n // 2 and cnt2 >= n // 2 and cntno == 0:\n                    ans = True\n    if ans:\n        print('YES')\n    else:\n        print('NO')"
    },
    "1594C": {
        "title": "C. Make Them Equal",
        "description": "Theofanis has a string s1s2\u2026sn and a character c. He wants to make all characters of the string equal to c using the minimum number of operations.\nIn one operation he can choose a number x (1\u2264x\u2264n) and for every position i, where i is not divisible by x, replace si with c. \nFind the minimum number of operations required to make all the characters equal to c and the x-s that he should use in his operations.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains the integer n (3\u2264n\u22643\u22c5105) and a lowercase Latin letter c\u00a0\u2014 the length of the string s and the character the resulting string should consist of.\nThe second line of each test case contains a string s of lowercase Latin letters\u00a0\u2014 the initial string.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, firstly print one integer m\u00a0\u2014 the minimum number of operations required to make all the characters equal to c.\nNext, print m integers x1,x2,\u2026,xm (1\u2264xj\u2264n)\u00a0\u2014 the x-s that should be used in the order they are given.\nIt can be proved that under given constraints, an answer always exists. If there are multiple answers, print any.\nLet's describe what happens in the third test case: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solutions": "1594C - Make Them EqualIf the whole string is equal to c then you don't need to make any operations.In order to find if it is possible with exactly 1 operation, we can pass through every x and count all the letters c that are divisible by x. This takes O(|s|log|s|) time complexity.If for some x all its multiples are c then the answer is 1 operation with that x.If all the above conditions don't hold you can always make 2 operations and make all the elements equal.One possible way is with x=|s| and x=|s|\u22121.After the first operation only the last element of s is not c thus if we use x=|s|\u22121 since gcd(|s|,|s|\u22121)=1 then |s| is not divisible by |s|\u22121 and it will become equal to c.Time complexity: O(|s|log|s|) per test case. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e9+7;\nconst ll MOD = 998244353;\ntypedef pair<ll,ll> ii;\n#define iii pair<ll,ii>\n#define f(i,a,b) for(int i = a;i < b;i++)\n#define pb push_back\n#define vll vector<ll>\n#define F first\n#define S second\n#define all(x) (x).begin(), (x).end()\nint main(void){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        ll n;\n        cin>>n;\n        char c;\n        cin>>c;\n        string s;\n        cin>>s;\n        vector<int>ans;\n        bool ok = true;\n        for(auto x:s){\n            if(x != c){\n                ok = false;\n            }\n        }\n        if(!ok){\n            f(i,1,n+1){\n                ok = true;\n                f(j,i,n+1){\n                    ok &= (s[j-1] == c);\n                    j += i-1;\n                }\n                if(ok){\n                    ans.pb(i);\n                    break;\n                }\n            }\n            if(!ok){\n                ans.pb(n);\n                ans.pb(n-1);\n            }\n        }\n        cout<<ans.size()<<\"\\n\";\n        for(auto x:ans){\n            cout<<x<<\" \";\n        }\n        cout<<\"\\n\";\n    }\n}"
    },
    "1594B": {
        "title": "B. Special Numbers",
        "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n=4 number 17 is special, because it can be written as 40+42=1+16=17, but 9 is not.\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 109+7.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (2\u2264n\u2264109; 1\u2264k\u2264109).\nFor each test case, print one integer\u00a0\u2014 the k-th special number in increasing order modulo 109+7.\nFor n=3 the sequence is [1,3,4,9...]",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "math",
            "*1100"
        ],
        "solutions": "1594B - Special Numbers HintThink of the numbers in base n. SolutionTutorial is loading... Code (C++)#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1e9+7;\nconst ll MOD = 998244353;\ntypedef pair<ll,ll> ii;\n#define iii pair<ll,ii>\n#define f(i,a,b) for(ll i = a;i < b;i++)\n#define pb push_back\n#define vll vector<ll>\n#define F first\n#define S second\n#define all(x) (x).begin(), (x).end()\nint main(void){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        ll n,k;\n        cin>>n>>k;\n        ll p = 1;\n        ll ans = 0;\n        f(j,0,31){\n            if(k & (1<<j)){\n                ans = (ans + p) % INF;\n            }\n            p *= n;\n            p %= INF;\n        }\n        cout<<ans<<\"\\n\";\n    }\n}"
    },
    "1593D1": {
        "title": "D1. All are Same",
        "description": "This problem is a simplified version of D2, but it has significant differences, so read the whole statement.\nPolycarp has an array of n (n is even) integers a1,a2,\u2026,an. Polycarp conceived of a positive integer k. After that, Polycarp began performing the following operations on the array: take an index i (1\u2264i\u2264n) and reduce the number ai by k.\nAfter Polycarp performed some (possibly zero) number of such operations, it turned out that all numbers in the array became the same. Find the maximum k at which such a situation is possible, or print \u22121 if such a number can be arbitrarily large.\nThe first line contains one integer t (1\u2264t\u226410) \u2014 the number of test cases. Then t test cases follow.\nEach test case consists of two lines. The first line contains an even integer n (4\u2264n\u226440) (n is even). The second line contains n integers a1,a2,\u2026an (\u2212106\u2264ai\u2264106).\nIt is guaranteed that the sum of all n specified in the given test cases does not exceed 100.\nFor each test case output on a separate line an integer k (k\u22651) \u2014 the maximum possible number that Polycarp used in operations on the array, or \u22121, if such a number can be arbitrarily large.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1593D1 - All are Samek can be arbitrarily large if and only if all numbers in the array are the same. In this case, we can choose any number k and subtract it from all the numbers, for example, exactly once.Suppose we fix some k. Let qi be the number of subtractions of the number k from the number ai. In this case, all numbers will be equal if and only if, for any two numbers ai and aj from the array, ai\u2212k\u22c5qi=aj\u2212k\u22c5qj. Let qi0 be the minimum of qi. Then all numbers in the array become the same if for each index i we subtract from ai k not qi, but qi\u2212qi0 times. Then we will never subtract k from the element ai0. This means that there is always an element in the array from which we can never subtract k. This element is the minimum on the array. Then from ai we will subtract k exactly ai\u2212ai0k times.Thus, with the current k, it is possible to make all elements equal if and only if for all elements ai the value ai\u2212ai0 (where ai0 is the minimum on the array) is divisible by k. So, the maximum k is the greatest common divisor of all values of ai\u2212ai0, i=1,n\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\n\t\tbool inf = true;\n\t\tint minval = a[0];\n\n\t\tfor (int i = 1; i < n; i++)\n\t\t{\n\t\t\tif (a[i] != a[0])\n\t\t\t{\n\t\t\t\tinf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tminval = min(minval, a[i]);\n\t\t}\n\n\t\tif (inf)\n\t\t{\n\t\t\tcout << \"-1\\n\";\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(a.begin(), a.end());\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tans = gcd(ans, a[i] - minval);\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    },
    "1593C": {
        "title": "C. Save More Mice",
        "description": "There are one cat, k mice, and one hole on a coordinate line. The cat is located at the point 0, the hole is located at the point n. All mice are located between the cat and the hole: the i-th mouse is located at the point xi (0<xi<n). At each point, many mice can be located.\nIn one second, the following happens. First, exactly one mouse moves to the right by 1. If the mouse reaches the hole, it hides (i.e. the mouse will not any more move to any point and will not be eaten by the cat). Then (after that the mouse has finished its move) the cat moves to the right by 1. If at the new cat's position, some mice are located, the cat eats them (they will not be able to move after that). The actions are performed until any mouse hasn't been hidden or isn't eaten.\nIn other words, the first move is made by a mouse. If the mouse has reached the hole, it's saved. Then the cat makes a move. The cat eats the mice located at the pointed the cat has reached (if the cat has reached the hole, it eats nobody).\nEach second, you can select a mouse that will make a move. What is the maximum number of mice that can reach the hole without being eaten?\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then t test cases follow.\nEach test case consists of two lines. The first line contains two integers n and k (2\u2264n\u2264109, 1\u2264k\u22644\u22c5105). The second line contains k integers x1,x2,\u2026xk (1\u2264xi<n) \u2014 the initial coordinates of the mice.\nIt is guaranteed that the sum of all k given in the input doesn't exceed 4\u22c5105.\nFor each test case output on a separate line an integer m (m\u22650) \u2014 the maximum number of mice that can reach the hole without being eaten.",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "greedy",
            "*1000"
        ],
        "solutions": "1593C - Save More MiceIdea: ITMO student team TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\n\twhile (t--)\n\t{\n\t\tint n, k;\n\t\tcin >> n >> k;\n\n\t\tvector<int> x(k);\n\t\tfor (int i = 0; i < k; i++) cin >> x[i];\n\t\tsort(x.rbegin(), x.rend());\n\n\t\tint cnt = 0;\n\t\tlong long sum = 0;\n\n\t\twhile (cnt < x.size() && sum + n - x[cnt] < n)\n\t\t{\n\t\t\tsum += n - x[cnt++];\n\t\t}\n\n\t\tcout << cnt << '\\n';\n\t}\n\n\treturn 0;\n}\n"
    },
    "1592B": {
        "title": "B. Hemose Shopping",
        "description": "Hemose was shopping with his friends Samez, AhmedZ, AshrafEzz, TheSawan and O_E in Germany. As you know, Hemose and his friends are problem solvers, so they are very clever. Therefore, they will go to all discount markets in Germany.\nHemose has an array of n integers. He wants Samez to sort the array in the non-decreasing order. Since it would be a too easy problem for Samez, Hemose allows Samez to use only the following operation:\nChoose indices i and j such that 1\u2264i,j\u2264n, and |i\u2212j|\u2265x. Then, swap elements ai and aj.\nCan you tell Samez if there's a way to sort the array in the non-decreasing order by using the operation written above some finite number of times (possibly 0)?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). Description of the test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264x\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,...,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, you should output a single string. \nIf Samez can sort the array in non-decreasing order using the operation written above, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\nIn the first test case, you can't do any operations.\nIn the second test case, the array is already sorted.\nIn the third test case, you can do the operations as follows: \n(Here swap(ai,aj) refers to swapping elements at positions i, j).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dsu",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1592B - Hemose ShoppingThe answer is always \"YES\" If n\u22652\u2217x because you can reorder the array as you want.Otherwise, You can swap the first n\u2212x elements and the last n\u2212x elements, so you can reorder them as you want but the rest have to stay in their positions in the sorted array.So if elements in the subarray [n\u2212x+1,x] in the original array are in their same position after sorting the array then the answer is YES, otherwise NO. "
    },
    "1584B": {
        "title": "B. Coloring Rectangles",
        "description": "David was given a red checkered rectangle of size n\u00d7m. But he doesn't like it. So David cuts the original or any other rectangle piece obtained during the cutting into two new pieces along the grid lines. He can do this operation as many times as he wants.\nAs a result, he will get a set of rectangles. Rectangles 1\u00d71 are forbidden.\nDavid also knows how to paint the cells blue. He wants each rectangle from the resulting set of pieces to be colored such that any pair of adjacent cells by side (from the same piece) have different colors.\nWhat is the minimum number of cells David will have to paint?\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The next lines contain descriptions of test cases.\nThe only line of each test case contains two integers n, m (1\u2264n,m\u22643\u22c5104, n\u22c5m\u22652).\nFor each test case print a single integer \u2014 the minimum number of cells David will have to paint blue.\nThe following pictures show how the initial rectangle can be split and cells colored blue.\nIn the first test case:\nIn the second test case:\nIn the third test case:\nIn the fourth test case:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1584B - Coloring RectanglesRectangles after cutting will be painted in a chess coloring. So, if the area is even, then the number of cells of different colors is the same, and if it is odd, then it differs by exactly 1.Let's find out what part the colored cells occupy in relation to all of them. For an even area, this ratio is always 12. For odd S\u221212\u22c5S. The smaller the odd area, the smaller the ratio. An area equal to 1 cannot be obtained, so the best ratio is 13 and is achieved with an area equal to 3.Then we get the lower estimate for the answer: answer\u2265n\u22c5m\u22c513. Great!We know that the answer is integer, so if we manage to construct such a cut that it is necessary to color exactly such a cnt of cells thatn\u22c5m3\u2264cnt<n\u22c5m3+1, then cnt will be the answer. After all, cnt is the minimum integer value satisfying the estimate.If one of the sides is divisible by 3, then it is obvious how to cut into 1\u00d73 rectangles and get the perfect answer.If the remains of sides 1 and 1 or 2 and 2, then you can cut into 1\u00d73 rectangles and one rectangle with an area of 4, in which you need to paint over 2 cells. Then the answer also fits the assessment.If the remains of sides 1 and 2, then after cutting into 1\u00d73 rectangles, a rectangle will remain 1\u00d72, in which you need to paint one cell. The answer also fits the assessment.For all pairs of remains, there is a way to construct an answer satisfying the inequality. Therefore, the answer is \u2308n\u22c5m3\u2309 "
    },
    "1583B": {
        "title": "B. Omkar and Heavenly Tree",
        "description": "Lord Omkar would like to have a tree with n nodes (3\u2264n\u2264105) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1\u2264m<n) restrictions to ensure that the tree will be as heavenly as possible. \nA tree with n nodes is an connected undirected graph with n nodes and n\u22121 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\nHere is an example of a tree: \nA restriction consists of 3 pairwise distinct integers, a, b, and c (1\u2264a,b,c\u2264n). It signifies that node b cannot lie on the simple path between node a and node c. \nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains two integers, n and m (3\u2264n\u2264105, 1\u2264m<n), representing the size of the tree and the number of restrictions.\nThe i-th of the next m lines contains three integers ai, bi, ci (1\u2264ai,bi,ci\u2264n, a, b, c are distinct), signifying that node bi cannot lie on the simple path between nodes ai and ci. \nIt is guaranteed that the sum of n across all test cases will not exceed 105.\nFor each test case, output n\u22121 lines representing the n\u22121 edges in the tree. On each line, output two integers u and v (1\u2264u,v\u2264n, u\u2260v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\nThe output of the first sample case corresponds to the following tree: \nThe output of the second sample case corresponds to the following tree: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "trees",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1582C": {
        "title": "C. Grandma Capa Knits a Scarf",
        "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The next 2\u22c5t lines contain the description of test cases. The description of each test case consists of two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the string.\nThe second line of each test case contains the string s consisting of n lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and \u22121, if it is impossible.\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "strings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1582C - Grandma Capa Knits a ScarfLet's iterate over the letter that we will erase from the string (from 'a' to 'z'), and for each letter independently find the minimal number of erased symbols required to make the string a palindrome.Let's say we are currently considering a letter c. Let's use the two pointers method: we will maintain two pointers l, r, initially l points at the beginning of the string, and r points at the end of the string. Now we will form a palindrome: each time we will compare sl and sr, if they are equal, then we can add both of them to the palindrome at corresponding positions and iterate to symbols l+1 and r\u22121. If sl\u2260sr, then we need to erase one of these symbols (otherwise, we won't get a palindrome), if sl=c, let's erase it (we'll add to the number of erased symbols 1 and iterate to l+1-th symbol), similarly, if sr=c, we'll add to the number of the erased symbols 1 and iterate to r\u22121-th symbol. And the last case, if sl\u2260c and sr\u2260c, then it's impossible to get a palindrome from s by erasing only letters equal to c.The asymptotic behaviour of this solution is O(|C|\u22c5n), where |C| is the size of the alphabet, i.e. 26. Solution (74TrAkToR)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> n >> s;\n        int ans = n + 1;\n        for (int c = 0; c < 26; ++c) {\n            int l = 0, r = n - 1, cnt = 0;\n            while (l <= r) {\n                if (s[l] == s[r]) {\n                    l++, r--;\n                }\n                else if (s[l] == char('a' + c)) {\n                    cnt++, l++;\n                }\n                else if (s[r] == char('a' + c)) {\n                    cnt++, r--;\n                }\n                else {\n                    cnt = n + 1;\n                    break;\n                }\n            }\n            ans = min(ans, cnt);\n        }\n        if (ans == n + 1) ans = -1;\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n"
    },
    "1581B": {
        "title": "B. Diameter of Graph",
        "description": "CQXYM wants to create a connected undirected graph with n nodes and m edges, and the diameter of the graph must be strictly less than k\u22121. Also, CQXYM doesn't want a graph that contains self-loops or multiple edges (i.e. each edge connects two different vertices and between each pair of vertices there is at most one edge).\nThe diameter of a graph is the maximum distance between any two nodes.\nThe distance between two nodes is the minimum number of the edges on the path which endpoints are the two nodes.\nCQXYM wonders whether it is possible to create such a graph.\nThe input consists of multiple test cases. \nThe first line contains an integer t(1\u2264t\u2264105) \u2014 the number of test cases. The description of the test cases follows.\nOnly one line of each test case contains three integers n(1\u2264n\u2264109), m, k (0\u2264m,k\u2264109).\nFor each test case, print YES if it is possible to create the graph, or print NO if it is impossible. You can print each letter in any case (upper or lower).\nIn the first test case, the graph's diameter equal to 0.\nIn the second test case, the graph's diameter can only be 2.\nIn the third test case, the graph's diameter can only be 1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1581B - Diameter of Graphidea: CQXYMpreparation: CQXYMtutorial: CQXYMIf m<n\u22121, the graph can't be connected, so the answer should be No.If m>n(n\u22121)2, the graph must contaion multiedges, so the answer should be No.If m=n(n\u22121)2, the graph must be a complete graph. The diameter of the graph is 1. If k>2 the answer is YES, otherwise the answer is NO.If n=1, the graph has only one node, and its diameter is 0. If k>1 the answer is YES, otherwise the answer is NO.If m=n\u22121, the graph must be a tree, the diameter of the tree is at least 2 when it comes to each node has an edge with node 1. If m>n\u22121\u2227m<n(n\u22121)2, we can add edges on the current tree and the diameter wouldn't be more than 2. Since the graph is not complete graph, the diameter is more than 1, the diameter is just 2. If k>3 the answer is YES, otherwise the answer is NO.The time complexity is O(t).  solution#include<stdio.h>\ninline void Solve(){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tif((n-1ll)*n>>1<m||m<n-1){\n\t\tputs(\"NO\");\n\t\treturn;\n\t}\n\tif(n==1){\n\t\tif(k>1){\n\t\t\tputs(\"YES\");\n\t\t}else{\n\t\t\tputs(\"NO\");\n\t\t}\n\t}else if(m<(n-1ll)*n>>1){\n\t\tif(k>3){\n\t\t\tputs(\"YES\");\n\t\t}else{\n\t\t\tputs(\"NO\");\n\t\t}\n\t}else if(k>2){\n\t\tputs(\"YES\");\n\t}else{\n\t\tputs(\"NO\");\n\t}\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\tfor(register int i=0;i!=t;i++){\n\t\tSolve();\n\t}\n\treturn 0;\n}"
    },
    "1579E1": {
        "title": "E1. Permutation Minimization by Deque",
        "description": "In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.\nA permutation p of size n is given. A permutation of size n is an array of size n in which each integer from 1 to n occurs exactly once. For example, [1,4,3,2] and [4,2,1,3] are correct permutations while [1,2,4] and [1,2,2] are not.\nLet us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [1,5,2] currently in the deque, adding an element 4 to the beginning will produce the sequence [4,1,5,2], and adding same element to the end will produce [1,5,2,4].\nThe elements of the permutation are sequentially added to the initially empty deque, starting with p1 and finishing with pn. Before adding each element to the deque, you may choose whether to add it to the beginning or the end.\nFor example, if we consider a permutation p=[3,1,2,4], one of the possible sequences of actions looks like this: \n\nFind the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed. \nA sequence [x1,x2,\u2026,xn] is lexicographically smaller than the sequence [y1,y2,\u2026,yn] if there exists such i\u2264n that x1=y1, x2=y2, \u2026, xi\u22121=yi\u22121 and xi<yi. In other words, if the sequences x and y have some (possibly empty) matching prefix, and the next element of the sequence x is strictly smaller than the corresponding element of the sequence y. For example, the sequence [1,3,2,4] is smaller than the sequence [1,3,4,2] because after the two matching elements [1,3] in the start the first sequence has an element 2 which is smaller than the corresponding element 4 in the second sequence.\nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain descriptions of the test cases. \nThe first line of each test case description contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 permutation size. The second line of the description contains n space-separated integers pi (1\u2264pi\u2264n; all pi are all unique)\u00a0\u2014 elements of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should contain n space-separated integer numbers\u00a0\u2014 the elements of the lexicographically smallest permutation that is possible to find in the deque after executing the described algorithm.\nOne of the ways to get a lexicographically smallest permutation [1,3,2,4] from the permutation [3,1,2,4] (the first sample test case) is described in the problem statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1579E1 - Permutation Minimization by DequeIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, a;\n        cin >> n;\n        deque<int> d;\n        for (int i = 0; i < n; i++) {\n            cin >> a;\n            if (d.empty() || a < d[0])\n                d.push_front(a);\n            else\n                d.push_back(a);\n        }\n        for (int x : d)\n            cout << x << ' ';\n        cout << '\\n';\n    }\n}"
    },
    "1579B": {
        "title": "B. Shifting Sort",
        "description": "The new generation external memory contains an array of integers a[1\u2026n]=[a1,a2,\u2026,an].\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\nTechnically, each cyclic shift consists of two consecutive actions: \nFor example, if a=[1,3,2,8,5], then choosing l=2, r=4 and d=2 yields a segment a[2\u20264]=[3,2,8]. This segment is then shifted by the offset d=2 to the left, and you get a segment [8,3,2] which then takes the place of of the original elements of the segment. In the end you get a=[1,8,3,2,5].\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain the descriptions of the test cases. \nThe first line of each test case description contains an integer n (2\u2264n\u226450)\u00a0\u2014 the length of the array. The second line consists of space-separated elements of the array ai (\u2212109\u2264ai\u2264109). Elements of array a may repeat and don't have to be unique.\nPrint t answers to all input test cases. \nThe first line of the answer of each test case should contain an integer k (0\u2264k\u2264n)\u00a0\u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l\u00a0r\u00a0d\" (without quotes) where l and r (1\u2264l<r\u2264n) are the boundaries of the segment being shifted, while d (1\u2264d\u2264r\u2212l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\nIf the given array a is already sorted, one of the possible answers is k=0 and an empty sequence of cyclic shifts.\nIf there are several possible answers, you may print any of them.\nExplanation of the fourth data set in the example: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1579B - Shifting SortIdea: doreshnikov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        vector<pii> actions;\n        for (int i = 0; i < n; i++)\n            cin >> a[i];\n\n        for (int i = 0; i < n - 1; i++) {\n            int min_pos = i;\n            for (int j = i + 1; j < n; j++)\n                if (a[j] < a[min_pos])\n                    min_pos = j;\n\n            if (min_pos > i) {\n                actions.push_back({i, min_pos});\n                int opt = a[min_pos];\n                for (int j = min_pos; j > i; j--)\n                    a[j] = a[j - 1];\n                a[i] = opt;\n            }\n        }\n\n        cout << actions.size() << '\\n';\n        for (auto &lr: actions) {\n            cout << lr.first + 1 << ' ' << lr.second + 1 << ' ' << lr.second - lr.first << '\\n';\n        }\n    }\n\n}"
    },
    "1578E": {
        "title": "E. Easy Scheduling",
        "description": "Eonathan Eostar decided to learn the magic of multiprocessor systems. He has a full binary tree of tasks with height h. In the beginning, there is only one ready task in the tree\u00a0\u2014 the task in the root. At each moment of time, p processes choose at most p ready tasks and perform them. After that, tasks whose parents were performed become ready for the next moment of time. Once the task becomes ready, it stays ready until it is performed. \nYou shall calculate the smallest number of time moments the system needs to perform all the tasks.\nThe first line of the input contains the number of tests t (1\u2264t\u22645\u22c5105). Each of the next t lines contains the description of a test. A test is described by two integers h (1\u2264h\u226450) and p (1\u2264p\u2264104)\u00a0\u2014 the height of the full binary tree and the number of processes. It is guaranteed that all the tests are different.\nFor each test output one integer on a separate line\u00a0\u2014 the smallest number of time moments the system needs to perform all the tasks.\nLet us consider the second test from the sample input. There is a full binary tree of height 3 and there are two processes. At the first moment of time, there is only one ready task, 1, and p1 performs it. At the second moment of time, there are two ready tasks, 2 and 3, and the processes perform them. At the third moment of time, there are four ready tasks, 4, 5, 6, and 7, and p1 performs 6 and p2 performs 5. At the fourth moment of time, there are two ready tasks, 4 and 7, and the processes perform them. Thus, the system spends 4 moments of time to perform all the tasks.\n",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test1024 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1575A": {
        "title": "A. Another Sorting Problem",
        "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string si numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\nThe first line contains two integers n and m (1\u2264n\u22c5m\u2264106).\nThe i-th of the next n lines contains a string si consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\nThe following illustrates the first example.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "data structures",
            "sortings",
            "strings",
            "*1100"
        ],
        "solutions": "1575A. Another Sorting ProblemAuthor: hockyDeveloper: richiesenliaEditorialist: hocky IdeaObserve that the even-indexed character of the string can be transformed from A-Z to Z-A. E.g. for the first example:  AA \u2192 AZ AB \u2192 AY BB \u2192 BY BA \u2192 BZ AZ \u2192 AA Now, you can use any known algorithms to sort the string as usual. You can sort it in linear time with trie, or std::sort in O(nmlogn) time.Time Complexity : O(nm) or O(nmlogn)"
    },
    "1574B": {
        "title": "B. Combinatorics Homework",
        "description": "You are given four integer values a, b, c and m.\nCheck if there exists a string that contains: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nEach of the next t lines contains the description of the testcase\u00a0\u2014 four integers a, b, c and m (1\u2264a,b,c\u2264108; 0\u2264m\u2264108).\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1574B - Combinatorics HomeworkLet's start with a simple assumption. For some fixed values a,b,c, the values of m that the answers exist for, make up a range. So there's the smallest possible number of adjacent equal pairs one can construct and the largest one\u00a0\u2014 everything in-between exists as well.The largest number is simple\u00a0\u2014 put all A's, then all B's, then all C's. So this value is (a\u22121)+(b\u22121)+(c\u22121).The smallest number is trickier. Let's instead investigate when it's equal to 0. WLOG, assume a\u2264b\u2264c. Imagine the following construction. There are c letters C which separate blocks of letters A and B. There are c\u22121 (c+1 if you consider the ones to the sides of all letters C, but we want the smallest value, so we shouldn't consider them) such blocks, thus it's possible that each block contains no more than one letter A and no more than one letter B. So letters A and B will never produce adjacent pairs.If there are empty blocks, then there are adjacent letters C. So the condition to still have no empty blocks is to have at least c\u22121 letters A and B in total. If c\u22121>a+b, then any extra letter C can only be put adjacent to another letter C, thus producing an extra pair (at least one extra pair, but since we are examining the lower bound, we can always do exactly one). That means that the lower bound is c\u22121\u2212(a+b).Now for the proof of the fact that every value in-between is also achievable. Since we have a construction for m=0, let's try modifying it. Let's reduce the test to m=0 the following way. While m>0, decrease the count of the letter that appears the most by 1 and decrease m by 1. Now build the string for m=0 with the reduced values. After that put the letters back, placing them next to the last occurrence of the same letter (there is at least one occurrence of each letter, the proof is trivial). That increases m by 1 and the count of this letter by 1. Thus, we'll return to the initial test.Overall complexity: O(1) per testcase. Solution (awoo)for _ in range(int(input())):\n\ta, b, c, m = map(int, input().split())\n\ta, b, c = sorted([a, b, c])\n\tprint(\"YES\" if c - (a + b + 1) <= m <= a + b + c - 3 else \"NO\")"
    },
    "1569B": {
        "title": "B. Chess Tournament",
        "description": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\nEach of the players has their own expectations about the tournament, they can be one of two types:\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\nThe first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (2\u2264n\u226450)\u00a0\u2014 the number of chess players.\nThe second line contains the string s (|s|=n; si\u2208{1,2}). If si=1, then the i-th player has expectations of the first type, otherwise of the second type.\nFor each test case, print the answer in the following format:\nIn the first line, print NO if it is impossible to meet the expectations of all players.\nOtherwise, print YES, and the matrix of size n\u00d7n in the next n lines.\nThe matrix element in the i-th row and j-th column should be equal to:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1569B - Chess TournamentSince the chess players of the first type should not lose a single game, each game between two chess players of the first type should end in a draw (so that none of them gets defeated). And a game between a chess player of the first type and the second type should end either with a victory of the first or a draw. Therefore, for convenience, we will say that all games with a chess player of the first type end in a draw.Now there are only games between chess players of the second type left. If there are only 1 or 2 such players, then there is no answer. Otherwise, we can choose the following method: the i-th chess player of the second type wins against the i+1-th chess player of the second type, and the last one wins against the first; all remaining games are drawn. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); \n  int t;\n  cin >> t;\n  while (t--) {\n    int n;\n    string s;\n    cin >> n >> s;\n    vector<int> id;\n    for (int i = 0; i < n; ++i) if (s[i] == '2')\n      id.push_back(i);\n    int k = id.size();\n    if (k == 1 || k == 2) {\n      cout << \"NO\\n\";\n      continue;\n    }\n    vector<string> t(n, string(n, '='));\n    for (int i = 0; i < n; ++i) t[i][i] = 'X';\n    for (int i = 0; i < k; ++i) {\n      int x = id[i], y = id[(i + 1) % k];\n      t[x][y] = '+';\n      t[y][x] = '-';\n    }\n    cout << \"YES\\n\";\n    for (int i = 0; i < n; ++i) cout << t[i] << '\\n';\n  }\n}"
    },
    "1567B": {
        "title": "B. MEXor Mixup",
        "description": "Alice gave Bob two integers a and b (a>0 and b\u22650). Being a curious boy, Bob wrote down an array of non-negative integers with MEX value of all elements equal to a and XOR value of all elements equal to b.\nWhat is the shortest possible length of the array Bob wrote?\nRecall that the MEX (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the XOR of an array is the bitwise XOR of all the elements of the array.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22645\u22c5104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers a and b (1\u2264a\u22643\u22c5105; 0\u2264b\u22643\u22c5105)\u00a0\u2014 the MEX and XOR of the array, respectively.\nFor each test case, output one (positive) integer\u00a0\u2014 the length of the shortest array with MEX a and XOR b. We can show that such an array always exists.\nIn the first test case, one of the shortest arrays with MEX 1 and XOR 1 is [0,2020,2021].\nIn the second test case, one of the shortest arrays with MEX 2 and XOR 1 is [0,1].\nIt can be shown that these arrays are the shortest arrays possible.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1000"
        ],
        "solutions": "1567B - MEXor MixupFirst consider the MEX condition: the shortest array with MEX a is the array [0,1,\u2026,a\u22121], which has length a. Now we'll consider the XOR condition. Let the XOR of the array [0,1,\u2026,a\u22121] be x. We have three cases.Case 1: x=b. Then we don't need to add any elements to the array, so the answer is a.Case 2: x\u2260b and x\u2295b\u2260a. Then we can add the element x\u2295b to the array since x\u2295b\u2260a, so the MEX will still be a. The XOR of the array will then be x\u2295x\u2295b=b. The answer is a+1.Case 3: x\u2260b and x\u2295b=a. Then we cannot add the element x\u2295b to the end of the array. We can just add x\u2295b\u22951 and 1, so the XOR of the array will be x\u2295x\u2295b\u22951\u22951=b. The answer is a+2.Time complexity: O(n) precomputation and O(1) per test case if you precalculate the XOR of the numbers from 0 to n\u22121, or O(1) if you use the well-known formula for it. Implementation (C++)127991329 Video SolutionLink to Video"
    },
    "1566D1": {
        "title": "D1. Seating Arrangements (easy version)",
        "description": "It is the easy version of the problem. The only difference is that in this version n=1.\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m(k\u22121)+1 to mk for all rows 1\u2264k\u2264n.\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight ai. Let's define si as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that ai<aj it should be satisfied that si<sj.\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\nLet's consider an example: m=5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n and m (n=1, 1\u2264m\u2264300)\u00a0\u2014 the number of rows and places in each row respectively.\nThe second line of each test case contains n\u22c5m integers a1,a2,\u2026,an\u22c5m (1\u2264ai\u2264109), where ai is the sight level of i-th person.\nIt's guaranteed that the sum of n\u22c5m over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the minimal total inconvenience that can be achieved.\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0+1+2=3.\nIn the second test case, people should sit as follows: s1=2, s2=1, s3=5, s4=4, s5=3. The total inconvenience will be 6.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1566C": {
        "title": "C. MAX-MEX Cut",
        "description": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\nLet MEX of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, MEX for [00111010] is 2, because 0 and 1 occur in the bi-table at least once. MEX for [111111] is 0, because 0 and 2 do not occur in the bi-table, and 0<2.\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\nWhat is the maximal sum of MEX of all resulting bi-tables can be?\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of the description of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of columns in the bi-table.\nEach of the next two lines contains a binary string of length n\u00a0\u2014 the rows of the bi-table.\nIt's guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the maximal sum of MEX of all bi-tables that it is possible to get by cutting the given bi-table optimally.\nIn the first test case you can cut the bi-table as follows:\nThe sum of MEX is 8.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "greedy",
            "*1000"
        ],
        "solutions": "1566C - MAX-MEX Cut First solutionHint 1You can cut out the columns with both 0 and 1. Hint 2Now in each column there are only 0 or only 1. We only need to solve the problem for a string because the columns can be replaced by one digit (they consist of equal elements). Hint 3Let's be greedy, to each zero we will \"join\" not more than one 1. EditorialLet's solve the same problem but for a string:It's needed to cut a binary string into segments so that each its element is in exactly one segment and the sum of MEX for all segments is maximal.Initially we will say that the string is cut into segments of length 1. Then the answer is the number of zeroes in the string. After that the answer is increased every time we merge a segment of 0 with a segment of 1. Each such merge increases the answer by 1. Let's make the merges greedily, maximizing the number of merges. Let's consider the first zero. If the previous element is a 1, let's merge them and consider the next zero. Else, if the next element is a 1, let's merge them and consider the next zero. Else, the next element is a zero and we should consider it instead of the current zero the same way. By doing so we get the answer as the number of zeroes + the number of merges.Now let's solve the initial problem. We can cut out the columns that contain both 0 and 1, because their MEX is already maximized and the answer will not become worse.Now we solve the problem for all remaining bi-tables independently. Each their column consists either only of 0 or only of 1 so both rows are equal. We will solve the problem for one row of each remaining bi-table as mentioned before and then sum up the values to get the answer. Implementation (C++, shishin)#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(string s) {\n    int ans = count(s.begin(), s.end(), '0');\n    int n = s.size();\n    bool a = false, b = false;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '0') a = true;\n        if (s[i] == '1') b = true;\n        if (a && b) {\n            ++ans;\n            a = b = false;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T --> 0) {\n        int n, ans = 0;\n        string a, b;\n        cin >> n >> a >> b;\n        string s = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (a[i] != b[i]) {\n                ans += 2 + solve(s);\n                s = \"\";\n            } else {\n                s += a[i];\n            }\n        }\n        cout << ans + solve(s) << '\\n';\n    }\n    return 0;\n} Second solution (two similar solutions)This problem could be solved in many ways using the dp. We will consider these solutions in short.Let's say that dpi \u2014 is the answer for a prefix until i. Then there are different approaches:We can calculate the dp values, iterating through all possible MEX values on the last segment. For example, if we want to make MEX equal 2 on the last segment, then we need to find the closest 0 and the closest 1 to position i. Let it be last0 and last1. Then we should recalc the dp like this dpi=max(dpi,dpj\u22121+2), where j=min(last0,last1), because we take the shortest segment ending in i which has both 0 and 1 and after that we add the answer for this segment and for prefix that ends in j\u22121. Implementation(C++, kpw29)#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define rep(i, l, r) for(int i = (l); i < (r); ++i)\ntypedef vector<int> vi;\n\n//Did you REAALLY consider sample tests?\nvoid solve(int tc) {\n    string s[2];\n    int n;\n    cin >> n;\n    cin >> s[0] >> s[1];\n    vi dp(n + 1, 0);\n    vi last(2, -1);\n    \n    auto take = [&](int i, bool take0, bool take1) {\n        int MEX = 0;\n        if (take0) {\n            if (take1) MEX = 2;\n            else MEX = 1;\n        }\n        \n        int index = i;\n        if (take0) index = min(index, last[0]);\n        if (take1) index = min(index, last[1]);\n        \n        if (index != -1) return MEX + dp[index - 1];\n        return -100000;\n    };\n    \n    FOR(i, 1, n) {\n        vi val(2);\n        rep(j, 0, 2) last[s[j][i-1] - '0'] = i;\n        dp[i] = dp[i-1];\n        dp[i] = max(dp[i], take(i, 1, 0));\n        dp[i] = max(dp[i], take(i, 0, 1));\n        dp[i] = max(dp[i], take(i, 1, 1));\n    }\n    \n    cout << dp[n] << \"\\n\";\n}\n \nint main() {\n    int tests;\n    cin >> tests;\n    FOR(test, 1, tests) {\n        solve(test);\n    }\n}Another possible solution with dp is based on the fact that we should not take any segments with length more than x, where x is some small number. We can just take some random big enough x and not prove anything. There exists a solution which does not consider segments with length bigger than 5. Implementation (C++, physics0523)#include<bits/stdc++.h>\n \nusing namespace std;\n \nint mex(string s){\n  int fl=0;\n  for(auto &nx : s){\n    if(nx=='0'){fl|=1;}\n    else if(nx=='1'){fl|=2;}\n  }\n  if(fl==3){return 2;}\n  if(fl==1){return 1;}\n  return 0;\n}\n \nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  while(t>0){\n    t--;\n    int n;\n    string s1,s2;\n    cin >> n >> s1 >> s2;\n    vector<int> dp(n+1,0);\n    for(int i=0;i<n;i++){\n      string s;\n      for(int j=0;j<5;j++){\n        if(i+j>=n){break;}\n        s.push_back(s1[i+j]);\n        s.push_back(s2[i+j]);\n        dp[i+j+1]=max(dp[i+j+1],dp[i]+mex(s));\n      }\n    }\n    cout << dp[n] << '\\n';\n  }\n  return 0;\n} D: Seating Arrangements"
    },
    "1562B": {
        "title": "B. Scenes From a Memory",
        "description": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\nNote that you cannot remove all the digits from the number.\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\nEach test contains multiple test cases.\nThe first line contains one positive integer t (1\u2264t\u2264103), denoting the number of test cases. Description of the test cases follows.\nThe first line of each test case contains one positive integer k (1\u2264k\u226450)\u00a0\u2014 the number of digits in the number.\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10k\u22121\u2264n<10k). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\nIt is guaranteed that the sum of k over all test cases does not exceed 104.\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \nIf there are multiple solutions, print any.\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27=33.\nIn the second test case, you can delete all digits except one, as 4=22 is a composite number.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1562B - Scenes From a MemoryLet's show that if a number has three digits, you can always remove at least one from it to get a number that is not prime. This can be proved by a simple brute-force search of all numbers with three digits, but we'll try to do it without a brute-force search.In fact, if a number contains the digits '1', '4', '6', '8' or '9', then that one digit is the answer, because 1, 4, 6, 8 and 9 are not prime numbers.Now let's see what happens if the number doesn't have those digits. Then, if the number has two identical digits, we have found an answer of size two\u00a0\u2014 the number of two identical digits (22, 33, 55, or 77) is divisible by 11. Also, if the digits 2 or 5 are not at the beginning of the number, we again have found an answer of size two\u00a0\u2014 the number of two digits ending in 2 or 5 is not prime.If none of the above cases worked, then we find that a three-digit number has one of the following values: 237, 273, 537, 573. It is not difficult to see that these numbers have two digits, which form a number, that is divisible by three.Thus, the maximum answer is two, that is, you can leave no more than two digits in the number. You can find these digits by considering the above cases, or you can just try.It can be shown that such a brute-force solution will work for O(k).Asymptotics: O(k) per test case. Code C++ (Wind_Eagle)#include <iostream>\n\nusing namespace std;\n\nint n;\n\nstring s;\n\nbool prime[100];\n\nvoid solve() {\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1' || s[i] == '4' || s[i] == '6' || s[i] == '8' || s[i] == '9') {\n            cout << 1 << endl;\n            cout << s[i] << endl;\n            return;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (!prime[(s[i] - '0') * 10 + (s[j] - '0')]) {\n                cout << 2 << endl;\n                cout << s[i] << s[j] << endl;\n                return;\n            }\n        }\n    }\n    exit(42);\n}\n\nint main() {\n    for (int i = 2; i < 100; i++) {\n        prime[i] = true;\n        for (int j = 2; j * j <= i; j++) {\n            if (i % j == 0) {\n                prime[i] = false;\n            }\n        }\n    }\n    int t;\n    cin >> t;\n    while (t--) {\n        cin >> n;\n        cin >> s;\n        solve();\n    }\n} Additional Problem 1Try to prove that the author's solution works for O(k) for one test case. Solution of Additional Problem 1Finding an answer consisting of one digit works in O(k). Now let's see how long the loop takes to complete. Indeed, it is easy to see that once the pairs of indexes (0,1), (0,2), and (1,2) are considered, an answer will always be found. This is so because in any number of three digits you can find an answer consisting of two digits (this was proved earlier). So this is equivalent to removing all but the first three digits, and then solving the problem for them (assuming that the length of the optimal answer is two). Additional Problem 2Try to think of a way to search index pairs and a test such that this search works for O(k2) per test case. Solution of Additional Problem 2Let's take the string \\t{3737 \\ldots 37} as a string. We will search pairs of indices in the following way: first we will search all pairs of indices with different parities, and then all pairs of indices with the same parity. It is easy to see that such a search will work for O(k2) for one test case, because all pairs of indices with different parity will give numbers 37 and 73, which are prime, and there are O(k2) such pairs."
    },
    "1559C": {
        "title": "C. Mocha and Hiking",
        "description": "The city where Mocha lives in is called Zhijiang. There are n+1 villages and 2n\u22121 directed roads in this city. \nThere are two kinds of roads:\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \nEach test contains multiple test cases. \nThe first line contains a single integer t (1\u2264t\u226420) \u2014 the number of test cases. Each test case consists of two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u2264104) \u2014 indicates that the number of villages is n+1.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u22641). If ai=0, it means that there is a road from village i to village n+1. If ai=1, it means that there is a road from village n+1 to village i.\nIt is guaranteed that the sum of n over all test cases does not exceed 104.\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print \u22121.\nIf there are multiple correct answers, you can print any one of them.\nIn the first test case, the city looks like the following graph:\n\nSo all possible answers are (1\u21924\u21922\u21923), (1\u21922\u21923\u21924).\nIn the second test case, the city looks like the following graph:\n\nSo all possible answers are (4\u21921\u21922\u21923), (1\u21922\u21923\u21924), (3\u21924\u21921\u21922), (2\u21923\u21924\u21921).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "*1200"
        ],
        "solutions": "1559C - Mocha and HikingIf a1=1, then the path [(n+1)\u21921\u21922\u2192\u22ef\u2192n] is valid.If an=0, then the path [1\u21922\u2192\u22ef\u2192n\u2192(n+1)] is valid.Otherwise, since a1=0\u2227an=1, there must exists an integer i (1\u2264i<n) where ai=0\u2227ai+1=1, then the path [1\u21922\u2192\u22ef\u2192i\u2192(n+1)\u2192(i+1)\u2192(i+2)\u2192\u22efn] is valid.This is a step to prove that there always exists an Hamiltonian path in a tournament graph. solution#include <bits/stdc++.h>\n#define maxn 100086\n\nusing namespace std;\n\nint t, n;\nint a[maxn];\n\nvoid solve(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i++) scanf(\"%d\", &a[i]);\n\tif(a[1]){\n\t\tprintf(\"%d \", n + 1);\n\t\tfor(int i = 1;i <= n;i++) printf(\"%d \", i);\n\t\treturn;\n\t}\n\tfor(int i = 1;i < n;i++){\n\t\tif(!a[i] && a[i + 1]){\n\t\t\tfor(int j = 1;j <= i;j++) printf(\"%d \", j);\n\t\t\tprintf(\"%d \", n + 1);\n\t\t\tfor(int j = i + 1;j <= n;j++) printf(\"%d \", j);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++) printf(\"%d \", i);\n\tprintf(\"%d \", n + 1);\n}\n\nint main(){\n    scanf(\"%d\", &t);\n    while(t--) solve(), puts(\"\");\n}\n "
    },
    "1557B": {
        "title": "B. Moamen and k-subarrays",
        "description": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u2264105).\nThe second line contains n integers a1,a2,\u2026,an (0\u2264|ai|\u2264109). It is guaranteed that all numbers are distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, you should output a single string.\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\nIn the first test case, a=[6,3,4,2,1], and k=4, so we can do the operations as follows: \nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\nAs an example, if we split it into {[1,\u22124],[0,\u22122]}, we can reorder them into {[1,\u22124],[0,\u22122]} or {[0,\u22122],[1,\u22124]}. However, after merging the subarrays, it is impossible to get a sorted array.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1557B - Moamen and k-subarrays Hint 1You can ignore the k given in the input, try to find the minimum k you need to sort the array (let call it mnK).If mnK \u2264 k then you can split some subarrays to make it equal k, so the answer is will be \"YES\". otherwise, the answer will be \"NO\". Hint 2You need to split the array into the minimum number of subarrays such that each subarray is sorted. SolutionThis problem can be solved for \\textbf{at least} k subarrays as it is easy to just add extra subarrays (if needed) to achieve \\textbf{exactly} k subarrays. To solve this problem, you need to know what are the numbers that can be grouped into the same subarray. This can be done by maintaining the sorted array along with the non-sorted array.As the numbers are distinct, we can iterate over the non-sorted array, and just add each element ai to the subarray ending in ai\u22121 IFF they follow each other in the sorted array, or start a new subarray if they do not follow each other.For example, if the (non-sorted) array is [ 2, 3, \u22121, 1], the sorted array will be [ \u22121, 1, 2, 3 ]. If we iterate over the non-sorted array, we will add 2 to a new subarray, then we will add 3 to the same subarray as they follow each other in the sorted array. After that, we will start a new subarray at \u22121 as \u22121 and 3 do not follow each other in the sorted array. Finally, we will add 1 to the subarray containing \u22121. It should end up like this: { [ 2, 3 ], [ \u22121, 1 ] }.Using this approach, you can get the smallest number of subarrays needed. If it is strictly greater than the given k, the answer is ''NO''. Otherwise, it is ''YES''. Code125412883"
    },
    "1553C": {
        "title": "C. Penalty",
        "description": "Consider a simplified penalty phase at the end of a football match.\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or ?. This string represents your predictions in the following way:\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or ?.\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\nConsider the example test:\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "greedy",
            "*1200"
        ],
        "solutions": "1553C - PenaltyAfter you have fixed the values of ? you can easily find the number of kicks needed to decide the winners in constant time. If you iterate over all possible values of ? you can get solution which works in O(210\u22c5check) for one testcase, which is enough to pass.The other possible solution is to notice that it's optimal to change ? of one team to 1 and to 0 for other. So you only have two candidates to check. Solution (BledDest)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint ans = 9;\n\t\t\n\t\t{\n\t\t\tint cnt0 = 0, cnt1 = 0;\n\t\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\t\tif (i % 2 == 0) cnt0 += s[i] != '0';\n\t\t\t\telse cnt1 += s[i] == '1'; \n\t\t\t\tif (cnt0 > cnt1 + (10 - i) / 2) ans = min(ans, i);\n\t\t\t\tif (cnt1 > cnt0 + (9 - i) / 2) ans = min(ans, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t{\n\t\t\tint cnt0 = 0, cnt1 = 0;\n\t\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\t\tif (i % 2 == 0) cnt0 += s[i] == '1';\n\t\t\t\telse cnt1 += s[i] != '0'; \n\t\t\t\tif (cnt0 > cnt1 + (10 - i) / 2) ans = min(ans, i);\n\t\t\t\tif (cnt1 > cnt0 + (9 - i) / 2) ans = min(ans, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans + 1 << '\\n';\n\t}\n}"
    },
    "1550B": {
        "title": "B. Maximum Cost Deletion",
        "description": "You are given a string s of length n consisting only of the characters 0 and 1.\nYou perform the following operation until the string becomes empty: choose some consecutive substring of equal characters, erase it from the string and glue the remaining two parts together (any of them can be empty) in the same order. For example, if you erase the substring 111 from the string 111110, you will get the string 110. When you delete a substring of length l, you get a\u22c5l+b points.\nYour task is to calculate the maximum number of points that you can score in total, if you have to make the given string empty.\nThe first line contains a single integer t (1\u2264t\u22642000)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains three integers n, a and b (1\u2264n\u2264100;\u2212100\u2264a,b\u2264100)\u00a0\u2014 the length of the string s and the parameters a and b.\nThe second line contains the string s. The string s consists only of the characters 0 and 1.\nFor each testcase, print a single integer\u00a0\u2014 the maximum number of points that you can score.\nIn the first example, it is enough to delete the entire string, then we will get 2\u22c53+0=6 points.\nIn the second example, if we delete characters one by one, then for each deleted character we will get (\u22122)\u22c51+5=3 points, i.\u2009e. 15 points in total.\nIn the third example, we can delete the substring 00 from the string 100111, we get 1\u22c52+(\u22124)=\u22122 points, and the string will be equal to 1111, removing it entirely we get 1\u22c54+(\u22124)=0 points. In total, we got \u22122 points for 2 operations.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1550B - Maximum Cost DeletionLet l1,l2,\u2026,lk be the length of the substring deleted at the i-th step. Then the number of points will be equal to \u2211i=1k(a\u22c5li+b) or a\u2211i=1kli+bk. The sum of all li is equal to n (because in the end we deleted the entire string), so the final formula has the form an+bk. Obviously, for b\u22650, you should delete the characters one by one so that k=n. Now b<0 and you have to delete the string in the minimum number of operations. Let the string s consist of m blocks of zeros and ones, then \u230am2\u230b+1 is the minimum number of operations for which the entire string can be deleted. As long as the number of blocks is more than 2, we will delete the second block, the number of blocks will decrease by 2 after each such operation (the block that we delete will disappear, and the first and third blocks will merge into one). Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    int n, a, b;\n    string s;\n    cin >> n >> a >> b >> s;\n    int m = unique(s.begin(), s.end()) - s.begin();\n    cout << n * a + max(n * b, (m / 2 + 1) * b) << '\\n'; \n  }\n}"
    },
    "1547C": {
        "title": "C. Pair Programming",
        "description": "Monocarp and Polycarp are learning new programming techniques. Now they decided to try pair programming.\nIt's known that they have worked together on the same file for n+m minutes. Every minute exactly one of them made one change to the file. Before they started, there were already k lines written in the file.\nEvery minute exactly one of them does one of two actions: adds a new line to the end of the file or changes one of its lines.\nMonocarp worked in total for n minutes and performed the sequence of actions [a1,a2,\u2026,an]. If ai=0, then he adds a new line to the end of the file. If ai>0, then he changes the line with the number ai. Monocarp performed actions strictly in this order: a1, then a2, ..., an.\nPolycarp worked in total for m minutes and performed the sequence of actions [b1,b2,\u2026,bm]. If bj=0, then he adds a new line to the end of the file. If bj>0, then he changes the line with the number bj. Polycarp performed actions strictly in this order: b1, then b2, ..., bm.\nRestore their common sequence of actions of length n+m such that all actions would be correct \u2014 there should be no changes to lines that do not yet exist. Keep in mind that in the common sequence Monocarp's actions should form the subsequence [a1,a2,\u2026,an] and Polycarp's \u2014 subsequence [b1,b2,\u2026,bm]. They can replace each other at the computer any number of times.\nLet's look at an example. Suppose k=3. Monocarp first changed the line with the number 2 and then added a new line (thus, n=2,a=[2,0]). Polycarp first added a new line and then changed the line with the number 5 (thus, m=2,b=[0,5]).\nSince the initial length of the file was 3, in order for Polycarp to change line number 5 two new lines must be added beforehand. Examples of correct sequences of changes, in this case, would be [0,2,0,5] and [2,0,0,5]. Changes [0,0,5,2] (wrong order of actions) and [0,5,2,0] (line 5 cannot be edited yet) are not correct.\nThe first line contains an integer t (1\u2264t\u22641000). Then t test cases follow. Before each test case, there is an empty line.\nEach test case contains three lines. The first line contains three integers k, n, m (0\u2264k\u2264100, 1\u2264n,m\u2264100)\u00a0\u2014 the initial number of lines in file and lengths of Monocarp's and Polycarp's sequences of changes respectively.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264300).\nThe third line contains m integers b1,b2,\u2026,bm (0\u2264bj\u2264300).\nFor each test case print any correct common sequence of Monocarp's and Polycarp's actions of length n+m or -1 if such sequence doesn't exist.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solutions": "1547C - Pair ProgrammingThe solution is that if we can do something, let's do it. It doesn't make sense not to act, because neither adding a new row nor modifying an existing one can prevent the existing row from being changed in the future. Therefore, we will iterate over the actions and eagerly act Monocarp or Polycarp.Let's create two pointers i and j in arrays a and b\u00a0\u2014 index of possible action of Monocarp and Polycarp and c\u00a0\u2014 the current length of the file.Suppose that ai=0 or bj=0 on current iteration. Then we take the appropriate zero element and increase c by one. We can do that because appending a new line cannot make a new answer prefix incorrect if the previous prefix was correct.Suppose that ai\u22600 and bj\u22600. If ai>c and bj>c then there is no answer because we can potentially do only two actions and both make the answer incorrect. If one number is greater than c and the other is less than or equals then we take the one that less than or equals c.If one of the sequences a or b ends then only one potential action needs to be checked at each iteration. Solution#include <iostream>\n#include <vector>\n\ntypedef std::vector<int> vi;\n\nint main() {\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int k, n, m;\n        std::cin >> k >> n >> m;\n\n        vi a(n), b(m);\n        for (int i = 0; i < n; i++)\n            std::cin >> a[i];\n        for (int i = 0; i < m; i++)\n            std::cin >> b[i];\n\n        int pos1 = 0, pos2 = 0;\n        vi res;\n        bool ok = true;\n        while (pos1 != n || pos2 != m) {\n            if (pos1 != n && a[pos1] == 0) {\n                res.push_back(0);\n                k++;\n                pos1++;\n            } else if (pos2 != m && b[pos2] == 0) {\n                res.push_back(0);\n                k++;\n                pos2++;\n            } else if (pos1 != n && a[pos1] <= k) {\n                res.push_back(a[pos1++]);\n            } else if (pos2 != m && b[pos2] <= k) {\n                res.push_back(b[pos2++]);\n            } else {\n                std::cout << -1 << '\\n';\n                ok = false;\n                break;\n            }\n        }\n\n        if (ok) {\n            for (int cur : res)\n                std::cout << cur << ' ';\n            std::cout << std::endl;\n        }\n    }\n\n    return 0;\n}"
    },
    "1546B": {
        "title": "B. AquaMoon and Stolen String",
        "description": "AquaMoon had n strings of length m each. n is an odd number.\nWhen AquaMoon was gone, Cirno tried to pair these n strings together. After making n\u221212 pairs, she found out that there was exactly one string without the pair!\nIn her rage, she disrupted each pair of strings. For each pair, she selected some positions (at least 1 and at most m) and swapped the letters in the two strings of this pair at the selected positions.\nFor example, if m=6 and two strings \"abcdef\" and \"xyzklm\" are in one pair and Cirno selected positions 2, 3 and 6 she will swap 'b' with 'y', 'c' with 'z' and 'f' with 'm'. The resulting strings will be \"ayzdem\" and \"xbcklf\".\nCirno then stole away the string without pair and shuffled all remaining strings in arbitrary order.\nAquaMoon found the remaining n\u22121 strings in complete disarray. Also, she remembers the initial n strings. She wants to know which string was stolen, but she is not good at programming. Can you help her?\nThis problem is made as interactive. It means, that your solution will read the input, given by the interactor. But the interactor will give you the full input at the beginning and after that, you should print the answer. So you should solve the problem, like as you solve the usual, non-interactive problem because you won't have any interaction process. The only thing you should not forget is to flush the output buffer, after printing the answer. Otherwise, you can get an \"Idleness limit exceeded\" verdict. Refer to the interactive problems guide for the detailed information about flushing the output buffer.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThe first line of each test case contains two integers n, m (1\u2264n\u2264105, 1\u2264m\u2264105) \u2014 the number of strings and the length of each string, respectively.\nThe next n lines each contain a string with length m, describing the original n strings. All string consists of lowercase Latin letters.\nThe next n\u22121 lines each contain a string with length m, describing the strings after Cirno exchanged and reordered them.\nIt is guaranteed that n is odd and that the sum of n\u22c5m over all test cases does not exceed 105.\nHack format:\nThe first line should contain a single integer t. After that t test cases should follow in the following format:\nThe first line should contain two integers n and m.\nThe following n lines should contain n strings of length m, describing the original strings.\nThe following n\u221212 lines should describe the pairs. They should contain, in the following order: the index of the first string i (1\u2264i\u2264n), the index of the second string j (1\u2264j\u2264n, i\u2260j), the number of exchanged positions k (1\u2264k\u2264m), and the list of k positions that are exchanged (k distinct indices from 1 to m in any order).\nThe final line should contain a permutation of integers from 1 to n, describing the way the strings should be reordered. The strings will be placed in the order indices placed in this permutation, the stolen string index will be ignored.\nFor each test case print a single line with the stolen string.\nIn the first test case, \"aaaaa\" and \"bbbbb\" exchanged all positions, and \"ccccc\" is the stolen string.\nIn the second test case, \"aaaa\" and \"bbbb\" exchanged two first positions, and \"cccc\" is the stolen string.\nThis is the first test in the hack format: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "interactive",
            "math",
            "*1200"
        ],
        "solutions": "1546B - AquaMoon and Stolen StringWe can find that for each letter of the answer must appear an odd number of times in its column(Since for other strings, they appear twice in total. The operation does not change the number of the occurrence of some certain letter in one column).So we can consider each position individually. There is always exactly one letter that occurs an odd number of times. So just take them out and they are the letters of the stolen string. solution#include <cstdio>\nconst int Maxn=1000000;\nchar s[Maxn+5];\nchar ans[Maxn+5];\nint n,m;\nvoid solve(){\n    scanf(\"%d%d\",&n,&m);\n    n=(n<<1)-1;\n    for(int i=1;i<=m;i++){\n        ans[i]=0;\n    }\n    for(int i=1;i<=n;i++){\n        scanf(\"%s\",s+1);\n        for(int j=1;j<=m;j++){\n            ans[j]^=s[j];\n        }\n    }\n    for(int i=1;i<=m;i++){\n        putchar(ans[i]);\n    }\n    putchar('\\n');\n}\nint main(){\n    int T;\n    scanf(\"%d\",&T);\n    while(T--){\n        solve();\n    }\n\treturn 0;\n}Idea: AquaMoon "
    },
    "1541B": {
        "title": "B. Pleasant Pairs",
        "description": "You are given an array a1,a2,\u2026,an consisting of n distinct integers. Count the number of pairs of indices (i,j) such that i<j and ai\u22c5aj=i+j.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t cases follow.\nThe first line of each test case contains one integer n (2\u2264n\u2264105)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n space separated integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5n)\u00a0\u2014 the array a. It is guaranteed that all elements are distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the number of pairs of indices (i,j) such that i<j and ai\u22c5aj=i+j.\nFor the first test case, the only pair that satisfies the constraints is (1,2), as a1\u22c5a2=1+2=3\nFor the second test case, the only pair that satisfies the constraints is (2,3).\nFor the third test case, the pairs that satisfy the constraints are (1,2), (1,5), and (2,3).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1541B - Pleasant PairsLoop over all values of ai and aj. Because i+j\u22642\u22c5n, we only care about pairs (ai,aj) if ai\u22c5aj\u22642\u22c5n. The number of such pairs is O(nlogn), so you can brute force all pairs.The reason the total number of pairs is O(nlogn) is because if the first element of the pair is x, there are only 2\u22c5nx possible values of y. 2\u22c5n1+2\u22c5n2+2\u22c5n3+\u20262\u22c5nn=2\u22c5n(11+12+13\u20261n)=O(nlogn) by the harmonic series. Thus the solution runs in O(nlogn) time total."
    },
    "1539C": {
        "title": "C. Stable Groups",
        "description": "There are n students numerated from 1 to n. The level of the i-th student is ai. You need to split the students into stable groups. A group of students is called stable, if in the sorted array of their levels no two neighboring elements differ by more than x.\nFor example, if x=4, then the group with levels [1,10,8,4,4] is stable (because 4\u22121\u2264x, 4\u22124\u2264x, 8\u22124\u2264x, 10\u22128\u2264x), while the group with levels [2,10,10,7] is not stable (7\u22122=5>x).\nApart from the n given students, teachers can invite at most k additional students with arbitrary levels (at teachers' choice). Find the minimum number of stable groups teachers can form from all students (including the newly invited).\nFor example, if there are two students with levels 1 and 5; x=2; and k\u22651, then you can invite a new student with level 3 and put all the students in one stable group.\nThe first line contains three integers n, k, x (1\u2264n\u2264200000, 0\u2264k\u22641018, 1\u2264x\u22641018)\u00a0\u2014 the initial number of students, the number of students you can additionally invite, and the maximum allowed level difference.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u22641018)\u00a0\u2014 the students levels.\nIn the only line print a single integer: the minimum number of stable groups you can split the students into.\nIn the first example you can invite two students with levels 2 and 11. Then you can split the students into two stable groups: \nIn the second example you are not allowed to invite new students, so you need 3 groups: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1539C - Stable GroupsFirstly, we will find the amount of groups needed if we don't add any new students. Let's consider the students in the increasing order of their knowledge level. Students are greedily determined to the same group if the difference of their knowledge levels is not greater than x. Else we create another group. After that all students will be split into continuous non-intersecting segments \u00a0\u2014 stable groups.Merging two segments with knowledge difference d may be done by adding \u2308dx\u2309\u22121 new students. Each such merge decreases the answer by 1 so we should maximize the amount of merges. To do that we should just consider the merges in increasing order of their costs. "
    },
    "1539A": {
        "title": "A. Contest Start",
        "description": "There are n people participating in some contest, they start participating in x minutes intervals. That means the first participant starts at time 0, the second participant starts at time x, the third\u00a0\u2014 at time 2\u22c5x, and so on.\nDuration of contest is t minutes for each participant, so the first participant finishes the contest at time t, the second\u00a0\u2014 at time t+x, and so on. When a participant finishes the contest, their dissatisfaction equals to the number of participants that started the contest (or starting it now), but haven't yet finished it.\nDetermine the sum of dissatisfaction of all participants.\nThe first line contains a single integer k (1\u2264k\u22641000)\u00a0\u2014 the number of test cases.\nEach of the next k lines contains three integers n, x, t (1\u2264n,x,t\u22642\u22c5109)\u00a0\u2014 the number of participants, the start interval and the contest duration.\nPrint k lines, in the i-th line print the total dissatisfaction of participants in the i-th test case.\nIn the first example the first participant starts at 0 and finishes at time 5. By that time the second and the third participants start, so the dissatisfaction of the first participant is 2. \nThe second participant starts at time 2 and finishes at time 7. By that time the third the fourth participants start, so the dissatisfaction of the second participant is 2. \nThe third participant starts at 4 and finishes at 9. By that time the fourth participant starts, so the dissatisfaction of the third participant is 1.\nThe fourth participant starts at 6 and finishes at 11. By time 11 everyone finishes the contest, so the dissatisfaction of the fourth participant is 0.\nIn the second example the first participant starts at 0 and finishes at time 2. By that time the second participants starts, and the third starts at exactly time 2. So the dissatisfaction of the first participant is 2. \nThe second participant starts at time 1 and finishes at time 3. At that time the third participant is solving the contest.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "geometry",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1539A - Contest Start was authored and prepared by grphil"
    },
    "1537C": {
        "title": "C. Challenging Cliffs",
        "description": "You are a game designer and want to make an obstacle course. The player will walk from left to right. You have n heights of mountains already selected and want to arrange them so that the absolute difference of the heights of the first and last mountains is as small as possible. \nIn addition, you want to make the game difficult, and since walking uphill or flat is harder than walking downhill, the difficulty of the level will be the number of mountains i (1\u2264i<n) such that hi\u2264hi+1 where hi is the height of the i-th mountain. You don't want to waste any of the mountains you modelled, so you have to use all of them. \nFrom all the arrangements that minimize |h1\u2212hn|, find one that is the most difficult. If there are multiple orders that satisfy these requirements, you may find any.\nThe first line will contain a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the number of mountains.\nThe second line of each test case contains n integers h1,\u2026,hn (1\u2264hi\u2264109), where hi is the height of the i-th mountain.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers \u2014 the given heights in an order that maximizes the difficulty score among all orders that minimize |h1\u2212hn|.\nIf there are multiple orders that satisfy these requirements, you may output any.\nIn the first test case:\nThe player begins at height 2, next going up to height 4 increasing the difficulty by 1. After that he will go down to height 1 and the difficulty doesn't change because he is going downhill. Finally the player will go up to height 2 and the difficulty will increase by 1. The absolute difference between the starting height and the end height is equal to 0 and it's minimal. The difficulty is maximal.\nIn the second test case:\nThe player begins at height 1, next going up to height 3 increasing the difficulty by 1. The absolute difference between the starting height and the end height is equal to 2 and it's minimal as they are the only heights. The difficulty is maximal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1537C - Challenging CliffsWe claim that the maximum difficulty is at least n\u22122. Assume the array is sorted. We first need to find the two mountains which go on the ends. To do this, we can iterate through every mountain in the sorted array and check the difference between a mountain and its neighbours in the array. Let mk and mk+1 be the mountains with the smallest height difference. We can achieve at least a difficulty of n\u22122 by arranging the mountains as mk,mk+2,mk+3...mn,m1,m2,.....,mk+1. To get difficulty n\u22121, we need mk to be the shortest mountain and mk+1 to be the tallest mountain. This will only happen if n=2. Code#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> h(n);\n\n        for (int i = 0;i < n; i++){\n            cin >> h[i];\n        }\n        sort(h.begin(), h.end());\n\n        if(n == 2){\n            cout << h[0] << \" \" << h[1] << \"\\n\";\n            continue;\n        }\n\n        int pos = -1, mn = INT_MAX;\n\n        for (int i = 1;i < n; i++){\n            if(mn > abs(h[i] - h[i - 1])){\n                pos = i;\n                mn = abs(h[i] - h[i - 1]);\n            }\n        }\n        \n        for (int i = pos;i < n; i++){\n            cout << h[i] << \" \";\n        }\n        for(int i = 0;i < pos; i++){\n            cout << h[i] << \" \";\n        }\n\n        cout << \"\\n\";\n\n    }\n}"
    },
    "1536B": {
        "title": "B. Prinzessin der Verurteilung",
        "description": "I, Fischl, Prinzessin der Verurteilung, descend upon this land by the call of fate an \u2014 Oh, you are also a traveler from another world? Very well, I grant you permission to travel with me.\nIt is no surprise Fischl speaks with a strange choice of words. However, this time, not even Oz, her raven friend, can interpret her expressions! Maybe you can help us understand what this young princess is saying?\nYou are given a string of n lowercase Latin letters, the word that Fischl just spoke. You think that the MEX of this string may help you find the meaning behind this message. The MEX of the string is defined as the shortest string that doesn't appear as a contiguous substring in the input. If multiple strings exist, the lexicographically smallest one is considered the MEX. Note that the empty substring does NOT count as a valid MEX.\nA string a is lexicographically smaller than a string b if and only if one of the following holds: \nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nFind out what the MEX of the string is!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22641000)\u00a0\u2014 the length of the word. The second line for each test case contains a single string of n lowercase Latin letters.\nThe sum of n over all test cases will not exceed 1000.\nFor each test case, output the MEX of the string on a new line.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "strings",
            "*1200"
        ],
        "solutions": "1536B - Prinzessin der VerurteilungIdea: MagentaCobraPreparation: MagentaCobraVideo editorial Hint 1Pigeonhole principle Hint 2What is the longest the answer can be? SolutionLet\u2019s brute force check all substrings of length <= 3 and print the lexicographically smallest one that doesn\u2019t appear as a substring in the input. We can guarantee that we will come across the answer due to the pigeonhole principle. There are at most n+n\u22121+n\u22122=3n\u22123 possible substrings of length 3 or shorter in the input. There exist 26+262+263=18278 total substrings of length 3 or shorter. It is impossible for the input to contain all 18278 substrings, as 3n\u22123<18278 for n\u22641000.Final runtime looks something like O(18278n) or O(n) depending on how you implement substring checking. Implementation in Java by hu_tao//stan hu tao\n//come to K-expo!!!\n//watch me get carried in nct ridin\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class FischlPog\n{\n    public static void main(String hi[]) throws Exception\n    {\n        ArrayList<String> ls = new ArrayList<String>();\n        for(int a=0; a < 26; a++)\n            ls.add(get(a)+\"\");\n        for(int a=0; a < 26; a++)\n            for(int b=0; b < 26; b++)\n                ls.add(get(a)+\"\"+get(b));\n        for(int a=0; a < 26; a++)\n            for(int b=0; b < 26; b++)\n                for(int c=0; c < 26; c++)\n                    ls.add(get(a)+\"\"+get(b)+\"\"+get(c));\n        Collections.sort(ls, (x,y) -> {\n            int len1 = x.length();\n            int len2 = y.length();\n            if(len1 != len2)\n                return len1-len2;\n            return x.compareTo(y);\n        });\n        //assume multitests exist\n        BufferedReader infile = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(infile.readLine());\n        int T = Integer.parseInt(st.nextToken());\n        StringBuilder sb = new StringBuilder();\n        while(T-->0)\n        {\n            int N = Integer.parseInt(infile.readLine());\n            String input = infile.readLine();\n            HashSet<String> substrings = new HashSet<String>();\n            for(int len=1; len <= 3; len++)\n                for(int i=0; i < N-len+1; i++)\n                    substrings.add(input.substring(i, i+len));\n            for(int i=0; i < ls.size(); i++)\n                if(!substrings.contains(ls.get(i)))\n                {\n                    sb.append(ls.get(i)+\"\\n\");\n                    break;\n                }\n        }\n        System.out.print(sb);\n    }\n    public static char get(int a)\n    {\n        return (char)(a+'a');\n    }\n} Implementation in Kotlin by Tlatoanifun main() {\n    repeat(readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val s = readLine()!!\n        for (length in 1..n) {\n            var mex = \"\"\n            var answer: String? = null\n            fun recur() {\n                if (mex.length == length) {\n                    if (mex !in s) {\n                        answer = mex\n                    }\n                } else {\n                    for (chara in 'a'..'z') {\n                        mex += chara\n                        recur()\n                        if (answer != null) {\n                            return\n                        }\n                        mex = mex.substring(0 until mex.lastIndex)\n                    }\n                }\n            }\n            recur()\n            if (answer != null) {\n                println(answer)\n                break\n            }\n        }\n    }\n} Implementation in C++ by 1-gon#include <bits/stdc++.h>\n \n#define ll long long\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define vi vector<int>\n#define pii pair<int, int>\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\nusing namespace std;\ntemplate<typename T>\nusing minpq = priority_queue<T, vector<T>, greater<T>>;\n \nvoid solve() {\n    int n;\n    string s;\n    cin >> n >> s;\n    set<string> se;\n    rep(i, 0, n) {\n        string ss;\n        for(int k = 0; k < 5 && i + k < n; k++) {\n            ss.push_back(s[i + k]);\n            se.insert(ss);\n        }\n    }\n    rep(len, 1, 6) {\n        string t(len, 'a');\n        while(true) {\n            if(se.count(t) == 0) {\n                cout << t << '\\n';\n                return;\n            }\n            int idx = len - 1;\n            while(idx >= 0 && t[idx] == 'z') {\n                t[idx] = 'a';\n                idx--;\n            }\n            if(idx < 0) break;\n            t[idx]++;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int te;\n    cin >> te;\n    while(te--) solve();\n} Implementation in Haskell by Tlatoaniimport Data.List (intercalate, tails, isPrefixOf, head)\nimport Control.Monad (replicateM)\nimport Data.Maybe (fromJust, listToMaybe, catMaybes)\n\nmain = do t <- read <$> getLine\n          replicateM t solve\n\nsolve = do getLine\n           s <- getLine\n           putStrLn (leastNonSubstring s)\n\nleastNonSubstring s = head $ catMaybes [leastOfLength l | l <- [1..]]\n  where leastOfLength l = helper \"\" l\n        helper prefix 0 | isSubstring prefix s = Nothing\n                        | otherwise            = Just prefix\n        helper prefix l = listToMaybe $ catMaybes [helper (prefix ++ [letter]) (l - 1) | letter <- ['a'..'z']]\n\nisSubstring s t = any id (map (isPrefixOf s) (tails t)) "
    },
    "1534B": {
        "title": "B. Histogram Ugliness",
        "description": "Little Dormi received a histogram with n bars of height a1,a2,\u2026,an for Christmas. However, the more he played with his new histogram, the more he realized its imperfections, so today he wanted to modify it to his liking.\nTo modify the histogram, Little Dormi is able to perform the following operation an arbitrary number of times:\nLittle Dormi defines the ugliness score of his histogram (after performing some number of operations) as the sum of the vertical length of its outline and the number of operations he performed on it. And to make the histogram as perfect as possible, he would like to minimize the ugliness score after modifying it with some number of operations.\nHowever, as his histogram is very large, Little Dormi is having trouble minimizing the ugliness score, so as Little Dormi's older brother, help him find the minimal ugliness.\nConsider the following example where the histogram has 4 columns of heights 4,8,9,6:\nThe blue region represents the histogram, and the red lines represent the vertical portion of the outline. Currently, the vertical length of the outline is 4+4+1+3+6=18, so if Little Dormi does not modify the histogram at all, the ugliness would be 18.\nHowever, Little Dormi can apply the operation once on column 2 and twice on column 3, resulting in a histogram with heights 4,7,7,6:\nNow, as the total vertical length of the outline (red lines) is 4+3+1+6=14, the ugliness is 14+3=17 dollars. It can be proven that this is optimal.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22644\u22c5105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 4\u22c5105.\nFor each test case output one integer, the minimal ugliness Little Dormi can achieve with the histogram in that test case.\nExample 1 is the example described in the statement.\nThe initial histogram for example 2 is given below:\nThe ugliness is currently 2+1+6+3+4=16.\nBy applying the operation once on column 1, six times on column 3, and three times on column 4, we can end up with a histogram with heights 1,1,1,1,0,0:\nThe vertical length of the outline is now 1+1=2 and Little Dormi made 1+6+3=10 operations, so the final ugliness is 2+10=12, which can be proven to be optimal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1534B - \u0423\u0440\u043e\u0434\u043b\u0438\u0432\u043e\u0441\u0442\u044c \u0433\u0438\u0441\u0442\u043e\u0433\u0440\u0430\u043c\u043c\u044bIt's only optimal to decrease a column i if ai>ai+1 and ai>ai\u22121, as that would reduce the vertical length of the outline by 2 while only costing 1 operation. Additionally, observe that decreasing a column will never affect whether it is optimal to decrease any other column, so we can treat the operations as independent.Thus, our algorithm is as follows: while it is optimal to decrease a column, do it. Once this is no longer the case, calculate the final value of the histogram. This can be sped up to O(n) with some arithmetic and the observation above. Solution119400874"
    },
    "1530C": {
        "title": "C. Pursuit",
        "description": "You and your friend Ilya are participating in an individual programming contest consisting of multiple stages. A contestant can get between 0 and 100 points, inclusive, for each stage, independently of other contestants.\nPoints received by contestants in different stages are used for forming overall contest results. Suppose that k stages of the contest are completed. For each contestant, k\u2212\u230ak4\u230b stages with the highest scores are selected, and these scores are added up. This sum is the overall result of the contestant. (Here \u230at\u230b denotes rounding t down.)\nFor example, suppose 9 stages are completed, and your scores are 50,30,50,50,100,10,30,100,50. First, 7 stages with the highest scores are chosen\u00a0\u2014 for example, all stages except for the 2-nd and the 6-th can be chosen. Then your overall result is equal to 50+50+50+100+30+100+50=430.\nAs of now, n stages are completed, and you know the points you and Ilya got for these stages. However, it is unknown how many more stages will be held. You wonder what the smallest number of additional stages is, after which your result might become greater than or equal to Ilya's result, at least in theory. Find this number!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of completed stages.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264100)\u00a0\u2014 your points for the completed stages.\nThe third line contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264100)\u00a0\u2014 Ilya's points for the completed stages.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the smallest number of additional stages required for your result to be able to become greater than or equal to Ilya's result.\nIf your result is already not less than Ilya's result, print 0.\nIn the first test case, you have scored 100 points for the first stage, while Ilya has scored 0. Thus, your overall result (100) is already not less than Ilya's result (0).\nIn the second test case, you have scored 0 points for the first stage, while Ilya has scored 100. A single stage with an opposite result is enough for both your and Ilya's overall scores to become equal to 100.\nIn the third test case, your overall result is 30+40+50=120, while Ilya's result is 100+100+100=300. After three additional stages your result might become equal to 420, while Ilya's result might become equal to 400.\nIn the fourth test case, your overall result after four additional stages might become equal to 470, while Ilya's result might become equal to 400. Three stages are not enough.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1530C - PursuitThe first thing to notice is that since we're chasing Ilya and we want to reach his score as soon as possible, it only makes sense to add 100's to our scores and 0's to his.We can also notice that the answer never exceeds n. No matter how bad a stage is for us in terms of points, adding a single stage where we score 100 and Ilya scores 0 \"compensates\" it. In particular, in the worst case, when all ai=0 and all bi=100, the answer is exactly n.However, if we just add the 100/0 stages one-by-one and calculate the overall results from scratch every time, our solution will have O(n2) complexity and that's too much.There are many ways to optimize the solution.One of them is to transform the given a and b arrays into arrays of length 101, containing the count of each score (since we are not interested in the order of the scores). Let m=100 be the maximum achievable score in a stage. Using the transformed arrays, we can calculate the overall scores in O(m) instead of O(n), to lower the final complexity to O(mn).Alternatively, notice that when we add 100 to our scores, it just adds 100 to our overall score except for the case when the total number of completed stages becomes divisible by 4, when we also need to subtract the score of the worst currently included stage from the sum. We can similarly handle adding 0 to Ilya's scores. If we sort all our and Ilya's scores at the beginning and maintain a pointer to the current worst included stage in both scoresheets, we can add a new 100/0 stage and recalculate the totals in O(1).Finally, we can also notice that whenever adding k stages works for us, adding k+1 stages will work too. Thus, we can use binary search on k. We can easily check a single value of k in O(n) or O(nlogn), resulting in O(nlogn) or O(nlog2n) time complexity. "
    },
    "1529B": {
        "title": "B. Sifid and Strange Subsequences",
        "description": "A sequence (b1,b2,\u2026,bk) is called strange, if the absolute difference between any pair of its elements is greater than or equal to the maximum element in the sequence. Formally speaking, it's strange if for every pair (i,j) with 1\u2264i<j\u2264k, we have |ai\u2212aj|\u2265MAX, where MAX is the largest element of the sequence. In particular, any sequence of length at most 1 is strange.\nFor example, the sequences (\u22122021,\u22121,\u22121,\u22121) and (\u22121,0,1) are strange, but (3,0,1) is not, because |0\u22121|<3.\nSifid has an array a of n integers. Sifid likes everything big, so among all the strange subsequences of a, he wants to find the length of the longest one. Can you help him?\nA sequence c is a subsequence of an array d if c can be obtained from d by deletion of several (possibly, zero or all) elements.\nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 105.\nFor each test case output a single integer \u2014 the length of the longest strange subsequence of a.\nIn the first test case, one of the longest strange subsequences is (a1,a2,a3,a4)\nIn the second test case, one of the longest strange subsequences is (a1,a3,a4,a5,a7).\nIn the third test case, one of the longest strange subsequences is (a1,a3,a4,a5).\nIn the fourth test case, one of the longest strange subsequences is (a2).\nIn the fifth test case, one of the longest strange subsequences is (a1,a2,a4).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1529B - Sifid \u0438 \u0441\u0442\u0440\u0430\u043d\u043d\u044b\u0435 \u043f\u043e\u0434\u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438It's easy to prove that a strange subsequence can't contain more than one positive element.So it's optimal to pick all of the non-positive elements, now we can pick at most one positive element.Assume x is the minimum positive element in the array. We can pick x if no two elements in the already picked set such as a and b exist in a way that |a\u2212b|<x. To check this, we just have to sort the already picked elements and see the difference between adjacent pairs. complexity: O(nlogn) official solution// khodaya khodet komak kon\n// Nightcall - London Grammer\n# include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define lc                                              id << 1\n# define rc                                              id << 1 | 1\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 1e5 + 10;\nconst int xm = - 20 + 10;\nconst int sq = 320;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;//998244353;\nconst int base = 257;\n \nint qq, n, a[xn], ans, mn;\nbool flag;\n \nint main(){\n\tios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \n\tcin >> qq;\n\twhile (qq --){\n\t\tcin >> n, ans = 0;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tcin >> a[i], ans += (a[i] <= 0);\n\t\tsort(a + 1, a + n + 1), mn = inf;\n\t\tfor (int i = 1; i <= n; ++ i)\n\t\t\tif (a[i] > 0)\n\t\t\t\tmn = min(mn, a[i]);\n\t\tflag = (mn < inf);\n\t\tfor (int i = 2; i <= n; ++ i)\n\t\t\tif (a[i] <= 0)\n\t\t\t\tflag &= (a[i] - a[i - 1] >= mn);\n\t\tif (flag)\n\t\t\tcout << ans + 1 << endl;\n\t\telse\n\t\t\tcout << ans << endl;\n\t}\n \n\treturn 0;\n}"
    },
    "1527B1": {
        "title": "B1. Palindrome Game (easy version)",
        "description": "The only difference between the easy and hard versions is that the given string s in the easy version is initially a palindrome, this condition is not always true for the hard version.\nA palindrome is a string that reads the same left to right and right to left. For example, \"101101\" is a palindrome, while \"0101\" is not.\nAlice and Bob are playing a game on a string s (which is initially a palindrome in this version) of length n consisting of the characters '0' and '1'. Both players take alternate turns with Alice going first.\nIn each turn, the player can perform one of the following operations: \nReversing a string means reordering its letters from the last to the first. For example, \"01001\" becomes \"10010\" after reversing.\nThe game ends when every character of string becomes '1'. The player who spends minimum dollars till this point wins the game and it is a draw if both spend equal dollars. If both players play optimally, output whether Alice wins, Bob wins, or if it is a draw.\nThe first line contains a single integer t (1\u2264t\u2264103). Then t test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u2264103).\nThe second line of each test case contains the string s of length n, consisting of the characters '0' and '1'. It is guaranteed that the string s is a palindrome and contains at least one '0'. \nNote that there is no limit on the sum of n over test cases.\nFor each test case print a single word in a new line: \nIn the first test case of the example, ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*1200"
        ],
        "solutions": "1527B1 - Palindrome Game (easy version)If the count of zeros in the string s is even then Bob always winProof   Bob can restrict Alice from performing operation 2 by making string s palindrome (if Alice changes s[i] to '1' then Bob will change s[n\u2212i+1] to '1'). However, when the last '0' is remaining, Bob will reverse the string, eventually forcing Alice to perform the operation 1. This way Alice will spend 2 dollars more than Bob resulting in Bob's win.  If the count of zeros in the string s is odd then Alice always win except for the case of one '0'Proof   Alice will change s[n/2] from '0' to '1' and play with the same strategy as Bob did in the above case. This way Bob will spend 1 dollar more than Alice resulting in Alice's win.  Solution (DenOMINATOR) #include<bits/stdc++.h>\nusing namespace std;\n\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tbool is_palindrome=1;\n\tint cnt_0 = 0;\n\tfor(int i=0;i<n;i++){\n\t\tcnt_0 += s[i]=='0';\n\t}\n\tif(cnt_0 == 1){\n\t\tcout << \"BOB\\n\";\n\t\treturn;\n\t}\n\tif(cnt_0%2){\n\t\tcout << \"ALICE\\n\";\n\t\treturn;\n\t}\n\tcout << \"BOB\\n\";\n\treturn;\n}\n\nsigned main()\n{\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tsolve();\n\t}\n    return 0;\n} Solution (shikhar7s) #include<bits/stdc++.h>\nusing namespace std;\n#define int long long int\n#define mp(a,b) make_pair(a,b)\n#define vi vector<int>\n#define mii map<int,int>\n#define mpi map<pair<int,int>,int>\n#define vp vector<pair<int,int> >\n#define pb(a) push_back(a)\n#define fr(i,n) for(i=0;i<n;i++)\n#define rep(i,a,n) for(i=a;i<n;i++)\n#define F first\n#define S second\n#define endl \"\\n\"\n#define fast std::ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define mod 1000000007\n#define dom 998244353\n#define sl(a) (int)a.length()\n#define sz(a) (int)a.size()\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int> \n#define mini 2000000000000000000\n#define time_taken 1.0 * clock() / CLOCKS_PER_SEC\n//const long double pi = acos(-1);\n//mt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//primes for hashing 937, 1013\ntemplate<typename T, typename U> static inline void amin(T &x, U y) \n{ \n    if (y < x) \n        x = y; \n}\ntemplate<typename T, typename U> static inline void amax(T &x, U y) \n{ \n    if (x < y) \n        x = y; \n}\nvoid shikhar7s(int cas)\n{\n    int n,i;\n    cin>>n;\n    string s;\n    cin>>s;\n    int f=1,z=0;\n    fr(i,n)\n    {\n        if(s[i]=='0')\n            z++;\n    }\n    int x=0;\n    fr(i,n/2)\n    {\n        if(s[i]!=s[n-1-i])\n        {\n            f=0;\n            x++;\n        }\n    }\n    if(f)\n    {\n        if(z==1||z%2==0)\n            cout<<\"BOB\"<<endl;\n        else\n            cout<<\"ALICE\"<<endl;\n    }\n    else\n    {\n        if(x==1&&z==2)\n            cout<<\"DRAW\"<<endl;\n        else\n            cout<<\"ALICE\"<<endl;\n    }\n}\nsigned main()\n{\n    fast;\n    //freopen(\"input.txt\", \"rt\", stdin);\n    //freopen(\"output.txt\", \"wt\", stdout);\n    int t=1;\n    cin>>t;\n    int cas=1;\n    while(cas<=t)\n    {\n    //cout<<\"Case #\"<<cas<<\": \";\n    shikhar7s(cas);\n    cas++;\n    }\n    return 0;\n}"
    },
    "1523B": {
        "title": "B. Lord of the Values",
        "description": "While trading on his favorite exchange trader William realized that he found a vulnerability. Using this vulnerability he could change the values of certain internal variables to his advantage. To play around he decided to change the values of all internal variables from a1,a2,\u2026,an to \u2212a1,\u2212a2,\u2026,\u2212an. For some unknown reason, the number of service variables is always an even number.\nWilliam understands that with his every action he attracts more and more attention from the exchange's security team, so the number of his actions must not exceed 5000 and after every operation no variable can have an absolute value greater than 1018. William can perform actions of two types for two chosen variables with indices i and j, where i<j:\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226420). Description of the test cases follows.\nThe first line of each test case contains a single even integer n (2\u2264n\u2264103), which is the number of internal variables.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), which are initial values of internal variables.\nFor each test case print the answer in the following format:\nThe first line of output must contain the total number of actions k, which the strategy will perform. Note that you do not have to minimize k. The inequality k\u22645000 must be satisfied. \nEach of the next k lines must contain actions formatted as \"type i j\", where \"type\" is equal to \"1\" if the strategy needs to perform an assignment of the first type and \"2\" if the strategy needs to perform an assignment of the second type. Note that i<j should hold.\nWe can show that an answer always exists.\nFor the first sample test case one possible sequence of operations is as follows:\nFor the second sample test case one possible sequence of operations is as follows:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1100"
        ],
        "solutions": "1523B - Lord of the ValuesNotice that for transforming any pair of numbers (a,b) into a pair (\u2212a,\u2212b) a sequence of operations such as (1,2,1,2,1,2) can be performed. Since n is even we can apply this sequence of operations for all pairs of numbers (ai\u22c52\u22121,ai\u22c52) for all i from 1 to n2.Final complexity: O(n).Prepared by AleXman111.  "
    },
    "1521A": {
        "title": "A. Nastia and Nearly Good Numbers",
        "description": "Nastia has 2 positive integers A and B. She defines that:\nFor example, if A=6 and B=4, the integers 24 and 72 are good, the integers 6, 660 and 12 are nearly good, the integers 16, 7 are neither good nor nearly good.\nFind 3 different positive integers x, y, and z such that exactly one of them is good and the other 2 are nearly good, and x+y=z.\nThe first line contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers A and B (1\u2264A\u2264106, 1\u2264B\u2264106)\u00a0\u2014 numbers that Nastia has.\nFor each test case print: \nIf there are multiple answers, print any.\nIn the first test case: 60\u00a0\u2014 good number; 10 and 50\u00a0\u2014 nearly good numbers.\nIn the second test case: 208\u00a0\u2014 good number; 169 and 39\u00a0\u2014 nearly good numbers.\nIn the third test case: 154\u00a0\u2014 good number; 28 and 182\u00a0\u2014 nearly good numbers.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1521A - Nastia and Nearly Good NumbersThere are 2 cases:if B=1, then the answer doesn't exist. Here we cannot get the nearly good numbers at all.Otherwise, we can construct the answer as A+A\u22c5B=A\u22c5(B+1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int q;\n    cin >> q;\n\n    while (q--) {\n        int a, b; cin >> a >> b;\n        if (b == 1) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"YES\" << endl;\n            cout << a << ' ' << a * (long long)b << ' ' << a * (long long)(b + 1) << endl;\n        }\n    }\n}"
    },
    "1520D": {
        "title": "D. Same Differences",
        "description": "You are given an array a of n integers. Count the number of pairs of indices (i,j) such that i<j and aj\u2212ai=j\u2212i.\nThe first line contains one integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output the number of pairs of indices (i,j) such that i<j and aj\u2212ai=j\u2212i.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "hashing",
            "math",
            "*1200"
        ],
        "solutions": "1520D - Same DifferencesLet's rewrite the original equality a bit: aj\u2212ai=j\u2212i, aj\u2212j=ai\u2212iLet's replace each ai with bi=ai\u2212i. Then the answer is the number of pairs (i,j) such that i<j and bi=bj. To calculate this value you can use map or sorting. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  map<int, int> a;\n  long long res = 0;\n  for (int i = 0; i < n; i++) {\n    int x;\n    cin >> x;\n    x -= i;\n    res += a[x];\n    a[x]++;\n  }\n  cout << res << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1520C": {
        "title": "C. Not Adjacent Matrix",
        "description": "We will consider the numbers a and b as adjacent if they differ by exactly one, that is, |a\u2212b|=1.\nWe will consider cells of a square matrix n\u00d7n as adjacent if they have a common side, that is, for cell (r,c) cells (r,c\u22121), (r,c+1), (r\u22121,c) and (r+1,c) are adjacent to it.\nFor a given number n, construct a square matrix n\u00d7n such that: \nThe first line contains one integer t (1\u2264t\u2264100). Then t test cases follow.\nEach test case is characterized by one integer n (1\u2264n\u2264100).\nFor each test case, output: \nThe matrix should be outputted as n lines, where each line contains n integers.",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "1520C - Not Adjacent MatrixAuthors: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  if (n == 1) {\n    cout << \"1\" << endl;\n    return;\n  } else if (n == 2) {\n    cout << \"-1\" << endl;\n    return;\n  }\n  vector<vector<int>> a(n, vector<int>(n));\n  a[0][0] = 1;\n  a[n - 1][n - 1] = n * n;\n  int x = n * n - 1;\n  for (int i = 1; i + 1 < n; i++) {\n    for (int j = i; j >= 0; j--, x--) {\n      a[i - j][j] = x;\n    }\n  }\n  x = 2;\n  for (int j = n - 2; j > 0; j--) {\n    for (int i = 0; i < n - j; i++, x++) {\n      a[n - i - 1][j + i] = x;\n    }\n  }\n  for (int i = n - 1; i >= 0; i--, x++) {\n    a[i][n - i - 1] = x;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cout << a[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1517B": {
        "title": "B. Morning Jogging",
        "description": "The 2050 volunteers are organizing the \"Run! Chase the Rising Sun\" activity. Starting on Apr 25 at 7:30 am, runners will complete the 6km trail around the Yunqi town.\nThere are n+1 checkpoints on the trail. They are numbered by 0, 1, ..., n. A runner must start at checkpoint 0 and finish at checkpoint n. No checkpoint is skippable\u00a0\u2014 he must run from checkpoint 0 to checkpoint 1, then from checkpoint 1 to checkpoint 2 and so on. Look at the picture in notes section for clarification.\nBetween any two adjacent checkpoints, there are m different paths to choose. For any 1\u2264i\u2264n, to run from checkpoint i\u22121 to checkpoint i, a runner can choose exactly one from the m possible paths. The length of the j-th path between checkpoint i\u22121 and i is bi,j for any 1\u2264j\u2264m and 1\u2264i\u2264n.\nTo test the trail, we have m runners. Each runner must run from the checkpoint 0 to the checkpoint n once, visiting all the checkpoints. Every path between every pair of adjacent checkpoints needs to be ran by exactly one runner. If a runner chooses the path of length li between checkpoint i\u22121 and i (1\u2264i\u2264n), his tiredness is nmini=1li, i.\u00a0e. the minimum length of the paths he takes.\nPlease arrange the paths of the m runners to minimize the sum of tiredness of them.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226410000). Description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264100).\nThe i-th of the next n lines contains m integers bi,1, bi,2, ..., bi,m (1\u2264bi,j\u2264109).\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 104.\nFor each test case, output n lines. The j-th number in the i-th line should contain the length of the path that runner j chooses to run from checkpoint i\u22121 to checkpoint i. There should be exactly m integers in the i-th line and these integers should form a permuatation of bi,1, ..., bi,m for all 1\u2264i\u2264n.\nIf there are multiple answers, print any.\nIn the first case, the sum of tiredness is min(2,5)+min(3,3)+min(4,1)=6.\nIn the second case, the sum of tiredness is min(2,4,3)+min(3,1,5)=3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1517B - Morning JoggingThe minimum sum is the sum of m smallest of all nm numbers.To construct the answer, we can just mark these m smallest numbers and put them in m different columns. A possible way is that for each row, you can sort all numbers from small to large, and rotate the marked number in this row to unmarked columns.For example,1?????23?????45 "
    },
    "1515B": {
        "title": "B. Phoenix and Puzzle",
        "description": "Phoenix is playing with a new puzzle, which consists of n identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.\nThe goal of the puzzle is to create a square using the n pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all n pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u2264109)\u00a0\u2014 the number of puzzle pieces.\nFor each test case, if Phoenix can create a square with the n puzzle pieces, print YES. Otherwise, print NO.\nFor n=2, Phoenix can create a square like this:\nFor n=4, Phoenix can create a square like this:\nFor n=6, it is impossible for Phoenix to create a square.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1515B - Phoenix and PuzzleIf n can be written as 2x or 4x, where x is a square number, then the answer is YES. Otherwise it is NO.To visualize this construction, we start by first building a smaller square using exactly 2 or 4 pieces (the drawings are in the sample test explanation). We can just use x of those smaller squares to build a larger square.Let's prove that there are no other answers (although this isn't necessary to solve the problem). Let's define each triangle piece to have a short side of length 1 and a longer side of length 2\u2013\u221a. Consider one side of the square, and suppose that it has a triangles on the short side and b triangles on the longer side. The side length will be a+2\u2013\u221ab. The area of the square is a rational number because the area of each triangle piece is rational. So, (a+2\u2013\u221ab)2 has to be rational, which means either a is 0, or b is 0. If either is 0, we can use the construction in the previous paragraph.Time complexity for each test case: O(n\u2212\u2212\u221a) or O(logn) (depends on how you check for square numbers) Solution#include <bits/stdc++.h>\nusing namespace std;\n\nbool isSquare(int x){\n  int y=sqrt(x);\n  return y*y==x;\n}\n\nvoid solve(){\n  int n;\n  cin>>n;\n  if (n%2==0 && isSquare(n/2))\n    cout<<\"YES\"<<endl;\n  else if (n%4==0 && isSquare(n/4))\n    cout<<\"YES\"<<endl;\n  else\n    cout<<\"NO\"<<endl;\n}\n\nint main(){\n  int t; cin>>t;\n  while (t--)\n    solve();\n}"
    },
    "1514B": {
        "title": "B. AND 0, Sum Big",
        "description": "Baby Badawy's first words were \"AND 0 SUM BIG\", so he decided to solve the following problem. Given two integers n and k, count the number of arrays of length n such that:\nSince the answer can be very large, print its remainder when divided by 109+7.\nThe first line contains an integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases you need to solve.\nEach test case consists of a line containing two integers n and k (1\u2264n\u2264105, 1\u2264k\u226420).\nFor each test case, print the number of arrays satisfying the conditions. Since the answer can be very large, print its remainder when divided by 109+7.\nIn the first example, the 4 arrays are:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "math",
            "*1200"
        ],
        "solutions": "1514B - AND 0, Sum BigLet's start with an array where every single bit in every single element is 1. It clearly doesn't have bitwise-and equal to 0, so for each bit, we need to turn it off (make it 0) in at least one of the elements. However, we can't turn it off in more than one element, since the sum would then decrease for no reason. So for every bit, we should choose exactly one element and turn it off there. Since there are k bits and n elements, the answer is just nk.Code link: https://pastebin.com/0D8yL5WW"
    },
    "1512D": {
        "title": "D. Corrupted Array",
        "description": "You are given a number n and an array b1,b2,\u2026,bn+2, obtained according to the following algorithm: \nFor example, the array b=[2,3,7,12,2] it could be obtained in the following ways: \nFor the given array b, find any array a that could have been guessed initially.\nThe first line contains a single integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nThe second row of each test case contains n+2 integers b1,b2,\u2026,bn+2 (1\u2264bi\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output: \nIf there are several arrays of a, you can output any.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1200"
        ],
        "solutions": "1512D - Corrupted ArrayWhat is the sum of all the elements in b? This is twice the sum of all the elements in a + x.Denote by B the sum of all the elements of b. Let's iterate over which of the array elements was added as the sum of the elements a (let's denote, for a). Then, x = B\u22122\u22c5A. It remains to check that the element x is present in the array b, this can be done using a hash table or a binary search tree. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid no() {\n  cout << \"-1\" << endl;\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> b(n + 2);\n  for (int &x : b) {\n    cin >> x;\n  }\n\n  multiset<int> have(b.begin(), b.end());\n  long long sum = accumulate(b.begin(), b.end(), 0LL);\n  for (int x : b) {\n    have.erase(have.find(x));\n    sum -= x;\n    if (sum % 2 == 0 && sum <= 2'000'000'000 && have.find(sum / 2) != have.end()) {\n      have.erase(have.find(sum / 2));\n      for (int y : have) {\n        cout << y << \" \";\n      }\n      cout << endl;\n      return;\n    }\n    sum += x;\n    have.insert(x);\n  }\n  no();\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1512C": {
        "title": "C. A-B Palindrome",
        "description": "You are given a string s consisting of the characters '0', '1', and '?'. You need to replace all the characters with '?' in the string s by '0' or '1' so that the string becomes a palindrome and has exactly a characters '0' and exactly b characters '1'. Note that each of the characters '?' is replaced independently from the others.\nA string t of length n is called a palindrome if the equality t[i]=t[n\u2212i+1] is true for all i (1\u2264i\u2264n).\nFor example, if s=\"01?????0\", a=4 and b=4, then you can replace the characters '?' in the following ways: \nFor the given string s and the numbers a and b, replace all the characters with '?' in the string s by '0' or '1' so that the string becomes a palindrome and has exactly a characters '0' and exactly b characters '1'.\nThe first line contains a single integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains two integers a and b (0\u2264a,b\u22642\u22c5105, a+b\u22651).\nThe second line of each test case contains the string s of length a+b, consisting of the characters '0', '1', and '?'.\nIt is guaranteed that the sum of the string lengths of s over all test cases does not exceed 2\u22c5105.\nFor each test case, output: \nIf there are several suitable ways to replace characters, you can output any.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "1512C - A-B PalindromeAuthor: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid no() {\n  cout << \"-1\" << endl;\n}\n\nvoid solve() {\n  int a, b;\n  cin >> a >> b;\n  string s;\n  cin >> s;\n  for (int times = 0; times < 2; times++) {\n    for (int i = 0; i < (int) s.size(); i++) {\n      int j = (int) s.size() - i - 1;\n      if (s[i] != '?') {\n        if (s[j] == '?') {\n          s[j] = s[i];\n        } else if (s[i] != s[j]) {\n          no();\n          return;\n        }\n      }\n    }\n    reverse(s.begin(), s.end());\n  }\n  a -= count(s.begin(), s.end(), '0');\n  b -= count(s.begin(), s.end(), '1');\n  int ques = count(s.begin(), s.end(), '?');\n  bool emptyMid = (s.size() % 2 == 1 && s[s.size() / 2] == '?');\n  if (a < 0 || b < 0 || a + b != ques || (emptyMid && a % 2 == 0 && b % 2 == 0)) {\n    no();\n    return;\n  }\n  if (a % 2 == 1 || b % 2 == 1) {\n    int i = s.size() / 2;\n    if (s[i] != '?') {\n      no();\n      return;\n    }\n    s[i] = (a % 2 == 1 ? '0' : '1');\n    if (a % 2 == 1) {\n      a--;\n    } else {\n      b--;\n    }\n  }\n  if (a % 2 == 1 || b % 2 == 1) {\n    no();\n    return;\n  }\n  for (int i = 0; i < (int) s.size(); i++) {\n    if (s[i] == '?') {\n      int j = s.size() - i - 1;\n      if (a > 0) {\n        a -= 2;\n        s[i] = s[j] = '0';\n      } else {\n        b -= 2;\n        s[i] = s[j] = '1';\n      }\n    }\n  }\n  cout << s << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1511C": {
        "title": "C. Yet Another Card Deck",
        "description": "You have a card deck of n cards, numbered from top to bottom, i.\u00a0e. the top card has index 1 and bottom card\u00a0\u2014 index n. Each card has its color: the i-th card has color ai.\nYou should process q queries. The j-th query is described by integer tj. For each query you should: \nThe first line contains two integers n and q (2\u2264n\u22643\u22c5105; 1\u2264q\u22643\u22c5105)\u00a0\u2014 the number of cards in the deck and the number of queries.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u226450)\u00a0\u2014 the colors of cards.\nThe third line contains q integers t1,t2,\u2026,tq (1\u2264tj\u226450)\u00a0\u2014 the query colors. It's guaranteed that queries ask only colors that are present in the deck.\nPrint q integers\u00a0\u2014 the answers for each query.\nDescription of the sample: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "trees",
            "*1100"
        ],
        "solutions": "1511C - Yet Another Card DeckLet's look at one fixed color. When we search a card of such color, we take the card with minimum index and after we place it on the top of the deck it remains the one with minimum index.It means that for each color we take and move the same card\u00a0\u2014 one card for each color. In other words, we need to keep track of only k cards, where k is the number of colors (k\u226450). As a result, if posc is the position of a card of color c then we can simulate a query in the following way: for each color c such that posc<postj we increase posc by one (since the card will move down) and then set postj=1. Complexity is O(n+qk).But, if we look closely, we may note that we don't even need array posc. We can almost manually find the first card of color tj and move it to the first position either by series of swaps or, for example, using rotate function (present in C++) and it will work fast.Why? Let's look at one color c. For the first time it will cost O(n) operations to search the corresponding card and move it to the position 1. But after that, at any moment of time, the position of the card won't exceed k, since all cards before are pairwise different (due to the nature of queries). So, all next moves the color c costs only O(k) time.As a result, the complexity of such almost naive solution is O(kn+qk). Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  scanf(\"%d%d\", &n, &q);\n  vector<int> a(n);\n  for (int& x : a) scanf(\"%d\", &x);\n  while (q--) {\n    int x;\n    scanf(\"%d\", &x);\n    int p = find(a.begin(), a.end(), x) - a.begin();\n    printf(\"%d \", p + 1);\n    rotate(a.begin(), a.begin() + p, a.begin() + p + 1);\n  }\n}"
    },
    "1511B": {
        "title": "B. GCD Length",
        "description": "You are given three integers a, b and c.\nFind two positive integers x and y (x>0, y>0) such that: \ngcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\nOutput x and y. If there are multiple answers, output any of them.\nThe first line contains a single integer t (1\u2264t\u2264285)\u00a0\u2014 the number of testcases.\nEach of the next t lines contains three integers a, b and c (1\u2264a,b\u22649, 1\u2264c\u2264min(a,b))\u00a0\u2014 the required lengths of the numbers.\nIt can be shown that the answer exists for all testcases under the given constraints.\nAdditional constraint on the input: all testcases are different.\nFor each testcase print two positive integers\u00a0\u2014 x and y (x>0, y>0) such that \nIn the example: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1511B - GCD LengthIdea: BledDest TutorialTutorial is loading... Solution (awoo)for t in range(int(input())):\n\ta, b, c = map(int, input().split())\n\tprint(\"1\" + \"0\" * (a - 1), \"1\" * (b - c + 1) + \"0\" * (c - 1))"
    },
    "1510K": {
        "title": "K. King's Task",
        "description": "The brave Knight came to the King and asked permission to marry the princess. The King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.\nThere is a permutation pi of numbers from 1 to 2n. You can make two types of operations. \nThe task is to find the minimal number of operations required to sort the given permutation.\nThe Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.\nThe first line contains the integer n (1\u2264n\u22641000). The second line contains 2n integers pi\u00a0\u2014 the permutation of numbers from 1 to 2n.\nPrint one integer\u00a0\u2014 the minimal number of operations required to sort the permutation. If it is impossible to sort the permutation using these operations, print \u22121.\nIn the first example, you can sort the permutation in three operations: ",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "graphs",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1509B": {
        "title": "B. TMT Document",
        "description": "The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.\nHowever, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length n whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.\nA string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero) characters.\nThe first line contains an integer t (1\u2264t\u22645000) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (3\u2264n<105), the number of characters in the string entered in the document. It is guaranteed that n is divisible by 3.\nThe second line of each test case contains a string of length n consisting of only the characters T and M.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print a single line containing YES if the described partition exists, and a single line containing NO otherwise.\nIn the first test case, the string itself is already a sequence equal to TMT.\nIn the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1100"
        ],
        "solutions": "1509B - TMT DocumentThere are many slightly different solutions, all based on some sort of greedy idea. Write n=3k for convenience. Obviously, the string must have k characters M and 2k characters T for the partition to be possible, so we can just discard all other cases.Now, let's consider the first M character in the string. This must be part of some TMT subsequence, so we must choose a T character to its left to work as the first character of this subsequence. Which character should we choose? Well, it seems intuitive to match it with the first T character we find going from left to right - it is certainly not the right character of any sequence, and it seems like a good idea to assign it to the first M character since characters that are further to the right may be too far right to match with this character.Continuing this idea, we come up with the following greedy algorithm: Take the first k T characters and use them as the first characters of the subsequences, matching them with the k M characters from left to right greedily. Similarly, take the last k T characters and match them with each M character from left to right greedily. If either of these steps fails, the partition is impossible. This can be formalized into the following observation, which is both easy to prove and gives a solution that is very easy to implement.Claim. Let m1<m2<\u22ef<mk be the positions of the M characters and let t1<t2<\u22ef<t2k be the positions of the T characters. Then the partition exists if and only if ti<mi<ti+k for 1\u2264i\u2264k.Proof. If the condition holds then we can just choose the k subsequences with indices (ti,mi,ti+k), so it is sufficient. To see that it's necessary, consider the first i M characters with indices m1,m2,\u2026,mi, and consider the left T characters in the subsequence they're in. These are to the left of their corresponding M characters, and in particular they are to the left of the i-th M character. Thus there's at least i T characters to the left of the i-th M character, meaning ti<mi. The other inequality is proved similarly. Comments from the authorsDo yourself a favor and listen to Towa-sama's singing! Here are some links to cool songs.Implementation"
    },
    "1506C": {
        "title": "C. Double-ended Strings",
        "description": "You are given the strings a and b, consisting of lowercase Latin letters. You can do any number of the following operations in any order: \nNote that after each of the operations, the string a or b may become empty.\nFor example, if a=\"hello\" and b=\"icpc\", then you can apply the following sequence of operations: \nFor the given strings a and b, find the minimum number of operations for which you can make the strings a and b equal. Note that empty strings are also equal.\nThe first line contains a single integer t (1\u2264t\u2264100). Then t test cases follow.\nThe first line of each test case contains the string a (1\u2264|a|\u226420), consisting of lowercase Latin letters.\nThe second line of each test case contains the string b (1\u2264|b|\u226420), consisting of lowercase Latin letters.\nFor each test case, output the minimum number of operations that can make the strings a and b equal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1506C - Double-ended StringsRegarding to the small constraints, in this problem you could iterate over how many characters were removed by each type of operation. If l characters at the beginning and x characters at the end are removed from the string s, then the substring s[l+1,n\u2212x] remains, where n\u00a0\u2014 is the length of the string s.There is also a fast solution to this problem using dynamic programming. Solution#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n    string a, b;\n    cin >> a >> b;\n    int n = a.size(), m = b.size();\n    int ans = 0;\n    for (int len = 1; len <= min(n, m); len++) {\n        for (int i = 0; i + len <= n; i++) {\n            for (int j = 0; j + len <= m; j++) {\n                if (a.substr(i, len) == b.substr(j, len)) {\n                    ans = max(ans, len);\n                }\n            }\n        }\n    }\n    cout << a.size() + b.size() - 2 * ans << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int n;\n    cin >> n;\n    while (n--) {\n        solve();\n    }\n}"
    },
    "1506B": {
        "title": "B. Partial Replacement",
        "description": "You are given a number k and a string s of length n, consisting of the characters '.' and '*'. You want to replace some of the '*' characters with 'x' characters so that the following conditions are met: \nFor example, if n=7, s=.**.*** and k=3, then the following strings will satisfy the conditions above: \nGiven n, k, and s, find the minimum number of '*' characters that must be replaced with 'x' in order to meet the above conditions.\nThe first line contains one integer t (1\u2264t\u2264500). Then t test cases follow.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u226450).\nThe second line of each test case contains a string s of length n, consisting of the characters '.' and '*'.\nIt is guaranteed that there is at least one '*' in the string s.\nIt is guaranteed that the distance between any two neighboring '*' characters does not exceed k.\nFor each test case output the minimum number of '*' characters that must be replaced with 'x' characters in order to satisfy the conditions above.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1506B - Partial ReplacementProblem author: MikeMirzayanov EditorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  string s;\n  cin >> s;\n  int res = 1;\n  int i = s.find_first_of('*');\n  while (true) {\n    int j = min(n - 1, i + k);\n    for (; i < j && s[j] == '.'; j--) {}\n    if (i == j) {\n      break;\n    }\n    res++;\n    i = j;\n  }\n  cout << res << \"\\n\";\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1504B": {
        "title": "B. Flip the Bits",
        "description": "There is a binary string a of length n. In one operation, you can select any prefix of a with an equal number of 0 and 1 symbols. Then all symbols in the prefix are inverted: each 0 becomes 1 and each 1 becomes 0.\nFor example, suppose a=0111010000. \nCan you transform the string a into the string b using some finite number of operations (possibly, none)?\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105) \u2014 the length of the strings a and b.\nThe following two lines contain strings a and b of length n, consisting of symbols 0 and 1.\nThe sum of n across all test cases does not exceed 3\u22c5105.\nFor each test case, output \"YES\" if it is possible to transform a into b, or \"NO\" if it is impossible. You can print each letter in any case (upper or lower).\nThe first test case is shown in the statement.\nIn the second test case, we transform a into b by using zero operations.\nIn the third test case, there is no legal operation, so it is impossible to transform a into b.\nIn the fourth test case, here is one such transformation: \nIn the fifth test case, the only legal operation is to transform a into 111000. From there, the only legal operation is to return to the string we started with, so we cannot transform a into b.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1504B - Flip the BitsLet's call a prefix legal if it contains an equal number of 0 and 1 symbols. The key observation is that applying operations never changes which prefixes are legal. In fact, suppose we apply an operation to a prefix of length i, and consider a prefix of length j. We want to show that if j was legal before, it remains legal. And if it wasn't legal, it won't become legal.  If j<i, then all bits in the length j prefix are inverted. The numbers of 0's and 1's swap, so it cannot change whether they are equal, and hence it cannot change whether j is legal.  If j\u2265i, then i/2 of the 0 symbols become 1 and i/2 of the 1 symbols become 0. So the numbers of both symbols do not change, so it cannot change whether j is legal. Using prefix sums, we can determine for each prefix whether it is legal.Consider an index i. If i=n and an\u2260bn, then we must flip the length n prefix at some point. If i<n and ai=bi, ai+1\u2260bi+1, or ai\u2260bi, ai+1=bi+1, then we must flip the length i prefix at some point. If we flip precisely these prefixes in any order, it will transform a into b. So we should simply check that every prefix that must be flipped is legal.Complexity is O(n).Implementation"
    },
    "1499B": {
        "title": "B. Binary Removals",
        "description": "You are given a string ss, consisting only of characters '0' or '1'. Let |s||s| be the length of ss.\nYou are asked to choose some integer kk (k>0k>0) and find a sequence aa of length kk such that: \nThe characters at positions a1,a2,\u2026,aka1,a2,\u2026,ak are removed, the remaining characters are concatenated without changing the order. So, in other words, the positions in the sequence aa should not be adjacent.\nLet the resulting string be s\u2032s\u2032. s\u2032s\u2032 is called sorted if for all ii from 22 to |s\u2032||s\u2032| s\u2032i\u22121\u2264s\u2032is\u2032i\u22121\u2264s\u2032i.\nDoes there exist such a sequence aa that the resulting string s\u2032s\u2032 is sorted?\nThe first line contains a single integer tt (1\u2264t\u226410001\u2264t\u22641000)\u00a0\u2014 the number of testcases.\nThen the descriptions of tt testcases follow.\nThe only line of each testcase contains a string ss (2\u2264|s|\u22641002\u2264|s|\u2264100). Each character is either '0' or '1'.\nFor each testcase print \"YES\" if there exists a sequence aa such that removing the characters at positions a1,a2,\u2026,aka1,a2,\u2026,ak and concatenating the parts without changing the order produces a sorted string.\nOtherwise, print \"NO\".\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as positive answer).\nIn the first testcase you can choose a sequence a=[1,3,6,9]a=[1,3,6,9]. Removing the underlined letters from \"10101011011\" will produce a string \"0011111\", which is sorted.\nIn the second and the third testcases the sequences are already sorted.\nIn the fourth testcase you can choose a sequence a=[3]a=[3]. s\u2032=s\u2032= \"11\", which is sorted.\nIn the fifth testcase there is no way to choose a sequence aa such that s\u2032s\u2032 is sorted.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1499B - Binary RemovalsThere are several different ways to solve this problem. In my opinion, the two easiest solutions are:  notice that, in the sorted string, there is a prefix of zeroes and a suffix of ones. It means that we can iterate on the prefix (from which we remove all ones), and remove all zeroes from the suffix we obtain. If we try to remove two adjacent characters, then we cannot use this prefix;  if there is a substring 11 before the substring 00 in our string, then from both of the substrings, at least one character remains, so if the first occurrence of 11 is earlier than the last occurrence of 00, there is no answer. Otherwise, the answer always exists.  Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    string s;\n    cin >> s;\n    int i = s.find(\"11\");\n    int j = s.rfind(\"00\");\n    cout << (i != -1 && j != -1 && i < j ? \"NO\" : \"YES\") << endl;\n  }\n}"
    },
    "1497C1": {
        "title": "C1. k-LCM (easy version)",
        "description": "It is the easy version of the problem. The only difference is that in this version k=3.\nYou are given a positive integer n. Find k positive integers a1,a2,\u2026,ak, such that:\nHere LCM is the least common multiple of numbers a1,a2,\u2026,ak.\nWe can show that for given constraints the answer always exists.\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n, k (3\u2264n\u2264109, k=3).\nFor each test case print k positive integers a1,a2,\u2026,ak, for which all conditions are satisfied.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1497C1 - k-LCM (easy version)  If n is odd, then the answer is (1,\u230an2\u230b,\u230an2\u230b)  If n is even, but is not a multiple of 4, then the answer is (n2\u22121,n2\u22121,2).  If n is a multiple of 4, then the answer is (n2,n4,n4).  Implementation// \u0442\u0440\u0438 \u043c\u0430\u043d\u0443\u043b\u0430\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int T;\n    cin >> T;\n    while (T --> 0) {\n        int n, k;\n        cin >> n >> k;\n        if (n % 2) cout << 1 << ' ' << n / 2 << ' ' << n / 2 << '\\n';\n        else if (n % 2 == 0 && n % 4) cout << 2 << ' ' << n / 2 - 1 << ' ' << n / 2  - 1 << '\\n';\n        else cout << n / 2 << ' ' << n / 4 << ' ' << n / 4 << '\\n';\n    }\n    return 0;\n}"
    },
    "1497B": {
        "title": "B. M-arrays",
        "description": "You are given an array a1,a2,\u2026,an consisting of n positive integers and a positive integer m.\nYou should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.\nLet's call an array m-divisible if for each two adjacent numbers in the array (two numbers on the positions i and i+1 are called adjacent for each i) their sum is divisible by m. An array of one element is m-divisible.\nFind the smallest number of m-divisible arrays that a1,a2,\u2026,an is possible to divide into.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n, m (1\u2264n\u2264105,1\u2264m\u2264105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n and the sum of m over all test cases do not exceed 105.\nFor each test case print the answer to the problem.\nIn the first test case we can divide the elements as follows:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1497B - M-arraysIdea: Artyom123 TutorialTutorial is loading... Implementation//\u0434\u0432\u0430 \u043c\u0430\u043d\u0443\u043b\u0430\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        map<int, int> cnt;\n        while (n--) {\n            int x;\n            cin >> x;\n            cnt[x % m]++;\n        }\n        int ans = 0;\n        for (auto &c : cnt) {\n            if (c.first == 0) ans++;\n            else if (2 * c.first == m) {\n                ans++;\n            } else if (2 * c.first < m || cnt.find(m - c.first) == cnt.end()) {\n                int x = c.second, y = cnt[m - c.first];\n                ans += 1 + max(0, abs(x - y) - 1);\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}"
    },
    "1496B": {
        "title": "B. Max and Mex",
        "description": "You are given a multiset S initially consisting of n distinct non-negative integers. A multiset is a set, that can contain some elements multiple times.\nYou will perform the following operation k times: \nHere max of a multiset denotes the maximum integer in the multiset, and mex of a multiset denotes the smallest non-negative integer that is not present in the multiset. For example: \nYour task is to calculate the number of distinct elements in S after k operations will be done.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n, k (1\u2264n\u2264105, 0\u2264k\u2264109)\u00a0\u2014 the initial size of the multiset S and how many operations you need to perform.\nThe second line of each test case contains n distinct integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the numbers in the initial multiset.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the number of distinct elements in S after k operations will be done.\nIn the first test case, S={0,1,3,4}, a=mex(S)=2, b=max(S)=4, \u2308a+b2\u2309=3. So 3 is added into S, and S becomes {0,1,3,3,4}. The answer is 4.\nIn the second test case, S={0,1,4}, a=mex(S)=2, b=max(S)=4, \u2308a+b2\u2309=3. So 3 is added into S, and S becomes {0,1,3,4}. The answer is 4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1496B - Max and MexLet a=max(S),b=mex(S).When k=0, the answer is n.Otherwise if b>a, then b=a+1 , so \u2308a+b2\u2309=b . It's not hard to find out that max(S\u222a{b})=b,mex(S\u222a{b})=b+1, so the set S always satisfies max(S)+1=mex(S). So the answer is n+k when b=a+1.Otherwise b<a. So b<a\u21d22b<a+b\u21d2a+b2>b\u21d2\u2308a+b2\u2309>b. In that case mex(S)=b is always true. So the element we add in all operations is always \u2308a+b2\u2309. Just check whether it is in S at first.The time complexity is O(n) or O(nlogn) for each test case depending on your implementation. Solution (waaitg)109637470"
    },
    "1495A": {
        "title": "A. Diamond Miner",
        "description": "Diamond Miner is a game that is similar to Gold Miner, but there are n miners instead of 1 in this game.\nThe mining area can be described as a plane. The n miners can be regarded as n points on the y-axis. There are n diamond mines in the mining area. We can regard them as n points on the x-axis. For some reason, no miners or diamond mines can be at the origin (point (0,0)). \nEvery miner should mine exactly one diamond mine. Every miner has a hook, which can be used to mine a diamond mine. If a miner at the point (a,b) uses his hook to mine a diamond mine at the point (c,d), he will spend \u221a(a\u2212c)2+(b\u2212d)2 energy to mine it (the distance between these points). The miners can't move or help each other.\nThe object of this game is to minimize the sum of the energy that miners spend. Can you find this minimum?\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of miners and mines.\nEach of the next 2n lines contains two space-separated integers x (\u2212108\u2264x\u2264108) and y (\u2212108\u2264y\u2264108), which represent the point (x,y) to describe a miner's or a diamond mine's position. Either x=0, meaning there is a miner at the point (0,y), or y=0, meaning there is a diamond mine at the point (x,0). There can be multiple miners or diamond mines at the same point.\nIt is guaranteed that no point is at the origin. It is guaranteed that the number of points on the x-axis is equal to n and the number of points on the y-axis is equal to n.\nIt's guaranteed that the sum of n for all test cases does not exceed 105.\nFor each test case, print a single real number \u2014 the minimal sum of energy that should be spent.\nYour answer is considered correct if its absolute or relative error does not exceed 10\u22129.\nFormally, let your answer be a, and the jury's answer be b. Your answer is accepted if and only if |a\u2212b|max(1,|b|)\u226410\u22129.\nIn the first test case, the miners are at (0,1) and (0,\u22121), while the diamond mines are at (1,0) and (\u22122,0). If you arrange the miners to get the diamond mines in the way, shown in the picture, you can get the sum of the energy \u221a2+\u221a5.\n",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solutions": "1495A - Diamond MinerIdea: smg23333 Tutorial is loading... Solution (smg23333)109637538"
    },
    "1492B": {
        "title": "B. Card Deck",
        "description": "You have a deck of n cards, and you'd like to reorder it to a new one.\nEach card has a value between 1 and n equal to pi. All pi are pairwise distinct. Cards in a deck are numbered from bottom to top, i.\u00a0e. p1 stands for the bottom card, pn is the top card. \nIn each step you pick some integer k>0, take the top k cards from the original deck and place them, in the order they are now, on top of the new deck. You perform this operation until the original deck is empty. (Refer to the notes section for the better understanding.)\nLet's define an order of a deck as n\u2211i=1nn\u2212i\u22c5pi.\nGiven the original deck, output the deck with maximum possible order you can make using the operation above.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains the single integer n (1\u2264n\u2264105)\u00a0\u2014 the size of deck you have.\nThe second line contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n; pi\u2260pj if i\u2260j)\u00a0\u2014 values of card in the deck from bottom to top.\nIt's guaranteed that the sum of n over all test cases doesn't exceed 105.\nFor each test case print the deck with maximum possible order. Print values of cards in the deck from bottom to top.\nIf there are multiple answers, print any of them.\nIn the first test case, one of the optimal strategies is the next one: \nIn the second test case, one of the optimal strategies is: \nIn the third test case, one of the optimal strategies is: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1492B - Card DeckIt's easy to prove that order of a deck differs for different permutations. And more than that order of permutation a is greater than order of permutation b if and only if a is lexicographically greater than b.Since we need to build a lexicographic maximum permutation, at each point of time we need to choose such k that k-th element from the top of the original deck is the maximum element in this deck. Total complexity is O(nlogn) or O(n) (depending on the implementation). "
    },
    "1491B": {
        "title": "B. Minimal Cost",
        "description": "There is a graph of n rows and 106+2 columns, where rows are numbered from 1 to n and columns from 0 to 106+1:\nLet's denote the node in the row i and column j by (i,j).\nInitially for each i the i-th row has exactly one obstacle \u2014 at node (i,ai). You want to move some obstacles so that you can reach node (n,106+1) from node (1,0) by moving through edges of this graph (you can't pass through obstacles). Moving one obstacle to an adjacent by edge free node costs u or v coins, as below:\nRefer to the picture above for a better understanding. \nNow you need to calculate the minimal number of coins you need to spend to be able to reach node (n,106+1) from node (1,0) by moving through edges of this graph without passing through obstacles.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains three integers n, u and v (2\u2264n\u2264100, 1\u2264u,v\u2264109)\u00a0\u2014 the number of rows in the graph and the numbers of coins needed to move vertically and horizontally respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 where ai represents that the obstacle in the i-th row is in node (i,ai).\nIt's guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5104.\nFor each test case, output a single integer\u00a0\u2014 the minimal number of coins you need to spend to be able to reach node (n,106+1) from node (1,0) by moving through edges of this graph without passing through obstacles.\nIt can be shown that under the constraints of the problem there is always a way to make such a trip possible.\nIn the first sample, two obstacles are at (1,2) and (2,2). You can move the obstacle on (2,2) to (2,3), then to (1,3). The total cost is u+v=7 coins.\nIn the second sample, two obstacles are at (1,3) and (2,2). You can move the obstacle on (1,3) to (2,3). The cost is u=3 coins.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1200"
        ],
        "solutions": "1491B - Minimal CostSetter: syksykCCCPrepared by: syksykCCC  Hint 1When is the answer 0? Or rather, when do you not have to make any moves? Hint 2What happens if a[i] is same for all i? SolutionConsider the following situations:  \u2200i\u2208[2,n],|ai\u2212ai\u22121|=0, then the answer will be v+min(u,v). \u2203i\u2208[2,n],|ai\u2212ai\u22121|>1, then the answer will be 0. Otherwise, the answer will be min(u,v).  Code (C++)#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5;\nint n, a[N], ans = INT_MAX, u, v, T;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>T;\n\twhile(T--){\n\t    ans = INT_MAX;\n\t    cin >> n >> u >> v;\n\t    for(int i = 1; i <= n; i++)\n\t\t    cin >> a[i];\n\t    for(int i = 2; i <= n; i++)\n\t    {\n\t\t    if(abs(a[i] - a[i - 1]) >= 2) ans = 0;\n\t    \tif(abs(a[i] - a[i - 1]) == 1) ans = min(ans, min(u, v));\n\t\t    if(a[i] == a[i - 1]) ans = min(ans, v + min(u, v));\n\t    }\n\t    cout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1490D": {
        "title": "D. Permutation Transformation",
        "description": "A permutation\u00a0\u2014 is a sequence of length n integers from 1 to n, in which all the numbers occur exactly once. For example, [1], [3,5,2,1,4], [1,3,2]\u00a0\u2014 permutations, and [2,3,2], [4,3,1], [0]\u00a0\u2014 no.\nPolycarp was recently gifted a permutation a[1\u2026n] of length n. Polycarp likes trees more than permutations, so he wants to transform permutation a into a rooted binary tree. He transforms an array of different integers into a tree as follows: \nFor example, if he builds a tree by permutation a=[3,5,2,1,4], then the root will be the element a2=5, and the left subtree will be the tree that will be built for the subarray a[1\u20261]=[3], and the right one \u2014 for the subarray a[3\u20265]=[2,1,4]. As a result, the following tree will be built: \nAnother example: let the permutation be a=[1,3,2,7,5,6,4]. In this case, the tree looks like this: \nLet us denote by dv the depth of the vertex av, that is, the number of edges on the path from the root to the vertex numbered av. Note that the root depth is zero. Given the permutation a, for each vertex, find the value of dv.\nThe first line contains one integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains an integer n (1\u2264n\u2264100)\u00a0\u2014 the length of the permutation.\nThis is followed by n numbers a1,a2,\u2026,an\u00a0\u2014 permutation a.\nFor each test case, output n values\u00a0\u2014 d1,d2,\u2026,dn.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "divide and conquer",
            "implementation",
            "*1200"
        ],
        "solutions": "1490D - Permutation TransformationWe will construct the required tree recursively. Let us describe the state of tree construction by three values (l,r,d), where [l,r]\u00a0\u2014 is the segment of the permutation, and d\u00a0\u2014 is the current depth. Then the following transitions can be described:   find the position m of the maximum element on the segment [l,r], that is, am=maxi=lrai;  the depth of the vertex am is equal to d;  if l<m, then make the transition to the state (l,m\u22121,d+1);  if m<r, then make the transition to the state (m+1,r,d+1); Then, in order to construct the required tree, it is necessary to take (1,n,0) as the initial state. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid build(int l, int r, vector<int> const &a, vector<int> &d, int curD = 0) {\n  if (r < l) {\n    return;\n  }\n  if (l == r) {\n    d[l] = curD;\n    return;\n  }\n  int m = l;\n  for (int i = l + 1; i <= r; i++) {\n    if (a[m] < a[i]) {\n      m = i;\n    }\n  }\n  d[m] = curD;\n  build(l, m - 1, a, d, curD + 1);\n  build(m + 1, r, a, d, curD + 1);\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n  vector<int> d(n);\n  build(0, n - 1, a, d);\n  for (int x :d) {\n    cout << x << \" \";\n  }\n  cout << endl;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}"
    },
    "1490C": {
        "title": "C. Sum of Cubes",
        "description": "You are given a positive integer x. Check whether the number x is representable as the sum of the cubes of two positive integers.\nFormally, you need to check if there are two integers a and b (1\u2264a,b) such that a3+b3=x.\nFor example, if x=35, then the numbers a=2 and b=3 are suitable (23+33=8+27=35). If x=4, then no pair of numbers a and b is suitable.\nThe first line contains one integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Then t test cases follow.\nEach test case contains one integer x (1\u2264x\u22641012).\nPlease note, that the input for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language.\nFor each test case, output on a separate line: \nYou can output \"YES\" and \"NO\" in any case (for example, the strings yEs, yes, Yes and YES will be recognized as positive).\nThe number 1 is not representable as the sum of two cubes.\nThe number 2 is represented as 13+13.\nThe number 4 is not representable as the sum of two cubes.\nThe number 34 is not representable as the sum of two cubes.\nThe number 35 is represented as 23+33.\nThe number 16 is represented as 23+23.\nThe number 703657519796 is represented as 57793+79933.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "brute force",
            "math",
            "*1100"
        ],
        "solutions": "1490C - Sum of CubesProblem author: MikeMirzayanov EditorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst ll N = 1'000'000'000'000L;\n\nunordered_set<ll> cubes;\n\nvoid precalc() {\n  for (ll i = 1; i * i * i <= N; i++) {\n    cubes.insert(i * i * i);\n  }\n}\n\nvoid solve() {\n  ll x;\n  cin >> x;\n  for (ll i = 1; i * i * i <= x; i++) {\n    if (cubes.count(x - i * i * i)) {\n      cout << \"YES\\n\";\n      return;\n    }\n  }\n  cout << \"NO\\n\";\n}\n\nint main() {\n  precalc();\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}"
    },
    "1490B": {
        "title": "B. Balanced Remainders",
        "description": "You are given a number n (divisible by 3) and an array a[1\u2026n]. In one move, you can increase any of the array elements by one. Formally, you choose the index i (1\u2264i\u2264n) and replace ai with ai+1. You can choose the same index i multiple times for different moves.\nLet's denote by c0, c1 and c2 the number of numbers from the array a that have remainders 0, 1 and 2 when divided by the number 3, respectively. Let's say that the array a has balanced remainders if c0, c1 and c2 are equal.\nFor example, if n=6 and a=[0,2,5,5,4,8], then the following sequence of moves is possible: \nFind the minimum number of moves needed to make the array a have balanced remainders.\nThe first line contains one integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains one integer n (3\u2264n\u22643\u22c5104)\u00a0\u2014 the length of the array a. It is guaranteed that the number n is divisible by 3.\nThe next line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264100).\nIt is guaranteed that the sum of n over all test cases does not exceed 150000.\nFor each test case, output one integer\u00a0\u2014 the minimum number of moves that must be made for the a array to make it have balanced remainders.\nThe first test case is explained in the statements.\nIn the second test case, you need to make one move for i=2.\nThe third test case you need to make three moves: \nIn the fourth test case, the values c0, c1 and c2 initially equal to each other, so the array a already has balanced remainders.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solutions": "1490B - Balanced RemaindersProblem author: MikeMirzayanov EditorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n\n  int res = 0;\n  vector<int> cnt(3);\n  for (int x = 0; x <= 2; x++) {\n      for (int i = 0; i < n; i++) {\n          if (a[i] % 3 == x) {\n              cnt[x]++;\n          }\n      }\n  }\n  \n  while (*min_element(cnt.begin(), cnt.end()) != n / 3) {\n      for (int i = 0; i < 3; i++) {\n          if (cnt[i] > n / 3) {\n              res++;\n              cnt[i]--;\n              cnt[(i + 1) % 3]++;\n          }\n      }\n  }\n  cout << res << endl;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}"
    },
    "1487B": {
        "title": "B. Cat Cycle",
        "description": "Suppose you are living with two cats: A and B. There are n napping spots where both cats usually sleep.\nYour cats like to sleep and also like all these spots, so they change napping spot each hour cyclically: \nThe cat B is much younger, so they have a strict hierarchy: A and B don't lie together. In other words, if both cats'd like to go in spot x then the A takes this place and B moves to the next place in its order (if x<n then to x+1, but if x=n then to 1). Cat B follows his order, so it won't return to the skipped spot x after A frees it, but will move to the spot x+2 and so on.\nCalculate, where cat B will be at hour k?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (2\u2264n\u2264109; 1\u2264k\u2264109)\u00a0\u2014 the number of spots and hour k.\nFor each test case, print one integer\u00a0\u2014 the index of the spot where cat B will sleep at hour k.\nIn the first and second test cases n=2, so: \nIn the sixth test case: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1487B - Cat CycleIf n is even, then each hour A and B are on the spots with different parity, so they will never meet. Otherwise, let's look closely what happens.At the start, A in n and B in 1. But since we can form a cycle from spots then it means that n and 1 in reality are neighbors. After that, A and B (starting from neighboring positions) just go in opposite directions and meet each other in the opposite spot after exactly \u230an2\u230b steps.After meeting B \"jumps over\" A making 1 extra step and the situation become practically the same: A and B are neighbors and move in the opposite direction.In other words, each f=\u230an2\u230b steps B makes one extra step, so the answer (if both k and spots are 0-indexed) is (k+(nmod2)\u22c5\u230akf\u230b)modn Solution (adedalic)fun main() {\n    repeat(readLine()!!.toInt()) {\n        var (n, k) = readLine()!!.split(' ').map { it.toInt() }\n        k--\n        val floor = n / 2\n        println((k + (n % 2) * k / floor) % n + 1)\n    }\n}"
    },
    "1485B": {
        "title": "B. Replace and Keep Sorted",
        "description": "Given a positive integer k, two arrays are called k-similar if:\nYou are given an integer k, a strictly increasing array a and q queries. For each query, you are given two integers li\u2264ri. Your task is to find how many arrays b exist, such that b is k-similar to array [ali,ali+1\u2026,ari]. \nThe first line contains three integers n, q and k (1\u2264n,q\u2264105, n\u2264k\u2264109)\u00a0\u2014 the length of array a, the number of queries and number k.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264k). This array is strictly increasing \u00a0\u2014 a1<a2<\u2026<an.\nEach of the following q lines contains two integers li, ri (1\u2264li\u2264ri\u2264n).\nPrint q lines. The i-th of them should contain the answer to the i-th query.\nIn the first example:\nIn the first query there are 4 arrays that are 5-similar to [2,4]: [1,4],[3,4],[2,3],[2,5].\nIn the second query there are 3 arrays that are 5-similar to [4,5]: [1,5],[2,5],[3,5].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1485B - Replace and Keep SortedAuthor: TheScrasse Preparation: Kaey Hint 1You can make a k-similar array by assigning ai=x for some l\u2264i\u2264r and 1\u2264x\u2264k.  Hint 2How many k-similar arrays can you make if x is already equal to some ai (l\u2264i\u2264r)? Hint 3How many k-similar arrays can you make if either x<al or x>ar? Hint 4How many k-similar arrays can you make if none of the previous conditions holds? SolutionLet's consider each value x from 1 to k.  If x<al, you can replace al with x (and you get 1 k-similar array). There are al\u22121 such values of x. If x>ar, you can replace ar with x (and you get 1 k-similar array). There are k\u2212ar such values of x. If al<x<ar, and x\u2260ai for all i in [l,r], you can either replace the rightmost bi which is less than x, or the leftmost bi which is greater than x (and you get 2 k-similar arrays). There are (ar\u2212al+1)\u2212(r\u2212l+1) such values of x. If x=ai for some i in [l,r], no k-similar arrays can be made. The total count is (al\u22121)+(k\u2212ar)+2((ar\u2212al+1)\u2212(r\u2212l+1)), which simplifies to k+(ar\u2212al+1)\u22122(r\u2212l+1).Complexity: O(n+q).Official solution: 107232462"
    },
    "1485A": {
        "title": "A. Add and Divide",
        "description": "You have two positive integers a and b.\nYou can perform two kinds of operations:\nFind the minimum number of operations required to make a=0.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThe only line of the description of each test case contains two integers a, b (1\u2264a,b\u2264109).\nFor each test case, print a single integer: the minimum number of operations required to make a=0.\nIn the first test case, one of the optimal solutions is:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1485A - Add and DivideAuthor: TheScrasse Preparation: MyK_00L Hint 1Suppose that you can use x operations of type 1 and y operations of type 2. Try to reorder the operations in such a way that a becomes the minimum possible. Hint 2You should use operations of type 2 first, then moves of type 1. How many operations do you need in the worst case? (a=109, b=1) Hint 3You need at most 30 operations. Iterate over the number of operations of type 2. SolutionNotice how it is never better to increase b after dividing (\u230aab+1\u230b\u2264\u230aab\u230b).So we can try to increase b to a certain value and then divide a by b until it is 0. Being careful as not to do this with b<2, the number of times we divide is going to be O(loga). In particular, if you reach b\u22652 (this requires at most 1 move), you need at most \u230alog2(109)\u230b=29 moves to finish.Let y be the number of moves of type 2; we can try all values of y (0\u2264y\u226430) and, for each y, check how many moves of type 1 are necessary.Complexity: O(log2a).If we notice that it is never convenient to increase b over 6, we can also achieve a solution with better complexity.Official solution: 107232596"
    },
    "1481B": {
        "title": "B. New Colony",
        "description": "After reaching your destination, you want to build a new colony on the new planet. Since this planet has many mountains and the colony must be built on a flat surface you decided to flatten the mountains using boulders (you are still dreaming so this makes sense to you).\nYou are given an array h1,h2,\u2026,hn, where hi is the height of the i-th mountain, and k\u00a0\u2014 the number of boulders you have.\nYou will start throwing boulders from the top of the first mountain one by one and they will roll as follows (let's assume that the height of the current mountain is hi): \nYou want to find the position of the k-th boulder or determine that it will fall into the waste collection system.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nEach test case consists of two lines. The first line in each test case contains two integers n and k (1\u2264n\u2264100; 1\u2264k\u2264109)\u00a0\u2014 the number of mountains and the number of boulders.\nThe second line contains n integers h1,h2,\u2026,hn (1\u2264hi\u2264100)\u00a0\u2014 the height of the mountains.\nIt is guaranteed that the sum of n over all test cases does not exceed 100.\nFor each test case, print \u22121 if the k-th boulder will fall into the collection system. Otherwise, print the position of the k-th boulder.\nLet's simulate the first case:\nThe positions where each boulder stopped are the following: [2,3,2].\nIn the second case, all 7 boulders will stop right at the first mountain rising its height from 1 to 8.\nThe third case is similar to the first one but now you'll throw 5 boulders. The first three will roll in the same way as in the first test case. After that, mountain heights will be equal to [4,3,3,3], that's why the other two boulders will fall into the collection system.\nIn the fourth case, the first and only boulders will fall straight into the collection system.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1481B - New ColonyThe two key observation here is that if one boulder fall into the collection system all later boulders will fall into the collection system too and the number of boulders that will end up at any mountain is too small (Hence it will be at most (n\u22121)\u22c5(100\u22121)).So we can simulate all boulders throwing until one boulder fall into the collection system, this will take at most O(100\u22c5n). code#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n#define fast ios::sync_with_stdio(false);cin.tie(0);\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n\tfast\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n,k;\n\t\tcin>>n>>k;\n\t\tvector<int> a(n);\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tint mx = *max_element(all(a));\n\t\tif(n * mx < k){\n\t\t\tcout << -1 << '\\n';\n\t\t\tcontinue;\n\t\t}\n\t\tint ans = n+1;\n\t\tfor(int b=0;b<k;b++){\n\t\t\tint to = -2;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tif(a[i] < a[i+1]){\n\t\t\t\t\tto = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = to + 1;\n\t\t\tif(to == -2)break;\n\t\t\ta[to]++;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\t\n}Author: Warawreh "
    },
    "1478B": {
        "title": "B. Nezzar and Lucky Number",
        "description": "Nezzar's favorite digit among 1,\u2026,9 is d. He calls a positive integer lucky if d occurs at least once in its decimal representation. \nGiven q integers a1,a2,\u2026,aq, for each 1\u2264i\u2264q Nezzar would like to know if ai can be equal to a sum of several (one or more) lucky numbers.\nThe first line contains a single integer t (1\u2264t\u22649) \u2014 the number of test cases.\nThe first line of each test case contains two integers q and d (1\u2264q\u2264104, 1\u2264d\u22649).\nThe second line of each test case contains q integers a1,a2,\u2026,aq (1\u2264ai\u2264109).\nFor each integer in each test case, print \"YES\" in a single line if ai can be equal to a sum of lucky numbers. Otherwise, print \"NO\".\nYou can print letters in any case (upper or lower).\nIn the first test case, 24=17+7, 27 itself is a lucky number, 25 cannot be equal to a sum of lucky numbers.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1478B - Nezzar and Lucky NumberFor any given d, We can observe the following:   10d to 10d+9 contains d as one of its digit  Let k=10d+9 be the upper bound of such range For every number x>k, we can keep reducing x by d, x will eventually fall into the range mentioned above, which contains d as digit. Therefore, for numbers x>k, they are always achievable. For x\u2264k\u221210, as k<=109, we can run a standard knapsack dynamicprogramming solution, where dp[x] indicates if x is achievable. dp[x] is achievable, if and only if one of the following is true:   x=0  For some y<x, dp[y] is true and x\u2212y contains d as digit Iterating for every x, all dp[x] for x<k can be computed with O(k) per state (as we only need to consider y<k.Besides dynamic programming solution, brute force solutions with enough optimization should also pass the test cases easily.Time complexity: O((10d)2) per test case. Solution#include<bits/stdc++.h>\nusing namespace std;\n \nconst int maxn=207;\nint t,d,q;\nbool dp[maxn];\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin>>t;\n    while (t--){\n        memset(dp,0,sizeof(dp));\n        dp[0]=1;\n        cin>>q>>d;\n        if (!d) d+=10;\n        int mx=d*10;\n        for (int i=0;10*i+d<=mx;++i){\n            for (int j=0;10*i+d+j<=mx;++j){\n                dp[10*i+d+j]|=dp[j];\n            }\n        }\n        while (q--){\n            int u;\n            cin>>u;\n            if (u>=mx||dp[u]) cout<<\"YES\\n\";\n            else cout<<\"NO\\n\";\n        }\n    }\n    return 0;\n}"
    },
    "1476A": {
        "title": "A. K-divisible Sum",
        "description": "You are given two integers n and k.\nYou should create an array of n positive integers a1,a2,\u2026,an such that the sum (a1+a2+\u22ef+an) is divisible by k and maximum element in a is minimum possible.\nWhat is the minimum possible maximum element in a?\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (1\u2264n\u2264109; 1\u2264k\u2264109).\nFor each test case, print one integer\u00a0\u2014 the minimum possible maximum element in array a such that the sum (a1+\u22ef+an) is divisible by k. \nIn the first test case n=1, so the array consists of one element a1 and if we make a1=5 it will be divisible by k=5 and the minimum possible.\nIn the second test case, we can create array a=[1,2,1,2]. The sum is divisible by k=3 and the maximum is equal to 2.\nIn the third test case, we can create array a=[1,1,1,1,1,1,1,1]. The sum is divisible by k=8 and the maximum is equal to 1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1476A - K-divisible SumLet's denote s as the sum of array a. From one side, since s should be divisible by k then we can say s=cf\u22c5k. From other side, since all ai are positive, then s\u2265n.It's quite obvious that the smaller s\u00a0\u2014 the smaller maximum ai so we need to find the smallest cf that cf\u22c5k\u2265n. Then cf=\u2308nk\u2309=\u230an+k\u22121k\u230b.Now we now that s=cf\u22c5k and we need to represent it as a1+\u22ef+an with maximum ai minimized. It's easy to prove by contradiction that maximum ai\u2265\u2308sn\u2309.Moreover we can always construct such array a that its sum is equal to s and the maximum element is equal to \u2308sn\u2309.As a result, the answer is \u2308sn\u2309=\u230acf\u22c5k+n\u22121n\u230b, where cf=\u230an+k\u22121k\u230b. Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int t; cin >> t;\n  while(t--) {\n    long long n, k;\n    cin >> n >> k;\n    \n    long long cf = (n + k - 1) / k;\n    k *= cf;\n    \n    cout << (k + n - 1) / n << endl;\n  }\n  return 0;\n}"
    },
    "1474B": {
        "title": "B. Different Divisors",
        "description": "Positive integer x is called divisor of positive integer y, if y is divisible by x without remainder. For example, 1 is a divisor of 7 and 3 is not divisor of 8.\nWe gave you an integer d and asked you to find the smallest positive integer a, such that \nThe first line contains a single integer t (1\u2264t\u22643000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer d (1\u2264d\u226410000).\nFor each test case print one integer a\u00a0\u2014 the answer for this test case.\nIn the first test case, integer 6 have following divisors: [1,2,3,6]. There are 4 of them and the difference between any two of them is at least 1. There is no smaller integer with at least 4 divisors.\nIn the second test case, integer 15 have following divisors: [1,3,5,15]. There are 4 of them and the difference between any two of them is at least 2.\nThe answer 12 is INVALID because divisors are [1,2,3,4,6,12]. And the difference between, for example, divisors 2 and 3 is less than d=2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1474B - Different DivisorsHint 1: Integer have exactly 4 divisors, if it is of form pq or p3 for some primes p and q. In the first case it have divisors 1, p, q, pq. In the second case it have divisors 1, p, p2, p3.Hint 2: Instead of finding integer with at least 4 divisors, find integer with exactly 4 divisors.Hint 3: Let p be the smallest prime factor of a. Then, p\u2265d+1.Solution:Suppose, we have integer a with more than 4 divisors (and satisfies the other condition). If a has at least two different prime factors, we can throw out all other prime factors and get a smaller number with at least 4 divisors. Otherwise, a=pk for some k>3. p3 will also have 4 divisors and it will be smaller than a. When we throw out a prime factor, no new divisors will appear, so the difference between any two of them will be at least d.Let's find smallest integers of form p3 and pq (p<q) independently.In the first case, p3\u2212p2>p2\u2212p>p\u22121, because p\u22652. If we will find the smallest p\u2265d+1 all conditions will be satisfied.In the second case, 1<p<q<pq. Let's find the smallest p\u2265d+1 and the smallest q\u2265d+p. In this case it is easy to see that p\u22121\u2265d and q\u2212p\u2265d. Also, pq\u2212q=q(p\u22121)\u2265qd\u2265d since q\u22652. It is enough to get OK even without checking case a=p3.Also we should prove that there cannot exist p\u2032 and q\u2032 such that p\u2032q\u2032<pq. It is true because p\u2032 should be at least d+1 and it should be prime, but p is the smallest prime greater than d, so p\u2032\u2265p. And q\u2032 should be at least p+d and we can prove that q\u2032\u2265q in the same way.Time complexity is O(t\u22c5gap\u22c5primecheck), where gap is difference between primes and O(loga) in average and primecheck is complexity of your prime check and usually is O(a\u2212\u2212\u221a).Answer for d=10000 is near to 2\u22c5108, so naive solution with factorization of each number shouldn't pass, but it is possible to precompute answers for all values of d by that solution (in this case, you should run solution once for all values of d, not once for each value of d). Solution104840809"
    },
    "1473B": {
        "title": "B. String LCM",
        "description": "Let's define a multiplication operation between a string a and a positive integer x: a\u22c5x is the string that is a result of writing x copies of a one after another. For example, \"abc\" \u22c5\u00a02\u00a0= \"abcabc\", \"a\" \u22c5\u00a05\u00a0= \"aaaaa\".\nA string a is divisible by another string b if there exists an integer x such that b\u22c5x=a. For example, \"abababab\" is divisible by \"ab\", but is not divisible by \"ababab\" or \"aa\".\nLCM of two strings s and t (defined as LCM(s,t)) is the shortest non-empty string that is divisible by both s and t.\nYou are given two strings s and t. Find LCM(s,t) or report that it does not exist. It can be shown that if LCM(s,t) exists, it is unique.\nThe first line contains one integer q (1\u2264q\u22642000) \u2014 the number of test cases.\nEach test case consists of two lines, containing strings s and t (1\u2264|s|,|t|\u226420). Each character in each of these strings is either 'a' or 'b'.\nFor each test case, print LCM(s,t) if it exists; otherwise, print -1. It can be shown that if LCM(s,t) exists, it is unique.\nIn the first test case, \"baba\" = \"baba\" \u22c5\u00a01\u00a0= \"ba\" \u22c5\u00a02.\nIn the second test case, \"aaaaaa\" = \"aa\" \u22c5\u00a03\u00a0= \"aaa\" \u22c5\u00a02.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "strings",
            "*1000"
        ],
        "solutions": "1473B - String LCMWe should notice that if some string x is a multiple of string y, then |x| is a multiple of |y|. This fact leads us to the conclusion that |LCM(s,t)| should be a common multiple of |s| and |t|. Since we want to minimize the length of the string LCM(s,t), then its length is LCM(|s|,|t|).So we have to check that LCM(|s|,|t|)|s| copies of the string s equal to LCM(|s|,|t|)|t| copies of the string t. If such strings are equal, print them, otherwise, there is no solution. Solution (Neon)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  auto mul = [](string s, int k) -> string {\n    string res = \"\";\n    while (k--) res += s;\n    return res;\n  };\n  \n  int tc;\n  cin >> tc;\n  while (tc--) {\n    string s, t;\n    cin >> s >> t;\n    int n = s.length(), m = t.length();\n    int g = __gcd(n, m);\n    if (mul(s, m / g) == mul(t, n / g))\n      cout << mul(s, m / g) << endl;\n    else\n      cout << \"-1\" << endl;\n  }\n}"
    },
    "1472D": {
        "title": "D. Even-Odd Game",
        "description": "During their New Year holidays, Alice and Bob play the following game using an array a of n integers: \nIf there are no numbers left in the array, then the game ends. The player with the highest score wins. If the scores of the players are equal, then a draw is declared.\nFor example, if n=4 and a=[5,2,7,3], then the game could go as follows (there are other options): \nYou want to find out who will win if both players play optimally. Note that there may be duplicate numbers in the array.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of elements in the array a.\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the array a used to play the game.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output on a separate line: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "games",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1472D - Even-Odd GameLet's look at an analogy for this game.   If Alice takes an even number x, she adds x points to the global result, otherwise 0;  If Bob takes an odd number x, he adds \u2212x points to the global result, otherwise 0;  Alice wants to maximize the global result and Bob wants to minimize it. Obviously, this game is completely equivalent to the conditional game.Suppose now it's Alice's move. Let's look at some number x in the array.   If this number is even, then taking it will add x points, and giving it to Bob will add 0 points.  If this number is odd, then taking it will add 0 points, and giving it to Bob will add \u2212x points. So taking the number x by x points is more profitable than not taking it (regardless of the parity). To maximize the result, Alice should always take the maximum number in the array.Similar reasoning can be done for Bob. In the task, it was necessary to sort the array and simulate the game. Solution#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> v(n);\n  for (int &e : v) {\n    cin >> e;\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for (int i = 0; i < n; i++) {\n    if (i % 2 == 0) {\n      if (v[i] % 2 == 0) {\n        ans += v[i];\n      }\n    } else {\n      if (v[i] % 2 == 1) {\n        ans -= v[i];\n      }\n    }\n  }\n  if (ans == 0) {\n    cout << \"Tie\\n\";\n  } else if (ans > 0) {\n    cout << \"Alice\\n\";\n  } else {\n    cout << \"Bob\\n\";\n  }\n}\n\nint main() {\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1472C": {
        "title": "C. Long Jumps",
        "description": "Polycarp found under the Christmas tree an array a of n elements and instructions for playing with it: \nFor example, if n=5 and a=[7,3,1,2,3], then the following game options are possible: \nHelp Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a.\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output on a separate line one number\u00a0\u2014 the maximum score that Polycarp can get by playing the game on the corresponding array according to the instruction from the statement. Note that Polycarp chooses any starting position from 1 to n in such a way as to maximize his result.\nThe first test case is explained in the statement.\nIn the second test case, the maximum score can be achieved by choosing i=1.\nIn the third test case, the maximum score can be achieved by choosing i=2.\nIn the fourth test case, the maximum score can be achieved by choosing i=1.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "graphs",
            "*1100"
        ],
        "solutions": "1472C - Long Jumps EditorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int &x : a) {\n    cin >> x;\n  }\n\n  vector<int> dp(n);\n  for (int i = n - 1; i >= 0; i--) {\n    dp[i] = a[i];\n    int j = i + a[i];\n    if (j < n) {\n      dp[i] += dp[j];\n    }\n  }\n  cout << *max_element(dp.begin(), dp.end()) << endl;\n}\n\nint main() {\n  int tests;\n  cin >> tests;\n  while (tests-- > 0) {\n    solve();\n  }\n  return 0;\n}"
    },
    "1471B": {
        "title": "B. Strange List",
        "description": "You have given an array a of length n and an integer x to a brand new robot. What the robot does is the following: it iterates over the elements of the array, let the current element be q. If q is divisible by x, the robot adds x copies of the integer qx to the end of the array, and moves on to the next element. Note that the newly added elements could be processed by the robot later. Otherwise, if q is not divisible by x, the robot shuts down.\nPlease determine the sum of all values of the array at the end of the process.\nThe first input line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and x (1\u2264n\u2264105, 2\u2264x\u2264109)\u00a0\u2014 the length of the array and the value which is used by the robot.\nThe next line contains integers a1, a2, ..., an (1\u2264ai\u2264109)\u00a0\u2014 the initial values in the array.\nIt is guaranteed that the sum of values n over all test cases does not exceed 105.\nFor each test case output one integer\u00a0\u2014 the sum of all elements at the end of the process.\nIn the first test case the array initially consists of a single element [12], and x=2. After the robot processes the first element, the array becomes [12,6,6]. Then the robot processes the second element, and the array becomes [12,6,6,3,3]. After the robot processes the next element, the array becomes [12,6,6,3,3,3,3], and then the robot shuts down, since it encounters an element that is not divisible by x=2. The sum of the elements in the resulting array is equal to 36.\nIn the second test case the array initially contains integers [4,6,8,2], and x=2. The resulting array in this case looks like [4,6,8,2,2,2,3,3,4,4,1,1,1,1,1,1].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1471B - Strange ListSolution 1. Let's represent each element ai as xbi\u22c5ci, where bi is the maximal possible. Let's take minimum over all values bi, and let's assume it's attained at position j. The robot will add each element to the array bj times (element at position j will be the first one, which will stop being divisible by x). However, we should not forget about the prefix before position j: each of those number is divisible by a higher power of x, and this prefix will count towards the total sum. The final answer is (bj+1)\u22c5\u2211ni=1ai+\u2211j\u22121i=1aiIn this solution we divide each number ai by x to generate the array b1,b2,\u2026,bn, and then it takes O(n) to compute both sums. The final complexity of the solution is O(nlogA), where A denotes the maximum possible element of the array.Solution 2. Let's maintain the list of pairs {ai,cnti}\u00a0\u2014 it indicates a range of cnti elements equal to ai. Then we can easily implement the operation performed by the robot: if we consider pair {a,cnt}, we either append the array with a pair {ax,cnt\u22c5x}, or terminate the process. The answer to the problem equals to sum of values ai\u22c5cnti.Each number ai will be copied to the end of the array at most O(logA) times, since each time ai is divided by x. Since there are n elements in the array initially, the total complexity of this solution is O(nlogA). "
    },
    "1469B": {
        "title": "B. Red and Blue",
        "description": "Monocarp had a sequence a consisting of n+m integers a1,a2,\u2026,an+m. He painted the elements into two colors, red and blue; n elements were painted red, all other m elements were painted blue.\nAfter painting the elements, he has written two sequences r1,r2,\u2026,rn and b1,b2,\u2026,bm. The sequence r consisted of all red elements of a in the order they appeared in a; similarly, the sequence b consisted of all blue elements of a in the order they appeared in a as well.\nUnfortunately, the original sequence was lost, and Monocarp only has the sequences r and b. He wants to restore the original sequence. In case there are multiple ways to restore it, he wants to choose a way to restore that maximizes the value of \nf(a)=max(0,a1,(a1+a2),(a1+a2+a3),\u2026,(a1+a2+a3+\u22ef+an+m))\nHelp Monocarp to calculate the maximum possible value of f(a).\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases. Then the test cases follow. Each test case consists of four lines.\nThe first line of each test case contains one integer n (1\u2264n\u2264100).\nThe second line contains n integers r1,r2,\u2026,rn (\u2212100\u2264ri\u2264100).\nThe third line contains one integer m (1\u2264m\u2264100).\nThe fourth line contains m integers b1,b2,\u2026,bm (\u2212100\u2264bi\u2264100).\nFor each test case, print one integer \u2014 the maximum possible value of f(a).\nIn the explanations for the sample test cases, red elements are marked as bold.\nIn the first test case, one of the possible sequences a is [6,2,\u22125,3,7,\u22123,\u22124].\nIn the second test case, one of the possible sequences a is [10,1,\u22123,1,2,2].\nIn the third test case, one of the possible sequences a is [\u22121,\u22121,\u22122,\u22123,\u22122,\u22124,\u22125,\u22123,\u22124,\u22125].\nIn the fourth test case, one of the possible sequences a is [0,0].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1000"
        ],
        "solutions": "1469B - Red and BlueDenote pi as the sum of first i elements of r, and qj as the sum of first j elements of b. These values can be calculated in O(n+m) with prefix sums.The first solution is to use dynamic programming. Let dpi,j be the maximum value of f(a) if we placed the first i elements of r and the first j elements of b. Transitions can be performed in O(1): we either place an element from r (then we go to dpi+1,j and update it with max(dpi,j,pi+1+qj)), or place an element from b (then we go to dpi,j+1 and update it with max(dpi,j,pi+qj+1)). The answer is stored in dpn,m, and this solution works in O(nm).The second solution: observe that the sum of several first elements of a is the sum of several first elements of r and several first elements of b. So each prefix sum of a (and the answer itself) is not greater than maxni=0pi+maxmj=0pj. It's easy to show how to obtain exactly this answer: let k be the value of i such that pi is maximized, and l be the value of j such that qj is maximized. Let's place the first k elements of r, then the first l elements of b (so the current sum is exactly maxni=0pi+maxmj=0pj), and place all of the remaining elements in any possible order. So, the answer is maxni=0pi+maxmj=0pj. This solution works in O(n+m). Solution 1 (Ne0n25)#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> r(n);\n\tfor (int &x : r) cin >> x;\n\tint m;\n\tcin >> m;\n\tvector<int> b(m);\n\tfor (int &x : b) cin >> x;\n\tpartial_sum(r.begin(), r.end(), r.begin());\n\tpartial_sum(b.begin(), b.end(), b.begin());\n\tcout << max(0, *max_element(r.begin(), r.end())) + max(0, *max_element(b.begin(), b.end())) << '\\n';\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n} Solution 2 (pikmike)for _ in range(int(input())):\n\tn = int(input())\n\ta = [int(x) for x in input().split()]\n\tm = int(input())\n\tb = [int(x) for x in input().split()]\n\tdp = [[-10**9 for j in range(m + 1)] for i in range(n + 1)]\n\tdp[0][0] = 0\n\tans = 0\n\tfor i in range(n + 1):\n\t\tfor j in range(m + 1):\n\t\t\tif i < n:\n\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + a[i])\n\t\t\tif j < m:\n\t\t\t\tdp[i][j + 1] = max(dp[i][j + 1], dp[i][j] + b[j])\n\t\t\tans = max(ans, dp[i][j])\n\tprint(ans)"
    },
    "1469A": {
        "title": "A. Regular Bracket Sequence",
        "description": "A bracket sequence is called regular if it is possible to obtain correct arithmetic expression by inserting characters + and 1 into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not. Let's call a regular bracket sequence \"RBS\".\nYou are given a sequence s of n characters (, ), and/or ?. There is exactly one character ( and exactly one character ) in this sequence.\nYou have to replace every character ? with either ) or ( (different characters ? can be replaced with different brackets). You cannot reorder the characters, remove them, insert other characters, and each ? must be replaced.\nDetermine if it is possible to obtain an RBS after these replacements.\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nEach test case consists of one line containing s (2\u2264|s|\u2264100) \u2014 a sequence of characters (, ), and/or ?. There is exactly one character ( and exactly one character ) in this sequence.\nFor each test case, print YES if it is possible to obtain a regular bracket sequence, or NO otherwise}. \nYou may print each letter in any case (for example, YES, Yes, yes, yEs will all be recognized as positive answer).\nIn the first test case, the sequence is already an RBS.\nIn the third test case, you can obtain an RBS as follows: ()() or (()).\nIn the fourth test case, you can obtain an RBS as follows: ()().",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1469A - Regular Bracket SequenceIdea: BledDest TutorialTutorial is loading... Solution 1 (BledDest)t = int(input())\nfor i in range(t):\n    s = input()\n    if len(s) % 2 == 0 and s[0] != ')' and s[-1] != '(':\n        print('YES')\n    else:\n        print('NO') Solution 2 (BledDest)t = int(input())\nfor i in range(t):\n    s = input()\n    n = len(s)\n    a = [s[i] for i in range(n)]\n    cnt = n // 2 - 1\n    for j in range(n):\n        if a[j] == '?':\n            if cnt > 0:\n                cnt -= 1\n                a[j] = '('\n            else:\n                a[j] = ')'\n    bal = 0\n    minbal = 0\n    for j in range(n):\n        if a[j] == '(':\n            bal += 1\n        else:\n            bal -= 1\n        minbal = min(bal, minbal)\n    print('YES' if bal == 0 and minbal >= 0 else 'NO') "
    },
    "1463A": {
        "title": "A. Dungeon",
        "description": "You are playing a new computer game in which you have to fight monsters. In a dungeon you are trying to clear, you met three monsters; the first of them has a health points, the second has b health points, and the third has c.\nTo kill the monsters, you can use a cannon that, when fired, deals 1 damage to the selected monster. Every 7-th (i.\u00a0e. shots with numbers 7, 14, 21 etc.) cannon shot is enhanced and deals 1 damage to all monsters, not just one of them. If some monster's current amount of health points is 0, it can't be targeted by a regular shot and does not receive damage from an enhanced shot.\nYou want to pass the dungeon beautifully, i.\u00a0e., kill all the monsters with the same enhanced shot (i.\u00a0e. after some enhanced shot, the health points of each of the monsters should become equal to 0 for the first time). Each shot must hit a monster, i.\u00a0e. each shot deals damage to at least one monster.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of a single line that contains three integers a, b and c (1\u2264a,b,c\u2264108) \u2014 the number of health points each monster has.\nFor each test case, print YES if you can kill all the monsters with the same enhanced shot. Otherwise, print NO. You may print each letter in any case (for example, YES, Yes, yes, yEs will all be recognized as positive answer).\nIn the first test case, you can do as follows: 1-th shot to the first monster, 2-th shot to the second monster, 3-th shot to the third monster, 4-th shot to the first monster, 5-th shot to the third monster, 6-th shot to the third monster, and 7-th enhanced shot will kill all the monsters.\nIn the second test case, you can't kill monsters with the same enhanced shot, because the total number of health points of monsters is 3, and you will kill them in the first 3 shots.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1100"
        ],
        "solutions": "1463A - DungeonNote that for every 7 shots, we deal a total of 9 units of damage. Since we want to kill all the monsters with a shot which index is divisible by 7, let's denote the number of shots as 7k. In this case, a total of a+b+c units of damage must be dealt, hence k=a+b+c9 (if the result of the division is not an integer, then there is no answer). Since each monster will receive at least k units of damage (with enhanced shots), the health of each monster must be at least k. If the two conditions described above are met, then the remaining shots can always be distributed in the desired way. Solution (Ne0n25)for i in range(int(input())):\n\ta, b, c = map(int, input().split())\n\tif (a + b + c) % 9 != 0:\n\t\tprint(\"NO\")\n\telse:\n\t    print(\"YES\" if min(a, b, c) >= (a + b + c) // 9 else \"NO\")"
    },
    "1455C": {
        "title": "C. Ping-pong",
        "description": "Alice and Bob play ping-pong with simplified rules.\nDuring the game, the player serving the ball commences a play. The server strikes the ball then the receiver makes a return by hitting the ball back. Thereafter, the server and receiver must alternately make a return until one of them doesn't make a return.\nThe one who doesn't make a return loses this play. The winner of the play commences the next play. Alice starts the first play.\nAlice has x stamina and Bob has y. To hit the ball (while serving or returning) each player spends 1 stamina, so if they don't have any stamina, they can't return the ball (and lose the play) or can't serve the ball (in this case, the other player serves the ball instead). If both players run out of stamina, the game is over.\nSometimes, it's strategically optimal not to return the ball, lose the current play, but save the stamina. On the contrary, when the server commences a play, they have to hit the ball, if they have some stamina left.\nBoth Alice and Bob play optimally and want to, firstly, maximize their number of wins and, secondly, minimize the number of wins of their opponent.\nCalculate the resulting number of Alice's and Bob's wins.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers x and y (1\u2264x,y\u2264106)\u00a0\u2014 Alice's and Bob's initial stamina.\nFor each test case, print two integers\u00a0\u2014 the resulting number of Alice's and Bob's wins, if both of them play optimally.\nIn the first test case, Alice serves the ball and spends 1 stamina. Then Bob returns the ball and also spends 1 stamina. Alice can't return the ball since she has no stamina left and loses the play. Both of them ran out of stamina, so the game is over with 0 Alice's wins and 1 Bob's wins.\nIn the second test case, Alice serves the ball and spends 1 stamina. Bob decides not to return the ball\u00a0\u2014 he loses the play but saves stamina. Alice, as the winner of the last play, serves the ball in the next play and spends 1 more stamina. This time, Bob returns the ball and spends 1 stamina. Alice doesn't have any stamina left, so she can't return the ball and loses the play. Both of them ran out of stamina, so the game is over with 1 Alice's and 1 Bob's win.\nIn the third test case, Alice serves the ball and spends 1 stamina. Bob returns the ball and spends 1 stamina. Alice ran out of stamina, so she can't return the ball and loses the play. Bob, as a winner, serves the ball in the next 6 plays. Each time Alice can't return the ball and loses each play. The game is over with 0 Alice's and 7 Bob's wins.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "math",
            "*1100"
        ],
        "solutions": "1455C - Ping-pongLet's find an answer for a little different version of the game. Let's say that f(x,y) is the final score if the first player has x stamina and the second has y stamina. The first player can either hit the ball or can give up and lose the play.How to calculate f(x,y)? Obviously, f(0,x)=(0,x) and f(x,0)=(x,0). Otherwise, the first player can   either hit the ball: then the player spent 1 stamina and now it's to the second player to decide\u00a0\u2014 hit or lose. So basically, we moved to the state f(y,x\u22121) and the answer in this case is rev(f(y,x\u22121)) where rev(a,b)=(b,a);  or lose the play: then the player doesn't spend any stamina, but the opponent has to serve the ball. He serves the ball, spend 1 stamina and return to the state, where the first player decides\u00a0\u2014 hit or lose. Formally, the answer in this case is f(x,y\u22121)+(0,1). Looking at f(0,x)=(0,x), f(x,0)=(x,0) and one of transitions f(x,y\u22121)+(0,1) we can guess that f(x,y)=(x,y) and prove it by induction: f(x,y) is either rev(f(y,x\u22121)) or f(x,y\u22121)+(0,1), but rev(f(y,x\u22121))=rev(y,x\u22121)=(x\u22121,y) and f(x,y\u22121)+(0,1)=(x,y\u22121)+(0,1)=(x,y) and (x,y) is better than (x\u22121,y), so f(x,y)=(x,y).The final step is to note that since Alice starts the first play and has to serve ball\u00a0\u2014 the answer is rev(f(y,x\u22121))=rev(y,x\u22121)=(x\u22121,y). Solution (Ne0n25)#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tint x, y;\n\tcin >> x >> y;\n\tcout << x - 1 << \" \" << y << endl;\t\n}\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) solve();\n}"
    },
    "1455B": {
        "title": "B. Jumps",
        "description": "You are standing on the OX-axis at point 0 and you want to move to an integer point x>0.\nYou can make several jumps. Suppose you're currently at point y (y may be negative) and jump for the k-th time. You can: \nWhat is the minimum number of jumps you need to reach the point x?\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains the single integer x (1\u2264x\u2264106)\u00a0\u2014 the destination point.\nFor each test case, print the single integer\u00a0\u2014 the minimum number of jumps to reach x. It can be proved that we can reach any integer point x.\nIn the first test case x=1, so you need only one jump: the 1-st jump from 0 to 0+1=1.\nIn the second test case x=2. You need at least three jumps: \nTwo jumps are not enough because these are the only possible variants: \nIn the third test case, you need two jumps: the 1-st one as +1 and the 2-nd one as +2, so 0+1+2=3.\nIn the fourth test case, you need three jumps: the 1-st one as \u22121, the 2-nd one as +2 and the 3-rd one as +3, so 0\u22121+2+3=4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1455B - JumpsIdea: adedalic TutorialTutorial is loading... Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t; cin >> t;\n\twhile (t--) {\n\t\tint x; cin >> x;\n\t\t\n\t\tint steps = 0;\n\t\twhile (steps * (steps + 1) < 2 * x)\n\t\t\tsteps++;\n\t\t\n\t\tif (steps * (steps + 1) / 2 == x + 1)\n\t\t\tsteps++;\n\t\tcout << steps << endl;\n\t}\n}"
    },
    "1454C": {
        "title": "C. Sequence Transformation",
        "description": "You are given a sequence a, initially consisting of n integers.\nYou want to transform this sequence so that all elements in it are equal (i.\u00a0e. it contains several occurrences of the same element).\nTo achieve this, you choose some integer x that occurs at least once in a, and then perform the following operation any number of times (possibly zero): choose some segment [l,r] of the sequence and remove it. But there is one exception: you are not allowed to choose a segment that contains x. More formally, you choose some contiguous subsequence [al,al+1,\u2026,ar] such that ai\u2260x if l\u2264i\u2264r, and remove it. After removal, the numbering of elements to the right of the removed segment changes: the element that was the (r+1)-th is now l-th, the element that was (r+2)-th is now (l+1)-th, and so on (i.\u00a0e. the remaining sequence just collapses).\nNote that you can not change x after you chose it.\nFor example, suppose n=6, a=[1,3,2,4,1,2]. Then one of the ways to transform it in two operations is to choose x=1, then:\nNote that choosing x is not an operation. Also, note that you can not remove any occurrence of x.\nYour task is to find the minimum number of operations required to transform the sequence in a way described above.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in a. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n), where ai is the i-th element of a.\nIt is guaranteed that the sum of n does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer \u2014 the minimum number of operations required to transform the given sequence in a way described in the problem statement. It can be proven that it is always possible to perform a finite sequence of operations so the sequence is transformed in the required way.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1454C - Sequence TransformationFirstly, let's remove all consecutive equal elements (just keep one occurrence of each such element). For example, the array [1,1,2,3,3,3,2] becomes [1,2,3,2].Now, the answer for each ai is almost the number of its occurrences plus one. Why is it so? Because we need to remove all segments of elements between every pair of consecutive occurrences of ai. The number of such segments is the number of occurrences of ai minus one. There is also a segment before the first occurrence of ai and a segment after the last occurrence of ai. But the first segment doesn't exist for the first element and the last segment doesn't exist for the last element.So, after removing consecutive elements, let's calculate for each ai the number of its occurrences plus one, subtract one from the value of the first element and from the value of the last element. Then the answer is the minimum among these values for all ai. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<int> res(n + 1, 1);\n\t\tn = unique(a.begin(), a.end()) - a.begin();\n\t\ta.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tres[a[i]] += 1;\n\t\t}\n\t\tres[a[0]] -= 1;\n\t\tres[a[n - 1]] -= 1;\n\t\tint ans = 1e9;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tans = min(ans, res[a[i]]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1450B": {
        "title": "B. Balls of Steel",
        "description": "You have n distinct points (x1,y1),\u2026,(xn,yn) on the plane and a non-negative integer parameter k. Each point is a microscopic steel ball and k is the attract power of a ball when it's charged. The attract power is the same for all balls.\nIn one operation, you can select a ball i to charge it. Once charged, all balls with Manhattan distance at most k from ball i move to the position of ball i. Many balls may have the same coordinate after an operation.\nMore formally, for all balls j such that |xi\u2212xj|+|yi\u2212yj|\u2264k, we assign xj:=xi and yj:=yi.\nYour task is to find the minimum number of operations to move all balls to the same position, or report that this is impossible.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n, k (2\u2264n\u2264100, 0\u2264k\u2264106)\u00a0\u2014 the number of balls and the attract power of all balls, respectively.\nThe following n lines describe the balls' coordinates. The i-th of these lines contains two integers xi, yi (0\u2264xi,yi\u2264105)\u00a0\u2014 the coordinates of the i-th ball.\nIt is guaranteed that all points are distinct.\nFor each test case print a single integer\u00a0\u2014 the minimum number of operations to move all balls to the same position, or \u22121 if it is impossible.\nIn the first test case, there are three balls at (0,0), (3,3), and (1,1) and the attract power is 2. It is possible to move two balls together with one operation, but not all three balls together with any number of operations.\nIn the second test case, there are three balls at (6,7), (8,8), and (6,9) and the attract power is 3. If we charge any ball, the other two will move to the same position, so we only require one operation.\nIn the third test case, there are four balls at (0,0), (0,1), (0,2), and (0,3), and the attract power is 1. We can show that it is impossible to move all balls to the same position with a sequence of operations.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "greedy",
            "*1000"
        ],
        "solutions": "1450B - Balls of SteelWe claim the answer is always \u22121 or 1.In fact, suppose in the first operation of a solution we select a point p. If we aren't done, there will at least one point with distance more than k from p. However, there will be no point within distance k of p, no matter how we perform future operations. So it is impossible for p to merge with a new point, and a solution with more than 1 operation will be impossible.To see if the answer is 1, we should check if there is some point p within distance k from all other points. Otherwise, the answer is \u22121. Complexity is O(n2) to compute pairwise distances.Implementation"
    },
    "1447B": {
        "title": "B. Numbers Box",
        "description": "You are given a rectangular grid with n rows and m columns. The cell located on the i-th row from the top and the j-th column from the left has a value aij written in it.\nYou can perform the following operation any number of times (possibly zero):\nNote that you can use a cell more than once in different operations.\nYou are interested in X, the sum of all the numbers in the grid. \nWhat is the maximum X you can achieve with these operations?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264100). Description of the test cases follows.\nThe first line of each test case contains two integers n,m (2\u2264n, m\u226410). \nThe following n lines contain m integers each, the j-th element in the i-th line is aij (\u2212100\u2264aij\u2264100).\nFor each testcase, print one integer X, the maximum possible sum of all the values in the grid after applying the operation as many times as you want.\nIn the first test case, there will always be at least one \u22121, so the answer is 2. \nIn the second test case, we can use the operation six times to elements adjacent horizontally and get all numbers to be non-negative. So the answer is: 2\u00d71+3\u00d72+3\u00d73+2\u00d74+1\u00d75=30.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1447B - Numbers Box HintWe want to minimize the number of negative numbers as much as we can by applying the operations. What is the minimum possible number of those negatives? SolutionLet X be the number of non-zero numbers in the grid, and let's see what happens in different scenarios.  both cells have negative numbers, then X goes down by 2. both cells have positive numbers, then X goes up by 2. one cell has a positive number while the other one has a negative number, then X stays the same. It is important to notice that we can apply this operation not only for the two neighboring cells, but for any two \u2014 to achieve this effect we apply this operation on any path between the cells consecutively.The parity of X never changes. So, for even X the answer is the sum of the absolute value of all numbers, S. Otherwise, one element will not be positive in the end -- so it's best to choose the one with minimum absolute value, V, and subtract 2\u22c5V from the sum.The existence of zeroes doesn't really change anything, both formulas output the same value in such a case.This gives us a solution in O(N\u22c5M)"
    },
    "1438B": {
        "title": "B. Valerii Against Everyone",
        "description": "You're given an array b of length n. Let's define another array a, also of length n, for which ai=2bi (1\u2264i\u2264n). \nValerii says that every two non-intersecting subarrays of a have different sums of elements. You want to determine if he is wrong. More formally, you need to determine if there exist four integers l1,r1,l2,r2 that satisfy the following conditions: \nIf such four integers exist, you will prove Valerii wrong. Do they exist?\nAn array c is a subarray of an array d if c can be obtained from d by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264100). Description of the test cases follows.\nThe first line of every test case contains a single integer n (2\u2264n\u22641000).\nThe second line of every test case contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264109). \nFor every test case, if there exist two non-intersecting subarrays in a that have the same sum, output YES on a separate line. Otherwise, output NO on a separate line. \nAlso, note that each letter can be in any case. \nIn the first case, a=[16,8,1,2,4,1]. Choosing l1=1, r1=1, l2=2 and r2=6 works because 16=(8+1+2+4+1).\nIn the second case, you can verify that there is no way to select to such subarrays.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1438B - Valerii Against EveryoneWe claim the answer is NO if and only if the elements are pairwise distinct.If any element has two occurrences, we can trivially select them as the two subarrays. Otherwise, since all elements are distinct, choosing a subarray is the same as choosing the set bits of a 109 digit long binary number. Since every number has a unique binary representation, no two subarrays can have the same sum.  "
    },
    "1437B": {
        "title": "B. Reverse Binary Strings",
        "description": "You are given a string s of even length n. String s is binary, in other words, consists only of 0's and 1's.\nString s has exactly n2 zeroes and n2 ones (n is even).\nIn one operation you can reverse any substring of s. A substring of a string is a contiguous subsequence of that string.\nWhat is the minimum number of operations you need to make string s alternating? A string is alternating if si\u2260si+1 for all i. There are two types of alternating strings in general: 01010101... or 10101010...\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105; n is even)\u00a0\u2014 the length of string s.\nThe second line of each test case contains a binary string s of length n (si\u2208 {0, 1}). String s has exactly n2 zeroes and n2 ones.\nIt's guaranteed that the total sum of n over test cases doesn't exceed 105.\nFor each test case, print the minimum number of operations to make s alternating.\nIn the first test case, string 10 is already alternating.\nIn the second test case, we can, for example, reverse the last two elements of s and get: 0110 \u2192 0101.\nIn the third test case, we can, for example, make the following two operations: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1437B - Reverse Binary StringsWe need to make our string alternating, i. e. si\u2260si+1. When we reverse substring sl\u2026sr, we change no more than two pairs sl\u22121,sl and sr,sr+1. Moreover, one pair should be a consecutive pair 00 and other\u00a0\u2014 11. So, we can find lower bound to our answer as maximum between number of pairs of 00 and number of pairs of 11. And we can always reach this lower bound, by pairing 00 with 11 or with left/right border of s. Another way to count the answer is next: suppose we want to make string 0101..., then let's transform s to 1 + s + 0. For example, if s= 0110, we will get 101100. We claim that after this transformation, we will have equal number of 00 and 11, so the answer is the number of consecutive pairs of the same character divided by two. The answer is the minimum between answers for 1 + s + 0 and 0 + s + 1. Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n#define sz(a) int((a).size())\n\nconst int INF = int(1e9);\n\nint n;\nstring s;\n\ninline bool read() {\n\tif(!(cin >> n >> s))\n\t\treturn false;\n\treturn true;\n}\n\nint cntSame(const string &s) {\n\tint ans = 0;\n\tfore (i, 1, sz(s))\n\t\tans += (s[i - 1] == s[i]);\n\tassert(ans % 2 == 0);\n\treturn ans / 2;\n}\n\ninline void solve() {\n\tint ans = INF;\n\tfore (k, 0, 2) {\n\t\tans = min(ans, cntSame(string(1, '0' + k) + s + string(1, '1' - k)));\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    },
    "1433D": {
        "title": "D. Districts Connection",
        "description": "There are n districts in the town, the i-th district belongs to the ai-th bandit gang. Initially, no districts are connected to each other.\nYou are the mayor of the city and want to build n\u22121 two-way roads to connect all districts (two districts can be connected directly or through other connected districts).\nIf two districts belonging to the same gang are connected directly with a road, this gang will revolt.\nYou don't want this so your task is to build n\u22121 two-way roads in such a way that all districts are reachable from each other (possibly, using intermediate districts) and each pair of directly connected districts belong to different gangs, or determine that it is impossible to build n\u22121 roads to satisfy all the conditions.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264500) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (2\u2264n\u22645000) \u2014 the number of districts. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is the gang the i-th district belongs to.\nIt is guaranteed that the sum of n does not exceed 5000 (\u2211n\u22645000).\nFor each test case, print:\nFor each road i, the condition a[xi]\u2260a[yi] should be satisfied. Also, all districts should be reachable from each other (possibly, using intermediate districts).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dfs and similar",
            "*1200"
        ],
        "solutions": "1433D - Districts ConnectionIf all districts belong to the same gang then the answer is NO. Otherwise, the answer is always YES (yeah, as in the previous problem). How to construct it? Let's choose the first \"root\" as the district 1 and connect all such districts i that a1\u2260ai to the district 1. So, all disconnected districts that remain are under control of the gang a1. Let's find any district i that ai\u2260a1 and just connect all remaining districts of the gang a1 to this district. This district always exists because we have at least two different gangs and it is connected to the remaining structure because its gang is not a1. So, all conditions are satisfied. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tvector<pair<int, int>> res;\n\t\tint idx = -1;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tif (a[i] != a[0]) {\n\t\t\t\tidx = i;\n\t\t\t\tres.push_back({1, i + 1});\n\t\t\t}\n\t\t}\n\t\tif (idx == -1) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tif (a[i] == a[0]) {\n\t\t\t\tres.push_back({idx + 1, i + 1});\n\t\t\t}\n\t\t}\n\t\tcout << \"YES\" << endl;\n\t\tfor (auto [x, y] : res) cout << x << \" \" << y << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1430C": {
        "title": "C. Numbers on Whiteboard",
        "description": "Numbers 1,2,3,\u2026n (each integer from 1 to n once) are written on a board. In one operation you can erase any two numbers a and b from the board and write one integer a+b2 rounded up instead.\nYou should perform the given operation n\u22121 times and make the resulting number that will be left on the board as small as possible. \nFor example, if n=4, the following course of action is optimal:\nIt's easy to see that after n\u22121 operations, there will be left only one number. Your goal is to minimize it.\nThe first line contains one integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains one integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the number of integers written on the board initially.\nIt's guaranteed that the total sum of n over test cases doesn't exceed 2\u22c5105.\nFor each test case, in the first line, print the minimum possible number left on the board after n\u22121 operations. Each of the next n\u22121 lines should contain two integers\u00a0\u2014 numbers a and b chosen and erased in each operation.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1430C - Numbers on WhiteboardIt's easy to see that we can't get the result less than 2, because, if we merge two positive numbers, and at least one of them is 2 or greater, the new number is always greater than 1. So we can't get rid of all numbers greater than 1.To always achieve 2, we can use a greedy algorithm: always merge two maximum numbers. During the first step, we merge n and n\u22121, get n; then we merge n and n\u22122, get n\u22121; then we merge n\u22121 and n\u22123, get n\u22122; and it's easy to see that the last operation is merging 3 and 1, so the result is 2. Solution (fcspartakm)#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cmath>\n\n#define forn(i, n) for(int i=0;i<n;++i)\n#define fore(i, l, r) for(int i = int(l); i <= int(r); ++i)\n#define sz(v) int(v.size())\n#define all(v) v.begin(), v.end()\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y1 ________y1\n#define y second\n#define ft first\n#define sc second\n#define pt pair<int, int>\n\ntemplate<typename X> inline X abs(const X& a) { return a < 0? -a: a; }\ntemplate<typename X> inline X sqr(const X& a) { return a * a; }\n\ntypedef long long li;\ntypedef long double ld;\n\nusing namespace std;\n\nconst int INF = 1000 * 1000 * 1000;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nint n;\n\ninline void read() {\t\n\tcin >> n;\n}\n\ninline void solve() {\n\tmultiset<int> was;\n\tfor (int i = 1; i <= n; i++) {\n\t\twas.insert(i);\n\t}\n\tvector<pair<int, int> > ans;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tauto it = was.end();\n\t\tit--;\n\t\tint a = *it;\n\t\twas.erase(it);\n\t\tit = was.end();\n\t\tit--;\n\t\tint b = *it;\n\t\twas.erase(it);\n\t\twas.insert((a + b + 1) / 2);\n\t\tans.pb(mp(a, b));\n\t}\n\tcout << *was.begin() << endl;\n\tfor (int i = 0; i < sz(ans); i++) {\n\t\tcout << ans[i].ft << ' ' << ans[i].sc << endl;\n\t}\t\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    cerr << setprecision(10) << fixed;\n    \n    int t; cin >> t;\n    while(t--) {\n    \tread();\n    \tsolve();\n    }\n    //cerr << \"TIME: \" << clock() << endl;\n}\n"
    },
    "1428C": {
        "title": "C. ABBB",
        "description": "Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either \"AB\" or \"BB\". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.\nFor example, Zookeeper can use two such operations: AABABBA \u2192 AABBA \u2192 AAA.\nZookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u226420000) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nEach of the next t lines contains a single test case each, consisting of a non-empty string s: the string that Zookeeper needs to bomb. It is guaranteed that all symbols of s are either 'A' or 'B'.\nIt is guaranteed that the sum of |s| (length of s) among all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer: the length of the shortest string that Zookeeper can make.\nFor the first test case, you can't make any moves, so the answer is 3.\nFor the second test case, one optimal sequence of moves is BABA \u2192 BA. So, the answer is 2.\nFor the third test case, one optimal sequence of moves is AABBBABBBB \u2192 AABBBABB \u2192 AABBBB \u2192 ABBB \u2192 AB \u2192 (empty string). So, the answer is 0.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "strings",
            "*1100"
        ],
        "solutions": "1428C - ABBBSetter: errorgorn and shenxy13Prepared by: errorgorn and oolimry Hint 1AB and BB means that ?B can be removed. Hint 2The final string is BAAA... or AAA.... SolutionThis game is equivalent to processing left to right and maintaining a stack. If the current processed character is A, we add it to the stack, if the current processed character is B, we can either add it to the stack or pop the top of the stack.In the optimal solution, we will always pop from the stack whenever possible. To prove this, we will use the stay ahead argument. Firstly, we notice that the contents of the stack do not actually matter. We actually only need to maintain the length of this stack. Decrementing the size of the stack whenever possible is optimal as it is the best we can do. And in the case where we must push `B' to the stack, this is optimal as the parity of the length of the stack must be the same as the parity of the processed string, so obtaining a stack of length 0 is impossble.Bonus: what is the length of the longest string that Zookeeper can make such that there are no moves left? Other commentsWe're also sorry for the weak pretests in this problem. About 1 hour before the contest, we found out that c++ O(N2) solution using find and erase would pass. Then we added testcases to kill the c++ solutions, but we didn't test the O(N2) solution for python using replace. Code (C++)//\u96ea\u82b1\u98c4\u98c4\u5317\u98a8\u562f\u562f\n//\u5929\u5730\u4e00\u7247\u84bc\u832b\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n//change less to less_equal for non distinct pbds, but erase will bug\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tint TC;\n\tcin>>TC;\n\t\n\twhile (TC--){\n\t\tstring s;\n\t\tcin>>s;\n\t\t\n\t\tint stk=0;\n\t\t\n\t\trep(x,0,sz(s)){\n\t\t\tif (stk && s[x]=='B') stk--;\n\t\t\telse stk++;\n\t\t}\n\t\t\n\t\tcout<<stk<<endl;\n\t}\n} Code (Python)TC = int(input())\nfor tc in range(TC):\n\ts = input()\n\tans=0\n\tfor i in s:\n\t\tif (i=='B' and ans!=0): ans-=1\n\t\telse: ans+=1\n\tprint(ans)"
    },
    "1428B": {
        "title": "B. Belted Rooms",
        "description": "In the snake exhibition, there are n rooms (numbered 0 to n\u22121) arranged in a circle, with a snake in each room. The rooms are connected by n conveyor belts, and the i-th conveyor belt connects the rooms i and (i+1)modn. In the other words, rooms 0 and 1, 1 and 2, \u2026, n\u22122 and n\u22121, n\u22121 and 0 are connected with conveyor belts.\nThe i-th conveyor belt is in one of three states:\nAbove is an example with 4 rooms, where belts 0 and 3 are off, 1 is clockwise, and 2 is anticlockwise.\nEach snake wants to leave its room and come back to it later. A room is returnable if the snake there can leave the room, and later come back to it using the conveyor belts. How many such returnable rooms are there?\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u22641000): the number of test cases. The description of the test cases follows. \n The first line of each test case description contains a single integer n (2\u2264n\u2264300000): the number of rooms.\n The next line of each test case description contains a string s of length n, consisting of only '<', '>' and '-'.\nIt is guaranteed that the sum of n among all test cases does not exceed 300000.\nFor each test case, output the number of returnable rooms.\nIn the first test case, all rooms are returnable except room 2. The snake in the room 2 is trapped and cannot exit. This test case corresponds to the picture from the problem statement.\n In the second test case, all rooms are returnable by traveling on the series of clockwise belts.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "graphs",
            "implementation",
            "*1200"
        ],
        "solutions": "1428B - Belted RoomsSetter: oolimryPrepared by: oolimry Hint 1There are 2 cases to consider for a room to be returnable. Hint 2For a room to be returnable, either go one big round around all the rooms or move to an adjacent room and move back. SolutionLet's consider two ways to return to the start point. The first is to go one big round around the circle. The second is to move 1 step to the side, and return back immediately.Going one big round is only possible if and only if:  There are no clockwise belts OR There are no anticlockwise belts If we can go one big round, all rooms are returnable.If there are both clockwise and anticlockwise belts, then we can't go one big round. For any room to be returnable, it must have an off belt to the left or to the right. In summary, check if clockwise belts are absent or if anticlockwise belts are absent. If either is absent, the answer is n. Otherwise, we have to count the number of rooms with an off belt to the left or to the right. Other commentsSorry for the unclear statement for B, we should've explained each sample testcase more clearly with better diagrams. Additionally, we're also sorry for the weak pretests. We should've added more testcases of smaller length, and thanks to hackers for adding stronger tests. Code (C++)#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\t\n\tint TC; cin >> TC;\n\twhile(TC--){\n\t\tint n; cin >> n;\n\t\tstring s; cin >> s;\n\t\t\n\t\tbool hasCW = false;\n\t\tbool hasCCW = false;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(s[i] == '<') hasCW = true;\n\t\t\tif(s[i] == '>') hasCCW = true;\n\t\t}\n\t\t\n\t\tif(hasCW && hasCCW){\n\t\t\tint ans = 0;\n\t\t\ts += s[0];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(s[i] == '-' || s[i+1] == '-') ans++;\n\t\t\t}\n\t\t\tcout << ans << \"\\n\";\n\t\t}\n\t\telse{\n\t\t\tcout << n << \"\\n\";\n\t\t}\n\t}\n} Code (Python)TC = int(input())\nfor tc in range(TC):\n    n = int(input())\n    s = input()\n\n    hasCW = False\n    hasCCW = False \n    for c in s:\n        if c == '>':\n            hasCW = True\n        if c == '<':\n            hasCCW = True\n            \n    if hasCW and hasCCW:\n        s += s[0]\n        ans = 0;\n        for i in range(n):\n            if s[i] == '-' or s[i+1] == '-':\n                ans += 1\n        print(ans)\n        \n    else:\n        print(n)"
    },
    "1426C": {
        "title": "C. Increase and Copy",
        "description": "Initially, you have the array a consisting of one element 1 (a=[1]).\nIn one move, you can do one of the following things:\nFor example, consider the sequence of five moves:\nYour task is to find the minimum number of moves required to obtain the array with the sum at least n.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases. Then t test cases follow.\nThe only line of the test case contains one integer n (1\u2264n\u2264109) \u2014 the lower bound on the sum of the array.\nFor each test case, print the answer: the minimum number of moves required to obtain the array with the sum at least n.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1426C - Increase and CopyIt is pretty intuitive that we firstly need to do all increments and only then copy numbers (because otherwise we can swap the order of moves and the sum will not decrease). You could notice that the answer does not exceed O(n\u2212\u2212\u221a) so we can just iterate from 1 to \u230an\u2212\u2212\u221a\u230b and fix the number we will copy. Let it be x. Then we need x\u22121 moves to obtain it and also need \u2308n\u2212xx\u2309 moves to get the enough number of copies. So, we can update the answer with this number of moves.Time complexity: O(n\u2212\u2212\u221a) per test case.Actually, the required number is always pretty near to \u230an\u2212\u2212\u221a\u230b so it is enough to try a few options in range [\u230an\u2212\u2212\u221a\u230b\u22125;\u230an\u2212\u2212\u221a\u230b+5] to get the optimal answer. This is O(1) solution. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tint ans = 1e9;\n\t\tfor (int x = 1; x * x <= n; ++x) {\n\t\t\tans = min(ans, x - 1 + ((n - x) + x - 1) / x);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n Solution 2#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long double EPS = 1e-9;\n\nlong long f(long long x)\n{                                                        \n\tlong long z = sqrtl(x);\n\tlong long ans = 1e18;\n\tfor(int i = -5; i <= 5; i++)\n\t{\n\t \tlong long z2 = z - i;\n\t \tif(z2 > x || z2 < 1)\n\t \t\tcontinue;\n\t \tans = min(ans, z2 - 2 + (x + z2 - 1) / z2);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n \tint t;\n \tcin >> t;\n \tfor(int i = 0; i < t; i++)\n \t{\n \t \tlong long x;\n \t \tcin >> x;\n \t \tcout << f(x) << endl;\n \t}\n}"
    },
    "1421B": {
        "title": "B. Putting Bricks in the Wall",
        "description": "Pink Floyd are pulling a prank on Roger Waters. They know he doesn't like walls, he wants to be able to walk freely, so they are blocking him from exiting his room which can be seen as a grid.\nRoger Waters has a square grid of size n\u00d7n and he wants to traverse his grid from the upper left (1,1) corner to the lower right corner (n,n). Waters can move from a square to any other square adjacent by a side, as long as he is still in the grid. Also except for the cells (1,1) and (n,n) every cell has a value 0 or 1 in it.\nBefore starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose. The starting and finishing cells (1,1) and (n,n) are exempt from this rule, he may go through them regardless of picked digit. Because of this the cell (1,1) takes value the letter 'S' and the cell (n,n) takes value the letter 'F'.\nFor example, in the first example test case, he can go from (1,1) to (n,n) by using the zeroes on this path: (1,1), (2,1), (2,2), (2,3), (3,3), (3,4), (4,4)\nThe rest of the band (Pink Floyd) wants Waters to not be able to do his traversal, so while he is not looking they will invert at most two cells in the grid (from 0 to 1 or vice versa). They are afraid they will not be quick enough and asked for your help in choosing the cells.  Note that you cannot invert cells (1,1) and (n,n).\nWe can show that there always exists a solution for the given constraints.\nAlso note that Waters will pick his digit of the traversal after the band has changed his grid, so he must not be able to reach (n,n) no matter what digit he picks.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226450). Description of the test cases follows.\nThe first line of each test case contains one integers n (3\u2264n\u2264200).\nThe following n lines of each test case contain the binary grid, square (1,1) being colored in 'S' and square (n,n) being colored in 'F'.\nThe sum of values of n doesn't exceed 200.\nFor each test case output on the first line an integer c (0\u2264c\u22642) \u00a0\u2014 the number of inverted cells.\nIn i-th of the following c lines, print the coordinates of the i-th cell you inverted. You may not invert the same cell twice.  Note that you cannot invert cells (1,1) and (n,n).\nFor the first test case, after inverting the cell, we get the following grid:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solutions": "1421B \u2014 Putting Bricks in the WallIdea: flaviu2001, solution: flaviu2001 and stefdasca HintIt's hard to use the two valuable switches somewhere in the middle of the matrix, a much wiser choice would be to somehow block the S cell or the F cell. Perhaps you can set both neighbours of S to 1 to force Roger to pick 1. SolutionIf we pick the neighbours of S to be 1 we can make the neighbours of F 0 and there would be no way to go from S to F. But this requires in the worst case 4 switches, which is not good enough. Luckily, in order to get down to 2 switches we only have to consider the other way around, making the squares neighboring S become 0 and the squares neighboring F 1. There must be a solution of the two with at most two switches and you won't get from S to F since you're forced to pick 1 (or 0) and can't get past the neighbours of F which are opposite."
    },
    "1420B": {
        "title": "B. Rock and Lever",
        "description": "You must block the canal. With a rock. I will not give the rock to you.\" \nDanik urgently needs rock and lever! Obviously, the easiest way to get these things is to ask Hermit Lizard for them.\nHermit Lizard agreed to give Danik the lever. But to get a stone, Danik needs to solve the following task.\nYou are given a positive integer n, and an array a of positive integers. The task is to calculate the number of such pairs (i,j) that i<j and ai & aj\u2265ai\u2295aj, where & denotes the bitwise AND operation, and \u2295 denotes the bitwise XOR operation.\nDanik has solved this task. But can you solve it?\nEach test contains multiple test cases.\nThe first line contains one positive integer t (1\u2264t\u226410) denoting the number of test cases. Description of the test cases follows.\nThe first line of each test case contains one positive integer n (1\u2264n\u2264105)\u00a0\u2014 length of the array.\nThe second line contains n positive integers ai (1\u2264ai\u2264109)\u00a0\u2014 elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor every test case print one non-negative integer\u00a0\u2014 the answer to the problem.\nIn the first test case there is only one pair: (4,7): for it 4 & 7=4, and 4\u22957=3.\nIn the second test case all pairs are good.\nIn the third test case there are two pairs: (6,5) and (2,3).\nIn the fourth test case there are no good pairs.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "math",
            "*1200"
        ],
        "solutions": "1420B - Rock and LeverLet's take a pair (ai,aj) and see in which case ai\u00a0&\u00a0aj\u2265ai\u2295aj will hold. For this we will follow the bits ai and aj from highest to lowest. If we meet two zero bits, the values of ai\u00a0&\u00a0aj and ai\u2295aj will match in this bit, so we move on. If we meet a zero bit in ai and in aj\u00a0\u2014one bit(or vice versa), then we get ai\u00a0&\u00a0aj<ai\u2295aj, and we can immediately say that the required condition is false. And if we meet two one bits, then the required condition is fulfilled, \u00a0e. ai\u00a0&\u00a0aj>ai\u2295aj, and then the bits can no longer be considered.Now let's consider the highest one bit in the number of ai (let it stand at pi position) and the highest single bit in the number of aj (let it stand at pj position). (Here, we consider that the bits are numbered in order of lowest to highest.) Then, pi=pj must hold. If pi>pj, then there is zero in the aj position and one unit in the ai position. But then from the reasoning above we get that ai\u00a0&\u00a0aj<ai\u2295aj. The case of pi<pj is treated in a similar way.It is also easy to see that if pi=pj then we automatically get the condition ai\u00a0&\u00a0aj>ai\u2295aj.From here the problem is solved. For each number we find the position of the highest one bit pi. Then we need to calculate the number of pairs of numbers, for which pi=pj. You may notice that the answer is \u2211\u2113k\u2113\u22c5(k\u2113\u22121)2, where k\u2113\u00a0\u2014 the number of numbers for which pi=pj.The complexity of the solution is O(n). Code in C++ (Wind_Eagle)#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<ctime>\n#include<random>\n\nusing namespace std;\n\nmt19937 rnd(time(NULL));\n\nint a[1000000+5];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin>>t;\n    while (t--)\n    {\n        int n;\n        cin>>n;\n        for (int i=0; i<n; i++)\n        {\n            cin>>a[i];\n        }\n        int64_t ans=0;\n        for (int j=29; j>=0; j--)\n        {\n            int64_t cnt=0;\n            for (int i=0; i<n; i++)\n            {\n                if (a[i]>=(1<<j)&&a[i]<(1<<(j+1)))\n                {\n                    cnt++;\n                }\n            }\n            ans+=cnt*(cnt-1)/2;\n        }\n        cout<<ans<<'\\n';\n    }\n}"
    },
    "1419D1": {
        "title": "D1. Sage's Birthday (easy version)",
        "description": "This is the easy version of the problem. The difference between the versions is that in the easy version all prices ai are different. You can make hacks if and only if you solved both versions of the problem.\nToday is Sage's birthday, and she will go shopping to buy ice spheres. All n ice spheres are placed in a row and they are numbered from 1 to n from left to right. Each ice sphere has a positive integer price. In this version all prices are different.\nAn ice sphere is cheap if it costs strictly less than two neighboring ice spheres: the nearest to the left and the nearest to the right. The leftmost and the rightmost ice spheres are not cheap. Sage will choose all cheap ice spheres and then buy only them.\nYou can visit the shop before Sage and reorder the ice spheres as you wish. Find out the maximum number of ice spheres that Sage can buy, and show how the ice spheres should be reordered.\nThe first line contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of ice spheres in the shop.\nThe second line contains n different integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the prices of ice spheres.\nIn the first line print the maximum number of ice spheres that Sage can buy.\nIn the second line print the prices of ice spheres in the optimal order. If there are several correct answers, you can print any of them.\nIn the example it's not possible to place ice spheres in any order so that Sage would buy 3 of them. If the ice spheres are placed like this (3,1,4,2,5), then Sage will buy two spheres: one for 1 and one for 2, because they are cheap.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1419B": {
        "title": "B. Stairs",
        "description": "Jett is tired after destroying the town and she wants to have a rest. She likes high places, that's why for having a rest she wants to get high and she decided to craft staircases.\nA staircase is a squared figure that consists of square cells. Each staircase consists of an arbitrary number of stairs. If a staircase has n stairs, then it is made of n columns, the first column is 1 cell high, the second column is 2 cells high, \u2026, the n-th column if n cells high. The lowest cells of all stairs must be in the same row.\nA staircase with n stairs is called nice, if it may be covered by n disjoint squares made of cells. All squares should fully consist of cells of a staircase.\nFind out the maximal number of different nice staircases, that can be built, using no more than x cells, in total. No cell can be used more than once.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases.\nThe description of each test case contains a single integer x (1\u2264x\u22641018) \u00a0\u2014 the number of cells for building staircases.\nFor each test case output a single integer \u00a0\u2014 the number of different nice staircases, that can be built, using not more than x cells, in total.\nIn the first test case, it is possible to build only one staircase, that consists of 1 stair. It's nice. That's why the answer is 1.\nIn the second test case, it is possible to build two different nice staircases: one consists of 1 stair, and another consists of 3 stairs. This will cost 7 cells. In this case, there is one cell left, but it is not possible to use it for building any nice staircases, that have not been built yet. That's why the answer is 2.\nIn the third test case, it is possible to build only one of two nice staircases: with 1 stair or with 3 stairs. In the first case, there will be 5 cells left, that may be used only to build a staircase with 2 stairs. This staircase is not nice, and Jett only builds nice staircases. That's why in this case the answer is 1. If Jett builds a staircase with 3 stairs, then there are no more cells left, so the answer is 1 again.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1418A": {
        "title": "A. Buying Torches",
        "description": "You are playing a very popular game called Cubecraft. Initially, you have one stick and want to craft k torches. One torch can be crafted using one stick and one coal.\nHopefully, you've met a very handsome wandering trader who has two trade offers:\nDuring one trade, you can use only one of these two trade offers. You can use each trade offer any number of times you want to, in any order.\nYour task is to find the minimum number of trades you need to craft at least k torches. The answer always exists under the given constraints.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe only line of the test case contains three integers x, y and k (2\u2264x\u2264109; 1\u2264y,k\u2264109) \u2014 the number of sticks you can buy with one stick, the number of sticks required to buy one coal and the number of torches you need, respectively.\nFor each test case, print the answer: the minimum number of trades you need to craft at least k torches. The answer always exists under the given constraints.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1418A - Buying TorchesYou need s=yk+k\u22121 additional sticks to get k torches (yk sticks for y units of coal and also k sticks required to craft torches) and you get x\u22121 sticks per one trade. To buy this number of sticks, you need \u2308sx\u22121\u2309 trades. And also, you need k additional trades to turn some sticks into coals. And the final answer is \u2308sx\u22121\u2309+k. Solution (vovuh)for i in range(int(input())):\n    x, y, k = map(int, input().split())\n    print(((y + 1) * k - 1 + x - 2) // (x - 1) + k)"
    },
    "1417B": {
        "title": "B. Two Arrays",
        "description": "RedDreamer has an array a consisting of n non-negative integers, and an unlucky integer T.\nLet's denote the misfortune of array b having length m as f(b) \u2014 the number of pairs of integers (i,j) such that 1\u2264i<j\u2264m and bi+bj=T. RedDreamer has to paint each element of a into one of two colors, white and black (for each element, the color is chosen independently), and then create two arrays c and d so that all white elements belong to c, and all black elements belong to d (it is possible that one of these two arrays becomes empty). RedDreamer wants to paint the elements in such a way that f(c)+f(d) is minimum possible.\nFor example:\nHelp RedDreamer to paint the array optimally!\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains two integers n and T (1\u2264n\u2264105, 0\u2264T\u2264109) \u2014 the number of elements in the array and the unlucky integer, respectively. \nThe second line contains n integers a1, a2, ..., an (0\u2264ai\u2264109) \u2014 the elements of the array. \nThe sum of n over all test cases does not exceed 105.\nFor each test case print n integers: p1, p2, ..., pn (each pi is either 0 or 1) denoting the colors. If pi is 0, then ai is white and belongs to the array c, otherwise it is black and belongs to the array d.\nIf there are multiple answers that minimize the value of f(c)+f(d), print any of them.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "1417B - Two ArraysLet us partition the array into three sets X, Y, Z such that X contains all numbers less than T/2, Y contains all numbers equal to T/2 and Z contains all numbers greater than T/2. It is clear that f(X)=f(Z)=0. Now, since each pair in Y makes a sum of T, the best solution is to distribute all numbers in Y equally among X and Z. Time complexity: O(n)Space complexity: O(n) Code in C++ (hugopm)#include <bits/stdc++.h>\n#define len(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define chmax(x, v) x = max((x), (v))\n#define chmin(x, v) x = min((x), (v))\nusing namespace std;\nusing ll = long long;\n\nvoid solve() {\n\tint n, tar;\n\tcin >> n >> tar;\n\tint curMid = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x; cin >> x;\n\t\tint r;\n\t\tif (tar % 2 == 0 && x == tar/2)\n\t\t\tr = (curMid++) % 2;\n\t\telse if (2*x < tar)\n\t\t\tr = 0;\n\t\telse\n\t\t\tr = 1;\n\t\tcout << r << \" \\n\"[i==n-1];\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\n\tint nbTests;\n\tcin >> nbTests;\n\tfor (int iTest = 0; iTest < nbTests; ++iTest) {\n\t\tsolve();\n\t}\n}Div2C/Div1A by nkamzabek  Editorial"
    },
    "1415B": {
        "title": "B. Repainting Street",
        "description": "There is a street with n houses in a line, numbered from 1 to n. The house i is initially painted in color ci. The street is considered beautiful if all houses are painted in the same color. Tom, the painter, is in charge of making the street beautiful. Tom's painting capacity is defined by an integer, let's call it k.\nOn one day, Tom can do the following repainting process that consists of two steps: \nNote that in the same day Tom can use different colors to repaint different houses.\nTom wants to know the minimum number of days needed to repaint the street so that it becomes beautiful.\nThe first line of input contains a single integer t (1\u2264t\u2264104), the number of test cases. Description of test cases follows.\nIn the first line of a test case description there are two integers n and k (1\u2264k\u2264n\u2264105).\nThe second line contains n space-separated integers. The i-th of these integers represents ci (1\u2264ci\u2264100), the color which house i is initially painted in.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nPrint t lines, each with one integer: the minimum number of days Tom needs to make the street beautiful for each test case. \nIn the first test case Tom should paint houses 1 and 2 in the first day in color 2, houses 5 and 6 in the second day in color 2, and the last house in color 2 on the third day.\nIn the second test case Tom can, for example, spend 6 days to paint houses 1, 2, 4, 5, 6, 7 in color 3.\nIn the third test case Tom can paint the first house in the first day and houses 6, 7, and 8 in the second day in color 3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "brute force",
            "greedy",
            "*1100"
        ],
        "solutions": "1415B - Repainting StreetIf we want to paint every house on the street with color x, it is easy to see that we need to change every house with color different from x, and not necessarily repaint houses already painted in color x. We can do the following greedy algorithm to minimize the number of days: Find leftmost house not painted in color x. Assume this is in position i. Then we will paint [i,i+k\u22121] with color x. Repeat this until all houses are painted in color x. Why is this optimal? When we find the leftmost house not painted in x, we know we need to change it, and as it is the leftmost one, everything before it is painted in x. To maximize our chances of changing other houses that need repainting, we choose this as the leftmost position in our painting range. This can be implemented easily with a linear pass. However, we don't know the color x that we will have at the end. Limit of colors are small enough, so we can try all of them and just keep the smallest answer.Time complexity: O(n\u22c5max(c))Space complexity: O(n) "
    },
    "1413B": {
        "title": "B. A New Technique",
        "description": "All techniques in the ninja world consist of hand seals. At the moment Naruto is learning a new technique, which consists of n\u22c5m different seals, denoted by distinct numbers. All of them were written in an n\u00d7m table.\nThe table is lost now. Naruto managed to remember elements of each row from left to right, and elements of each column from top to bottom, but he doesn't remember the order of rows and columns. Please restore the table consistent with this data so that Naruto will be able to learn the new technique.\nThe first line of the input contains the only integer t (1\u2264t\u2264100000) denoting the number of test cases. Their descriptions follow.\nThe first line of each test case description consists of two space-separated integers n and m (1\u2264n,m\u2264500) standing for the number of rows and columns in the table, respectively. All hand seals are encoded by the positive integers from 1 to n\u22c5m.\nThe following n lines contain m space separated integers each, denoting elements of an arbitrary row in the table left to right.\nThe following m lines contain n space separated integers each, denoting elements of an arbitrary column in the table top to bottom.\nSum of nm over all test cases does not exceed 250000. It is guaranteed that each row occurs in the input exactly once, as well as each column. It is also guaranteed that each number from 1 to nm occurs exactly once in all rows, as well as in all columns. Finally, it is guaranteed that a table consistent with the input exists.\nFor each test case, output n lines with m space-separated integers each, denoting the restored table. One can show that the answer is always unique.\nConsider the first test case. The matrix is 2\u00d73. You are given the rows and columns in arbitrary order.\nOne of the rows is [6,5,4]. One of the rows is [1,2,3].\nOne of the columns is [1,6]. One of the columns is [2,5]. One of the columns is [3,4].\nYou are to reconstruct the matrix. The answer is given in the output.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "1413B - A New TechniqueTo solve this problem it's sufficient to find the position of each row in the table. If we consider the first number of each row and find a column containing it, we will automatically obtain the position of the row. Since all numbers are distinct, the positions will be determined uniquely. Problem C of tc/C div2/A div1 (Perform Easily)"
    },
    "1411B": {
        "title": "B. Fair Numbers",
        "description": "We call a positive integer number fair if it is divisible by each of its nonzero digits. For example, 102 is fair (because it is divisible by 1 and 2), but 282 is not, because it isn't divisible by 8. Given a positive integer n. Find the minimum integer x, such that n\u2264x and x is fair.\nThe first line contains number of test cases t (1\u2264t\u2264103). Each of the next t lines contains an integer n (1\u2264n\u22641018).\nFor each of t test cases print a single integer\u00a0\u2014 the least fair number, which is not less than n.\nExplanations for some test cases: ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "number theory",
            "*1000"
        ],
        "solutions": "1411B - Fair NumbersLet's call a number super-fair if it is divisible by each of the numbers 1..9. It is fair to say that super-fair numbers are also divisible by LCM(1..9) which is equal to 2520. The answer isn't larger than the nearest super-fair number, which means that you can increase the original n by one until it becomes fair. We will determine if the number is fair by checking each of its digits separately. "
    },
    "1409C": {
        "title": "C. Yet Another Array Restoration",
        "description": "We have a secret array. You don't know this array and you have to restore it. However, you know some facts about this array:\nIt can be proven that such an array always exists under the constraints given below.\nAmong all possible arrays that satisfy the given conditions, we ask you to restore one which has the minimum possible maximum element. In other words, you have to minimize max(a1,a2,\u2026,an).\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases. Then t test cases follow.\nThe only line of the test case contains three integers n, x and y (2\u2264n\u226450; 1\u2264x<y\u226450) \u2014 the length of the array and two elements that are present in the array, respectively.\nFor each test case, print the answer: n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is the i-th element of the required array. If there are several answers, you can print any (it also means that the order of elements doesn't matter).\nIt can be proven that such an array always exists under the given constraints.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1409C - Yet Another Array RestorationThe only fact required to solve this problem is just to notice that the answer array is just an arithmetic progression. After that, we can fix the first element start, fix the difference d, construct the array [start,start+d,start+2d,\u2026,start+d\u22c5(n\u22121)], check if x and y are in this array and, if yes, update the answer with start+d\u22c5(n\u22121). This is O(n3) solution.There are faster solutions, though. Other author's solution is O(ny\u221a) but I didn't want to make this problem harder, so I allowed O(n3) solutions.It is obvious that the difference of the progression is some divisor of y\u2212x. Let it be d. Let's add some elements starting from y \"to the left\" (y,y\u2212d,y\u22122d and so on) and stop if we reach n elements or the next element is less than 1. If we didn't find x among these elements, just skip this difference, it is useless for us. Otherwise, if we have less than n elements, let's add y+d,y+2d,y+3d and so on until we get n elements. And then update the answer with the maximum element of the array.There is also a solution in O(n+y\u221a) with some greedy observations :) Solution (Gassa)// Author: Ivan Kazmenko (gassa@mail.ru)\nmodule solution;\nimport std.algorithm;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nimport std.string;\n\nvoid main ()\n{\n\tauto tests = readln.strip.to !(int);\n\tforeach (test; 0..tests)\n\t{\n\t\tint n, x, y;\n\t\treadf !(\" %s %s %s\") (n, x, y);\n\t\tauto answer = int.max.repeat (n).array;\n\t\tforeach (start; 1..51)\n\t\t{\n\t\t\tforeach (d; 1..51)\n\t\t\t{\n\t\t\t\tauto a = iota (start, start + d * n, d).array;\n\t\t\t\tif (a.canFind (x) && a.canFind (y))\n\t\t\t\t{\n\t\t\t\t\tif (answer.back > a.back)\n\t\t\t\t\t{\n\t\t\t\t\t\tanswer = a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twritefln !(\"%(%s %)\") (answer);\n\t}\n} Solution (vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, x, y;\n\t\tcin >> n >> x >> y;\n\t\tvector<int> ans;\n\t\tfor (int d = 1; d <= y - x; ++d) {\n\t\t\tif ((y - x) % d != 0) continue;\n\t\t\tvector<int> res;\n\t\t\tbool foundx = false;\n\t\t\tint cur = y;\n\t\t\tint need = n;\n\t\t\twhile (cur >= 1 && need > 0) {\n\t\t\t\tres.push_back(cur);\n\t\t\t\tfoundx |= cur == x;\n\t\t\t\t--need;\n\t\t\t\tcur -= d;\n\t\t\t}\n\t\t\tcur = y;\n\t\t\twhile (need > 0) {\n\t\t\t\tcur += d;\n\t\t\t\tres.push_back(cur);\n\t\t\t\t--need;\n\t\t\t}\n\t\t\tsort(res.begin(), res.end());\n\t\t\tif (need == 0 && foundx) {\n\t\t\t\tif (ans.empty() || ans.back() > res.back()) {\n\t\t\t\t\tans = res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(!ans.empty());\n\t\tfor (auto it : ans) cout << it << \" \";\n\t\tcout << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n} Solution (Rox)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int tcs;\n    cin >> tcs;\n\n    while (tcs--) {\n        int n, x, y;\n        cin >> n >> x >> y;\n        int diff = y - x;\n        for (int delta = 1; delta <= diff; ++delta) {\n            if (diff % delta) continue;\n            if (diff / delta + 1 > n) continue;\n            int k = min((y - 1) / delta, n - 1);\n            int a0 = y - k * delta;\n            for (int i = 0; i < n; ++i) {\n                cout << (a0 + i * delta) << ' ';\n            }\n            cout << endl;\n            break;\n        }\n    }\n}"
    },
    "1409B": {
        "title": "B. Minimum Product",
        "description": "You are given four integers a, b, x and y. Initially, a\u2265x and b\u2265y. You can do the following operation no more than n times:\nYour task is to find the minimum possible product of a and b (a\u22c5b) you can achieve by applying the given operation no more than n times.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe only line of the test case contains five integers a, b, x, y and n (1\u2264a,b,x,y,n\u2264109). Additional constraint on the input: a\u2265x and b\u2265y always holds.\nFor each test case, print one integer: the minimum possible product of a and b (a\u22c5b) you can achieve by applying the given operation no more than n times.\nIn the first test case of the example, you need to decrease b three times and obtain 10\u22c57=70.\nIn the second test case of the example, you need to decrease a one time, b one time and obtain 11\u22c57=77.\nIn the sixth test case of the example, you need to decrease a five times and obtain 5\u22c511=55.\nIn the seventh test case of the example, you need to decrease b ten times and obtain 10\u22c51=10.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1409B - Minimum ProductIdea: vovuh TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint a, b, x, y, n;\n\t\tcin >> a >> b >> x >> y >> n;\n\t\tlong long ans = 1e18;\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tint da = min(n, a - x);\n\t\t\tint db = min(n - da, b - y);\n\t\t\tans = min(ans, (a - da) * 1ll * (b - db));\n\t\t\tswap(a, b);\n\t\t\tswap(x, y);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1407A": {
        "title": "A. Ahahahahahahahaha",
        "description": "Alexandra has an even-length array a, consisting of 0s and 1s. The elements of the array are enumerated from 1 to n. She wants to remove at most n2 elements (where n \u2014 length of array) in the way that alternating sum of the array will be equal 0 (i.e. a1\u2212a2+a3\u2212a4+\u2026=0). In other words, Alexandra wants sum of all elements at the odd positions and sum of all elements at the even positions to become equal. The elements that you remove don't have to be consecutive.\nFor example, if she has a=[1,0,1,0,0,0] and she removes 2nd and 4th elements, a will become equal [1,1,0,0] and its alternating sum is 1\u22121+0\u22120=0.\nHelp her!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264103). Description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264103, n is even) \u00a0\u2014 length of the array.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u22641) \u00a0\u2014 elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 103.\nFor each test case, firstly, print k (n2\u2264k\u2264n) \u2014 number of elements that will remain after removing in the order they appear in a. Then, print this k numbers. Note that you should print the numbers themselves, not their indices.\nWe can show that an answer always exists. If there are several answers, you can output any of them. \nIn the first and second cases, alternating sum of the array, obviously, equals 0.\nIn the third case, alternating sum of the array equals 1\u22121=0.\nIn the fourth case, alternating sum already equals 1\u22121+0\u22120=0, so we don't have to remove anything.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1407A - AhahahahahahahahaLet cnt0 be the count of zeroes in the array, cnt1 \u2014 count of ones. Then if cnt1\u2264n2, we remove all ones and alternating sum, obliously, equals 0. Otherwise, cnt0<n2, we remove all zeroes and if cnt1 is odd \u2014 plus another 1. In this case, alternating sum equals 1\u22121+1\u2212\u2026\u22121=0 (because count of remaining ones if even) and we'll remove not more than cnt0+1\u2264n2. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int>a(n), ans;\n        int cnt0 = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (!a[i]) cnt0++;\n        }\n        int cnt1 = n - cnt0;\n        if (cnt0 >= n / 2) {\n            cout << cnt0 << '\\n';\n            for (int i = 0; i < cnt0; i++) cout << 0 << ' ';\n        } else {\n            cout << cnt1 - cnt1 % 2 << '\\n';\n            for (int i = 0; i < cnt1 - cnt1 % 2; i++) {\n                cout << 1 << ' ';\n            }\n        }\n        cout << '\\n';\n    }\n    return 0;\n}"
    },
    "1406B": {
        "title": "B. Maximum Product",
        "description": "You are given an array of integers a1,a2,\u2026,an. Find the maximum possible value of aiajakalat among all five indices (i,j,k,l,t) (i<j<k<l<t).\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (5\u2264n\u2264105) \u2014 the size of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u22123\u00d7103\u2264ai\u22643\u00d7103) \u2014 given array.\nIt's guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the answer to the problem.\nIn the first test case, choosing a1,a2,a3,a4,a5 is a best choice: (\u22121)\u22c5(\u22122)\u22c5(\u22123)\u22c5(\u22124)\u22c5(\u22125)=\u2212120.\nIn the second test case, choosing a1,a2,a3,a5,a6 is a best choice: (\u22121)\u22c5(\u22122)\u22c5(\u22123)\u22c52\u22c5(\u22121)=12.\nIn the third test case, choosing a1,a2,a3,a4,a5 is a best choice: (\u22121)\u22c50\u22c50\u22c50\u22c5(\u22121)=0.\nIn the fourth test case, choosing a1,a2,a3,a4,a6 is a best choice: (\u22129)\u22c5(\u22127)\u22c5(\u22125)\u22c5(\u22123)\u22c51=945.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1406B - Maximum ProductFirst, if all numbers are less than 0, then you should print the product of the five biggest numbers of them.Otherwise, the maximum product must be non-negative. Sort the numbers by their absolute value from big to small. If the first five numbers' product is positive then print it. Then we can always change one of the five to one of the n\u22125 other numbers to make this product positive. Enumerate which one to replace, and you can solve this problem in O(n) time.idea: feecIe6418 solution:feecIe6418 tutorial:feecIe6418Jury solution:92671590 "
    },
    "1405B": {
        "title": "B. Array Cancellation",
        "description": "You're given an array a of n integers, such that a1+a2+\u22ef+an=0.\nIn one operation, you can choose two different indices i and j (1\u2264i,j\u2264n), decrement ai by one and increment aj by one. If i<j this operation is free, otherwise it costs one coin.\nHow many coins do you have to spend in order to make all elements equal to 0?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22645000). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u00a0\u2014 the number of elements.\nThe next line contains n integers a1,\u2026,an (\u2212109\u2264ai\u2264109). It is given that \u2211ni=1ai=0.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the minimum number of coins we have to spend in order to make all elements equal to 0.\nPossible strategy for the first test case: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1000"
        ],
        "solutions": "1405B - Array CancellationThe answer is the maximum suffix sum, which can be computed in O(n).Formal proof.Define ci=ai+ai+1+\u22ef+an (partial suffix sum). Note M=max(c).We can observe that a1=\u22ef=an=0 if and only if c1=\u22ef=cn=0. (If c is null, ai=ci\u2212ci+1=0\u22120=0.)A free operation on i<j is equivalent to incrementing ci+1,\u2026,cj. Free operations can only increment elements of c, so we obviously need at least M coins.Let's do M times the operation (i=n,j=1), which decrement every element M times. Now, for every i, ci\u22640 and we can make it equal to 0 by performing \u2212ci times the free operation (i\u22121,i).Implementation"
    },
    "1401B": {
        "title": "B. Ternary Sequence",
        "description": "You are given two sequences a1,a2,\u2026,an and b1,b2,\u2026,bn. Each element of both sequences is either 0, 1 or 2. The number of elements 0, 1, 2 in the sequence a is x1, y1, z1 respectively, and the number of elements 0, 1, 2 in the sequence b is x2, y2, z2 respectively.\nYou can rearrange the elements in both sequences a and b however you like. After that, let's define a sequence c as follows:\nci={aibiif\u00a0ai>bi0if\u00a0ai=bi\u2212aibiif\u00a0ai<bi\nYou'd like to make \u2211ni=1ci (the sum of all elements of the sequence c) as large as possible. What is the maximum possible sum?\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of two lines. The first line of each test case contains three integers x1, y1, z1 (0\u2264x1,y1,z1\u2264108)\u00a0\u2014 the number of 0-s, 1-s and 2-s in the sequence a.\nThe second line of each test case also contains three integers x2, y2, z2 (0\u2264x2,y2,z2\u2264108; x1+y1+z1=x2+y2+z2>0)\u00a0\u2014 the number of 0-s, 1-s and 2-s in the sequence b.\nFor each test case, print the maximum possible sum of the sequence c.\nIn the first sample, one of the optimal solutions is:\na={2,0,1,1,0,2,1}\nb={1,0,1,0,2,1,0}\nc={2,0,0,0,0,2,0}\nIn the second sample, one of the optimal solutions is:\na={0,2,0,0,0}\nb={1,1,0,1,0}\nc={0,2,0,0,0}\nIn the third sample, the only possible solution is:\na={2}\nb={2}\nc={0}",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1401B - \u0422\u0440\u043e\u0438\u0447\u043d\u0430\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044cWe can find the kind of the value of ci is three (\u22122,0,2). And ci is \u22122 only if ai is 1 and bi is 2, and ci is 2 only if ai is 2 and bi is 1. Otherwise ci is 0. So we have to make (ai,bi) pair (1,2) as little as possible, and pair (2,1) as much as possible. To do this, first we can make (1,0) pair, (0,2) pair, and (2,1) pair as much as possible. After that, pairing the remaining values doesn't affect the sum of ci. (It ai in which value is 1 and bi in which value is 2 are all left, we have to pair them although the sum decreases.)Time complexity : O(1) Solution Code#include<bits/stdc++.h>\n\n#define endl '\\n'\n\nusing namespace std;\n\nmain()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int t;\n\n    cin >> t;\n    for(;t--;)\n    {\n\tint m, sum = 0, x0, x1, x2, y0, y1, y2;\n\n\tcin >> x0 >> x1 >> x2 >> y0 >> y1 >> y2;\n\n\tm = min(x0, y2);\n\tx0 -= m;\n\ty2 -= m;\n\n\tm = min(x1, y0);\n\tx1 -= m;\n\ty0 -= m;\n\n\tm = min(x2, y1);\n\tx2 -= m;\n\ty1 -= m;\n\tsum += 2 * m;\n\n\tsum -= 2 * min(x1, y2);\n\n\tcout << sum << endl;\n    }\n} Behind StoryOne tester suggested to swap A and B but I and adedalic thought it is not good idea, so the order didn't changed."
    },
    "1399C": {
        "title": "C. Boats Competition",
        "description": "There are n people who want to participate in a boat competition. The weight of the i-th participant is wi. Only teams consisting of two people can participate in this competition. As an organizer, you think that it's fair to allow only teams with the same total weight.\nSo, if there are k teams (a1,b1), (a2,b2), \u2026, (ak,bk), where ai is the weight of the first participant of the i-th team and bi is the weight of the second participant of the i-th team, then the condition a1+b1=a2+b2=\u22ef=ak+bk=s, where s is the total weight of each team, should be satisfied.\nYour task is to choose such s that the number of teams people can create is the maximum possible. Note that each participant can be in no more than one team.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u226450) \u2014 the number of participants. The second line of the test case contains n integers w1,w2,\u2026,wn (1\u2264wi\u2264n), where wi is the weight of the i-th participant.\nFor each test case, print one integer k: the maximum number of teams people can compose with the total weight s, if you choose s optimally.\nIn the first test case of the example, we can reach the optimal answer for s=6. Then the first boat is used by participants 1 and 5 and the second boat is used by participants 2 and 4 (indices are the same as weights).\nIn the second test case of the example, we can reach the optimal answer for s=12. Then first 6 participants can form 3 pairs.\nIn the third test case of the example, we can reach the optimal answer for s=3. The answer is 4 because we have 4 participants with weight 1 and 4 participants with weight 2.\nIn the fourth test case of the example, we can reach the optimal answer for s=4 or s=6.\nIn the fifth test case of the example, we can reach the optimal answer for s=3. Note that participant with weight 3 can't use the boat because there is no suitable pair for him in the list.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "two pointers",
            "*1200"
        ],
        "solutions": "1399C - Boats CompetitionThis is just an implementation problem. Firstly, let's fix s (it can be in range [2;2n]), find the maximum number of boats we can obtain with this s and choose the maximum among all found values.To find the number of pairs, let's iterate over the smallest weight in the team in range [1;\u230as+12\u230b\u22121]. Let this weight be i. Then (because the sum of weights is s) the biggest weight is s\u2212i. And the number of pairs we can obtain with such two weights and the total weight s is min(cnti,cnts\u2212i), where cnti is the number of occurrences of i in w. And the additional case: if s is even, we need to add \u230acnts22\u230b. Don't forget that there is a case s\u2212i>n, so you need to assume that these values cnt are zeros. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> cnt(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t++cnt[x];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int s = 2; s <= 2 * n; ++s) {\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 1; i < (s + 1) / 2; ++i) {\n\t\t\t\tif (s - i > n) continue;\n\t\t\t\tcur += min(cnt[i], cnt[s - i]);\n\t\t\t}\n\t\t\tif (s % 2 == 0) cur += cnt[s / 2] / 2;\n\t\t\tans = max(ans, cur);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1395B": {
        "title": "B. Boboniu Plays Chess",
        "description": "Boboniu likes playing chess with his employees. As we know, no employee can beat the boss in the chess game, so Boboniu has never lost in any round.\nYou are a new applicant for his company. Boboniu will test you with the following chess question:\nConsider a n\u00d7m grid (rows are numbered from 1 to n, and columns are numbered from 1 to m). You have a chess piece, and it stands at some cell (Sx,Sy) which is not on the border (i.e. 2\u2264Sx\u2264n\u22121 and 2\u2264Sy\u2264m\u22121).\nFrom the cell (x,y), you can move your chess piece to (x,y\u2032) (1\u2264y\u2032\u2264m,y\u2032\u2260y) or (x\u2032,y) (1\u2264x\u2032\u2264n,x\u2032\u2260x). In other words, the chess piece moves as a rook. From the cell, you can move to any cell on the same row or column.\nYour goal is to visit each cell exactly once. Can you find a solution?\nNote that cells on the path between two adjacent cells in your route are not counted as visited, and it is not required to return to the starting point.\nThe only line of the input contains four integers n, m, Sx and Sy (3\u2264n,m\u2264100, 2\u2264Sx\u2264n\u22121, 2\u2264Sy\u2264m\u22121) \u2014 the number of rows, the number of columns, and the initial position of your chess piece, respectively.\nYou should print n\u22c5m lines.\nThe i-th line should contain two integers xi and yi (1\u2264xi\u2264n, 1\u2264yi\u2264m), denoting the i-th cell that you visited. You should print exactly nm pairs (xi,yi), they should cover all possible pairs (xi,yi), such that 1\u2264xi\u2264n, 1\u2264yi\u2264m.\nWe can show that under these constraints there always exists a solution. If there are multiple answers, print any.\nPossible routes for two examples:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "*1100"
        ],
        "solutions": "1395B - Boboniu Plays ChessThere are many solutions and I will describe one of them.Let say f(i,j)=((i+Sx\u22122)modn+1,(j+Sy\u22122)modm+1).Iterate i from 1 to n:  if i is odd, print f(i,1),f(i,2),\u2026,f(i,m).  Else print f(i,m),f(i,m\u22121),\u2026,f(i,1).  Solution#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\n\nint n,m,sx,sy;\n\nvoid f(int i,int j){\n    printf(\"%d %d\\n\",(i+sx-2)%n+1,(j+sy-2)%m+1);\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&m,&sx,&sy);\n    FOR(i,1,n){\n        if(i&1)FOR(j,1,m)f(i,j);\n        else ROF(j,m,1)f(i,j);\n    }\n    return 0;\n}\t"
    },
    "1395A": {
        "title": "A. Boboniu Likes to Color Balls",
        "description": "Boboniu gives you\nHe allows you to do the following operation as many times as you want: \nYou should answer if it's possible to arrange all the balls into a palindrome after several (possibly zero) number of described operations. \nThe first line contains one integer T (1\u2264T\u2264100) denoting the number of test cases.\nFor each of the next T cases, the first line contains four integers r, g, b and w (0\u2264r,g,b,w\u2264109).\nFor each test case, print \"Yes\" if it's possible to arrange all the balls into a palindrome after doing several (possibly zero) number of described operations. Otherwise, print \"No\".\nIn the first test case, you're not able to do any operation and you can never arrange three balls of distinct colors into a palindrome.\nIn the second test case, after doing one operation, changing (8,1,9,3) to (7,0,8,6), one of those possible palindromes may be \"rrrwwwbbbbrbbbbwwwrrr\".\nA palindrome is a word, phrase, or sequence that reads the same backwards as forwards. For example, \"rggbwbggr\", \"b\", \"gg\" are palindromes while \"rgbb\", \"gbbgr\" are not. Notice that an empty word, phrase, or sequence is palindrome.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1000"
        ],
        "solutions": "1395A - Boboniu Likes to Color BallsIdea: dqa2021 TutorialTutorial is loading... Solutiondef check(r,g,b,w):\n    return False if r%2 + g%2 + b%2 + w%2 > 1 else True\n\nif __name__ == '__main__':\n    T = int(input())\n    for ttt in range(T):\n        r,g,b,w = map(int,input().split())\n        if check(r,g,b,w):\n            print(\"Yes\")\n        elif r>0 and g>0 and b>0 and check(r-1,g-1,b-1,w+1):\n            print(\"Yes\")\n        else :\n            print(\"No\")"
    },
    "1392C": {
        "title": "C. Omkar and Waterslide",
        "description": "Omkar is building a waterslide in his water park, and he needs your help to ensure that he does it as efficiently as possible.\nOmkar currently has n supports arranged in a line, the i-th of which has height ai. Omkar wants to build his waterslide from the right to the left, so his supports must be nondecreasing in height in order to support the waterslide. In 1 operation, Omkar can do the following: take any contiguous subsegment of supports which is nondecreasing by heights and add 1 to each of their heights. \nHelp Omkar find the minimum number of operations he needs to perform to make his supports able to support his waterslide!\nAn array b is a subsegment of an array c if b can be obtained from c by deletion of several (possibly zero or all) elements from the beginning and several (possibly zero or all) elements from the end.\nAn array b1,b2,\u2026,bn is called nondecreasing if bi\u2264bi+1 for every i from 1 to n\u22121.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264100). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of supports Omkar has.\nThe second line of each test case contains n integers a1,a2,...,an (0\u2264ai\u2264109)\u00a0\u2014 the heights of the supports.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations Omkar needs to perform to make his supports able to support his waterslide.\nThe subarray with which Omkar performs the operation is bolded.\nIn the first test case:\nFirst operation:\n[5,3,2,5]\u2192[5,3,3,5]\nSecond operation:\n[5,3,3,5]\u2192[5,4,4,5]\nThird operation:\n[5,4,4,5]\u2192[5,5,5,5]\nIn the third test case, the array is already nondecreasing, so Omkar does 0 operations.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1392C - Omkar and WaterslideCall the initial array a. We claim that the answer is \u2211max(ai\u2212ai+1,0) over the entire array of supports (call this value ans). Now let's show why.First, notice that in a nondecreasing array, ans=0. So, the problem is now to apply operations to the array such that ans=0.Now, let's see how applying one operation affects ans. Perform an operation on an arbitrary nondecreasing subarray that begins at index i and ends at index j. Note that the differences of elements within the subarray stay the same, so the only two pairs of elements which affect the sum are ai\u22121,ai and aj,aj+1.Let's initially look at the pair ai\u22121,ai. If ai\u22121\u2264ai (or if i=1), applying an operation would not change ans. But, if ai\u22121/gtai, applying an operation would decrease ans by 1.Now let's look at the pair aj,aj+1. If aj\u2264aj+1 (or if j=n), applying an operation would not change ans. But, if aj>aj+1, applying an operation would increase ans by 1.We have now shown that we can decrease ans by at most 1 with each operation, showing that it is impossible to make his supports able to hold the waterslide in fewer than \u2211max(ai\u2212ai+1,0) over the initial array. Now, let's construct a solution that applies exactly \u2211max(ai\u2212ai+1,0) operations to make the array valid.Consider applying operations to each suffix of length j until the suffix of length j+1 is nondecreasing. Since operations are applied iff an\u2212j+1<an\u2212j, and each operation decreases an\u2212j+1<an\u2212j by 1, the total number of operations would just be the sum of max(0,an\u2212j\u2212an\u2212j+1), which is equal to \u2211max(ai\u2212ai+1,0) over the entire array. Solution (Kotlin) by Tlatoaniimport kotlin.math.max\n\nfun main() {\n    for (c in 1..readLine()!!.toInt()) {\n        val n = readLine()!!.toInt()\n        val hs = readLine()!!.split(\" \").map { it.toLong() }\n        var answer = 0L\n        for (j in 1 until n) {\n            answer += max(0L, hs[j - 1] - hs[j])\n        }\n        println(answer)\n    }\n} Solution (Java) by qlf9import java.util.*;\nimport java.io.*;\n\npublic class OmkarAndWaterslide {\n    public static void main(String[] args) throws IOException{\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        int t = Integer.parseInt(f.readLine());\n        while(t-->0){\n            int n = Integer.parseInt(f.readLine());\n            long[] arr = new long[n];\n            StringTokenizer st = new StringTokenizer(f.readLine());\n            for(int i = 0; i < n; i++){\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n            long ans = 0;\n            for(int i = 0; i < n-1; i++){\n                ans+=Math.max(0, arr[i]-arr[i+1]);\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n} Solution (C++) by tfg#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <cassert>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint t;\n\tstd::cin >> t;\n\twhile(t--) {\n\t\tint n;\n\t\tstd::cin >> n;\n\t\tlong long last = 0;\n\t\tlong long ans = 0;\n\t\twhile(n--) {\n\t\t\tlong long x;\n\t\t\tstd::cin >> x;\n\t\t\tx += ans;\n\t\t\tif(x >= last) {\n\t\t\t\tlast = x;\n\t\t\t} else {\n\t\t\t\tans += last &mdash; x;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << '\\n';\n\t}\n}Idea: qlf9Preparation: qlf9 "
    },
    "1388B": {
        "title": "B. Captain Flint and a Long Voyage",
        "description": "Captain Flint and his crew keep heading to a savage shore of Byteland for several months already, drinking rum and telling stories. In such moments uncle Bogdan often remembers his nephew Denis. Today, he has told a story about how Denis helped him to come up with an interesting problem and asked the crew to solve it.\nIn the beginning, uncle Bogdan wrote on a board a positive integer x consisting of n digits. After that, he wiped out x and wrote integer k instead, which was the concatenation of binary representations of digits x consists of (without leading zeroes). For example, let x=729, then k=111101001 (since 7=111, 2=10, 9=1001).\nAfter some time, uncle Bogdan understood that he doesn't know what to do with k and asked Denis to help. Denis decided to wipe last n digits of k and named the new number as r.\nAs a result, Denis proposed to find such integer x of length n that r (as number) is maximum possible. If there are multiple valid x then Denis is interested in the minimum one.\nAll crew members, including captain Flint himself, easily solved the task. All, except cabin boy Kostya, who was too drunk to think straight. But what about you?\nNote: in this task, we compare integers (x or k) as numbers (despite what representations they are written in), so 729<1999 or 111<1000.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nNext t lines contain test cases\u00a0\u2014 one per test case. The one and only line of each test case contains the single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the integer x you need to find.\nIt's guaranteed that the sum of n from all test cases doesn't exceed 2\u22c5105.\nFor each test case, print the minimum integer x of length n such that obtained by Denis number r is maximum possible.\nIn the second test case (with n=3), if uncle Bogdan had x=998 then k=100110011000. Denis (by wiping last n=3 digits) will obtain r=100110011.\nIt can be proved that the 100110011 is the maximum possible r Denis can obtain and 998 is the minimum x to obtain it.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1388B - Captain Flint and a Long VoyageStatement: x consists of digits 8\u22129.This is so, because if x contains digits 0\u22127, which in their binary notation are shorter than digits 8\u22129, then the number k written on the board, and therefore the number r (obtained by removing the last n digits of the number k) will be shorter than if you use only the digits 8 and 9, which means it will not be the maximum possible.Statement: x is 99\u2026988\u20268.Obviously, the more x, the more k and r. Therefore, to maximize k, x must be 99\u2026999. However, due to the fact that r is k without the last n digits, at the end of the number x it is possible to replace a certain number of 9 digits with 8 so that r will still be the maximum possible.Statement: the number of digits 8 in the number x of length n is equal to \u2308n4\u2309.810=10002 and 910=10012. We can see that the binary notations of the digits 8 and 9 are 4 long and differ in the last digit.Suppose the suffix of a number x consists of p digits 8. Then the maximum r is achieved if at least 4\u22c5p\u22123 digits are removed from the end of k. By the condition of the problem, exactly n digits are removed, which means 4\u22c5p\u22123\u2264n and then p=\u230an+34\u230b=\u2308n4\u2309.Complexity: O(n). Solution (Karavaev1101)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n\n    int q;\n    cin >> q;\n\n    while (q--) {\n        int n; cin >> n;\n        int x = (n + 3) / 4;\n        for (int i = 0; i < n - x; ++i) {\n            cout << 9;\n        }\n        for (int i = 0; i < x; ++i) {\n            cout << 8;\n        }\n        cout << endl;\n    }\n}"
    },
    "1385C": {
        "title": "C. Make It Good",
        "description": "You are given an array a consisting of n integers. You have to find the length of the smallest (shortest) prefix of elements you need to erase from a to make it a good array. Recall that the prefix of the array a=[a1,a2,\u2026,an] is a subarray consisting several first elements: the prefix of the array a of length k is the array [a1,a2,\u2026,ak] (0\u2264k\u2264n).\nThe array b of length m is called good, if you can obtain a non-decreasing array c (c1\u2264c2\u2264\u22ef\u2264cm) from it, repeating the following operation m times (initially, c is empty):\nFor example, if we do 4 operations: take b1, then bm, then bm\u22121 and at last b2, then b becomes [b3,b4,\u2026,bm\u22123] and c=[b1,bm,bm\u22121,b2].\nConsider the following example: b=[1,2,3,4,4,2,1]. This array is good because we can obtain non-decreasing array c from it by the following sequence of operations:\nNote that the array consisting of one element is good.\nPrint the length of the shortest prefix of a to delete (erase), to make a to be a good array. Note that the required length can be 0.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the length of a. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5105), where ai is the i-th element of a.\nIt is guaranteed that the sum of n does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer: the length of the shortest prefix of elements you need to erase from a to make it a good array.\nIn the first test case of the example, the array a is already good, so we don't need to erase any prefix.\nIn the second test case of the example, the initial array a is not good. Let's erase first 4 elements of a, the result is [4,5,2]. The resulting array is good. You can prove that if you erase fewer number of first elements, the result will not be good.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "1385C - Make It GoodConsider the maximum element amx of the good array a of length k. Then we can notice that the array a looks like [a1\u2264a2\u2264\u22ef\u2264amx\u2265\u22ef\u2265ak\u22121\u2265ak]. And this is pretty obvious that if the array doesn't have this structure, then it isn't good (you can see it yourself). So we need to find the longest such suffix. It's pretty easy doable with pointer: initially, the pointer pos is at the last element. Then, while pos>1 and apos\u22121\u2265apos, decrease pos by one. If we're done with the previous step, we do the same, but while pos>1 and apos\u22121\u2264apos. The answer is pos\u22121. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tint pos = n - 1;\n\t\twhile (pos > 0 && a[pos - 1] >= a[pos]) --pos;\n\t\twhile (pos > 0 && a[pos - 1] <= a[pos]) --pos;\n\t\tcout << pos << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1384A": {
        "title": "A. Common Prefixes",
        "description": "The length of the longest common prefix of two strings s=s1s2\u2026sn and t=t1t2\u2026tm is defined as the maximum integer k (0\u2264k\u2264min(n,m)) such that s1s2\u2026sk equals t1t2\u2026tk.\nKoa the Koala initially has n+1 strings s1,s2,\u2026,sn+1.\nFor each i (1\u2264i\u2264n) she calculated ai\u00a0\u2014 the length of the longest common prefix of si and si+1.\nSeveral days later Koa found these numbers, but she couldn't remember the strings.\nSo Koa would like to find some strings s1,s2,\u2026,sn+1 which would have generated numbers a1,a2,\u2026,an. Can you help her?\nIf there are many answers print any. We can show that answer always exists for the given constraints. \nEach test contains multiple test cases. The first line contains t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the number of elements in the list a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u226450)\u00a0\u2014 the elements of a.\nIt is guaranteed that the sum of n over all test cases does not exceed 100.\nFor each test case:\nOutput n+1 lines. In the i-th line print string si (1\u2264|si|\u2264200), consisting of lowercase Latin letters. Length of the longest common prefix of strings si and si+1 has to be equal to ai.\nIf there are many answers print any. We can show that answer always exists for the given constraints.\nIn the 1-st test case one of the possible answers is s=[aeren,ari,arousal,around,ari].\nLengths of longest common prefixes are:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "strings",
            "*1200"
        ],
        "solutions": "1384A - Common PrefixesThe problem asks to find n+1 strings such that LCP(si,si+1)=ai for all i (1\u2264i\u2264n). A way to solve this problem is the following:  Set s1= \"aaaa...aaaaaaa\" (ie. 200 times 'a').  For i such that (1\u2264i\u2264n) set si+1:=si and then flip (ai+1)-th character of si+1 (ie. if it was 'a' put 'b' otherwise 'a'). So for each i:   si and si+1 will have exactly ai common characters from the prefix.  The (ai+1)-th character of si+1 is different than (ai+1)-th character of si (this character always exists since 0\u2264ai\u226450 and each string has length exactly 200).  Therefore the LCP is ai as desired. Time complexity: O(n) per testcase C++ solution#include <iostream>\n\n#define endl '\\n'\n\nusing namespace std;\n\nvoid solve()\n{\n    int n;\n    cin >> n;\n\n    string s(200, 'a');\n    cout << s << endl;\n\n    for (int i = 0; i < n; ++i)\n    {\n        int u;\n        cin >> u;\n        s[u] = s[u] == 'a' ? 'b' : 'a';\n        cout << s << endl;\n    }\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n\n    for (int i = 0; i < t; ++i)\n    {\n        solve();\n    }\n\n    return 0;\n} Python solutionimport sys\ninput = sys.stdin.readline\n\ndef main():\n    t = int(input())\n    \n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n    \n        mx = max(a)\n        ans = [ 'a' * (mx + 1) ] * (n + 1)\n    \n        for i, x in enumerate(a):\n            who = 'a' if ans[i][x] == 'b' else 'b'\n            ans[i + 1] = ans[i][:x] + who + ans[i][x + 1:]\n    \n        print('\\n'.join(ans))    \n\nmain()Problem idea: dcordbSolution idea: dcordb and Devil "
    },
    "1382B": {
        "title": "B. Sequential Nim",
        "description": "There are n piles of stones, where the i-th pile has ai stones. Two people play a game, where they take alternating turns removing stones.\nIn a move, a player may remove a positive number of stones from the first non-empty pile (the pile with the minimal index, that has at least one stone). The first player who cannot make a move (because all piles are empty) loses the game. If both players play optimally, determine the winner of the game.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases. Next 2t lines contain descriptions of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u00a0\u2014 the number of piles.\nThe second line of each test case contains n integers a1,\u2026,an (1\u2264ai\u2264109) \u00a0\u2014 ai is equal to the number of stones in the i-th pile.\nIt is guaranteed that the sum of n for all test cases does not exceed 105.\nFor each test case, if the player who makes the first move will win, output \"First\". Otherwise, output \"Second\".\nIn the first test case, the first player will win the game. His winning strategy is: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "games",
            "*1100"
        ],
        "solutions": "1382B - Sequential NimSuppose a1>1. If removing the entire first pile is winning, player 1 will do that. Otherwise, player 1 can leave exactly one stone in the first pile, forcing player 2 to remove it, leaving player 1 in the winning position. Otherwise, if a1=1, then it is forced to remove the first pile.So, whichever player gets the first pile with more than one stone wins. That is, let k be the maximum number such that a1=\u22ef=ak=1. If k is even, the first player will win. Otherwise, the second player will win. The only exception is when all piles have exactly 1 stone. In that case, the first player wins when k is odd.Complexity is O(n).Implementation"
    },
    "1375B": {
        "title": "B. Neighbor Grid",
        "description": "You are given a grid with n rows and m columns, where each cell has a non-negative integer written on it. We say the grid is good if for each cell the following condition holds: if it has a number k>0 written on it, then exactly k of its neighboring cells have a number greater than 0 written on them. Note that if the number in the cell is 0, there is no such restriction on neighboring cells.\nYou are allowed to take any number in the grid and increase it by 1. You may apply this operation as many times as you want, to any numbers you want. Perform some operations (possibly zero) to make the grid good, or say that it is impossible. If there are multiple possible answers, you may find any of them.\nTwo cells are considered to be neighboring if they have a common edge.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22645000) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (2\u2264n,m\u2264300) \u00a0\u2014 the number of rows and columns, respectively.\nThe following n lines contain m integers each, the j-th element in the i-th line ai,j is the number written in the j-th cell of the i-th row (0\u2264ai,j\u2264109).\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 105.\nIf it is impossible to obtain a good grid, print a single line containing \"NO\".\nOtherwise, print a single line containing \"YES\", followed by n lines each containing m integers, which describe the final state of the grid. This final grid should be obtainable from the initial one by applying some operations (possibly zero).\nIf there are multiple possible answers, you may print any of them.\nIn the first test case, we can obtain the resulting grid by increasing the number in row 2, column 3 once. Both of the cells that contain 1 have exactly one neighbor that is greater than zero, so the grid is good. Many other solutions exist, such as the grid\nAll of them are accepted as valid answers.\nIn the second test case, it is impossible to make the grid good.\nIn the third test case, notice that no cell has a number greater than zero on it, so the grid is automatically good.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1375B - \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0441\u043e\u0441\u0435\u0434\u0435\u0439For every cell (i,j) let's denote by ni,j the number of neighbors it has (either zero or non-zero, it doesn't matter). Then for each cell, it must hold that ai,j\u2264ni,j, otherwise, no solution exists because it is impossible to decrease ai,j.Let's now suppose that ai,j\u2264ni,j for all cells (i,j). Then a solution always exists: We can increase each ai,j to make it equal to ni,j. This always works because every number will be non-zero, so every neighbor of every cell will be non-zero, and every cell has a value equal to its number of neighbors.Problem B author \u2014 Ari Problem C"
    },
    "1375A": {
        "title": "A. Sign Flipping",
        "description": "You are given n integers a1,a2,\u2026,an, where n is odd. You are allowed to flip the sign of some (possibly all or none) of them. You wish to perform these flips in such a way that the following conditions hold:\nFind any valid way to flip the signs. It can be shown that under the given constraints, there always exists at least one choice of signs to flip that satisfies the required condition. If there are several solutions, you can find any of them.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264500) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (3\u2264n\u226499, n is odd) \u00a0\u2014 the number of integers given to you.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109) \u00a0\u2014 the numbers themselves.\nIt is guaranteed that the sum of n over all test cases does not exceed 10000.\nFor each test case, print n integers b1,b2,\u2026,bn, corresponding to the integers after flipping signs. bi has to be equal to either ai or \u2212ai, and of the adjacent differences bi+1\u2212bi for i=1,\u2026,n\u22121, at least n\u221212 should be non-negative and at least n\u221212 should be non-positive.\nIt can be shown that under the given constraints, there always exists at least one choice of signs to flip that satisfies the required condition. If there are several solutions, you can find any of them.\nIn the first test case, the difference (\u22124)\u2212(\u22122)=\u22122 is non-positive, while the difference 3\u2212(\u22124)=7 is non-negative.\nIn the second test case, we don't have to flip any signs. All 4 differences are equal to 0, which is both non-positive and non-negative.\nIn the third test case, 7\u2212(\u22124) and 4\u2212(\u22126) are non-negative, while (\u22124)\u2212(\u22122) and (\u22126)\u22127 are non-positive.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1375A - \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u043a\u043e\u0432Notice that $$$a_{i + 1} - a_i \\ge 0$$$ is equivalent to $$$a_{i + 1} \\ge a_i$$$. Similarly $$$a_{i + 1} - a_i \\le 0$$$ is equivalent to $$$a_{i + 1} \\le a_i$$$. Flip the signs in such a way that $$$a_i \\ge 0$$$ for odd $$$i$$$, while $$$a_i \\le 0$$$ for even $$$i$$$. Then  $$$a_{i + 1} \\ge 0 \\ge a_i$$$, and thus $$$a_{i + 1} \\ge a_i$$$, for $$$i = 2, 4, \\dots, n - 1$$$.  $$$a_{i + 1} \\le 0 \\le a_i$$$, and thus $$$a_{i + 1} \\le a_i$$$, for $$$i = 1, 3, \\dots, n - 2$$$. Giving at least $$$\\frac{n - 1}{2}$$$ of each, as desired.Problem A authors \u2014 antontrygubO_o, Ari Problem B"
    },
    "1374C": {
        "title": "C. Move Brackets",
        "description": "You are given a bracket sequence s of length n, where n is even (divisible by two). The string s consists of n2 opening brackets '(' and n2 closing brackets ')'.\nIn one move, you can choose exactly one bracket and move it to the beginning of the string or to the end of the string (i.e. you choose some index i, remove the i-th character of s and insert it before or after all remaining characters of s).\nYour task is to find the minimum number of moves required to obtain regular bracket sequence from s. It can be proved that the answer always exists under the given constraints.\nRecall what the regular bracket sequence is:\nFor example, \"()()\", \"(())()\", \"(())\" and \"()\" are regular bracket sequences, but \")(\", \"()(\" and \")))\" are not.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642000) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (2\u2264n\u226450) \u2014 the length of s. It is guaranteed that n is even. The second line of the test case containg the string s consisting of n2 opening and n2 closing brackets.\nFor each test case, print the answer \u2014 the minimum number of moves required to obtain regular bracket sequence from s. It can be proved that the answer always exists under the given constraints.\nIn the first test case of the example, it is sufficient to move the first bracket to the end of the string.\nIn the third test case of the example, it is sufficient to move the last bracket to the beginning of the string.\nIn the fourth test case of the example, we can choose last three openning brackets, move them to the beginning of the string and obtain \"((()))(())\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1000"
        ],
        "solutions": "1374C - Move BracketsLet's go from left to right over characters of s maintaining the current bracket balance (for the position i the balance is the number of opening brackets on the prefix till the i-th character minus the number of closing brackets on the same prefix).If the current balance becomes less than zero, then let's just take some opening bracket after the current position (it obviously exists because the number of opening equals the number of closing brackets) and move it to the beginning (so the negative balance becomes zero again and the answer increases by one). Or we can move the current closing bracket to the end of the string because it leads to the same result.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tint ans = 0;\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (s[i] == '(') ++bal;\n\t\t\telse {\n\t\t\t\t--bal;\n\t\t\t\tif (bal < 0) {\n\t\t\t\t\tbal = 0;\n\t\t\t\t\t++ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1373A": {
        "title": "A. Donut Shops",
        "description": "There are two rival donut shops.\nThe first shop sells donuts at retail: each donut costs a dollars.\nThe second shop sells donuts only in bulk: box of b donuts costs c dollars. So if you want to buy x donuts from this shop, then you have to buy the smallest number of boxes such that the total number of donuts in them is greater or equal to x.\nYou want to determine two positive integer values: \nIf any of these values doesn't exist then that value should be equal to \u22121. If there are multiple possible answers, then print any of them.\nThe printed values should be less or equal to 109. It can be shown that under the given constraints such values always exist if any values exist at all.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of testcases.\nEach of the next t lines contains three integers a, b and c (1\u2264a\u2264109, 2\u2264b\u2264109, 1\u2264c\u2264109).\nFor each testcase print two positive integers. For both shops print such x that buying x donuts in this shop is strictly cheaper than buying x donuts in the other shop. x should be greater than 0 and less or equal to 109.\nIf there is no such x, then print \u22121. If there are multiple answers, then print any of them.\nIn the first testcase buying any number of donuts will be cheaper in the second shop. For example, for 3 or 5 donuts you'll have to buy a box of 10 donuts for 4 dollars. 3 or 5 donuts in the first shop would cost you 15 or 25 dollars, respectively, however. For 20 donuts you'll have to buy two boxes for 8 dollars total. Note that 3 and 5 are also valid answers for the second shop, along with many other answers.\nIn the second testcase buying any number of donuts will be either cheaper in the first shop or the same price. 8 donuts cost 32 dollars in the first shop and 40 dollars in the second shop (because you have to buy two boxes). 10 donuts will cost 40 dollars in both shops, so 10 is not a valid answer for any of the shops.\nIn the third testcase 1 donut costs 2 and 3 dollars, respectively. 2 donuts cost 4 and 3 dollars. Thus, 1 is a valid answer for the first shop and 2 is a valid answer for the second shop.\nIn the fourth testcase 109 donuts cost 1018 dollars in the first shop and 109 dollars in the second shop.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1373A - Donut ShopsAt first notice that if there exists a value for the second shop, then the value divisible by b also exists. For any x you can round it up to the nearest multiple of b. That won't change the price for the second shop and only increase the price for the first shop.You can also guess that if there exists a value for the first shop, then the value with 1 modulo b also exists (exactly 1 donut on top of some number of full boxes). Following the same logic\u00a0\u2014 the second shop needs an entire new box and the first shop needs only an extra donut.So let's take a look at the smallest values of two kinds:   x=b: this value is valid for the second shop if one box is cheaper than b donuts in the first shop. Otherwise, no matter how many boxes will you take, they will never be cheaper than the corresponding number of donuts.  x=1: this value is valid for the first shop if one donut is cheaper than one box in the second shop. Apply the same idea\u00a0\u2014 otherwise no value for the first shop is valid. Overall complexity: O(1) per testcase. Solution (pikmike)for tc in range(int(input())):\n\ta, b, c = map(int, input().split())\n\tprint(1 if a < c else -1, end=\" \")\n\tprint(b if c < a * b else -1)"
    },
    "1371B": {
        "title": "B. Magical Calendar",
        "description": "A competitive eater, Alice is scheduling some practices for an eating contest on a magical calendar. The calendar is unusual because a week contains not necessarily 7 days!\nIn detail, she can choose any integer k which satisfies 1\u2264k\u2264r, and set k days as the number of days in a week.\nAlice is going to paint some n consecutive days on this calendar. On this calendar, dates are written from the left cell to the right cell in a week. If a date reaches the last day of a week, the next day's cell is the leftmost cell in the next (under) row.\nShe wants to make all of the painted cells to be connected by side. It means, that for any two painted cells there should exist at least one sequence of painted cells, started in one of these cells, and ended in another, such that any two consecutive cells in this sequence are connected by side.\nAlice is considering the shape of the painted cells. Two shapes are the same if there exists a way to make them exactly overlapped using only parallel moves, parallel to the calendar's sides.\nFor example, in the picture, a week has 4 days and Alice paints 5 consecutive days. [1] and [2] are different shapes, but [1] and [3] are equal shapes.\nAlice wants to know how many possible shapes exists if she set how many days a week has and choose consecutive n days and paints them in calendar started in one of the days of the week. As was said before, she considers only shapes, there all cells are connected by side.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Next t lines contain descriptions of test cases.\nFor each test case, the only line contains two integers n, r (1\u2264n\u2264109,1\u2264r\u2264109).\nFor each test case, print a single integer \u00a0\u2014 the answer to the problem.\nPlease note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language.\nIn the first test case, Alice can set 1,2,3 or 4 days as the number of days in a week.\nThere are 6 possible paintings shown in the picture, but there are only 4 different shapes. So, the answer is 4. Notice that the last example in the picture is an invalid painting because all cells are not connected by sides.\nIn the last test case, be careful with the overflow issue, described in the output format.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solutions": "1371B - Magical CalendarFirst, let's consider in case of a week has exactly w days.  If w<n , the length of painted cells is strictly more than one week. So there are w valid shapes. (The first week contains 1,2,...,w days) The shapes have w-day width, then if the value of w are different, the shapes are also different.  Otherwise (n\u2264w) , there is only one valid liner pattern. The shape is insensitive to the chosen value of w. We can sum up this for 1\u2264w\u2264r, by using following well-known formula: a+(a+1)+(a+2)+...+b=(a+b)\u2217(b\u2212a+1)2Total complexity : O(1) Jury solution: 85699884 "
    },
    "1370B": {
        "title": "B. GCD Compression",
        "description": "Ashish has an array a of consisting of 2n positive integers. He wants to compress a into an array b of size n\u22121. To do this, he first discards exactly 2 (any two) elements from a. He then performs the following operation until there are no elements left in a: \nThe compressed array b has to have a special property. The greatest common divisor (gcd) of all its elements should be greater than 1.\nRecall that the gcd of an array of positive integers is the biggest integer that is a divisor of all integers in the array.\nIt can be proven that it is always possible to compress array a into an array b of size n\u22121 such that gcd(b1,b2...,bn\u22121)>1. \nHelp Ashish find a way to do so.\nThe first line contains a single integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u22641000).\nThe second line of each test case contains 2n integers a1,a2,\u2026,a2n (1\u2264ai\u22641000)\u00a0\u2014 the elements of the array a.\nFor each test case, output n\u22121 lines\u00a0\u2014 the operations performed to compress the array a to the array b. The initial discard of the two elements is not an operation, you don't need to output anything about it.\nThe i-th line should contain two integers, the indices (1\u00a0\u2014based) of the two elements from the array a that are used in the i-th operation. All 2n\u22122 indices should be distinct integers from 1 to 2n.\nYou don't need to output two initially discarded elements from a.\nIf there are multiple answers, you can find any.\nIn the first test case, b={3+6,4+5}={9,9} and gcd(9,9)=9.\nIn the second test case, b={9+10}={19} and gcd(19)=19.\nIn the third test case, b={1+2,3+3,4+5,90+3}={3,6,9,93} and gcd(3,6,9,93)=3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1370B - GCD CompressionKey Idea:It is always possible to form n\u22121 pairs of elements such that their gcd is divisible by 2.Solution:We can pair up the odd numbers and even numbers separately so that the sum of numbers in each pair is divisible by 2. Note that we can always form n\u22121 pairs in the above manner because in the worst case, we would discard one odd number and one even number from a. If we discarded more than one even or odd numbers, we could instead form another pair with even sum.Time Complexity: O(n) Code\n#include < bits/stdc++.h >\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define int long long\n\nconst int N = 2e5 + 5;\n\nint n;\nint a[N];\n\nint32_t main()\n{\n\tIOS;\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tcin >> n;\n\t\tvector< int > even, odd;\n\t\tfor(int i = 1; i <= 2 * n; i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tif(a[i] % 2)\n\t\t\t\todd.push_back(i);\n\t\t\telse\n\t\t\t\teven.push_back(i);\n\t\t}\n\t\tvector< pair< int, int > > ans;\n\t\tfor(int i = 0; i + 1 < odd.size(); i += 2)\n\t\t\tans.push_back({odd[i], odd[i + 1]});\n\t\tfor(int i = 0; i + 1 < even.size(); i += 2)\n\t\t\tans.push_back({even[i], even[i + 1]});\n\t\tfor(int i = 0; i < n - 1; i++)\n\t\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n\treturn 0;\n}This problem was prepared by Ashishgup and ridbit10"
    },
    "1369B": {
        "title": "B. AccurateLee",
        "description": "Lee was cleaning his house for the party when he found a messy string under the carpets. Now he'd like to make it clean accurately and in a stylish way...\nThe string s he found is a binary string of length n (i. e. string consists only of 0-s and 1-s).\nIn one move he can choose two consecutive characters si and si+1, and if si is 1 and si+1 is 0, he can erase exactly one of them (he can choose which one to erase but he can't erase both characters simultaneously). The string shrinks after erasing.\nLee can make an arbitrary number of moves (possibly zero) and he'd like to make the string s as clean as possible. He thinks for two different strings x and y, the shorter string is cleaner, and if they are the same length, then the lexicographically smaller string is cleaner.\nNow you should answer t test cases: for the i-th test case, print the cleanest possible string that Lee can get by doing some number of moves.\nSmall reminder: if we have two strings x and y of the same length then x is lexicographically smaller than y if there is a position i such that x1=y1, x2=y2,..., xi\u22121=yi\u22121 and xi<yi.\nThe first line contains the integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. \nNext 2t lines contain test cases\u00a0\u2014 one per two lines.\nThe first line of each test case contains the integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the string s.\nThe second line contains the binary string s. The string s is a string of length n which consists only of zeroes and ones.\nIt's guaranteed that sum of n over test cases doesn't exceed 105.\nPrint t answers\u00a0\u2014 one per test case.\nThe answer to the i-th test case is the cleanest string Lee can get after doing some number of moves (possibly zero).\nIn the first test case, Lee can't perform any moves.\nIn the second test case, Lee should erase s2.\nIn the third test case, Lee can make moves, for example, in the following order: 11001101\u00a0\u2192 1100101\u00a0\u2192 110101\u00a0\u2192 10101\u00a0\u2192 1101\u00a0\u2192 101\u00a0\u2192 01.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "1369B - AccurateLeeCompleteProof :Realize that the answer is always non-descending, and we can't perform any operations on non-descending strings.First we know that we can't perform any operations on non-descending strings, so the answer to a non-descending string is itself. From now we consider our string s to not to be non-descending. (i.e. there exist index i such that 1\u2264i\u2264n\u22121 and si>si+1)Also realize that the remaining string wont be empty, so \"0\" is the cleanest possible answer, but we can't reach it probable.Now realize that leading zeroes and trailing ones can't be present in any operation. So they have to be in the answer, erase them from s, and add them to the answer for the modified s. From now we know that the string s has no leading zeroes and/or trailing ones, and is not non-descending, so it starts with 1 and ends with 0. (why?)With some small paperwork, we will realize that the answer to a string that starts with 1 and ends with 0 is a single 0(proof is bellow). So if the string s is non-descending and it has x leading zeroes and y trailing ones(x and y can be equal to zero), then the answer is 00\u20260\ue152\ue153\ue151\ue150\ue154\ue154\ue154\ue154x011\u20261\ue152\ue153\ue151\ue150\ue154\ue154\ue154\ue154y (its x+1 zeroes and y ones in order)TheSmallPaperwork:We will randomly perform operations until we can't do any more or the string's length is equal to 2, but we wont erase the first 1 and the last 0, we want to prove that the remaining string's length is exactly 2 after the process ends, proof by contradiction :So it's length is at least 3, so we have at least two 1 or at least two 0. If we had two or more 0 then the string [s1s2\u2026sn\u22121] will not be non-descending(so we can perform more operations as we proved in STAR, but the process have ended, contradiction!) and if we had two or more 1 then the string [s2s3\u2026sn] will not be non-descending. So the length of the remaining string is exactly 2, and we haven't erased first '1' and last '0', so the string is equal to \"10\", now erase '1' to get the cleanest string.Sorry if the proof seems too long and hard, i wanted to explain it accurately. ^-^ Python solutiont = int(input())\nfor testcase in range(t):\n    n = int(input())\n    s = input()\n    lef, rig, sw = 1, 1, 0\n    for i in range(n-1):\n        if(s[i] > s[i+1]):\n            sw = 1\n            break\n    if(sw == 0):\n        print(s)\n        continue\n    for i in range(n):\n        if (s[i] == '1'):\n            lef = i\n            break\n    for i in range(n-1, 0, -1):\n        if (s[i] == '0'):\n            rig = i\n            break\n    st = s[:lef] + '0' + s[rig+1:]\n    print(st)\n C++ solution#include <iostream>\n#include <string>\n \nusing namespace std;\n \nint main(){\n    \n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        int sw = 1;\n        for(int i = 1; i < s.size(); i++){\n            if(s[i] < s[i-1])sw = 0;\n        }\n        if(sw){\n            cout << s << '\\n';\n            continue;\n        }\n        string ans;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == '1')break;\n            ans.push_back('0');\n        }\n        ans.push_back('0');\n        for(int i = s.size()-1; i >= 0; i--){\n            if(s[i] == '0')break;\n            ans.push_back('1');\n        }\n        cout << ans << '\\n';\n    }\n}\nC. RationalLee :Invented by DeadlyCritic and adedalic. Brief SolutionBriefSolution :Give greatest elements to friends with wi=1. For the rest sort the elements in non-descending order of ai and sort the friends in non-ascending order of wi then give first w1\u22121 elements to friend 1, next w2\u22121 elements to friend 2 and so on, also give k\u2212i+1-th greatest element to friend i (1\u2264i\u2264k). Complete Proof"
    },
    "1366A": {
        "title": "A. Shovels and Swords",
        "description": "Polycarp plays a well-known computer game (we won't mention its name). In this game, he can craft tools of two types \u2014 shovels and swords. To craft a shovel, Polycarp spends two sticks and one diamond; to craft a sword, Polycarp spends two diamonds and one stick.\nEach tool can be sold for exactly one emerald. How many emeralds can Polycarp earn, if he has a sticks and b diamonds?\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nThe only line of each test case contains two integers a and b (0\u2264a,b\u2264109)\u00a0\u2014 the number of sticks and the number of diamonds, respectively.\nFor each test case print one integer \u2014 the maximum number of emeralds Polycarp can earn.\nIn the first test case Polycarp can earn two emeralds as follows: craft one sword and one shovel.\nIn the second test case Polycarp does not have any diamonds, so he cannot craft anything.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "1366A - Shovels and SwordsThere are three constraints on the number of emeralds:  the number of emeralds can't be greater than a;  the number of emeralds can't be greater than b;  the number of emeralds can't be greater than a+b3. So the answer is min(a,b,a+b3). Solution (Roms)for _ in range(int(input())):\n    l, r = map(int, input().split())\n    print(min(l, r, (l + r) // 3))"
    },
    "1365A": {
        "title": "A. Matrix Game",
        "description": "Ashish and Vivek play a game on a matrix consisting of n rows and m columns, where they take turns claiming cells. Unclaimed cells are represented by 0, while claimed cells are represented by 1. The initial state of the matrix is given. There can be some claimed cells in the initial state.\nIn each turn, a player must claim a cell. A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells. When a player is unable to make a move, he loses and the game ends.\nIf Ashish and Vivek take turns to move and Ashish goes first, determine the winner of the game if both of them are playing optimally.\nOptimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves.\nThe first line consists of a single integer t (1\u2264t\u226450)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case consists of two space-separated integers n, m (1\u2264n,m\u226450)\u00a0\u2014 the number of rows and columns in the matrix.\nThe following n lines consist of m integers each, the j-th integer on the i-th line denoting ai,j (ai,j\u2208{0,1}).\nFor each test case if Ashish wins the game print \"Ashish\" otherwise print \"Vivek\" (without quotes).\nFor the first case: One possible scenario could be: Ashish claims cell (1,1), Vivek then claims cell (2,2). Ashish can neither claim cell (1,2), nor cell (2,1) as cells (1,1) and (2,2) are already claimed. Thus Ashish loses. It can be shown that no matter what Ashish plays in this case, Vivek will win. \nFor the second case: Ashish claims cell (1,1), the only cell that can be claimed in the first move. After that Vivek has no moves left.\nFor the third case: Ashish cannot make a move, so Vivek wins.\nFor the fourth case: If Ashish claims cell (2,3), Vivek will have no moves left.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1365A - Matrix GameKey Idea:Vivek and Ashish can never claim cells in rows and columns which already have at least one cell claimed. So we need to look at the parity of minimum of the number of rows and columns which have no cells claimed initially.Solution:Let a be the number of rows which do not have any cell claimed in them initially and similarly b be the number of columns which do not have any cell claimed initially. Each time a player makes a move both a and b decrease by 1, since they only claim cells in rows and columns with no claimed cells. If either one of a or b becomes 0, the player whose turn comes next loses the game. Since both a and b decrease by 1 after each move, min(a,b) becomes 0 first. So, if min(a,b) is odd, Ashish wins the game otherwise Vivek wins.Time complexity: O(n\u22c5m) Code\n#include \nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define int long long\n\nconst int N = 51;\n\nint n, m;\nint a[N][N];\n\nint32_t main()\n{\n\tIOS;\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tcin >> n >> m;\n\t\tset< int > r, c;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tfor(int j = 1; j <= m; j++)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == 1)\n\t\t\t\t\tr.insert(i), c.insert(j);\n\t\t\t}\n\t\t}\n\t\tint mn = min(n \u2014 r.size(), m \u2014 c.size());\n\t\tif(mn % 2)\n\t\t\tcout << \"Ashish\" << endl;\n\t\telse\n\t\t\tcout << \"Vivek\" << endl;\n\t}\n\treturn 0;\n}This problem was prepared by Ashishgup"
    },
    "1364A": {
        "title": "A. XXXXX",
        "description": "Ehab loves number theory, but for some reason he hates the number x. Given an array a, find the length of its longest subarray such that the sum of its elements isn't divisible by x, or determine that such subarray doesn't exist.\nAn array a is a subarray of an array b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe first line contains an integer t (1\u2264t\u22645)\u00a0\u2014 the number of test cases you need to solve. The description of the test cases follows.\nThe first line of each test case contains 2 integers n and x (1\u2264n\u2264105, 1\u2264x\u2264104)\u00a0\u2014 the number of elements in the array a and the number that Ehab hates.\nThe second line contains n space-separated integers a1, a2, \u2026, an (0\u2264ai\u2264104)\u00a0\u2014 the elements of the array a.\nFor each testcase, print the length of the longest subarray whose sum isn't divisible by x. If there's no such subarray, print \u22121.\nIn the first test case, the subarray [2,3] has sum of elements 5, which isn't divisible by 3.\nIn the second test case, the sum of elements of the whole array is 6, which isn't divisible by 4.\nIn the third test case, all subarrays have an even sum, so the answer is \u22121.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "number theory",
            "two pointers",
            "*1200"
        ],
        "solutions": "1364A - XXXXXLet's start with the whole array. If every element in it is divisible by x, the answer is \u22121; if its sum isn't divisible by x, the answer is n. Otherwise, we must remove some elements. The key idea is that removing an element that is divisible by x doesn't do us any benefits, but once we remove an element that isn't, the sum won't be divisible by x. So let the first non-multiple of x be at index l, and the last one be at index r. We must either remove the prefix all the way up to l or the suffix all the way up to r, and we'll clearly remove whichever shorter.Code link: https://pastebin.com/j2Y8AJBAAlternatively, we can notice that this means the answer is either a prefix or a suffix, so we can simply bruteforce them all."
    },
    "1363A": {
        "title": "A. Odd Selection",
        "description": "Shubham has an array a of size n, and wants to select exactly x elements from it, such that their sum is odd. These elements do not have to be consecutive. The elements of the array are not guaranteed to be distinct.\nTell him whether he can do so.\nThe first line of the input contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264x\u2264n\u22641000)\u00a0\u2014 the length of the array and the number of elements you need to choose.\nThe next line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641000)\u00a0\u2014 elements of the array.\nFor each test case, print \"Yes\" or \"No\" depending on whether it is possible to choose x elements such that their sum is odd.\nYou may print every letter in any case you want.\nFor 1st case: We must select element 999, and the sum is odd.\nFor 2nd case: We must select element 1000, so overall sum is not odd.\nFor 3rd case: We can select element 51.\nFor 4th case: We must select both elements 50 and 51 \u00a0\u2014 so overall sum is odd.\nFor 5th case: We must select all elements \u00a0\u2014 but overall sum is not odd.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1363A - Odd SelectionKey Idea: The sum of x numbers can only be odd if we have an odd number of numbers which are odd. (An odd statement, indeed).Detailed Explanation: We first maintain two variables, num_odd and num_even, representing the number of odd and even numbers in the array, respectively. We then iterate over the number of odd numbers we can choose; which are 1,3,5,... upto min(num_odd,x), and see if num_even \u2265x\u2212i where i is the number of odd numbers we have chosen. Time complexity: O(N)Author of this problem was Ashishgup.  Relevant Meme Code for A#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define int long long\n \nconst int N = 2e5 + 5;\n \nint n, x;\nint a[N], f[2];\n \nint32_t main()\n{\n\tIOS;\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t    f[0] = f[1] = 0;\n    \tcin >> n >> x;\n    \tfor(int i = 1; i <= n; i++)\n    \t{\n    \t\tcin >> a[i];\n    \t\tf[a[i] % 2]++;\n    \t}\n    \tbool flag = 0;\n    \tfor(int i = 1; i <= f[1] && i <= x; i += 2) //Fix no of odd\n    \t{\n    \t\tint have = f[0], need = x - i;\n    \t\tif(need <= f[0])\n    \t        flag = 1;\n    \t}\n    \tif(flag)\n    \t    cout << \"Yes\" << endl;\n    \telse\n    \t    cout << \"No\" << endl;\n\t}\n\treturn 0;\n} "
    },
    "1362B": {
        "title": "B. Johnny and His Hobbies",
        "description": "Among Johnny's numerous hobbies, there are two seemingly harmless ones: applying bitwise operations and sneaking into his dad's office. As it is usually the case with small children, Johnny is unaware that combining these two activities can get him in a lot of trouble.\nThere is a set S containing very important numbers on his dad's desk. The minute Johnny heard about it, he decided that it's a good idea to choose a positive integer k and replace each element s of the set S with s\u2295k (\u2295 denotes the exclusive or operation). \nHelp him choose such k that Johnny's dad will not see any difference after his son is done playing (i.e. Johnny will get the same set as before playing). It is possible that no such number exists. It is also possible that there are many of them. In such a case, output the smallest one. Note that the order of elements in a set doesn't matter, i.e. set {1,2,3} equals to set {2,1,3}.\nFormally, find the smallest positive integer k such that {s\u2295k|s\u2208S}=S or report that there is no such number.\nFor example, if S={1,3,4} and k=2, new set will be equal to {3,1,6}. If S={0,1,2,3} and k=1, after playing set will stay the same.\nIn the first line of input, there is a single integer t (1\u2264t\u22641024), the number of test cases. In the next lines, t test cases follow. Each of them consists of two lines. \nIn the first line there is a single integer n (1\u2264n\u22641024) denoting the number of elements in set S. Second line consists of n distinct integers si (0\u2264si<1024), elements of S.\nIt is guaranteed that the sum of n over all test cases will not exceed 1024.\nPrint t lines; i-th line should contain the answer to the i-th test case, the minimal positive integer k satisfying the conditions or \u22121 if no such k exists.\nIn the first test case, the answer is 1 because it is a minimum positive integer and it satisfies all the conditions.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "*1200"
        ],
        "solutions": "1362B - Johnny and His HobbiesConsider i-th least significant bit (0 indexed). If it is set in k, but not in s, it will be set in k\u2295s. Hence k\u2295s\u22652i.Consider such minimal positive integer m, that 2m>s holds for all s\u2208S. k cannot have the i-th bit set for any i\u2265m. From this follows that k<2m. So there are only 2m feasible choices of k. We can verify if a number satisfies the condition from the statement in O(n) operations. This gives us a solution with complexity O(n\u22c52m). Note that in all tests m is at most 10.There is also another solution possible. It uses the observation that if k satisfies the required conditions, then for every s\u2208S there exists such t\u2208S (t\u2260s) , that t\u2295s=k. This gives us n\u22121 feasible choices of k and thus the complexity of this solution is O(n2). Solution//O(n * maxA) solution\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1025;\n\nint n;\nint in[N];\nbool is[N];\n\nbool check(int k){\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!is[in[i] ^ k])\n\t\t\treturn false;\n\treturn true;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < N; ++i)\n\t\tis[i] = false;\n\t\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", &in[i]);\n\t\tis[in[i]] = true;\n\t}\n\t\n\tfor(int k = 1; k < 1024; ++k)\n\t\tif(check(k)){\n\t\t\tprintf(\"%d\\n\", k);\n\t\t\treturn;\n\t\t}\n\t\n\tputs(\"-1\");\n}\n\nint main(){\n\tint cases;\n\tscanf(\"%d\", &cases);\n\t\n\twhile(cases--)\n\t\tsolve();\n\treturn 0;\n}\n"
    },
    "1362A": {
        "title": "A. Johnny and Ancient Computer",
        "description": "Johnny has recently found an ancient, broken computer. The machine has only one register, which allows one to put in there one variable. Then in one operation, you can shift its bits left or right by at most three positions. The right shift is forbidden if it cuts off some ones. So, in fact, in one operation, you can multiply or divide your number by 2, 4 or 8, and division is only allowed if the number is divisible by the chosen divisor. \nFormally, if the register contains a positive integer x, in one operation it can be replaced by one of the following: \nFor example, if x=6, in one operation it can be replaced by 12, 24, 48 or 3. Value 6 isn't divisible by 4 or 8, so there're only four variants of replacement.\nNow Johnny wonders how many operations he needs to perform if he puts a in the register and wants to get b at the end.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The following t lines contain a description of test cases.\nThe first and only line in each test case contains integers a and b (1\u2264a,b\u22641018)\u00a0\u2014 the initial and target value of the variable, respectively.\nOutput t lines, each line should contain one integer denoting the minimum number of operations Johnny needs to perform. If Johnny cannot get b at the end, then write \u22121.\nIn the first test case, Johnny can reach 5 from 10 by using the shift to the right by one (i.e. divide by 2).\nIn the second test case, Johnny can reach 44 from 11 by using the shift to the left by two (i.e. multiply by 4).\nIn the third test case, it is impossible for Johnny to reach 21 from 17.\nIn the fourth test case, initial and target values are equal, so Johnny has to do 0 operations.\nIn the fifth test case, Johnny can reach 3 from 96 by using two shifts to the right: one by 2, and another by 3 (i.e. divide by 4 and by 8).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1362A - Johnny and Ancient ComputerAuthor: Anadi TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL getR(LL a){\n\twhile(a % 2 == 0)\n\t\ta /= 2;\n\treturn a;\n}\n\nvoid solve(){\n\tLL a, b;\n\tscanf(\"%lld %lld\", &a, &b);\n\tif(a > b)\tswap(a, b);\n\t\n\tLL r = getR(a);\n\tif(getR(b) != r){\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\t\n\tint ans = 0;\n\tb /= a;\n\t\n\twhile(b >= 8)\n\t\tb /= 8, ++ans;\n\tif(b > 1)\t++ans;\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\tint quest;\n\tscanf(\"%d\", &quest);\n\t\n\twhile(quest--)\n\t\tsolve();\n\treturn 0;\n}\n"
    },
    "1360C": {
        "title": "C. Similar Pairs",
        "description": "We call two numbers x and y similar if they have the same parity (the same remainder when divided by 2), or if |x\u2212y|=1. For example, in each of the pairs (2,6), (4,3), (11,7), the numbers are similar to each other, and in the pairs (1,4), (3,12), they are not.\nYou are given an array a of n (n is even) positive integers. Check if there is such a partition of the array into pairs that each element of the array belongs to exactly one pair and the numbers in each pair are similar to each other.\nFor example, for the array a=[11,14,16,12], there is a partition into pairs (11,12) and (14,16). The numbers in the first pair are similar because they differ by one, and in the second pair because they are both even.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Then t test cases follow.\nEach test case consists of two lines.\nThe first line contains an even positive integer n (2\u2264n\u226450)\u00a0\u2014 length of array a.\nThe second line contains n positive integers a1,a2,\u2026,an (1\u2264ai\u2264100).\nFor each test case print:\nThe letters in the words YES and NO can be displayed in any case.\nThe first test case was explained in the statement.\nIn the second test case, the two given numbers are not similar.\nIn the third test case, any partition is suitable.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "graph matchings",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1360C - Similar PairsLet e\u00a0\u2014 be the number of even numbers in the array, and o\u00a0\u2014 be the number of odd numbers in the array. Note that if the parities of e and of o do not equal, then the answer does not exist. Otherwise, we consider two cases:   e and o\u00a0\u2014 are even numbers. Then all numbers can be combined into pairs of equal parity.  e and o\u00a0\u2014 are odd numbers. Then you need to check whether there are two numbers in the array such that the modulus of their difference is 1. If there are two such numbers, then combine them into one pair. e and o will decrease by 1 and become even, then the solution exists as shown in the previous case.  Solution#include <bits/stdc++.h>\n\nusing namespace std;\nusing ld = long double;\nusing ll = long long;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> v(n);\n    int a = 0, b = 0;\n    for (int &e : v) {\n        cin >> e;\n        if (e % 2 == 0) {\n            a++;\n        } else {\n            b++;\n        }\n    }\n    if (a % 2 != b % 2) {\n        cout << \"NO\\n\";\n    } else {\n        if (a % 2 == 0) {\n            cout << \"YES\\n\";\n        } else {\n            for (int i = 0; i < n; i++) {\n                for (int j = i + 1; j < n; j++) {\n                    if (v[i] % 2 != v[j] % 2 && abs(v[i] - v[j]) == 1) {\n                        cout << \"YES\\n\";\n                        return;\n                    }\n                }\n            }\n            cout << \"NO\\n\";\n        }\n    }\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}"
    },
    "1359B": {
        "title": "B. New Theatre Square",
        "description": "You might have remembered Theatre square from the problem 1A. Now it's finally getting repaved.\nThe square still has a rectangular shape of n\u00d7m meters. However, the picture is about to get more complicated now. Let ai,j be the j-th square in the i-th row of the pavement.\nYou are given the picture of the squares:\nThe black squares are paved already. You have to pave the white squares. There are two options for pavement tiles:\nYou should cover all the white squares, no two tiles should overlap and no black squares should be covered by tiles.\nWhat is the smallest total price of the tiles needed to cover all the white squares?\nThe first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of testcases. Then the description of t testcases follow.\nThe first line of each testcase contains four integers n, m, x and y (1\u2264n\u2264100; 1\u2264m\u22641000; 1\u2264x,y\u22641000)\u00a0\u2014 the size of the Theatre square, the price of the 1\u00d71 tile and the price of the 1\u00d72 tile.\nEach of the next n lines contains m characters. The j-th character in the i-th line is ai,j. If ai,j= \"*\", then the j-th square in the i-th row should be black, and if ai,j= \".\", then the j-th square in the i-th row should be white.\nIt's guaranteed that the sum of n\u00d7m over all testcases doesn't exceed 105.\nFor each testcase print a single integer\u00a0\u2014 the smallest total price of the tiles needed to cover all the white squares in burles.\nIn the first testcase you are required to use a single 1\u00d71 tile, even though 1\u00d72 tile is cheaper. So the total price is 10 burles.\nIn the second testcase you can either use two 1\u00d71 tiles and spend 20 burles or use a single 1\u00d72 tile and spend 1 burle. The second option is cheaper, thus the answer is 1.\nThe third testcase shows that you can't rotate 1\u00d72 tiles. You still have to use two 1\u00d71 tiles for the total price of 20.\nIn the fourth testcase the cheapest way is to use 1\u00d71 tiles everywhere. The total cost is 6\u22c53=18.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "1359B - New Theatre SquareNotice that rows can be solved completely separately of each other. Each tile takes either one or two squares but it's always in the same row.So let's take a look at a single row. There are sequences of dot characters separated by some asterisks. Once again each of these sequences can be solved independently of the others.Thus, we have these empty strips of empty squares 1\u00d7k which, when solved, can be summed up into the whole answer.There are two cases, depending on if a 1\u00d72 is cheaper than two 1\u00d71 tiles. If it is then we want to use of many 1\u00d72 tiles as possible. So given k, we can place \u230ak2\u230b 1\u00d72 tiles and cover the rest k\u22122\u22c5\u230ak2\u230b=k\u00a0mod\u00a02 squares with 1\u00d71 tiles.If it isn't cheaper then we want to cover everything with 1\u00d71 tiles and never use 1\u00d72 ones. So all k should be 1\u00d71.The easier way to implement this might be the following. Let's update the price of the 1\u00d72 tile with the minimum of y and 2\u22c5x. This way the first algorithm will produce exactly the same result of the second one in the case when a 1\u00d72 tile isn't cheaper than two 1\u00d71 ones.Overall complexity: O(nm) per testcase. Solution (pikmike)t = int(input())\nfor _ in range(t):\n\tn, m, x, y = map(int, input().split())\n\tans = 0\n\ty = min(y, 2 * x)\n\tfor __ in range(n):\n\t\ts = input()\n\t\ti = 0\n\t\twhile i < m:\n\t\t\tif s[i] == '*':\n\t\t\t\ti += 1\n\t\t\t\tcontinue\n\t\t\tj = i\n\t\t\twhile j + 1 < m and s[j + 1] == '.':\n\t\t\t\tj += 1\n\t\t\tl = j - i + 1\n\t\t\tans += l % 2 * x + l // 2 * y\n\t\t\ti = j + 1\n\tprint(ans)"
    },
    "1359A": {
        "title": "A. Berland Poker",
        "description": "The game of Berland poker is played with a deck of n cards, m of which are jokers. k players play this game (n is divisible by k).\nAt the beginning of the game, each player takes nk cards from the deck (so each card is taken by exactly one player). The player who has the maximum number of jokers is the winner, and he gets the number of points equal to x\u2212y, where x is the number of jokers in the winner's hand, and y is the maximum number of jokers among all other players. If there are two or more players with maximum number of jokers, all of them are winners and they get 0 points.\nHere are some examples:\nGiven n, m and k, calculate the maximum number of points a player can get for winning the game.\nThe first line of the input contains one integer t (1\u2264t\u2264500) \u2014 the number of test cases.\nThen the test cases follow. Each test case contains three integers n, m and k (2\u2264n\u226450, 0\u2264m\u2264n, 2\u2264k\u2264n, k is a divisors of n).\nFor each test case, print one integer \u2014 the maximum number of points a player can get for winning the game.\nTest cases of the example are described in the statement.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1359A - Berland PokerIdea: BledDest TutorialTutorial is loading... Solution 1 (BledDest)t = int(input())\n\nfor i in range(t):\n    n, m, k = map(int, input().split())\n    d = n // k\n    a1 = min(m, d)\n    a2 = (m - a1 + k - 2) // (k - 1)\n    print(a1 - a2) Solution 2 (BledDest)t = int(input())\n\nfor i in range(t):\n    n, m, k = map(int, input().split())\n    ans = 0\n    d = n // k\n    for a1 in range(m + 1):\n        for a2 in range(a1 + 1):\n            if(a1 > d):\n                continue\n            if(a1 + a2 > m):\n                continue\n            if(a1 + (k - 1) * a2 < m):\n                continue\n            ans = max(ans, a1 - a2)\n    print(ans)"
    },
    "1358B": {
        "title": "B. Maria Breaks the Self-isolation",
        "description": "Maria is the most active old lady in her house. She was tired of sitting at home. She decided to organize a ceremony against the coronavirus.\nShe has n friends who are also grannies (Maria is not included in this number). The i-th granny is ready to attend the ceremony, provided that at the time of her appearance in the courtyard there will be at least ai other grannies there. Note that grannies can come into the courtyard at the same time. Formally, the granny i agrees to come if the number of other grannies who came earlier or at the same time with her is greater than or equal to ai.\nGrannies gather in the courtyard like that.\nYour task is to find what maximum number of grannies (including herself) Maria can collect in the courtyard for the ceremony. After all, the more people in one place during quarantine, the more effective the ceremony!\nConsider an example: if n=6 and a=[1,5,4,5,1,9], then:\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases in the input. Then test cases follow.\nThe first line of a test case contains a single integer n (1\u2264n\u2264105) \u2014 the number of grannies (Maria is not included in this number).\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5105).\nIt is guaranteed that the sum of the values n over all test cases of the input does not exceed 105.\nFor each test case, print a single integer k (1\u2264k\u2264n+1) \u2014 the maximum possible number of grannies in the courtyard.\nIn the first test case in the example, on the first step Maria can call all the grannies. Then each of them will see five grannies when they come out. Therefore, Maria and five other grannies will be in the yard.\nIn the second test case in the example, no one can be in the yard, so Maria will remain there alone.\nThe third test case in the example is described in the details above.\nIn the fourth test case in the example, on the first step Maria can call grannies with numbers 1, 2 and 3. If on the second step Maria calls 4 or 5 (one of them), then when a granny appears in the yard, she will see only four grannies (but it is forbidden). It means that Maria can't call the 4-th granny or the 5-th granny separately (one of them). If she calls both: 4 and 5, then when they appear, they will see 4+1=5 grannies. Despite the fact that it is enough for the 4-th granny, the 5-th granny is not satisfied. So, Maria cannot call both the 4-th granny and the 5-th granny at the same time. That is, Maria and three grannies from the first step will be in the yard in total.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1358B - Maria Breaks the Self-isolationLet x be the maximum number of grannies that can go out to the yard. Then if Maria Ivanovna calls them all at the same time, then everyone will see x grannies. Since x is the maximum answer, then each granny of them satisfy ai\u2264x (otherwise there's no way for these grannies to gather in the yard), that is, such call is correct. So it is always enough to call once.Note that if you order grannies by ai, Maria Ivanovna will have to call x first grannies from this list. She can take x grannies if ax\u2264x (otherwise, after all x grannies arrived, the last one will leave). To find x we can do a linear search.The overall compexity is O(nlogn) per test.  Solution#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int &el : arr)\n        cin >> el;\n    sort(arr.begin(), arr.end());\n    for (int i = n - 1; i >= 0; i--) {\n        if (arr[i] <= i + 1) {\n            cout << i + 2 << '\\n';\n            return;\n        }\n    }\n    cout << 1 << '\\n';\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n}\n"
    },
    "1355B": {
        "title": "B. Young Explorers",
        "description": "Young wilderness explorers set off to their first expedition led by senior explorer Russell. Explorers went into a forest, set up a camp and decided to split into groups to explore as much interesting locations as possible. Russell was trying to form groups, but ran into some difficulties...\nMost of the young explorers are inexperienced, and sending them alone would be a mistake. Even Russell himself became senior explorer not long ago. Each of young explorers has a positive integer parameter ei\u00a0\u2014 his inexperience. Russell decided that an explorer with inexperience e can only join the group of e or more people.\nNow Russell needs to figure out how many groups he can organize. It's not necessary to include every explorer in one of the groups: some can stay in the camp. Russell is worried about this expedition, so he asked you to help him.\nThe first line contains the number of independent test cases T(1\u2264T\u22642\u22c5105). Next 2T lines contain description of test cases.\nThe first line of description of each test case contains the number of young explorers N (1\u2264N\u22642\u22c5105).\nThe second line contains N integers e1,e2,\u2026,eN (1\u2264ei\u2264N), where ei is the inexperience of the i-th explorer.\nIt's guaranteed that sum of all N doesn't exceed 3\u22c5105.\nPrint T numbers, each number on a separate line.\nIn i-th line print the maximum number of groups Russell can form in i-th test case.\nIn the first example we can organize three groups. There will be only one explorer in each group. It's correct because inexperience of each explorer equals to 1, so it's not less than the size of his group.\nIn the second example we can organize two groups. Explorers with inexperience 1, 2 and 3 will form the first group, and the other two explorers with inexperience equal to 2 will form the second group.\nThis solution is not unique. For example, we can form the first group using the three explorers with inexperience equal to 2, and the second group using only one explorer with inexperience equal to 1. In this case the young explorer with inexperience equal to 3 will not be included in any group.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1355B - Young ExplorersLet's sort all the explorers by non-decreasing inexperience. Suppose we have formed some group, how can we check is this group is valid? Inexperience of all the explorers in the group should be not greater than the group size. But we have sorted all the explorers, so the last explorer from the group has the largest inexperience. Therefore, to check the group for validity it is necessary and sufficient to check that inexperience of the last explorer is not greater than the group size.We can notice that we don't even look at all the explorers except the last one, the only important thing is their number. In fact, we can organize the creation of groups in this way: first choose the explorers that will be the last in their groups, then assign sufficient number of other explorers to corresponding groups. It is not profitable to assign more explorers than needed for this particular last explorer, because we can always leave them at the camp.So how should we choose the last explorers? We want to make more groups, so the groups themselves should me smaller... It is tempting to use the following greedy algorithm: let's greedily pick the leftmost (which means with the smallest necessary group size) explorer such that they have enough explorers to the left of them to create a valid group. The idea is that we spend the smallest number of explorers and leave the most potential last explorers in the future. Let's strictly prove this greedy:The solution is defined by positions of the last explorers in their corresponding groups 1\u2264p1<p2<\u2026<pk\u2264n. Notice that the solution is valid if and only if ep1+ep2+\u2026+epi\u2264pi for all 1\u2264i\u2264k (we always have enough explorers to form first i groups).Let 1\u2264p1<p2<\u2026<pk\u2264n be the greedy solution and 1\u2264q1<q2<\u2026<qm\u2264n be the optimal solution such that it has the largest common prefix with greedy one among all optimal solutions. Let t be the position of first difference in these solutions. t\u2264k since otherwise the greedy algorithm couldn't add one more group but it was possible. pt<qt since otherwise the greedy algorithm would take qt instead of pt. Since the explorers are sorted we have ept\u2264eqt. But then 1\u2264q1<q2<\u2026<qt\u22121<pt<qt+1<\u2026<qm\u2264n is a valid optimal solution and it has strictly larger common prefix with the greedy one which contradicts the choosing of our optimal solution.To implement this solution it is enough to sort the explorers by the non-decreasing inexperience, then go from left to right and maintain the number of unused explorers. As soon as we encounter the possibility to create a new group, we do it.Author's solution: 80407200 "
    },
    "1355A": {
        "title": "A. Sequence with Digits",
        "description": "Let's define the following recurrence: an+1=an+minDigit(an)\u22c5maxDigit(an).\nHere minDigit(x) and maxDigit(x) are the minimal and maximal digits in the decimal representation of x without leading zeroes. For examples refer to notes.\nYour task is calculate aK for given a1 and K.\nThe first line contains one integer t (1\u2264t\u22641000)\u00a0\u2014 the number of independent test cases.\nEach test case consists of a single line containing two integers a1 and K (1\u2264a1\u22641018, 1\u2264K\u22641016) separated by a space.\nFor each test case print one integer aK on a separate line.\na1=487 \n a2=a1+minDigit(a1)\u22c5maxDigit(a1)=487+min(4,8,7)\u22c5max(4,8,7)=487+4\u22c58=519 \n a3=a2+minDigit(a2)\u22c5maxDigit(a2)=519+min(5,1,9)\u22c5max(5,1,9)=519+1\u22c59=528 \n a4=a3+minDigit(a3)\u22c5maxDigit(a3)=528+min(5,2,8)\u22c5max(5,2,8)=528+2\u22c58=544 \n a5=a4+minDigit(a4)\u22c5maxDigit(a4)=544+min(5,4,4)\u22c5max(5,4,4)=544+4\u22c55=564 \n a6=a5+minDigit(a5)\u22c5maxDigit(a5)=564+min(5,6,4)\u22c5max(5,6,4)=564+4\u22c56=588 \n a7=a6+minDigit(a6)\u22c5maxDigit(a6)=588+min(5,8,8)\u22c5max(5,8,8)=588+5\u22c58=628",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1355A - Sequence with DigitsLet's calculate the sequence for fixed $$$a_{1} = 1$$$: $$$1, 2, 6, 42, 50, 50, 50, \\ldots$$$We got lucky and the minimal digit has become 0, after that the element has stopped changing because we always add 0.Actually it is not luck and that will always happen. Note that we add no more than $$$9 \\cdot 9 = 81$$$ every time, so the difference between two consecutive elements of the sequence is bounded by 81. Assume that we will never have minimal digit equal to 0. Then the sequence will go to infinity. Let's take $$$X = 1000(\\lfloor \\frac{a_{1}}{1000} \\rfloor + 1)$$$. All the numbers on segment $$$[X;X+99]$$$ have 0 in hundreds digit, so none of them can be element of our sequence. But our sequence should have numbers greater than $$$X$$$. Let's take the smallest of them, it should be at least $$$X + 100$$$. But then the previous number in the sequence is at least $$$(X + 100) - 81 = X + 19$$$. It is greater than $$$X$$$ but smaller than the minimal of such numbers. Contradiction.In the previous paragraph we have actually shown that we have no numbers greater than $$$X + 100$$$ in our sequence and we will see the number with 0 among first 1001 elements.That means that we can build the sequence till we find the first number with 0 and then it will repeat forever.In reality the maximal index of the first elements with 0 is 54 and minimal $$$a_{1}$$$ for that to happen is 28217.Author's solution: 80407149 "
    },
    "1354B": {
        "title": "B. Ternary String",
        "description": "You are given a string s such that each its character is either 1, 2, or 3. You have to choose the shortest contiguous substring of s such that it contains each of these three characters at least once.\nA contiguous substring of string s is a string that can be obtained from s by removing some (possibly zero) characters from the beginning of s and some (possibly zero) characters from the end of s.\nThe first line contains one integer t (1\u2264t\u226420000) \u2014 the number of test cases.\nEach test case consists of one line containing the string s (1\u2264|s|\u2264200000). It is guaranteed that each character of s is either 1, 2, or 3.\nThe sum of lengths of all strings in all test cases does not exceed 200000.\nFor each test case, print one integer \u2014 the length of the shortest contiguous substring of s containing all three types of characters at least once. If there is no such substring, print 0 instead.\nConsider the example test:\nIn the first test case, the substring 123 can be used.\nIn the second test case, the substring 213 can be used.\nIn the third test case, the substring 1223 can be used.\nIn the fourth test case, the substring 3221 can be used.\nIn the fifth test case, there is no character 3 in s.\nIn the sixth test case, there is no character 1 in s.\nIn the seventh test case, the substring 3112 can be used.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solutions": "1354B - Ternary StringThere are multiple solutions involving advanced methods such as binary search or two pointers, but I'll try to describe a simpler one.The main idea of my solution is that the answer should look like abb...bbbbbc: one character of type a, a block of characters of type b, and one character of type c. If we find all blocks of consecutive equal characters in our string, each candidate for the answer can be obtained by expanding a block to the left and to the right by exactly one character. So the total length of all candidates is O(n), and we can check them all.Why does the answer look like abb...bbbbbc? If the first character of the substring appears somewhere else in it, it can be deleted. The same applies for the last character. So, the first and the last characters should be different, and should not appear anywhere else within the string. Since there are only three types of characters, the answer always looks like abb...bbbbbc. Solution (BledDest)#include<bits/stdc++.h>\n\nusing namespace std;\n\nchar buf[200043];\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\tfor(int i = 0; i < t; i++)\n\t{\n\t\tscanf(\"%s\", buf);\n\t\tstring s = buf;\n\t\tint ans = int(1e9);\n\t\tint n = s.size();\n\t\tvector<pair<char, int> > c;\n\t\tfor(auto x : s)\n\t\t{\n\t\t\tif(c.empty() || c.back().first != x)\n\t\t\t\tc.push_back(make_pair(x, 1));\n\t\t\telse\n\t\t\t\tc.back().second++;\n\t\t}\n\t\tint m = c.size();\n\t\tfor(int i = 1; i < m - 1; i++)\n\t\t\tif(c[i - 1].first != c[i + 1].first)\n\t\t\t\tans = min(ans, c[i].second + 2);\n\t\tif(ans > n)\n\t\t\tans = 0;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
    },
    "1353C": {
        "title": "C. Board Moves",
        "description": "You are given a board of size n\u00d7n, where n is odd (not divisible by 2). Initially, each cell of the board contains one figure.\nIn one move, you can select exactly one figure presented in some cell and move it to one of the cells sharing a side or a corner with the current cell, i.e. from the cell (i,j) you can move the figure to cells: \nOf course, you can not move figures to cells out of the board. It is allowed that after a move there will be several figures in one cell.\nYour task is to find the minimum number of moves needed to get all the figures into one cell (i.e. n2\u22121 cells should contain 0 figures and one cell should contain n2 figures).\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264200) \u2014 the number of test cases. Then t test cases follow.\nThe only line of the test case contains one integer n (1\u2264n<5\u22c5105) \u2014 the size of the board. It is guaranteed that n is odd (not divisible by 2).\nIt is guaranteed that the sum of n over all test cases does not exceed 5\u22c5105 (\u2211n\u22645\u22c5105).\nFor each test case print the answer \u2014 the minimum number of moves needed to get all the figures into one cell.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1353C - Board MovesIt is intuitive (and provable) that the best strategy is to move each figure to the center cell (n+12,n+12). Now, with some paperwork or easy observations, we can notice that we have exactly 8 cells with the shortest distance 1, 16 cells with the shortest distance 2, 24 cells with the shortest distance 3 and so on. So we have 8i cells with the shortest distance i. So the answer is 1\u22c58+2\u22c516+3\u22c524+\u22ef+(n\u221212)2\u22c58. It can be rewritten as 8(1+4+9+\u22ef+(n\u221212)2) so we can just calculate the sum of squares of all integers from 1 to n\u221212 using loop (or formula n(n+1)(2n+1)6) and multiply the answer by 8.Time complexity: O(n) or O(1). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tlong long ans = 0;\n\t\tfor (int i = 1; i <= n / 2; ++i) {\n\t\t\tans += i * 1ll * i;\n\t\t}\n\t\tcout << ans * 8 << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1352C": {
        "title": "C. K-th Not Divisible by n",
        "description": "You are given two positive integers n and k. Print the k-th positive integer that is not divisible by n.\nFor example, if n=3, and k=7, then all numbers that are not divisible by 3 are: 1,2,4,5,7,8,10,11,13\u2026. The 7-th number among them is 10.\nThe first line contains an integer t (1\u2264t\u22641000) \u2014 the number of test cases in the input. Next, t test cases are given, one per line.\nEach test case is two positive integers n (2\u2264n\u2264109) and k (1\u2264k\u2264109).\nFor each test case print the k-th positive integer that is not divisible by n.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1200"
        ],
        "solutions": "1352C - K-th Not Divisible by nSuppose the answer is just k-th positive integer which we should \"shift right\" by some number. Each multiplier of n shifts our answer by 1. The number of such multipliers is need=\u230ak\u22121n\u22121\u230b, where \u230axy\u230b is x divided by y rounded down. So the final answer is k+need (k-th positive integer with the required number of skipped integers multipliers of n).You can also use a binary search to solve this problem :) Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tint need = (k - 1) / (n - 1);\n\t\tcout << k + need << endl;\n\t}\n}"
    },
    "1352B": {
        "title": "B. Same Parity Summands",
        "description": "You are given two positive integers n (1\u2264n\u2264109) and k (1\u2264k\u2264100). Represent the number n as the sum of k positive integers of the same parity (have the same remainder when divided by 2).\nIn other words, find a1,a2,\u2026,ak such that all ai>0, n=a1+a2+\u2026+ak and either all ai are even or all ai are odd at the same time.\nIf such a representation does not exist, then report it.\nThe first line contains an integer t (1\u2264t\u22641000) \u2014 the number of test cases in the input. Next, t test cases are given, one per line.\nEach test case is two positive integers n (1\u2264n\u2264109) and k (1\u2264k\u2264100).\nFor each test case print:\nThe letters in the words YES and NO can be printed in any case.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1352B - Same Parity Summands TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tint n1 = n - (k - 1);\n\t\tif (n1 > 0 && n1 % 2 == 1) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int i = 0; i < k - 1; ++i) cout << \"1 \";\n\t\t\tcout << n1 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint n2 = n - 2 * (k - 1);\n\t\tif (n2 > 0 && n2 % 2 == 0) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int i = 0; i < k - 1; ++i) cout << \"2 \";\n\t\t\tcout << n2 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"NO\" << endl;\n\t}\n}"
    },
    "1346A": {
        "title": "A. Color Revolution",
        "description": "Hmm, how long has it been since the last color revolution? 5 years?! It's totally the time to make a new one!\nSo the general idea is the following. Division 1 should have n1 participants. Division 2 should have n2 and be exactly k times bigger than division 1 (n2=k\u22c5n1). Division 3 should have n3=k\u22c5n2 participants. Finally, division 4 should have n4=k\u22c5n3 participants.\nThere are n participants on Codeforces in total. So n1+n2+n3+n4 should be exactly equal to n.\nYou know the values of n and k. You also know that n and k are chosen in such a way that there exist values n1,n2,n3 and n4 such that all the conditions are satisfied.\nWhat will be the number of participants in each division (n1,n2,n3 and n4) after the revolution?\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of testcases.\nEach of the next t lines contains two integers n and k (4\u2264n\u2264109; 1\u2264k\u2264500) \u2014 the total number of participants on Codeforces and the size multiplier for the corresponding testcase. In each testcase, n and k are chosen in such a way that the answer exists.\nFor each testcase print four integers n1,n2,n3 and n4 such that n2=k\u22c5n1, n3=k\u22c5n2, n4=k\u22c5n3 and n1+n2+n3+n4=n.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "math",
            "*1000"
        ],
        "solutions": "1346A - Color RevolutionNotice that all division sizes are determined by the size of the first one. So the sizes are n1,n1\u22c5k,n1\u22c5k2,n1\u22c5k3. Their sum is n1+n1\u22c5k+n1\u22c5k2+n1\u22c5k3. Let's rewrite it as n1\u22c5(1+k+k2+k3). Now it's easy to see that n1 can be obtained by dividing n by (1+k+k2+k3).Alternatively, you can binary search for n1 because the sum of sizes only increases with the increase of n1.Overall complexity: O(1) or O(logmaxn) per testcase. Solution (elizarov)fun main() {\n    repeat(readLine()!!.toInt()) {\n        val (n, k) = readLine()!!.split(\" \").map { it.toInt() }\n        val n1 = n / (1 + k + k * k + k * k * k)\n        val n2 = n1 * k\n        val n3 = n2 * k\n        val n4 = n3 * k\n        println(\"$n1 $n2 $n3 $n4\")\n    }\n}"
    },
    "1345B": {
        "title": "B. Card Constructions",
        "description": "A card pyramid of height 1 is constructed by resting two cards against each other. For h>1, a card pyramid of height h is constructed by placing a card pyramid of height h\u22121 onto a base. A base consists of h pyramids of height 1, and h\u22121 cards on top. For example, card pyramids of heights 1, 2, and 3 look as follows:\nYou start with n cards and build the tallest pyramid that you can. If there are some cards remaining, you build the tallest pyramid possible with the remaining cards. You repeat this process until it is impossible to build another pyramid. In the end, how many pyramids will you have constructed?\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Next t lines contain descriptions of test cases.\nEach test case contains a single integer n (1\u2264n\u2264109)\u00a0\u2014 the number of cards.\nIt is guaranteed that the sum of n over all test cases does not exceed 109.\nFor each test case output a single integer\u00a0\u2014 the number of pyramids you will have constructed in the end.\nIn the first test, you construct a pyramid of height 1 with 2 cards. There is 1 card remaining, which is not enough to build a pyramid.\nIn the second test, you build two pyramids, each of height 2, with no cards remaining.\nIn the third test, you build one pyramid of height 3, with no cards remaining.\nIn the fourth test, you build one pyramid of height 3 with 9 cards remaining. Then you build a pyramid of height 2 with 2 cards remaining. Then you build a final pyramid of height 1 with no cards remaining.\nIn the fifth test, one card is not enough to build any pyramids.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dp",
            "math",
            "*1100"
        ],
        "solutions": "1345B - Card ConstructionsLet's count the number of cards in a pyramid of height h. There are 2(1+2+3+\u22ef+h) cards standing up, and there are 0+1+2+\u22ef+(h\u22121) horizontal cards. So, there are 2h(h+1)2+(h\u22121)h2=32h2+12h cards total. Using this formula, we can quickly find the largest height h that uses at most n cards.The quadratic formula or binary search can be used here, but are unnecessary. Simply iterating through all h values works in O(n\u2212\u2212\u221a) time per test.It's enough to see that this takes O(tN\u2212\u2212\u221a) time overall, where N is the sum of n across all test cases. But interestingly, we can argue for a tighter bound of O(tN\u2212\u2212\u2212\u221a) due to the Cauchy-Schwarz Inequality:\u2211i=1t(1\u22c5ni\u2212\u2212\u221a)\u2264(\u2211i=1t12)(\u2211i=1t(n\u2212\u2212\u221ai)2)\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\ue001\u23b7\ue000\ue000=tN\u2212\u2212\u2212\u221a"
    },
    "1343C": {
        "title": "C. Alternating Subsequence",
        "description": "Recall that the sequence b is a a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements. For example, if a=[1,2,1,3,1,2,1], then possible subsequences are: [1,1,1,1], [3] and [1,2,1,3,1,2,1], but not [3,2,3] and [1,1,1,1,2].\nYou are given a sequence a consisting of n positive and negative elements (there is no zeros in the sequence).\nYour task is to choose maximum by size (length) alternating subsequence of the given sequence (i.e. the sign of each next element is the opposite from the sign of the current element, like positive-negative-positive and so on or negative-positive-negative and so on). Among all such subsequences, you have to choose one which has the maximum sum of elements.\nIn other words, if the maximum length of alternating subsequence is k then your task is to find the maximum sum of elements of some alternating subsequence of length k.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in a. The second line of the test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109,ai\u22600), where ai is the i-th element of a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer \u2014 the maximum sum of the maximum by size (length) alternating subsequence of a.\nIn the first test case of the example, one of the possible answers is [1,2,3_,\u22121_,\u22122].\nIn the second test case of the example, one of the possible answers is [\u22121,\u22122,\u22121_,\u22123].\nIn the third test case of the example, one of the possible answers is [\u22122_,8,3,8_,\u22124_,\u221215,5_,\u22122_,\u22123,1_].\nIn the fourth test case of the example, one of the possible answers is [1_,\u22121000000000_,1_,\u22121000000000_,1_,\u22121000000000_].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "two pointers",
            "*1200"
        ],
        "solutions": "1343C - Alternating SubsequenceFirstly, let's extract maximum by inclusion segments of the array that consists of the numbers with the same sign. For example, if the array is [1,1,2,\u22121,\u22125,2,1,\u22123] then these segments are [1,1,2], [\u22121,\u22125], [2,1] and [\u22123]. We can do it with any \"two pointers\"-like algorithm. The number of these segments is the maximum possible length of the alternating subsequence because we can take only one element from each block. And as we want to maximize the sum, we need to take the maximum element from each block.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tauto sgn = [&](int x) {\n\t\tif (x > 0) return 1;\n\t\telse return -1;\n\t};\n\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tfor (auto &it : a) cin >> it;\n\t\tlong long sum = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint cur = a[i];\n\t\t\tint j = i;\n\t\t\twhile (j < n && sgn(a[i]) == sgn(a[j])) {\n\t\t\t\tcur = max(cur, a[j]);\n\t\t\t\t++j;\n\t\t\t}\n\t\t\tsum += cur;\n\t\t\ti = j - 1;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1342B": {
        "title": "B. Binary Period",
        "description": "Let's say string s has period k if si=si+k for all i from 1 to |s|\u2212k (|s| means length of string s) and k is the minimum positive integer with this property.\nSome examples of a period: for s=\"0101\" the period is k=2, for s=\"0000\" the period is k=1, for s=\"010\" the period is k=2, for s=\"0011\" the period is k=4.\nYou are given string t consisting only of 0's and 1's and you need to find such string s that:\nLet us recall that t is a subsequence of s if t can be derived from s by deleting zero or more elements (any) without changing the order of the remaining elements. For example, t=\"011\" is a subsequence of s=\"10101\".\nThe first line contains single integer T (1\u2264T\u2264100)\u00a0\u2014 the number of test cases.\nNext T lines contain test cases \u2014 one per line. Each line contains string t (1\u2264|t|\u2264100) consisting only of 0's and 1's.\nPrint one string for each test case \u2014 string s you needed to find. If there are multiple solutions print any one of them.\nIn the first and second test cases, s=t since it's already one of the optimal solutions. Answers have periods equal to 1 and 2, respectively.\nIn the third test case, there are shorter optimal solutions, but it's okay since we don't need to minimize the string s. String s has period equal to 1.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "strings",
            "*1100"
        ],
        "solutions": "1342B - Binary PeriodLet's see how strings with periods k=1 and k=2 look. There are two types of strings with a period equal to 1: 0000... and 1111.... And there are two types of strings with a period equal to 2: 01010... and 10101....It's easy to see if t consists only of 0's (1's) then the string itself is an answer since it has period equal to 1. Otherwise, it's also quite obvious that any string t is a subsequence of 0101...01 (1010...10) of 2|t| length. Solution (adedalic)fun main() {\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val t = readLine()!!\n\n        val s = t.toCharArray().distinct().joinToString(\"\").repeat(t.length)\n        println(s)\n    }\n}"
    },
    "1342A": {
        "title": "A. Road To Zero",
        "description": "You are given two integers x and y. You can perform two types of operations: \n \nYour goal is to make both given integers equal zero simultaneously, i.e. x=y=0. There are no other requirements. In particular, it is possible to move from x=1, y=0 to x=y=0.\nCalculate the minimum amount of dollars you have to spend on it.\nThe first line contains one integer t (1\u2264t\u2264100)\u00a0\u2014 the number of testcases.\nThe first line of each test case contains two integers x and y (0\u2264x,y\u2264109).\nThe second line of each test case contains two integers a and b (1\u2264a,b\u2264109).\nFor each test case print one integer\u00a0\u2014 the minimum amount of dollars you have to spend.\nIn the first test case you can perform the following sequence of operations: first, second, first. This way you spend 391+555+391=1337 dollars.\nIn the second test case both integers are equal to zero initially, so you dont' have to spend money.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1342A - Road To ZeroLet's presume that $$$x \\ge y$$$. Then there are two cases in the problem:   If $$$a + a \\le b$$$ then we have to $$$x + y$$$ times perform the first operation. So the answer is $$$(x + y) \\cdot a$$$;  If $$$a + a > b$$$ then we have to $$$y$$$ times perform the second operation and pass the remaining distance by performing the first operation. So the answer is $$$y \\cdot b + (x - y) \\cdot a$$$.  Solution (Roms)for _ in range(int(input())):\n    x, y = map(int, input().split())\n    a, b = map(int, input().split())\n    b = min(b, a + a)\n    if x < y:\n        x, y= y, x\n    print(y * b + (x - y) * a)"
    },
    "1339B": {
        "title": "B. Sorted Adjacent Differences",
        "description": "You have array of n numbers a1,a2,\u2026,an. \nRearrange these numbers to satisfy |a1\u2212a2|\u2264|a2\u2212a3|\u2264\u2026\u2264|an\u22121\u2212an|, where |x| denotes absolute value of x. It's always possible to find such rearrangement.\nNote that all numbers in a are not necessarily different. In other words, some numbers of a may be same.\nYou have to answer independent t test cases.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains single integer n (3\u2264n\u2264105)\u00a0\u2014 the length of array a. It is guaranteed that the sum of values of n over all test cases in the input does not exceed 105.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109).\nFor each test case, print the rearranged version of array a which satisfies given condition. If there are multiple valid rearrangements, print any of them.\nIn the first test case, after given rearrangement, |a1\u2212a2|=0\u2264|a2\u2212a3|=1\u2264|a3\u2212a4|=2\u2264|a4\u2212a5|=2\u2264|a5\u2212a6|=10. There are other possible answers like \"5 4 5 6 -2 8\".\nIn the second test case, after given rearrangement, |a1\u2212a2|=1\u2264|a2\u2212a3|=2\u2264|a3\u2212a4|=4. There are other possible answers like \"2 4 8 1\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1200"
        ],
        "solutions": "1339B - Sorted Adjacent DifferencesSort the list, and make an oscillation centered on middle element like picture below.  In this way, you will always achieve to make |ai\u2212ai+1|\u2264|ai+1\u2212ai+2| for all i. Time complexity is O(nlogn).Behind story of B:  I tried to block various heuristics. There were some critical heuristics which could pass so many cases. Fortunately I blocked them during testing period, so I hope there won't be much FST this time.  "
    },
    "1335C": {
        "title": "C. Two Teams Composing",
        "description": "You have n students under your control and you have to compose exactly two teams consisting of some subset of your students. Each student had his own skill, the i-th student skill is denoted by an integer ai (different students can have the same skills).\nSo, about the teams. Firstly, these two teams should have the same size. Two more constraints:\nNote that it is permissible that some student of the first team has the same skill as a student of the second team.\nConsider some examples (skills are given):\nYour task is to find the maximum possible size x for which it is possible to compose a valid pair of teams, where each team size is x (skills in the first team needed to be unique, skills in the second team should be the same between them). A student cannot be part of more than one team.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of students. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n), where ai is the skill of the i-th student. Different students can have the same skills.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer \u2014 the maximum possible size x for which it is possible to compose a valid pair of teams, where each team size is x.\nIn the first test case of the example, it is possible to construct two teams of size 3: the first team is [1,2,4] and the second team is [4,4,4]. Note, that there are some other ways to construct two valid teams of size 3.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "1335C - Two Teams ComposingLet the number of students with the skill i is cnti and the number of different skills is diff. Then the size of the first team can not exceed diff and the size of the second team can not exceed maxcnt=max(cnt1,cnt2,\u2026,cntn). So the answer is not greater than the minimum of these two values. Moreover, let's take a look at the skill with a maximum value of cnt. Then there are two cases: all students with this skill go to the second team then the sizes of teams are at most diff\u22121 and maxcnt correspondingly. Otherwise, at least one student with this skill goes to the first team and the sizes are at most diff and maxcnt\u22121 correspondingly. So the answer is max(min(diff\u22121,maxcnt),min(diff,maxcnt\u22121)).Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> cnt(n + 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t++cnt[x];\n\t\t}\n\t\tint mx = *max_element(cnt.begin(), cnt.end());\n\t\tint diff = n + 1 - count(cnt.begin(), cnt.end(), 0);\n\t\tcout << max(min(mx - 1, diff), min(mx, diff - 1)) << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1334B": {
        "title": "B. Middle Class",
        "description": "Many years ago Berland was a small country where only n people lived. Each person had some savings: the i-th one had ai burles.\nThe government considered a person as wealthy if he had at least x burles. To increase the number of wealthy people Berland decided to carry out several reforms. Each reform looked like that: \nFor example, consider the savings as list [5,1,2,1]: if the government chose the 1-st and the 3-rd persons then it, at first, will take all 5+2=7 burles and after that will return 3.5 burles to the chosen people. As a result, the savings will become [3.5,1,3.5,1].\nA lot of data was lost from that time, so we don't know how many reforms were implemented and to whom. All we can do is ask you to calculate the maximum possible number of wealthy people after several (maybe zero) reforms.\nThe first line contains single integer T (1\u2264T\u22641000) \u2014 the number of test cases.\nNext 2T lines contain the test cases \u2014 two lines per test case. The first line contains two integers n and x (1\u2264n\u2264105, 1\u2264x\u2264109) \u2014 the number of people and the minimum amount of money to be considered as wealthy.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 the initial savings of each person.\nIt's guaranteed that the total sum of n doesn't exceed 105.\nPrint T integers \u2014 one per test case. For each test case print the maximum possible number of wealthy people after several (maybe zero) reforms.\nThe first test case is described in the statement.\nIn the second test case, the government, for example, could carry out two reforms: [11_,9_,11,9]\u2192[10,10,11_,9_]\u2192[10,10,10,10].\nIn the third test case, the government couldn't make even one person wealthy.\nIn the fourth test case, the government could choose all people to carry out a reform: [9_,4_,9_]\u2192[713,713,713].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solutions": "1334B - Middle ClassIn fact, to carry out only one reform is always enough. And it's easy to prove if you make only one reform it's always optimal to take the maximum such k that the average of k maximums in the array a is at least x (i.e. sum greater or equal to kx). So the solution is next: sort array a and find the suffix with maximum length k such that the sum on the suffix is at least kx.===To prove the fact about one reform we can prove another fact: after each reform, the sum of k maximums doesn't increase for each k. We'll prove it in two steps.The first step. Let's look at some reform and form an array b from the chosen elements in a in descending order. After the reform we'll get array b\u2032 where all b\u2032[i]=1|b|\u2211|b|i=1b[i]. Let's just skip the proof and say it's obvious enough that \u2211yi=1b[i]\u2265\u2211yi=1b\u2032[i] for any y.The second step. Let fix k and divide array a on two parts: k maximums as a1 and other n\u2212k elements as a2. And let's make the same division of a\u2032 (the array after performing the reform) on a\u20321 and a\u20322. So, we need to prove that sum(a\u20321)\u2264sum(a1). Suppose m elements were chosen in the reform: cnt of them were in a1 and cnt\u2032 now in a\u20321. If cnt\u2265cnt\u2032 then we can think like maximum cnt\u2032 elements from cnt elements in a were replaced by the average and other cnt\u2212cnt\u2032 were replaced by elements from a2. Since \u2211cnt\u2032i=1b[i]\u2265\u2211cnt\u2032i=1b\u2032[i] and any element from a1 is greater or equal to any element from a2 then we proved that sum(a\u20321)\u2264sum(a1) when cnt\u2265cnt\u2032.If cnt<cnt\u2032 then let's look at a2 and a\u20322. The a2 has m\u2212cnt chosen elements and a\u20322 has m\u2212cnt\u2032, so m\u2212cnt>m\u2212cnt\u2032 and we can prove that sum(a\u20322)\u2265sum(a2) practically in the same way as before. Obviously, if sum(a\u2032)=sum(a) and sum(a\u20322)\u2265sum(a2) then sum(a\u20321)\u2264sum(a1). Q.E.D.The last step is easy, let's prove that the only reform is enough. The answer after several reforms is clearly equal to k maximums which are at least x. But it means that the sum of k maximums is at least kx, therefore the sum of k maximums in the initial array is at least kx. So we can make them all at least k by only one reform.  Solution (adedalic)fun main() {\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val (n, x) = readLine()!!.split(' ').map { it.toInt() }\n        val a = readLine()!!.split(' ').map { it.toInt() }.sortedDescending()\n\n        var cnt = 0\n        var sum = 0L\n        while (cnt < n && sum + a[cnt] >= (cnt + 1) * x.toLong()) {\n            sum += a[cnt]\n            cnt++\n        }\n        println(cnt)\n    }\n}"
    },
    "1334A": {
        "title": "A. Level Statistics",
        "description": "Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online. Now players from all over the world can try his level.\nAll levels in this game have two stats to them: the number of plays and the number of clears. So when a player attempts the level, the number of plays increases by 1. If he manages to finish the level successfully then the number of clears increases by 1 as well. Note that both of the statistics update at the same time (so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears).\nPolycarp is very excited about his level, so he keeps peeking at the stats to know how hard his level turns out to be.\nSo he peeked at the stats n times and wrote down n pairs of integers \u2014 (p1,c1),(p2,c2),\u2026,(pn,cn), where pi is the number of plays at the i-th moment of time and ci is the number of clears at the same moment of time. The stats are given in chronological order (i.e. the order of given pairs is exactly the same as Polycarp has written down).\nBetween two consecutive moments of time Polycarp peeked at the stats many players (but possibly zero) could attempt the level.\nFinally, Polycarp wonders if he hasn't messed up any records and all the pairs are correct. If there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then he considers his records correct.\nHelp him to check the correctness of his records.\nFor your convenience you have to answer multiple independent test cases.\nThe first line contains a single integer T (1\u2264T\u2264500) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100) \u2014 the number of moments of time Polycarp peeked at the stats.\nEach of the next n lines contains two integers pi and ci (0\u2264pi,ci\u22641000) \u2014 the number of plays and the number of clears of the level at the i-th moment of time.\nNote that the stats are given in chronological order.\nFor each test case print a single line.\nIf there could exist such a sequence of plays (and clears, respectively) that the stats were exactly as Polycarp has written down, then print \"YES\".\nOtherwise, print \"NO\".\nYou can print each letter in any case (upper or lower).\nIn the first test case at the third moment of time the number of clears increased but the number of plays did not, that couldn't have happened.\nThe second test case is a nice example of a Super Expert level.\nIn the third test case the number of plays decreased, which is impossible.\nThe fourth test case is probably an auto level with a single jump over the spike.\nIn the fifth test case the number of clears decreased, which is also impossible.\nNobody wanted to play the sixth test case; Polycarp's mom attempted it to make him feel better, however, she couldn't clear it.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1334A - Level StatisticsLet's use the fact that initially the level has $$$0$$$ plays and $$$0$$$ clears. Call the differences before the previous stats and the current ones $$$\\Delta p$$$ and $$$\\Delta c$$$.The stats are given in chronological order, so neither the number of plays, nor the number of clears should decrease (i.e. $$$\\Delta p \\ge 0$$$ and $$$\\Delta c \\ge 0$$$).Finally, $$$\\Delta p$$$ should be greater or equal to $$$\\Delta c$$$. It's easy to show that if $$$\\Delta c$$$ players pass the level successfully and $$$\\Delta p - \\Delta c$$$ players just try the level then such deltas are achieved.So in implementation it's enough to check these three conditions between the consecutive pieces of data (including the initial ($$$0, 0$$$)).Overall complexity: $$$O(n)$$$. Solution (pikmike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\twhile (tc--){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tint p = 0, c = 0;\n\t\tbool fl = true;\n\t\tforn(i, n){\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tif (x < p || y < c || y - c > x - p)\n\t\t\t\tfl = false;\n\t\t\tp = x, c = y;\n\t\t}\n\t\tputs(fl ? \"YES\" : \"NO\");\n\t}\n\treturn 0;\n}"
    },
    "1333B": {
        "title": "B. Kind Anton",
        "description": "Once again, Boris needs the help of Anton in creating a task. This time Anton needs to solve the following problem:\nThere are two arrays of integers a and b of length n. It turned out that array a contains only elements from the set {\u22121,0,1}.\nAnton can perform the following sequence of operations any number of times:\nFor example, if you are given array [1,\u22121,0], you can transform it only to [1,\u22121,\u22121], [1,0,0] and [1,\u22121,1] by one operation.\nAnton wants to predict if it is possible to apply some number (zero or more) of these operations to the array a so that it becomes equal to array b. Can you help him?\nEach test contains multiple test cases. \nThe first line contains the number of test cases t (1\u2264t\u226410000). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u00a0\u2014 the length of arrays.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u22121\u2264ai\u22641) \u00a0\u2014 elements of array a. There can be duplicates among elements.\nThe third line of each test case contains n integers b1,b2,\u2026,bn (\u2212109\u2264bi\u2264109) \u00a0\u2014 elements of array b. There can be duplicates among elements.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 105.\nFor each test case, output one line containing \"YES\" if it's possible to make arrays a and b equal by performing the described operations, or \"NO\" if it's impossible.\nYou can print each letter in any case (upper or lower).\nIn the first test-case we can choose (i,j)=(2,3) twice and after that choose (i,j)=(1,2) twice too. These operations will transform [1,\u22121,0]\u2192[1,\u22121,\u22122]\u2192[1,1,\u22122]\nIn the second test case we can't make equal numbers on the second position.\nIn the third test case we can choose (i,j)=(1,2) 41 times. The same about the fourth test case.\nIn the last lest case, it is impossible to make array a equal to the array b.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1333B - Kind AntonFirst of all, note that we can add an element with index i to an element with index j iff i<j. This means that the element an cannot be added to any other element because there is no index j>n in the array. This is why we can first equalize the elements an and bn. If an=bn, they are already equal. If an<bn, then we need to have element equal to 1 along the elements a with indexes {1,...,n\u22121}. For an>bn, we need to have \u22121 along these elements. After the elements with index n become equal, we can go to the element with index n\u22121 and do the same. Then indexes n\u22122, n\u22123, ..., 1. You can implement this idea yourself!Final time complexity: O(n) Solution C++#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n    }\n    vector<int> good(2, 0);\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > b[i] && !good[0]) {\n            cout << \"NO\\n\";\n            return;\n        } else if (a[i] < b[i] && !good[1]) {\n            cout << \"NO\\n\";\n            return;\n        }\n        if (a[i] == -1) good[0] = 1;\n        if (a[i] == 1) good[1] = 1;\n    }\n    cout << \"YES\\n\";\n}\n\nint main() {\n    int t; cin >> t;\n    while(t--) {\n        solve();\n    }\n} "
    },
    "1333A": {
        "title": "A. Little Artem",
        "description": "Young boy Artem tries to paint a picture, and he asks his mother Medina to help him. Medina is very busy, that's why she asked for your help.\nArtem wants to paint an n\u00d7m board. Each cell of the board should be colored in white or black. \nLets B be the number of black cells that have at least one white neighbor adjacent by the side. Let W be the number of white cells that have at least one black neighbor adjacent by the side. A coloring is called good if B=W+1. \nThe first coloring shown below has B=5 and W=4 (all cells have at least one neighbor with the opposite color). However, the second coloring is not good as it has B=4, W=4 (only the bottom right cell doesn't have a neighbor with the opposite color).\nPlease, help Medina to find any good coloring. It's guaranteed that under given constraints the solution always exists. If there are several solutions, output any of them.\nEach test contains multiple test cases. \nThe first line contains the number of test cases t (1\u2264t\u226420). Each of the next t lines contains two integers n,m (2\u2264n,m\u2264100)\u00a0\u2014 the number of rows and the number of columns in the grid.\nFor each test case print n lines, each of length m, where i-th line is the i-th row of your colored matrix (cell labeled with 'B' means that the cell is black, and 'W' means white). Do not use quotes.\nIt's guaranteed that under given constraints the solution always exists.\nIn the first testcase, B=3, W=2.\nIn the second testcase, B=5, W=4. You can see the coloring in the statement.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1332A": {
        "title": "A. Exercising Walk",
        "description": "Alice has a cute cat. To keep her cat fit, Alice wants to design an exercising walk for her cat! \nInitially, Alice's cat is located in a cell (x,y) of an infinite grid. According to Alice's theory, cat needs to move: \nNote that the moves can be performed in an arbitrary order. For example, if the cat has to move 1 step left, 3 steps right and 2 steps down, then the walk right, down, left, right, right, down is valid.\nAlice, however, is worrying that her cat might get lost if it moves far away from her. So she hopes that her cat is always in the area [x1,x2]\u00d7[y1,y2], i.e. for every cat's position (u,v) of a walk x1\u2264u\u2264x2 and y1\u2264v\u2264y2 holds.\nAlso, note that the cat can visit the same cell multiple times.\nCan you help Alice find out if there exists a walk satisfying her wishes?\nFormally, the walk should contain exactly a+b+c+d unit moves (a to the left, b to the right, c to the down, d to the up). Alice can do the moves in any order. Her current position (u,v) should always satisfy the constraints: x1\u2264u\u2264x2, y1\u2264v\u2264y2. The staring point is (x,y).\nYou are required to answer t test cases independently.\nThe first line contains a single integer t (1\u2264t\u2264103) \u2014 the number of testcases. \nThe first line of each test case contains four integers a, b, c, d (0\u2264a,b,c,d\u2264108, a+b+c+d\u22651).\nThe second line of the test case contains six integers x, y, x1, y1, x2, y2 (\u2212108\u2264x1\u2264x\u2264x2\u2264108, \u2212108\u2264y1\u2264y\u2264y2\u2264108).\nFor each test case, output \"YES\" in a separate line, if there exists a walk satisfying her wishes. Otherwise, output \"NO\" in a separate line. \nYou can print each letter in any case (upper or lower).\nIn the first test case, one valid exercising walk is (0,0)\u2192(\u22121,0)\u2192(\u22122,0)\u2192(\u22122,1)\u2192(\u22122,2)\u2192(\u22121,2)\u2192(0,2)\u2192(0,1)\u2192(0,0)\u2192(\u22121,0)",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1332A - Exercising WalkThe key observation is x-axis and y-axis is independent in this task as the area is a rectangle. Therefore, we should only consider 1D case (x-axis, for example). The optimal path to choose alternates between right and left moves until only one type of move is possible. And sometimes there is no place to make even one move, which has to handled separately. So the verdict is \"Yes\" if and only if x1\u2264x\u2212a+b\u2264x2 and (x1<x2 or a+b=0).  Solution (python by pikmike)t = int(input())\nfor _ in range(t):\n\ta, b, c, d = map(int, input().split())\n\tx, y, x1, y1, x2, y2 = map(int, input().split())\n\tx += b - a\n\ty += d - c\n\tif a + b > 0 and x1 == x2:\n\t\tprint(\"No\")\n\telif c + d > 0 and y1 == y2:\n\t\tprint(\"No\")\n\telif x1 <= x <= x2 and y1 <= y <= y2:\n\t\tprint(\"Yes\")\n\telse:\n\t\tprint(\"No\") Solution (C++)#include<bits/stdc++.h>\nusing namespace std;\n\nint a,b,c,d,x,y,x1,y1,x2,y2,xx,yy;\n\nint main(){\n    int t;\n    cin>>t;\n    while (t--){\n        cin>>a>>b>>c>>d;\n        cin>>x>>y>>x1>>y1>>x2>>y2;\n        xx=x,yy=y;\n        x+=-a+b, y+=-c+d;\n        if (x>=x1&&x<=x2&&y>=y1&&y<=y2&&(x2>x1||a+b==0)&&(y2>y1||c+d==0)){\n            cout<<\"Yes\\n\";\n        }\n        else{\n            cout<<\"No\\n\";\n        }\n    }\n    return 0;\n}"
    },
    "1328C": {
        "title": "C. Ternary XOR",
        "description": "A number is ternary if it contains only digits 0, 1 and 2. For example, the following numbers are ternary: 1022, 11, 21, 2002.\nYou are given a long ternary number x. The first (leftmost) digit of x is guaranteed to be 2, the other digits of x can be 0, 1 or 2.\nLet's define the ternary XOR operation \u2299 of two ternary numbers a and b (both of length n) as a number c=a\u2299b of length n, where ci=(ai+bi)%3 (where % is modulo operation). In other words, add the corresponding digits and take the remainders of the sums when divided by 3. For example, 10222\u229911021=21210.\nYour task is to find such ternary numbers a and b both of length n and both without leading zeros that a\u2299b=x and max(a,b) is the minimum possible.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then t test cases follow. The first line of the test case contains one integer n (1\u2264n\u22645\u22c5104) \u2014 the length of x. The second line of the test case contains ternary number x consisting of n digits 0,1 or 2. It is guaranteed that the first digit of x is 2. It is guaranteed that the sum of n over all test cases does not exceed 5\u22c5104 (\u2211n\u22645\u22c5104).\nFor each test case, print the answer \u2014 two ternary integers a and b both of length n and both without leading zeros such that a\u2299b=x and max(a,b) is the minimum possible. If there are several answers, you can print any.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1328C - Ternary XORLet's iterate from left to right over the digits of x. If the current digit is either 0 or 2 then we can set ai=bi=0 or ai=bi=1 correspondingly. There are no better choices. And if the current digit xi is 1 then the optimal choise is to set ai=1 and bi=0. What happens after the first occurrence of 1? Because of this choice a is greater than b even if all remaining digits in b are 2. So for each j>i set aj=0 and bj=xj and print the answer. The case without 1 is even easier and in fact we handle it automatically. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n;\n\t\tstring x;\n\t\tcin >> n >> x;\n\t\tstring a(n, '0'), b(n, '0');\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (x[i] == '1') {\n\t\t\t\ta[i] = '1';\n\t\t\t\tb[i] = '0';\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tb[j] = x[j];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ta[i] = b[i] = '0' + (x[i] - '0') / 2;\n\t\t\t}\n\t\t}\n\t\tcout << a << endl << b << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1327B": {
        "title": "B. Princesses and Princes",
        "description": "The King of Berland Polycarp LXXXIV has n daughters. To establish his power to the neighbouring kingdoms he wants to marry his daughters to the princes of these kingdoms. As a lucky coincidence there are n other kingdoms as well.\nSo Polycarp LXXXIV has enumerated his daughters from 1 to n and the kingdoms from 1 to n. For each daughter he has compiled a list of kingdoms princes of which she wanted to marry.\nPolycarp LXXXIV is very busy, so he finds a couple for his daughters greedily one after another.\nFor the first daughter he takes the kingdom with the lowest number from her list and marries the daughter to their prince. For the second daughter he takes the kingdom with the lowest number from her list, prince of which hasn't been taken already. If there are no free princes in the list then the daughter marries nobody and Polycarp LXXXIV proceeds to the next daughter. The process ends after the n-th daughter.\nFor example, let there be 4 daughters and kingdoms, the lists daughters have are [2,3], [1,2], [3,4], [3], respectively.\nIn that case daughter 1 marries the prince of kingdom 2, daughter 2 marries the prince of kingdom 1, daughter 3 marries the prince of kingdom 3, leaving daughter 4 nobody to marry to.\nActually, before starting the marriage process Polycarp LXXXIV has the time to convince one of his daughters that some prince is also worth marrying to. Effectively, that means that he can add exactly one kingdom to exactly one of his daughter's list. Note that this kingdom should not be present in the daughter's list.\nPolycarp LXXXIV wants to increase the number of married couples.\nUnfortunately, what he doesn't have the time for is determining what entry to add. If there is no way to increase the total number of married couples then output that the marriages are already optimal. Otherwise, find such an entry that the total number of married couples increases if Polycarp LXXXIV adds it.\nIf there are multiple ways to add an entry so that the total number of married couples increases then print any of them.\nFor your and our convenience you are asked to answer t independent test cases.\nThe first line contains a single integer t (1\u2264t\u2264105) \u2014 the number of test cases.\nThen t test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the number of daughters and the number of kingdoms.\nEach of the next n lines contains the description of each daughter's list. The first integer k (0\u2264k\u2264n) is the number of entries in the i-th daughter's list. After that k distinct integers follow gi[1],gi[2],\u2026,gi[k] (1\u2264gi[j]\u2264n) \u2014 the indices of the kingdoms in the list in the increasing order (gi[1]<gi[2]<\u22ef<gi[k]).\nIt's guaranteed that the total number of daughters over all test cases does not exceed 105.\nIt's also guaranteed that the total number of kingdoms in lists over all test cases does not exceed 105.\nFor each test case print the answer to it.\nPrint \"IMPROVE\" in the first line if Polycarp LXXXIV can add some kingdom to some of his daughter's list so that the total number of married couples increases. The second line then should contain two integers \u2014 the index of the daughter and the index of the kingdom Polycarp LXXXIV should add to that daughter's list.\nIf there are multiple ways to add an entry so that the total number of married couples increases then print any of them.\nOtherwise the only line should contain one word \"OPTIMAL\".\nThe first test case is depicted in the statement. Adding the fourth kingdom to the list of the fourth daughter makes her marry the prince of the fourth kingdom.\nIn the second test case any new entry will increase the number of marriages from 0 to 1.\nIn the third and the fourth test cases there is no way to add an entry.\nIn the fifth test case there is no way to change the marriages by adding any entry.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "graphs",
            "greedy",
            "*1200"
        ],
        "solutions": "1327B - Princesses and PrincesSimulate the process without adding the new entry. For this you can just maintain an array taken, i-th value of which is true if the i-th prince is married and false otherwise.Now observe that there are two possible outcomes:   Every daughter is married \u2014 the answer is optimal.  There is a daughter who isn't married. That means that there is a free prince as well. Marry them to each other because doing that won't affect any other marriages and add a new one to the answer. Overall complexity: O(n+m). Solution (pikmike)from sys import stdin, stdout\n\nt = int(stdin.readline())\nfor _ in range(t):\n    n = int(stdin.readline())\n    used = [False for i in range(n)]\n    v = -1\n    for i in range(n):\n        l = [int(x) - 1 for x in stdin.readline().split()][1:]\n        for j in l:\n            if not used[j]:\n                used[j] = True\n                break\n        else:\n            v = i\n    if v == -1:\n        stdout.write(\"OPTIMAL\\n\")\n    else:\n        u = used.index(False)\n        stdout.write(\"IMPROVE\\n\" + str(v + 1) + \" \" + str(u + 1) + \"\\n\")"
    },
    "1327A": {
        "title": "A. Sum of Odd Integers",
        "description": "You are given two integers n and k. Your task is to find if n can be represented as a sum of k distinct positive odd (not divisible by 2) integers or not.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264105) \u2014 the number of test cases.\nThe next t lines describe test cases. The only line of the test case contains two integers n and k (1\u2264n,k\u2264107).\nFor each test case, print the answer \u2014 \"YES\" (without quotes) if n can be represented as a sum of k distinct positive odd (not divisible by 2) integers and \"NO\" otherwise.\nIn the first test case, you can represent 3 as 3.\nIn the second test case, the only way to represent 4 is 1+3.\nIn the third test case, you cannot represent 10 as the sum of three distinct positive odd integers.\nIn the fourth test case, you can represent 10 as 3+7, for example.\nIn the fifth test case, you can represent 16 as 1+3+5+7.\nIn the sixth test case, you cannot represent 16 as the sum of five distinct positive odd integers.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1327A - Sum of Odd IntegersIdea: vovuh TutorialTutorial is loading... Solution (vovuh)for i in range(int(input())):\n    n, k = map(int, input().split())\n    print('YES' if k * k <= n and n % 2 == k % 2 else 'NO')"
    },
    "1326A": {
        "title": "A. Bad Ugly Numbers",
        "description": "You are given a integer n (n>0). Find any integer s which satisfies these conditions, or report that there are no such numbers:\nIn the decimal representation of s: \nThe input consists of multiple test cases. The first line of the input contains a single integer t (1\u2264t\u2264400), the number of test cases. The next t lines each describe a test case.\nEach test case contains one positive integer n (1\u2264n\u2264105).\nIt is guaranteed that the sum of n for all test cases does not exceed 105.\nFor each test case, print an integer s which satisfies the conditions described above, or \"-1\" (without quotes), if no such number exists. If there are multiple possible solutions for s, print any solution.\nIn the first test case, there are no possible solutions for s consisting of one digit, because any such solution is divisible by itself.\nFor the second test case, the possible solutions are: 23, 27, 29, 34, 37, 38, 43, 46, 47, 49, 53, 54, 56, 57, 58, 59, 67, 68, 69, 73, 74, 76, 78, 79, 83, 86, 87, 89, 94, 97, and 98.\nFor the third test case, one possible solution is 239 because 239 is not divisible by 2, 3 or 9 and has three digits (none of which equals zero).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "number theory",
            "*1000"
        ],
        "solutions": "1326A - Bad Ugly NumbersIf n=1, no solution exists.Otherwise, if n\u22652, the number 233\u20263\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af (n digits) satisfies all conditions, because it is not divisible by 2 and 3.Jury solution: link "
    },
    "1324C": {
        "title": "C. Frog Jumps",
        "description": "There is a frog staying to the left of the string s=s1s2\u2026sn consisting of n characters (to be more precise, the frog initially stays at the cell 0). Each character of s is either 'L' or 'R'. It means that if the frog is staying at the i-th cell and the i-th character is 'L', the frog can jump only to the left. If the frog is staying at the i-th cell and the i-th character is 'R', the frog can jump only to the right. The frog can jump only to the right from the cell 0.\nNote that the frog can jump into the same cell twice and can perform as many jumps as it needs.\nThe frog wants to reach the n+1-th cell. The frog chooses some positive integer value d before the first jump (and cannot change it later) and jumps by no more than d cells at once. I.e. if the i-th character is 'L' then the frog can jump to any cell in a range [max(0,i\u2212d);i\u22121], and if the i-th character is 'R' then the frog can jump to any cell in a range [i+1;min(n+1;i+d)].\nThe frog doesn't want to jump far, so your task is to find the minimum possible value of d such that the frog can reach the cell n+1 from the cell 0 if it can jump by no more than d cells at once. It is guaranteed that it is always possible to reach n+1 from 0.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe next t lines describe test cases. The i-th test case is described as a string s consisting of at least 1 and at most 2\u22c5105 characters 'L' and 'R'.\nIt is guaranteed that the sum of lengths of strings over all test cases does not exceed 2\u22c5105 (\u2211|s|\u22642\u22c5105).\nFor each test case, print the answer \u2014 the minimum possible value of d such that the frog can reach the cell n+1 from the cell 0 if it jumps by no more than d at once.\nThe picture describing the first test case of the example and one of the possible answers:\n\nIn the second test case of the example, the frog can only jump directly from 0 to n+1.\nIn the third test case of the example, the frog can choose d=3, jump to the cell 3 from the cell 0 and then to the cell 4 from the cell 3.\nIn the fourth test case of the example, the frog can choose d=1 and jump 5 times to the right.\nIn the fifth test case of the example, the frog can only jump directly from 0 to n+1.\nIn the sixth test case of the example, the frog can choose d=1 and jump 2 times to the right.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dfs and similar",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1324C - Frog JumpsThe only observation we need is that we don't need to jump left at all. This only decreases our position so we have less freedom after the jump to the left. Then, to minimize d, we only need to jump between the closest 'R' cells. So, if we build the array b=[0,r1,r2,\u2026,rk,n+1], where ri is the position of the i-th 'R' cell from left to right (1-indexed), then the answer is maxi=0kbi+1\u2212bi.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<int> pos;\n\t\tpos.push_back(0);\n\t\tfor (int i = 0; i < int(s.size()); ++i) {\n\t\t\tif (s[i] == 'R') pos.push_back(i + 1);\n\t\t}\n\t\tpos.push_back(s.size() + 1);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < int(pos.size()) - 1; ++i) {\n\t\t\tans = max(ans, pos[i + 1] - pos[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1324B": {
        "title": "B. Yet Another Palindrome Problem",
        "description": "You are given an array a consisting of n integers.\nYour task is to determine if a has some subsequence of length at least 3 that is a palindrome.\nRecall that an array b is called a subsequence of the array a if b can be obtained by removing some (possibly, zero) elements from a (not necessarily consecutive) without changing the order of remaining elements. For example, [2], [1,2,1,3] and [2,3] are subsequences of [1,2,1,3], but [1,1,2] and [4] are not.\nAlso, recall that a palindrome is an array that reads the same backward as forward. In other words, the array a of length n is the palindrome if ai=an\u2212i\u22121 for all i from 1 to n. For example, arrays [1234], [1,2,1], [1,3,2,2,3,1] and [10,100,10] are palindromes, but arrays [1,2] and [1,2,3,1] are not.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nNext 2t lines describe test cases. The first line of the test case contains one integer n (3\u2264n\u22645000) \u2014 the length of a. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n), where ai is the i-th element of a.\nIt is guaranteed that the sum of n over all test cases does not exceed 5000 (\u2211n\u22645000).\nFor each test case, print the answer \u2014 \"YES\" (without quotes) if a has some subsequence of length at least 3 that is a palindrome and \"NO\" otherwise.\nIn the first test case of the example, the array a has a subsequence [1,2,1] which is a palindrome.\nIn the second test case of the example, the array a has two subsequences of length 3 which are palindromes: [2,3,2] and [2,2,2].\nIn the third test case of the example, the array a has no subsequences of length at least 3 which are palindromes.\nIn the fourth test case of the example, the array a has one subsequence of length 4 which is a palindrome: [1,2,2,1] (and has two subsequences of length 3 which are palindromes: both are [1,2,1]).\nIn the fifth test case of the example, the array a has no subsequences of length at least 3 which are palindromes.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "*1100"
        ],
        "solutions": "1324B - Yet Another Palindrome Problem TutorialTutorial is loading... Solutionfor i in range(int(input())):\n\tn = int(input())\n\ts = list(map(int, input().split()))\n\tok = False\n\tfor i in range(n):\n\t\tfor j in range(i + 2, n):\n\t\t\tif s[i] == s[j]: ok = True\n\tprint('YES' if ok else 'NO')"
    },
    "1315C": {
        "title": "C. Restoring Permutation",
        "description": "You are given a sequence b1,b2,\u2026,bn. Find the lexicographically minimal permutation a1,a2,\u2026,a2n such that bi=min(a2i\u22121,a2i), or determine that it is impossible.\nEach test contains one or more test cases. The first line contains the number of test cases t (1\u2264t\u2264100).\nThe first line of each test case consists of one integer n\u00a0\u2014 the number of elements in the sequence b (1\u2264n\u2264100).\nThe second line of each test case consists of n different integers b1,\u2026,bn\u00a0\u2014 elements of the sequence b (1\u2264bi\u22642n).\nIt is guaranteed that the sum of n by all test cases doesn't exceed 100.\nFor each test case, if there is no appropriate permutation, print one number \u22121.\nOtherwise, print 2n integers a1,\u2026,a2n\u00a0\u2014 required lexicographically minimal permutation of numbers from 1 to 2n.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "1315C - Restoring PermutationThis problem has a greedy solution. As you know the bi, which is equal to min(a2i\u22121,a2i), then one of a2i\u22121,a2i should be equal to bi. Which one? Of course, a2i\u22121, because we want to get the lexicographically minimal answer, and we want to place a smaller number before the larger number.So, we know that a1=b1, a3=b2, a5=b3, and so on, so we know all elements of the permutation with odd indices. What number should be placed at a2? We know that a2\u2265a1 (as a1\u2260a2, and b1=min(a1,a2)). So, let's take the a2=x for minimal possible x such that x\u2265a1 and x\u2260a1,x\u2260a3,\u2026,x\u2260a2n\u22121. If there is no such x (if all numbers greater than a1 are already used), there is no appropriate permutation. Otherwise, we should take a2=x and resume the process.The question is, why do we can place the minimal not used integer each time? Suppose there is another optimal answer a\u20321,a\u20322,\u2026,a\u20322n, and we get a1,a2,\u2026,a2n or we didn't get any permutation by our greedy algorithm. As these two sequences are different, there is the first k such that a\u20322k\u2260a2k. As we tried to take the minimal possible a2k, there are two options:   a2k>a\u20322k. This is impossible as we tried to take the minimal possible a2k, contradiction;  a2k<a\u20322k. As a\u2032 is \u00aboptimal correct\u00bb answer, we didn't finish our sequence a. Let's see, where is the number a2k in the sequence a\u2032. It should be on some position 2l, where l>k (as 2k is the first difference between the sequences). But we can swap a\u20322k and a\u20322l and get smaller, but still correct sequence a\", so a\u2032 is not optimal. Contradiction.  1310A - RecommendationsIn this problem we have an array a1,\u2026,an, we can increase each ai by one with cost ti, and we want to make all ai different with minimal total cost.Let's sort ai in a non-decreasing way (and permute the t in a corresponding way). Let's see at the minimal number, a1. If it is unique, e.g. a1\u2260a2, then we don't need to change a1\u00a0\u2014 it is already unique, and it can't get equal to something else if we don't increase it. In this case, we can just skip a1 and solve the smaller problem without a1.Otherwise, suppose there is some j>1 such that a1=a2=\u2026=aj. Obviously, we should leave at most one of them with the current value, and increase other j\u22121 numbers by one. Which one should be not increased? We shouldn't increase the al (1\u2264l\u2264j) with the maximal tl because it minimizes the total cost. So, we should remove the maximal value tl among all elements with minimal al, and increase all other by one. This effectively reduces our problem to the smaller one, decreasing n by one.This gives us a O(n2) solution\u00a0\u2014 n times we discard one minimum from the array and increase all other minimums by one. We can further optimize it by using a multiset of values tl for all minimal al and its sum. At each iteration, we should (probably) add some values to a multiset, if the number of minimums in array increases, discard one maximum from multiset and add the current sum to the answer. Continue the process until the array becomes empty. This is an O(nlogn) solution. 1310B - Double EliminationThe main observation in this problem is that for each set of players that lie in the subtree of any vertex of a binary tree of the upper bracket, exactly one player will win all matches in the upper bracket, and exactly one player will win all matches in the lower bracket. We can define this set of players (in 0-indexation instead of 1-indexation from statement) as [a\u22c52t;(a+1)\u22c52t) for some 1\u2264t\u2264n, 0\u2264a<2n2t. For each fixed t the players with different values of id2t don't play with each other, and their upper and lower brackets are independent.For each of these sets of players, we are interested only in a number of interesting matches between them, and if the winner of their upper and lower brackets are the teams that are we're fans of. This leads us to the dynamic programming solution: dp[l\u2026r][fup][flower]\u00a0\u2014 the maximal number of matches between teams with indices in [l;r), if fup\u2208{0,1} is 1 if the we're fans of winner of upper bracket, and flower\u2208{0,1} is 1 if the we're fans of winner of lower bracket. Again, l\u2026r is the special segment: l=a\u22c52t,r=(a+1)\u22c52t\u22121 for some 1\u2264t\u2264n, 0\u2264a<2n2t.dp[l\u2026r][fup][flower] can be recalculated from dp[l\u2026l+r2][flup][fllower] and dp[l+r2\u2026r][frup][frlower]\u00a0\u2014 we just iterate over all possible flup,fllower,frup,frlower, and the results of all three matches (one in the upper bracket and two in the lower bracket).In the end, we use dp[0\u20262n][fup][flower] to count the result with the last, grand-finals match.This solution works in something like O(2n\u22c527) because there are 2n interesting segments. 1310C - Au Pont RougeLet's list all distinct substrings, sort them and make a binary search. Now, we need to count number of ways to make minimal string no more then given one. Let's count inverse value \u2014 number of wat to make minimal string greater. It could be done by quadratic dynamic programming dppos,count \u2014 number of ways to split suffix starting at pos to count string all of which are greater then given value. Let's find first position where suffix differs which given string. If next character in suffix is smaller, no part can start here and answer is zero. Otherwise, any longer part is acceptable, so we need to find \u2211i>lcp(S,s[pos:])dpi,count\u22121, which can be done in O(1) time by suffix sums and precalculating lcp for all pairs of suffixes. Later can by done by another quadratic dynamic programming. lcp of two suffix is equal to 0 if first letter differs, and equal to lcp of two smaller suffixes +1 otherwise.  1310D - TourismThere are two different solutions possible. First, one is to fix all even vertices in the path. It can be done in O(nk/2\u22121) time. If it's done, we need to join them by the minimal path of length 2, not going through these vertices. It can be done by precalculating 6 minimal paths of length 2 between each pair of vertices and ignoring no more than 5 best ones until good one found. Another solution is a randomized one. Let's color all vertices in 2 colors in a random way. We can find the best path which is consistent with given coloring in O(k\u22c5E) time using dynamic programming. With probability 1512 best path overall is consistent with coloring. So, if one repeats this operation 512\u22c520 time, probability of fail would be about (511512)512\u22c520\u2248e\u221220\u22482\u22c510\u22129.  1310E - Strange FunctionThe solution of the task consists of three cases:  k=1. For fixed n f(a) can be equal to any partition of n. We need to count the number of arrays b1,b2,\u2026,bm, such that b1\u2265b2\u2265\u2026\u2265bm and m\u2211i=1bi\u2264n. This can be done by simple dp in O(n2) (or even faster, much faster). k=2. When the array b1\u2265b2\u2265\u2026\u2265bm can be equal to value of f2(a) for some |a|\u2264n? When there exists some array c1,\u2026,cl such that l\u2211i=1ci\u2264n, and f(c)=b. The values of b are the numbers of occurences of numbers in c, so we need to minimize m\u2211i=1bivi, where vi\u00a0\u2014 the unique numbers in c. To minimize this sum we should take v1=1,\u2026,vm=m, so we need m\u2211i=1bii\u2264n. This can be done by simple dp: dp[val][j][sum]\u00a0\u2014 the number of prefixes of b such that we already took j elements to b, all elements on prefix are greater than or equal to val, and the j\u2211i=1bii=sum.This dp can look like it is O(n3), but it is actually O(n2logn), because there is a limitation val\u22c5j\u2264n, and there are O(nlogn) such pairs. There is also a subquadratic solution. k\u22653. We can notice that in the array f2(a) there are at most O(\u221a2n) elements. We can use this fact to bruteforce all possible answers\u00a0\u2014 candidates for the answer are the partitions of numbers not exceeding \u221a2n=64, there are few millions of them. How to check if the array b1\u2265b2\u2265\u2026\u2265bm can be the falue of fk(a)? It happens that we can make k\u22122 iterations of the unfolding algorithm from case k=2 and get the \u00abminimal\u00bb possible array a, and check, if it contains no more than n elements. This part works in O(P(\u221a2n)). 1310F - Bad CryptographyOne of the well-known algorithms for the discrete logarithm problem is baby step giant step algorithm based on the meet in the middle idea. It can solve the problem in O(\u221a|F|) time, which is definitely too much for the field of size 264. Multiplicative group of field has size F=264\u22121=3\u22c55\u22c517\u22c5257\u22c5641\u22c565537\u22c56700417. We can see, that all numbers in this factoring are not too big. Let's try to find an answer modulo each of these primes. If we do that, we can restore the answer by the Chinese remainder theorem, and we are done. Let p be one of divisors. So, if x=k\u2217p+y is answer, than akp+y=b, than akF+yFp=bFp. aF is equal to 1, so problem is equivalent to searching such an y, that (aFp)y=bFp, which is discrete logarithm problem on multiplicative subgroup of size p. So it can be solved using O(\u221ap) multiplications, which is about 6000 multiplications total for all values of p. If one of the discrete logarithms not exists, the total answer obviously not exists. Another corner case, that both values in subproblem can be equal to 1. That means, that any value for this module is good. Also, this means, that a and b both have a smaller period, so any of these values would lead us to the correct answer. Another part of problem is making multiplication fast enough. The first idea is to cache multiplications for powers of 2. This solution works for about 5 seconds in my implementation, and probably can be squeezed in time limit with some hacks. But multiplication can be done asymptotically faster. Let's a=a1\u22c5P+a2, b=b1\u22c5P+b2 is decomposition to first and second half of bits (in fact P is equal to power in multiply_powers_of_2 function). Then a\u2299b=(a1\u22c5P+a2)\u22c5(b1\u22c5P+b2)=(a1\u2299P\u2295a2)\u2299(b1\u2299P\u2295b2)=(a1\u2299b1)\u2299(P\u2299P)\u2295(a2\u2299b2)\u2295((a1\u2299b2)\u2295(a2\u2299b1))\u2299P. As in Karatsuba algroithm, this 4 products can be reduce for 3, if one notice, that (a1\u2299b2)\u2295(a2\u2299b1)=(a1\u2295a2)\u2299(b1\u2295b2)\u2295(a1\u2299b1)\u2295(a2\u2299b2). The only diffrenece is instead of shift for multiplying on P\u22c5P we need to do one more multiplication. But P\u2299P=P\u2295P2. We can multiply by them separately. Multiplying on P is easy. The other one is multiplying on the power of 2, which can be done by the naive algorithm in linear time. On the other hand, we can just call multiply for the second one recursively, and it will work fast enough because most of the branches will lead to multiplying on zero. Also, to make things fast, one can precompute all multiplications for numbers smaller than 256. This makes multiplication about 5 times faster than naive approach. "
    },
    "1312B": {
        "title": "B. Bogosort",
        "description": "You are given an array a1,a2,\u2026,an. Array is good if for each pair of indexes i<j the condition j\u2212aj\u2260i\u2212ai holds. Can you shuffle this array so that it becomes good? To shuffle an array means to reorder its elements arbitrarily (leaving the initial order is also an option).\nFor example, if a=[1,1,3,5], then shuffled arrays [1,3,5,1], [3,5,1,1] and [5,3,1,1] are good, but shuffled arrays [3,1,5,1], [1,1,3,5] and [1,1,5,3] aren't.\nIt's guaranteed that it's always possible to shuffle an array to meet this condition.\nThe first line contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThe first line of each test case contains one integer n (1\u2264n\u2264100) \u2014 the length of array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264100).\nFor each test case print the shuffled version of the array a which is good.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solutions": "1312B - BogosortLet's sort array a in non-ascending order (a1\u2265a2\u2265\u22ef\u2265an). In this case for each pair of indexes i<j the condition j\u2212aj\u2260i\u2212ai holds. Solution (Roms)for t in range(int(input())):\n    n = input()\n    print(*sorted(map(int, input().split()))[::-1])"
    },
    "1311B": {
        "title": "B. WeirdSort",
        "description": "You are given an array a of length n.\nYou are also given a set of distinct positions p1,p2,\u2026,pm, where 1\u2264pi<n. The position pi means that you can swap elements a[pi] and a[pi+1]. You can apply this operation any number of times for each of the given positions.\nYour task is to determine if it is possible to sort the initial array in non-decreasing order (a1\u2264a2\u2264\u22ef\u2264an) using only allowed swaps.\nFor example, if a=[3,2,1] and p=[1,2], then we can first swap elements a[2] and a[3] (because position 2 is contained in the given set p). We get the array a=[3,1,2]. Then we swap a[1] and a[2] (position 1 is also contained in p). We get the array a=[1,3,2]. Finally, we swap a[2] and a[3] again and get the array a=[1,2,3], sorted in non-decreasing order.\nYou can see that if a=[4,1,2,3] and p=[3,2] then you cannot sort the array.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThen t test cases follow. The first line of each test case contains two integers n and m (1\u2264m<n\u2264100) \u2014 the number of elements in a and the number of elements in p. The second line of the test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264100). The third line of the test case contains m integers p1,p2,\u2026,pm (1\u2264pi<n, all pi are distinct) \u2014 the set of positions described in the problem statement.\nFor each test case, print the answer \u2014 \"YES\" (without quotes) if you can sort the initial array in non-decreasing order (a1\u2264a2\u2264\u22ef\u2264an) using only allowed swaps. Otherwise, print \"NO\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "sortings",
            "*1200"
        ],
        "solutions": "1311B - WeirdSortThe simple simulation works here: while there is at least one inversion (such a pair of indices i and i+1 that a[i]>a[i+1]) we can fix, let's fix it (we can fix this inversion if i\u2208p). If there are inversions but we cannot fix any of them, the answer is \"NO\". Otherwise, the answer is \"YES\".There is also a O(nlogn) solution: it is obvious that we have some segments in which we can change the order of elements as we want. And it is also obvious that we cannot move elements between these \"allowed\" segments. So, each of them is independent of each other. We can just find all these segments of indices using two pointers and sort them independently. Then we just need to check if the array becomes sorted.Time complexity is O(n2) or O(nlogn). Solution (n^2)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> p(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tp[pos - 1] = 1;\n\t\t}\n\t\twhile (true) {\n\t\t\tbool ok = false;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (p[i] && a[i] > a[i + 1]) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tswap(a[i], a[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) break;\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tok &= a[i] <= a[i + 1];\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n} Solution (n log n)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> p(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint pos;\n\t\t\tcin >> pos;\n\t\t\tp[pos - 1] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (p[i] == 0) continue;\n\t\t\tint j = i;\n\t\t\twhile (j < n && p[j]) ++j;\n\t\t\tsort(a.begin() + i, a.begin() + j + 1);\n\t\t\ti = j;\n\t\t}\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tok &= a[i] <= a[i + 1];\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}\n"
    },
    "1305B": {
        "title": "B. Kuroni and Simple Strings",
        "description": "Now that Kuroni has reached 10 years old, he is a big boy and doesn't like arrays of integers as presents anymore. This year he wants a Bracket sequence as a Birthday present. More specifically, he wants a bracket sequence so complex that no matter how hard he tries, he will not be able to remove a simple subsequence!\nWe say that a string formed by n characters '(' or ')' is simple if its length n is even and positive, its first n2 characters are '(', and its last n2 characters are ')'. For example, the strings () and (()) are simple, while the strings )( and ()() are not simple.\nKuroni will be given a string formed by characters '(' and ')' (the given string is not necessarily simple). An operation consists of choosing a subsequence of the characters of the string that forms a simple string and removing all the characters of this subsequence from the string. Note that this subsequence doesn't have to be continuous. For example, he can apply the operation to the string ')()(()))', to choose a subsequence of bold characters, as it forms a simple string '(())', delete these bold characters from the string and to get '))()'. \nKuroni has to perform the minimum possible number of operations on the string, in such a way that no more operations can be performed on the remaining string. The resulting string does not have to be empty.\nSince the given string is too large, Kuroni is unable to figure out how to minimize the number of operations. Can you help him do it instead?\nA sequence of characters a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters.\nThe only line of input contains a string s (1\u2264|s|\u22641000) formed by characters '(' and ')', where |s| is the length of s.\nIn the first line, print an integer k \u00a0\u2014 the minimum number of operations you have to apply. Then, print 2k lines describing the operations in the following format:\nFor each operation, print a line containing an integer m \u00a0\u2014 the number of characters in the subsequence you will remove.\nThen, print a line containing m integers 1\u2264a1<a2<\u22ef<am \u00a0\u2014 the indices of the characters you will remove. All integers must be less than or equal to the length of the current string, and the corresponding subsequence must form a simple string.\nIf there are multiple valid sequences of operations with the smallest k, you may print any of them.\nIn the first sample, the string is '(()(('. The operation described corresponds to deleting the bolded subsequence. The resulting string is '(((', and no more operations can be performed on it. Another valid answer is choosing indices 2 and 3, which results in the same final string.\nIn the second sample, it is already impossible to perform any operations.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "strings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1305B - Kuroni and Simple StringsWe claim that the answer is always 0 or 1. First, note we can't apply any operations if and only if each '(' symbol is left from each ')' symbol, so that the string looks as ')))(((((('.Let a1,a2,\u2026,ap be the indexes of symbols '(' in the string, and b1,b2,\u2026,bq be the indexes of symbols ')' in the string. Let i be the largest index for which ai<bq\u2212i+1. We claim that we can delete subsequence {a1,a2,\u2026,ai,bq\u2212i+1,\u2026,bq\u22121,bq}, and won't be able to apply any operation to the resulting string. Indeed, suppose that in the resulting string some '(' symbol will be to the left from some ')' symbol, say they were ak and bl in out sequences. Then we must have k>i and l<q\u2212i+1, as they weren't deleted yet. So, we get that bi+1\u2264bk<bl\u2264bq\u2212i, so i wasn't maximal.In other words, just pick brackets greedily from ends, forming as large simple string as you can. Asymptotics O(|s|). Solution (Ari, C++)Submission link: 72364435 Source code in plain text#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tstring s;\n\tcin >> s;\n\tvector<int> le, ri;\n\tint l = 0, r = s.size() - 1;\n\twhile(l < r) {\n\t\twhile(l < s.size() && s[l] == ')')\n\t\t\tl++;\n\t\twhile(r >= 0 && s[r] == '(')\n\t\t\tr--;\n\t\tif(l < s.size() && r >= 0 && l < r) {\n\t\t\tle.push_back(l + 1);\n\t\t\tri.push_back(r + 1);\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t}\n\tif(le.empty()) {\n\t\tcout << \"0\\n\";\n\t\treturn 0;\n\t}\n\tcout << \"1\\n\";\n\tcout << 2 * le.size() << '\\n';\n\tfor(auto x : le)\n\t\tcout << x << \" \";\n\treverse(ri.begin(), ri.end());\n\tfor(auto x : ri)\n\t\tcout << x << \" \";\n\tcout << '\\n';\n} Solution (Akikaze, Java 8)Submission link: 72364561 Source code in plain textimport java.io.*;\nimport java.util.*;\n\npublic class JavAki {\n\tpublic static Scanner sc = new Scanner(System.in);\n\n\tpublic static String s;\n\n\tpublic static void Input() {\n\t\ts = sc.next();\n\t}\n\n\tpublic static void Solve() {\n\t\tArrayList<Integer> oList = new ArrayList<>();\n\t\tArrayList<Integer> cList = new ArrayList<>();\n\t\tfor (int i=0; i<s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') oList.add(i);\n\t\t\tif (s.charAt(i) == ')') cList.add(i);\n\t\t}\n\n\t\tArrayList<Integer> removal = new ArrayList<>();\n\t\tint oPtr = 0, cPtr = cList.size() - 1;\n\t\twhile (oPtr < oList.size() && cPtr >= 0) {\n\t\t\tif (oList.get(oPtr) > cList.get(cPtr)) break;\n\t\t\tremoval.add(oList.get(oPtr)); removal.add(cList.get(cPtr));\n\t\t\toPtr++; cPtr--;\n\t\t}\n\n\t\tCollections.sort(removal);\n\t\tif (removal.size() == 0) System.out.println(0);\n\t\telse {\n\t\t\tSystem.out.println(1); System.out.println(removal.size());\n\t\t\tfor (int x: removal) System.out.print((x+1) + \" \");\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInput(); Solve();\n\t}\n} Solution (Akikaze, Python 3)Submission link: 72364606 Source code in plain textstring = input()\noList, cList = [], []\nfor i in range(len(string)):\n\tif string[i] == '(': oList.append(i)\n\tif string[i] == ')': cList.append(i)\n\noPtr, cPtr = 0, len(cList)-1\nremoval = []\nwhile oPtr < len(oList) and cPtr >= 0:\n\tif oList[oPtr] > cList[cPtr]: break\n\tremoval.append(oList[oPtr])\n\tremoval.append(cList[cPtr])\n\toPtr += 1\n\tcPtr -= 1\n\nremoval.sort()\nif len(removal) == 0: print(0)\nelse: print('1\\n{}\\n{}'.format(len(removal), ' '.join([str(x+1) for x in removal])))"
    },
    "1304B": {
        "title": "B. Longest Palindrome",
        "description": "Returning back to problem solving, Gildong is now studying about palindromes. He learned that a palindrome is a string that is the same as its reverse. For example, strings \"pop\", \"noon\", \"x\", and \"kkkkkk\" are palindromes, while strings \"moon\", \"tv\", and \"abab\" are not. An empty string is also a palindrome.\nGildong loves this concept so much, so he wants to play with it. He has n distinct strings of equal length m. He wants to discard some of the strings (possibly none or all) and reorder the remaining strings so that the concatenation becomes a palindrome. He also wants the palindrome to be as long as possible. Please help him find one.\nThe first line contains two integers n and m (1\u2264n\u2264100, 1\u2264m\u226450) \u2014 the number of strings and the length of each string.\nNext n lines contain a string of length m each, consisting of lowercase Latin letters only. All strings are distinct.\nIn the first line, print the length of the longest palindrome string you made.\nIn the second line, print that palindrome. If there are multiple answers, print any one of them. If the palindrome is empty, print an empty line or don't print this line at all.\nIn the first example, \"battab\" is also a valid answer.\nIn the second example, there can be 4 different valid answers including the sample output. We are not going to provide any hints for what the others are.\nIn the third example, the empty string is the only valid palindrome string.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1304B - \u0421\u0430\u043c\u044b\u0439 \u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043cLet's define rev(S) as the reversed string of a string S. There are two cases when we choose K strings to make a palindrome string S1+S2+\u22ef+SK:   If K is even, for every integer X (1\u2264X\u2264K2), SX=rev(SK\u2212X+1).  if K is odd, SK+12 must be palindrome. Also for every integer X (1\u2264X\u2264K\u221212), SX=rev(SK\u2212X+1). In either case we want to find as many pairs of strings as possible such that one is the reverse of the other. It is also clear that if T is a palindrome string then rev(T)=T. We cannot make a pair of T and rev(T) because all strings in the input are distinct.Therefore, for each string we need to find if there is another string that is its reverse. If there exists one, put them on the left / right end respectively. If there are one or more strings that are palindrome themselves, pick any one of them and put it in the middle.Time complexity: O(n2m) if we implement it naively. O(nmlogn) is possible if we use a data structure that provides O(logn) search such as std::set in C++. Solution#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 100;\nstring s[MAX_N];\n\nint main()\n{\n\tset<string> dict;\n\tint n, m, i;\n\tcin >> n >> m;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tcin >> s[i];\n\t\tdict.insert(s[i]);\n\t}\n\tvector<string> left, right;\n\tstring mid;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstring t = s[i];\n\t\treverse(t.begin(), t.end());\n\t\tif (t == s[i])\n\t\t\tmid = t;\n\t\telse if (dict.find(t) != dict.end())\n\t\t{\n\t\t\tleft.push_back(s[i]);\n\t\t\tright.push_back(t);\n\t\t\tdict.erase(s[i]);\n\t\t\tdict.erase(t);\n\t\t}\n\t}\n\tcout << left.size() * m * 2 + mid.size() << endl;\n\tfor (string x : left)\n\t\tcout << x;\n\tcout << mid;\n\treverse(right.begin(), right.end());\n\tfor (string x : right)\n\t\tcout << x;\n\tcout << endl;\n}"
    },
    "1300B": {
        "title": "B. Assigning to Classes",
        "description": "Reminder: the median of the array [a1,a2,\u2026,a2k+1] of odd number of elements is defined as follows: let [b1,b2,\u2026,b2k+1] be the elements of the array in the sorted order. Then median of this array is equal to bk+1.\nThere are 2n students, the i-th student has skill level ai. It's not guaranteed that all skill levels are distinct.\nLet's define skill level of a class as the median of skill levels of students of the class.\nAs a principal of the school, you would like to assign each student to one of the 2 classes such that each class has odd number of students (not divisible by 2). The number of students in the classes may be equal or different, by your choice. Every student has to be assigned to exactly one class. Among such partitions, you want to choose one in which the absolute difference between skill levels of the classes is minimized.\nWhat is the minimum possible absolute difference you can achieve?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of students halved.\nThe second line of each test case contains 2n integers a1,a2,\u2026,a2n (1\u2264ai\u2264109)\u00a0\u2014 skill levels of students.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer, the minimum possible absolute difference between skill levels of two classes of odd sizes.\nIn the first test, there is only one way to partition students\u00a0\u2014 one in each class. The absolute difference of the skill levels will be |1\u22121|=0.\nIn the second test, one of the possible partitions is to make the first class of students with skill levels [6,4,2], so that the skill level of the first class will be 4, and second with [5,1,3], so that the skill level of the second class will be 3. Absolute difference will be |4\u22123|=1.\nNote that you can't assign like [2,3], [6,5,4,1] or [], [6,5,4,1,2,3] because classes have even number of students.\n[2], [1,3,4] is also not possible because students with skills 5 and 6 aren't assigned to a class.\nIn the third test you can assign the students in the following way: [3,4,13,13,20],[2,5,8,16,17] or [3,8,17],[2,4,5,13,13,16,20]. Both divisions give minimal possible absolute difference.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1000"
        ],
        "solutions": "1300B - Assigning to ClassesLet's sort the array. From now on, a1\u2264a2\u22ef\u2264a2n.Consider any partition. Suppose that the first class has 2k+1 students, and the skill level of this class is ai, and the second class had 2l+1 students, and the skill level of this class is aj, where (2k+1)+(2l+1)=2n\u27f9k+l=n\u22121. Without losing generality, i<j. At least n+1 students have skill level at least ai. Indeed, as ai is a median of his class, he and k other students have skill level at least ai. As aj\u2265ai and at least l other students of the second class have skill level at least aj\u2265ai, we get at least k+l+2=n+1 students (including ai) with skill level at least ai. Therefore, ai\u2264an.Similarly, we get that at least n+1 students have skill level at most aj. Therefore, aj\u2265an+1.So, |aj\u2212ai|\u2265an+1\u2212an. However, an+1\u2212an is achievable. Let's put student an into the class alone, and all other students into other class. an+1 will be the median skill level of that class, so the absolute difference will be exactly an+1\u2212an.Therefore, it's enough to sort the array and to output the difference between two middle elements.  "
    },
    "1294B": {
        "title": "B. Collecting Packages",
        "description": "There is a robot in a warehouse and n packages he wants to collect. The warehouse can be represented as a coordinate grid. Initially, the robot stays at the point (0,0). The i-th package is at the point (xi,yi). It is guaranteed that there are no two packages at the same point. It is also guaranteed that the point (0,0) doesn't contain a package.\nThe robot is semi-broken and only can move up ('U') and right ('R'). In other words, in one move the robot can go from the point (x,y) to the point (x+1,y) or to the point (x,y+1).\nAs we say above, the robot wants to collect all n packages (in arbitrary order). He wants to do it with the minimum possible number of moves. If there are several possible traversals, the robot wants to choose the lexicographically smallest path.\nThe string s of length n is lexicographically less than the string t of length n if there is some index 1\u2264j\u2264n that for all i from 1 to j\u22121 si=ti and sj<tj. It is the standard comparison of string, like in a dictionary. Most programming languages compare strings in this way.\nThe first line of the input contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases. Then test cases follow.\nThe first line of a test case contains one integer n (1\u2264n\u22641000) \u2014 the number of packages.\nThe next n lines contain descriptions of packages. The i-th package is given as two integers xi and yi (0\u2264xi,yi\u22641000) \u2014 the x-coordinate of the package and the y-coordinate of the package.\nIt is guaranteed that there are no two packages at the same point. It is also guaranteed that the point (0,0) doesn't contain a package.\nThe sum of all values n over test cases in the test doesn't exceed 1000.\nPrint the answer for each test case.\nIf it is impossible to collect all n packages in some order starting from (0,0), print \"NO\" on the first line.\nOtherwise, print \"YES\" in the first line. Then print the shortest path \u2014 a string consisting of characters 'R' and 'U'. Among all such paths choose the lexicographically smallest path.\nNote that in this problem \"YES\" and \"NO\" can be only uppercase words, i.e. \"Yes\", \"no\" and \"YeS\" are not acceptable.\nFor the first test case in the example the optimal path RUUURRRRUU is shown below: ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1294B - Collecting PackagesIt is obvious that if there is a pair of points (xi,yi) and (xj,yj) such that xi<xj and yi>yj then the answer is \"NO\". It means that if the answer is \"YES\" then there is some ordering of points such that xi1\u2264xi2\u2264\u22ef\u2264xin and yi1\u2264yi2\u2264\u22ef\u2264yin because we can only move right or up. But what is this ordering? it is just sorted order of points (firstly by xi then by yi).So we can sort all points, check if this ordering is valid and traverse among all these points. For each k from 2 to n firstly do xik\u2212xik\u22121 moves to the right then do yik\u2212yik\u22121 moves to the up (because this order minimizing the answer lexicographically).Time complexity: O(nlogn) or O(n2). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n    int t;\n    cin >> t;\n    \n    for (int tt = 0; tt < t; tt++) {\n     \tint n;\n    \tcin >> n;\n    \tvector<pair<int, int>> a(n);\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tcin >> a[i].first >> a[i].second;\n    \t}\n    \tsort(a.begin(), a.end());\n    \tpair<int, int> cur = make_pair(0, 0);\n    \tstring ans;\n    \tbool ok = true;\n    \tfor (int i = 0; i < n; ++i) {\n    \t\tint r = a[i].first - cur.first;\n    \t\tint u = a[i].second - cur.second;\n    \t\tif (r < 0 || u < 0) {\n    \t\t\tcout << \"NO\" << endl;\n    \t\t\tok = false;\n    \t\t\tbreak;\n    \t\t}\n    \t\tans += string(r, 'R');\n    \t\tans += string(u, 'U');\n    \t\tcur = a[i];\n    \t}\n    \t\n    \tif (ok)\n    \t    cout << \"YES\" << endl << ans << endl;\n   }\n\n\treturn 0;\n}"
    },
    "1293B": {
        "title": "B. JOE is on TV!",
        "description": "Our dear Cafe's owner, JOE Miller, will soon take part in a new game TV-show \"1 vs. n\"!\nThe game goes in rounds, where in each round the host asks JOE and his opponents a common question. All participants failing to answer are eliminated. The show ends when only JOE remains (we assume that JOE never answers a question wrong!).\nFor each question JOE answers, if there are s (s>0) opponents remaining and t (0\u2264t\u2264s) of them make a mistake on it, JOE receives ts dollars, and consequently there will be s\u2212t opponents left for the next question.\nJOE wonders what is the maximum possible reward he can receive in the best possible scenario. Yet he has little time before show starts, so can you help him answering it instead?\nThe first and single line contains a single integer n (1\u2264n\u2264105), denoting the number of JOE's opponents in the show.\nPrint a number denoting the maximum prize (in dollars) JOE could have.\nYour answer will be considered correct if it's absolute or relative error won't exceed 10\u22124. In other words, if your answer is a and the jury answer is b, then it must hold that |a\u2212b|max(1,b)\u226410\u22124.\nIn the second example, the best scenario would be: one contestant fails at the first question, the other fails at the next one. The total reward will be 12+11=1.5 dollars.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1293B - JOE is on TV!Frums - Turnstile JumperThis is a greedy problem, with the optimal scenario being each question eliminating a single opponent.It is easy to see that we will want each question to eliminate one opponent only, since after each elimination, the ratio t/s will be more and more rewarding (as s lowers overtime) - as a result, each elimination should have the lowest possible t (i.e. t=1) so more opponents would have their rewards increased.Time complexity is O(n). Solution (Akikaze, C++)Submission link: 69151243 Source code in plain text#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n\nint n;\n\nvoid Input() {\n\tcin >> n;\n}\n\nvoid Solve() {\n\tdouble ans = 0;\n\tfor (int i=1; i<=n; i++) ans += 1.0 / i;\n\t\n\tcout << fixed << setprecision(12) << ans << endl;\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n} Solution (Akikaze, Java 8)Submission link: 69151737 Source code in plain textimport java.io.*;\nimport java.util.*;\n\npublic class Akisolution {\n\tpublic static Scanner sc = new Scanner(System.in);\n\tpublic static PrintWriter out = new PrintWriter(System.out, true);\n\tpublic static int n;\n\n\tpublic static void Input() {\n\t\tn = sc.nextInt();\n\t}\n\n\tpublic static void Solve() {\n\t\tdouble ans = 0;\n\t\tfor (int i=1; i<=n; i++) ans += 1.0 / i;\n\n\t\tout.printf(\"%.12f\\n\", ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tInput(); Solve();\n\t}\n} Solution (Akikaze, Python 3)Submission link: 69151256 Source code in plain textT = 1\nfor test_no in range(T):\n\tn = int(input())\n\tans = sum([1.0 / i for i in range(1, n+1)])\n\n\tprint(ans)"
    },
    "1293A": {
        "title": "A. ConneR and the A.R.C. Markland-N",
        "description": "A.R.C. Markland-N is a tall building with n floors numbered from 1 to n. Between each two adjacent floors in the building, there is a staircase connecting them.\nIt's lunchtime for our sensei Colin \"ConneR\" Neumann Jr, and he's planning for a location to enjoy his meal.\nConneR's office is at floor s of the building. On each floor (including floor s, of course), there is a restaurant offering meals. However, due to renovations being in progress, k of the restaurants are currently closed, and as a result, ConneR can't enjoy his lunch there.\nCooneR wants to reach a restaurant as quickly as possible to save time. What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant.\nPlease answer him quickly, and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns' way!\nThe first line contains one integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases in the test. Then the descriptions of t test cases follow.\nThe first line of a test case contains three integers n, s and k (2\u2264n\u2264109, 1\u2264s\u2264n, 1\u2264k\u2264min(n\u22121,1000))\u00a0\u2014 respectively the number of floors of A.R.C. Markland-N, the floor where ConneR is in, and the number of closed restaurants.\nThe second line of a test case contains k distinct integers a1,a2,\u2026,ak (1\u2264ai\u2264n)\u00a0\u2014 the floor numbers of the currently closed restaurants.\nIt is guaranteed that the sum of k over all test cases does not exceed 1000.\nFor each test case print a single integer\u00a0\u2014 the minimum number of staircases required for ConneR to walk from the floor s to a floor with an open restaurant.\nIn the first example test case, the nearest floor with an open restaurant would be the floor 4.\nIn the second example test case, the floor with ConneR's office still has an open restaurant, so Sensei won't have to go anywhere.\nIn the third example test case, the closest open restaurant is on the 6-th floor.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "implementation",
            "*1100"
        ],
        "solutions": "1293A - \u041a\u043e\u043d\u043d\u0435\u0420 \u0438 A.R.C. Markland-NAuthor: xuanquang1999Development: xuanquang1999, AkiLotusEditorialist: xuanquang1999, AkiLotus  TutorialTutorial is loading... Solution (Akikaze, C++)Submission link: 69149995 Source code in plain text#pragma GCC optimize(\"Ofast\")\n \n#include <bits/stdc++.h>\nusing namespace std;\n \n#define endl '\\n'\n \nint n, s, k;\nvector<int> a;\n \nvoid Input() {\n\tcin >> n >> s >> k; a.clear(); a.resize(k);\n\tfor (auto &z: a) cin >> z;\n}\n \nvoid Solve() {\n\tfor (int i=0; i<=k; i++) {\n\t\tif (s-i >= 1 && find(a.begin(), a.end(), s-i) == a.end()) {cout << i << endl; return;}\n\t\tif (s+i <= n && find(a.begin(), a.end(), s+i) == a.end()) {cout << i << endl; return;}\n\t}\n\tassert(false); // if reached this line, the solution failed to find a free floor\n}\n \nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tint T; cin >> T; while (T--) {Input(); Solve();} return 0;\n} Solution (Akikaze, Java 8)Submission link: 69150848 Source code in plain textimport java.io.*;\nimport java.util.*;\n\npublic class Akisolution {\n\tpublic static Scanner sc = new Scanner(System.in);\n\tpublic static PrintWriter out = new PrintWriter(System.out, true);\n\tpublic static int n, s, k;\n\tpublic static int[] a;\n\n\tpublic static boolean exist(int[] arr, int x) {\n\t\tfor (int i=0; i<arr.length; i++) {\n\t\t\tif (arr[i] == x) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void Input() {\n\t\tn = sc.nextInt(); s = sc.nextInt(); k = sc.nextInt();\n\t\ta = new int[k];\n\t\tfor (int i=0; i<k; i++) a[i] = sc.nextInt();\n\t}\n\n\tpublic static void Solve() {\n\t\tfor (int i=0; i<=k; i++) {\n\t\t\tif (s-i >= 1 && !exist(a, s-i)) {out.println(i); return;}\n\t\t\tif (s+i <= n && !exist(a, s+i)) {out.println(i); return;}\n\t\t}\n\t\tassert false; // if reached this line, the solution failed to find a free floor\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint t = sc.nextInt();\n\t\twhile (t-- > 0) {Input(); Solve();}\n\t}\n} Solution (Akikaze, Python 3)Submission link: 69150816 Source code in plain textT = int(input())\nfor test_no in range(T):\n\tn, s, k = map(int, input().split())\n\ta = list(map(int, input().split()))\n\n\tfor i in range(0, k+1):\n\t\tif s-i >= 1 and not s-i in a: \n\t\t\tprint(i); break\n\t\tif s+i <= n and not s+i in a:\n\t\t\tprint(i); break\n\telse: assert(False) # if reached this line, the solution failed to find a free floor"
    },
    "1288B": {
        "title": "B. Yet Another Meme Problem",
        "description": "You are given two integers A and B, calculate the number of pairs (a,b) such that 1\u2264a\u2264A, 1\u2264b\u2264B, and the equation a\u22c5b+a+b=conc(a,b) is true; conc(a,b) is the concatenation of a and b (for example, conc(12,23)=1223, conc(100,11)=10011). a and b should not contain leading zeroes.\nThe first line contains t (1\u2264t\u2264100) \u2014 the number of test cases.\nEach test case contains two integers A and B (1\u2264A,B\u2264109).\nPrint one integer \u2014 the number of pairs (a,b) such that 1\u2264a\u2264A, 1\u2264b\u2264B, and the equation a\u22c5b+a+b=conc(a,b) is true.\nThere is only one suitable pair in the first test case: a=1, b=9 (1+9+1\u22c59=19).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1288B - Yet Another Meme ProblemLet's perform some conversions:a\u22c5b+a+b=conc(a,b)a\u22c5b+a+b=a\u22c510|b|+b, where |b| is the length of decimal representation of b.a\u22c5b+a=a\u22c510|b|b+1=10|b|Thus, b always look like 99\u202699. So, the answer is a\u2217(|b+1|\u22121). Solution (Roms)for t in range(int(input())):\n\ta, b = map(int, input().split())\n\tprint(a * (len(str(b + 1)) - 1))"
    },
    "1288A": {
        "title": "A. Deadline",
        "description": "Adilbek was assigned to a special project. For Adilbek it means that he has n days to run a special program and provide its results. But there is a problem: the program needs to run for d days to calculate the results.\nFortunately, Adilbek can optimize the program. If he spends x (x is a non-negative integer) days optimizing the program, he will make the program run in \u2308dx+1\u2309 days (\u2308a\u2309 is the ceiling function: \u23082.4\u2309=3, \u23082\u2309=2). The program cannot be run and optimized simultaneously, so the total number of days he will spend is equal to x+\u2308dx+1\u2309.\nWill Adilbek be able to provide the generated results in no more than n days?\nThe first line contains a single integer T (1\u2264T\u226450) \u2014 the number of test cases.\nThe next T lines contain test cases \u2013 one per line. Each line contains two integers n and d (1\u2264n\u2264109, 1\u2264d\u2264109) \u2014 the number of days before the deadline and the number of days the program runs.\nPrint T answers \u2014 one per test case. For each test case print YES (case insensitive) if Adilbek can fit in n days or NO (case insensitive) otherwise.\nIn the first test case, Adilbek decides not to optimize the program at all, since d\u2264n.\nIn the second test case, Adilbek can spend 1 day optimizing the program and it will run \u230852\u2309=3 days. In total, he will spend 4 days and will fit in the limit.\nIn the third test case, it's impossible to fit in the limit. For example, if Adilbek will optimize the program 2 days, it'll still work \u2308112+1\u2309=4 days.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "ternary search",
            "*1100"
        ],
        "solutions": "1288A - DeadlineIdea: adedalic TutorialTutorial is loading... Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tint tt = clock();\n#endif\n\t\n\tint T; cin >> T;\n\twhile(T--) {\n\t\tint n, d;\n\t\tcin >> n >> d;\n\t\t\n\t\tint x, MAG = (int)sqrt(d) + 10;\n\t\tfor(x = 0; x < MAG; x++) {\n\t\t\tif(x + (d + x) / (x + 1) <= n)\n\t\t\t\tbreak;\n\t\t}\n\t\tcout << (x < MAG ? \"YES\" : \"NO\") << endl;\n\t}\n\n\treturn 0;\n}"
    },
    "1278A": {
        "title": "A. Shuffle Hashing",
        "description": "Polycarp has built his own web service. Being a modern web service it includes login feature. And that always implies password security problems.\nPolycarp decided to store the hash of the password, generated by the following algorithm:\nFor example, let the password p= \"abacaba\". Then p\u2032 can be equal to \"aabcaab\". Random strings s1= \"zyx\" and s2= \"kjh\". Then h= \"zyxaabcaabkjh\".\nNote that no letters could be deleted or added to p to obtain p\u2032, only the order could be changed.\nNow Polycarp asks you to help him to implement the password check module. Given the password p and the hash h, check that h can be the hash for the password p.\nYour program should answer t independent test cases.\nThe first line contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThe first line of each test case contains a non-empty string p, consisting of lowercase Latin letters. The length of p does not exceed 100.\nThe second line of each test case contains a non-empty string h, consisting of lowercase Latin letters. The length of h does not exceed 100.\nFor each test case print the answer to it \u2014 \"YES\" if the given hash h could be obtained from the given password p or \"NO\" otherwise.\nThe first test case is explained in the statement.\nIn the second test case both s1 and s2 are empty and p\u2032= \"threetwoone\" is p shuffled.\nIn the third test case the hash could not be obtained from the password.\nIn the fourth test case s1= \"n\", s2 is empty and p\u2032= \"one\" is p shuffled (even thought it stayed the same). \nIn the fifth test case the hash could not be obtained from the password.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1278A - Shuffle HashingThe general idea of the solution is to check that string h contains some substring which is a permutation of p. The constraints were so low you could do it with any algorithm, even O(n3logn) per test case could pass.The most straightforward way was to iterate over the substring of h, sort it and check if it's equal to p sorted. That's O(n3logn).Next you could notice than only substrings of length |p| matter and shave another n off the complexity to get O(n2logn).After that you might remember that the size of the alphabet is pretty low. And one string is a permutation of another one if the amounts of letters 'a', letters 'b' and so on in them are equal. So you can precalculate array cntp, where cntp[i] is equal to the amount of the i-th letter of the alphabet in p. Calculating this array for O(n) substrings will be O(n) each, so that makes it O(n2).Then notice how easy it is to recalculate the letter counts going from some substring [i;i+|p|\u22121] to [i+1;i+|p|]. Just subtract 1 from the amount of the i-th letter and add 1 to the amount of the (i+|p|)-th letter. Comparing two array every time will still lead to O(n\u22c5|AL|), though.The final optimization is to maintain the boolean array eq such that eqi means that cntp[i] is equal to the current value of cnt of the substring. You are updating just two values of cnt on each step, thus only two values of eq might change. You want all the |AL| values to be true, so keep the number of values true in that array and say \"YES\" if that number is equal to |AL|. That finally makes the solution O(n) per test case. Solution 1 (pikmike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nstring p, h;\n\nbool read(){\n\tif (!(cin >> p >> h))\n\t\treturn false;\n\treturn true;\n}\n\nvoid solve(){\n\tint n = h.size();\n\tvector<int> cntp(26);\n\tforn(i, p.size())\n\t\t++cntp[p[i] - 'a'];\n\tforn(i, n){\n\t\tvector<int> cnth(26);\n\t\tfor (int j = i; j < n; ++j){\n\t\t\t++cnth[h[j] - 'a'];\n\t\t\tif (cntp == cnth){\n\t\t\t\tputs(\"YES\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"NO\");\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(_, tc){\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n} Solution 2 (pikmike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\nconst int AL = 26;\nstring p, h;\n\nbool read(){\n\tif (!(cin >> p >> h))\n\t\treturn false;\n\treturn true;\n}\n\nvoid solve(){\n\tvector<int> cntp(AL), cnt(AL);\n\tvector<bool> eq(AL);\n\tint sum = 0;\n\t\n\tauto chg = [&cntp, &cnt, &eq, &sum](int c, int val){\n\t\tsum -= eq[c];\n\t\tcnt[c] += val;\n\t\teq[c] = (cntp[c] == cnt[c]);\n\t\tsum += eq[c];\n\t};\n\t\n\tforn(i, p.size())\n\t\t++cntp[p[i] - 'a'];\n\tforn(i, AL){\n\t\teq[i] = (cnt[i] == cntp[i]);\n\t\tsum += eq[i];\n\t}\n\t\n\tint m = p.size();\n\tint n = h.size();\n\tforn(i, n){\n\t\tchg(h[i] - 'a', 1);\n\t\tif (i >= m) chg(h[i - m] - 'a', -1);\n\t\tif (sum == AL){\n\t\t\tputs(\"YES\");\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tputs(\"NO\");\n}\n\nint main() {\n\tint tc;\n\tscanf(\"%d\", &tc);\n\tforn(_, tc){\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    },
    "1277B": {
        "title": "B. Make Them Odd",
        "description": "There are n positive integers a1,a2,\u2026,an. For the one move you can choose any even value c and divide by two all elements that equal c.\nFor example, if a=[6,8,12,6,3,12] and you choose c=6, and a is transformed into a=[3,8,12,3,3,12] after the move.\nYou need to find the minimal number of moves for transforming a to an array of only odd integers (each element shouldn't be divisible by 2).\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases in the input. Then t test cases follow.\nThe first line of a test case contains n (1\u2264n\u22642\u22c5105) \u2014 the number of integers in the sequence a. The second line contains positive integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nThe sum of n for all test cases in the input doesn't exceed 2\u22c5105.\nFor t test cases print the answers in the order of test cases in the input. The answer for the test case is the minimal number of moves needed to make all numbers in the test case odd (i.e. not divisible by 2).\nIn the first test case of the example, the optimal sequence of moves can be as follows:\nThus, all numbers became odd after 4 moves. In 3 or fewer moves, you cannot make them all odd.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "number theory",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1277A": {
        "title": "A. Happy Birthday, Polycarp!",
        "description": "Hooray! Polycarp turned n years old! The Technocup Team sincerely congratulates Polycarp!\nPolycarp celebrated all of his n birthdays: from the 1-th to the n-th. At the moment, he is wondering: how many times he turned beautiful number of years?\nAccording to Polycarp, a positive integer is beautiful if it consists of only one digit repeated one or more times. For example, the following numbers are beautiful: 1, 77, 777, 44 and 999999. The following numbers are not beautiful: 12, 11110, 6969 and 987654321.\nOf course, Polycarpus uses the decimal numeral system (i.e. radix is 10).\nHelp Polycarpus to find the number of numbers from 1 to n (inclusive) that are beautiful.\nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the input. Then t test cases follow.\nEach test case consists of one line, which contains a positive integer n (1\u2264n\u2264109) \u2014 how many years Polycarp has turned.\nPrint t integers \u2014 the answers to the given test cases in the order they are written in the test. Each answer is an integer: the number of beautiful years between 1 and n, inclusive.\nIn the first test case of the example beautiful years are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 11.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1272C": {
        "title": "C. Yet Another Broken Keyboard",
        "description": "Recently, Norge found a string s=s1s2\u2026sn consisting of n lowercase Latin letters. As an exercise to improve his typing speed, he decided to type all substrings of the string s. Yes, all n(n+1)2 of them!\nA substring of s is a non-empty string x=s[a\u2026b]=sasa+1\u2026sb (1\u2264a\u2264b\u2264n). For example, \"auto\" and \"ton\" are substrings of \"automaton\".\nShortly after the start of the exercise, Norge realized that his keyboard was broken, namely, he could use only k Latin letters c1,c2,\u2026,ck out of 26.\nAfter that, Norge became interested in how many substrings of the string s he could still type using his broken keyboard. Help him to find this number.\nThe first line contains two space-separated integers n and k (1\u2264n\u22642\u22c5105, 1\u2264k\u226426) \u2014 the length of the string s and the number of Latin letters still available on the keyboard.\nThe second line contains the string s consisting of exactly n lowercase Latin letters.\nThe third line contains k space-separated distinct lowercase Latin letters c1,c2,\u2026,ck \u2014 the letters still available on the keyboard.\nPrint a single number \u2014 the number of substrings of s that can be typed using only available letters c1,c2,\u2026,ck.\nIn the first example Norge can print substrings s[1\u20262], s[2\u20263], s[1\u20263], s[1\u20261], s[2\u20262], s[3\u20263], s[5\u20266], s[6\u20267], s[5\u20267], s[5\u20265], s[6\u20266], s[7\u20267].",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "implementation",
            "*1200"
        ],
        "solutions": "1272C - Yet Another Broken KeyboardLet's replace all characters of s with zeros and ones (zero if the character is unavailable and one otherwise). Then we have the binary string and we have to calculate the number of contiguous segments of this string consisting only of ones. It can be done with two pointers approach.If we are staying at the position i and its value is zero, just skip it. Otherwise, let's find the leftmost position j such that j>i and the j-th value is zero. Then we have to add to the answer the value (j\u2212i)\u22c5(j\u2212i+1)2 and set i:=j.Time complexity: O(n). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\tset<char> st;\n\tfor (int i = 0; i < k; ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\tst.insert(c);\n\t}\n\t\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint j = i;\n\t\twhile (j < n && st.count(s[j])) ++j;\n\t\tint len = j - i;\n\t\tans += len * 1ll * (len + 1) / 2;\n\t\ti = j;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
    },
    "1272B": {
        "title": "B. Snow Walking Robot",
        "description": "Recently you have bought a snow walking robot and brought it home. Suppose your home is a cell (0,0) on an infinite grid.\nYou also have the sequence of instructions of this robot. It is written as the string s consisting of characters 'L', 'R', 'U' and 'D'. If the robot is in the cell (x,y) right now, he can move to one of the adjacent cells (depending on the current instruction).\nYou've noticed the warning on the last page of the manual: if the robot visits some cell (except (0,0)) twice then it breaks.\nSo the sequence of instructions is valid if the robot starts in the cell (0,0), performs the given instructions, visits no cell other than (0,0) two or more times and ends the path in the cell (0,0). Also cell (0,0) should be visited at most two times: at the beginning and at the end (if the path is empty then it is visited only once). For example, the following sequences of instructions are considered valid: \"UD\", \"RL\", \"UUURULLDDDDLDDRRUU\", and the following are considered invalid: \"U\" (the endpoint is not (0,0)) and \"UUDD\" (the cell (0,1) is visited twice).\nThe initial sequence of instructions, however, might be not valid. You don't want your robot to break so you decided to reprogram it in the following way: you will remove some (possibly, all or none) instructions from the initial sequence of instructions, then rearrange the remaining instructions as you wish and turn on your robot to move. \nYour task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid. Report the valid sequence of the maximum length you can obtain.\nNote that you can choose any order of remaining instructions (you don't need to minimize the number of swaps or any other similar metric).\nYou have to answer q independent test cases.\nThe first line of the input contains one integer q (1\u2264q\u22642\u22c5104) \u2014 the number of test cases.\nThe next q lines contain test cases. The i-th test case is given as the string s consisting of at least 1 and no more than 105 characters 'L', 'R', 'U' and 'D' \u2014 the initial sequence of instructions.\nIt is guaranteed that the sum of |s| (where |s| is the length of s) does not exceed 105 over all test cases (\u2211|s|\u2264105).\nFor each test case print the answer on it. In the first line print the maximum number of remaining instructions. In the second line print the valid sequence of remaining instructions t the robot has to perform. The moves are performed from left to right in the order of the printed sequence. If there are several answers, you can print any. If the answer is 0, you are allowed to print an empty line (but you can don't print it).\nThere are only two possible answers in the first test case: \"LR\" and \"RL\".\nThe picture corresponding to the second test case:\nAnother correct answer to the third test case: \"URDDLLLUURDR\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1272B - Snow Walking Robot TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst string MOVES = \"LRUD\";\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tmap<char, int> cnt;\n\t\tfor (auto c : MOVES) cnt[c] = 0;\n\t\tfor (auto c : s) ++cnt[c];\n\t\tint v = min(cnt['U'], cnt['D']);\n\t\tint h = min(cnt['L'], cnt['R']);\n\t\tif (min(v, h) == 0) {\n\t\t\tif (v == 0) {\n\t\t\t\th = min(h, 1);\n\t\t\t\tcout << 2 * h << endl << string(h, 'L') + string(h, 'R') << endl;\n\t\t\t} else {\n\t\t\t\tv = min(v, 1);\n\t\t\t\tcout << 2 * v << endl << string(v, 'U') + string(v, 'D') << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tstring res;\n\t\t\tres += string(h, 'L');\n\t\t\tres += string(v, 'U');\n\t\t\tres += string(h, 'R');\n\t\t\tres += string(v, 'D');\n\t\t\tcout << res.size() << endl << res << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
    },
    "1270B": {
        "title": "B. Interesting Subarray",
        "description": "For an array a of integers let's denote its maximal element as max(a), and minimal as min(a). We will call an array a of k integers interesting if max(a)\u2212min(a)\u2265k. For example, array [1,3,4,3] isn't interesting as max(a)\u2212min(a)=4\u22121=3<4 while array [7,3,0,4,3] is as max(a)\u2212min(a)=7\u22120=7\u22655.\nYou are given an array a of n integers. Find some interesting nonempty subarray of a, or tell that it doesn't exist.\nAn array b is a subarray of an array a if b can be obtained from a by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. In particular, an array is a subarray of itself.\nThe first line contains integer number t (1\u2264t\u226410000). Then t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"NO\" in a separate line if there is no interesting nonempty subarray in a. \nOtherwise, output \"YES\" in a separate line. In the next line, output two integers l and r (1\u2264l\u2264r\u2264n)\u00a0\u2014 bounds of the chosen subarray. If there are multiple answers, print any.\nYou can print each letter in any case (upper or lower).\nIn the second test case of the example, one of the interesting subarrays is a=[2,0,1,9]: max(a)\u2212min(a)=9\u22120=9\u22654.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1266B": {
        "title": "B. Dice Tower",
        "description": "Bob is playing with 6-sided dice. A net of such standard cube is shown below.\n\nHe has an unlimited supply of these dice and wants to build a tower by stacking multiple dice on top of each other, while choosing the orientation of each dice. Then he counts the number of visible pips on the faces of the dice.\nFor example, the number of visible pips on the tower below is 29 \u2014 the number visible on the top is 1, from the south 5 and 3, from the west 4 and 2, from the north 2 and 4 and from the east 3 and 5.\n\nThe one at the bottom and the two sixes by which the dice are touching are not visible, so they are not counted towards total.\nBob also has t favourite integers xi, and for every such integer his goal is to build such a tower that the number of visible pips is exactly xi. For each of Bob's favourite integers determine whether it is possible to build a tower that has exactly that many visible pips.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of favourite integers of Bob. \nThe second line contains t space-separated integers xi (1\u2264xi\u22641018)\u00a0\u2014 Bob's favourite integers.\nFor each of Bob's favourite integers, output \"YES\" if it is possible to build the tower, or \"NO\" otherwise (quotes for clarity).\nThe first example is mentioned in the problem statement.\nIn the second example, one can build the tower by flipping the top dice from the previous tower.\nIn the third example, one can use a single die that has 5 on top.\nThe fourth example is impossible.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solutions": "1266B - Dice TowerConsider a die other than the top-most one. As the sum of numbers on the opposite faces of a die is always 7, the sum of numbers on the visible faces is always 14, regardless of its orientation.For the top-most die, the numbers on the sides also add up to 14, and there is an additional number on top of the die. The total number of visible pips is thus 14d+t, where d is the number of dice and t is the number on top. For a given x, compute t=xmod14 and d=\u230ax14\u230b. The answer is positive if and only if d\u22651 and 1\u2264t\u22646.  "
    },
    "1266A": {
        "title": "A. Competitive Programmer",
        "description": "Bob is a competitive programmer. He wants to become red, and for that he needs a strict training regime. He went to the annual meeting of grandmasters and asked n of them how much effort they needed to reach red.\n\"Oh, I just spent xi hours solving problems\", said the i-th of them. \nBob wants to train his math skills, so for each answer he wrote down the number of minutes (60\u22c5xi), thanked the grandmasters and went home. Bob could write numbers with leading zeroes \u2014 for example, if some grandmaster answered that he had spent 2 hours, Bob could write 000120 instead of 120.\nAlice wanted to tease Bob and so she took the numbers Bob wrote down, and for each of them she did one of the following independently: \nThis way, Alice generated n numbers, denoted y1, ..., yn.\nFor each of the numbers, help Bob determine whether yi can be a permutation of a number divisible by 60 (possibly with leading zeroes).\nThe first line contains a single integer n (1\u2264n\u2264418)\u00a0\u2014 the number of grandmasters Bob asked.\nThen n lines follow, the i-th of which contains a single integer yi\u00a0\u2014 the number that Alice wrote down.\nEach of these numbers has between 2 and 100 digits '0' through '9'. They can contain leading zeroes.\nOutput n lines.\nFor each i, output the following. If it is possible to rearrange the digits of yi such that the resulting number is divisible by 60, output \"red\" (quotes for clarity). Otherwise, output \"cyan\".\nIn the first example, there is one rearrangement that yields a number divisible by 60, and that is 360.\nIn the second example, there are two solutions. One is 060 and the second is 600.\nIn the third example, there are 6 possible rearrangments: 025, 052, 205, 250, 502, 520. None of these numbers is divisible by 60.\nIn the fourth example, there are 3 rearrangements: 228, 282, 822.\nIn the fifth example, none of the 24 rearrangements result in a number divisible by 60.\nIn the sixth example, note that 000\u20260 is a valid solution.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "chinese remainder theorem",
            "math",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1265A": {
        "title": "A. Beautiful String",
        "description": "A string is called beautiful if no two consecutive characters are equal. For example, \"ababcb\", \"a\" and \"abab\" are beautiful strings, while \"aaaaaa\", \"abaa\" and \"bb\" are not.\nAhcl wants to construct a beautiful string. He has a string s, consisting of only characters 'a', 'b', 'c' and '?'. Ahcl needs to replace each character '?' with one of the three characters 'a', 'b' or 'c', such that the resulting string is beautiful. Please help him!\nMore formally, after replacing all characters '?', the condition si\u2260si+1 should be satisfied for all 1\u2264i\u2264|s|\u22121, where |s| is the length of the string s.\nThe first line contains positive integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Next t lines contain the descriptions of test cases.\nEach line contains a non-empty string s consisting of only characters 'a', 'b', 'c' and '?'. \nIt is guaranteed that in each test case a string s has at least one character '?'. The sum of lengths of strings s in all test cases does not exceed 105.\nFor each test case given in the input print the answer in the following format:\nIn the first test case, all possible correct answers are \"ababcb\", \"abcacb\", \"abcbcb\", \"acabcb\" and \"acbacb\". The two answers \"abcbab\" and \"abaabc\" are incorrect, because you can replace only '?' characters and the resulting string must be beautiful.\nIn the second test case, it is impossible to create a beautiful string, because the 4-th and 5-th characters will be always equal.\nIn the third test case, the only answer is \"acbac\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solutions": "1265A - Beautiful StringIf string s initially contains 2 equal consecutive letters (\"aa\", \"bb\" or \"cc\") then the answer is obviously -1. Otherwise, it is always possible to replacing all characters '?' to make s beautiful. We will replacing one '?' at a time and in any order (from left to right for example). For each '?', since it is adjacent to at most 2 other characters and we have 3 options ('a', 'b' and 'c') for this '?', there always exists at least one option which differ from 2 characters that are adjacent with this '?'. Simply find one and replace '?' by it.Time comlexity: O(n) where n is length of s. Python SolutionT = int(input())\nfor tc in range(T):\n    s = [c for c in input()]\n    n = len(s)\n    i = 0\n    while (i < n):\n        if (s[i] == '?'):\n            prv = 'd' if i == 0 else s[i - 1]\n            nxt = 'e' if i + 1 >= n else s[i + 1]\n            for x in ['a', 'b', 'c']:\n                if (x != prv) and (x != nxt):\n                    s[i] = x\n                    break\n        else:\n            i += 1\n           \n    ok = True \n    for i in range(n - 1):\n        if (s[i] == s[i + 1]):\n            print(\"-1\")\n            ok = False\n            break\n    if (ok == True):  \n        print(\"\".join(s))Author: isaf27, prepare laoriu, I_love_Hoang_Yen "
    },
    "1263A": {
        "title": "A. Sweet Problem",
        "description": "You have three piles of candies: red, green and blue candies:\nEach day Tanya eats exactly two candies of different colors. She is free to choose the colors of eaten candies: the only restriction that she can't eat two candies of the same color in a day.\nFind the maximal number of days Tanya can eat candies? Each day she needs to eat exactly two candies.\nThe first line contains integer t (1\u2264t\u22641000) \u2014 the number of test cases in the input. Then t test cases follow.\nEach test case is given as a separate line of the input. It contains three integers r, g and b (1\u2264r,g,b\u2264108) \u2014 the number of red, green and blue candies, respectively.\nPrint t integers: the i-th printed integer is the answer on the i-th test case in the input.\nIn the first example, Tanya can eat candies for one day only. She can eat any pair of candies this day because all of them have different colors.\nIn the second example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and green and blue candies on the second day.\nIn the third example, Tanya can eat candies for two days. For example, she can eat red and green candies on the first day, and red and blue candies on the second day. Note, that two red candies will remain uneaten.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1263A - Sweet ProblemSort the values of r, g, b such that r\u2265g\u2265b. Now consider two cases.If r\u2265g+b, then Tanya can take g candies from piles r and g, and then\u00a0\u2014 b candies from piles r and b. After that there may be a bunch of candies left in the pile r that Tanya won't be able to eat, so the answer is g+b.Otherwise, we need to achieve the equality of the piles r, g, b. First, we make equal r and g by eating r\u2212g from the piles r and b (this can always be done since r<g+b). Then we make equal the piles g, b by eating g\u2212b from the piles r and g. After that, r=g=b, and we can get three different cases.  r=g=b=0\u00a0\u2014 nothing needs to be done, Tanya has already eaten all the sweets;  r=g=b=1\u00a0\u2014 you can take candy from any of two piles so in the end there will always be one candy left;  r=g=b\u22652\u00a0\u2014 we reduce all the piles by 2, taking, for example, a candy from piles r and g, g and b, r and b. With such actions, Tanya eventually reaches the two previous cases, since the sizes of the piles are reduced by 2. Since with this strategy we always have 0 or 1 candy at the end, Tanya will be able to eat candies for \u230ar+g+b2\u230b days. Solution (MikeMirzayanov)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {   \n        int a[3];\n        cin >> a[0] >> a[1] >> a[2];\n        sort(a, a + 3);\n        if (a[2] <= a[0] + a[1])\n            cout << (a[0] + a[1] + a[2]) / 2 << endl;\n        else\n            cout << a[0] + a[1] << endl;\n    }\n}"
    },
    "1260A": {
        "title": "A. Heating",
        "description": "Several days ago you bought a new house and now you are planning to start a renovation. Since winters in your region can be very cold you need to decide how to heat rooms in your house.\nYour house has n rooms. In the i-th room you can install at most ci heating radiators. Each radiator can have several sections, but the cost of the radiator with k sections is equal to k2 burles.\nSince rooms can have different sizes, you calculated that you need at least sumi sections in total in the i-th room. \nFor each room calculate the minimum cost to install at most ci radiators with total number of sections not less than sumi.\nThe first line contains single integer n (1\u2264n\u22641000) \u2014 the number of rooms.\nEach of the next n lines contains the description of some room. The i-th line contains two integers ci and sumi (1\u2264ci,sumi\u2264104) \u2014 the maximum number of radiators and the minimum total number of sections in the i-th room, respectively.\nFor each room print one integer \u2014 the minimum possible cost to install at most ci radiators with total number of sections not less than sumi.\nIn the first room, you can install only one radiator, so it's optimal to use the radiator with sum1 sections. The cost of the radiator is equal to (104)2=108.\nIn the second room, you can install up to 104 radiators, but since you need only one section in total, it's optimal to buy one radiator with one section.\nIn the third room, there 7 variants to install radiators: [6,0], [5,1], [4,2], [3,3], [2,4], [1,5], [0,6]. The optimal variant is [3,3] and it costs 32+32=18.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1260A - HeatingLet's denote the number of sections in the i-th radiator as xi. Let's prove that in the optimal answer max(xi)\u2212min(xi)<2. Proof by contradiction: suppose we have x and y\u2265x+2 in the answer, let's move 1 from y to x and check: (x+1)2+(y\u22121)2=x2+2x+1+y2\u22122y+1=(x2+y2)+2(x\u2212y+1)<x2+y2 The answer is not optimal \u2014 contradiction.Finally, there is the only way to take x1+x2+\u22ef+xc=sum with max(xi)\u2212min(xi)\u22641. And it's to take (summodc) elements with value \u230asumc\u230b+1 and c\u2212(summodc) elements with \u230asumc\u230b. Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\nint c, sum;\n\ninline bool read() {\n\tif(!(cin >> c >> sum))\n\t\treturn false;\n\treturn true;\n}\n\ninline void solve() {\n\tint d = sum / c;\n\tint rem = sum % c;\n\tcout << rem * (d + 1) * (d + 1) + (c - rem) * d * d << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; cin >> n;\n\twhile(n--) {\n\t\tread();\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    },
    "1257C": {
        "title": "C. Dominated Subarray",
        "description": "Let's call an array t dominated by value v in the next situation.\nAt first, array t should have at least 2 elements. Now, let's calculate number of occurrences of each number num in t and define it as occ(num). Then t is dominated (by v) if (and only if) occ(v)>occ(v\u2032) for any other number v\u2032. For example, arrays [1,2,3,4,5,2], [11,11] and [3,2,3,2,3] are dominated (by 2, 11 and 3 respectevitely) but arrays [3], [1,2] and [3,3,2,2,1] are not.\nSmall remark: since any array can be dominated only by one number, we can not specify this number and just say that array is either dominated or not.\nYou are given array a1,a2,\u2026,an. Calculate its shortest dominated subarray or say that there are no such subarrays.\nThe subarray of a is a contiguous part of the array a, i.\u2009e. the array ai,ai+1,\u2026,aj for some 1\u2264i\u2264j\u2264n.\nThe first line contains single integer T (1\u2264T\u22641000) \u2014 the number of test cases. Each test case consists of two lines.\nThe first line contains single integer n (1\u2264n\u22642\u22c5105) \u2014 the length of the array a.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the corresponding values of the array a.\nIt's guaranteed that the total length of all arrays in one test doesn't exceed 2\u22c5105.\nPrint T integers \u2014 one per test case. For each test case print the only integer \u2014 the length of the shortest dominated subarray, or \u22121 if there are no such subarrays.\nIn the first test case, there are no subarrays of length at least 2, so the answer is \u22121.\nIn the second test case, the whole array is dominated (by 1) and it's the only dominated subarray.\nIn the third test case, the subarray a4,a5,a6 is the shortest dominated subarray.\nIn the fourth test case, all subarrays of length more than one are dominated.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "strings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1257C - Dominated SubarrayAt first, let's prove that the shortest dominated subarray has pattern like v,c1,c2,\u2026,ck,v with k\u22650 and dominated by value v. Otherwise, we can decrease its length by erasing an element from one of its ends which isn't equal to v and it'd still be dominated.Now we should go over all pairs of the same numbers and check its subarrays... Or not? Let's look closely at the pattern: if v and all ci are pairwise distinct then the pattern is dominated subarray itself. Otherwise, we can find in our pattern other shorter pattern and either the found pattern is dominated or it has the pattern inside it and so on.What does it mean? It means that the answer is just the shortest pattern we can find. And all we need to find is the shortest subarray with the same first and last elements or just distance between two consecutive occurrences of each number. We can do it by iterating over current position i and keeping track of the last occurrence of each number in some array lst[v]. Then the current distance is i\u2212lst[a[i]]+1.The total complexity is O(n). Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\n#define sz(a) int((a).size())\n\nint n;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\treturn true;\n}\n\ninline void solve() {\n\tint ans = n + 5;\n\tvector<int> lst(n + 1, -1);\n\tfor(int i = 0; i < n; i++) {\n\t\tif(lst[a[i]] != -1)\n\t\t\tans = min(ans, i - lst[a[i]] + 1);\n\t\tlst[a[i]] = i;\n\t}\n\tif(ans > n)\n\t\tans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(15);\n\t\n\tint tc; cin >> tc;\n\twhile(tc--) {\n\t\tassert(read());\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    },
    "1257B": {
        "title": "B. Magic Stick",
        "description": "Recently Petya walked in the forest and found a magic stick.\nSince Petya really likes numbers, the first thing he learned was spells for changing numbers. So far, he knows only two spells that can be applied to a positive integer: \nNote that if the number is even and greater than one, then Petya can choose which spell to apply.\nPetya now has only one number x. He wants to know if his favorite number y can be obtained from x using the spells he knows. The spells can be used any number of times in any order. It is not required to use spells, Petya can leave x as it is.\nThe first line contains single integer T (1\u2264T\u2264104) \u2014 the number of test cases. Each test case consists of two lines.\nThe first line of each test case contains two integers x and y (1\u2264x,y\u2264109) \u2014 the current number and the number that Petya wants to get.\nFor the i-th test case print the answer on it \u2014 YES if Petya can get the number y from the number x using known spells, and NO otherwise.\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1257B - \u0412\u043e\u043b\u0448\u0435\u0431\u043d\u0430\u044f \u043f\u0430\u043b\u043e\u0447\u043a\u0430Idea: BledDest TutorialTutorial is loading... Solution (Ne0n25)#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid solve() {\n\tint x, y;\n\tcin >> x >> y;\n\t\n\tif (x > 3) puts(\"YES\");\n\telse if (x == 1) puts(y == 1 ? \"YES\" : \"NO\");\n\telse puts(y <= 3 ? \"YES\" : \"NO\");\n}\n\nint main() {\n\tint tc;\n\tcin >> tc;\n\twhile (tc--) solve();\n}"
    },
    "1256A": {
        "title": "A. Payment Without Change",
        "description": "You have a coins of value n and b coins of value 1. You always pay in exact change, so you want to know if there exist such x and y that if you take x (0\u2264x\u2264a) coins of value n and y (0\u2264y\u2264b) coins of value 1, then the total value of taken coins will be S.\nYou have to answer q independent test cases.\nThe first line of the input contains one integer q (1\u2264q\u2264104) \u2014 the number of test cases. Then q test cases follow.\nThe only line of the test case contains four integers a, b, n and S (1\u2264a,b,n,S\u2264109) \u2014 the number of coins of value n, the number of coins of value 1, the value n and the required total value.\nFor the i-th test case print the answer on it \u2014 YES (without quotes) if there exist such x and y that if you take x coins of value n and y coins of value 1, then the total value of taken coins will be S, and NO otherwise.\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1256A - Payment Without ChangeFirstly, we obviously need to take at least S%n coins of value 1. If we cannot do it, the answer it NO. Otherwise we always can obtain the required sum S if a\u22c5n+b\u2265S. Solution#include <iostream>\n\nusing namespace std;\n\nint main() {\n\tint q;\n\tcin >> q;\n\n\tfor (int qr = 0; qr < q; ++qr) {\n\t\tint a, b, n, s;\n\t\tcin >> a >> b >> n >> s;\n\n\t\tif (s % n <= b && 1ll * a * n + b >= s) {\n\t\t\tcout << \"YES\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"NO\\n\";\n\t\t}\n\t}\n}"
    },
    "1255B": {
        "title": "B. Fridge Lockers",
        "description": "Hanh lives in a shared apartment. There are n people (including Hanh) living there, each has a private fridge. \nn fridges are secured by several steel chains. Each steel chain connects two different fridges and is protected by a digital lock. The owner of a fridge knows passcodes of all chains connected to it. A fridge can be open only if all chains connected to it are unlocked. For example, if a fridge has no chains connected to it at all, then any of n people can open it.\nThe weights of these fridges are a1,a2,\u2026,an. To make a steel chain connecting fridges u and v, you have to pay au+av dollars. Note that the landlord allows you to create multiple chains connecting the same pair of fridges. \nHanh's apartment landlord asks you to create exactly m steel chains so that all fridges are private. A fridge is private if and only if, among n people living in the apartment, only the owner can open it (i.e. no other person acting alone can do it). In other words, the fridge i is not private if there exists the person j (i\u2260j) that the person j can open the fridge i.\nFor example, in the picture all the fridges are private. On the other hand, if there are n=2 fridges and only one chain (which connects them) then both fridges are not private (both fridges can be open not only by its owner but also by another person).\nOf course, the landlord wants to minimize the total cost of all steel chains to fulfill his request. Determine whether there exists any way to make exactly m chains, and if yes, output any solution that minimizes the total cost. \nEach test contains multiple test cases. The first line contains the number of test cases T (1\u2264T\u226410). Then the descriptions of the test cases follow.\nThe first line of each test case contains two integers n, m (2\u2264n\u22641000, 1\u2264m\u2264n)\u00a0\u2014 the number of people living in Hanh's apartment and the number of steel chains that the landlord requires, respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264104)\u00a0\u2014 weights of all fridges.\nFor each test case:\nIf there are multiple answers, print any.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "graphs",
            "implementation",
            "*1100"
        ],
        "solutions": "1255B - Fridge LockersAuthor: I_love_tigersugar ft. MikeMirzayanov. Prepared by UncleGrandpa TutorialModelize the problemWe modelize the problem as graph, where each fridge is a vertex and each chain is an edge between two vertexes. The problem is now equivalent to: Given a graph with n vertexes, each vertex has a value ai\u22650. We have to add m edges to the graph such that each vertex is connected to at least two different vertexes and the total cost of edges added is minimum. The cost of an edge is the sum of value of its two end-points. Observe some basic properties of graphNow, each edge added will increase the sum of degree of all vertexes by 2. So adding m edges will make the sum of degree equal to 2\u00d7m. Since each vertexes must be connected to at least 2 other vertexes, the minimum sum of degree is 2\u00d7n.  Case 1: 2\u00d7m<2\u00d7n\u21d4m<n In this case, it is obvious that the answer is \u22121.  Case 2: 2\u00d7m=2\u00d7n\u21d4m=n In this case, it is easy to see that the degree of each vertex will be exactly 2. As a result, no matter what edges we add, the result is still 2\u00d7(a1+a2+...+an). But please take note that if n=2, then the answer will be \u22121 since for each vertex we have at most 1 different vertex to connect to.   Case 3(Of the original, pre-modified version of the problem): 2\u00d7m>2\u00d7n\u21d4m>n Please read this excellent answer by Um_nik. All credit goes to him for the excellent proof. "
    },
    "1253A": {
        "title": "A. Single Push",
        "description": "You're given two arrays a[1\u2026n] and b[1\u2026n], both of the same length n.\nIn order to perform a push operation, you have to choose three integers l,r,k satisfying 1\u2264l\u2264r\u2264n and k>0. Then, you will add k to elements al,al+1,\u2026,ar.\nFor example, if a=[3,7,1,4,1,2] and you choose (l=3,r=5,k=2), the array a will become [3,7,3,6,3_,2].\nYou can do this operation at most once. Can you make array a equal to array b?\n(We consider that a=b if and only if, for every 1\u2264i\u2264n, ai=bi)\nThe first line contains a single integer t (1\u2264t\u226420) \u2014 the number of test cases in the input.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100\u00a0000) \u2014 the number of elements in each array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641000).\nThe third line of each test case contains n integers b1,b2,\u2026,bn (1\u2264bi\u22641000).\nIt is guaranteed that the sum of n over all test cases doesn't exceed 105.\nFor each test case, output one line containing \"YES\" if it's possible to make arrays a and b equal by performing at most once the described operation or \"NO\" if it's impossible.\nYou can print each letter in any case (upper or lower).\nThe first test case is described in the statement: we can perform a push operation with parameters (l=3,r=5,k=2) to make a equal to b.\nIn the second test case, we would need at least two operations to make a equal to b.\nIn the third test case, arrays a and b are already equal.\nIn the fourth test case, it's impossible to make a equal to b, because the integer k has to be positive.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1253A - Single PushIf we set di=bi\u2212ai, we have to check that d has the following form: [0,0,\u2026,0,k,k,\u2026,k,0,0,\u2026,0]. Firstly check that there is no negative element in d.Solution 1 : add 0 to the beginning and the end of the array d, then check that there is at most two indices i such that di\u2260di+1.Solution 2 : let l be the smallest integer such that dl\u22600, and r be the greatest integer such that dr\u22600. Check that for all l\u2264i\u2264r, di=dl.Complexity : O(n) for each test case.Implementation (solution 1) "
    },
    "1252A": {
        "title": "A. Copying Homework",
        "description": "Danang and Darto are classmates. They are given homework to create a permutation of N integers from 1 to N. Danang has completed the homework and created a permutation A of N integers. Darto wants to copy Danang's homework, but Danang asks Darto to change it up a bit so it does not look obvious that Darto copied.\nThe difference of two permutations of N integers A and B, denoted by diff(A,B), is the sum of the absolute difference of Ai and Bi for all i. In other words, diff(A,B)=\u03a3Ni=1|Ai\u2212Bi|. Darto would like to create a permutation of N integers that maximizes its difference with A. Formally, he wants to find a permutation of N integers Bmax such that diff(A,Bmax)\u2265diff(A,B\u2032) for all permutation of N integers B\u2032.\nDarto needs your help! Since the teacher giving the homework is lenient, any permutation of N integers B is considered different with A if the difference of A and B is at least N. Therefore, you are allowed to return any permutation of N integers B such that diff(A,B)\u2265N.\nOf course, you can still return Bmax if you want, since it can be proven that diff(A,Bmax)\u2265N for any permutation A and N>1. This also proves that there exists a solution for any permutation of N integers A. If there is more than one valid solution, you can output any of them.\nInput begins with a line containing an integer: N (2\u2264N\u2264100000) representing the size of Danang's permutation. The next line contains N integers: Ai (1\u2264Ai\u2264N) representing Danang's permutation. It is guaranteed that all elements in A are distinct.\nOutput in a line N integers (each separated by a single space) representing the permutation of N integers B such that diff(A,B)\u2265N. As a reminder, all elements in the permutation must be between 1 to N and distinct.\nExplanation for the sample input/output #1\nWith A=[1,3,2,4] and B=[4,2,3,1], diff(A,B)=|1\u22124|+|3\u22122|+|2\u22123|+|4\u22121|=3+1+1+3=8. Since 8\u22654, [4,2,3,1] is one of the valid output for this sample.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1251A": {
        "title": "A. Broken Keyboard",
        "description": "Recently Polycarp noticed that some of the buttons of his keyboard are malfunctioning. For simplicity, we assume that Polycarp's keyboard contains 26 buttons (one for each letter of the Latin alphabet). Each button is either working fine or malfunctioning. \nTo check which buttons need replacement, Polycarp pressed some buttons in sequence, and a string s appeared on the screen. When Polycarp presses a button with character c, one of the following events happened:\nFor example, suppose the buttons corresponding to characters a and c are working correctly, and the button corresponding to b is malfunctioning. If Polycarp presses the buttons in the order a, b, a, c, a, b, a, then the string he is typing changes as follows: a \u2192 abb \u2192 abba \u2192 abbac \u2192 abbaca \u2192 abbacabb \u2192 abbacabba.\nYou are given a string s which appeared on the screen after Polycarp pressed some buttons. Help Polycarp to determine which buttons are working correctly for sure (that is, this string could not appear on the screen if any of these buttons was malfunctioning).\nYou may assume that the buttons don't start malfunctioning when Polycarp types the string: each button either works correctly throughout the whole process, or malfunctions throughout the whole process.\nThe first line contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases in the input.\nThen the test cases follow. Each test case is represented by one line containing a string s consisting of no less than 1 and no more than 500 lowercase Latin letters.\nFor each test case, print one line containing a string res. The string res should contain all characters which correspond to buttons that work correctly in alphabetical order, without any separators or repetitions. If all buttons may malfunction, res should be empty.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "two pointers",
            "*1000"
        ],
        "solutions": "1251A - Broken KeyboardIf a key malfunctions, each sequence of presses of this key gives a string with even number of characters. So, if there is a substring consisting of odd number of equal characters c, such that it cannot be extended to the left or to the right without adding other characters, then it could not be produced by presses of button c if c was malfunctioning.The only thing that's left is to find all maximal by inclusion substrings consisting of the same character. Solution (Ne0n25)#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool ans[26];\n\nvoid solve() {\n\tstring s;\n\tcin >> s;\n\t\n\tmemset(ans, 0, sizeof(ans));\n\t\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tint j = i;\n\t\twhile (j + 1 < s.size() && s[j + 1] == s[i])\n\t\t\tj++;\n\t\tif ((j - i) % 2 == 0)\n\t\t\tans[s[i] - 'a'] = true;\n\t\ti = j;\n\t}\n\t\n\tfor (int i = 0; i < 26; i++) if (ans[i])\n\t\tcout << char('a' + i);\n\tcout << endl;\n}\n\nint main() {\n\tint q;\n\tcin >> q;\n\twhile (q--) solve();\n}"
    },
    "1249B1": {
        "title": "B1. Books Exchange (easy version)",
        "description": "The only difference between easy and hard versions is constraints.\nThere are n kids, each of them is reading a unique book. At the end of any day, the i-th kid will give his book to the pi-th kid (in case of i=pi the kid will give his book to himself). It is guaranteed that all values of pi are distinct integers from 1 to n (i.e. p is a permutation). The sequence p doesn't change from day to day, it is fixed.\nFor example, if n=6 and p=[4,6,1,3,5,2] then at the end of the first day the book of the 1-st kid will belong to the 4-th kid, the 2-nd kid will belong to the 6-th kid and so on. At the end of the second day the book of the 1-st kid will belong to the 3-th kid, the 2-nd kid will belong to the 2-th kid and so on.\nYour task is to determine the number of the day the book of the i-th child is returned back to him for the first time for every i from 1 to n.\nConsider the following example: p=[5,1,2,4,3]. The book of the 1-st kid will be passed to the following kids:\nSo after the fourth day, the book of the first kid will return to its owner. The book of the fourth kid will return to him for the first time after exactly one day.\nYou have to answer q independent queries.\nThe first line of the input contains one integer q (1\u2264q\u2264200) \u2014 the number of queries. Then q queries follow.\nThe first line of the query contains one integer n (1\u2264n\u2264200) \u2014 the number of kids in the query. The second line of the query contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n, all pi are distinct, i.e. p is a permutation), where pi is the kid which will get the book of the i-th kid.\nFor each query, print the answer on it: n integers a1,a2,\u2026,an, where ai is the number of the day the book of the i-th child is returned back to him for the first time in this query.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dsu",
            "math",
            "*1000"
        ],
        "solutions": "1249B1 - Books Exchange (easy version)In this problem you just need to implement what is written in the problem statement. For the kid i the following pseudocode will calculate the answer (indices of the array p and its values are 0-indexed):pos = p[i]ans = 1while pos != i:    ans += 1    pos = p[pos] Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> p(n);\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> p[j];\n\t\t\t--p[j];\n\t\t}\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tint cnt = 0;\n\t\t\tint k = j;\n\t\t\tdo {\n\t\t\t\t++cnt;\n\t\t\t\tk = p[k];\n\t\t\t} while (k != j);\n\t\t\tcout << cnt << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1248A": {
        "title": "A. Integer Points",
        "description": "DLS and JLS are bored with a Math lesson. In order to entertain themselves, DLS took a sheet of paper and drew n distinct lines, given by equations y=x+pi for some distinct p1,p2,\u2026,pn.\nThen JLS drew on the same paper sheet m distinct lines given by equations y=\u2212x+qi for some distinct q1,q2,\u2026,qm.\nDLS and JLS are interested in counting how many line pairs have integer intersection points, i.e. points with both coordinates that are integers. Unfortunately, the lesson will end up soon, so DLS and JLS are asking for your help.\nThe first line contains one integer t (1\u2264t\u22641000), the number of test cases in the input. Then follow the test case descriptions.\nThe first line of a test case contains an integer n (1\u2264n\u2264105), the number of lines drawn by DLS.\nThe second line of a test case contains n distinct integers pi (0\u2264pi\u2264109) describing the lines drawn by DLS. The integer pi describes a line given by the equation y=x+pi.\nThe third line of a test case contains an integer m (1\u2264m\u2264105), the number of lines drawn by JLS.\nThe fourth line of a test case contains m distinct integers qi (0\u2264qi\u2264109) describing the lines drawn by JLS. The integer qi describes a line given by the equation y=\u2212x+qi.\nThe sum of the values of n over all test cases in the input does not exceed 105. Similarly, the sum of the values of m over all test cases in the input does not exceed 105.\nIn hacks it is allowed to use only one test case in the input, so t=1 should be satisfied.\nFor each test case in the input print a single integer\u00a0\u2014 the number of line pairs with integer intersection points. \nThe picture shows the lines from the first test case of the example. Black circles denote intersection points with integer coordinates.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "geometry",
            "math",
            "*1000"
        ],
        "solutions": "1248A - Integer Points was authored by voidmax and prepared by vintage_Vlad_Makeev."
    },
    "1245B": {
        "title": "B. Restricted RPS",
        "description": "Let n be a positive integer. Let a,b,c be nonnegative integers such that a+b+c=n.\nAlice and Bob are gonna play rock-paper-scissors n times. Alice knows the sequences of hands that Bob will play. However, Alice has to play rock a times, paper b times, and scissors c times.\nAlice wins if she beats Bob in at least \u2308n2\u2309 (n2 rounded up to the nearest integer) hands, otherwise Alice loses.\nNote that in rock-paper-scissors:\nThe task is, given the sequence of hands that Bob will play, and the numbers a,b,c, determine whether or not Alice can win. And if so, find any possible sequence of hands that Alice can use to win.\nIf there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThen, t testcases follow, each consisting of three lines: \nFor each testcase: \nThe \"YES\" / \"NO\" part of the output is case-insensitive (i.e. \"yEs\", \"no\" or \"YEs\" are all valid answers). Note that 'R', 'P' and 'S' are case-sensitive.\nIn the first testcase, in the first hand, Alice plays paper and Bob plays rock, so Alice beats Bob. In the second hand, Alice plays scissors and Bob plays paper, so Alice beats Bob. In the third hand, Alice plays rock and Bob plays scissors, so Alice beats Bob. Alice beat Bob 3 times, and 3\u2265\u230832\u2309=2, so Alice wins.\nIn the second testcase, the only sequence of hands that Alice can play is \"RRR\". Alice beats Bob only in the last hand, so Alice can't win. 1<\u230832\u2309=2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "*1200"
        ],
        "solutions": "1245B - Restricted RPSLet A, B, C be the number of rocks, papers, and scissors in Bob's sequence, respectively. It is easy to see that Alice can win at most w:=min(A,b)+min(B,c)+min(C,a) hands.So if 2w<n, Alice can't win.Otherwise, Alice can always win. One way to construct a winning sequence of hands for Alice is as follows:   Create a sequence of length n.   For Bob's first min(A,b) rock hands, put a paper hand in the corresponding position in our sequence.   For Bob's first min(B,c) paper hands, put a scissors hand in the corresponding position in our sequence.   For Bob's first min(C,a) scissors hands, put a rock hand in the corresponding position in our sequence.   Just fill in the other elements of the sequence by the remaining hands that Alice has. By construction, Alice uses exactly a rock hands, b paper hands, and c scissors hands. Also, Alice beats Bob exactly w times. Since 2w\u2265n, Alice wins. Solution#include <vector>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int q;\n    for (cin >> q; q--;)\n    {\n        int n;\n        cin >> n;\n        int a, b, c;\n        cin >> a >> b >> c;\n        string s;\n        cin >> s;\n        \n        vector<int> count(26);\n        for (char x : s)\n        \tcount[x - 'A']++;\n        \n        int wins = min(a, count['S' - 'A']) + min(b, count['R' - 'A']) + min(c, count['P' - 'A']);\n        \n        if (2 * wins < n)\n        {\n        \tcout << \"NO\" << '\\n';continue;\n        }\n        \n        cout << \"YES\" << '\\n';\n        string t;\n        for (int i = 0; i != n; ++i)\n        {\n        \tif (s[i] == 'S' && a)\n        \t{\n        \t\tt += 'R';\n        \t\ta--;\n        \t}\n        \telse if (s[i] == 'R' && b)\n        \t{\n        \t\tt += 'P';\n        \t\tb--;\n        \t}\n        \telse if (s[i] == 'P' && c)\n        \t{\n        \t\tt += 'S';\n        \t\tc--;\n        \t}\n        \telse\n        \t\tt += '_';\n        }\n        for (int i = 0; i != n; ++i)\n        {\n        \tif (t[i] != '_')\n        \t\tcontinue;\n        \t\n        \tif (a)\n        \t{\n        \t\tt[i] = 'R';\n        \t\ta--;\n        \t}\n        \telse if (b)\n        \t{\n        \t\tt[i] = 'P';\n        \t\tb--;\n        \t}\n        \telse\n        \t{\n        \t\tt[i] = 'S';\n        \t\tc--;\n        \t}\n        }\n        cout << t << '\\n';\n    }\n    \n    return 0;\n}"
    },
    "1245A": {
        "title": "A. Good ol' Numbers Coloring",
        "description": "Consider the set of all nonnegative integers: 0,1,2,\u2026. Given two integers a and b (1\u2264a,b\u2264104). We paint all the numbers in increasing number first we paint 0, then we paint 1, then 2 and so on.\nEach number is painted white or black. We paint a number i according to the following rules: \nIn this way, each nonnegative integer gets one of two colors.\nFor example, if a=3, b=5, then the colors of the numbers (in the order from 0) are: white (0), black (1), black (2), white (3), black (4), white (5), white (6), black (7), white (8), white (9), ...\nNote that: \nYour task is to determine whether or not the number of nonnegative integers colored black is infinite.\nIf there are infinitely many nonnegative integers colored black, simply print a line containing \"Infinite\" (without the quotes). Otherwise, print \"Finite\" (without the quotes).\nThe first line of input contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases in the input. Then t lines follow, each line contains two space-separated integers a and b (1\u2264a,b\u2264104).\nFor each test case, print one line containing either \"Infinite\" or \"Finite\" (without the quotes). Output is case-insensitive (i.e. \"infinite\", \"inFiNite\" or \"finiTE\" are all valid answers).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1245A - Good ol' Numbers Coloring TutorialTutorial is loading... Solution#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (b)\n    {\n        a %= b;\n        swap(a, b);\n    }\n    \n    return a;\n}\n\nint main()\n{\n    int t;\n    for (cin >> t; t--;)\n    \n    {\n        int a, b;\n        cin >> a >> b;\n        \n        if (gcd(a, b) == 1)\n            cout << \"Finite\" << '\\n';\n        else\n            cout << \"Infinite\" << '\\n';\n    }\n    \n    return 0;\n}"
    },
    "1244B": {
        "title": "B. Rooms and Staircases",
        "description": "Nikolay lives in a two-storied house. There are n rooms on each floor, arranged in a row and numbered from one from left to right. So each room can be represented by the number of the floor and the number of the room on this floor (room number is an integer between 1 and n). \nIf Nikolay is currently in some room, he can move to any of the neighbouring rooms (if they exist). Rooms with numbers i and i+1 on each floor are neighbouring, for all 1\u2264i\u2264n\u22121. There may also be staircases that connect two rooms from different floors having the same numbers. If there is a staircase connecting the room x on the first floor and the room x on the second floor, then Nikolay can use it to move from one room to another.\nNikolay wants to move through some rooms in his house. To do this, he firstly chooses any room where he starts. Then Nikolay moves between rooms according to the aforementioned rules. Nikolay never visits the same room twice (he won't enter a room where he has already been). \nCalculate the maximum number of rooms Nikolay can visit during his tour, if:\nThe first line of the input contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases in the input. Then test cases follow. Each test case consists of two lines.\nThe first line contains one integer n (1\u2264n\u22641000) \u2014 the number of rooms on each floor.\nThe second line contains one string consisting of n characters, each character is either a '0' or a '1'. If the i-th character is a '1', then there is a staircase between the room i on the first floor and the room i on the second floor. If the i-th character is a '0', then there is no staircase between the room i on the first floor and the room i on the second floor.\nIn hacks it is allowed to use only one test case in the input, so t=1 should be satisfied.\nFor each test case print one integer \u2014 the maximum number of rooms Nikolay can visit during his tour, if he can start in any room on any floor, and he won't visit the same room twice.\nIn the first test case Nikolay may start in the first room of the first floor. Then he moves to the second room on the first floor, and then \u2014 to the third room on the first floor. Then he uses a staircase to get to the third room on the second floor. Then he goes to the fourth room on the second floor, and then \u2014 to the fifth room on the second floor. So, Nikolay visits 6 rooms.\nThere are no staircases in the second test case, so Nikolay can only visit all rooms on the same floor (if he starts in the leftmost or in the rightmost room).\nIn the third test case it is possible to visit all rooms: first floor, first room \u2192 second floor, first room \u2192 second floor, second room \u2192 first floor, second room \u2192 first floor, third room \u2192 second floor, third room \u2192 second floor, fourth room \u2192 first floor, fourth room \u2192 first floor, fifth room \u2192 second floor, fifth room.\nIn the fourth test case it is also possible to visit all rooms: second floor, third room \u2192 second floor, second room \u2192 second floor, first room \u2192 first floor, first room \u2192 first floor, second room \u2192 first floor, third room.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1000"
        ],
        "solutions": "1244B - Rooms and StaircasesIf there are no stairs, the best we can do is to visit all the rooms on the same floor, so the answer is n.Otherwise, the best course of action is to choose exactly one stair (let's denote its number by s) and do one of the following: either start from the leftmost room on the first floor, then use the stair and move to the leftmost room on the second floor, or do the same, but start and end in rightmost rooms instead of leftmost ones. Then for choosing the stair in room s, we get max(2s,2(n\u2212s+1)) as the answer.Why is it optimal? Let's denote the leftmost stair as l, and the rightmost stair as r. There are four special segments of rooms such that if we enter them, we can't leave. These are: rooms [1\u2026l\u22121] on the first floor, rooms [1\u2026l\u22121] on the second floor, rooms [r+1\u2026n] on the first floor and rooms [r+1\u2026n] on the second floor. We can visit only two of them, if one contains the starting room and the other contains the ending room. So the answer cannot be greater than 2n\u22122min(l\u22121,n\u2212r\u22121) \u2014 and our algorithm will give exactly this value either by choosing stair l, or by choosing the stair r. "
    },
    "1243B1": {
        "title": "B1. Character Swap (Easy Version)",
        "description": "This problem is different from the hard version. In this version Ujan makes exactly one exchange. You can hack this problem only if you solve both problems.\nAfter struggling and failing many times, Ujan decided to try to clean up his house again. He decided to get his strings in order first.\nUjan has two distinct strings s and t of length n consisting of only of lowercase English characters. He wants to make them equal. Since Ujan is lazy, he will perform the following operation exactly once: he takes two positions i and j (1\u2264i,j\u2264n, the values i and j can be equal or different), and swaps the characters si and tj. Can he succeed?\nNote that he has to perform this operation exactly once. He has to perform this operation.\nThe first line contains a single integer k (1\u2264k\u226410), the number of test cases.\nFor each of the test cases, the first line contains a single integer n (2\u2264n\u2264104), the length of the strings s and t. \nEach of the next two lines contains the strings s and t, each having length exactly n. The strings consist only of lowercase English letters. It is guaranteed that strings are different.\nFor each test case, output \"Yes\" if Ujan can make the two strings equal and \"No\" otherwise.\nYou can print each letter in any case (upper or lower).\nIn the first test case, Ujan can swap characters s1 and t4, obtaining the word \"house\".\nIn the second test case, it is not possible to make the strings equal using exactly one swap of si and tj.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "strings",
            "*1000"
        ],
        "solutions": "1243B1 - Character Swap (Easy Version)First, suppose that we make the strings equal by picking some i, j. Then for all p\u2260i,j, we must have sp=tp, since these letters don't change.Suppose that i=j. Since the strings are distinct, we then must have si\u2260ti. But then the strings are not equal also after the swap; hence, we always need to pick distinct i and j.Now, if i\u2260j and the strings are equal after the swap, we must have that si=sj, ti=tj and si,sj\u2260ti,tj. Therefore, the solution is as follows: if the number of positions where s and t differ is not equal to 2, the answer is \"No\". Otherwise we find the two positions i, j, where s and t differ, and check that the above conditions hold. Then the answer is \"Yes\". Complexity of the solution: O(n). "
    },
    "1237A": {
        "title": "A. Balanced Rating Changes",
        "description": "Another Codeforces Round has just finished! It has gathered n participants, and according to the results, the expected rating change of participant i is ai. These rating changes are perfectly balanced\u00a0\u2014 their sum is equal to 0.\nUnfortunately, due to minor technical glitches, the round is declared semi-rated. It means that all rating changes must be divided by two.\nThere are two conditions though: \nCan you help with that?\nThe first line contains a single integer n (2\u2264n\u226413845), denoting the number of participants.\nEach of the next n lines contains a single integer ai (\u2212336\u2264ai\u22641164), denoting the rating change of the i-th participant.\nThe sum of all ai is equal to 0.\nOutput n integers bi, each denoting the modified rating change of the i-th participant in order of input.\nFor any i, it must be true that either bi=\u230aai2\u230b or bi=\u2308ai2\u2309. The sum of all bi must be equal to 0.\nIf there are multiple solutions, print any. We can show that a solution exists for any valid input.\nIn the first example, b1=5, b2=\u22123 and b3=\u22122 is another correct solution.\nIn the second example there are 6 possible solutions, one of them is shown in the example output.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1234B1": {
        "title": "B1. Social Network (easy version)",
        "description": "The only difference between easy and hard versions are constraints on n and k.\nYou are messaging in one of the popular social networks via your smartphone. Your smartphone can show at most k most recent conversations with your friends. Initially, the screen is empty (i.e. the number of displayed conversations equals 0).\nEach conversation is between you and some of your friends. There is at most one conversation with any of your friends. So each conversation is uniquely defined by your friend.\nYou (suddenly!) have the ability to see the future. You know that during the day you will receive n messages, the i-th message will be received from the friend with ID idi (1\u2264idi\u2264109).\nIf you receive a message from idi in the conversation which is currently displayed on the smartphone then nothing happens: the conversations of the screen do not change and do not change their order, you read the message and continue waiting for new messages.\nOtherwise (i.e. if there is no conversation with idi on the screen):\nYour task is to find the list of conversations (in the order they are displayed on the screen) after processing all n messages.\nThe first line of the input contains two integers n and k (1\u2264n,k\u2264200) \u2014 the number of messages and the number of conversations your smartphone can show.\nThe second line of the input contains n integers id1,id2,\u2026,idn (1\u2264idi\u2264109), where idi is the ID of the friend which sends you the i-th message.\nIn the first line of the output print one integer m (1\u2264m\u2264min(n,k)) \u2014 the number of conversations shown after receiving all n messages.\nIn the second line print m integers ids1,ids2,\u2026,idsm, where idsi should be equal to the ID of the friend corresponding to the conversation displayed on the position i after receiving all n messages.\nIn the first example the list of conversations will change in the following way (in order from the first to last message):\nIn the second example the list of conversations will change in the following way:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1234B1 - Social Network (easy version)The solution to this problem is just the implementation of what is written in the problem statement. Let's carry the array q which shows the current smartphone screen. When we receive the new message from the friend with ID idi, let's do the following sequence of moves:  Firstly, let's try to find him on the screen. If he is found, just do nothing and continue.  Otherwise, let's check if the current number of conversations is k. If it is so then let's remove the last conversation.  Now the number of conversations is less than k and the current friend is not shown on the screen. Let's insert him into the first position. After processing all n messages the answer is just the array q. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> ids;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint id;\n\t\tcin >> id;\n\t\tif (find(ids.begin(), ids.end(), id) == ids.end()) {\n\t\t\tif (int(ids.size()) >= k) ids.pop_back();\n\t\t\tids.insert(ids.begin(), id);\n\t\t}\n\t}\n\t\n\tcout << ids.size() << endl;\n\tfor (auto it : ids) cout << it << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}"
    },
    "1231C": {
        "title": "C. Increasing Matrix",
        "description": "In this problem, a n\u00d7m rectangular matrix a is called increasing if, for each row of i, when go from left to right, the values strictly increase (that is, ai,1<ai,2<\u22ef<ai,m) and for each column j, when go from top to bottom, the values strictly increase (that is, a1,j<a2,j<\u22ef<an,j).\nIn a given matrix of non-negative integers, it is necessary to replace each value of 0 with some positive integer so that the resulting matrix is increasing and the sum of its elements is maximum, or find that it is impossible.\nIt is guaranteed that in a given value matrix all values of 0 are contained only in internal cells (that is, not in the first or last row and not in the first or last column).\nThe first line contains integers n and m (3\u2264n,m\u2264500) \u2014 the number of rows and columns in the given matrix a.\nThe following lines contain m each of non-negative integers \u2014 the values in the corresponding row of the given matrix: ai,1,ai,2,\u2026,ai,m (0\u2264ai,j\u22648000).\nIt is guaranteed that for all ai,j=0, 1<i<n and 1<j<m are true.\nIf it is possible to replace all zeros with positive numbers so that the matrix is increasing, print the maximum possible sum of matrix elements. Otherwise, print -1.\nIn the first example, the resulting matrix is as follows: \nIn the second example, the value 3 must be put in the middle cell.\nIn the third example, the desired resultant matrix does not exist.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1230B": {
        "title": "B. Ania and Minimizing",
        "description": "Ania has a large integer S. Its decimal representation has length n and doesn't contain any leading zeroes. Ania is allowed to change at most k digits of S. She wants to do it in such a way that S still won't contain any leading zeroes and it'll be minimal possible. What integer will Ania finish with?\nThe first line contains two integers n and k (1\u2264n\u2264200000, 0\u2264k\u2264n) \u2014 the number of digits in the decimal representation of S and the maximum allowed number of changed digits.\nThe second line contains the integer S. It's guaranteed that S has exactly n digits and doesn't contain any leading zeroes.\nOutput the minimal possible value of S which Ania can end with. Note that the resulting integer should also have n digits.\nA number has leading zeroes if it consists of at least two digits and its first digit is 0. For example, numbers 00, 00069 and 0101 have leading zeroes, while 0, 3000 and 1010 don't have leading zeroes.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1227B": {
        "title": "B. Box",
        "description": "Permutation p is a sequence of integers p=[p1,p2,\u2026,pn], consisting of n distinct (unique) positive integers between 1 and n, inclusive. For example, the following sequences are permutations: [3,4,1,2], [1], [1,2]. The following sequences are not permutations: [0], [1,2,1], [2,3], [0,1,2].\nThe important key is in the locked box that you need to open. To open the box you need to enter secret code. Secret code is a permutation p of length n. \nYou don't know this permutation, you only know the array q of prefix maximums of this permutation. Formally:\nYou want to construct any possible suitable permutation (i.e. any such permutation, that calculated q for this permutation is equal to the given array).\nThe first line contains integer number t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the input. Then t test cases follow.\nThe first line of a test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the number of elements in the secret code permutation p.\nThe second line of a test case contains n integers q1,q2,\u2026,qn (1\u2264qi\u2264n)\u00a0\u2014 elements of the array q for secret permutation. It is guaranteed that qi\u2264qi+1 for all i (1\u2264i<n).\nThe sum of all values n over all the test cases in the input doesn't exceed 105.\nFor each test case, print:\nIn the first test case of the example answer [1,3,4,5,2] is the only possible answer:\nIt can be proved that there are no answers for the second test case of the example.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1227A": {
        "title": "A. Math Problem",
        "description": "Your math teacher gave you the following problem:\nThere are n segments on the x-axis, [l1;r1],[l2;r2],\u2026,[ln;rn]. The segment [l;r] includes the bounds, i.e. it is a set of such x that l\u2264x\u2264r. The length of the segment [l;r] is equal to r\u2212l.\nTwo segments [a;b] and [c;d] have a common point (intersect) if there exists x that a\u2264x\u2264b and c\u2264x\u2264d. For example, [2;5] and [3;10] have a common point, but [5;6] and [1;4] don't have.\nYou should add one segment, which has at least one common point with each of the given segments and as short as possible (i.e. has minimal length). The required segment can degenerate to be a point (i.e a segment with length zero). The added segment may or may not be among the given n segments.\nIn other words, you need to find a segment [a;b], such that [a;b] and every [li;ri] have a common point for each i, and b\u2212a is minimal.\nThe first line contains integer number t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases in the input. Then t test cases follow.\nThe first line of each test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the number of segments. The following n lines contain segment descriptions: the i-th of them contains two integers li,ri (1\u2264li\u2264ri\u2264109).\nThe sum of all values n over all the test cases in the input doesn't exceed 105.\nFor each test case, output one integer\u00a0\u2014 the smallest possible length of the segment which has at least one common point with all given segments.\nIn the first test case of the example, we can choose the segment [5;7] as the answer. It is the shortest segment that has at least one common point with all given segments.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1225B1": {
        "title": "B1. TV Subscriptions (Easy Version)",
        "description": "The only difference between easy and hard versions is constraints.\nThe BerTV channel every day broadcasts one episode of one of the k TV shows. You know the schedule for the next n days: a sequence of integers a1,a2,\u2026,an (1\u2264ai\u2264k), where ai is the show, the episode of which will be shown in i-th day.\nThe subscription to the show is bought for the entire show (i.e. for all its episodes), for each show the subscription is bought separately.\nHow many minimum subscriptions do you need to buy in order to have the opportunity to watch episodes of purchased shows d (1\u2264d\u2264n) days in a row? In other words, you want to buy the minimum number of TV shows so that there is some segment of d consecutive days in which all episodes belong to the purchased shows.\nThe first line contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases in the input. Then t test case descriptions follow.\nThe first line of each test case contains three integers n,k and d (1\u2264n\u2264100, 1\u2264k\u2264100, 1\u2264d\u2264n). The second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264k), where ai is the show that is broadcasted on the i-th day.\nIt is guaranteed that the sum of the values \u200b\u200bof n for all test cases in the input does not exceed 100.\nPrint t integers \u2014 the answers to the test cases in the input in the order they follow. The answer to a test case is the minimum number of TV shows for which you need to purchase a subscription so that you can watch episodes of the purchased TV shows on BerTV for d consecutive days. Please note that it is permissible that you will be able to watch more than d days in a row.\nIn the first test case to have an opportunity to watch shows for two consecutive days, you need to buy a subscription on show 1 and on show 2. So the answer is two.\nIn the second test case, you can buy a subscription to any show because for each show you can find a segment of three consecutive days, consisting only of episodes of this show.\nIn the third test case in the unique segment of four days, you have four different shows, so you need to buy a subscription to all these four shows.\nIn the fourth test case, you can buy subscriptions to shows 3,5,7,8,9, and you will be able to watch shows for the last eight days.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1225B1 - TV Subscriptions (Easy Version)We are looking for a segment of length d with the smallest number of distinct values. In small limitations one could just try all segments and count the number of distinct elements naively (for example, by sorting or with an std::set). "
    },
    "1223B": {
        "title": "B. Strings Equalization",
        "description": "You are given two strings of equal length s and t consisting of lowercase Latin letters. You may perform any number (possibly, zero) operations on these strings.\nDuring each operation you choose two adjacent characters in any string and assign the value of the first character to the value of the second or vice versa.\nFor example, if s is \"acbc\" you can get the following strings in one operation: \nNote that you can also apply this operation to the string t.\nPlease determine whether it is possible to transform s into t, applying the operation above any number of times.\nNote that you have to answer q independent queries.\nThe first line contains one integer q (1\u2264q\u2264100)\u00a0\u2014 the number of queries. Each query is represented by two consecutive lines.\nThe first line of each query contains the string s (1\u2264|s|\u2264100) consisting of lowercase Latin letters.\nThe second line of each query contains the string t (1\u2264|t|\u2264100, |t|=|s|) consisting of lowercase Latin letters.\nFor each query, print \"YES\" if it is possible to make s equal to t, and \"NO\" otherwise.\nYou may print every letter in any case you want (so, for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will all be recognized as positive answer).\nIn the first query, you can perform two operations s1=s2 (after it s turns into \"aabb\") and t4=t3 (after it t turns into \"aabb\"). \nIn the second query, the strings are equal initially, so the answer is \"YES\".\nIn the third query, you can not make strings s and t equal. Therefore, the answer is \"NO\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "strings",
            "*1000"
        ],
        "solutions": "1223B - Strings EqualizationIf there is a character which is contained in string s and t (let's denote it as c), then we answer is \"YES\" because we can turn these string into string consisting only of this character c.Otherwise the answer is \"NO\", because if initially strings have not a common character, then after performing operation they also have not a common character.  Solution (Roms)for t in range(int(input())):\n    print('NO' if len(set(input()) & set(input())) == 0 else 'YES')"
    },
    "1221C": {
        "title": "C. Perfect Team",
        "description": "You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She/he can have no specialization, but can't have both at the same time.\nSo the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members.\nYou are a coach at a very large university and you know that c of your students are coders, m are mathematicians and x have no specialization.\nWhat is the maximum number of full perfect teams you can distribute them into? \nNote that some students can be left without a team and each student can be a part of no more than one team.\nYou are also asked to answer q independent queries.\nThe first line contains a single integer q (1\u2264q\u2264104) \u2014 the number of queries. \nEach of the next q lines contains three integers c, m and x (0\u2264c,m,x\u2264108) \u2014 the number of coders, mathematicians and students without any specialization in the university, respectively.\nNote that the no student is both coder and mathematician at the same time. \nPrint q integers \u2014 the i-th of them should be the answer to the i query in the order they are given in the input. The answer is the maximum number of full perfect teams you can distribute your students into. \nIn the first example here are how teams are formed:",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1200"
        ],
        "solutions": "1221C - Perfect TeamNotice that if c\u2260m, then you can equalize them to the min and re-qualify the rest into students without specialization. That won't change the answer.Now analyze the possible team formations: 1 of each kind, 2 coders and 1 mathematician or 1 coder and 2 mathematicians. Each of these squads have 1 coder and 1 mathematician, so you can only choose the type of the third member.The students without specialization can only be used in the first kind of teams, so let's use them first. After that you might have been left with a nonzero count of coders and mathematicians. These are equal however, so \u230ac+m3\u230b can be added to the answer.This solves each query in O(1).You can also run a binary search and solve each query in O(logMAX).  Solution 1 (BledDest)t = int(input())\nfor i in range(t):\n\tc, m, x = map(int, input().split())\n\td = max(c, m) - min(c, m)\n\tx += d\n\tif(c > m):\n\t\tc -= d\n\telse:\n\t\tm -= d\n\tans = min(c, m, x)\n\tc -= ans\n\tm -= ans\n\tx -= ans\n\tans += (c + m) // 3\n\tprint(ans) Solution 2 (PikMike)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i){\n\t\tint c, m, x;\n\t\tcin >> c >> m >> x;\n\t\tint l = 0, r = min(c, m);\n\t\tint ans = 0;\n\t\twhile (l <= r){\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (c + m + x - 2 * mid >= mid){\n\t\t\t\tl = mid + 1;\n\t\t\t\tans = mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t}\n}"
    },
    "1221B": {
        "title": "B. Knights",
        "description": "You are given a chess board with n rows and n columns. Initially all cells of the board are empty, and you have to put a white or a black knight into each cell of the board.\nA knight is a chess piece that can attack a piece in cell (x2, y2) from the cell (x1, y1) if one of the following conditions is met:\nHere are some examples of which cells knight can attack. In each of the following pictures, if the knight is currently in the blue cell, it can attack all red cells (and only them).\nA duel of knights is a pair of knights of different colors such that these knights attack each other. You have to put a knight (a white one or a black one) into each cell in such a way that the number of duels is maximum possible.\nThe first line contains one integer n (3\u2264n\u2264100) \u2014 the number of rows (and columns) in the board.\nPrint n lines with n characters in each line. The j-th character in the i-th line should be W, if the cell (i, j) contains a white knight, or B, if it contains a black knight. The number of duels should be maximum possible. If there are multiple optimal answers, print any of them.\nIn the first example, there are 8 duels:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1221B - KnightsIdea: BledDest TutorialTutorial is loading... Solution (PikMike)n = int(input())\nfor i in range(n):\n\tprint(''.join(['W' if (i + j) % 2 == 0 else 'B' for j in range(n)]))"
    },
    "1221A": {
        "title": "A. 2048 Game",
        "description": "You are playing a variation of game 2048. Initially you have a multiset s of n integers. Every integer in this multiset is a power of two. \nYou may perform any number (possibly, zero) operations with this multiset.\nDuring each operation you choose two equal integers from s, remove them from s and insert the number equal to their sum into s.\nFor example, if s={1,2,1,1,4,2,2} and you choose integers 2 and 2, then the multiset becomes {1,1,1,4,4,2}.\nYou win if the number 2048 belongs to your multiset. For example, if s={1024,512,512,4} you can win as follows: choose 512 and 512, your multiset turns into {1024,1024,4}. Then choose 1024 and 1024, your multiset turns into {2048,4} and you win.\nYou have to determine if you can win this game.\nYou have to answer q independent queries.\nThe first line contains one integer q (1\u2264q\u2264100) \u2013 the number of queries.\nThe first line of each query contains one integer n (1\u2264n\u2264100) \u2014 the number of elements in multiset.\nThe second line of each query contains n integers s1,s2,\u2026,sn (1\u2264si\u2264229) \u2014 the description of the multiset. It is guaranteed that all elements of the multiset are powers of two. \nFor each query print YES if it is possible to obtain the number 2048 in your multiset, and NO otherwise.\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\nIn the first query you can win as follows: choose 512 and 512, and s turns into {1024,64,1024}. Then choose 1024 and 1024, and s turns into {2048,64} and you win.\nIn the second query s contains 2048 initially.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1221A - 2048 GameIdea: Roms TutorialTutorial is loading... Solution (Roms)for t in range(int(input())):\n\tn = input()\n\tl = filter(lambda x : x <= 2048,  map(int, input().split()) )\n\tprint('YES' if sum(l) >= 2048 else 'NO')"
    },
    "1215A": {
        "title": "A. Yellow Cards",
        "description": "The final match of the Berland Football Cup has been held recently. The referee has shown n yellow cards throughout the match. At the beginning of the match there were a1 players in the first team and a2 players in the second team.\nThe rules of sending players off the game are a bit different in Berland football. If a player from the first team receives k1 yellow cards throughout the match, he can no longer participate in the match \u2014 he's sent off. And if a player from the second team receives k2 yellow cards, he's sent off. After a player leaves the match, he can no longer receive any yellow cards. Each of n yellow cards was shown to exactly one player. Even if all players from one team (or even from both teams) leave the match, the game still continues.\nThe referee has lost his records on who has received each yellow card. Help him to determine the minimum and the maximum number of players that could have been thrown out of the game.\nThe first line contains one integer a1 (1\u2264a1\u22641000) \u2014 the number of players in the first team.\nThe second line contains one integer a2 (1\u2264a2\u22641000) \u2014 the number of players in the second team.\nThe third line contains one integer k1 (1\u2264k1\u22641000) \u2014 the maximum number of yellow cards a player from the first team can receive (after receiving that many yellow cards, he leaves the game).\nThe fourth line contains one integer k2 (1\u2264k2\u22641000) \u2014 the maximum number of yellow cards a player from the second team can receive (after receiving that many yellow cards, he leaves the game).\nThe fifth line contains one integer n (1\u2264n\u2264a1\u22c5k1+a2\u22c5k2) \u2014 the number of yellow cards that have been shown during the match.\nPrint two integers \u2014 the minimum and the maximum number of players that could have been thrown out of the game.\nIn the first example it could be possible that no player left the game, so the first number in the output is 0. The maximum possible number of players that could have been forced to leave the game is 4 \u2014 one player from the first team, and three players from the second.\nIn the second example the maximum possible number of yellow cards has been shown (3\u22c56+1\u22c57=25), so in any case all players were sent off.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1215A - Yellow CardsAt first, if k1>k2, then we swap k1 with k2 and a1 with a2, so the number of yellow cards required to send a player of the first team off is not greater than the same value for the second team. If all players from the first team receive k1\u22121 cards each and all players from the second team receive k2\u22121 cards each, we will minimize the number of players who left the game. Let cnt=a1\u22c5(k1\u22121)+a2\u22c5(k2\u22121). If cnt\u22640, then the minimum number of players who left the game is equal to 0. In the other case, if any player receivse one more yellow card, he leaves the game. So the minimum number of players who left the game is (n\u2212cnt).When we maximize the number of players who left the game, at first we should give cards to players in the first team, and then give cards to players in the second team. So, if n\u2264a1\u22c5k1, the answer is \u230ank1\u230b. In the other case, the answer is a1+\u230an\u2212a1\u22c5k1k2\u230b.  Solution (fcspartakm)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint a1, a2, k1, k2, n;\n\ninline void read() {\n\tcin >> a1 >> a2 >> k1 >> k2 >> n;\t\n}\n\ninline void solve() {\n\tif (k1 > k2) {\n\t\tswap(k1, k2);\n\t\tswap(a1, a2);\n\t}\n\tint minCnt = max(0, n &mdash; a1 * (k1 &mdash; 1) &mdash; a2 * (k2 &mdash; 1));\n\tint maxCnt = 0;\n\tif (n <= a1 * k1) {\n\t\tmaxCnt = n / k1;\n\t} else {\n\t\tmaxCnt = a1 + (n &mdash; a1 * k1) / k2;\n    }    \n    cout << minCnt << ' ' << maxCnt << endl;\n}\n\nint main () {\n#ifdef fcspartakm\n    freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    srand(time(NULL));\n    cerr << setprecision(10) << fixed;\n    \n    read();\n    solve();\n \n    //cerr << \"TIME: \" << clock() << endl;\n}"
    },
    "1214C": {
        "title": "C. Bad Sequence",
        "description": "Petya's friends made him a birthday present \u2014 a bracket sequence. Petya was quite disappointed with his gift, because he dreamed of correct bracket sequence, yet he told his friends nothing about his dreams and decided to fix present himself. \nTo make everything right, Petya is going to move at most one bracket from its original place in the sequence to any other position. Reversing the bracket (e.g. turning \"(\" into \")\" or vice versa) isn't allowed. \nWe remind that bracket sequence s is called correct if: \nFor example, \"(()())\", \"()\" are correct, while \")(\" and \"())\" are not. Help Petya to fix his birthday present and understand whether he can move one bracket so that the sequence becomes correct.\nFirst of line of input contains a single number n (1\u2264n\u2264200000)\u00a0\u2014 length of the sequence which Petya received for his birthday.\nSecond line of the input contains bracket sequence of length n, containing symbols \"(\" and \")\".\nPrint \"Yes\" if Petya can make his sequence correct moving at most one bracket. Otherwise print \"No\".\nIn the first example, Petya can move first bracket to the end, thus turning the sequence into \"()\", which is correct bracket sequence.\nIn the second example, there is no way to move at most one bracket so that the sequence becomes correct.\nIn the third example, the sequence is already correct and there's no need to move brackets.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1200"
        ],
        "solutions": "1214C - Bad SequenceLet's call a balance of bracket sequence a number of opening brackets minus the number of closing brackets. Correct bracket sequence is such a sequence that balance of any of its prefixes is at least 0 and the balance of the entire sequence is equal to 0. To solve the problem let's consider the shortest prefix with balance equal to \u22121. In this prefix last symbol is obviously equal to \")\", so let's move this closing bracket to the end of the sequence. If the sequence is correct now, then the answer is \"Yes\", otherwise it is \"No\", because it means that in original sequence there exists some longer prefix with balance equal to \u22122. Let's show why we can't move some bracket so that the sequence becomes correct.Consider the shortest prefix with balance equal to \u22122. If we move some opening bracket to the beginning of the sequence, balance of considered prefix becomes \u22121 and the sequence is not correct yet. Moving opening bracket from considered prefix to the beginning doesn't change anything. Even more, if we move the closing bracket from the end of the considered prefix to the end of the sequence, it still doesn't become correct, because balance of the prefix is \u22121.This results in a following solution: if balance of all prefixes is not less than \u22121, answer is \"Yes\", otherwise it's \"No\". "
    },
    "1214B": {
        "title": "B. Badges",
        "description": "There are b boys and g girls participating in Olympiad of Metropolises. There will be a board games tournament in the evening and n participants have accepted the invitation. The organizers do not know how many boys and girls are among them.\nOrganizers are preparing red badges for girls and blue ones for boys.\nVasya prepared n+1 decks of badges. The i-th (where i is from 0 to n, inclusive) deck contains i blue badges and n\u2212i red ones. The total number of badges in any deck is exactly n.\nDetermine the minimum number of decks among these n+1 that Vasya should take, so that there will be a suitable deck no matter how many girls and boys there will be among the participants of the tournament.\nThe first line contains an integer b (1\u2264b\u2264300), the number of boys. \nThe second line contains an integer g (1\u2264g\u2264300), the number of girls. \nThe third line contains an integer n (1\u2264n\u2264b+g), the number of the board games tournament participants.\nOutput the only integer, the minimum number of badge decks that Vasya could take.\nIn the first example, each of 4 decks should be taken: (0 blue, 3 red), (1 blue, 2 red), (2 blue, 1 red), (3 blue, 0 red).\nIn the second example, 4 decks should be taken: (2 blue, 3 red), (3 blue, 2 red), (4 blue, 1 red), (5 blue, 0 red). Piles (0 blue, 5 red) and (1 blue, 4 red) can not be used.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1100"
        ],
        "solutions": "1214B - Badges was authored by jury and prepared by Chmel_Tolstiy."
    },
    "1213C": {
        "title": "C. Book Reading",
        "description": "Polycarp is reading a book consisting of n pages numbered from 1 to n. Every time he finishes the page with the number divisible by m, he writes down the last digit of this page number. For example, if n=15 and m=5, pages divisible by m are 5,10,15. Their last digits are 5,0,5 correspondingly, their sum is 10.\nYour task is to calculate the sum of all digits Polycarp has written down.\nYou have to answer q independent queries.\nThe first line of the input contains one integer q (1\u2264q\u22641000) \u2014 the number of queries.\nThe following q lines contain queries, one per line. Each query is given as two integers n and m (1\u2264n,m\u22641016) \u2014 the number of pages in the book and required divisor, respectively.\nFor each query print the answer for it \u2014 the sum of digits written down by Polycarp.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solutions": "1213C - Book ReadingLet k=\u230anm\u230b be the number of integers from 1 to n divisible by m. We can notice that because we write down only the last digit of each number divisible by m then the length of the \"cycle\" of digits does not exceed 10. In fact, we can always suppose that it is 10 because i\u22c5m%10=(10+i)\u22c5m%10 for all i from 0 to 9. So let cyclei=m\u2217(i+1)%10 for all i from 0 to 9. Then the answer is \u230ak10\u230b\u22c5\u2211i=09cyclei+\u2211i=0k%10cyclei. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int q;\n    cin >> q;\n    forn(i, q) {\n        long long n, m;\n        cin >> n >> m;\n        n = n / m;\n        vector<int> digits(10);\n        forn(i, 10)\n            digits[i] = ((i + 1) * m) % 10;\n        long long sum = 0;\n        forn(i, n % 10)\n            sum += digits[i];\n        cout << sum + n / 10 * accumulate(digits.begin(), digits.end(), 0LL) << endl;\n    }\n}"
    },
    "1213B": {
        "title": "B. Bad Prices",
        "description": "Polycarp analyzes the prices of the new berPhone. At his disposal are the prices for n last days: a1,a2,\u2026,an, where ai is the price of berPhone on the day i.\nPolycarp considers the price on the day i to be bad if later (that is, a day with a greater number) berPhone was sold at a lower price. For example, if n=6 and a=[3,9,4,6,7,5], then the number of days with a bad price is 3 \u2014 these are days 2 (a2=9), 4 (a4=6) and 5 (a5=7).\nPrint the number of days with a bad price.\nYou have to answer t independent data sets.\nThe first line contains an integer t (1\u2264t\u226410000) \u2014 the number of sets of input data in the test. Input data sets must be processed independently, one after another.\nEach input data set consists of two lines. The first line contains an integer n (1\u2264n\u2264150000) \u2014 the number of days. The second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106), where ai is the price on the i-th day.\nIt is guaranteed that the sum of n over all data sets in the test does not exceed 150000.\nPrint t integers, the j-th of which should be equal to the number of days with a bad price in the j-th input data set.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "*1100"
        ],
        "solutions": "1213B - Bad Prices TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nint main() {\n    int t;\n    cin >> t;\n    forn(tt, t) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        forn(i, n)\n            cin >> a[i];\n        int ans = 0;\n        int right_min = INT_MAX;\n        for (int i = n -  1; i >= 0; i--) {\n            if (a[i] > right_min)\n                ans++;\n            right_min = min(right_min, a[i]);\n        }\n        cout << ans << endl;\n    }\n}"
    },
    "1211A": {
        "title": "A. Three Problems",
        "description": "Polycarp is choosing three problems for creating a programming test. Totally he has n problems in his list. The complexity of the i-th problem equals ri. All problems are numerated from 1 to n.\nHelp Polycarp to choose such three problems a, b and c, so that the complexity of the first problem strictly less than the complexity of second problem and the complexity of the second problem is strictly less than the complexity of the third problem. So, for chosen problems a, b and c it should be true that ra<rb<rc.\nIf Polycarp can choose three problems in different ways, you can print any of them.\nThe first line of the input contains one integer n (3\u2264n\u22643000) \u2014 the number of problems in Polycarp's list.\nThe second line of the input contains n integers r1,r2,\u2026,rn (1\u2264ri\u2264109), where ri is the complexity of the i-th problem.\nIf Polycarp has no ways to choose three problems, you should print three numbers -1. Ih there is a way to choose them, you should print three different integers a,b,c (1\u2264a,b,c\u2264n), where a is the number of the first chosen problem, b is the number of the second chosen problem and c is the number of the third chosen problem.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "implementation",
            "*1000"
        ],
        "solutions": "1211A - Three ProblemsJust choose any three indices with different values and print them in order of increasing values. You can do it in a billion ways. One of the is to use map data structure (from elements to indices): while reading the data assign value $$$i$$$ for the key $$$a_i$$$ (use an ordered map, for example, TreeMap). If the size of the map less than $$$3$$$, print -1. Overwise print values (i.e. correspondent values) for the first three elements of the map.Here is the example of a solution in Kotlin:fun main() {    val n = readLine()!!.toInt()    val r = readLine()!!.split(\" \").map { it.toInt() }        .withIndex()        .distinctBy { it.value }        .sortedBy { it.value }        .map { it.index + 1 }    if (r.size < 3) {        println(\"-1 -1 -1\")    } else {        println(\"${r[0]} ${r[1]} ${r[2]}\")    }}"
    },
    "1207B": {
        "title": "B. Square Filling",
        "description": "You are given two matrices A and B. Each matrix contains exactly n rows and m columns. Each element of A is either 0 or 1; each element of B is initially 0.\nYou may perform some operations with matrix B. During each operation, you choose any submatrix of B having size 2\u00d72, and replace every element in the chosen submatrix with 1. In other words, you choose two integers x and y such that 1\u2264x<n and 1\u2264y<m, and then set Bx,y, Bx,y+1, Bx+1,y and Bx+1,y+1 to 1.\nYour goal is to make matrix B equal to matrix A. Two matrices A and B are equal if and only if every element of matrix A is equal to the corresponding element of matrix B.\nIs it possible to make these matrices equal? If it is, you have to come up with a sequence of operations that makes B equal to A. Note that you don't have to minimize the number of operations.\nThe first line contains two integers n and m (2\u2264n,m\u226450).\nThen n lines follow, each containing m integers. The j-th integer in the i-th line is Ai,j. Each integer is either 0 or 1.\nIf it is impossible to make B equal to A, print one integer \u22121.\nOtherwise, print any sequence of operations that transforms B into A in the following format: the first line should contain one integer k \u2014 the number of operations, and then k lines should follow, each line containing two integers x and y for the corresponding operation (set Bx,y, Bx,y+1, Bx+1,y and Bx+1,y+1 to 1). The condition 0\u2264k\u22642500 should hold.\nThe sequence of operations in the first example:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1207B - Square FillingIt is quite obvious that we can't choose any submatrix that contains at least one zero in A. The contrary is also true \u2014 if a submatrix of A consists of only ones, then there's no reason not to choose it (suppose there is an answer that does not choose it \u2014 then choosing this submatrix won't affect it).So we may perform an operation on every submatrix of B such that the corresponding submatrix in A is filled with 1's, and check if our answer is correct. Solution (BledDest)n, m = map(int, input().split())\na = [[] for i in range(n)]\nfor i in range(n):\n    a[i] = list(map(int, input().split()))\n\nans = []\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if(a[i][j] * a[i][j + 1] * a[i + 1][j] * a[i + 1][j + 1] > 0):\n            a[i][j] = 2\n            a[i + 1][j] = 2\n            a[i][j + 1] = 2\n            a[i + 1][j + 1] = 2\n            ans.append([i, j])\n\ncnt1 = 0\nfor i in range(n):\n    for j in range(m):\n        if(a[i][j] == 1):\n            cnt1 += 1\n\nif(cnt1 != 0):\n    print(-1)\nelse:\n    print(len(ans))\n    for x in ans:\n        print(x[0] + 1, x[1] + 1)"
    },
    "1205A": {
        "title": "A. Almost Equal",
        "description": "You are given integer n. You have to arrange numbers from 1 to 2n, using each of them exactly once, on the circle, so that the following condition would be satisfied:\nFor every n consecutive numbers on the circle write their sum on the blackboard. Then any two of written on the blackboard 2n numbers differ not more than by 1.\nFor example, choose n=3. On the left you can see an example of a valid arrangement: 1+4+5=10, 4+5+2=11, 5+2+3=10, 2+3+6=11, 3+6+1=10, 6+1+4=11, any two numbers differ by at most 1. On the right you can see an invalid arrangement: for example, 5+1+6=12, and 3+2+4=9, 9 and 12 differ more than by 1.\nThe first and the only line contain one integer n (1\u2264n\u2264105).\nIf there is no solution, output \"NO\" in the first line. \nIf there is a solution, output \"YES\" in the first line. In the second line output 2n numbers\u00a0\u2014 numbers from 1 to 2n in the order they will stay in the circle. Each number should appear only once. If there are several solutions, you can output any of them.\nExample from the statement is shown for the first example. \nIt can be proved that there is no solution in the second example.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1205A - Almost EqualConsider a valid arrangement for some n. We denote Si=ai+ai+1+ai+2+\u22ef+ai+n\u22121 for each i from 1 to 2n, where at+2n=at. Then we have: Si+1\u2212Si=(ai+1+ai+2+ai+3+\u22ef+ai+n)\u2212(ai+ai+1+ai+2+\u22ef+ai+n\u22121)=ai+n\u2212ai. Hence |ai+n\u2212ai|\u22641. Since ai+n and ai are different, |ai+n\u2212ai|= 1.It is also clear from this that ai+n\u2212ai and ai+n+1\u2212ai+1 have opposite signs: if they were both equal to 1, we would get Si+2\u2212Si=(Si+2\u2212Si+1)+(Si+1\u2212Si)=(ai+n+1\u2212ai+1)+(ai+n\u2212ai)= 2, similarly with \u22121. Thus, the values \u200b\u200bai+n\u2212ai for i from 1 to 2n shoul be 1 and \u22121 alternating, and this is a sufficient condition.Now, if n is even, we get a contradiction, since ai+n\u2212ai=\u2212(a(i+n)+n\u2212ai+n), but due to the alternating they must be equal.If n is odd, then it's now easy to build an example: for i from 1 to n ai=2i\u22121, ai=2i, if i is even, and ai=2i , ai=2i\u22121 if i is odd.Asymptotics O(n).Challenge:For which pairs of (n,k) (n>k\u22651) is there an arrangement of numbers from 1 to n on a circle such that the sums of each k consecutive numbers differ by not more than 1 ? "
    },
    "1204A": {
        "title": "A. BowWow and the Timetable",
        "description": "In the city of Saint Petersburg, a day lasts for 2100 minutes. From the main station of Saint Petersburg, a train departs after 1 minute, 4 minutes, 16 minutes, and so on; in other words, the train departs at time 4k for each integer k\u22650. Team BowWow has arrived at the station at the time s and it is trying to count how many trains have they missed; in other words, the number of trains that have departed strictly before time s. For example if s=20, then they missed trains which have departed at 1, 4 and 16. As you are the only one who knows the time, help them!\nNote that the number s will be given you in a binary representation without leading zeroes.\nThe first line contains a single binary number s (0\u2264s<2100) without leading zeroes.\nOutput a single number\u00a0\u2014 the number of trains which have departed strictly before the time s.\nIn the first example 1000000002=25610, missed trains have departed at 1, 4, 16 and 64.\nIn the second example 1012=510, trains have departed at 1 and 4.\nThe third example is explained in the statements.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1204A - BowWow and the TimetableBasically, the problem asks you to count \u2308log4s\u2309, which is equal to \u2308log2slog24\u2309=\u2308log2s2\u2309. If we denote l as a length of the input number, then \u2308log2s\u2309 is either equal to l\u22121 if s is the power of two (it can be checked by checking that there is not more than one 1 in the input string), or to l\u22121 otherwise, so the answer to the problem is either \u2308l\u221212\u2309 or \u2308l2\u2309. Also for s=0 the answer is 0. "
    },
    "1203B": {
        "title": "B. Equal Rectangles",
        "description": "You are given 4n sticks, the length of the i-th stick is ai.\nYou have to create n rectangles, each rectangle will consist of exactly 4 sticks from the given set. The rectangle consists of four sides, opposite sides should have equal length and all angles in it should be right. Note that each stick can be used in only one rectangle. Each stick should be used as a side, you cannot break the stick or use it not to the full length.\nYou want to all rectangles to have equal area. The area of the rectangle with sides a and b is a\u22c5b.\nYour task is to say if it is possible to create exactly n rectangles of equal area or not.\nYou have to answer q independent queries.\nThe first line of the input contains one integer q (1\u2264q\u2264500) \u2014 the number of queries. Then q queries follow.\nThe first line of the query contains one integer n (1\u2264n\u2264100) \u2014 the number of rectangles.\nThe second line of the query contains 4n integers a1,a2,\u2026,a4n (1\u2264ai\u2264104), where ai is the length of the i-th stick.\nFor each query print the answer to it. If it is impossible to create exactly n rectangles of equal area using given sticks, print \"NO\". Otherwise print \"YES\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1203B - Equal RectanglesAfter sorting a we can observe that if the answer is \"YES\" then the area of each rectangle is area=a1\u22c5a4n. Then we just need to check for each i from 1 to n that a2i\u22121=a2i and a4n\u22122i+1=a4n\u22122i+2 and a2i\u22121\u22c5a4n\u22122i+2=area. If all conditions are satisfied for all i then the answer is \"YES\". Otherwise the answer is \"NO\". Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(4 * n);\n\t\tfor (int j = 0; j < 4 * n; ++j) {\n\t\t\tcin >> a[j];\n\t\t}\n\t\tsort(a.begin(), a.end());\n\t\tint area = a[0] * a.back();\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint lf = i * 2, rg = 4 * n - (i * 2) - 1;\n\t\t\tif (a[lf] != a[lf + 1] || a[rg] != a[rg - 1] || a[lf] * 1ll * a[rg] != area) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t\tif (ok) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1203A": {
        "title": "A. Circle of Students",
        "description": "There are n students standing in a circle in some order. The index of the i-th student is pi. It is guaranteed that all indices of students are distinct integers from 1 to n (i.\u2009e. they form a permutation).\nStudents want to start a round dance. A clockwise round dance can be started if the student 2 comes right after the student 1 in clockwise order (there are no students between them), the student 3 comes right after the student 2 in clockwise order, and so on, and the student n comes right after the student n\u22121 in clockwise order. A counterclockwise round dance is almost the same thing \u2014 the only difference is that the student i should be right after the student i\u22121 in counterclockwise order (this condition should be met for every i from 2 to n). \nFor example, if the indices of students listed in clockwise order are [2,3,4,5,1], then they can start a clockwise round dance. If the students have indices [3,2,1,4] in clockwise order, then they can start a counterclockwise round dance.\nYour task is to determine whether it is possible to start a round dance. Note that the students cannot change their positions before starting the dance; they cannot swap or leave the circle, and no other student can enter the circle. \nYou have to answer q independent queries.\nThe first line of the input contains one integer q (1\u2264q\u2264200) \u2014 the number of queries. Then q queries follow.\nThe first line of the query contains one integer n (1\u2264n\u2264200) \u2014 the number of students.\nThe second line of the query contains a permutation of indices p1,p2,\u2026,pn (1\u2264pi\u2264n), where pi is the index of the i-th student (in clockwise order). It is guaranteed that all pi are distinct integers from 1 to n (i.\u2009e. they form a permutation).\nFor each query, print the answer on it. If a round dance can be started with the given order of students, print \"YES\". Otherwise print \"NO\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1203A - Circle of Students TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n);\n\t\tint pos = -1;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> a[j];\n\t\t\tif (a[j] == 1) pos = j;\n\t\t}\n\t\tbool okl = true, okr = true;\n\t\tfor (int j = 1; j < n; ++j) {\n\t\t\tokl &= (a[(pos - j + n) % n] == j + 1);\n\t\t\tokr &= (a[(pos + j + n) % n] == j + 1);\n\t\t}\n\t\tif (okl || okr) cout << \"YES\" << endl;\n\t\telse cout << \"NO\" << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1202A": {
        "title": "A. You Are Given Two Binary Strings...",
        "description": "You are given two binary strings x and y, which are binary representations of some two integers (let's denote these integers as f(x) and f(y)). You can choose any integer k\u22650, calculate the expression sk=f(x)+f(y)\u22c52k and write the binary representation of sk in reverse order (let's denote it as revk). For example, let x=1010 and y=11; you've chosen k=1 and, since 21=102, so sk=10102+112\u22c5102=100002 and revk=00001.\nFor given x and y, you need to choose such k that revk is lexicographically minimal (read notes if you don't know what does \"lexicographically\" means).\nIt's guaranteed that, with given constraints, k exists and is finite.\nThe first line contains a single integer T (1\u2264T\u2264100) \u2014 the number of queries.\nNext 2T lines contain a description of queries: two lines per query. The first line contains one binary string x, consisting of no more than 105 characters. Each character is either 0 or 1.\nThe second line contains one binary string y, consisting of no more than 105 characters. Each character is either 0 or 1.\nIt's guaranteed, that 1\u2264f(y)\u2264f(x) (where f(x) is the integer represented by x, and f(y) is the integer represented by y), both representations don't have any leading zeroes, the total length of x over all queries doesn't exceed 105, and the total length of y over all queries doesn't exceed 105.\nPrint T integers (one per query). For each query print such k that revk is lexicographically minimal.\nThe first query was described in the legend.\nIn the second query, it's optimal to choose k=3. The 23=10002 so s3=100012+1102\u22c510002=10001+110000=1000001 and rev3=1000001. For example, if k=0, then s0=10111 and rev0=11101, but rev3=1000001 is lexicographically smaller than rev0=11101.\nIn the third query s0=10 and rev0=01. For example, s2=101 and rev2=101. And 01 is lexicographically smaller than 101.\nThe quote from Wikipedia: \"To determine which of two strings of characters comes when arranging in lexicographical order, their first letters are compared. If they differ, then the string whose first letter comes earlier in the alphabet comes before the other string. If the first letters are the same, then the second letters are compared, and so on. If a position is reached where one string has no more letters to compare while the other does, then the first (shorter) string is deemed to come first in alphabetical order.\"",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1100"
        ],
        "solutions": "1202A - You Are Given Two Binary Strings...Multiplying by power of 2 is \"shift left\" binary operation (you, probably, should know it). Reverse x and y for the simplicity and look at leftmost 1 in y (let's denote its position as posy).If you move it to 0 in x then you make the revk lexicographically bigger than the reverse of x. So you should move it to 1 in x too. You can choose any 1 with position \u2265posy.Let posx be the minimum position of 1 in x, such that posx\u2265posy. You must move posy to posx, otherwise the 1 in posx still be present in revk and it will be not optimal.So, the solution is next: reverse x and y, find posy, find posx\u2265posy, print posx\u2212posy. Solution (adedalic)fun main(args: Array<String>) {\n    val T = readLine()!!.toInt()\n    for (tc in 1..T) {\n        val x = readLine()!!.reversed()\n        val y = readLine()!!.reversed()\n\n        val posY = y.indexOf('1')\n        val posX = x.indexOf('1', posY)\n        println(posX - posY)\n    }\n}"
    },
    "1200B": {
        "title": "B. Block Adventure",
        "description": "Gildong is playing a video game called Block Adventure. In Block Adventure, there are n columns of blocks in a row, and the columns are numbered from 1 to n. All blocks have equal heights. The height of the i-th column is represented as hi, which is the number of blocks stacked in the i-th column.\nGildong plays the game as a character that can stand only on the top of the columns. At the beginning, the character is standing on the top of the 1-st column. The goal of the game is to move the character to the top of the n-th column.\nThe character also has a bag that can hold infinitely many blocks. When the character is on the top of the i-th column, Gildong can take one of the following three actions as many times as he wants: \nIn actions of the first two types the character remains in the i-th column, and the value hi changes.\nThe character initially has m blocks in the bag. Gildong wants to know if it is possible to win the game. Help Gildong find the answer to his question.\nEach test contains one or more test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains three integers n, m, and k (1\u2264n\u2264100, 0\u2264m\u2264106, 0\u2264k\u2264106) \u2014 the number of columns in the game, the number of blocks in the character's bag at the beginning, and the non-negative integer k described in the statement.\nThe second line of each test case contains n integers. The i-th integer is hi (0\u2264hi\u2264106), the initial height of the i-th column.\nFor each test case, print \"YES\" if it is possible to win the game. Otherwise, print \"NO\".\nYou can print each letter in any case (upper or lower).\nIn the first case, Gildong can take one block from the 1-st column, move to the 2-nd column, put the block on the 2-nd column, then move to the 3-rd column.\nIn the second case, Gildong has to put the block in his bag on the 1-st column to get to the 2-nd column. But it is impossible to get to the 3-rd column because |h2\u2212h3|=3>k and there is no way to decrease the gap.\nIn the fifth case, the character is already on the n-th column from the start so the game is won instantly.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1200"
        ],
        "solutions": "1200B - Block AdventureWe can easily see that it's always optimal to have as many blocks as possible in the bag before getting to the next column. Therefore, if the character is currently on the top of the i-th column, Gildong just needs to make hi become max(0,hi+1\u2212k) by repeating the 1-st or the 2-nd action. In other words, we should add hi\u2212max(0,hi+1\u2212k) blocks to the bag. Adding or subtracting one by one will lead to TLE. If there exists a situation where the bag will have negative number of blocks, the answer is NO. Otherwise the answer is YES.Time complexity: O(n) for each test case. "
    },
    "1199B": {
        "title": "B. Water Lily",
        "description": "While sailing on a boat, Inessa noticed a beautiful water lily flower above the lake's surface. She came closer and it turned out that the lily was exactly H centimeters above the water surface. Inessa grabbed the flower and sailed the distance of L centimeters. Exactly at this point the flower touched the water surface.\nSuppose that the lily grows at some point A on the lake bottom, and its stem is always a straight segment with one endpoint at point A. Also suppose that initially the flower was exactly above the point A, i.e. its stem was vertical. Can you determine the depth of the lake at point A?\nThe only line contains two integers H and L (1\u2264H<L\u2264106).\nPrint a single number\u00a0\u2014 the depth of the lake at point A. The absolute or relative error should not exceed 10\u22126.\nFormally, let your answer be A, and the jury's answer be B. Your answer is accepted if and only if |A\u2212B|max(1,|B|)\u226410\u22126.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "math",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1199A": {
        "title": "A. City Day",
        "description": "For years, the Day of city N was held in the most rainy day of summer. New mayor decided to break this tradition and select a not-so-rainy day for the celebration. The mayor knows the weather forecast for the n days of summer. On the i-th day, ai millimeters of rain will fall. All values ai are distinct.\nThe mayor knows that citizens will watch the weather x days before the celebration and y days after. Because of that, he says that a day d is not-so-rainy if ad is smaller than rain amounts at each of x days before day d and and each of y days after day d. In other words, ad<aj should hold for all d\u2212x\u2264j<d and d<j\u2264d+y. Citizens only watch the weather during summer, so we only consider such j that 1\u2264j\u2264n.\nHelp mayor find the earliest not-so-rainy day of summer.\nThe first line contains three integers n, x and y (1\u2264n\u2264100000, 0\u2264x,y\u22647)\u00a0\u2014 the number of days in summer, the number of days citizens watch the weather before the celebration and the number of days they do that after.\nThe second line contains n distinct integers a1, a2, ..., an (1\u2264ai\u2264109), where ai denotes the rain amount on the i-th day.\nPrint a single integer\u00a0\u2014 the index of the earliest not-so-rainy day of summer. We can show that the answer always exists.\nIn the first example days 3 and 8 are not-so-rainy. The 3-rd day is earlier.\nIn the second example day 3 is not not-so-rainy, because 3+y=6 and a3>a6. Thus, day 8 is the answer. Note that 8+y=11, but we don't consider day 11, because it is not summer.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1197B": {
        "title": "B. Pillars",
        "description": "There are n pillars aligned in a row and numbered from 1 to n.\nInitially each pillar contains exactly one disk. The i-th pillar contains a disk having radius ai.\nYou can move these disks from one pillar to another. You can take a disk from pillar i and place it on top of pillar j if all these conditions are met:\nWhen you place a disk on a pillar that already has some disks on it, you put the new disk on top of previously placed disks, so the new disk will be used to check the third condition if you try to place another disk on the same pillar.\nYou may take any disk and place it on other pillar any number of times, provided that every time you do it, all three aforementioned conditions are met. Now you wonder, is it possible to place all n disks on the same pillar simultaneously?\nThe first line contains one integer n (3\u2264n\u22642\u22c5105) \u2014 the number of pillars.\nThe second line contains n integers a1, a2, ..., ai (1\u2264ai\u2264n), where ai is the radius of the disk initially placed on the i-th pillar. All numbers ai are distinct.\nPrint YES if it is possible to place all the disks on the same pillar simultaneously, and NO otherwise. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).\nIn the first case it is possible to place all disks on pillar 3 using the following sequence of actions:",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1196B": {
        "title": "B. Odd Sum Segments",
        "description": "You are given an array a consisting of n integers a1,a2,\u2026,an. You want to split it into exactly k non-empty non-intersecting subsegments such that each subsegment has odd sum (i.\u2009e. for each subsegment, the sum of all elements that belong to this subsegment is odd). It is impossible to rearrange (shuffle) the elements of a given array. Each of the n elements of the array a must belong to exactly one of the k subsegments.\nLet's see some examples of dividing the array of length 5 into 3 subsegments (not necessarily with odd sums): [1,2,3,4,5] is the initial array, then all possible ways to divide it into 3 non-empty non-intersecting subsegments are described below:\nOf course, it can be impossible to divide the initial array into exactly k subsegments in such a way that each of them will have odd sum of elements. In this case print \"NO\". Otherwise, print \"YES\" and any possible division of the array. See the output format for the detailed explanation.\nYou have to answer q independent queries.\nThe first line contains one integer q (1\u2264q\u22642\u22c5105) \u2014 the number of queries. Then q queries follow.\nThe first line of the query contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105) \u2014 the number of elements in the array and the number of subsegments, respectively.\nThe second line of the query contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is the i-th element of a.\nIt is guaranteed that the sum of n over all queries does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each query, print the answer to it. If it is impossible to divide the initial array into exactly k subsegments in such a way that each of them will have odd sum of elements, print \"NO\" in the first line. Otherwise, print \"YES\" in the first line and any possible division of the array in the second line. The division can be represented as k integers r1, r2, ..., rk such that 1\u2264r1<r2<\u22ef<rk=n, where rj is the right border of the j-th segment (the index of the last element that belongs to the j-th segment), so the array is divided into subsegments [1;r1],[r1+1;r2],[r2+1,r3],\u2026,[rk\u22121+1,n]. Note that rk is always n but you should print it anyway. ",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1196B - Odd Sum SegmentsFirstly, let cnt be the number of odd elements in the array. Note that even elements are don't matter at all because they cannot change the parity of the sum.If cnt<k then it is obviously impossible to split the given array into k subsegments with odd sum. And if cnt%2\u2260k%2 then it is impossible to split the array into k subsegments with odd sum also because at least one of k segments will have even number of odd elements (so will have odd sum).In other cases the answer is always \"YES\" and you can print k\u22121 leftmost positions of odd elements and n as right borders of segments (it means that when you find one odd element, you end one segment). Because cnt%2=k%2 now, the last segment will have odd number of odd elements so it will have odd sum also. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint q;\n\tcin >> q;\n\tfor (int i = 0; i < q; ++i) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tvector<int> a(n);\n\t\tint cntodd = 0;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tcin >> a[j];\n\t\t\tcntodd += a[j] % 2;\n\t\t}\n\t\tif (cntodd < k || cntodd % 2 != k % 2) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"YES\" << endl;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (k == 1) break;\n\t\t\tif (a[j] % 2 == 1) {\n\t\t\t\tcout << j + 1 << \" \";\n\t\t\t\t--k;\n\t\t\t}\n\t\t}\n\t\tcout << n << endl;\n\t}\n\treturn 0;\n}"
    },
    "1195B": {
        "title": "B. Sport Mafia",
        "description": "Each evening after the dinner the SIS's students gather together to play the game of Sport Mafia. \nFor the tournament, Alya puts candies into the box, which will serve as a prize for a winner. To do that, she performs n actions. The first action performed is to put a single candy into the box. For each of the remaining moves she can choose from two options:\nThus, if the box is empty, then it can only use the second option.\nFor example, one possible sequence of Alya's actions look as follows:\nThis way she will perform 9 actions, the number of candies at the end will be 11, while Alya will eat 4 candies in total.\nYou know the total number of actions n and the number of candies at the end k. You need to find the total number of sweets Alya ate. That is the number of moves of the first option. It's guaranteed, that for the given n and k the answer always exists.\nPlease note, that during an action of the first option, Alya takes out and eats exactly one candy.\nThe first line contains two integers n and k (1\u2264n\u2264109; 0\u2264k\u2264109)\u00a0\u2014 the total number of moves and the number of candies in the box at the end. \nIt's guaranteed, that for the given n and k the answer exists.\nPrint a single integer\u00a0\u2014 the number of candies, which Alya ate. Please note, that in this problem there aren't multiple possible answers\u00a0\u2014 the answer is unique for any input data. \nIn the first example, Alya has made one move only. According to the statement, the first move is always putting one candy in the box. Hence Alya ate 0 candies.\nIn the second example the possible sequence of Alya's actions looks as follows: \nThis way, she will make exactly n=9 actions and in the end the box will contain 1+2\u22121\u22121+3\u22121+4\u22121+5=11 candies. The answer is 4, since she ate 4 candies in total.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1000"
        ],
        "solutions": "1195B - Sport MafiaIn fact, we need to solve the following equation: x(x+1)2\u2212(n\u2212x)=k and when we will find x we need to print n\u2212x as the answer. x(x+1)2 is the number of candies Alya will put into the box with x turns (sum of arithmetic progression). This equation can be solved mathematically. The only problem is getting the square root, it can be avoided with binary search or taking square root in non-integer numbers and checking some amount of integers in small range nearby the obtained root. The other solution is the binary search by x.  Solution (binary search)#include <iostream>\n#include <cmath>\n\nint main() {\n    long long n, k;\n    std::cin >> n >> k;\n    long long l = -1, r = n + 1;\n    while (r - l > 1) {\n        long long m = (l + r) / 2;\n        if ((n - m) * (n - m + 1) / 2 - m > k)\n            l = m;\n        else\n            r = m;\n    }\n    std::cout << r;\n    return 0;\n} Solution (formula)#include <iostream>\n#include <cmath>\n\nint main() {\n    long long n, k;\n    std::cin >> n >> k;\n    std::cout << static_cast<long long>(round(n + 1.5 - sqrt(2 * (n + k) + 2.75)));\n    return 0;\n}"
    },
    "1195A": {
        "title": "A. Drinks Choosing",
        "description": "Old timers of Summer Informatics School can remember previous camps in which each student was given a drink of his choice on the vechorka (late-evening meal). Or may be the story was more complicated?\nThere are n students living in a building, and for each of them the favorite drink ai is known. So you know n integers a1,a2,\u2026,an, where ai (1\u2264ai\u2264k) is the type of the favorite drink of the i-th student. The drink types are numbered from 1 to k.\nThere are infinite number of drink sets. Each set consists of exactly two portions of the same drink. In other words, there are k types of drink sets, the j-th type contains two portions of the drink j. The available number of sets of each of the k types is infinite.\nYou know that students will receive the minimum possible number of sets to give all students exactly one drink. Obviously, the number of sets will be exactly \u2308n2\u2309, where \u2308x\u2309 is x rounded up.\nAfter students receive the sets, they will distribute their portions by their choice: each student will get exactly one portion. Note, that if n is odd then one portion will remain unused and the students' teacher will drink it.\nWhat is the maximum number of students that can get their favorite drink if \u2308n2\u2309 sets will be chosen optimally and students will distribute portions between themselves optimally?\nThe first line of the input contains two integers n and k (1\u2264n,k\u22641000) \u2014 the number of students in the building and the number of different drinks.\nThe next n lines contain student's favorite drinks. The i-th line contains a single integer from 1 to k \u2014 the type of the favorite drink of the i-th student.\nPrint exactly one integer \u2014 the maximum number of students that can get a favorite drink.\nIn the first example, students could choose three sets with drinks 1, 1 and 2 (so they will have two sets with two drinks of the type 1 each and one set with two drinks of the type 2, so portions will be 1,1,1,1,2,2). This way all students except the second one will get their favorite drinks.\nAnother possible answer is sets with drinks 1, 2 and 3. In this case the portions will be 1,1,2,2,3,3. Then all the students except one will gain their favorite drinks. The only student that will not gain the favorite drink will be a student with ai=1 (i.e. the first, the third or the fourth).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1195A - Drinks ChoosingIdea: budalnikPreparation: budalnik TutorialTutorial is loading... Solution// Created by Nikolay Budin\n\n#ifdef LOCAL\n#  define _GLIBCXX_DEBUG\n#else\n#  define cerr __get_ce\n#endif\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\n\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tmap<int, int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint num;\n\t\tcin >> num;\n\t\thave[num]++;\n\t}\n\tint cnt = 0;\n\tint ans = 0;\n\tfor (pii p : have) {\n\t\tcnt += p.ss % 2;\n\t\tans += p.ss / 2 * 2;\n\t}\n\tans += (cnt + 1) / 2;\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\t\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}"
    },
    "1191B": {
        "title": "B. Tokitsukaze and Mahjong",
        "description": "Tokitsukaze is playing a game derivated from Japanese mahjong. In this game, she has three tiles in her hand. Each tile she owns is a suited tile, which means it has a suit (manzu, pinzu or souzu) and a number (a digit ranged from 1 to 9). In this problem, we use one digit and one lowercase letter, which is the first character of the suit, to represent a suited tile. All possible suited tiles are represented as 1m, 2m, \u2026, 9m, 1p, 2p, \u2026, 9p, 1s, 2s, \u2026, 9s.\nIn order to win the game, she must have at least one mentsu (described below) in her hand, so sometimes she should draw extra suited tiles. After drawing a tile, the number of her tiles increases by one. She can draw any tiles she wants, including those already in her hand.\nDo you know the minimum number of extra suited tiles she needs to draw so that she can win?\nHere are some useful definitions in this game:\nSome examples: \nNote that the order of tiles is unnecessary and you can assume the number of each type of suited tiles she can draw is infinite.\nThe only line contains three strings\u00a0\u2014 the tiles in Tokitsukaze's hand. For each string, the first character is a digit ranged from 1 to 9 and the second character is m, p or s.\nPrint a single integer\u00a0\u2014 the minimum number of extra suited tiles she needs to draw.\nIn the first example, Tokitsukaze already has a shuntsu.\nIn the second example, Tokitsukaze already has a koutsu.\nIn the third example, Tokitsukaze can get a shuntsu by drawing one suited tile\u00a0\u2014 1p or 4p. The resulting tiles will be [3p, 9m, 2p, 1p] or [3p, 9m, 2p, 4p].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "1191B - Tokitsukaze and MahjongIdea: tokitsukaze, 2014CAIS01 TutorialThere are only two types of mentsus, so you can enumerate the mentsu you want her to form, and check the difference between that and those currently in her hand.Alternatively, you can find out that the answer is at most 2, since she can draw two extra identical tiles which are the same as one of those in her hand. You may enumerate at most 1 extra tile for her and check if it can contribute to a mentsu. If she can't, the answer will be 2. Solution (by skywalkert)#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint idx[257] = {}, c[3][9] = {}, ans = 2;\n\tidx['m'] = 1;\n\tidx['p'] = 2;\n\tidx['s'] = 3;\n\tfor(int i = 0; i < 3; ++i) {\n\t\tchar buf[3];\n\t\tscanf(\"%s\", buf);\n\t\t++c[idx[buf[1]] - 1][buf[0] - '1'];\n\t}\n\tfor(int i = 0; i < 3; ++i)\n\t\tfor(int j = 0; j < 9; ++j) {\n\t\t\tans = min(ans, 3 - c[i][j]);\n\t\t\tif(j + 2 < 9)\n\t\t\t\tans = min(ans, 3 - !!c[i][j] - !!c[i][j + 1] - !!c[i][j + 2]);\n\t\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n} Solution (by isaf27)//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n \nusing namespace std;\n \n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define prev _prev\n#define y0 y00\n \n//permanent constants\nconst ld pi = acos(-1.0);\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int alf = 26;\nconst int dig = 10;\nconst int two = 2;\nconst int th = 3;\nconst ll prost = 239;\nconst ll bt = 30;\nconst ld eps = 1e-7;\nconst ll INF = (ll)(1e18 + 239);\nconst int BIG = (int)(1e9 + 239);\nconst int MOD = 998244353;\nconst ll MOD2 = (ll)MOD * (ll)MOD;\n \n//random\nmt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());\n \n//constants\nconst int M = (int)(2e5 + 239);\nconst int N = (int)(2e3 + 239);\nconst int L = 20;\nconst int T = (1 << 20);\nconst int B = (int)sqrt(M);\nconst int X = 1e4 + 239;\n \nbool check(string a, string b, string c)\n{\n    if (a == b && b == c) return true;\n    if (a > b) swap(a, b);\n    if (b > c) swap(b, c);\n    if (a > b) swap(a, b);\n    if (a[1] == b[1] && b[1] == c[1])\n    {\n        if (a[0] + 1 == b[0] && b[0] + 1 == c[0])\n            return true;\n    }\n    return false;\n}\n \nint32_t main()\n{\n#ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    string a, b, c;\n    cin >> a >> b >> c;\n    if (check(a, b, c))\n    {\n        cout << \"0\";\n        return 0;\n    }\n    vector<string> var;\n    for (int i = 1; i <= 9; i++)\n    {\n        string s = \"\";\n        s += (char)(i + '0');\n        var.push_back(s + \"m\");\n        var.push_back(s + \"p\");\n        var.push_back(s + \"s\");\n    }\n    for (string s : var)\n    {\n        if (check(s, a, b))\n        {\n            cout << \"1\";\n            return 0;\n        }\n        if (check(s, a, c))\n        {\n            cout << \"1\";\n            return 0;\n        }\n        if (check(s, b, c))\n        {\n            cout << \"1\";\n            return 0;\n        }\n    }\n    cout << \"2\";\n    return 0;\n}1190A - Tokitsukaze and Discard Items / "
    },
    "1189B": {
        "title": "B. Number Circle",
        "description": "You are given n numbers a1,a2,\u2026,an. Is it possible to arrange them in a circle in such a way that every number is strictly less than the sum of its neighbors?\nFor example, for the array [1,4,5,6,7,8], the arrangement on the left is valid, while arrangement on the right is not, as 5\u22654+1 and 8>1+6.\nThe first line contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the number of numbers.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the numbers. The given numbers are not necessarily distinct (i.e. duplicates are allowed).\nIf there is no solution, output \"NO\" in the first line. \nIf there is a solution, output \"YES\" in the first line. In the second line output n numbers\u00a0\u2014 elements of the array in the order they will stay in the circle. The first and the last element you output are considered neighbors in the circle. If there are multiple solutions, output any of them. You can print the circle starting with any element.\nOne of the possible arrangements is shown in the first example: \n4<2+3;\n2<4+3;\n3<4+2.\nOne of the possible arrangements is shown in the second example.\nNo matter how we arrange 13,8,5 in a circle in the third example, 13 will have 8 and 5 as neighbors, but 13\u22658+5. \nThere is no solution in the fourth example.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1185C1": {
        "title": "C1. Exam in BerSU (easy version)",
        "description": "The only difference between easy and hard versions is constraints.\nA session has begun at Beland State University. Many students are taking exams.\nPolygraph Poligrafovich is going to examine a group of n students. Students will take the exam one-by-one in order from 1-th to n-th. Rules of the exam are following:\nStudents take the exam in the fixed order, one-by-one, without any interruption. At any moment of time, Polygraph Poligrafovich takes the answer from one student.\nThe duration of the whole exam for all students is M minutes (maxti\u2264M), so students at the end of the list have a greater possibility to run out of time to pass the exam.\nFor each student i, you should count the minimum possible number of students who need to fail the exam so the i-th student has enough time to pass the exam.\nFor each student i, find the answer independently. That is, if when finding the answer for the student i1 some student j should leave, then while finding the answer for i2 (i2>i1) the student j student does not have to go home.\nThe first line of the input contains two integers n and M (1\u2264n\u2264100, 1\u2264M\u2264100)\u00a0\u2014 the number of students and the total duration of the exam in minutes, respectively.\nThe second line of the input contains n integers ti (1\u2264ti\u2264100)\u00a0\u2014 time in minutes that i-th student spends to answer to a ticket.\nIt's guaranteed that all values of ti are not greater than M.\nPrint n numbers: the i-th number must be equal to the minimum number of students who have to leave the exam in order to i-th student has enough time to pass the exam.\nThe explanation for the example 1.\nPlease note that the sum of the first five exam times does not exceed M=15 (the sum is 1+2+3+4+5=15). Thus, the first five students can pass the exam even if all the students before them also pass the exam. In other words, the first five numbers in the answer are 0.\nIn order for the 6-th student to pass the exam, it is necessary that at least 2 students must fail it before (for example, the 3-rd and 4-th, then the 6-th will finish its exam in 1+2+5+6=14 minutes, which does not exceed M).\nIn order for the 7-th student to pass the exam, it is necessary that at least 3 students must fail it before (for example, the 2-nd, 5-th and 6-th, then the 7-th will finish its exam in 1+3+4+7=15 minutes, which does not exceed M).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1185C1 - \u042d\u043a\u0437\u0430\u043c\u0435\u043d \u0432 \u0411\u0435\u0440\u0413\u0423 (\u0443\u043f\u0440\u043e\u0449\u0451\u043d\u043d\u0430\u044f \u0432\u0435\u0440\u0441\u0438\u044f)First of all we should precalculate sum si of all students' durations for each student. For i-th student si=si\u22121+ti.Then for each student we can sort all durations ti of passing exam of students, who are before the current student. So, let's walk by these durations from larger to smaller and calculate prefix sum of them Di. We will iterate them until total duration is enough for the current student to pass the exam too, i.e. until si+ti\u2212Di\u2264M. For i-th student the answer is number of iterated durations.Sorting works in O(nlogn), walking by array works in O(n). Total complexity for all students is O(n2logn).Authors: MikeMirzayanov, cannor147 and geranazavr555 Authors' solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int T = 100;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tint sum = 0;\n\tvector<int> t(n), count(T + 1, 0);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t[i];\n\t}\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tint d = sum + t[i] - m, k = 0;\n\t\tif (d > 0) {\n\t\t    for (int j = T; j > 0; j--) {\n\t\t\t\tint x = j * count[j];\n\t\t\t\tif (d <= x) {\n\t\t\t\t\tk += (d + j - 1) / j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tk += count[j];\n\t\t\t\td -= x;\n\t\t\t}\n\t\t}\n\t\tsum += t[i];\n\t\tcount[t[i]]++;\n\t\tcout << k << \" \";\n\t}\n} "
    },
    "1185B": {
        "title": "B. Email from Polycarp",
        "description": "Methodius received an email from his friend Polycarp. However, Polycarp's keyboard is broken, so pressing a key on it once may cause the corresponding symbol to appear more than once (if you press a key on a regular keyboard, it prints exactly one symbol).\nFor example, as a result of typing the word \"hello\", the following words could be printed: \"hello\", \"hhhhello\", \"hheeeellllooo\", but the following could not be printed: \"hell\", \"helo\", \"hhllllooo\".\nNote, that when you press a key, the corresponding symbol must appear (possibly, more than once). The keyboard is broken in a random manner, it means that pressing the same key you can get the different number of letters in the result.\nFor each word in the letter, Methodius has guessed what word Polycarp actually wanted to write, but he is not sure about it, so he asks you to help him.\nYou are given a list of pairs of words. For each pair, determine if the second word could be printed by typing the first one on Polycarp's keyboard.\nThe first line of the input contains one integer n (1\u2264n\u2264105) \u2014 the number of pairs to check. Further input contains n descriptions of pairs.\nThe first line of each description contains a single non-empty word s consisting of lowercase Latin letters. The second line of the description contains a single non-empty word t consisting of lowercase Latin letters. The lengths of both strings are not greater than 106.\nIt is guaranteed that the total length of all words s in the input is not greater than 106. Also, it is guaranteed that the total length of all words t in the input is not greater than 106.\nOutput n lines. In the i-th line for the i-th pair of words s and t print YES if the word t could be printed by typing the word s. Otherwise, print NO.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1184A1": {
        "title": "A1. Heidi Learns Hashing (Easy)",
        "description": "Melody Pond was stolen from her parents as a newborn baby by Madame Kovarian, to become a weapon of the Silence in their crusade against the Doctor. Madame Kovarian changed Melody's name to River Song, giving her a new identity that allowed her to kill the Eleventh Doctor.\nHeidi figured out that Madame Kovarian uses a very complicated hashing function in order to change the names of the babies she steals. In order to prevent this from happening to future Doctors, Heidi decided to prepare herself by learning some basic hashing techniques.\nThe first hashing function she designed is as follows.\nGiven two positive integers (x,y)(x,y) she defines H(x,y):=x2+2xy+x+1H(x,y):=x2+2xy+x+1.\nNow, Heidi wonders if the function is reversible. That is, given a positive integer rr, can you find a pair (x,y)(x,y) (of positive integers) such that H(x,y)=rH(x,y)=r?\nIf multiple such pairs exist, output the one with smallest possible xx. If there is no such pair, output \"NO\".\nThe first and only line contains an integer rr (1\u2264r\u226410121\u2264r\u22641012).\nOutput integers x,yx,y such that H(x,y)=rH(x,y)=r and xx is smallest possible, or \"NO\" if no such pair exists.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1182A": {
        "title": "A. Filling Shapes",
        "description": "You have a given integer n. Find the number of ways to fill all 3\u00d7n tiles with the shape described in the picture below. Upon filling, no empty spaces are allowed. Shapes cannot overlap.\nThe only line contains one integer n (1\u2264n\u226460)\u00a0\u2014 the length.\nPrint the number of ways to fill.\nIn the first example, there are 4 possible cases of filling.\nIn the second example, you cannot fill the shapes in 3\u00d71 tiles.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "math",
            "*1000"
        ],
        "solutions": "1182A - Filling ShapesIf you want to have no empty spaces on 3\u00d7n tiles, you should fill leftmost bottom tile. Then you have only 2 choices;  Both cases force you to group leftmost 3\u00d72 tiles and fill. By this fact, we should group each 3\u00d72 tiles and fill independently. So the answer is\u00a0\u2014 if n is odd, then the answer is 0 (impossible), otherwise, the answer is 2n2.Time complexity is O(1) with bit operation or O(n) with iteration.Solution Code for ABehind story of B: Original B was harder. None of 2100+ rated testers solved original B, so it got downgraded. Also there was more than 15 pretests before. "
    },
    "1181A": {
        "title": "A. Chunga-Changa",
        "description": "Soon after the Chunga-Changa island was discovered, it started to acquire some forms of civilization and even market economy. A new currency arose, colloquially called \"chizhik\". One has to pay in chizhiks to buy a coconut now.\nSasha and Masha are about to buy some coconuts which are sold at price z chizhiks per coconut. Sasha has x chizhiks, Masha has y chizhiks. Each girl will buy as many coconuts as she can using only her money. This way each girl will buy an integer non-negative number of coconuts.\nThe girls discussed their plans and found that the total number of coconuts they buy can increase (or decrease) if one of them gives several chizhiks to the other girl. The chizhiks can't be split in parts, so the girls can only exchange with integer number of chizhiks.\nConsider the following example. Suppose Sasha has 5 chizhiks, Masha has 4 chizhiks, and the price for one coconut be 3 chizhiks. If the girls don't exchange with chizhiks, they will buy 1+1=2 coconuts. However, if, for example, Masha gives Sasha one chizhik, then Sasha will have 6 chizhiks, Masha will have 3 chizhiks, and the girls will buy 2+1=3 coconuts. \nIt is not that easy to live on the island now, so Sasha and Mash want to exchange with chizhiks in such a way that they will buy the maximum possible number of coconuts. Nobody wants to have a debt, so among all possible ways to buy the maximum possible number of coconuts find such a way that minimizes the number of chizhiks one girl gives to the other (it is not important who will be the person giving the chizhiks).\nThe first line contains three integers x, y and z (0\u2264x,y\u22641018, 1\u2264z\u22641018)\u00a0\u2014 the number of chizhics Sasha has, the number of chizhics Masha has and the price of a coconut. \nPrint two integers: the maximum possible number of coconuts the girls can buy and the minimum number of chizhiks one girl has to give to the other.\nThe first example is described in the statement. In the second example the optimal solution is to dot exchange any chizhiks. The girls will buy 3+4=7 coconuts.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solutions": "1181A - Chunga-Changa  It's easy to calculate how much coconuts we will buy: k=\u230ax+yz\u230b (suppose that all money transferred to a single person, this way the number of bought coconuts would be clearly maximal)  If k=\u230axz\u230b+\u230ayz\u230b, then the answer is \u27e8k,0\u27e9. The remaining case is a bit harder.  Let's notice, that there is no need to transfer \u2265z chizhiks, since the one transferring money could have used z chizhiks to buy one more coconut herself.  Also it's optimal to transfer coins such that the remainder modulo z of the receiving part will turn to be exactly zero (we could have simply transfer less for the same effect).  So the answer is \u27e8k,min(z\u2212(xmodz),z\u2212(ymodz))\u27e9.  "
    },
    "1177A": {
        "title": "A. Digits Sequence (Easy Edition)",
        "description": "Let's write all the positive integer numbers one after another from 1 without any delimiters (i.e. as a single string). It will be the infinite sequence starting with 123456789101112131415161718192021222324252627282930313233343536...\nYour task is to print the k-th digit of this sequence.\nThe first and only line contains integer k (1\u2264k\u226410000) \u2014 the position to process (1-based index).\nPrint the k-th digit of the resulting infinite sequence.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1176B": {
        "title": "B. Merge it!",
        "description": "You are given an array a consisting of n integers a1,a2,\u2026,an.\nIn one operation you can choose two elements of the array and replace them with the element equal to their sum (it does not matter where you insert the new element). For example, from the array [2,1,4] you can obtain the following arrays: [3,4], [1,6] and [2,5].\nYour task is to find the maximum possible number of elements divisible by 3 that are in the array after performing this operation an arbitrary (possibly, zero) number of times.\nYou have to answer t independent queries.\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of queries.\nThe first line of each query contains one integer n (1\u2264n\u2264100).\nThe second line of each query contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109). \nFor each query print one integer in a single line \u2014 the maximum possible number of elements divisible by 3 that are in the array after performing described operation an arbitrary (possibly, zero) number of times.\nIn the first query of the example you can apply the following sequence of operations to obtain 3 elements divisible by 3: [3,1,2,3,1]\u2192[3,3,3,1].\nIn the second query you can obtain 3 elements divisible by 3 with the following sequence of operations: [1,1,1,1,1,2,2]\u2192[1,1,1,1,2,3]\u2192[1,1,1,3,3]\u2192[2,1,3,3]\u2192[3,3,3].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1176B - Merge it!Let cnti be the number of elements of a with the remainder i modulo 3. Then the initial answer can be represented as cnt0 and we have to compose numbers with remainders 1 and 2 somehow optimally. It can be shown that the best way to do it is the following: firstly, while there is at least one remainder 1 and at least one remainder 2, let's compose them into one 0. After this, at least one of the numbers cnt1,cnt2 will be zero, then we have to compose remaining numbers into numbers divisible by 3. If cnt1=0 then the maximum remaining number of elements we can obtain is \u230acnt23\u230b (because 2+2+2=6), and in the other case (cnt2=0) the maximum number of elements is \u230acnt13\u230b (because 1+1+1=3). Solution#include<bits/stdc++.h>\n\nusing namespace std;\n\nint t, n;\nint cnt[3];\n\nint main(){\n    cin >> t;\n    for(int tc = 0; tc < t; ++tc){\n        memset(cnt, 0, sizeof cnt);\n        cin >> n;\n        for(int i = 0; i < n; ++i){\n            int x;\n            cin >> x;\n            ++cnt[x % 3];\n        }\n    \t\n    \tint res = cnt[0];\n        int mn = min(cnt[1], cnt[2]);\n        res += mn;\n        cnt[1] -= mn, cnt[2] -= mn;\n        res += (cnt[1] + cnt[2]) / 3;\n        cout << res << endl;\n    }\n    return 0;\n}"
    },
    "1174B": {
        "title": "B. Ehab Is an Odd Person",
        "description": "You're given an array a of length n. You can perform the following operation on it as many times as you want:\nWhat is lexicographically the smallest array you can obtain?\nAn array x is lexicographically smaller than an array y if there exists an index i such that xi<yi, and xj=yj for all 1\u2264j<i. Less formally, at the first index i in which they differ, xi<yi\nThe first line contains an integer n (1\u2264n\u2264105)\u00a0\u2014 the number of elements in the array a.\nThe second line contains n space-separated integers a1, a2, \u2026, an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nThe only line contains n space-separated integers, the lexicographically smallest array you can obtain.\nIn the first example, we can swap 1 and 4 since 1+4=5, which is odd.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "*1200"
        ],
        "solutions": "1174B - Ehab Is an Odd PersonNotice that you can only swap 2 elements if they have different parities. If all elements in the array have the same parity, you can't do any swaps, and the answer will just be like the input. Otherwise, let's prove you can actually swap any pair of elements. Assume you want to swap 2 elements, a and b, and they have the same parity. There must be a third element c that has a different parity. Without loss of generality, assume the array is [a,b,c]. You'll do the following swaps:  Swap a and c: [c,b,a]. Swap b and c: [b,c,a]. Swap a and c: [b,a,c]. In other words, you'll use c as an intermediate element to swap a and b, and it'll return to its original position afterwards! Since you can swap any pair of elements, you can always sort the array, which is the lexicographically smallest permutation.Code link: https://pastebin.com/xhqGXLiuTime complexity: O(nlog(n))."
    },
    "1174A": {
        "title": "A. Ehab Fails to Be Thanos",
        "description": "You're given an array a of length 2n. Is it possible to reorder it in such way so that the sum of the first n elements isn't equal to the sum of the last n elements?\nThe first line contains an integer n (1\u2264n\u22641000), where 2n is the number of elements in the array a.\nThe second line contains 2n space-separated integers a1, a2, \u2026, a2n (1\u2264ai\u2264106)\u00a0\u2014 the elements of the array a.\nIf there's no solution, print \"-1\" (without quotes). Otherwise, print a single line containing 2n space-separated integers. They must form a reordering of a. You are allowed to not change the order.\nIn the first example, the first n elements have sum 2+1+3=6 while the last n elements have sum 1+1+2=4. The sums aren't equal.\nIn the second example, there's no solution.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1174A - Ehab Fails to Be ThanosIf all elements in the array are equal, there's no solution. Otherwise, sort the array. The sum of the second half will indeed be greater than that of the first half.Another solution is to see if they already have different sums. If they do, print the array as it is. Otherwise, find any pair of different elements from different halves and swap them.Code link: https://pastebin.com/FDXTuDdZ"
    },
    "1173B": {
        "title": "B. Nauuo and Chess",
        "description": "Nauuo is a girl who loves playing chess.\nOne day she invented a game by herself which needs n chess pieces to play on a m\u00d7m chessboard. The rows and columns are numbered from 1 to m. We denote a cell on the intersection of the r-th row and c-th column as (r,c).\nThe game's goal is to place n chess pieces numbered from 1 to n on the chessboard, the i-th piece lies on (ri,ci), while the following rule is satisfied: for all pairs of pieces i and j, |ri\u2212rj|+|ci\u2212cj|\u2265|i\u2212j|. Here |x| means the absolute value of x.\nHowever, Nauuo discovered that sometimes she couldn't find a solution because the chessboard was too small.\nShe wants to find the smallest chessboard on which she can put n pieces according to the rules.\nShe also wonders how to place the pieces on such a chessboard. Can you help her?\nThe only line contains a single integer n (1\u2264n\u22641000) \u2014 the number of chess pieces for the game.\nThe first line contains a single integer \u2014 the minimum value of m, where m is the length of sides of the suitable chessboard.\nThe i-th of the next n lines contains two integers ri and ci (1\u2264ri,ci\u2264m) \u2014 the coordinates of the i-th chess piece.\nIf there are multiple answers, print any.\nIn the first example, you can't place the two pieces on a 1\u00d71 chessboard without breaking the rule. But you can place two pieces on a 2\u00d72 chessboard like this:\n\nIn the second example, you can't place four pieces on a 2\u00d72 chessboard without breaking the rule. For example, if you place the pieces like this:\n\nthen |r1\u2212r3|+|c1\u2212c3|=|1\u22122|+|1\u22121|=1, |1\u22123|=2, 1<2; and |r1\u2212r4|+|c1\u2212c4|=|1\u22122|+|1\u22122|=2, |1\u22124|=3, 2<3. It doesn't satisfy the rule.\nHowever, on a 3\u00d73 chessboard, you can place four pieces like this:\n",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solutions": "1173B - Nauuo and ChessIdea: furry Tutorial m\u2265\u230an2\u230b+1 Consider the chess pieces 1 and n.\u2235\u23a7\u23a9\u23a8|r1\u2212rn|+|c1\u2212cn|\u2265n\u22121|r1\u2212rn|\u2264m\u22121|c1\u2212cn|\u2264m\u22121\u2234m\u22121+m\u22121\u2265n\u22121\u2234m\u2265n+12\u2235m\u00a0is an integer\u2234m\u2265\u230an2\u230b+1  m can be \u230an2\u230b+1 If we put the i-th piece on (ri,ci) satisfying ri+ci=i+1, it is a feasible plan, because |ri\u2212rj|+|ci\u2212cj|\u2265|ri+ci\u2212rj\u2212cj|. Solution#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int n, i, ans;\n\n    scanf(\"%d\", &n);\n    ans = n / 2 + 1;\n\n    printf(\"%d\", ans);\n\n    for (i = 1; i <= ans; ++i) printf(\"\\n%d 1\", i);\n    for (i = 2; i <= n - ans + 1; ++i) printf(\"\\n%d %d\", ans, i);\n\n    return 0;\n}\n1172A - Nauuo and CardsIdea: QAQAutoMaton TutorialFirst, try to finish it without playing any empty cards.If that's not possible, the best choice is to play several empty cards in a row, then play from 1 to n. For a card i, suppose that it is in the pi-th position in the pile (pi=0 if it is in the hand), you have to play at least pi\u2212i+1 empty cards. So the answer will be max{pi\u2212i+1+n}. Solution#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200010;\n\nint n, a[N], b[N], p[N], ans;\n\nint main()\n{\n    int i, j;\n\n    scanf(\"%d\", &n);\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", a + i);\n        p[a[i]] = 0;\n    }\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", b + i);\n        p[b[i]] = i;\n    }\n\n    if (p[1])\n    {\n        for (i = 2; p[i] == p[1] + i - 1; ++i);\n        if (p[i - 1] == n)\n        {\n            for (j = i; j <= n && p[j] <= j - i; ++j);\n            if (j > n)\n            {\n                printf(\"%d\", n - i + 1);\n                return 0;\n            }\n        }\n    }\n\n    for (i = 1; i <= n; ++i) ans = max(ans, p[i] - i + 1 + n);\n\n    printf(\"%d\", ans);\n\n    return 0;\n}1172B - Nauuo and CircleIdea: furry TutorialFirst, if we choose a node as the root, then each subtree must be in a continuous arc on the circle. Then, we can use DP to solve this problem.Let fu be the number of plans to draw the subtree of u, then fu=(|son(u)|+[u\u2260root])!\u220fv\u2208son(u)fv \u2014 choose a position for each subtree and then u itself, then draw the subtrees. However, instead of choosing the position of the root, we suppose the root is on a certain point on the circle, then rotate the circle, thus get the answer: nfroot.In fact, we don't have to write a DP, the answer is n times the product of the factorial of each node's degree (n\u220fi=1ndegree[i]!). Solution#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int mod = 998244353;\n\nint n, ans, d[N];\n\nint main()\n{\n    int i, u, v;\n\n    scanf(\"%d\", &n);\n    ans = n;\n\n    for (i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        ans = (ll) ans * (++d[u]) % mod * (++d[v]) % mod;\n    }\n\n    cout << ans;\n\n    return 0;\n}1172C1 - Nauuo and Pictures (easy version) and 1172C2 - Nauuo and Pictures (hard version)Idea: ouuan TutorialFirst, let's focus on a single picture with weight w which Nauuo likes, so we only have to know the sum of the weights of the pictures Nauuo likes (SA=\u2211i=1nwi[ai=1]) and the sum of the disliked ones (SB=\u2211i=1nwi[ai=0]) instead of all the n weights.Then, we can use DP to solve this problem.Let fw[i][j][k] be the expected weight of a picture Nauuo likes with weight w after another i visits since SA=j and SB=k.Obviously, fw[0][j][k]=w.The state transition:  The next visit displays the picture we focus on. Probaility: wj+k. Lead to: fw+1[i\u22121][j+1][k]. The next visit displays a picture Nauuo likes but is not the one we focus on. Probaility: j\u2212wj+k. Lead to: fw[i\u22121][j+1][k]. The next visit displays a picture Nauuo doesn't like. Probaility: kj+k. Lead to: fw[i\u22121][j][k\u22121]. So, fw[i][j][k]=wj+kfw+1[i\u22121][j+1][k]+j\u2212wj+kfw[i\u22121][j+1][k]+kj+kfw[i\u22121][j][k\u22121].Let gw[i][j][k] be the expected weight of a picture Nauuo doesn't like with weight w after another i visits since SA=j and SB=k. The state transition is similar.Note that i,j,k,m have some relation. In fact we can let f\u2032w[i][j] be fw[m\u2212i\u2212j][SA+i][SB\u2212j] (SA and SB are the initial ones here).But up to now, we can only solve the easy version.To solve the hard version, let's introduce a lemma: fw[i][j][k]=wf1[i][j][k]Proof:Obviously, this is true when i=0.Then, suppose we have already proved fw[i\u22121][j][k]=wf1[i\u22121][j][k].f1[i][j][k]=1j+kf2[i\u22121][j+1][k]+j\u22121j+kf1[i\u22121][j+1][k]+kj+kf1[i\u22121][j][k\u22121]=2j+kf1[i\u22121][j+1][k]+j\u22121j+kf1[i\u22121][j+1][k]+kj+kf1[i\u22121][j][k\u22121]=j+1j+kf1[i\u22121][j+1][k]+kj+kf1[i\u22121][j][k\u22121]fw[i][j][k]=wj+kfw+1[i\u22121][j+1][k]+j\u2212wj+kfw[i\u22121][j+1][k]+kj+kfw[i\u22121][j][k\u22121]=w(w+1)j+kf1[i\u22121][j+1][k]+w(j\u2212w)j+kf1[i\u22121][j+1][k]+wkj+kf1[i\u22121][j][k\u22121]=w(j+1)j+kf1[i\u22121][j+1][k]+wkj+kf1[i\u22121][j][k\u22121]=wf1[i][j][k]Also, a brief but not so strict proof: the increment in each step is proportional to the expectation.So, we only have to calculate f1[i][j][k] (f\u20321[i][j]).In conclusion:f\u20321[i][j]=1\u00a0(i+j=m)f\u20321[i][j]=SA+i+1SA+SB+i\u2212jf\u20321[i+1][j]+SB\u2212jSA+SB+i\u2212jf\u20321[i][j+1]\u00a0(i+j<m)g\u20321[i][j]=1\u00a0(i+j=m)g\u20321[i][j]=SA+iSA+SB+i\u2212jg\u20321[i+1][j]+SB\u2212j\u22121SA+SB+i\u2212jg\u20321[i][j+1]\u00a0(i+j<m)If ai=1, the expected weight of the i-th picture is wif\u20321[0][0], otherwise, the expected weight is wig\u20321[0][0].Last question: how to calculate the result modulo 998244353?If you don't know how, please read the wiki to learn it.You can calculate and store all the O(m) inverses at first, then you can get an O(n+m2+mlogp) solution instead of O(n+m2logp) (p=998244353 here). Solution#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 200010;\nconst int M = 3010;\nconst int mod = 998244353;\n\nint qpow(int x, int y) //calculate the modular multiplicative inverse\n{\n\tint out = 1;\n\twhile (y)\n\t{\n\t\tif (y & 1) out = (ll) out * x % mod;\n\t\tx = (ll) x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn out;\n}\n\nint n, m, a[N], w[N], f[M][M], g[M][M], inv[M << 1], sum[3];\n\nint main()\n{\n\tint i,j;\n\t\n\tscanf(\"%d%d\", &n, &m);\n\t\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\t\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", w + i);\n\t\tsum[a[i]] += w[i];\n\t\tsum[2] += w[i];\n\t}\n\t\n\tfor (i = max(0, m - sum[0]); i <= 2 * m; ++i) inv[i] = qpow(sum[2] + i - m, mod - 2);\n\t\n\tfor (i = m; i >= 0; --i)\n\t{\n\t\tf[i][m - i] = g[i][m - i] = 1;\n\t\tfor (j = min(m - i - 1, sum[0]); j >= 0; --j)\n\t\t{\n\t\t\tf[i][j] = ((ll) (sum[1] + i + 1) * f[i + 1][j] + (ll) (sum[0] - j) * f[i][j + 1]) % mod * inv[i - j + m] % mod;\n\t\t\tg[i][j] = ((ll) (sum[1] + i) * g[i + 1][j] + (ll) (sum[0] - j - 1) * g[i][j + 1]) % mod * inv[i - j + m] % mod;\n\t\t}\n\t}\n\t\n\tfor (i = 1; i <= n; ++i) printf(\"%d\\n\", int((ll) w[i] * (a[i] ? f[0][0] : g[0][0]) % mod));\n\t\n\treturn 0;\n}1172D - Nauuo and PortalsIdea: furry TutorialConsider this problem:the person in (i,1) facing right is numbered ai, the person in (1,i) facing bottom is numbered bi. The person numbered pi has to exit the grid from (i,n), the person numbered qi has to exit the grid from (n,i).The original problem can be easily transferred to this problem. And now let's transfer it into an (n\u22121)\u00d7(n\u22121) subproblem by satisfying the requirement of the first row and the first column.If a1=p1 and b1=q1, you can simply do nothing and get an (n\u22121)\u00d7(n\u22121) subproblem.Otherwise, you can set a portal consisting of two doors in (x,1) and (1,y) where ax=p1 and by=q1. Swap a1 and ax, b1 and by, then you will get an (n\u22121)\u00d7(n\u22121) subproblem.Then, you can solve the problem until it changes into a 1\u00d71 one.This problem can be solved in O(n), but the checker needs O(n2). Solution#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 1010;\n\nstruct Portal\n{\n\tint x, y, p, q;\n\tPortal(int _x, int _y, int _p, int _q): x(_x), y(_y), p(_p), q(_q) {}\n};\nvector<Portal> ans;\nint n, a[N], b[N], c[N], d[N], ra[N], rb[N], rc[N], rd[N];\n\nint main()\n{\n\tint i;\n\t\n\tscanf(\"%d\", &n);\n\t\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", b + i);\n\t\trb[b[i]] = i;\n\t}\n\tfor (i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\tra[a[i]] = i;\n\t}\n\tfor (i = 1; i <= n; ++i) c[i] = d[i] = rc[i] = rd[i] = i;\n\t\n\tfor (i = 1; i < n; ++i)\n\t{\n\t\tif (c[i] == ra[i] && d[i] == rb[i]) continue;\n\t\tans.push_back(Portal(i, rc[ra[i]], rd[rb[i]], i));\n\t\tint t1 = c[i];\n\t\tint t2 = d[i];\n\t\tswap(c[i], c[rc[ra[i]]]);\n\t\tswap(d[i], d[rd[rb[i]]]);\n\t\tswap(rc[ra[i]], rc[t1]);\n\t\tswap(rd[rb[i]], rd[t2]);\n\t}\n\t\n\tprintf(\"%d\\n\", ans.size());\n\tfor (auto k : ans) printf(\"%d %d %d %d\\n\", k.x, k.y, k.p, k.q);\n\t\n\treturn 0;\n}1172E - Nauuo and ODTIdea: ODT TutorialFor each color, we can try to maintain the number of simple paths that do not contain such color.If we can maintain such information, we can easily calculate the number of simple paths that contain a certain color, thus get the answer.For each color, we delete all nodes that belong to such color, thus splitting the tree into some clusters (here we define a \"cluster\" as a connected subgraph of the original tree).By maintaining \u2211cluster size2, we can get the number of simple paths that do not contain such color.For each color we try to maintain the same information, add them together, and get the answer.So now the problem is: a white tree  reverse the color of a node ( white <-> black ) output \u2211cluster size2 This problem can be solved by many data structures like top tree, link/cut tree or heavy path decomposition.Let's use the link/cut tree for example.You can maintain the size of each subtree and the sum of size2 of each node's sons. Link/cut one node with its father (choose a node as the root and make the tree a rooted-tree first) when its color changes. In this way, the real clusters are the ones that are still connected after deleting the top node of a cluster in the link/cut tree. Update \u2211cluster size2 while linking/cutting.link:cut: Solution#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 400010;\n\nstruct Node\n{\n    int fa, ch[2], siz, sizi;\n    ll siz2i;\n    ll siz2() { return (ll) siz * siz; }\n} t[N];\n\nbool nroot(int x);\nvoid rotate(int x);\nvoid Splay(int x);\nvoid access(int x);\nint findroot(int x);\nvoid link(int x);\nvoid cut(int x);\nvoid pushup(int x);\n\nvoid add(int u, int v);\nvoid dfs(int u);\n\nint head[N], nxt[N << 1], to[N << 1], cnt;\nint n, m, c[N], f[N];\nll ans, delta[N];\nbool bw[N];\nvector<int> mod[N][2];\n\nint main()\n{\n    int i, j, u, v;\n    ll last;\n\n    scanf(\"%d%d\", &n, &m);\n\n    for (i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", c + i);\n        mod[c[i]][0].push_back(i);\n        mod[c[i]][1].push_back(0);\n    }\n\n    for (i = 1; i <= n + 1; ++i) t[i].siz = 1;\n\n    for (i = 1; i < n; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        add(u, v);\n        add(v, u);\n    }\n\n    for (i = 1; i <= m; ++i)\n    {\n        scanf(\"%d%d\", &u, &v);\n        mod[c[u]][0].push_back(u);\n        mod[c[u]][1].push_back(i);\n        c[u] = v;\n        mod[v][0].push_back(u);\n        mod[v][1].push_back(i);\n    }\n\n    f[1] = n + 1;\n    dfs(1);\n\n    for (i = 1; i <= n; ++i) link(i);\n\n    for (i = 1; i <= n; ++i)\n    {\n        if (!mod[i][0].size())\n        {\n            delta[0] += (ll)n * n;\n            continue;\n        }\n        if (mod[i][1][0])\n        {\n            delta[0] += (ll)n * n;\n            last = (ll)n * n;\n        } else\n            last = 0;\n        for (j = 0; j < mod[i][0].size(); ++j)\n        {\n            u = mod[i][0][j];\n            if (bw[u] ^= 1)\n                cut(u);\n            else\n                link(u);\n            if (j == mod[i][0].size() - 1 || mod[i][1][j + 1] != mod[i][1][j])\n            {\n                delta[mod[i][1][j]] += ans - last;\n                last = ans;\n            }\n        }\n        for (j = mod[i][0].size() - 1; ~j; --j)\n        {\n            u = mod[i][0][j];\n            if (bw[u] ^= 1)\n                cut(u);\n            else\n                link(u);\n        }\n    }\n\n    ans = (ll) n * n * n;\n    for (i = 0; i <= m; ++i)\n    {\n        ans -= delta[i];\n        printf(\"%I64d \", ans);\n    }\n\n    return 0;\n}\n\nbool nroot(int x) { return x == t[t[x].fa].ch[0] || x == t[t[x].fa].ch[1]; }\n\nvoid rotate(int x)\n{\n    int y = t[x].fa;\n    int z = t[y].fa;\n    int k = x == t[y].ch[1];\n    if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x;\n    t[x].fa = z;\n    t[y].ch[k] = t[x].ch[k ^ 1];\n    t[t[x].ch[k ^ 1]].fa = y;\n    t[x].ch[k ^ 1] = y;\n    t[y].fa = x;\n    pushup(y);\n    pushup(x);\n}\n\nvoid Splay(int x)\n{\n    while (nroot(x))\n    {\n        int y = t[x].fa;\n        int z = t[y].fa;\n        if (nroot(y)) (x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? rotate(x) : rotate(y);\n        rotate(x);\n    }\n}\n\nvoid access(int x)\n{\n    for (int y = 0; x; x = t[y = x].fa)\n    {\n        Splay(x);\n        t[x].sizi += t[t[x].ch[1]].siz;\n        t[x].sizi -= t[y].siz;\n        t[x].siz2i += t[t[x].ch[1]].siz2();\n        t[x].siz2i -= t[y].siz2();\n        t[x].ch[1] = y;\n        pushup(x);\n    }\n}\n\nint findroot(int x)\n{\n    access(x);\n    Splay(x);\n    while (t[x].ch[0]) x = t[x].ch[0];\n    Splay(x);\n    return x;\n}\n\nvoid link(int x)\n{\n    int y = f[x];\n    Splay(x);\n    ans -= t[x].siz2i + t[t[x].ch[1]].siz2();\n    int z = findroot(y);\n    access(x);\n    Splay(z);\n    ans -= t[t[z].ch[1]].siz2();\n    t[x].fa = y;\n    Splay(y);\n    t[y].sizi += t[x].siz;\n    t[y].siz2i += t[x].siz2();\n    pushup(y);\n    access(x);\n    Splay(z);\n    ans += t[t[z].ch[1]].siz2();\n}\n\nvoid cut(int x)\n{\n    int y = f[x];\n    access(x);\n    ans += t[x].siz2i;\n    int z = findroot(y);\n    access(x);\n    Splay(z);\n    ans -= t[t[z].ch[1]].siz2();\n    Splay(x);\n    t[x].ch[0] = t[t[x].ch[0]].fa = 0;\n    pushup(x);\n    Splay(z);\n    ans += t[t[z].ch[1]].siz2();\n}\n\nvoid pushup(int x)\n{\n    t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + t[x].sizi + 1;\n}\n\nvoid add(int u, int v)\n{\n    nxt[++cnt] = head[u];\n    head[u] = cnt;\n    to[cnt] = v;\n}\n\nvoid dfs(int u)\n{\n    int i, v;\n    for (i = head[u]; i; i = nxt[i])\n    {\n        v = to[i];\n        if (v != f[u])\n        {\n            f[v] = u;\n            dfs(v);\n        }\n    }\n}1172F - Nauuo and BugIdea: rushcheyo TutorialAt first, let's solve this problem in O(nnlogn\u2212\u2212\u2212\u2212\u2212\u221a).Let's split our array into blocks by B integers, and let's find a function, f(x)= which value you will get at the end of the current block if you will start with x. With simple induction, you can prove that this function is a piece-wise linear, and it has O(B) segments, so you can build it iteratively in O(B2) time for each block, so the preprocessing took O(nB).And to answer the query, you can keep the current value of x and then find with binary search by that piece-wise linear function the f(x) for the current block.With a good choice of B, this solution will work in O(nnlogn\u2212\u2212\u2212\u2212\u2212\u221a).Ok, but then how to solve it in O(nlog+qlog2)?Lemma: each segment of this piece-wise linear function has length at least p.You can prove it with simple induction.And then, with this lemma, it is possible by two functions f(x) of size n and g(x) of size m find the new function h(x)=g(f(x)), in the O(n+m), you can do it with two pointers, similar to the previous iterative method, but adding a several points to the function each time, best way to understand it is to check the indendent solution :) Solution#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1000005;\nconst ll inf = (ll)1e16;\nint n, m, P, a[N];\nll sum[N];\nvector<ll> func[N << 2];\n\nvector<ll> merge(int l, int r, int mid, const vector<ll> &f, const vector<ll> &g) {\n\tll suml = sum[mid] - sum[l - 1], sumr = sum[r] - sum[mid];\n\tvector<ll> ret(f.size() + g.size() - 1, inf);\n\tfor (int i = 0, j = 0; i < (int)f.size(); ++i) {\n\t\tll xl = f[i], xr = (i + 1 == (int)f.size() ? inf : f[i + 1] - 1), yl = xl + suml - (ll)i * P, yr = xr + suml - (ll)i * P;\n\t\twhile (j > 0 && g[j] > yl) --j;\n\t\twhile (j < (int)g.size() && (j == 0 || g[j] <= yl)) ++j;\n\t\t--j;\n\t\tfor (; j < (int)g.size() && g[j] <= yr; ++j)\n\t\t\tret[i + j] = min(ret[i + j], max(xl, g[j] - suml + (ll)i * P));\n\t}\n\tret[0] = -inf;\n\treturn ret;\n}\nvoid build(int u, int l, int r) {\n\tif (l == r) {\n\t\tfunc[u].push_back(-inf);\n\t\tfunc[u].push_back(P - a[l]);\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(u << 1, l, mid);\n\tbuild(u << 1 | 1, mid + 1, r);\n\tfunc[u] = merge(l, r, mid, func[u << 1], func[u << 1 | 1]);\n}\nll query(int u, int l, int r, int ql, int qr, ll now) {\n\tif (l >= ql && r <= qr)\n\t\treturn now + sum[r] - sum[l - 1] - (ll)P * (upper_bound(func[u].begin(), func[u].end(), now) - func[u].begin() - 1);\n\tint mid = l + r >> 1;\n\tif (qr <= mid)\n\t\treturn query(u << 1, l, mid, ql, qr, now);\n\tif (ql > mid)\n\t\treturn query(u << 1 | 1, mid + 1, r, ql, qr, now);\n\treturn query(u << 1 | 1, mid + 1, r, ql, qr, query(u << 1, l, mid, ql, qr, now));\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &m, &P);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i), sum[i] = sum[i - 1] + a[i];\n\tbuild(1, 1, n);\n\tfor (int l, r; m--;) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tprintf(\"%I64d\\n\", query(1, 1, n, l, r, 0));\n\t}\n\treturn 0;\n}We had prepared a problem similar to "
    },
    "1166B": {
        "title": "B. All the Vowels Please",
        "description": "Tom loves vowels, and he likes long words with many vowels. His favorite words are vowelly words. We say a word of length k is vowelly if there are positive integers n and m such that n\u22c5m=k and when the word is written by using n rows and m columns (the first row is filled first, then the second and so on, with each row filled from left to right), every vowel of the English alphabet appears at least once in every row and every column.\nYou are given an integer k and you must either print a vowelly word of length k or print \u22121 if no such word exists.\nIn this problem the vowels of the English alphabet are 'a', 'e', 'i', 'o' ,'u'.\nInput consists of a single line containing the integer k (1\u2264k\u2264104)\u00a0\u2014 the required length.\nThe output must consist of a single line, consisting of a vowelly word of length k consisting of lowercase English letters if it exists or \u22121 if it does not.\nIf there are multiple possible words, you may output any of them.\nIn the second example, the word \"agoeuioaeiruuimaeoieauoweouoiaouimae\" can be arranged into the following 6\u00d76 grid:\nIt is easy to verify that every row and every column contain all the vowels.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1166B - All the Vowels PleaseFirst, which boards could we feasibly fill with characters satisfying that every row and column contains one vowel at least once? Well, if we have a board with less than 5 rows, then each column contains less than 5 characters, so we cannot have every vowel on each column, and we can't fill the board. Similarly, we can't fill a board with less than 5 columns.Ok, so say now that we have a board with at least 5 rows and at least 5 columns. Can we fill it? Yes we can! It's enough to fill it by diagonals, as shown in the following picture:  Now we can easily solve the problem. If n\u22c5m=k, then n must divide k and m=kn. So we can iterate over all possible n from 5 to k, check whether n divides k and in that case, check whether m=kn is at least 5. If this works for at least one value of n then we can fill the n\u22c5m board by diagonals as shown before, and obtain our vowelly word by reading the characters row by row. If we don't find any values of n satisfying this, then no vowelly word exists.Complexity: O(k). "
    },
    "1165B": {
        "title": "B. Polycarp Training",
        "description": "Polycarp wants to train before another programming competition. During the first day of his training he should solve exactly 1 problem, during the second day \u2014 exactly 2 problems, during the third day \u2014 exactly 3 problems, and so on. During the k-th day he should solve k problems.\nPolycarp has a list of n contests, the i-th contest consists of ai problems. During each day Polycarp has to choose exactly one of the contests he didn't solve yet and solve it. He solves exactly k problems from this contest. Other problems are discarded from it. If there are no contests consisting of at least k problems that Polycarp didn't solve yet during the k-th day, then Polycarp stops his training.\nHow many days Polycarp can train if he chooses the contests optimally?\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of contests.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5105) \u2014 the number of problems in the i-th contest.\nPrint one integer \u2014 the maximum number of days Polycarp can train if he chooses the contests optimally.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1165B - Polycarp TrainingAfter sorting the array, we can maintain the last day Polycarp can train, in the variable pos. Initially it is 1. Let's iterate over all elements of the sorted array in non-decreasing order and if the current element ai\u2265pos then let's increase pos by one. The answer will be pos\u22121. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\t\n\tint pos = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] >= pos) ++pos;\n\t}\n\t\n\tcout << pos - 1 << endl;\n\t\n\treturn 0;\n}"
    },
    "1165A": {
        "title": "A. Remainder",
        "description": "You are given a huge decimal number consisting of n digits. It is guaranteed that this number has no leading zeros. Each digit of this number is either 0 or 1.\nYou may perform several (possibly zero) operations with this number. During each operation you are allowed to change any digit of your number; you may change 0 to 1 or 1 to 0. It is possible that after some operation you can obtain a number with leading zeroes, but it does not matter for this problem.\nYou are also given two integers 0\u2264y<x<n. Your task is to calculate the minimum number of operations you should perform to obtain the number that has remainder 10y modulo 10x. In other words, the obtained number should have remainder 10y when divided by 10x.\nThe first line of the input contains three integers n,x,y (0\u2264y<x<n\u22642\u22c5105) \u2014 the length of the number and the integers x and y, respectively.\nThe second line of the input contains one decimal number consisting of n digits, each digit of this number is either 0 or 1. It is guaranteed that the first digit of the number is 1.\nPrint one integer \u2014 the minimum number of operations you should perform to obtain the number having remainder 10y modulo 10x. In other words, the obtained number should have remainder 10y when divided by 10x.\nIn the first example the number will be 11010100100 after performing one operation. It has remainder 100 modulo 100000.\nIn the second example the number will be 11010100010 after performing three operations. It has remainder 10 modulo 100000.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1165A - RemainderIdea: vovuh TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, x, y;\n\tstring s;\n\tcin >> n >> x >> y >> s;\n\t\n\tint ans = 0;\n\tfor (int i = n - x; i < n; ++i) {\n\t\tif (i == n - y - 1) ans += s[i] != '1';\n\t\telse ans += s[i] != '0';\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
    },
    "1157A": {
        "title": "A. Reachable Numbers",
        "description": "Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero. For example, \nWe say that some number y is reachable from x if we can apply function f to x some (possibly zero) times so that we get y as a result. For example, 102 is reachable from 10098 because f(f(f(10098)))=f(f(10099))=f(101)=102; and any number is reachable from itself.\nYou are given a number n; your task is to count how many different numbers are reachable from n.\nThe first line contains one integer n (1\u2264n\u2264109).\nPrint one integer: the number of different numbers that are reachable from n.\nThe numbers that are reachable from 1098 are:\n1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,1098,1099.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "1157A - Reachable NumbersThe key fact in this problem is that the answer is not very large (in fact, it's not greater than 91). Why is it so? Every 10 times we apply function f to our current number, it gets divided by 10 (at least), and the number of such divisions is bounded as O(logn).So we can just do the following: store all reachable numbers somewhere, and write a loop that adds current number n to reachable numbers, and sets n=f(n) (we should end this loop when n already belongs to reachable numbers). The most convenient way to store reachable numbers is to use any data structure from your favourite programming language that implemenets a set, but, in fact, the constrains were so small that it was possible to store all reachable numbers in an array. Solutiondef f(x):\n\tx += 1\n\twhile(x % 10 == 0):\n\t\tx //= 10\n\treturn x\n\na = set()\nn = int(input())\n\nwhile(not(n in a)):\n\ta.add(n)\n\tn = f(n)\n\nprint(len(a))"
    },
    "1155B": {
        "title": "B. Game with Telephone Numbers",
        "description": "A telephone number is a sequence of exactly 11 digits such that its first digit is 8.\nVasya and Petya are playing a game. Initially they have a string s of length n (n is odd) consisting of digits. Vasya makes the first move, then players alternate turns. In one move the player must choose a character and erase it from the current string. For example, if the current string 1121, after the player's move it may be 112, 111 or 121. The game ends when the length of string s becomes 11. If the resulting string is a telephone number, Vasya wins, otherwise Petya wins.\nYou have to determine if Vasya has a winning strategy (that is, if Vasya can win the game no matter which characters Petya chooses during his moves).\nThe first line contains one integer n (13\u2264n<105, n is odd) \u2014 the length of string s.\nThe second line contains the string s (|s|=n) consisting only of decimal digits.\nIf Vasya has a strategy that guarantees him victory, print YES.\nOtherwise print NO.\nIn the first example Vasya needs to erase the second character. Then Petya cannot erase a character from the remaining string 880011223344 so that it does not become a telephone number.\nIn the second example after Vasya's turn Petya can erase one character character 8. The resulting string can't be a telephone number, because there is no digit 8 at all.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1155B - Game with Telephone NumbersLet's understand how players should act. Vasya needs to delete the first digit that is not equal to 8, because the first digit of telephone number should be 8, and the first digit not equal to 8 is preventing it.Petya needs to delete the first digit equal to 8, for the same reasons.So, all that we need to do is delete first n\u2212112 digits not equal to 8 (if they exist), and first n\u2212112 digits equal to 8 (again if they exist). It's enough to stop when there is either no 8's left or no non-8's because the latter moves won't change the result of the game anyway. Finally, if first digit of resulting string is 8, then Vasya wins, otherwise Petya.Overall complexity: O(n). Solution (Roms)#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring s;\n\nint main(){\n    cin >> n >> s;\n    int cnt1 = (n - 11) / 2;\n    int cnt2 = cnt1;\n    string res = \"\";\n    for(int i = 0; i < n; ++i){\n        if(s[i] == '8'){\n            if(cnt1 > 0) --cnt1;\n            else res += s[i];\n        }\n        else{\n            if(cnt2 > 0) --cnt2;\n            else res += s[i];\n        }\n    }\n    \n    if(res[0] == '8') cout << \"YES\\n\";\n    else cout << \"NO\\n\";\n\treturn 0;\n}"
    },
    "1155A": {
        "title": "A. Reverse a Substring",
        "description": "You are given a string s consisting of n lowercase Latin letters.\nLet's define a substring as a contiguous subsegment of a string. For example, \"acab\" is a substring of \"abacaba\" (it starts in position 3 and ends in position 6), but \"aa\" or \"d\" aren't substrings of this string. So the substring of the string s from position l to position r is s[l;r]=slsl+1\u2026sr.\nYou have to choose exactly one of the substrings of the given string and reverse it (i.\u2009e. make s[l;r]=srsr\u22121\u2026sl) to obtain a string that is less lexicographically. Note that it is not necessary to obtain the minimum possible string.\nIf it is impossible to reverse some substring of the given string to obtain a string that is less, print \"NO\". Otherwise print \"YES\" and any suitable substring.\nString x is lexicographically less than string y, if either x is a prefix of y (and x\u2260y), or there exists such i (1\u2264i\u2264min(|x|,|y|)), that xi<yi, and for any j (1\u2264j<i) xj=yj. Here |a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator < in modern programming languages\u200b\u200b.\nThe first line of the input contains one integer n (2\u2264n\u22643\u22c5105) \u2014 the length of s.\nThe second line of the input contains the string s of length n consisting only of lowercase Latin letters.\nIf it is impossible to reverse some substring of the given string to obtain a string which is lexicographically less, print \"NO\". Otherwise print \"YES\" and two indices l and r (1\u2264l<r\u2264n) denoting the substring you have to reverse. If there are multiple answers, you can print any.\nIn the first testcase the resulting string is \"aacabba\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "strings",
            "*1000"
        ],
        "solutions": "1155A - Reverse a Substring TutorialTutorial is loading... Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\t\n\tfor (int i = 1; i < int(s.size()); ++i) {\n\t\tif (s[i] < s[i - 1]) {\n\t\t\tcout << \"YES\" << endl;\n\t\t\tcout << i << \" \" << i + 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << \"NO\" << endl;\n\n\treturn 0;\n}"
    },
    "1154B": {
        "title": "B. Make Them Equal",
        "description": "You are given a sequence a1,a2,\u2026,an consisting of n integers.\nYou can choose any non-negative integer D (i.e. D\u22650), and for each ai you can:\nIt is possible that after an operation the value ai becomes negative.\nYour goal is to choose such minimum non-negative integer D and perform changes in such a way, that all ai are equal (i.e. a1=a2=\u22ef=an).\nPrint the required D or, if it is impossible to choose such value D, print -1.\nFor example, for array [2,8] the value D=3 is minimum possible because you can obtain the array [5,5] if you will add D to 2 and subtract D from 8. And for array [1,4,7,7] the value D=3 is also minimum possible. You can add it to 1 and subtract it from 7 and obtain the array [4,4,4,4].\nThe first line of the input contains one integer n (1\u2264n\u2264100) \u2014 the number of elements in a.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264100) \u2014 the sequence a.\nPrint one integer \u2014 the minimum non-negative integer value D such that if you add this value to some ai, subtract this value from some ai and leave some ai without changes, all obtained values become equal.\nIf it is impossible to choose such value D, print -1.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solutions": "1154B - Make Them EqualLet's leave only unique values of the given array in the array b (i.\u2009e. construct an array b that is actually array a without duplicate element) and sort it in ascending order. Then let's consider the following cases:   If the length of b is greater than 3 then the answer is -1;  if the length of b is 3 then there are two cases:   if b3\u2212b2=b2\u2212b1 then the answer is b2\u2212b1;  otherwise the answer is -1;   if the length of b is 2 then there are also two cases:   if b2\u2212b1 is even then the answer is b2\u2212b12;  otherwise the answer is b2\u2212b1;   and if the length of b is 1 then the answer is 0.  Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\ta.resize(unique(a.begin(), a.end()) - a.begin());\n\tif (a.size() > 3) {\n\t\tcout << -1 << endl;\n\t} else {\n\t\tif (a.size() == 1) {\n\t\t\tcout << 0 << endl;\n\t\t} else if (a.size() == 2) {\n\t\t\tif ((a[1] - a[0]) % 2 == 0) {\n\t\t\t\tcout << (a[1] - a[0]) / 2 << endl;\n\t\t\t} else {\n\t\t\t\tcout << a[1] - a[0] << endl;\n\t\t\t}\n\t\t} else {\n\t\t\tif (a[1] - a[0] != a[2] - a[1]) {\n\t\t\t\tcout << -1 << endl;\n\t\t\t} else {\n\t\t\t\tcout << a[1] - a[0] << endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
    },
    "1153B": {
        "title": "B. Serval and Toy Bricks",
        "description": "Luckily, Serval got onto the right bus, and he came to the kindergarten on time. After coming to kindergarten, he found the toy bricks very funny.\nHe has a special interest to create difficult problems for others to solve. This time, with many 1\u00d71\u00d71 toy bricks, he builds up a 3-dimensional object. We can describe this object with a n\u00d7m matrix, such that in each cell (i,j), there are hi,j bricks standing on the top of each other.\nHowever, Serval doesn't give you any hi,j, and just give you the front view, left view, and the top view of this object, and he is now asking you to restore the object. Note that in the front view, there are m columns, and in the i-th of them, the height is the maximum of h1,i,h2,i,\u2026,hn,i. It is similar for the left view, where there are n columns. And in the top view, there is an n\u00d7m matrix ti,j, where ti,j is 0 or 1. If ti,j equals 1, that means hi,j>0, otherwise, hi,j=0.\nHowever, Serval is very lonely because others are bored about his unsolvable problems before, and refused to solve this one, although this time he promises there will be at least one object satisfying all the views. As his best friend, can you have a try?\nThe first line contains three positive space-separated integers n,m,h (1\u2264n,m,h\u2264100)\u00a0\u2014 the length, width and height.\nThe second line contains m non-negative space-separated integers a1,a2,\u2026,am, where ai is the height in the i-th column from left to right of the front view (0\u2264ai\u2264h).\nThe third line contains n non-negative space-separated integers b1,b2,\u2026,bn (0\u2264bj\u2264h), where bj is the height in the j-th column from left to right of the left view.\nEach of the following n lines contains m numbers, each is 0 or 1, representing the top view, where j-th number of i-th row is 1 if hi,j>0, and 0 otherwise.\nIt is guaranteed that there is at least one structure satisfying the input.\nOutput n lines, each of them contains m integers, the j-th number in the i-th line should be equal to the height in the corresponding position of the top view. If there are several objects satisfying the views, output any one of them.\nThe graph above illustrates the object in the first example.\nThe first graph illustrates the object in the example output for the second example, and the second graph shows the three-view drawing of it.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solutions": "1153B - Serval and Toy BricksAuthor: Serval, Preparation: bzh EditorialFill in all the bricks, and then remove all bricks you must remove (which in some view, there is empty). This can be solved in O(nm)."
    },
    "1153A": {
        "title": "A. Serval and Bus",
        "description": "It is raining heavily. But this is the first day for Serval, who just became 3 years old, to go to the kindergarten. Unfortunately, he lives far from kindergarten, and his father is too busy to drive him there. The only choice for this poor little boy is to wait for a bus on this rainy day. Under such circumstances, the poor boy will use the first bus he sees no matter where it goes. If several buses come at the same time, he will choose one randomly.\nServal will go to the bus station at time t, and there are n bus routes which stop at this station. For the i-th bus route, the first bus arrives at time si minutes, and each bus of this route comes di minutes later than the previous one.\nAs Serval's best friend, you wonder which bus route will he get on. If several buses arrive at the same time, you can print any of them.\nThe first line contains two space-separated integers n and t (1\u2264n\u2264100, 1\u2264t\u2264105)\u00a0\u2014 the number of bus routes and the time Serval goes to the station. \nEach of the next n lines contains two space-separated integers si and di (1\u2264si,di\u2264105)\u00a0\u2014 the time when the first bus of this route arrives and the interval between two buses of this route.\nPrint one number\u00a0\u2014 what bus route Serval will use. If there are several possible answers, you can print any of them.\nIn the first example, the first bus of the first route arrives at time 6, and the first bus of the second route arrives at time 9, so the first route is the answer.\nIn the second example, a bus of the third route arrives at time 5, so it is the answer.\nIn the third example, buses of the first route come at times 2, 4, 6, 8, and so fourth, buses of the second route come at times 2, 5, 8, and so fourth and buses of the third route come at times 2, 6, 10, and so on, so 1 and 2 are both acceptable answers while 3 is not.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1000"
        ],
        "solutions": "1153A - Serval and BusAuthor: Serval, preparation: bzh EditorialFind the first bus Serval can see in each route and find the earliest one. For each route, finding the first bus Serval sees can work in O(1).Or mark all the time no more than max(si,t+max(di)) which bus would come or there will be no bus, then search the nearest one."
    },
    "1151A": {
        "title": "A. Maxim and Biology",
        "description": "Today in the scientific lyceum of the Kingdom of Kremland, there was a biology lesson. The topic of the lesson was the genomes. Let's call the genome the string \"ACTG\".\nMaxim was very boring to sit in class, so the teacher came up with a task for him: on a given string s consisting of uppercase letters and length of at least 4, you need to find the minimum number of operations that you need to apply, so that the genome appears in it as a substring. For one operation, you can replace any letter in the string s with the next or previous in the alphabet. For example, for the letter \"D\" the previous one will be \"C\", and the next\u00a0\u2014 \"E\". In this problem, we assume that for the letter \"A\", the previous one will be the letter \"Z\", and the next one will be \"B\", and for the letter \"Z\", the previous one is the letter \"Y\", and the next one is the letter \"A\".\nHelp Maxim solve the problem that the teacher gave him.\nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nThe first line contains a single integer n (4\u2264n\u226450)\u00a0\u2014 the length of the string s.\nThe second line contains the string s, consisting of exactly n uppercase letters of the Latin alphabet.\nOutput the minimum number of operations that need to be applied to the string s so that the genome appears as a substring in it.\nIn the first example, you should replace the letter \"Z\" with \"A\" for one operation, the letter \"H\"\u00a0\u2014 with the letter \"G\" for one operation. You will get the string \"ACTG\", in which the genome is present as a substring.\nIn the second example, we replace the letter \"A\" with \"C\" for two operations, the letter \"D\"\u00a0\u2014 with the letter \"A\" for three operations. You will get the string \"ZACTG\", in which there is a genome.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "strings",
            "*1000"
        ],
        "solutions": "1151A - Maxim and BiologyCheck every substring of string s of length 4 and find the minimum number of operations to transform it into \"ACTG\" and update the answer.Complexity is O(n). "
    },
    "1149A": {
        "title": "A. Prefix Sum Primes",
        "description": "We're giving away nice huge bags containing number tiles! A bag we want to present to you contains n tiles. Each of them has a single number written on it\u00a0\u2014 either 1 or 2.\nHowever, there is one condition you must fulfill in order to receive the prize. You will need to put all the tiles from the bag in a sequence, in any order you wish. We will then compute the sums of all prefixes in the sequence, and then count how many of these sums are prime numbers. If you want to keep the prize, you will need to maximize the number of primes you get.\nCan you win the prize? Hurry up, the bags are waiting!\nThe first line of the input contains a single integer n (1\u2264n\u2264200000) \u2014 the number of number tiles in the bag. The following line contains n space-separated integers a1,a2,\u2026,an (ai\u2208{1,2}) \u2014 the values written on the tiles.\nOutput a permutation b1,b2,\u2026,bn of the input sequence (a1,a2,\u2026,an) maximizing the number of the prefix sums being prime numbers. If there are multiple optimal permutations, output any.\nThe first solution produces the prefix sums 1,2,3,5,7 (four primes constructed), while the prefix sums in the second solution are 1,2,3,5,6,7,8,10,11 (five primes). Primes are marked bold and blue. In each of these cases, the number of produced primes is maximum possible.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1149A. Prefix Sum Primes Tutorial1150C - Prefix Sum PrimesThere are at least a couple of correct solutions I had in mind. Let me present the one I find the most straightforward, which doesn't even require implementing any sieve.If all the numbers on the tiles are equal, we have no choice but to output the only possible permutation. In the remaining cases, we'll show that the following solution is optimal:  Start with 2 and 1.  Use all remaining 2s.  Finish with all remaining 1s.  It's easy to see that we generate 2 and all odd numbers between 3 and \u2211ni=1ai as the prefix sums. Notice now that each prime is either 2 or an odd number greater than or equal to 3. Therefore, using the construction above we construct all possible prime prefix sums we possibly can \u2014 and so the construction is optimal. The solution can be implemented easily in O(n) time. Code53560113 1150D / "
    },
    "1146B": {
        "title": "B. Hate \"A\"",
        "description": "Bob has a string s consisting of lowercase English letters. He defines s\u2032 to be the string after removing all \"a\" characters from s (keeping all other characters in the same order). He then generates a new string t by concatenating s and s\u2032. In other words, t=s+s\u2032 (look at notes for an example).\nYou are given a string t. Your task is to find some s that Bob could have used to generate t. It can be shown that if an answer exists, it will be unique.\nThe first line of input contains a string t (1\u2264|t|\u2264105) consisting of lowercase English letters.\nPrint a string s that could have generated t. It can be shown if an answer exists, it is unique. If no string exists, print \":(\" (without double quotes, there is no space between the characters).\nIn the first example, we have s= \"aaaaa\", and s\u2032= \"\".\nIn the second example, no such s can work that will generate the given t.\nIn the third example, we have s= \"ababacac\", and s\u2032= \"bbcc\", and t=s+s\u2032= \"ababacacbbcc\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1146B - Hate \"A\"There are a few different ways to approach this.In one way, we can approach it by looking at the frequency of all characters. We want to find a split point so that all \"a\"s lie on the left side of the split, and all other characters are split evenly between the left and right side. This split can be uniquely determined and found in linear time by keeping track of prefix sums (it also might be possible there is no split, in which case the answer is impossible). After finding a split, we still need to make sure the characters appear in the same order, which is another linear time pass.In another way, let's count the number of \"a\" and non-\"a\" characters. Let these numbers be c0 and c1. If c1 is not divisible by 2, then the answer is impossible. Otherwise, we know the suffix of length c1/2 of t must be s\u2032, and we can check there are no \"a\"s there. We also check that after removing all \"a\"s from t, the first and second half of the strings are equal.First solve: tourist, 00:02:37 Tree Diameter"
    },
    "1144C": {
        "title": "C. Two Shuffled Sequences",
        "description": "Two integer sequences existed initially \u2014 one of them was strictly increasing, and the other one \u2014 strictly decreasing.\nStrictly increasing sequence is a sequence of integers [x1<x2<\u22ef<xk]. And strictly decreasing sequence is a sequence of integers [y1>y2>\u22ef>yl]. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\nThey were merged into one sequence a. After that sequence a got shuffled. For example, some of the possible resulting sequences a for an increasing sequence [1,3,4] and a decreasing sequence [10,4,2] are sequences [1,2,3,4,4,10] or [4,2,1,10,4,3].\nThis shuffled sequence a is given in the input.\nYour task is to find any two suitable initial sequences. One of them should be strictly increasing and the other one \u2014 strictly decreasing. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\nIf there is a contradiction in the input and it is impossible to split the given sequence a to increasing and decreasing sequences, print \"NO\".\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in a.\nThe second line of the input contains n integers a1,a2,\u2026,an (0\u2264ai\u22642\u22c5105), where ai is the i-th element of a.\nIf there is a contradiction in the input and it is impossible to split the given sequence a to increasing and decreasing sequences, print \"NO\" in the first line.\nOtherwise print \"YES\" in the first line and any two suitable sequences. Note that the empty sequence and the sequence consisting of one element can be considered as increasing or decreasing.\nIn the second line print ni \u2014 the number of elements in the strictly increasing sequence. ni can be zero, in this case the increasing sequence is empty.\nIn the third line print ni integers inc1,inc2,\u2026,incni in the increasing order of its values (inc1<inc2<\u22ef<incni) \u2014 the strictly increasing sequence itself. You can keep this line empty if ni=0 (or just print the empty line).\nIn the fourth line print nd \u2014 the number of elements in the strictly decreasing sequence. nd can be zero, in this case the decreasing sequence is empty.\nIn the fifth line print nd integers dec1,dec2,\u2026,decnd in the decreasing order of its values (dec1>dec2>\u22ef>decnd) \u2014 the strictly decreasing sequence itself. You can keep this line empty if nd=0 (or just print the empty line).\nni+nd should be equal to n and the union of printed sequences should be a permutation of the given sequence (in case of \"YES\" answer).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solutions": "1144C - Two Shuffled SequencesLet's count the number of occurrences of each element in the array cnt. Because the maximum possible element is 2\u22c5105, it can be done without any data structures.Then let's check if cnti is greater than 2 for some i from 0 to 2\u22c5105, and if it is, then the answer is \"NO\", because this element should occur at least twice in one of the sequences.Now let's output the increasing sequence. The number of elements in it is the number of elements i such that cnti=2. Let's iterate from left to right, print the suitable elements and decrease their cnt.The number of elements in the decreasing sequence is just the number of elements with non-zero cnt. So let's iterate from right to left and just print suitable elements. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> cnt(200 * 1000 + 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++cnt[x];\n\t\tif (cnt[x] > 2) {\n\t\t\tcout << \"NO\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << \"YES\" << endl << count(cnt.begin(), cnt.end(), 2) << endl;\n\tfor (int i = 0; i <= 200 * 1000; ++i) {\n\t\tif (cnt[i] == 2) {\n\t\t\tcout << i << \" \";\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\tcout << endl << count(cnt.begin(), cnt.end(), 1) << endl;\n\tfor (int i = 200 * 1000; i >= 0; --i) {\n\t\tif (cnt[i] == 1) {\n\t\t\tcout << i << \" \";\n\t\t\t--cnt[i];\n\t\t}\n\t}\n\tcout << endl;\n\t\n\tassert(count(cnt.begin(), cnt.end(), 0) == 200 * 1000 + 1);\n\t\n\treturn 0;\n}"
    },
    "1143B": {
        "title": "B. Nirvana",
        "description": "Kurt reaches nirvana when he finds the product of all the digits of some positive integer. Greater value of the product makes the nirvana deeper.\nHelp Kurt find the maximum possible product of digits among all integers from 1 to n.\nThe only input line contains the integer n (1\u2264n\u22642\u22c5109).\nPrint the maximum product of digits among all integers from 1 to n.\nIn the first example the maximum product is achieved for 389 (the product of digits is 3\u22c58\u22c59=216).\nIn the second example the maximum product is achieved for 7 (the product of digits is 7).\nIn the third example the maximum product is achieved for 999999999 (the product of digits is 99=387420489).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1143B - NirvanaLet number x be an answer, and y0y1\u2026yl\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af - number from input, so x = y0y1\u2026yk(yk+1\u22121)99\u20269\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af\u00af for some k (otherwise, you can increase one of the digits by 1, so that x will still be no more than y). So, let's go through k from 0 to the length of y and return the maximum of them by the product of digits.Author: MikeMirzayanov "
    },
    "1141A": {
        "title": "A. Game 23",
        "description": "Polycarp plays \"Game 23\". Initially he has a number n and his goal is to transform it to m. In one move, he can multiply n by 2 or multiply n by 3. He can perform any number of moves.\nPrint the number of moves needed to transform n to m. Print -1 if it is impossible to do so.\nIt is easy to prove that any way to transform n to m contains the same number of moves (i.e. number of moves doesn't depend on the way of transformation).\nThe only line of the input contains two integers n and m (1\u2264n\u2264m\u22645\u22c5108).\nPrint the number of moves to transform n to m, or -1 if there is no solution.\nIn the first example, the possible sequence of moves is: 120\u2192240\u2192720\u21921440\u21924320\u219212960\u219225920\u219251840. The are 7 steps in total.\nIn the second example, no moves are needed. Thus, the answer is 0.\nIn the third example, it is impossible to transform 48 to 72.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1141A - Game 23If m is not divisible by n then just print -1 and stop the program. Otherwise, calculate d=m/n, denoting the required number of times to multiply n. It is easy to see that d should be a product of zero or more 2's and of zero or more 3's, i.e. d=2x3y for integers x,y\u22650. To find x just use a loop to divide d by 2 while it is divisible by 2. Similarly, to find y just use a loop to divide d by 3 while it is divisible by 3. After the divisions, the expected value of d is 1. If d\u22601, print -1. Otherwise, print the total number of the loop iterations. Codeint n, m;\ncin >> n >> m;\nint result = -1;\nif (m % n == 0) {\n    result = 0;\n    int d = m / n;\n    while (d % 2 == 0)\n        d /= 2, result++;\n    while (d % 3 == 0)\n        d /= 3, result++;\n    if (d != 1)\n        result = -1;\n}\ncout << result << endl; "
    },
    "1140D": {
        "title": "D. Minimum Triangulation",
        "description": "You are given a regular polygon with n vertices labeled from 1 to n in counter-clockwise order. The triangulation of a given polygon is a set of triangles such that each vertex of each triangle is a vertex of the initial polygon, there is no pair of triangles such that their intersection has non-zero area, and the total area of all triangles is equal to the area of the given polygon. The weight of a triangulation is the sum of weigths of triangles it consists of, where the weight of a triagle is denoted as the product of labels of its vertices.\nCalculate the minimum weight among all triangulations of the polygon.\nThe first line contains single integer n (3\u2264n\u2264500) \u2014 the number of vertices in the regular polygon.\nPrint one integer \u2014 the minimum weight among all triangulations of the given polygon.\nAccording to Wiki: polygon triangulation is the decomposition of a polygonal area (simple polygon) P into a set of triangles, i.\u2009e., finding a set of triangles with pairwise non-intersecting interiors whose union is P.\nIn the first example the polygon is a triangle, so we don't need to cut it further, so the answer is 1\u22c52\u22c53=6.\nIn the second example the polygon is a rectangle, so it should be divided into two triangles. It's optimal to cut it using diagonal 1\u22123 so answer is 1\u22c52\u22c53+1\u22c53\u22c54=6+12=18.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1140D - Minimum TriangulationYou can use straightforward way and calculate answer with \"l-r-dp\" with O(n3).But there is a easier claim: it's optimal to split n-gon with diagonals coming from 1, so answer is n\u22121\u2211i=2i\u22c5(i+1).Proof: let's look at the triange which contains edge 1\u2212n. Let's name it 1\u2212n\u2212x. If x=n\u22121, we can delete this triangle and go to (n\u22121)-gon.Otherwise, 1<x<n\u22121. Let's look at triangle n\u2212x\u2212k. It always exists and x<k<n. Finally, if we change pair of triangles (1\u2212n\u2212x, n\u2212x\u2212k) to (1\u2212n\u2212k, 1\u2212k\u2212x), answer will decrease since nx>kx and nxk>nk, that's why nx+nxk>nk+kx.Note, that triangle 1\u2212n\u2212x changes to 1\u2212n\u2212k and k>x, so repeating this step will eventually lead us to situation x=n\u22121.As a result, we can morph any triangulation into one mentioned above and its weight won't increase. Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\n\tlong long ans = 0;\n\tfor(int id = 2; id < n; id++)\n\t\tans += 1ll * id * (id + 1);\n\t\n\tcout << ans << endl;\n}"
    },
    "1140B": {
        "title": "B. Good String",
        "description": "You have a string s of length n consisting of only characters > and <. You may do some operations with this string, for each operation you have to choose some character that still remains in the string. If you choose a character >, the character that comes right after it is deleted (if the character you chose was the last one, nothing happens). If you choose a character <, the character that comes right before it is deleted (if the character you chose was the first one, nothing happens).\nFor example, if we choose character > in string > > < >, the string will become to > > >. And if we choose character < in string > <, the string will become to <.\nThe string is good if there is a sequence of operations such that after performing it only one character will remain in the string. For example, the strings >, > > are good. \nBefore applying the operations, you may remove any number of characters from the given string (possibly none, possibly up to n\u22121, but not the whole string). You need to calculate the minimum number of characters to be deleted from string s so that it becomes good.\nThe first line contains one integer t (1\u2264t\u2264100) \u2013 the number of test cases. Each test case is represented by two lines.\nThe first line of i-th test case contains one integer n (1\u2264n\u2264100) \u2013 the length of string s.\nThe second line of i-th test case contains string s, consisting of only characters > and <.\nFor each test case print one line.\nFor i-th test case print the minimum number of characters to be deleted from string s so that it becomes good.\nIn the first test case we can delete any character in string <>.\nIn the second test case we don't need to delete any characters. The string > < < is good, because we can perform the following sequence of operations: > < < \u2192 < < \u2192 <.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "1140B - Good String TutorialTutorial is loading... Solution (Roms)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint t, n;\nstring s;\n\nint main(){\n\tcin >> t;\n\tfor(int tc = 0; tc < t; ++tc){\n\t\tcin >> n >> s;\n\t\tint res = n - 1;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(s[i] == '>' || s[n - 1 - i] == '<')\n\t\t\t\tres = min(res, i);\n\t\t\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}\n"
    },
    "1140A": {
        "title": "A. Detective Book",
        "description": "Ivan recently bought a detective book. The book is so interesting that each page of this book introduces some sort of a mystery, which will be explained later. The i-th page contains some mystery that will be explained on page ai (ai\u2265i).\nIvan wants to read the whole book. Each day, he reads the first page he didn't read earlier, and continues to read the following pages one by one, until all the mysteries he read about are explained and clear to him (Ivan stops if there does not exist any page i such that Ivan already has read it, but hasn't read page ai). After that, he closes the book and continues to read it on the following day from the next page.\nHow many days will it take to read the whole book?\nThe first line contains single integer n (1\u2264n\u2264104) \u2014 the number of pages in the book.\nThe second line contains n integers a1,a2,\u2026,an (i\u2264ai\u2264n), where ai is the number of page which contains the explanation of the mystery on page i.\nPrint one integer \u2014 the number of days it will take to read the whole book.\nExplanation of the example test:\nDuring the first day Ivan will read only the first page. During the second day Ivan will read pages number 2 and 3. During the third day \u2014 pages 4-8. During the fourth (and the last) day Ivan will read remaining page number 9.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1140A - Detective Book TutorialTutorial is loading... Solution (adedalic)#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> a;\n\ninline bool read() {\n\tif(!(cin >> n))\n\t\treturn false;\n\ta.resize(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t}\n\treturn true;\n}\n\ninline void solve() {\n\tint cnt = 0, pos = 0;\n\twhile(pos < n) {\n\t\tcnt++;\n\t\tint mx = pos;\n\t\twhile(pos < n && pos <= mx) {\n\t\t\tmx = max(mx, a[pos]);\n\t\t\tpos++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\t\n\tif(read()) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
    },
    "1139B": {
        "title": "B. Chocolates",
        "description": "You went to the store, selling n types of chocolates. There are ai chocolates of type i in stock.\nYou have unlimited amount of cash (so you are not restricted by any prices) and want to buy as many chocolates as possible. However if you buy xi chocolates of type i (clearly, 0\u2264xi\u2264ai), then for all 1\u2264j<i at least one of the following must hold:\nFor example, the array x=[0,0,1,2,10] satisfies the requirement above (assuming that all ai\u2265xi), while arrays x=[0,1,0], x=[5,5] and x=[3,2] don't.\nCalculate the maximum number of chocolates you can buy.\nThe first line contains an integer n (1\u2264n\u22642\u22c5105), denoting the number of types of chocolate.\nThe next line contains n integers ai (1\u2264ai\u2264109), denoting the number of chocolates of each type.\nPrint the maximum number of chocolates you can buy.\nIn the first example, it is optimal to buy: 0+0+1+3+6 chocolates.\nIn the second example, it is optimal to buy: 1+2+3+4+10 chocolates.\nIn the third example, it is optimal to buy: 0+0+0+1 chocolates.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solutions": "1139B - ChocolatesIt is optimal to proceed greedily from the back of the array. If we have taken x candies of the i+1 type, then we can only take min(x\u22121,Ai) candies for type i. If this value is less than zero, we take 0 from here.Overall Complexity: O(n)Author: AshishgupC++ Code: 51651887Java Code: 51651375 "
    },
    "1136B": {
        "title": "B. Nastya Is Playing Computer Games",
        "description": "Finished her homework, Nastya decided to play computer games. Passing levels one by one, Nastya eventually faced a problem. Her mission is to leave a room, where a lot of monsters live, as quickly as possible.\nThere are n manholes in the room which are situated on one line, but, unfortunately, all the manholes are closed, and there is one stone on every manhole. There is exactly one coin under every manhole, and to win the game Nastya should pick all the coins. Initially Nastya stands near the k-th manhole from the left. She is thinking what to do.\nIn one turn, Nastya can do one of the following: \nNastya can leave the room when she picks all the coins. Monsters are everywhere, so you need to compute the minimum number of moves Nastya has to make to pick all the coins.\nNote one time more that Nastya can open a manhole only when there are no stones onto it.\nThe first and only line contains two integers n and k, separated by space (2\u2264n\u22645000, 1\u2264k\u2264n)\u00a0\u2014 the number of manholes and the index of manhole from the left, near which Nastya stays initially. Initially there is exactly one stone near each of the n manholes. \nPrint a single integer\u00a0\u2014 minimum number of moves which lead Nastya to pick all the coins.\nLet's consider the example where n=2, k=2. Nastya should play as follows:\nSo, 6 moves are required to win.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solutions": "1136B - Nastya Is Playing Computer GamesNote that in any case we will open n hatches. Also, initial position of stones is : 1,1,1,1,1,1...1 (1 - the number of stones on the i-th hatch ).After any permutation of stones we will have permutation of numbers : 2,0,1,1,1,1,1... So, to open hatch with 2 stones, we need at least 2 movements. So, at all, we need at least n+1 movements(1). To get into all the hatches we need at least min(n\u2212k,k\u22121)+n\u22121 movements.(since we can only go to the neighboring). So, at all, answer is : (n+1)+n+(n\u22121)+min(n\u2212k,k\u22121)=3n+min(n\u2212k,k\u22121).Code(Idea of the problem C \u2014 usertab34) "
    },
    "1133C": {
        "title": "C. Balanced Team",
        "description": "You are a coach at your local university. There are n students under your supervision, the programming skill of the i-th student is ai.\nYou have to create a team for a new programming competition. As you know, the more students some team has the more probable its victory is! So you have to create a team with the maximum number of students. But you also know that a team should be balanced. It means that the programming skill of each pair of students in a created team should differ by no more than 5.\nYour task is to report the maximum possible number of students in a balanced team.\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of students.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is a programming skill of the i-th student.\nPrint one integer \u2014 the maximum possible number of students in a balanced team.\nIn the first example you can create a team with skills [12,17,15].\nIn the second example you can take all students in a team because their programming skills are equal.\nIn the third example you can create a team consisting of a single student (and you cannot create a team consisting of at least two students).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "two pointers",
            "*1200"
        ],
        "solutions": "1133C - Balanced TeamLet's sort all values in non-decreasing order. Then we can use two pointers to calculate for each student i the maximum number of students j such that aj\u2212ai\u22645 (j>i). This is pretty standard approach. We also can use binary search to do it (or we can store for each programming skill the number of students with this skill and just iterate from some skill x to x+5 and sum up all numbers of students). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\tint ans = 0;\n\tint j = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\twhile (j < n && a[j] - a[i] <= 5) {\n\t\t\t++j;\n\t\t\tans = max(ans, j - i);\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
    },
    "1133B": {
        "title": "B. Preparation for International Women's Day",
        "description": "International Women's Day is coming soon! Polycarp is preparing for the holiday.\nThere are n candy boxes in the shop for sale. The i-th box contains di candies.\nPolycarp wants to prepare the maximum number of gifts for k girls. Each gift will consist of exactly two boxes. The girls should be able to share each gift equally, so the total amount of candies in a gift (in a pair of boxes) should be divisible by k. In other words, two boxes i and j (i\u2260j) can be combined as a gift if di+dj is divisible by k.\nHow many boxes will Polycarp be able to give? Of course, each box can be a part of no more than one gift. Polycarp cannot use boxes \"partially\" or redistribute candies between them. \nThe first line of the input contains two integers n and k (1\u2264n\u22642\u22c5105,1\u2264k\u2264100) \u2014 the number the boxes and the number the girls.\nThe second line of the input contains n integers d1,d2,\u2026,dn (1\u2264di\u2264109), where di is the number of candies in the i-th box.\nPrint one integer \u2014 the maximum number of the boxes Polycarp can give as gifts.\nIn the first example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \nSo the answer is 6.\nIn the second example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \nSo the answer is 8.\nIn the third example Polycarp can give the following pairs of boxes (pairs are presented by indices of corresponding boxes): \nSo the answer is 4.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "1133B - Preparation for International Women's DayIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> cnt(k);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\t++cnt[x % k];\n\t}\n\tint ans = cnt[0] / 2;\n\tif (k % 2 == 0) ans += cnt[k / 2] / 2;\n\tfor (int i = 1; i < (k + 1) / 2; ++i) {\n\t\tint j = k - i;\n\t\tans += min(cnt[i], cnt[j]);\n\t}\n\t\n\tcout << ans * 2 << endl;\n\t\n\treturn 0;\n}"
    },
    "1133A": {
        "title": "A. Middle of the Contest",
        "description": "Polycarp is going to participate in the contest. It starts at h1:m1h1:m1 and ends at h2:m2. It is guaranteed that the contest lasts an even number of minutes (i.e. m1%2=m2%2, where x%y is x modulo y). It is also guaranteed that the entire contest is held during a single day. And finally it is guaranteed that the contest lasts at least two minutes.\nPolycarp wants to know the time of the midpoint of the contest. For example, if the contest lasts from 10:00 to 11:00 then the answer is 10:30, if the contest lasts from 11:10 to 11:12 then the answer is 11:11.\nThe first line of the input contains two integers h1 and m1 in the format hh:mm.\nThe second line of the input contains two integers h2 and m2 in the same format (hh:mm).\nIt is guaranteed that 0\u2264h1,h2\u226423 and 0\u2264m1,m2\u226459.\nIt is guaranteed that the contest lasts an even number of minutes (i.e. m1%2=m2%2, where x%y is x modulo y). It is also guaranteed that the entire contest is held during a single day. And finally it is guaranteed that the contest lasts at least two minutes.\nPrint two integers h3 and m3 (0\u2264h3\u226423,0\u2264m3\u226459) corresponding to the midpoint of the contest in the format hh:mm. Print each number as exactly two digits (prepend a number with leading zero if needed), separate them with ':'.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1133A - Middle of the ContestIdea: MikeMirzayanov TutorialTutorial is loading... Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint h1, m1;\n\tscanf(\"%d:%d\", &h1, &m1);\n\tint h2, m2;\n\tscanf(\"%d:%d\", &h2, &m2);\n\tint t1 = h1 * 60 + m1;\n\tint t2 = h2 * 60 + m2;\n\tint t3 = (t1 + t2) / 2;\n\tprintf(\"%02d:%02d\\n\", t3 / 60, t3 % 60);\n\t\n\treturn 0;\n}"
    },
    "1132A": {
        "title": "A. Regular Bracket Sequence",
        "description": "A string is called bracket sequence if it does not contain any characters other than \"(\" and \")\". A bracket sequence is called regular if it it is possible to obtain correct arithmetic expression by inserting characters \"+\" and \"1\" into this sequence. For example, \"\", \"(())\" and \"()()\" are regular bracket sequences; \"))\" and \")((\" are bracket sequences (but not regular ones), and \"(a)\" and \"(1)+(1)\" are not bracket sequences at all.\nYou have a number of strings; each string is a bracket sequence of length 2. So, overall you have cnt1 strings \"((\", cnt2 strings \"()\", cnt3 strings \")(\" and cnt4 strings \"))\". You want to write all these strings in some order, one after another; after that, you will get a long bracket sequence of length 2(cnt1+cnt2+cnt3+cnt4). You wonder: is it possible to choose some order of the strings you have such that you will get a regular bracket sequence? Note that you may not remove any characters or strings, and you may not add anything either.\nThe input consists of four lines, i-th of them contains one integer cnti (0\u2264cnti\u2264109).\nPrint one integer: 1 if it is possible to form a regular bracket sequence by choosing the correct order of the given strings, 0 otherwise.\nIn the first example it is possible to construct a string \"(())()(()((()()()())))\", which is a regular bracket sequence.\nIn the second example it is possible to construct a string \"\", which is a regular bracket sequence.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1131C": {
        "title": "C. Birthday",
        "description": "Cowboy Vlad has a birthday today! There are n children who came to the celebration. In order to greet Vlad, the children decided to form a circle around him. Among the children who came, there are both tall and low, so if they stand in a circle arbitrarily, it may turn out, that there is a tall and low child standing next to each other, and it will be difficult for them to hold hands. Therefore, children want to stand in a circle so that the maximum difference between the growth of two neighboring children would be minimal possible.\nFormally, let's number children from 1 to n in a circle order, that is, for every i child with number i will stand next to the child with number i+1, also the child with number 1 stands next to the child with number n. Then we will call the discomfort of the circle the maximum absolute difference of heights of the children, who stand next to each other.\nPlease help children to find out how they should reorder themselves, so that the resulting discomfort is smallest possible.\nThe first line contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the number of the children who came to the cowboy Vlad's birthday.\nThe second line contains integers a1,a2,\u2026,an (1\u2264ai\u2264109) denoting heights of every child.\nPrint exactly n integers\u00a0\u2014 heights of the children in the order in which they should stand in a circle. You can start printing a circle with any child.\nIf there are multiple possible answers, print any of them.\nIn the first example, the discomfort of the circle is equal to 1, since the corresponding absolute differences are 1, 1, 1 and 0. Note, that sequences [2,3,2,1,1] and [3,2,1,1,2] form the same circles and differ only by the selection of the starting point.\nIn the second example, the discomfort of the circle is equal to 20, since the absolute difference of 10 and 30 is equal to 20.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "1131C - \u0414\u0435\u043d\u044c \u0440\u043e\u0436\u0434\u0435\u043d\u0438\u044fThe solution is greedy one.Suppose we have reordered ai, so that ai\u2264ai+1.Then I claim that the answer can be built as follows:First write all elements with even indices and then all elements with odd indices in reversed order.For example, if n=5: we get a1,a3,a5\u2223a4,a2 and if n=6: a1,a3,a5\u2223a6,a4,a2.One can \"check on many tests\" that it works in practice, but here goes the proof:Note, that the solution provides answer which is at most maxai+2\u2212ai.Let's show that for every i, answer must be at least ai+2\u2212ai. To do this, draw all ai's as a graph. Then the solution to the problem is some Hamiltonian cycle.Let's suppose that ai+2\u2212ai is prohibited to us (and all jumps containing this one).  Red denotes the forbidden jumps. One can easily see, that ai+1 is a cut point, and no hamiltonian cycle is possible. This concludes our proof!(Developing \u2014 cdkrot, idea \u2014 jury) "
    },
    "1130B": {
        "title": "B. Two Cakes",
        "description": "Sasha and Dima want to buy two n-tier cakes. Each cake should consist of n different tiers: from the size of 1 to the size of n. Tiers should go in order from the smallest to the biggest (from top to bottom).\nThey live on the same street, there are 2\u22c5n houses in a row from left to right. Each house has a pastry shop where you can buy a cake tier. Unfortunately, in each pastry shop you can buy only one tier of only one specific size: in the i-th house you can buy a tier of the size ai (1\u2264ai\u2264n).\nSince the guys carry already purchased tiers, and it is impossible to insert a new tier in the middle of the cake, they agreed to buy tiers from the smallest to the biggest. That is, each of them buys tiers in order: 1, then 2, then 3 and so on up to n.\nInitially, Sasha and Dima are located near the first (leftmost) house. Output the minimum distance that they will have to walk in total to buy both cakes. The distance between any two neighboring houses is exactly 1.\nThe first line of the input contains an integer number n \u2014 the number of tiers in each cake (1\u2264n\u2264105).\nThe second line contains 2\u22c5n integers a1,a2,\u2026,a2n (1\u2264ai\u2264n), where ai is equal to the size of the tier, which can be bought in the i-th house. Remember that in each house you can buy only one tier. It is guaranteed that every number from 1 to n occurs in a exactly two times.\nPrint one number \u00a0\u2014 the minimum distance that the guys have to walk in total to buy both cakes. Guys can be near same house at the same time. They begin near the first (leftmost) house. Each of the guys should buy n tiers in ascending order of their sizes.\nIn the first example, the possible optimal sequence of actions is:\nSo, Sasha goes the distance 3+1=4, and Dima goes the distance 1+1+3=5. In total, they cover a distance of 4+5=9. You can make sure that with any other sequence of actions they will walk no less distance.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "1130B - Two CakesTutorial is not available Div2C"
    },
    "1121B": {
        "title": "B. Mike and Children",
        "description": "Mike decided to teach programming to children in an elementary school. He knows that it is not an easy task to interest children in that age to code. That is why he decided to give each child two sweets.\nMike has n sweets with sizes a1,a2,\u2026,an. All his sweets have different sizes. That is, there is no such pair (i,j) (1\u2264i,j\u2264n) such that i\u2260j and ai=aj.\nSince Mike has taught for many years, he knows that if he gives two sweets with sizes ai and aj to one child and ak and ap to another, where (ai+aj)\u2260(ak+ap), then a child who has a smaller sum of sizes will be upset. That is, if there are two children who have different sums of sweets, then one of them will be upset. Apparently, Mike does not want somebody to be upset. \nMike wants to invite children giving each of them two sweets. Obviously, he can't give one sweet to two or more children. His goal is to invite as many children as he can. \nSince Mike is busy preparing to his first lecture in the elementary school, he is asking you to find the maximum number of children he can invite giving each of them two sweets in such way that nobody will be upset.\nThe first line contains one integer n (2\u2264n\u22641000)\u00a0\u2014 the number of sweets Mike has.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264105)\u00a0\u2014 the sizes of the sweets. It is guaranteed that all integers are distinct.\nPrint one integer\u00a0\u2014 the maximum number of children Mike can invite giving each of them two sweets in such way that nobody will be upset.\nIn the first example, Mike can give 9+2=11 to one child, 8+3=11 to another one, and 7+4=11 to the third child. Therefore, Mike can invite three children. Note that it is not the only solution.\nIn the second example, Mike can give 3+9=12 to one child and 1+11 to another one. Therefore, Mike can invite two children. Note that it is not the only solution.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "1121B - Mike and ChildrenNotice that the sum of sweets each child gets cannot exceed 2\u22c5105, so for each of numbers no more than this threshold we can store the number of ways to obtain it as the sum of two sweets. It can be done just by considering all possible (unordered) pairs of sweets and printing the maximal obtained number (of ways to represent something as sum of two sweets). Indeed, if x can be represented as a sum of two sweets in several ways then no two of them share a sweet since if ai+aj = ai+ak then aj=ak and therefore j=k. Problem B of final/C div2 (System Testing)"
    },
    "1121A": {
        "title": "A. Technogoblet of Fire",
        "description": "Everybody knows that the m-coder Tournament will happen soon. m schools participate in the tournament, and only one student from each school participates.\nThere are a total of n students in those schools. Before the tournament, all students put their names and the names of their schools into the Technogoblet of Fire. After that, Technogoblet selects the strongest student from each school to participate. \nArkady is a hacker who wants to have k Chosen Ones selected by the Technogoblet. Unfortunately, not all of them are the strongest in their schools, but Arkady can make up some new school names and replace some names from Technogoblet with those. You can't use each made-up name more than once. In that case, Technogoblet would select the strongest student in those made-up schools too.\nYou know the power of each student and schools they study in. Calculate the minimal number of schools Arkady has to make up so that k Chosen Ones would be selected by the Technogoblet.\nThe first line contains three integers n, m and k (1\u2264n\u2264100, 1\u2264m,k\u2264n)\u00a0\u2014 the total number of students, the number of schools and the number of the Chosen Ones.\nThe second line contains n different integers p1,p2,\u2026,pn (1\u2264pi\u2264n), where pi denotes the power of i-th student. The bigger the power, the stronger the student.\nThe third line contains n integers s1,s2,\u2026,sn (1\u2264si\u2264m), where si denotes the school the i-th student goes to. At least one student studies in each of the schools. \nThe fourth line contains k different integers c1,c2,\u2026,ck (1\u2264ci\u2264n) \u00a0\u2014 the id's of the Chosen Ones.\nOutput a single integer \u00a0\u2014 the minimal number of schools to be made up by Arkady so that k Chosen Ones would be selected by the Technogoblet.\nIn the first example there's just a single Chosen One with id 3. His power is equal to 3, but in the same school 1, there's a student with id 5 and power 6, and that means inaction would not lead to the latter being chosen. If we, however, make up a new school (let its id be 4) for the Chosen One, Technogoblet would select students with ids 2 (strongest in 3), 5 (strongest in 1), 6 (strongest in 2) and 3 (strongest in 4).\nIn the second example, you can change the school of student 3 to the made-up 5 and the school of student 4 to the made-up 6. It will cause the Technogoblet to choose students 8, 7, 6, 5, 3 and 4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1119A": {
        "title": "A. Ilya and a Colorful Walk",
        "description": "Ilya lives in a beautiful city of Chordalsk.\nThere are n houses on the street Ilya lives, they are numerated from 1 to n from left to right; the distance between every two neighboring houses is equal to 1 unit. The neighboring houses are 1 and 2, 2 and 3, ..., n\u22121 and n. The houses n and 1 are not neighboring.\nThe houses are colored in colors c1,c2,\u2026,cn so that the i-th house is colored in the color ci. Everyone knows that Chordalsk is not boring, so there are at least two houses colored in different colors.\nIlya wants to select two houses i and j so that 1\u2264i<j\u2264n, and they have different colors: ci\u2260cj. He will then walk from the house i to the house j the distance of (j\u2212i) units.\nIlya loves long walks, so he wants to choose the houses so that the distance between them is the maximum possible.\nHelp Ilya, find this maximum possible distance.\nThe first line contains a single integer n (3\u2264n\u2264300000)\u00a0\u2014 the number of cities on the street.\nThe second line contains n integers c1,c2,\u2026,cn (1\u2264ci\u2264n)\u00a0\u2014 the colors of the houses.\nIt is guaranteed that there is at least one pair of indices i and j so that 1\u2264i<j\u2264n and ci\u2260cj.\nPrint a single integer\u00a0\u2014 the maximum possible distance Ilya can walk.\nIn the first example the optimal way is to walk from the first house to the last one, where Ilya can walk the distance of 5\u22121=4 units.\nIn the second example the optimal way is to either walk from the first house to the second or from the second to the third. Both these ways have the distance of 1 unit.\nIn the third example the optimal way is to walk from the third house to the last one, where Ilya can walk the distance of 7\u22123=4 units. ",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "1119A - Ilya and a Colorful WalkIt is enough to find the last color different from the c1 and the first color different from cn and print the maximum of the two distances."
    },
    "1118B": {
        "title": "B. Tanya and Candies",
        "description": "Tanya has n candies numbered from 1 to n. The i-th candy has the weight ai.\nShe plans to eat exactly n\u22121 candies and give the remaining candy to her dad. Tanya eats candies in order of increasing their numbers, exactly one candy per day.\nYour task is to find the number of such candies i (let's call these candies good) that if dad gets the i-th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days. Note that at first, she will give the candy, after it she will eat the remaining candies one by one.\nFor example, n=4 and weights are [1,4,3,3]. Consider all possible cases to give a candy to dad:\nIn total there 2 cases which should counted (these candies are good), so the answer is 2.\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of candies.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264104), where ai is the weight of the i-th candy.\nPrint one integer \u2014 the number of such candies i (good candies) that if dad gets the i-th candy then the sum of weights of candies Tanya eats in even days will be equal to the sum of weights of candies Tanya eats in odd days.\nIn the first example indices of good candies are [1,2].\nIn the second example indices of good candies are [2,3].\nIn the third example indices of good candies are [4,5,9].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "1118B - Tanya and CandiesLet's maintain four variables oddPref, evenPref, oddSuf and evenSuf, which will mean the sum of ai with odd i on prefix, even i on prefix, odd i on suffix and even i on suffix. Initially, oddPref and evenPref are 0, oddSuf equals to the sum of ai with odd i in a whole array and evenSuf equals to the sum of ai with even i in a whole array.Let's iterate from left to right over all elements of the array. Let's consider the current element ai. If i is even, then set evenSuf:=evenSuf\u2212ai, otherwise let's set oddSuf:=oddSuf\u2212ai. Then let's consider we give the current candy to dad. Then we have to increase the answer if oddPref=evenSuf and evenPref=oddSuf. Then if i is even then let's set evenPref:=evenPref+ai, otherwise let's set oddPref:=oddPref+ai. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n;\n\tcin >> n;\n\t\n\tvector<int> a(n);\n\t\n\tint ePref = 0, oPref = 0, eSuf = 0, oSuf = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tif (i & 1) eSuf += a[i];\n\t\telse oSuf += a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i & 1) eSuf -= a[i];\n\t\telse oSuf -= a[i];\n\t\tif (ePref + oSuf == oPref + eSuf) {\n\t\t\t++ans;\n\t\t}\n\t\tif (i & 1) ePref += a[i];\n\t\telse oPref += a[i];\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
    },
    "1117B": {
        "title": "B. Emotes",
        "description": "There are n emotes in very popular digital collectible card game (the game is pretty famous so we won't say its name). The i-th emote increases the opponent's happiness by ai units (we all know that emotes in this game are used to make opponents happy).\nYou have time to use some emotes only m times. You are allowed to use any emotion once, more than once, or not use it at all. The only restriction is that you cannot use the same emote more than k times in a row (otherwise the opponent will think that you're trolling him).\nNote that two emotes i and j (i\u2260j) such that ai=aj are considered different.\nYou have to make your opponent as happy as possible. Find the maximum possible opponent's happiness.\nThe first line of the input contains three integers n,m and k (2\u2264n\u22642\u22c5105, 1\u2264k\u2264m\u22642\u22c5109) \u2014 the number of emotes, the number of times you can use emotes and the maximum number of times you may use the same emote in a row.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is value of the happiness of the i-th emote.\nPrint one integer \u2014 the maximum opponent's happiness if you use emotes in a way satisfying the problem statement.\nIn the first example you may use emotes in the following sequence: 4,4,5,4,4,5,4,4,5.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "1117B - EmotesIt is obvious that we always can use only two emotes with maximum ai. Let their values be x and y (x\u2265y).We have to solve the problem by some formula. The best way to use emotes \u2014 use the emote with the value x k times, then use the emotion with the value y, then again use the emote with value x k times, and so on.So the \"cycle\" has length k+1, and we can use the emote with the value x the remaining number of times. So the answer is \u230amk+1\u230b\u22c5(x\u22c5k+y)+(m%(k+1))\u22c5x, where x is the first maximum of a, y is the second maximum of a, \u230apq\u230b is p divided by q rounded down, and p%q is p modulo q. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.rbegin(), a.rend());\n\t\n\tcout << m / (k + 1) * 1ll * (a[0] * 1ll * k + a[1]) + m % (k + 1) * 1ll * a[0] << endl;\n\t\n\treturn 0;\n}"
    },
    "1117A": {
        "title": "A. Best Subsegment",
        "description": "You are given array a1,a2,\u2026,an. Find the subsegment al,al+1,\u2026,ar (1\u2264l\u2264r\u2264n) with maximum arithmetic mean 1r\u2212l+1r\u2211i=lai (in floating-point numbers, i.e. without any rounding).\nIf there are many such subsegments find the longest one.\nThe first line contains single integer n (1\u2264n\u2264105) \u2014 length of the array a.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u2014 the array a.\nPrint the single integer \u2014 the length of the longest subsegment with maximum possible arithmetic mean.\nThe subsegment [3,4] is the longest among all subsegments with maximum arithmetic mean.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solutions": "1117A - Best Subsegment TutorialTutorial is loading... Solution (adedalic)#include<iostream>\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tint mx = -1, lenMx = 0;\n\t\n\tint curEl = -1, curLen = 0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint a; cin >> a;\n\t\t\n\t\tif(curEl != a)\n\t\t\tcurEl = a, curLen = 0;\n\t\tcurLen++;\n\t\t\n\t\tif(mx < curEl)\n\t\t\tmx = curEl, lenMx = 0;\n\t\tif(mx == curEl)\n\t\t\tlenMx = max(lenMx, curLen);\n\t}\n\tcout << lenMx << endl;\n\treturn 0;\n}"
    },
    "1115G1": {
        "title": "G1. AND oracle",
        "description": "Implement a quantum oracle on N qubits which implements the following function: f(\u2192x)=x0\u2227x1\u2227\u22ef\u2227xN\u22121\nYou have to implement an operation which takes the following inputs:\nand performs a transformation |x\u27e9|y\u27e9\u2192|x\u27e9|y\u2295f(x)\u27e9. The operation doesn't have an output; its \"output\" is the state in which it leaves the qubits.\nYour code should have the following signature:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1111A": {
        "title": "A. Superhero Transformation",
        "description": "We all know that a superhero can transform to certain other superheroes. But not all Superheroes can transform to any other superhero. A superhero with name s can transform to another superhero with name t if s can be made equal to t by changing any vowel in s to any other vowel and any consonant in s to any other consonant. Multiple changes can be made.\nIn this problem, we consider the letters 'a', 'e', 'i', 'o' and 'u' to be vowels and all the other letters to be consonants.\nGiven the names of two superheroes, determine if the superhero with name s can be transformed to the Superhero with name t.\nThe first line contains the string s having length between 1 and 1000, inclusive.\nThe second line contains the string t having length between 1 and 1000, inclusive.\nBoth strings s and t are guaranteed to be different and consist of lowercase English letters only.\nOutput \"Yes\" (without quotes) if the superhero with name s can be transformed to the superhero with name t and \"No\" (without quotes) otherwise.\nYou can print each letter in any case (upper or lower).\nIn the first sample, since both 'a' and 'u' are vowels, it is possible to convert string s to t.\nIn the third sample, 'k' is a consonant, whereas 'a' is a vowel, so it is not possible to convert string s to t.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1111A - Superhero TransformationCheck lengths of s and t. If they are different, s can never be converted to t and answer is \"No\".If for all indexes i either both s[i] and t[i] are vowels or both s[i] and t[i] are consonants, then answer is \"Yes\", else answer is \"No\". Author's code#include \"bits/stdc++.h\"\nusing namespace std;\n\n// Checking if a character is vowel\nbool isVowel(char a)\n{\n    if(a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u')\n        return true;\n    return false;\n}\n\nint main()\n{\n    string S, T;\n    cin >> S;\n    cin >> T;\n    // Answer is no if size of strings is differents\n    if(S.size() != T.size())\n    {\n        cout << \"No\\n\";\n        return 0;\n    }\n    int flag = 1;\n    // Checking the condition on all characters one by one \n    for(int i = 0; i < S.size(); ++i)\n    {\n        if((isVowel(S[i]) && isVowel(T[i])) || (isVowel(S[i]) == false && isVowel(T[i]) == false))\n        {\n            continue;\n        }\n        flag = 0;\n        break;\n    }\n    if(flag)\n        cout << \"Yes\\n\";\n    else\n        cout << \"No\\n\";\n    return 0;\n} "
    },
    "1108B": {
        "title": "B. Divisors of Two Integers",
        "description": "Recently you have received two positive integer numbers x and y. You forgot them, but you remembered a shuffled list containing all divisors of x (including 1 and x) and all divisors of y (including 1 and y). If d is a divisor of both numbers x and y at the same time, there are two occurrences of d in the list.\nFor example, if x=4 and y=6 then the given list can be any permutation of the list [1,2,4,1,2,3,6]. Some of the possible lists are: [1,1,2,4,6,3,2], [4,6,1,1,2,3,2] or [1,6,3,2,4,1,2].\nYour problem is to restore suitable positive integer numbers x and y that would yield the same list of divisors (possibly in different order).\nIt is guaranteed that the answer exists, i.e. the given list of divisors corresponds to some positive integers x and y.\nThe first line contains one integer n (2\u2264n\u2264128) \u2014 the number of divisors of x and y.\nThe second line of the input contains n integers d1,d2,\u2026,dn (1\u2264di\u2264104), where di is either divisor of x or divisor of y. If a number is divisor of both numbers x and y then there are two copies of this number in the list.\nPrint two positive integer numbers x and y \u2014 such numbers that merged list of their divisors is the permutation of the given list of integers. It is guaranteed that the answer exists.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1108B - Divisors of Two IntegersLet's take a look on the maximum element of the given array. Suddenly, this number is x (or y, the order doesn't matter). Okay, what would we do if we know x and merged list of divisors of x and y? Let's remove all divisors of x and see what we got. The maximum element in the remaining array is y. So, the problem is solved. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tmultiset<int> a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta.insert(x);\n\t}\n\t\n\tint x = *prev(a.end());\n\tfor (int i = 1; i <= x; ++i) {\n\t\tif (x % i == 0) {\n\t\t\ta.erase(a.find(i));\n\t\t}\n\t}\n\t\n\tcout << x << \" \" << *prev(a.end()) << endl;\n\t\n\treturn 0;\n}"
    },
    "1107B": {
        "title": "B. Digital root",
        "description": "Today at the lesson of mathematics, Petya learns about the digital root.\nThe digital root of a non-negative integer is the single digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute a digit sum. The process continues until a single-digit number is reached. \nLet's denote the digital root of x as S(x). Then S(5)=5, S(38)=S(3+8=11)=S(1+1=2)=2, S(10)=S(1+0=1)=1.\nAs a homework Petya got n tasks of the form: find k-th positive number whose digital root is x.\nPetya has already solved all the problems, but he doesn't know if it's right. Your task is to solve all n tasks from Petya's homework.\nThe first line contains a single integer n (1\u2264n\u2264103) \u2014 the number of tasks in Petya's homework. The next n lines contain two integers ki (1\u2264ki\u22641012) and xi (1\u2264xi\u22649) \u2014 i-th Petya's task in which you need to find a ki-th positive number, the digital root of which is xi.\nOutput n lines, i-th line should contain a single integer \u2014 the answer to the i-th problem.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1107B - Digital rootThe key observation is that the digital root of an integer k is the single-digit number 1\u2009\u2264\u2009d\u2009\u2264\u20099 such that . You can prove this by noticing that  for all p. Once we observe this, finding the k-th number is very simple; see the code: 48993705"
    },
    "1105B": {
        "title": "B. Zuhair and Strings",
        "description": "Given a string s of length n and integer k (1\u2264k\u2264n). The string s has a level x, if x is largest non-negative integer, such that it's possible to find in s:\nA substring is a sequence of consecutive (adjacent) characters, it is defined by two integers i and j (1\u2264i\u2264j\u2264n), denoted as s[i\u2026j] = \"sisi+1\u2026sj\".\nFor example, if k=2, then:\nZuhair gave you the integer k and the string s of length n. You need to find x, the level of the string s.\nThe first line contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string and the value of k.\nThe second line contains the string s of length n consisting only of lowercase Latin letters.\nPrint a single integer x\u00a0\u2014 the level of the string.\nIn the first example, we can select 2 non-intersecting substrings consisting of letter 'a': \"(aa)ac(aa)bb\", so the level is 2.\nIn the second example, we can select either substring \"a\" or \"b\" to get the answer 1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1100"
        ],
        "solutions": "1105B - Zuhair and StringsSince all the substrings of length k must be of the same latter, we can iterate over all letters from 'a' to 'z' and for each letter count the number of disjoint substrings of length k and take the maximum one. "
    },
    "1105A": {
        "title": "A. Salem and Sticks",
        "description": "Salem gave you n sticks with integer positive lengths a1,a2,\u2026,an.\nFor every stick, you can change its length to any other positive integer length (that is, either shrink or stretch it). The cost of changing the stick's length from a to b is |a\u2212b|, where |x| means the absolute value of x.\nA stick length ai is called almost good for some integer t if |ai\u2212t|\u22641.\nSalem asks you to change the lengths of some sticks (possibly all or none), such that all sticks' lengths are almost good for some positive integer t and the total cost of changing is minimum possible. The value of t is not fixed in advance and you can choose it as any positive integer. \nAs an answer, print the value of t and the minimum cost. If there are multiple optimal choices for t, print any of them.\nThe first line contains a single integer n (1\u2264n\u22641000)\u00a0\u2014 the number of sticks.\nThe second line contains n integers ai (1\u2264ai\u2264100)\u00a0\u2014 the lengths of the sticks.\nPrint the value of t and the minimum possible cost. If there are multiple optimal choices for t, print any of them.\nIn the first example, we can change 1 into 2 and 10 into 4 with cost |1\u22122|+|10\u22124|=1+6=7 and the resulting lengths [2,4,4] are almost good for t=3.\nIn the second example, the sticks lengths are already almost good for t=2, so we don't have to do anything.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1104B": {
        "title": "B. Game with string",
        "description": "Two people are playing a game with a string s, consisting of lowercase latin letters. \nOn a player's turn, he should choose two consecutive equal letters in the string and delete them. \nFor example, if the string is equal to \"xaax\" than there is only one possible turn: delete \"aa\", so the string will become \"xx\". A player not able to make a turn loses.\nYour task is to determine which player will win if both play optimally.\nThe only line contains the string s, consisting of lowercase latin letters (1\u2264|s|\u2264100000), where |s| means the length of a string s.\nIf the first player wins, print \"Yes\". If the second player wins, print \"No\".\nIn the first example the first player is unable to make a turn, so he loses.\nIn the second example first player turns the string into \"q\", then second player is unable to move, so he loses.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1104B - Game with stringIt can be shown that the answer does not depend on the order of deletions. Let's remove letters from left to right, storing a stack of letters, remaining in the left. When we process a letter, it will be deleted together with the last letter in the stack if they are equal or will be pushed to the stack. Let's calculate parity of the number of deletions during this process and determine the answer.Author: 300iqStatements and editorial: scanhex "
    },
    "1102C": {
        "title": "C. Doors Breaking and Repairing",
        "description": "You are policeman and you are playing a game with Slavik. The game is turn-based and each turn consists of two phases. During the first phase you make your move and during the second phase Slavik makes his move.\nThere are n doors, the i-th door initially has durability equal to ai.\nDuring your move you can try to break one of the doors. If you choose door i and its current durability is bi then you reduce its durability to max(0,bi\u2212x) (the value x is given).\nDuring Slavik's move he tries to repair one of the doors. If he chooses door i and its current durability is bi then he increases its durability to bi+y (the value y is given). Slavik cannot repair doors with current durability equal to 0.\nThe game lasts 10100 turns. If some player cannot make his move then he has to skip it.\nYour goal is to maximize the number of doors with durability equal to 0 at the end of the game. You can assume that Slavik wants to minimize the number of such doors. What is the number of such doors in the end if you both play optimally?\nThe first line of the input contains three integers n, x and y (1\u2264n\u2264100, 1\u2264x,y\u2264105) \u2014 the number of doors, value x and value y, respectively.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264105), where ai is the initial durability of the i-th door.\nPrint one integer \u2014 the number of doors with durability equal to 0 at the end of the game, if you and Slavik both play optimally.\nClarifications about the optimal strategy will be ignored.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "*1200"
        ],
        "solutions": "1102C - Doors Breaking and RepairingLet's consider two cases:If x>y then the answer is n because we can make opposite moves to the Slavik's moves and it always will reduce durability of some door (so at some point we will reach the state when all doors will have durability 0).Otherwise x\u2264y and we have to realize the optimal strategy for us. If we have some door with durability z\u2264x then let's break it immediately (why shouldn't we do this?). If we don't do it then Slavik will repair this door during his move. So what Slavik will do now? He will repair some door. Which door he has to repair? Of course the one with durability z\u2264x because otherwise we will break it during our next move. So we can realize that doors with durability z>x are not interesting for us because Slavik will make opposite moves to our moves. And what is the answer if the number of doors with durability z\u2264x equals to cnt? It is \u2308cnt2\u2309. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, x, y;\n\tcin >> n >> x >> y;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint cur;\n\t\tcin >> cur;\n\t\tif (cur <= x) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\t\n\tif (x > y) {\n\t\tcout << n << endl;\n\t} else {\n\t\tcout << (cnt + 1) / 2 << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1101A": {
        "title": "A. Minimum Integer",
        "description": "You are given q queries in the following form:\nGiven three integers li, ri and di, find minimum positive integer xi such that it is divisible by di and it does not belong to the segment [li,ri].\nCan you answer all the queries?\nRecall that a number x belongs to segment [l,r] if l\u2264x\u2264r.\nThe first line contains one integer q (1\u2264q\u2264500) \u2014 the number of queries.\nThen q lines follow, each containing a query given in the format li ri di (1\u2264li\u2264ri\u2264109, 1\u2264di\u2264109). li, ri and di are integers.\nFor each query print one integer: the answer to this query.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1101A - Minimum IntegerThere are two basic cases we have to consider: either the element we want to find is less than li, or it is greater than ri.In the first case, we are interested in di itself: it is the minimum positive number divisible by di, and if it is less than li, then it is the answer.In the second case, we have to find minimum element that is greater than ri and is divisible by di. This can be done as follows: we calculate the number of elements divisible by di that are not greater than ri as c=\u230aridi\u230b, and then we take (c+1)-th element, which is di(c+1). Solution (BledDest)q = int(input())\nfor i in range(q):\n    l, r, d = map(int, input().split())\n    if(d < l or d > r):\n        print(d)\n    else:\n        print((r // d) * d + d)"
    },
    "1100C": {
        "title": "C. NN and the Optical Illusion",
        "description": "NN is an experienced internet user and that means he spends a lot of time on the social media. Once he found the following image on the Net, which asked him to compare the sizes of inner circles:\nIt turned out that the circles are equal. NN was very surprised by this fact, so he decided to create a similar picture himself.\nHe managed to calculate the number of outer circles n and the radius of the inner circle r. NN thinks that, using this information, you can exactly determine the radius of the outer circles R so that the inner circle touches all of the outer ones externally and each pair of neighboring outer circles also touches each other. While NN tried very hard to guess the required radius, he didn't manage to do that. \nHelp NN find the required radius for building the required picture.\nThe first and the only line of the input file contains two numbers n and r (3\u2264n\u2264100, 1\u2264r\u2264100)\u00a0\u2014 the number of the outer circles and the radius of the inner circle respectively.\nOutput a single number R\u00a0\u2014 the radius of the outer circle required for building the required picture. \nYour answer will be accepted if its relative or absolute error does not exceed 10\u22126.\nFormally, if your answer is a and the jury's answer is b. Your answer is accepted if and only when |a\u2212b|max(1,|b|)\u226410\u22126.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "math",
            "*1200"
        ],
        "solutions": "1100C - NN and the Optical IllusionConsider three circles \u2014 inner and two outer. Since all the circles are tangent, the sides of the triangle constructed on the centers of the circles pass through the tangency points of the circles. Denote by \u03b1 the angle in an equilateral n -gon. Then \u03b1=\u03c0(n\u22122)n. On the other hand, Rr+R=cos(\u00a0alpha2). It can be noted that Rr+R=R+r\u2212rr+R=1\u2212rr+R, i.e. the function increases with R. On this basis, a binary search can be used to find the answer, or explicitly derive the formula R=rcos(\u03b12)1\u2212cos(\u03b12)The complexity is O(1) or O(logC). "
    },
    "1100A": {
        "title": "A. Roman and Browser",
        "description": "This morning, Roman woke up and opened the browser with n opened tabs numbered from 1 to n. There are two kinds of tabs: those with the information required for the test and those with social network sites. Roman decided that there are too many tabs open so he wants to close some of them.\nHe decided to accomplish this by closing every k-th (2\u2264k\u2264n\u22121) tab. Only then he will decide whether he wants to study for the test or to chat on the social networks. Formally, Roman will choose one tab (let its number be b) and then close all tabs with numbers c=b+i\u22c5k that satisfy the following condition: 1\u2264c\u2264n and i is an integer (it may be positive, negative or zero).\nFor example, if k=3, n=14 and Roman chooses b=8, then he will close tabs with numbers 2, 5, 8, 11 and 14.\nAfter closing the tabs Roman will calculate the amount of remaining tabs with the information for the test (let's denote it e) and the amount of remaining social network tabs (s). Help Roman to calculate the maximal absolute value of the difference of those values |e\u2212s| so that it would be easy to decide what to do next.\nThe first line contains two integers n and k (2\u2264k<n\u2264100) \u2014 the amount of tabs opened currently and the distance between the tabs closed.\nThe second line consists of n integers, each of them equal either to 1 or to \u22121. The i-th integer denotes the type of the i-th tab: if it is equal to 1, this tab contains information for the test, and if it is equal to \u22121, it's a social network tab.\nOutput a single integer \u2014 the maximum absolute difference between the amounts of remaining tabs of different types |e\u2212s|.\nIn the first example we can choose b=1 or b=3. We will delete then one tab of each type and the remaining tabs are then all contain test information. Thus, e=2 and s=0 and |e\u2212s|=2.\nIn the second example, on the contrary, we can leave opened only tabs that have social networks opened in them.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1100A - Roman and BrowserLoop over all values of b and take the sum of all indices that are not equivalent to . Remember to take the absolute value at the end. Runtime is . Code: 48374675"
    },
    "1099C": {
        "title": "C. Postcard",
        "description": "Andrey received a postcard from Irina. It contained only the words \"Hello, Andrey!\", and a strange string consisting of lowercase Latin letters, snowflakes and candy canes. Andrey thought that this string is an encrypted message, and decided to decrypt it.\nAndrey noticed that snowflakes and candy canes always stand after the letters, so he supposed that the message was encrypted as follows. Candy cane means that the letter before it can be removed, or can be left. A snowflake means that the letter before it can be removed, left, or repeated several times.\nFor example, consider the following string: \nThis string can encode the message \u00abhappynewyear\u00bb. For this, candy canes and snowflakes should be used as follows: \nPlease note that the same string can encode different messages. For example, the string above can encode \u00abhayewyar\u00bb, \u00abhapppppynewwwwwyear\u00bb, and other messages.\nAndrey knows that messages from Irina usually have a length of k letters. Help him to find out if a given string can encode a message of k letters, and if so, give an example of such a message.\nThe first line contains the string received in the postcard. The string consists only of lowercase Latin letters, as well as the characters \u00ab*\u00bb and \u00ab?\u00bb, meaning snowflake and candy cone, respectively. These characters can only appear immediately after the letter. The length of the string does not exceed 200.\nThe second line contains an integer number k (1\u2264k\u2264200), the required message length.\nPrint any message of length k that the given string can encode, or \u00abImpossible\u00bb if such a message does not exist.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1099B": {
        "title": "B. Squares and Segments",
        "description": "Little Sofia is in fourth grade. Today in the geometry lesson she learned about segments and squares. On the way home, she decided to draw n squares in the snow with a side length of 1. For simplicity, we assume that Sofia lives on a plane and can draw only segments of length 1, parallel to the coordinate axes, with vertices at integer points.\nIn order to draw a segment, Sofia proceeds as follows. If she wants to draw a vertical segment with the coordinates of the ends (x,y) and (x,y+1). Then Sofia looks if there is already a drawn segment with the coordinates of the ends (x\u2032,y) and (x\u2032,y+1) for some x\u2032. If such a segment exists, then Sofia quickly draws a new segment, using the old one as a guideline. If there is no such segment, then Sofia has to take a ruler and measure a new segment for a long time. Same thing happens when Sofia wants to draw a horizontal segment, but only now she checks for the existence of a segment with the same coordinates x, x+1 and the differing coordinate y.\nFor example, if Sofia needs to draw one square, she will have to draw two segments using a ruler: \nAfter that, she can draw the remaining two segments, using the first two as a guide: \nIf Sofia needs to draw two squares, she will have to draw three segments using a ruler: \nAfter that, she can draw the remaining four segments, using the first three as a guide: \nSofia is in a hurry, so she wants to minimize the number of segments that she will have to draw with a ruler without a guide. Help her find this minimum number.\nThe only line of input contains a single integer n (1\u2264n\u2264109), the number of squares that Sofia wants to draw.\nPrint single integer, the minimum number of segments that Sofia will have to draw with a ruler without a guide in order to draw n squares in the manner described above.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1097B": {
        "title": "B. Petr and a Combination Lock",
        "description": "Petr has just bought a new car. He's just arrived at the most known Petersburg's petrol station to refuel it when he suddenly discovered that the petrol tank is secured with a combination lock! The lock has a scale of 360 degrees and a pointer which initially points at zero:\nPetr called his car dealer, who instructed him to rotate the lock's wheel exactly n times. The i-th rotation should be ai degrees, either clockwise or counterclockwise, and after all n rotations the pointer should again point at zero.\nThis confused Petr a little bit as he isn't sure which rotations should be done clockwise and which should be done counterclockwise. As there are many possible ways of rotating the lock, help him and find out whether there exists at least one, such that after all n rotations the pointer will point at zero again.\nThe first line contains one integer n (1\u2264n\u226415) \u2014 the number of rotations.\nEach of the following n lines contains one integer ai (1\u2264ai\u2264180) \u2014 the angle of the i-th rotation in degrees.\nIf it is possible to do all the rotations so that the pointer will point at zero after all of them are performed, print a single word \"YES\". Otherwise, print \"NO\". Petr will probably buy a new car in this case.\nYou can print each letter in any case (upper or lower).\nIn the first example, we can achieve our goal by applying the first and the second rotation clockwise, and performing the third rotation counterclockwise.\nIn the second example, it's impossible to perform the rotations in order to make the pointer point at zero in the end.\nIn the third example, Petr can do all three rotations clockwise. In this case, the whole wheel will be rotated by 360 degrees clockwise and the pointer will point at zero again.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "*1200"
        ],
        "solutions": "1097B - Petr and a Combination LockThe best way to check the condition in the statement is to use bitmasks. Iterate from 0 to 2n\u22121 and for each number consider its binary representation. If the i-th bit of the representation is set to 0, then decide to perform the i-th rotation clockwise. In the opposite case, do it counterclockwise. Finally, check if the whole angle is a multiple of 360 and if so, output \"YES\". If no good combination of rotations was found, output \"NO\". "
    },
    "1091B": {
        "title": "B. New Year and the Treasure Geolocation",
        "description": "Bob is a pirate looking for the greatest treasure the world has ever seen. The treasure is located at the point T, which coordinates to be found out.\nBob travelled around the world and collected clues of the treasure location at n obelisks. These clues were in an ancient language, and he has only decrypted them at home. Since he does not know which clue belongs to which obelisk, finding the treasure might pose a challenge. Can you help him?\nAs everyone knows, the world is a two-dimensional plane. The i-th obelisk is at integer coordinates (xi,yi). The j-th clue consists of 2 integers (aj,bj) and belongs to the obelisk pj, where p is some (unknown) permutation on n elements. It means that the treasure is located at T=(xpj+aj,ypj+bj). This point T is the same for all clues.\nIn other words, each clue belongs to exactly one of the obelisks, and each obelisk has exactly one clue that belongs to it. A clue represents the vector from the obelisk to the treasure. The clues must be distributed among the obelisks in such a way that they all point to the same position of the treasure.\nYour task is to find the coordinates of the treasure. If there are multiple solutions, you may print any of them.\nNote that you don't need to find the permutation. Permutations are used only in order to explain the problem.\nThe first line contains an integer n\u00a0(1\u2264n\u22641000)\u00a0\u2014 the number of obelisks, that is also equal to the number of clues.\nEach of the next n lines contains two integers xi, yi\u00a0(\u2212106\u2264xi,yi\u2264106)\u00a0\u2014 the coordinates of the i-th obelisk. All coordinates are distinct, that is xi\u2260xj or yi\u2260yj will be satisfied for every (i,j) such that i\u2260j. \nEach of the next n lines contains two integers ai, bi\u00a0(\u22122\u22c5106\u2264ai,bi\u22642\u22c5106)\u00a0\u2014 the direction of the i-th clue. All coordinates are distinct, that is ai\u2260aj or bi\u2260bj will be satisfied for every (i,j) such that i\u2260j. \nIt is guaranteed that there exists a permutation p, such that for all i,j it holds (xpi+ai,ypi+bi)=(xpj+aj,ypj+bj). \nOutput a single line containing two integers Tx,Ty\u00a0\u2014 the coordinates of the treasure.\nIf there are multiple answers, you may print any of them.\nAs n=2, we can consider all permutations on two elements. \nIf p=[1,2], then the obelisk (2,5) holds the clue (7,\u22122), which means that the treasure is hidden at (9,3). The second obelisk (\u22126,4) would give the clue (\u22121,\u22123) and the treasure at (\u22127,1). However, both obelisks must give the same location, hence this is clearly not the correct permutation.\nIf the hidden permutation is [2,1], then the first clue belongs to the second obelisk and the second clue belongs to the first obelisk. Hence (\u22126,4)+(7,\u22122)=(2,5)+(\u22121,\u22123)=(1,2), so T=(1,2) is the location of the treasure.\nIn the second sample, the hidden permutation is [2,3,4,1].",
        "time limit": "time limit per test1.5 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1091B - New Year and the Treasure GeolocationWe know that there exists some permutation p such that for all i the following holds: (tx,ty)=(xpi+ai,ypi+bi)Summing this for all i we get:n\u22c5(tx,ty)=\u2211(xpi+ai,ypi+bi)=(\u2211(xpi+ai),\u2211(ypi+bi))=(\u2211xi+\u2211ai,\u2211yi+\u2211bi)We can thus sum all x, respectively y, coordinates of both obelisks and clues, and divide by n. This takes O(n) time.Alternative solution: Take the lexicographically smallest obelisk coordinate. It is clear that this needs to be paired with the lexicographically largest clue. We simply find minimum and maximum in O(n) and sum. Code#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define x first\n#define y second\n\nint main() {\n    int N; cin >> N;\n    vector<pii> O(N), T(N);\n    for (int i = 0; i < N; i++) cin >> O[i].x >> O[i].y;\n    for (int i = 0; i < N; i++) cin >> T[i].x >> T[i].y;\n    sort(O.begin(),O.end());\n    sort(T.begin(),T.end());\n    reverse(T.begin(),T.end());\n\n    vector<pii> Ans(N);\n    for (int i = 0; i < N; i++) Ans[i] = {O[i].x+T[i].x, O[i].y+T[i].y};\n    sort(Ans.begin(),Ans.end());\n    cout << Ans[0].x << ' ' << Ans[0].y << endl;\n} "
    },
    "1090M": {
        "title": "M. The Pleasant Walk",
        "description": "There are n houses along the road where Anya lives, each one is painted in one of k possible colors.\nAnya likes walking along this road, but she doesn't like when two adjacent houses at the road have the same color. She wants to select a long segment of the road such that no two adjacent houses have the same color.\nHelp Anya find the longest segment with this property.\nThe first line contains two integers n and k\u00a0\u2014 the number of houses and the number of colors (1\u2264n\u2264100000, 1\u2264k\u2264100000).\nThe next line contains n integers a1,a2,\u2026,an\u00a0\u2014 the colors of the houses along the road (1\u2264ai\u2264k).\nOutput a single integer\u00a0\u2014 the maximum number of houses on the road segment having no two adjacent houses of the same color.\nIn the example, the longest segment without neighboring houses of the same color is from the house 4 to the house 7. The colors of the houses are [3,2,1,2] and its length is 4 houses.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1088B": {
        "title": "B. Ehab and subtraction",
        "description": "You're given an array a. You should repeat the following operation k times: find the minimum non-zero element in the array, print it, and then subtract it from all the non-zero elements of the array. If all the elements are 0s, just print 0.\nThe first line contains integers n and k (1\u2264n,k\u2264105), the length of the array and the number of operations you should perform.\nThe second line contains n space-separated integers a1,a2,\u2026,an (1\u2264ai\u2264109), the elements of the array.\nPrint the minimum non-zero element before each operation in a new line.\nIn the first sample:\nIn the first step: the array is [1,2,3], so the minimum non-zero element is 1.\nIn the second step: the array is [0,1,2], so the minimum non-zero element is 1.\nIn the third step: the array is [0,0,1], so the minimum non-zero element is 1.\nIn the fourth and fifth step: the array is [0,0,0], so we printed 0.\nIn the second sample:\nIn the first step: the array is [10,3,5,3], so the minimum non-zero element is 3.\nIn the second step: the array is [7,0,2,0], so the minimum non-zero element is 2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1000"
        ],
        "solutions": "1088B - Ehab and subtractionLet s be the set of numbers in input (sorted and distinct). In the ith step, si is subtracted from all bigger or equal elements, and all smaller elements are 0. Thus, the answer in the ith step is si\u2009-\u2009si\u2009-\u20091 (s0\u2009=\u20090).Code link: https://pastebin.com/bpz1YxBeTime complexity: O(nlog(n))."
    },
    "1085B": {
        "title": "B. Div Times Mod",
        "description": "Vasya likes to solve equations. Today he wants to solve (x\u00a0div\u00a0k)\u22c5(xmodk)=n, where div and mod stand for integer division and modulo operations (refer to the Notes below for exact definition). In this equation, k and n are positive integer parameters, and x is a positive integer unknown. If there are several solutions, Vasya wants to find the smallest possible x. Can you help him?\nThe first line contains two integers n and k (1\u2264n\u2264106, 2\u2264k\u22641000).\nPrint a single integer x\u00a0\u2014 the smallest positive integer solution to (x\u00a0div\u00a0k)\u22c5(xmodk)=n. It is guaranteed that this equation has at least one positive integer solution.\nThe result of integer division a\u00a0div\u00a0b is equal to the largest integer c such that b\u22c5c\u2264a. a modulo b (shortened amodb) is the only integer c such that 0\u2264c<b, and a\u2212c is divisible by b.\nIn the first sample, 11\u00a0div\u00a03=3 and 11mod3=2. Since 3\u22c52=6, then x=11 is a solution to (x\u00a0div\u00a03)\u22c5(xmod3)=6. One can see that 19 is the only other positive integer solution, hence 11 is the smallest one.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1084B": {
        "title": "B. Kvass and the Fair Nut",
        "description": "The Fair Nut likes kvass very much. On his birthday parents presented him n kegs of kvass. There are vi liters of kvass in the i-th keg. Each keg has a lever. You can pour your glass by exactly 1 liter pulling this lever. The Fair Nut likes this drink very much, so he wants to pour his glass by s liters of kvass. But he wants to do it, so kvass level in the least keg is as much as possible.\nHelp him find out how much kvass can be in the least keg or define it's not possible to pour his glass by s liters of kvass.\nThe first line contains two integers n and s (1\u2264n\u2264103, 1\u2264s\u22641012)\u00a0\u2014 the number of kegs and glass volume.\nThe second line contains n integers v1,v2,\u2026,vn (1\u2264vi\u2264109)\u00a0\u2014 the volume of i-th keg.\nIf the Fair Nut cannot pour his glass by s liters of kvass, print \u22121. Otherwise, print a single integer\u00a0\u2014 how much kvass in the least keg can be.\nIn the first example, the answer is 3, the Fair Nut can take 1 liter from the first keg and 2 liters from the third keg. There are 3 liters of kvass in each keg.\nIn the second example, the answer is 2, the Fair Nut can take 3 liters from the first keg and 1 liter from the second keg.\nIn the third example, the Fair Nut can't pour his cup by 7 liters, so the answer is \u22121.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1084A": {
        "title": "A. The Fair Nut and Elevator",
        "description": "The Fair Nut lives in n story house. ai people live on the i-th floor of the house. Every person uses elevator twice a day: to get from the floor where he/she lives to the ground (first) floor and to get from the first floor to the floor where he/she lives, when he/she comes back home in the evening. \nIt was decided that elevator, when it is not used, will stay on the x-th floor, but x hasn't been chosen yet. When a person needs to get from floor a to floor b, elevator follows the simple algorithm: \nYour task is to help Nut to find the minimum number of electricity units, that it would be enough for one day, by choosing an optimal the x-th floor. Don't forget than elevator initially stays on the x-th floor. \nThe first line contains one integer n (1\u2264n\u2264100)\u00a0\u2014 the number of floors.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264100)\u00a0\u2014 the number of people on each floor.\nIn a single line, print the answer to the problem\u00a0\u2014 the minimum number of electricity units.\nIn the first example, the answer can be achieved by choosing the second floor as the x-th floor. Each person from the second floor (there are two of them) would spend 4 units of electricity per day (2 to get down and 2 to get up), and one person from the third would spend 8 units of electricity per day (4 to get down and 4 to get up). 4\u22c52+8\u22c51=16.\nIn the second example, the answer can be achieved by choosing the first floor as the x-th floor.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "1082A": {
        "title": "A. Vasya and Book",
        "description": "Vasya is reading a e-book. The file of the book consists of n pages, numbered from 1 to n. The screen is currently displaying the contents of page x, and Vasya wants to read the page y. There are two buttons on the book which allow Vasya to scroll d pages forwards or backwards (but he cannot scroll outside the book). For example, if the book consists of 10 pages, and d=3, then from the first page Vasya can scroll to the first or to the fourth page by pressing one of the buttons; from the second page \u2014 to the first or to the fifth; from the sixth page \u2014 to the third or to the ninth; from the eighth \u2014 to the fifth or to the tenth.\nHelp Vasya to calculate the minimum number of times he needs to press a button to move to page y.\nThe first line contains one integer t (1\u2264t\u2264103) \u2014 the number of testcases.\nEach testcase is denoted by a line containing four integers n, x, y, d (1\u2264n,d\u2264109, 1\u2264x,y\u2264n) \u2014 the number of pages, the starting page, the desired page, and the number of pages scrolled by pressing one button, respectively.\nPrint one line for each test.\nIf Vasya can move from page x to page y, print the minimum number of times he needs to press a button to do it. Otherwise print \u22121.\nIn the first test case the optimal sequence is: 4\u21922\u21921\u21923\u21925.\nIn the second test case it is possible to get to pages 1 and 5.\nIn the third test case the optimal sequence is: 4\u21927\u219210\u219213\u219216\u219219.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1082A - Vasya and BookIt is easy to understand that the optimal answer is achieved in one of three cases:   Vasya is trying to visit page y without visiting pages 1 and n;  Vasya first goes to the page 1, and then to the page y;  Vasya first goes to the n page, and then to the y page. In the first case, Vasya can go directly to the y page from the x page if |x\u2212y| is divided by d.In the second case, Vasya can get to page y through page 1, if y\u22121 is divided by d. The required number of actions will be equal to \u2308x\u22121d\u2309+y\u22121d.Similarly, in the third case, Vasya can go to the page y through the page n if n\u2212y is divided by d. The required number of actions will be equal to \u2308n\u2212xd\u2309+n\u2212yd.If none of the three options described above is appropriate, then there is no answer. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = int(2e9) + 99;\n\nint n, x, y, d;\n\nint dist(int x, int y){\n\treturn (abs(x - y) + (d - 1)) / d;\n}\n\nint main() {\n\t\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; ++i){\n    \tcin >> n >> x >> y >> d;\n    \t\n    \tint len = abs(x - y);\n    \tint res = INF;\n    \t\n    \tif(len % d == 0) \n    \t\tres = min(res, dist(x, y));\n    \t\n    \tlen = y - 1;\n    \tif(len % d == 0)\n    \t\tres = min(res, dist(x, 1) + dist(1, y));\n    \t\n    \tlen = n - y;\n    \tif(len % d == 0)\n    \t\tres = min(res, dist(x, n) + dist(n, y));\n    \t\t\n    \tif(res == INF)\n    \t\tres = -1;\n    \t\n    \tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1077B": {
        "title": "B. Disturbed People",
        "description": "There is a house with n flats situated on the main street of Berlatov. Vova is watching this house every night. The house can be represented as an array of n integer numbers a1,a2,\u2026,an, where ai=1 if in the i-th flat the light is on and ai=0 otherwise.\nVova thinks that people in the i-th flats are disturbed and cannot sleep if and only if 1<i<n and ai\u22121=ai+1=1 and ai=0.\nVova is concerned by the following question: what is the minimum number k such that if people from exactly k pairwise distinct flats will turn off the lights then nobody will be disturbed? Your task is to find this number k.\nThe first line of the input contains one integer n (3\u2264n\u2264100) \u2014 the number of flats in the house.\nThe second line of the input contains n integers a1,a2,\u2026,an (ai\u2208{0,1}), where ai is the state of light in the i-th flat.\nPrint only one integer \u2014 the minimum number k such that if people from exactly k pairwise distinct flats will turn off the light then nobody will be disturbed.\nIn the first example people from flats 2 and 7 or 4 and 7 can turn off the light and nobody will be disturbed. It can be shown that there is no better answer in this example.\nThere are no disturbed people in second and third examples.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1077B - Disturbed PeopleThe first observation is that we are interested only in patterns of kind \"101\". All other patterns don't make sense at all.So, let's build a greedy approach. Let's iterate over the given array from the left to the right and maintain that the prefix of the given answer is already correct. If now we are at some position i, ai\u22121=ai+1=1 and ai=0 (and the prefix from 1 to i\u22122 is already correct) then which one 1 we have to replace? When we replace the left one then we cannot do better in the future, but when we replace the right one then we can fix some on the suffix of the array.The easiest example is \"1101011\". If now we are at the position 3 then we will do better if we will set a4:=0. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 1; i < n - 1; ++i) {\n\t\tif (a[i] == 0 && a[i - 1] == 1 && a[i + 1] == 1) {\n\t\t\t++ans;\n\t\t\ta[i + 1] = 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
    },
    "1076B": {
        "title": "B. Divisor Subtraction",
        "description": "You are given an integer number n. The following algorithm is applied to it:\nDetermine the number of subtrations the algorithm will make.\nThe only line contains a single integer n (2\u2264n\u22641010).\nPrint a single integer \u2014 the number of subtractions the algorithm will make.\nIn the first example 5 is the smallest prime divisor, thus it gets subtracted right away to make a 0.\nIn the second example 2 is the smallest prime divisor at both steps.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1076A": {
        "title": "A. Minimizing the String",
        "description": "You are given a string s consisting of n lowercase Latin letters.\nYou have to remove at most one (i.e. zero or one) character of this string in such a way that the string you obtain will be lexicographically smallest among all strings that can be obtained using this operation.\nString s=s1s2\u2026sn is lexicographically smaller than string t=t1t2\u2026tm if n<m and s1=t1,s2=t2,\u2026,sn=tn or there exists a number p such that p\u2264min(n,m) and s1=t1,s2=t2,\u2026,sp\u22121=tp\u22121 and sp<tp.\nFor example, \"aaa\" is smaller than \"aaaa\", \"abb\" is smaller than \"abc\", \"pqr\" is smaller than \"z\".\nThe first line of the input contains one integer n (2\u2264n\u22642\u22c5105) \u2014 the length of s.\nThe second line of the input contains exactly n lowercase Latin letters \u2014 the string s.\nPrint one string \u2014 the smallest possible lexicographically string that can be obtained by removing at most one character from the string s.\nIn the first example you can remove any character of s to obtain the string \"aa\".\nIn the second example \"abca\" < \"abcd\" < \"abcda\" < \"abda\" < \"acda\" < \"bcda\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1075B": {
        "title": "B. Taxi drivers and Lyft",
        "description": "Palo Alto is an unusual city because it is an endless coordinate line. It is also known for the office of Lyft Level 5.\nLyft has become so popular so that it is now used by all m taxi drivers in the city, who every day transport the rest of the city residents\u00a0\u2014 n riders.\nEach resident (including taxi drivers) of Palo-Alto lives in its unique location (there is no such pair of residents that their coordinates are the same).\nThe Lyft system is very clever: when a rider calls a taxi, his call does not go to all taxi drivers, but only to the one that is the closest to that person. If there are multiple ones with the same distance, then to taxi driver with a smaller coordinate is selected.\nBut one morning the taxi drivers wondered: how many riders are there that would call the given taxi driver if they were the first to order a taxi on that day? In other words, you need to find for each taxi driver i the number ai\u00a0\u2014 the number of riders that would call the i-th taxi driver when all drivers and riders are at their home?\nThe taxi driver can neither transport himself nor other taxi drivers.\nThe first line contains two integers n and m (1\u2264n,m\u2264105)\u00a0\u2014 number of riders and taxi drivers.\nThe second line contains n+m integers x1,x2,\u2026,xn+m (1\u2264x1<x2<\u2026<xn+m\u2264109), where xi is the coordinate where the i-th resident lives. \nThe third line contains n+m integers t1,t2,\u2026,tn+m (0\u2264ti\u22641). If ti=1, then the i-th resident is a taxi driver, otherwise ti=0.\nIt is guaranteed that the number of i such that ti=1 is equal to m.\nPrint m integers a1,a2,\u2026,am, where ai is the answer for the i-th taxi driver. The taxi driver has the number i if among all the taxi drivers he lives in the i-th smallest coordinate (see examples for better understanding).\nIn the first example, we have only one taxi driver, which means an order from any of n riders will go to him.\nIn the second example, the first taxi driver lives at the point with the coordinate 2, and the second one lives at the point with the coordinate 6. Obviously, the nearest taxi driver to the rider who lives on the 3 coordinate is the first one, and to the rider who lives on the coordinate 5 is the second one. The rider who lives on the 4 coordinate has the same distance to the first and the second taxi drivers, but since the first taxi driver has a smaller coordinate, the call from this rider will go to the first taxi driver.\nIn the third example, we have one rider and the taxi driver nearest to him is the fourth one.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1073B": {
        "title": "B. Vasya and Books",
        "description": "Vasya has got n books, numbered from 1 to n, arranged in a stack. The topmost book has number a1, the next one \u2014 a2, and so on. The book at the bottom of the stack has number an. All numbers are distinct.\nVasya wants to move all the books to his backpack in n steps. During i-th step he wants to move the book number bi into his backpack. If the book with number bi is in the stack, he takes this book and all the books above the book bi, and puts them into the backpack; otherwise he does nothing and begins the next step. For example, if books are arranged in the order [1,2,3] (book 1 is the topmost), and Vasya moves the books in the order [2,1,3], then during the first step he will move two books (1 and 2), during the second step he will do nothing (since book 1 is already in the backpack), and during the third step \u2014 one book (the book number 3). Note that b1,b2,\u2026,bn are distinct.\nHelp Vasya! Tell him the number of books he will put into his backpack during each step.\nThe first line contains one integer n\u00a0(1\u2264n\u22642\u22c5105) \u2014 the number of books in the stack.\nThe second line contains n integers a1,a2,\u2026,an\u00a0(1\u2264ai\u2264n) denoting the stack of books.\nThe third line contains n integers b1,b2,\u2026,bn\u00a0(1\u2264bi\u2264n) denoting the steps Vasya is going to perform.\nAll numbers a1\u2026an are distinct, the same goes for b1\u2026bn.\nPrint n integers. The i-th of them should be equal to the number of books Vasya moves to his backpack during the i-th step.\nThe first example is described in the statement.\nIn the second example, during the first step Vasya will move the books [3,1,4]. After that only books 2 and 5 remain in the stack (2 is above 5). During the second step Vasya will take the books 2 and 5. After that the stack becomes empty, so during next steps Vasya won't move any books.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "1073B - Vasya and BooksLet's maintain the pointer pos to the topmost non-deleted book and whether each book whether is removed from the stack or not. Initially, all books are in a stack, and pos is 0 (if we store the array 0-indexed). We will process the array B in the order b1,b2,\u2026bn. If the current book bi is removed from the stack, then the answer for it is zero. Otherwise, we will increment the pointer pos until the equality apos=bi is satisfied, while marking all the intermediate books in the array u. After that, the answer for the book bi will be the number of marked books in the u array (including itself).Since the pointer pos shifts n times at total, we get a solution with an O(n) complexity. Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = int(2e5) + 9;\n\nint n;\nint a[N];\nint b[N];\nbool u[N];\n\nint main() {\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i) {\n    \tscanf(\"%d\", a + i);\n    }\n    for(int i = 0; i < n; ++i){\n    \tscanf(\"%d\", b + i);\n    }\n\t\n\tint pos = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x = b[i];\n\t\tif(u[x]){\n\t\t\tprintf(\"0 \");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\t++cnt;\n\t\t\tu[a[pos]] = true;\n\t\t\tif(a[pos] == x) break;\n\t\t\t++pos;\n\t\t} \n\t\t\n\t\t++pos;\n\t\tprintf(\"%d \", cnt);\n\t}    \n\t\n\tputs(\"\");\n    return 0;\n}"
    },
    "1073A": {
        "title": "A. Diverse Substring",
        "description": "You are given a string s, consisting of n lowercase Latin letters.\nA substring of string s is a continuous segment of letters from s. For example, \"defor\" is a substring of \"codeforces\" and \"fors\" is not. \nThe length of the substring is the number of letters in it.\nLet's call some string of length n diverse if and only if there is no letter to appear strictly more than n2 times. For example, strings \"abc\" and \"iltlml\" are diverse and strings \"aab\" and \"zz\" are not.\nYour task is to find any diverse substring of string s or report that there is none. Note that it is not required to maximize or minimize the length of the resulting substring.\nThe first line contains a single integer n (1\u2264n\u22641000) \u2014 the length of string s.\nThe second line is the string s, consisting of exactly n lowercase Latin letters.\nPrint \"NO\" if there is no diverse substring in the string s.\nOtherwise the first line should contain \"YES\". The second line should contain any diverse substring of string s.\nThe first example has lots of correct answers. \nPlease, restrain yourself from asking if some specific answer is correct for some specific test or not, these questions always lead to \"No comments\" answer.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1073A - Diverse SubstringNotice that the string of two distinct letter is already diverse. That implies that the answer is \"NO\" if and only if all the letters in the string are the same. Otherwise you can check all pairs of adjacent letters in O(n).Overall complexity: O(n). Solution (PikMike)n = int(input())\ns = input()\nfor i in range(n - 1):\n\tif (s[i] != s[i + 1]):\n\t\tprint(\"YES\")\n\t\tprint(s[i], s[i + 1], sep=\"\")\n\t\texit(0)\nprint(\"NO\")"
    },
    "1070K": {
        "title": "K. Video Posts",
        "description": "Polycarp took n videos, the duration of the i-th video is ai seconds. The videos are listed in the chronological order, i.e. the 1-st video is the earliest, the 2-nd video is the next, ..., the n-th video is the last.\nNow Polycarp wants to publish exactly k (1\u2264k\u2264n) posts in Instabram. Each video should be a part of a single post. The posts should preserve the chronological order, it means that the first post should contain one or more of the earliest videos, the second post should contain a block (one or more videos) going next and so on. In other words, if the number of videos in the j-th post is sj then:\nPolycarp is a perfectionist, he wants the total duration of videos in each post to be the same.\nHelp Polycarp to find such positive integer values s1,s2,\u2026,sk that satisfy all the conditions above.\nThe first line contains two integers n and k (1\u2264k\u2264n\u2264105). The next line contains n positive integer numbers a1,a2,\u2026,an (1\u2264ai\u2264104), where ai is the duration of the i-th video.\nIf solution exists, print \"Yes\" in the first line. Print k positive integers s1,s2,\u2026,sk (s1+s2+\u22ef+sk=n) in the second line. The total duration of videos in each post should be the same. It can be easily proven that the answer is unique (if it exists).\nIf there is no solution, print a single line \"No\".",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1068B": {
        "title": "B. LCM",
        "description": "Ivan has number b. He is sorting through the numbers a from 1 to 1018, and for every a writes [a,b]a on blackboard. Here [a,b] stands for least common multiple of a and b. Ivan is very lazy, that's why this task bored him soon. But he is interested in how many different numbers he would write on the board if he would finish the task. Help him to find the quantity of different numbers he would write on the board.\nThe only line contains one integer\u00a0\u2014 b (1\u2264b\u22641010).\nPrint one number\u00a0\u2014 answer for the problem.\nIn the first example [a,1]=a, therefore [a,b]a is always equal to 1.\nIn the second example [a,2] can be equal to a or 2\u22c5a depending on parity of a. [a,b]a can be equal to 1 and 2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1066A": {
        "title": "A. Vova and Train",
        "description": "Vova plans to go to the conference by train. Initially, the train is at the point 1 and the destination point of the path is the point L. The speed of the train is 1 length unit per minute (i.e. at the first minute the train is at the point 1, at the second minute \u2014 at the point 2 and so on).\nThere are lanterns on the path. They are placed at the points with coordinates divisible by v (i.e. the first lantern is at the point v, the second is at the point 2v and so on).\nThere is also exactly one standing train which occupies all the points from l to r inclusive.\nVova can see the lantern at the point p if p is divisible by v and there is no standing train at this position (p\u2209[l;r]). Thus, if the point with the lantern is one of the points covered by the standing train, Vova can't see this lantern.\nYour problem is to say the number of lanterns Vova will see during the path. Vova plans to go to t different conferences, so you should answer t independent queries.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of queries.\nThen t lines follow. The i-th line contains four integers Li,vi,li,ri (1\u2264L,v\u2264109, 1\u2264l\u2264r\u2264L) \u2014 destination point of the i-th path, the period of the lantern appearance and the segment occupied by the standing train.\nPrint t lines. The i-th line should contain one integer \u2014 the answer for the i-th query.\nFor the first example query, the answer is 3. There are lanterns at positions 2, 4, 6, 8 and 10, but Vova didn't see the lanterns at positions 4 and 6 because of the standing train.\nFor the second example query, the answer is 0 because the only lantern is at the point 51 and there is also a standing train at this point.\nFor the third example query, the answer is 1134 because there are 1234 lanterns, but Vova didn't see the lanterns from the position 100 to the position 199 inclusive.\nFor the fourth example query, the answer is 0 because the standing train covers the whole path.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "1066A - Vova and TrainWhat is the number of lanterns Vova will see from 1 to L? This number is \u230aLv\u230b. Now we have to subtract the number of lanters in range [l;r] from this number. This number equals to \u230arv\u230b\u2212\u230al\u22121v\u230b. So the answer is \u230aLv\u230b - \u230arv\u230b + \u230al\u22121v\u230b. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint t;\n\tcin >> t;\n\t\n\tfor (int i = 0; i < t; ++i) {\t\n\t\tint L, v, l, r;\n\t\tcin >> L >> v >> l >> r;\n\t\tcout << L / v - r / v + (l - 1) / v << endl;\n\t}\n\t\n\treturn 0;\n}"
    },
    "1064B": {
        "title": "B. Equations of Mathematical Magic",
        "description": "Reading the book \"Equations of Mathematical Magic\" Roman Oira-Oira and Cristobal Junta found an interesting equation: a\u2212(a\u2295x)\u2212x=0 for some given a, where \u2295 stands for a bitwise exclusive or (XOR) of two integers (this operation is denoted as ^ or xor in many modern programming languages). Oira-Oira quickly found some x, which is the solution of the equation, but Cristobal Junta decided that Oira-Oira's result is not interesting enough, so he asked his colleague how many non-negative solutions of this equation exist. This task turned out to be too difficult for Oira-Oira, so he asks you to help.\nEach test contains several possible values of a and your task is to find the number of equation's solution for each of them. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of these values.\nThe following t lines contain the values of parameter a, each value is an integer from 0 to 230\u22121 inclusive.\nFor each value of a print exactly one integer\u00a0\u2014 the number of non-negative solutions of the equation for the given value of the parameter. Print answers in the same order as values of a appear in the input.\nOne can show that the number of solutions is always finite.\nLet's define the bitwise exclusive OR (XOR) operation. Given two integers x and y, consider their binary representations (possibly with leading zeroes): xk\u2026x2x1x0 and yk\u2026y2y1y0. Here, xi is the i-th bit of the number x and yi is the i-th bit of the number y. Let r=x\u2295y be the result of the XOR operation of x and y. Then r is defined as rk\u2026r2r1r0 where:\nri={1,\u00a0if\u00a0xi\u2260yi0,\u00a0if\u00a0xi=yi\nFor the first value of the parameter, only x=0 is a solution of the equation.\nFor the second value of the parameter, solutions are x=0 and x=2.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solutions": "1064B - \u0423\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043c\u0430\u0433\u0438\u0438Rewriting equation we have a\u2295x=a\u2212x.If you look in the xor definition, it is easy to see, that a\u2295x\u2265a\u2212x, no matter a and x (just look at the each bit of the a\u2295x).And the equality handles only if bits of x form a subset of bits of a.So the answer is 2t, where t is the number of bits in a (also known as popcount). "
    },
    "1060B": {
        "title": "B. Maximum Sum of Digits",
        "description": "You are given a positive integer n.\nLet S(x) be sum of digits in base 10 representation of x, for example, S(123)=1+2+3=6, S(0)=0.\nYour task is to find two integers a,b, such that 0\u2264a,b\u2264n, a+b=n and S(a)+S(b) is the largest possible among all such pairs.\nThe only line of input contains an integer n (1\u2264n\u22641012).\nPrint largest S(a)+S(b) among all pairs of integers a,b, such that 0\u2264a,b\u2264n and a+b=n.\nIn the first example, you can choose, for example, a=17 and b=18, so that S(17)+S(18)=1+7+1+8=17. It can be shown that it is impossible to get a larger answer.\nIn the second test example, you can choose, for example, a=5000000001 and b=4999999999, with S(5000000001)+S(4999999999)=91. It can be shown that it is impossible to get a larger answer.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1059A": {
        "title": "A. Cashier",
        "description": "Vasya has recently got a job as a cashier at a local store. His day at work is L minutes long. Vasya has already memorized n regular customers, the i-th of which comes after ti minutes after the beginning of the day, and his service consumes li minutes. It is guaranteed that no customer will arrive while Vasya is servicing another customer. \nVasya is a bit lazy, so he likes taking smoke breaks for a minutes each. Those breaks may go one after another, but Vasya must be present at work during all the time periods he must serve regular customers, otherwise one of them may alert his boss. What is the maximum number of breaks Vasya can take during the day?\nThe first line contains three integers n, L and a (0\u2264n\u2264105, 1\u2264L\u2264109, 1\u2264a\u2264L).\nThe i-th of the next n lines contains two integers ti and li (0\u2264ti\u2264L\u22121, 1\u2264li\u2264L). It is guaranteed that ti+li\u2264ti+1 and tn+ln\u2264L.\nOutput one integer \u00a0\u2014 the maximum number of breaks.\nIn the first sample Vasya can take 3 breaks starting after 2, 5 and 8 minutes after the beginning of the day.\nIn the second sample Vasya can take 2 breaks starting after 0 and 2 minutes after the beginning of the day.\nIn the third sample Vasya can't take any breaks.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1059A - CashierThere are only n+1 possible segments of time when Vasya can take breaks: between the consecutive clients, before the first client, and after the last client. If the length of the i-th such segment is s, Vasya may take at most \u230asa\u230b breaks, so we just sum those values over the n+1 possible segments. Time complexity is O(n). Code#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\n\nint n, L, a;\nint t[maxn], l[maxn];\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &L, &a);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &t[i], &l[i]);\n\t}\n\tint start = 0;\n\tint ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += (t[i] - start)/a;\n\t\tstart = t[i] + l[i];\n\t}\n\tans += (L - start)/a;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}"
    },
    "1054B": {
        "title": "B. Appending Mex",
        "description": "Initially Ildar has an empty array. He performs n steps. On each step he takes a subset of integers already added to the array and appends the mex of this subset to the array. \nThe mex of an multiset of integers is the smallest non-negative integer not presented in the multiset. For example, the mex of the multiset [0,2,3] is 1, while the mex of the multiset [1,2,1] is 0.\nMore formally, on the step m, when Ildar already has an array a1,a2,\u2026,am\u22121, he chooses some subset of indices 1\u2264i1<i2<\u2026<ik<m (possibly, empty), where 0\u2264k<m, and appends the mex(ai1,ai2,\u2026aik) to the end of the array.\nAfter performing all the steps Ildar thinks that he might have made a mistake somewhere. He asks you to determine for a given array a1,a2,\u2026,an the minimum step t such that he has definitely made a mistake on at least one of the steps 1,2,\u2026,t, or determine that he could have obtained this array without mistakes.\nThe first line contains a single integer n (1\u2264n\u2264100000)\u00a0\u2014 the number of steps Ildar made.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the array Ildar obtained.\nIf Ildar could have chosen the subsets on each step in such a way that the resulting array is a1,a2,\u2026,an, print \u22121.\nOtherwise print a single integer t\u00a0\u2014 the smallest index of a step such that a mistake was made on at least one step among steps 1,2,\u2026,t.\nIn the first example it is possible that Ildar made no mistakes. Here is the process he could have followed.\nThus, he can get the array without mistakes, so the answer is \u22121.\nIn the second example he has definitely made a mistake on the very first step, because he could not have obtained anything different from 0.\nIn the third example he could have obtained [0,1,2] without mistakes, but 239 is definitely wrong.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "1054B - Appending MexIldar has written an array correctly if there exists numbers 0,1,\u2026,ai\u22121 to the left of ai for all i. This is equivalent to ai\u2264max(\u22121,a1,a2,\u2026,ai\u22121)+1 for all i. If this condition is false for some i we made a mistake.So the solution is to check that ai\u2264max(\u22121,a1,a2,\u2026,ai\u22121)+1 in the increasing order of i. If it is false i is answer. If it is always true answer is \u22121.Time complexity: O(n). Jury's solution: 44522430 "
    },
    "1051B": {
        "title": "B. Relatively Prime Pairs",
        "description": "You are given a set of all integers from l to r inclusive, l<r, (r\u2212l+1)\u22643\u22c5105 and (r\u2212l) is always odd.\nYou want to split these numbers into exactly r\u2212l+12 pairs in such a way that for each pair (i,j) the greatest common divisor of i and j is equal to 1. Each number should appear in exactly one of the pairs.\nPrint the resulting pairs or output that no solution exists. If there are multiple solutions, print any of them.\nThe only line contains two integers l and r (1\u2264l<r\u22641018, r\u2212l+1\u22643\u22c5105, (r\u2212l) is odd).\nIf any solution exists, print \"YES\" in the first line. Each of the next r\u2212l+12 lines should contain some pair of integers. GCD of numbers in each pair should be equal to 1. All (r\u2212l+1) numbers should be pairwise distinct and should have values from l to r inclusive.\nIf there are multiple solutions, print any of them.\nIf there exists no solution, print \"NO\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solutions": "1051B - Relatively Prime PairsNumbers with the difference of 1 are always relatively prime. That's the only thing I should mention for this editorial.Overall complexity: O(r\u2212l). Solution (PikMike)#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n\nint main() {\n\tlong long l, r;\n\tscanf(\"%lld%lld\", &l, &r);\n\tputs(\"YES\");\n\tforn(i, (r - l) / 2 + 1)\n\t\tprintf(\"%lld %lld\\n\", l + i * 2, l + i * 2 + 1);\n}\n"
    },
    "1051A": {
        "title": "A. Vasya And Password",
        "description": "Vasya came up with a password to register for EatForces \u2014 a string s. The password in EatForces should be a string, consisting of lowercase and uppercase Latin letters and digits.\nBut since EatForces takes care of the security of its users, user passwords must contain at least one digit, at least one uppercase Latin letter and at least one lowercase Latin letter. For example, the passwords \"abaCABA12\", \"Z7q\" and \"3R24m\" are valid, and the passwords \"qwerty\", \"qwerty12345\" and \"Password\" are not. \nA substring of string s is a string x=slsl+1\u2026sl+len\u22121(1\u2264l\u2264|s|,0\u2264len\u2264|s|\u2212l+1). len is the length of the substring. Note that the empty string is also considered a substring of s, it has the length 0.\nVasya's password, however, may come too weak for the security settings of EatForces. He likes his password, so he wants to replace some its substring with another string of the same length in order to satisfy the above conditions. This operation should be performed exactly once, and the chosen string should have the minimal possible length.\nNote that the length of s should not change after the replacement of the substring, and the string itself should contain only lowercase and uppercase Latin letters and digits.\nThe first line contains a single integer T (1\u2264T\u2264100) \u2014 the number of testcases.\nEach of the next T lines contains the initial password s\u00a0(3\u2264|s|\u2264100), consisting of lowercase and uppercase Latin letters and digits.\nOnly T=1 is allowed for hacks.\nFor each testcase print a renewed password, which corresponds to given conditions. \nThe length of the replaced substring is calculated as following: write down all the changed positions. If there are none, then the length is 0. Otherwise the length is the difference between the first and the last changed position plus one. For example, the length of the changed substring between the passwords \"abcdef\" \u2192 \"a7cdEf\" is 4, because the changed positions are 2 and 5, thus (5\u22122)+1=4.\nIt is guaranteed that such a password always exists.\nIf there are several suitable passwords \u2014 output any of them.\nIn the first example Vasya's password lacks a digit, he replaces substring \"C\" with \"4\" and gets password \"abcD4E\". That means, he changed the substring of length 1.\nIn the second example Vasya's password is ok from the beginning, and nothing has to be changed. That is the same as replacing the empty substring with another empty substring (length 0).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "1051A - Vasya And PasswordThere are just a few general cases in the task to consider:   If the password s is already valid, nothing has to be changed, just print s.   Try to change exactly one character, iterate over all positions in s and all three options for character (any digit, any lowercase or uppercase Latin letter). After the replacement the string is checked for the validity and printed if it turned out to be valid.   We weren't able to replace a substring of length 0 or 1, then the answer is at least 2. We can obtain it in a following manner: replace the first two characters to \"a1\" if the third character is an uppercase Latin letter, to \"A1\" if the third character is a lowercase Latin letter and to \"aA\" if the third character is a digit.  Solution (Ajosteen)#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\n\nbool ok(string t){\n    int msk = 0;\n    \n    for(int i = 0; i < int(t.size()); ++i){\n\t    if(isupper(t[i])) msk |= 1;\n\t    if(islower(t[i])) msk |= 2;\n\t    if(isdigit(t[i])) msk |= 4;\n\t}\n\t\n\treturn msk == 7;\n}\n\nint main() {\n\t//freopen(\"input.txt\", \"r\", stdin);\n\tint t;\n\tcin >> t;\n\tfor(int i = 0; i < t; ++i){\n    \tcin >> s;\n    \tif(ok(s)){\n    \t    cout << s << endl;\n    \t    continue;\n    \t}\n    \tbool fnd = false;\n        for(int i = 0; i < int(s.size()); ++i){\n            string t = s;\n            \n            t[i] = '1';\n            if(ok(t)){\n    \t        cout << t << endl;\n    \t        fnd = true;\n    \t        break;\n    \t    }\n            t[i] = 'a';\n            if(ok(t)){\n    \t        cout << t << endl;\n    \t        fnd = true;\n    \t        break;\n    \t    }\n    \t    t[i] = 'A';\n            if(ok(t)){\n    \t        cout << t << endl;\n    \t        fnd = true;\n    \t        break;\n    \t    }\n        }\n    \t\n    \tif(fnd) continue;\n    \t\n    \tif(isupper(s[2])){\n    \t    s[0] = 'a';\n    \t    s[1] = '1';\n    \t    cout << s << endl;\n    \t    continue;\n    \t}\n    \tif(islower(s[2])){\n    \t    s[0] = 'A';\n    \t    s[1] = '1';\n    \t    cout << s << endl;\n    \t    continue;\n    \t}\n    \tif(isdigit(s[2])){\n    \t    s[0] = 'a';\n    \t    s[1] = 'A';\n    \t    cout << s << endl;\n    \t    continue;\n    \t}\n\t}\n\treturn  0;\n}\n\n"
    },
    "1043B": {
        "title": "B. Lost Array",
        "description": "Bajtek, known for his unusual gifts, recently got an integer array x0,x1,\u2026,xk\u22121.\nUnfortunately, after a huge array-party with his extraordinary friends, he realized that he'd lost it. After hours spent on searching for a new toy, Bajtek found on the arrays producer's website another array a of length n+1. As a formal description of a says, a0=0 and for all other i\u00a0(1\u2264i\u2264n) ai=x(i\u22121)modk+ai\u22121, where pmodq denotes the remainder of division p by q.\nFor example, if the x=[1,2,3] and n=5, then:\nSo, if the x=[1,2,3] and n=5, then a=[0,1,3,6,7,9].\nNow the boy hopes that he will be able to restore x from a! Knowing that 1\u2264k\u2264n, help him and find all possible values of k\u00a0\u2014 possible lengths of the lost array.\nThe first line contains exactly one integer n (1\u2264n\u22641000)\u00a0\u2014 the length of the array a, excluding the element a0.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106).\nNote that a0 is always 0 and is not given in the input.\nThe first line of the output should contain one integer l denoting the number of correct lengths of the lost array.\nThe second line of the output should contain l integers\u00a0\u2014 possible lengths of the lost array in increasing order.\nIn the first example, any k is suitable, since a is an arithmetic progression.\nPossible arrays x:\nIn the second example, Bajtek's array can have three or five elements.\nPossible arrays x:\nFor example, k=4 is bad, since it leads to 6+x0=8 and 0+x0=1, which is an obvious contradiction.\nIn the third example, only k=n is good.\nArray [1,4,\u22122] satisfies the requirements.\nNote that xi may be negative.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "1043B \u2014 Lost Array TutorialFirst, let's observe that we can replace array ai with array bi = ai \u2009-\u2009 ai\u2009-\u20091, because all we care about are differences between neighboring elements. Now, we can see that our lost array can have length d if and only if for every j such that j \u2009+\u2009 d \u2009\u2264\u2009 n, bj \u2009=\u2009 bj\u2009+\u2009d. So we can iterate over every possible d from 1 to n and check if it is correct in O(n). Complexity of whole algorithm is O(n2). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1007;\n\nint n;\nint in[N];\n\nbool ok(int d){\n\tfor(int i = 0; i + d < n; ++i)\n\t\tif(in[i + 1] - in[i] != in[i + d + 1] - in[i + d])\n\t\t\treturn false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", &in[i]);\n\t\n\tvector <int> res;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(ok(i))\n\t\t\tres.push_back(i);\n\t\n\tprintf(\"%d\\n\", res.size());\n\tfor(int v: res)\n\t\tprintf(\"%d \", v);\n\treturn 0;\n}Author: Anadi"
    },
    "1042B": {
        "title": "B. Vitamins",
        "description": "Berland shop sells n kinds of juices. Each juice has its price ci. Each juice includes some set of vitamins in it. There are three types of vitamins: vitamin \"A\", vitamin \"B\" and vitamin \"C\". Each juice can contain one, two or all three types of vitamins in it.\nPetya knows that he needs all three types of vitamins to stay healthy. What is the minimum total price of juices that Petya has to buy to obtain all three vitamins? Petya obtains some vitamin if he buys at least one juice containing it and drinks it.\nThe first line contains a single integer n (1\u2264n\u22641000) \u2014 the number of juices.\nEach of the next n lines contains an integer ci (1\u2264ci\u2264100000) and a string si \u2014 the price of the i-th juice and the vitamins it contains. String si contains from 1 to 3 characters, and the only possible characters are \"A\", \"B\" and \"C\". It is guaranteed that each letter appears no more than once in each string si. The order of letters in strings si is arbitrary.\nPrint -1 if there is no way to obtain all three vitamins. Otherwise print the minimum total price of juices that Petya has to buy to obtain all three vitamins.\nIn the first example Petya buys the first, the second and the fourth juice. He spends 5+6+4=15 and obtains all three vitamins. He can also buy just the third juice and obtain three vitamins, but its cost is 16, which isn't optimal.\nIn the second example Petya can't obtain all three vitamins, as no juice contains vitamin \"C\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "implementation",
            "*1200"
        ],
        "solutions": "1042B - VitaminsLet's calculate the minimum cost of the juice containing only the vitamin \"A\", only the vitamin \"B\" and only the vitamin \"C\". Also let's calculate the minimum cost of the juice containing all three vitamins.If there is at least one juice containing only the vitamin \"A\", at least one juice containing only the vitamin \"B\" and at least one juice containing only the vitamin \"C\", let's update the answer with the sum of the corresponding minimum costs.If there is at least one juice containing all three vitamins, let's update the answer with its cost.Only one case remains \u2014 when Petya has to buy two juices. Let's iterate over all pairs of juices using nested loops. Let the index of the first juice we iterate be a, the index of the second juice be b. We have to check that the strings sa and sb contain all three letters \"A\", \"B\", \"C\" (i.e. these juices contain all the vitamins). If they do, let's update the answer with the value ca+cb. Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint n;\nmap<string, int> was;\n\ninline void read() {\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c;\n\t\tstring s;\n\t\tcin >> c >> s;\n\t\tsort(s.begin(), s.end());\n\t\tif (was.count(s) == 0) {\n\t\t\twas[s] = c;\n\t\t} else {\n\t\t\twas[s] = min(was[s], c);\n\t\t}\n\t}\n}\n\ninline int getC(string a, string b) {\n \tif (!was.count(a) || !was.count(b)) {\n \t\treturn INF;\n \t}\n \treturn was[a] + was[b];\n}\n\ninline void solve() {\n\tint ans = INF;\n\tif (was.count(\"A\") && was.count(\"B\") && was.count(\"C\")) {\n\t\tans = was[\"A\"] + was[\"B\"] + was[\"C\"];\n\t}\n    if (was.count(\"ABC\")) {\n    \tans = min(ans, was[\"ABC\"]);\n    }\n    ans = min(ans, getC(\"AB\", \"C\"));\n    ans = min(ans, getC(\"A\", \"BC\"));\n    ans = min(ans, getC(\"AC\", \"B\"));\n    ans = min(ans, getC(\"AB\", \"BC\"));\n    ans = min(ans, getC(\"AC\", \"BC\"));\n    ans = min(ans, getC(\"AC\", \"AB\"));\n    if (ans == INF) {\n    \tans = -1;\n    }\n    cout << ans << endl;\n}\n\nint main () {\n    read();\n    solve();\n}"
    },
    "1042A": {
        "title": "A. Benches",
        "description": "There are n benches in the Berland Central park. It is known that ai people are currently sitting on the i-th bench. Another m people are coming to the park and each of them is going to have a seat on some bench out of n available.\nLet k be the maximum number of people sitting on one bench after additional m people came to the park. Calculate the minimum possible k and the maximum possible k.\nNobody leaves the taken seat during the whole process.\nThe first line contains a single integer n (1\u2264n\u2264100) \u2014 the number of benches in the park.\nThe second line contains a single integer m (1\u2264m\u226410000) \u2014 the number of people additionally coming to the park.\nEach of the next n lines contains a single integer ai (1\u2264ai\u2264100) \u2014 the initial number of people on the i-th bench.\nPrint the minimum possible k and the maximum possible k, where k is the maximum number of people sitting on one bench after additional m people came to the park.\nIn the first example, each of four benches is occupied by a single person. The minimum k is 3. For example, it is possible to achieve if two newcomers occupy the first bench, one occupies the second bench, one occupies the third bench, and two remaining \u2014 the fourth bench. The maximum k is 7. That requires all six new people to occupy the same bench.\nThe second example has its minimum k equal to 15 and maximum k equal to 15, as there is just a single bench in the park and all 10 people will occupy it.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "*1100"
        ],
        "solutions": "1042A - BenchesThe maximum value of k should be determined in the following way: let's find the maximum number of people already sitting on the same bench (i. e. the maximum value in the array a). Let this number be t. Then if all additional m people will seat on this bench, we will get the maximum value of k, so the answer is t+m.To determine the minimum value of k let's perform m operations. During each operation we put a new person on the bench currently having minimum number of people occupying it. The answer is the maximum number of people on the bench after we perform this operation for each of m newcomers. Solution#include <set>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 100 + 13;\n\nint n, m;\nint a[N];\n\nint main() {\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    int ans2 = *max_element(a, a + n) + m;\n    for (int it = 0; it < m; it++) {\n        int pos = -1;\n        for (int i = 0; i < n; i++) {\n            if (pos == -1 || a[i] < a[pos]) {\n                pos = i;\n            }\n        }\n        assert(pos != -1);\n        a[pos]++;\n    }\n    int ans1 = *max_element(a, a + n);\n    cout << ans1 << ' ' << ans2 << endl;\n}"
    },
    "1041B": {
        "title": "B. Buying a TV Set",
        "description": "Monocarp has decided to buy a new TV set and hang it on the wall in his flat. The wall has enough free space so Monocarp can buy a TV set with screen width not greater than a and screen height not greater than b. Monocarp is also used to TV sets with a certain aspect ratio: formally, if the width of the screen is w, and the height of the screen is h, then the following condition should be met: wh=xy.\nThere are many different TV sets in the shop. Monocarp is sure that for any pair of positive integers w and h there is a TV set with screen width w and height h in the shop.\nMonocarp isn't ready to choose the exact TV set he is going to buy. Firstly he wants to determine the optimal screen resolution. He has decided to try all possible variants of screen size. But he must count the number of pairs of positive integers w and h, beforehand, such that (w\u2264a), (h\u2264b) and (wh=xy).\nIn other words, Monocarp wants to determine the number of TV sets having aspect ratio xy, screen width not exceeding a, and screen height not exceeding b. Two TV sets are considered different if they have different screen width or different screen height.\nThe first line contains four integers a, b, x, y (1\u2264a,b,x,y\u22641018)\u00a0\u2014 the constraints on the screen width and height, and on the aspect ratio.\nPrint one integer\u00a0\u2014 the number of different variants to choose TV screen width and screen height so that they meet the aforementioned constraints.\nIn the first example, there are 3 possible variants: (5,3), (10,6), (15,9).\nIn the second example, there is no TV set meeting the constraints.\nIn the third example, there is only one variant: (3,2).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1041B - Buying a TV SetFirstly let's make x and y coprime. To do so, we calculate g=gcd(x,y) and then divide both numbers by g.Then the pair (w,h) is included in the answer if the following conditions are met: w\u2264a, h\u2264b, and there exists some positive integer k such that w=kx and h=ky. Furthermore, each such pair is uniquely determined by this integer k. So we can reduce our task to counting the number of positive integers k such that kx\u2264a and ky\u2264b, and that is just min(\u230aax\u230b,\u230aby\u230b). Solution #include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    \n    ll a, b, c, d;\n    cin >> a >> b >> c >> d;\n    ll gc = __gcd(c, d);\n    c /= gc;\n    d /= gc;\n    cout << min(a/c, b/d);\n}"
    },
    "1040A": {
        "title": "A. Palindrome Dance",
        "description": "A group of n dancers rehearses a performance for the closing ceremony. The dancers are arranged in a row, they've studied their dancing moves and can't change positions. For some of them, a white dancing suit is already bought, for some of them \u2014 a black one, and for the rest the suit will be bought in the future.\nOn the day when the suits were to be bought, the director was told that the participants of the olympiad will be happy if the colors of the suits on the scene will form a palindrome. A palindrome is a sequence that is the same when read from left to right and when read from right to left. The director liked the idea, and she wants to buy suits so that the color of the leftmost dancer's suit is the same as the color of the rightmost dancer's suit, the 2nd left is the same as 2nd right, and so on.\nThe director knows how many burls it costs to buy a white suit, and how many burls to buy a black suit. You need to find out whether it is possible to buy suits to form a palindrome, and if it's possible, what's the minimal cost of doing so. Remember that dancers can not change positions, and due to bureaucratic reasons it is not allowed to buy new suits for the dancers who already have suits, even if it reduces the overall spending.\nThe first line contains three integers n, a, and b (1\u2264n\u226420, 1\u2264a,b\u2264100)\u00a0\u2014 the number of dancers, the cost of a white suit, and the cost of a black suit.\nThe next line contains n numbers ci, i-th of which denotes the color of the suit of the i-th dancer. Number 0 denotes the white color, 1\u00a0\u2014 the black color, and 2 denotes that a suit for this dancer is still to be bought.\nIf it is not possible to form a palindrome without swapping dancers and buying new suits for those who have one, then output -1. Otherwise, output the minimal price to get the desired visual effect.\nIn the first sample, the cheapest way to obtain palindromic colors is to buy a black suit for the third from left dancer and a white suit for the rightmost dancer.\nIn the second sample, the leftmost dancer's suit already differs from the rightmost dancer's suit so there is no way to obtain the desired coloring.\nIn the third sample, all suits are already bought and their colors form a palindrome.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "1040A - Palindrome DanceConsider a pair of dancers located symmetrically with respect to the center of the stage. If they already have different suits, the answer is definitely \"impossible\". If they both have same suits, they are fine. If one of them doesn't have a suit, buy him a matching one. Finally, if both don't have suits, buy them two same suits of the cheaper color. Also, if n is odd and the central dancer doesn't have a suit, buy him a cheaper one. "
    },
    "1038B": {
        "title": "B. Non-Coprime Partition",
        "description": "Find out if it is possible to partition the first n positive integers into two non-empty disjoint sets S1 and S2 such that:\nHere sum(S) denotes the sum of all elements present in set S and gcd means thegreatest common divisor.\nEvery integer number from 1 to n should be present in exactly one of S1 or S2.\nThe only line of the input contains a single integer n (1\u2264n\u226445000)\nIf such partition doesn't exist, print \"No\" (quotes for clarity).\nOtherwise, print \"Yes\" (quotes for clarity), followed by two lines, describing S1 and S2 respectively.\nEach set description starts with the set size, followed by the elements of the set in any order. Each set must be non-empty.\nIf there are multiple possible partitions\u00a0\u2014 print any of them.\nIn the first example, there is no way to partition a single number into two non-empty sets, hence the answer is \"No\".\nIn the second example, the sums of the sets are 2 and 4 respectively. The gcd(2,4)=2>1, hence that is one of the possible answers.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solutions": "1038B - Non-Coprime PartitionThere are many ways to solve this question. The easiest way perhaps was to note that the sum of first n numbers is given by n\u2217(n+1)2, and one of n2 or n+12 has to be an integer, suppose k. Then we can partition the numbers into two sets, one containing k and the other containing the remaining integers, both of which will have k as a common factor. Special Case: There is no answer for n\u22642Overall Complexity: O(n)Author's Code: 42591830 "
    },
    "1036A": {
        "title": "A. Function Height",
        "description": "You are given a set of 2n+1 integer points on a Cartesian plane. Points are numbered from 0 to 2n inclusive. Let Pi be the i-th point. The x-coordinate of the point Pi equals i. The y-coordinate of the point Pi equals zero (initially). Thus, initially Pi=(i,0).\nThe given points are vertices of a plot of a piecewise function. The j-th piece of the function is the segment PjPj+1.\nIn one move you can increase the y-coordinate of any point with odd x-coordinate (i.e. such points are P1,P3,\u2026,P2n\u22121) by 1. Note that the corresponding segments also change.\nFor example, the following plot shows a function for n=3 (i.e. number of points is 2\u22c53+1=7) in which we increased the y-coordinate of the point P1 three times and y-coordinate of the point P5 one time:\nLet the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).\nLet the height of the plot be the maximum y-coordinate among all initial points in the plot (i.e. points P0,P1,\u2026,P2n). The height of the plot on the picture above is 3.\nYour problem is to say which minimum possible height can have the plot consisting of 2n+1 vertices and having an area equal to k. Note that it is unnecessary to minimize the number of moves.\nIt is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding 1018.\nThe first line of the input contains two integers n and k (1\u2264n,k\u22641018) \u2014 the number of vertices in a plot of a piecewise function and the area we need to obtain.\nPrint one integer \u2014 the minimum possible height of a plot consisting of 2n+1 vertices and with an area equals k. It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding 1018.\nOne of the possible answers to the first example:\nThe area of this plot is 3, the height of this plot is 1.\nThere is only one possible answer to the second example:\nThe area of this plot is 12, the height of this plot is 3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1036A - Function HeightIt is easy to see that the area of the plot is the sum of areas of all triangles in this plot. Each move increases area by one. We cannot obtain the answer less than \u2308kn\u2309 but we always can obtain such an answer. Solution (Vovuh)n, k = map(int, input().split())\nprint((k + n - 1) // n)"
    },
    "1033B": {
        "title": "B. Square Difference",
        "description": "Alice has a lovely piece of cloth. It has the shape of a square with a side of length a centimeters. Bob also wants such piece of cloth. He would prefer a square with a side of length b centimeters (where b<a). Alice wanted to make Bob happy, so she cut the needed square out of the corner of her piece and gave it to Bob. Now she is left with an ugly L shaped cloth (see pictures below).\nAlice would like to know whether the area of her cloth expressed in square centimeters is prime. Could you help her to determine it?\nThe first line contains a number t\u00a0(1\u2264t\u22645)\u00a0\u2014 the number of test cases.\nEach of the next t lines describes the i-th test case. It contains two integers a and b\u00a0(1\u2264b<a\u22641011)\u00a0\u2014 the side length of Alice's square and the side length of the square that Bob wants.\nPrint t lines, where the i-th line is the answer to the i-th test case. Print \"YES\" (without quotes) if the area of the remaining piece of cloth is prime, otherwise print \"NO\".\nYou can print each letter in an arbitrary case (upper or lower).\nThe figure below depicts the first test case. The blue part corresponds to the piece which belongs to Bob, and the red part is the piece that Alice keeps for herself. The area of the red part is 62\u221252=36\u221225=11, which is prime, so the answer is \"YES\".\nIn the second case, the area is 162\u2212132=87, which is divisible by 3.\nIn the third case, the area of the remaining piece is 616908503612\u2212247776226302=3191830435068605713421. This number is not prime because 3191830435068605713421=36913227731\u22c586468472991.\nIn the last case, the area is 342\u2212332=67.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "1033B - Square DifferenceThe task looks simple enough, but there is a problem. The number we want to check might be very large - it might not even fit into 64-bit integer. Checking primality for it certainly cannot be performed naively.However, the input is no ordinary number. It is of form A2\u2212B2, which can be expressed as (A\u2212B)(A+B). This is prime if and only if A\u2212B=1 and A+B is a prime. Since A+B is at most 2\u22171011, we can use trial division to check its primality.Complexity: O(TA+B\u2212\u2212\u2212\u2212\u2212\u221a). Alternatively, you could cheat and use big integers and test primality using Miller-Rabin algorithm. With Java's BigInteger.isProbablePrime it's not too much work. "
    },
    "1033A": {
        "title": "A. King Escape",
        "description": "Alice and Bob are playing chess on a huge chessboard with dimensions n\u00d7n. Alice has a single piece left\u00a0\u2014 a queen, located at (ax,ay), while Bob has only the king standing at (bx,by). Alice thinks that as her queen is dominating the chessboard, victory is hers. \nBut Bob has made a devious plan to seize the victory for himself\u00a0\u2014 he needs to march his king to (cx,cy) in order to claim the victory for himself. As Alice is distracted by her sense of superiority, she no longer moves any pieces around, and it is only Bob who makes any turns.\nBob will win if he can move his king from (bx,by) to (cx,cy) without ever getting in check. Remember that a king can move to any of the 8 adjacent squares. A king is in check if it is on the same rank (i.e. row), file (i.e. column), or diagonal as the enemy queen. \nFind whether Bob can win or not.\nThe first line contains a single integer n (3\u2264n\u22641000)\u00a0\u2014 the dimensions of the chessboard.\nThe second line contains two integers ax and ay (1\u2264ax,ay\u2264n)\u00a0\u2014 the coordinates of Alice's queen.\nThe third line contains two integers bx and by (1\u2264bx,by\u2264n)\u00a0\u2014 the coordinates of Bob's king.\nThe fourth line contains two integers cx and cy (1\u2264cx,cy\u2264n)\u00a0\u2014 the coordinates of the location that Bob wants to get to.\nIt is guaranteed that Bob's king is currently not in check and the target location is not in check either.\nFurthermore, the king is not located on the same square as the queen (i.e. ax\u2260bx or ay\u2260by), and the target does coincide neither with the queen's position (i.e. cx\u2260ax or cy\u2260ay) nor with the king's position (i.e. cx\u2260bx or cy\u2260by).\nPrint \"YES\" (without quotes) if Bob can get from (bx,by) to (cx,cy) without ever getting in check, otherwise print \"NO\".\nYou can print each letter in any case (upper or lower).\nIn the diagrams below, the squares controlled by the black queen are marked red, and the target square is marked blue.\nIn the first case, the king can move, for instance, via the squares (2,3) and (3,2). Note that the direct route through (2,2) goes through check.\nIn the second case, the queen watches the fourth rank, and the king has no means of crossing it.\nIn the third case, the queen watches the third file.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "graphs",
            "implementation",
            "*1000"
        ],
        "solutions": "1033A - King EscapeImagine a two-dimensional plane with origin positioned on the black queen. We notice that the queen partitions the board into up to four connected components, with each quadrant being one of them. The answer is thus \"YES\" if and only if the source king position and the target position are in the same quadrant. This condition can be checked in O(1) using few simple ifs.In case you prefer brute force over case analysis, it is also possible to construct the grid graph and find the connected components or use DFS to find the path. This runs in O(n2). "
    },
    "1032B": {
        "title": "B. Personalized Cup",
        "description": "At many competitions that have a word \u00abcup\u00bb in its official name the winner is presented with an actual cup. This time the organizers of one unusual programming competition have decided to please the winner even more and to add a nameplate to the cup with the handle of the winner.\nThe nameplate is to be rectangular and the text on it will be printed as a table of several rows and columns. Having some measurements done, the organizers have found out that the number a of rows cannot be greater than 5 while the number b of columns cannot exceed 20. Every cell of the table will contain either an asterisk (\u00ab*\u00bb) or a letter of user's handle.\nFurthermore, the organizers want the rows of the table to be uniform, which means that the number of asterisks used in different rows should differ by at most one (i.e. you can't have two asterisks in the first row and none in the second). The main goal, however, is to obtain the winner's handle precisely when reading the table from top to bottom and from left to right in every row (skipping asterisks).\nThe organizers want for the nameplate to have as few rows as possible and among all valid tables with the minimum number of rows they want to choose the one that has the minimum number of columns.\nThe winner is not yet determined so your task is to write a program that, given a certain handle, generates the necessary table.\nThe only line contains one string s (1\u2264|s|\u2264100), comprised of uppercase and lowercase Latin letters, \u00a0\u2014 the handle of the winner.\nIn the first line output the minimum number a of rows in the table and the minimum number b of columns in an optimal table with rows.\nThe following a lines should contain b characters each \u00a0\u2014 any valid table.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*1200"
        ],
        "solutions": "1032B - Personalized CupLet's iterate over all possible pairs (a,b) with 1\u2264a\u22645 and 1\u2264b\u226420 to find the optimal one satisfying the inequality a\u22c5b\u2265|s|. So now we need to place the characters of s in the same relative order through the table. Possibly, several cells will remain unused, but we will distribute them over the table and place at most one asterisk in every row.One can show that we will have at most one asterisk in each row, because otherwise we would have been able to reduce the value of b. Problem C of elimination/div2"
    },
    "1030B": {
        "title": "B. Vasya and Cornfield",
        "description": "Vasya owns a cornfield which can be defined with two integers n and d. The cornfield can be represented as rectangle with vertices having Cartesian coordinates (0,d),(d,0),(n,n\u2212d) and (n\u2212d,n).\nVasya also knows that there are m grasshoppers near the field (maybe even inside it). The i-th grasshopper is at the point (xi,yi). Vasya does not like when grasshoppers eat his corn, so for each grasshopper he wants to know whether its position is inside the cornfield (including the border) or outside.\nHelp Vasya! For each grasshopper determine if it is inside the field (including the border).\nThe first line contains two integers n and d (1\u2264d<n\u2264100).\nThe second line contains a single integer m (1\u2264m\u2264100) \u2014 the number of grasshoppers.\nThe i-th of the next m lines contains two integers xi and yi (0\u2264xi,yi\u2264n) \u2014 position of the i-th grasshopper.\nPrint m lines. The i-th line should contain \"YES\" if the position of the i-th grasshopper lies inside or on the border of the cornfield. Otherwise the i-th line should contain \"NO\".\nYou can print each letter in any case (upper or lower).\nThe cornfield from the first example is pictured above. Grasshoppers with indices 1 (coordinates (2,4)) and 4 (coordinates (4,5)) are inside the cornfield.\nThe cornfield from the second example is pictured below. Grasshoppers with indices 1 (coordinates (4,4)), 3 (coordinates (8,1)) and 4 (coordinates (6,1)) are inside the cornfield. ",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "*1100"
        ],
        "solutions": "1030B - Vasya and CornfieldFor each point (x,y) let's look at values of two diagonals: x+y and x\u2212y. Borders of the cornfield, in fact, give limits to this values in the next way: d\u2264x+y\u22642n\u2212d and \u2212d\u2264x\u2212y\u2264d \u2014 that's all we need to check. There is a picture below for the further explanation.   Solution#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n, d;\nint m;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n\tcin >> n >> d;\n\tcin >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t\n\t\tbool ok = true;\n\t\tif(!((x - y) <= d && (x - y) >= -d)) \n\t\t\tok = false;\n\t\tif(!((x + y) <= n + n - d && (x + y) >= d))\n\t\t\tok = false;\n\n\t\tif(ok) puts(\"YES\");\n\t\telse puts(\"NO\");\n\t}\n\treturn 0;\n}"
    },
    "1029B": {
        "title": "B. Creating the Contest",
        "description": "You are given a problemset consisting of n problems. The difficulty of the i-th problem is ai. It is guaranteed that all difficulties are distinct and are given in the increasing order.\nYou have to assemble the contest which consists of some problems of the given problemset. In other words, the contest you have to assemble should be a subset of problems (not necessary consecutive) of the given problemset. There is only one condition that should be satisfied: for each problem but the hardest one (the problem with the maximum difficulty) there should be a problem with the difficulty greater than the difficulty of this problem but not greater than twice the difficulty of this problem. In other words, let ai1,ai2,\u2026,aip be the difficulties of the selected problems in increasing order. Then for each j from 1 to p\u22121 aij+1\u2264aij\u22c52 should hold. It means that the contest consisting of only one problem is always valid.\nAmong all contests satisfying the condition above you have to assemble one with the maximum number of problems. Your task is to find this number of problems.\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of problems in the problemset.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 difficulties of the problems. It is guaranteed that difficulties of the problems are distinct and are given in the increasing order.\nPrint a single integer \u2014 maximum number of problems in the contest satisfying the condition in the problem statement.\nDescription of the first example: there are 10 valid contests consisting of 1 problem, 10 valid contests consisting of 2 problems ([1,2],[5,6],[5,7],[5,10],[6,7],[6,10],[7,10],[21,23],[21,24],[23,24]), 5 valid contests consisting of 3 problems ([5,6,7],[5,6,10],[5,7,10],[6,7,10],[21,23,24]) and a single valid contest consisting of 4 problems ([5,6,7,10]).\nIn the second example all the valid contests consist of 1 problem.\nIn the third example are two contests consisting of 3 problems: [4,7,12] and [100,150,199].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solutions": "1029B - Creating the ContestThe answer is always a segment of the initial array. The authors solution uses two pointers technique: let's iterate over all left bounds of the correct contests and try to search maximum by inclusion correct contest. Let's iterate over all i from 0 to n\u22121 and let the current left bound be i. Let j be the maximum right bound of the correct contest starting from the position i. Initially j=i. Now while j+1<n and aj+1\u2264aj\u22c52 let's increase j. Try to update the answer with the value j\u2212i+1. It is obvious that all positions from i+1 to j cannot be left bounds of the maximum by inclusion correct contests, so let's set i=j and go on. Because each element will be processed once, time complexity is O(n). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\t\t\n\tint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint j = i;\n\t\twhile (j + 1 < n && a[j + 1] <= a[j] * 2)\n\t\t\t++j;\n\t\tans = max(ans, j - i + 1);\n\t\ti = j;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n}"
    },
    "1028B": {
        "title": "B. Unnatural Conditions",
        "description": "Let s(x) be sum of digits in decimal representation of positive integer x. Given two integers n and m, find some positive integers a and b such that \nThe only line of input contain two integers n and m (1\u2264n,m\u22641129).\nPrint two lines, one for decimal representation of a and one for decimal representation of b. Both numbers must not contain leading zeros and must have length no more than 2230.\nIn the first sample, we have n=6 and m=5. One valid solution is a=6, b=7. Indeed, we have s(a)=6\u2265n and s(b)=7\u2265n, and also s(a+b)=s(13)=4\u2264m.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solutions": "1028B - Unnatural ConditionsFirst note, that if some output is correct for test with n=1129 and m=1, then it's correct for any valid test. After noticing this, we don't need to read input and output one answer for any test. One of many possible answers isa=99..9900..001 (200 nines, 199 zeroes, 1 one) b=99..99 (200 nines) a+b=10400s(a)=1801,s(b)=1800,s(a+b)=1Problem author: VadymKaProblem developers: riadwaw, malcolm, Kostroma, Errichto Code  int len = 400;\n  cout << string(len, '5') << \"\\n\";\n  cout << (string(len - 1, '4') + '5') << \"\\n\"; "
    },
    "1027B": {
        "title": "B. Numbers on the Chessboard",
        "description": "You are given a chessboard of size n\u00d7n. It is filled with numbers from 1 to n2 in the following way: the first \u2308n22\u2309 numbers from 1 to \u2308n22\u2309 are written in the cells with even sum of coordinates from left to right from top to bottom. The rest n2\u2212\u2308n22\u2309 numbers from \u2308n22\u2309+1 to n2 are written in the cells with odd sum of coordinates from left to right from top to bottom. The operation \u2308xy\u2309 means division x by y rounded up.\nFor example, the left board on the following picture is the chessboard which is given for n=4 and the right board is the chessboard which is given for n=5.\nYou are given q queries. The i-th query is described as a pair xi,yi. The answer to the i-th query is the number written in the cell xi,yi (xi is the row, yi is the column). Rows and columns are numbered from 1 to n.\nThe first line contains two integers n and q (1\u2264n\u2264109, 1\u2264q\u2264105) \u2014 the size of the board and the number of queries.\nThe next q lines contain two integers each. The i-th line contains two integers xi,yi (1\u2264xi,yi\u2264n) \u2014 description of the i-th query.\nFor each query from 1 to q print the answer to this query. The answer to the i-th query is the number written in the cell xi,yi (xi is the row, yi is the column). Rows and columns are numbered from 1 to n. Queries are numbered from 1 to q in order of the input.\nAnswers to the queries from examples are on the board in the picture from the problem statement.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "1027B - Numbers on the ChessboardLet's see the following fact: if we will decrease \u2308n22\u2309 from all numbers written in cells with an odd sum of coordinates and write out the numbers obtained on the board from left to right from top to bottom, the sequence will looks like 1,1,2,2,\u2026,\u2308n22\u2309,\u2308n22\u2309 for even n (for odd n there is only one number \u2308n22\u2309 at the end of the sequence, but, in general, it does not matter).Let's try to find out the answer for some query (x,y). Let cnt=(x\u22121)\u22c5n+y (1-indexed). There cnt is the position of our cell in order of the written sequence. The first approximation of the answer is \u2308cnt2\u2309. But now we are remember that we decreased \u2308n22\u2309 from all numbers written in cells with an odd sum of coordinates. So if x+y is even then the answer is \u2308cnt2\u2309, otherwise the answer is \u2308cnt2\u2309+\u2308n22\u2309. Note that you should be careful with integer overflow in C++, Java or similar languages. 64-bit datatype is quite enough.Time complexity: O(q). Solution (Vovuh)import sys\n\nlst = sys.stdin.readlines()\nn, q = map(int, lst[0].split())\n\nfor i in range(q):\n    x, y = map(int, lst[i + 1].split())\n    cnt = (x - 1) * n + y\n    ans = (cnt + 1) // 2\n    if ((x + y) % 2 == 1): ans += (n * n + 1) // 2\n    sys.stdout.write(str(ans) + '\\n')"
    },
    "1027A": {
        "title": "A. Palindromic Twist",
        "description": "You are given a string s consisting of n lowercase Latin letters. n is even.\nFor each position i (1\u2264i\u2264n) in string s you are required to change the letter on this position either to the previous letter in alphabetic order or to the next one (letters 'a' and 'z' have only one of these options). Letter in every position must be changed exactly once.\nFor example, letter 'p' should be changed either to 'o' or to 'q', letter 'a' should be changed to 'b' and letter 'z' should be changed to 'y'.\nThat way string \"codeforces\", for example, can be changed to \"dpedepqbft\" ('c' \u2192 'd', 'o' \u2192 'p', 'd' \u2192 'e', 'e' \u2192 'd', 'f' \u2192 'e', 'o' \u2192 'p', 'r' \u2192 'q', 'c' \u2192 'b', 'e' \u2192 'f', 's' \u2192 't').\nString s is called a palindrome if it reads the same from left to right and from right to left. For example, strings \"abba\" and \"zz\" are palindromes and strings \"abca\" and \"zy\" are not.\nYour goal is to check if it's possible to make string s a palindrome by applying the aforementioned changes to every position. Print \"YES\" if string s can be transformed to a palindrome and \"NO\" otherwise.\nEach testcase contains several strings, for each of them you are required to solve the problem separately.\nThe first line contains a single integer T (1\u2264T\u226450) \u2014 the number of strings in a testcase.\nThen 2T lines follow \u2014 lines (2i\u22121) and 2i of them describe the i-th string. The first line of the pair contains a single integer n (2\u2264n\u2264100, n is even) \u2014 the length of the corresponding string. The second line of the pair contains a string s, consisting of n lowercase Latin letters.\nPrint T lines. The i-th line should contain the answer to the i-th string of the input. Print \"YES\" if it's possible to make the i-th string a palindrome by applying the aforementioned changes to every position. Print \"NO\" otherwise.\nThe first string of the example can be changed to \"bcbbcb\", two leftmost letters and two rightmost letters got changed to the next letters, two middle letters got changed to the previous letters.\nThe second string can be changed to \"be\", \"bg\", \"de\", \"dg\", but none of these resulting strings are palindromes.\nThe third string can be changed to \"beeb\" which is a palindrome.\nThe fifth string can be changed to \"lk\", \"lm\", \"nk\", \"nm\", but none of these resulting strings are palindromes. Also note that no letter can remain the same, so you can't obtain strings \"ll\" or \"mm\".",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1000"
        ],
        "solutions": "1027A - Palindromic TwistIf some string can't be transformed to palindrom then it has some pair of positions (i,n\u2212i+1) with different letters on them (as no such pair affects any other pair). Thus you need to check each pair for i from 1 to n2 and verify that the distance between the corresponding letters is either 0 or 2.Overall complexity: O(T\u22c5n). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n    int T;\n    cin >> T;\n    \n    int n;\n    string s;\n    forn(_, T){\n        cin >> n >> s;\n        bool ok = true;\n        forn(i, n){\n            int k = abs(s[i] - s[n - i - 1]);\n            if (k > 2 || k % 2 == 1){\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok ? \"YES\" : \"NO\") << endl;\n    }\n    return 0;\n}"
    },
    "1023C": {
        "title": "C. Bracket Subsequence",
        "description": "A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\nSubsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\nYou are given a regular bracket sequence s and an integer number k. Your task is to find a regular bracket sequence of length exactly k such that it is also a subsequence of s.\nIt is guaranteed that such sequence always exists.\nThe first line contains two integers n and k (2\u2264k\u2264n\u22642\u22c5105, both n and k are even) \u2014 the length of s and the length of the sequence you are asked to find.\nThe second line is a string s \u2014 regular bracket sequence of length n.\nPrint a single string \u2014 a regular bracket sequence of length exactly k such that it is also a subsequence of s.\nIt is guaranteed that such sequence always exists.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "1023C - Bracket SubsequenceLet the array used of n boolean values describe if the corresponding bracket of string s is included in answer or not.The algorithm goes like this: iterate over the string from 1 to n, maintain the stack of positions of currenly unmatched opening brackets st. When opening bracket is met at position i, push i to st, and when closing bracket is met, set used[st.top()]=True, used[i]=True and pop the top of st. When k values are marked True in used then break, iterate from 1 to n and print the brackets at positions where used[i]=True.Obviously, this algorithm produces a subsequence of s of length k. Why will it be a regular bracket sequence? The requirements for it are:  no prefix contains more closing brackets than opening ones;  the total number of closing bracket equals the total number of opening brackets. The first requirement is met by construction, we couldn't pop more elements from the stack than it had. The second requirement is also met as we marked brackets in pairs.Overall complexity: O(n).Problem idea: MikeMirzayanov, prepared by: awoo. "
    },
    "1023B": {
        "title": "B. Pair of Toys",
        "description": "Tanechka is shopping in the toy shop. There are exactly n toys in the shop for sale, the cost of the i-th toy is i burles. She wants to choose two toys in such a way that their total cost is k burles. How many ways to do that does she have?\nEach toy appears in the shop exactly once. Pairs (a,b) and (b,a) are considered equal. Pairs (a,b), where a=b, are not allowed.\nThe first line of the input contains two integers n, k (1\u2264n,k\u22641014) \u2014 the number of toys and the expected total cost of the pair of toys.\nPrint the number of ways to choose the pair of toys satisfying the condition above. Print 0, if Tanechka can choose no pair of toys in such a way that their total cost is k burles.\nIn the first example Tanechka can choose the pair of toys (1,4) or the pair of toys (2,3).\nIn the second example Tanechka can choose only the pair of toys (7,8).\nIn the third example choosing any pair of toys will lead to the total cost less than 20. So the answer is 0.\nIn the fourth example she can choose the following pairs: (1,1000000000000), (2,999999999999), (3,999999999998), ..., (500000000000,500000000001). The number of such pairs is exactly 500000000000.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1023B - Pair of ToysThe problem is to calculate the number of ways to choose two distinct integers from 1 to n with sum equals k.If k\u2264n then the answer is \u230ak2\u230b because this is the number of ways to choose two distinct integers from 1 to k\u22121 with the sum equals k. Otherwise let mn=n\u2212k will be the minimum possible term in the correct pair of integers. Also let mx=n will be the maximum possible term in the correct pair of integers. Then the answer is max(0,\u230amx\u2212mn+12\u230b) because this is the number of ways to choose two distinct integers from mn to mx with the sum equals k.Problem idea: MikeMirzayanov, prepared by: MikeMirzayanov. "
    },
    "1023A": {
        "title": "A. Single Wildcard Pattern Matching",
        "description": "You are given two strings s and t. The string s consists of lowercase Latin letters and at most one wildcard character '*', the string t consists only of lowercase Latin letters. The length of the string s equals n, the length of the string t equals m.\nThe wildcard character '*' in the string s (if any) can be replaced with an arbitrary sequence (possibly empty) of lowercase Latin letters. No other character of s can be replaced with anything. If it is possible to replace a wildcard character '*' in s to obtain a string t, then the string t matches the pattern s.\nFor example, if s=\"aba*aba\" then the following strings match it \"abaaba\", \"abacaba\" and \"abazzzaba\", but the following strings do not match: \"ababa\", \"abcaaba\", \"codeforces\", \"aba1aba\", \"aba?aba\".\nIf the given string t matches the given string s, print \"YES\", otherwise print \"NO\".\nThe first line contains two integers n and m (1\u2264n,m\u22642\u22c5105) \u2014 the length of the string s and the length of the string t, respectively.\nThe second line contains string s of length n, which consists of lowercase Latin letters and at most one wildcard character '*'.\nThe third line contains string t of length m, which consists only of lowercase Latin letters.\nPrint \"YES\" (without quotes), if you can obtain the string t from the string s. Otherwise print \"NO\" (without quotes).\nIn the first example a wildcard character '*' can be replaced with a string \"force\". So the string s after this replacement is \"codeforces\" and the answer is \"YES\".\nIn the second example a wildcard character '*' can be replaced with an empty string. So the string s after this replacement is \"vkcup\" and the answer is \"YES\".\nThere is no wildcard character '*' in the third example and the strings \"v\" and \"k\" are different so the answer is \"NO\".\nIn the fourth example there is no such replacement of a wildcard character '*' that you can obtain the string t so the answer is \"NO\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1200"
        ],
        "solutions": "1023A - Single Wildcard Pattern MatchingIf there is no wildcard character in the string s, the answer is \"YES\" if and only if strings s and t are equal. In the other case let's do the following thing: while both strings are not empty and their last characters are equal, let's erase them. Then do the same for the first characters, i.e. while both strings are not empty and their first characters are equal, let's erase them. Now if s is empty or s=\"*\" the answer is \"YES\", otherwise the answer is \"NO\".Problem idea: MikeMirzayanov, awoo; prepared by: vovuh. "
    },
    "1020B": {
        "title": "B. Badge",
        "description": "In Summer Informatics School, if a student doesn't behave well, teachers make a hole in his badge. And today one of the teachers caught a group of n students doing yet another trick. \nLet's assume that all these students are numbered from 1 to n. The teacher came to student a and put a hole in his badge. The student, however, claimed that the main culprit is some other student pa.\nAfter that, the teacher came to student pa and made a hole in his badge as well. The student in reply said that the main culprit was student ppa.\nThis process went on for a while, but, since the number of students was finite, eventually the teacher came to the student, who already had a hole in his badge.\nAfter that, the teacher put a second hole in the student's badge and decided that he is done with this process, and went to the sauna.\nYou don't know the first student who was caught by the teacher. However, you know all the numbers pi. Your task is to find out for every student a, who would be the student with two holes in the badge if the first caught student was a.\nThe first line of the input contains the only integer n (1\u2264n\u22641000)\u00a0\u2014 the number of the naughty students.\nThe second line contains n integers p1, ..., pn (1\u2264pi\u2264n), where pi indicates the student who was reported to the teacher by student i.\nFor every student a from 1 to n print which student would receive two holes in the badge, if a was the first student caught by the teacher.\nThe picture corresponds to the first example test case.\nWhen a=1, the teacher comes to students 1, 2, 3, 2, in this order, and the student 2 is the one who receives a second hole in his badge.\nWhen a=2, the teacher comes to students 2, 3, 2, and the student 2 gets a second hole in his badge. When a=3, the teacher will visit students 3, 2, 3 with student 3 getting a second hole in his badge.\nFor the second example test case it's clear that no matter with whom the teacher starts, that student would be the one who gets the second hole in his badge.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "graphs",
            "*1000"
        ],
        "solutions": "1020B - BadgeIn this problem you are given a graph, with one outgoing edge from each vertex. You are asked which vertex is first to be visited twice, if you start in some vertex, and go by outgoing edge from current vertex until you visited some vertex twice.The problem can be solved by straightforward implementation. You choose a starting vertex (which student is first to get a hole in their badge), and keep the current vertex, and for all vertices how many times it was visited. After transition to the next vertex you just check if it has been already visited, and update visited mark for it.This solution works in O(n2), and is very easy in implementation. It can be optimized to O(n), but it was not necessary in this problem. It an easy and useful exercise left to reader. "
    },
    "1020A": {
        "title": "A. New Building for SIS",
        "description": "You are looking at the floor plan of the Summer Informatics School's new building. You were tasked with SIS logistics, so you really care about travel time between different locations: it is important to know how long it would take to get from the lecture room to the canteen, or from the gym to the server room.\nThe building consists of n towers, h floors each, where the towers are labeled from 1 to n, the floors are labeled from 1 to h. There is a passage between any two adjacent towers (two towers i and i\u2009+\u20091 for all i: 1\u2009\u2264\u2009i\u2009\u2264\u2009n\u2009-\u20091) on every floor x, where a\u2009\u2264\u2009x\u2009\u2264\u2009b. It takes exactly one minute to walk between any two adjacent floors of a tower, as well as between any two adjacent towers, provided that there is a passage on that floor. It is not permitted to leave the building.\nThe picture illustrates the first example. \nYou have given k pairs of locations (ta,\u2009fa), (tb,\u2009fb): floor fa of tower ta and floor fb of tower tb. For each pair you need to determine the minimum walking time between these locations.\nThe first line of the input contains following integers:\nNext k lines contain description of the queries. Each description consists of four integers ta, fa, tb, fb (1\u2009\u2264\u2009ta,\u2009tb\u2009\u2264\u2009n, 1\u2009\u2264\u2009fa,\u2009fb\u2009\u2264\u2009h). This corresponds to a query to find the minimum travel time between fa-th floor of the ta-th tower and fb-th floor of the tb-th tower.\nFor each query print a single integer: the minimum walking time between the locations in minutes.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "1020A - New Building for SISIn this problem you need to find a shortest path between some locations in a building. You need to look at some cases to solve this problem. First, if locations are in the same tower (ta\u2009=\u2009tb), you don't need to use a passages between two towers at all, and answer is fa\u2009-\u2009fb. In other case, you have to use some passage between towers. Obviously, you need to use only passage on one floor. The easiest way to do this is to write down interesting floors in array\u00a0\u2014 the floor where you start, the floor where you end your path, first and last floors with passages. After that you can choose interesting floor x where you will use a passage, check if there is a passage at this floor (a\u2009\u2264\u2009x\u2009\u2264\u2009b), and update answer with an expression like |ta\u2009-\u2009tb|\u2009+\u2009|fa\u2009-\u2009x|\u2009+\u2009|fb\u2009-\u2009x|.Another method is to choose a floor where you use a passage by case handling. If you start on the floor fa, and there is a passage, you can just use this passage. Otherwise, you choose between floors a and b, whichever is closer to the start. "
    },
    "1017B": {
        "title": "B. The Bits",
        "description": "Rudolf is on his way to the castle. Before getting into the castle, the security staff asked him a question:\nGiven two binary numbers a and b of length n. How many different ways of swapping two digits in a (only in a, not b) so that bitwise OR of these two numbers will be changed? In other words, let c be the bitwise OR of a and b, you need to find the number of ways of swapping two bits in a so that bitwise OR will not be equal to c.\nNote that binary numbers can contain leading zeros so that length of each number is exactly n.\nBitwise OR is a binary operation. A result is a binary number which contains a one in each digit if there is a one in at least one of the two numbers. For example, 010102 OR 100112 = 110112.\nWell, to your surprise, you are not Rudolf, and you don't need to help him\u2026 You are the security staff! Please find the number of ways of swapping two bits in a so that bitwise OR will be changed.\nThe first line contains one integer n (2\u2264n\u2264105)\u00a0\u2014 the number of bits in each number.\nThe second line contains a binary number a of length n.\nThe third line contains a binary number b of length n.\nPrint the number of ways to swap two bits in a so that bitwise OR will be changed.\nIn the first sample, you can swap bits that have indexes (1,4), (2,3), (3,4), and (3,5).\nIn the second example, you can swap bits that have indexes (1,2), (1,3), (2,4), (3,4), (3,5), and (3,6).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1015C": {
        "title": "C. Songs Compression",
        "description": "Ivan has n songs on his phone. The size of the i-th song is ai bytes. Ivan also has a flash drive which can hold at most m bytes in total. Initially, his flash drive is empty.\nIvan wants to copy all n songs to the flash drive. He can compress the songs. If he compresses the i-th song, the size of the i-th song reduces from ai to bi bytes (bi<ai).\nIvan can compress any subset of the songs (possibly empty) and copy all the songs to his flash drive if the sum of their sizes is at most m. He can compress any subset of the songs (not necessarily contiguous).\nIvan wants to find the minimum number of songs he needs to compress in such a way that all his songs fit on the drive (i.e. the sum of their sizes is less than or equal to m).\nIf it is impossible to copy all the songs (even if Ivan compresses all the songs), print \"-1\". Otherwise print the minimum number of songs Ivan needs to compress.\nThe first line of the input contains two integers n and m (1\u2264n\u2264105,1\u2264m\u2264109) \u2014 the number of the songs on Ivan's phone and the capacity of Ivan's flash drive.\nThe next n lines contain two integers each: the i-th line contains two integers ai and bi (1\u2264ai,bi\u2264109, ai>bi) \u2014 the initial size of the i-th song and the size of the i-th song after compression.\nIf it is impossible to compress a subset of the songs in such a way that all songs fit on the flash drive, print \"-1\". Otherwise print the minimum number of the songs to compress.\nIn the first example Ivan can compress the first and the third songs so after these moves the sum of sizes will be equal to 8+7+1+5=21\u226421. Also Ivan can compress the first and the second songs, then the sum of sizes will be equal 8+4+3+5=20\u226421. Note that compressing any single song is not sufficient to copy all the songs on the flash drive (for example, after compressing the second song the sum of sizes will be equal to 10+4+3+5=22>21).\nIn the second example even if Ivan compresses all the songs the sum of sizes will be equal 8+4+1+4=17>16.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "*1100"
        ],
        "solutions": "1015C - Songs CompressionIf we will no compress songs, the sum of the sizes will be equal \u2211i=1nai. Let it be sum. Now, if we will compress the j-th song, how do sum will change? It will decrease by aj\u2212bj. This suggests that the optimal way to compress the songs is the compress it in non-increasing order of aj\u2212bj. Let's create the array d of size n, where dj=aj\u2212bj. Let's sort it in non-increasing order, and then iterate over all j from 1 to n. If at the current step sum\u2264m, we print j\u22121 and terminate the program. Otherwise we set sum:=sum\u2212dj. After all we have to check again if sum\u2264m then print n otherwise print \"-1\".Time complexity is O(nlogn) because of sorting. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pair<int, int>> a(n);\n\tlong long sum = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i].first >> a[i].second;\n\t\tsum += a[i].first;\n\t}\n\t\n\tsort(a.begin(), a.end(), [&](pair<int, int> a, pair<int, int> b) { return a.first - a.second > b.first - b.second; });\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (sum <= m) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum -= a[i].first - a[i].second;\n\t}\n\t\n\tif (sum <= m)\n\t\tcout << n << endl;\n\telse\n\t\tcout << -1 << endl;\n\t\n\treturn 0;\n}"
    },
    "1015B": {
        "title": "B. Obtaining the String",
        "description": "You are given two strings s and t. Both strings have length n and consist of lowercase Latin letters. The characters in the strings are numbered from 1 to n.\nYou can successively perform the following move any number of times (possibly, zero):\nYou can't apply a move to the string t. The moves are applied to the string s one after another.\nYour task is to obtain the string t from the string s. Find any way to do it with at most 104 such moves.\nYou do not have to minimize the number of moves, just find any sequence of moves of length 104 or less to transform s into t.\nThe first line of the input contains one integer n (1\u2264n\u226450) \u2014 the length of strings s and t.\nThe second line of the input contains the string s consisting of n lowercase Latin letters.\nThe third line of the input contains the string t consisting of n lowercase Latin letters.\nIf it is impossible to obtain the string t using moves, print \"-1\".\nOtherwise in the first line print one integer k \u2014 the number of moves to transform s to t. Note that k must be an integer number between 0 and 104 inclusive.\nIn the second line print k integers cj (1\u2264cj<n), where cj means that on the j-th move you swap characters scj and scj+1.\nIf you do not need to apply any moves, print a single integer 0 in the first line and either leave the second line empty or do not print it at all.\nIn the first example the string s changes as follows: \"abcdef\" \u2192 \"abdcef\" \u2192 \"abdcfe\" \u2192 \"abdfce\" \u2192 \"abdfec\".\nIn the second example there is no way to transform the string s into the string t through any allowed moves.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "1015B - Obtaining the StringThis problem can be solved using the next greedy approach: let's iterate over all i from 1 to n. If si=ti, go further. Otherwise let's find any position j>i such that sj=ti and move the character from the position j to the position i. If there is no such position in s, the answer is \"-1\".Upper bound on time complexity (and the size of the answer) of this solution is O(n2). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tstring s, t;\n\tcin >> n >> s >> t;\n\t\n\tvector<int> ans;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (s[i] == t[i]) continue;\n\t\tint pos = -1;\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (s[j] == t[i]) {\n\t\t\t        pos = j;\n\t\t\t        break;\n\t\t\t}\n\t\t}\n\t\tif (pos == -1) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int j = pos - 1; j >= i; --j) {\n\t\t\tswap(s[j], s[j + 1]);\n\t\t\tans.push_back(j);\n\t\t}\n\t}\n\t\n\tassert(s == t);\n\t\n\tcout << ans.size() << endl;\n\tfor (auto it : ans) cout << it + 1 << \" \";\n\tcout << endl;\n\t\n\treturn 0;\n}"
    },
    "1013B": {
        "title": "B. And",
        "description": "There is an array with n elements a1,\u2009a2,\u2009...,\u2009an and the number x.\nIn one operation you can select some i (1\u2009\u2264\u2009i\u2009\u2264\u2009n) and replace element ai with ai\u2009&\u2009x, where & denotes the bitwise and operation.\nYou want the array to have at least two equal elements after applying some operations (possibly, none). In other words, there should be at least two distinct indices i\u2009\u2260\u2009j such that ai\u2009=\u2009aj. Determine whether it is possible to achieve and, if possible, the minimal number of operations to apply.\nThe first line contains integers n and x (2\u2009\u2264\u2009n\u2009\u2264\u2009100\u2009000, 1\u2009\u2264\u2009x\u2009\u2264\u2009100\u2009000), number of elements in the array and the number to and with.\nThe second line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009100\u2009000), the elements of the array.\nPrint a single integer denoting the minimal number of operations to do, or -1, if it is impossible.\nIn the first example one can apply the operation to the last element of the array. That replaces 7 with 3, so we achieve the goal in one move.\nIn the second example the array already has two equal elements.\nIn the third example applying the operation won't change the array at all, so it is impossible to make some pair of elements equal.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "1013B - AndClearly, if it is possible then there are no more than 2 operations needed.So we basically need to distinguish 4 outcomes\u00a0\u2014 \u2009-\u20091, 0, 1 and 2.The answer is zero if there are already equal elements in the array.To check if the answer is -1 we can apply the operation to each element of the array. If all elements are still distinct, then it couldn't be helped.To check if the answer is one we can bruteforce the element a to apply the operation to, and if this operation changes this element, we can check if there is an a\u2009&\u2009x element in the array.In all other cases answer is two.D1A author: isaf27, developer: isaf27 "
    },
    "1011B": {
        "title": "B. Planning The Expedition",
        "description": "Natasha is planning an expedition to Mars for n people. One of the important tasks is to provide food for each participant.\nThe warehouse has m daily food packages. Each package has some food type ai.\nEach participant must eat exactly one food package each day. Due to extreme loads, each participant must eat the same food type throughout the expedition. Different participants may eat different (or the same) types of food.\nFormally, for each participant j Natasha should select his food type bj and each day j-th participant will eat one food package of type bj. The values bj for different participants may be different.\nWhat is the maximum possible number of days the expedition can last, following the requirements above?\nThe first line contains two integers n and m (1\u2264n\u2264100, 1\u2264m\u2264100)\u00a0\u2014 the number of the expedition participants and the number of the daily food packages available.\nThe second line contains sequence of integers a1,a2,\u2026,am (1\u2264ai\u2264100), where ai is the type of i-th food package.\nPrint the single integer\u00a0\u2014 the number of days the expedition can last. If it is not possible to plan the expedition for even one day, print 0.\nIn the first example, Natasha can assign type 1 food to the first participant, the same type 1 to the second, type 5 to the third and type 2 to the fourth. In this case, the expedition can last for 2 days, since each participant can get two food packages of his food type (there will be used 4 packages of type 1, two packages of type 2 and two packages of type 5).\nIn the second example, there are 100 participants and only 1 food package. In this case, the expedition can't last even 1 day.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "1011B - Planning The ExpeditionLet ci be the number of food packages that equal to i. Calculate the array c.For any d we can calculate the maximum number of people k, who can participate in the expedition for d days. To do this, we'll go over all the elements of the array c. Let now be considered ci. If ci\u2265d, we can decrease ci by d and increase k by 1, that is, take d daily food packages for one person. If still ci\u2265d, repeat the algorithm, and so on. That is for i-th iteration number k increases by \u230acid\u230b. After all the iterations the number k will be the required number of people.It is clear that the answer does not exceed m (every day at least one food package is used).Let's iterate d from m to 1, each time checking whether the answer can be equal d. To do this, we calculate the maximum number of people k, who can participate in the expedition for d days. If k\u2265n, then the answer is d. If no answer was received on any iteration, then the answer is 0.Complexity: O(m2).Bonus. Try to improve the complexity to O(mlogm). Solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> c(N + 1);\n    for (int i = 0; i < m; i++) {\n        int a;\n        cin >> a;\n        c[a]++;\n    }\n    for (int d = N; d >= 1; d--) {\n        vector<int> cc(c);\n        int k = 0;\n        for (int i = 1; i <= N; i++)\n            while (cc[i] >= d) {\n                k++;\n                cc[i] -= d;\n            }\n        if (k >= n) {\n            cout << d << endl;\n            return 0;\n        }\n    }\n    cout << 0 << endl;\n}"
    },
    "1008B": {
        "title": "B. Turn the Rectangles",
        "description": "There are n rectangles in a row. You can either turn each rectangle by 90 degrees or leave it as it is. If you turn a rectangle, its width will be height, and its height will be width. Notice that you can turn any number of rectangles, you also can turn all or none of them. You can not change the order of the rectangles.\nFind out if there is a way to make the rectangles go in order of non-ascending height. In other words, after all the turns, a height of every rectangle has to be not greater than the height of the previous rectangle (if it is such). \nThe first line contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of rectangles.\nEach of the next n lines contains two integers wi and hi (1\u2264wi,hi\u2264109)\u00a0\u2014 the width and the height of the i-th rectangle.\nPrint \"YES\" (without quotes) if there is a way to make the rectangles go in order of non-ascending height, otherwise print \"NO\".\nYou can print each letter in any case (upper or lower).\nIn the first test, you can rotate the second and the third rectangles so that the heights will be [4, 4, 3].\nIn the second test, there is no way the second rectangle will be not higher than the first one.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "1008B - Turn the RectanglesYou need to iterate over the rectangles from left to right and turn each rectangle in such a way that its height is as big as possible but not greater than the height of the previous rectangle (if it's not the first one). If on some iteration there is no such way to place the rectangle, the answer is \"NO\". "
    },
    "1006C": {
        "title": "C. Three Parts of the Array",
        "description": "You are given an array d1,d2,\u2026,dn consisting of n integer numbers.\nYour task is to split this array into three parts (some of which may be empty) in such a way that each element of the array belongs to exactly one of the three parts, and each of the parts forms a consecutive contiguous subsegment (possibly, empty) of the original array. \nLet the sum of elements of the first part be sum1, the sum of elements of the second part be sum2 and the sum of elements of the third part be sum3. Among all possible ways to split the array you have to choose a way such that sum1=sum3 and sum1 is maximum possible.\nMore formally, if the first part of the array contains a elements, the second part of the array contains b elements and the third part contains c elements, then:\nsum1=\u22111\u2264i\u2264adi, sum2=\u2211a+1\u2264i\u2264a+bdi, sum3=\u2211a+b+1\u2264i\u2264a+b+cdi.\nThe sum of an empty array is 0.\nYour task is to find a way to split the array such that sum1=sum3 and sum1 is maximum possible.\nThe first line of the input contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in the array d.\nThe second line of the input contains n integers d1,d2,\u2026,dn (1\u2264di\u2264109) \u2014 the elements of the array d.\nPrint a single integer \u2014 the maximum possible value of sum1, considering that the condition sum1=sum3 must be met.\nObviously, at least one valid way to split the array exists (use a=c=0 and b=n).\nIn the first example there is only one possible splitting which maximizes sum1: [1,3,1],[\u00a0],[1,4].\nIn the second example the only way to have sum1=4 is: [1,3],[2,1],[4].\nIn the third example there is only one way to split the array: [\u00a0],[4,1,2],[\u00a0].",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "two pointers",
            "*1200"
        ],
        "solutions": "1006C - Three Parts of the ArraySince the given array consists of positive integers, for each value of a, there can be at most one value of c such that sum1=sum3. We can use binary search on the array of prefix sums of d to find the correct value of c, given that it exists. If it does exist and a+c\u2264n, this is a candidate solution so we store it. Alternatively, we can use the two pointers trick \u2013 when a increases, c cannot decrease. Be careful to use 64 bit integers to store sums.Overall complexity is O(nlogn) or O(n).  Solution (Vovuh, set)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\t\t\n\tset<long long> sum;\n\tlong long l = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tl += a[i];\n\t\tsum.insert(l);\n\t}\n\t\n\tlong long ans = 0;\n\tlong long r = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tsum.erase(l);\n\t\tl -= a[i];\n\t\tr += a[i];\n\t\tif (sum.count(r))\n\t\t\tans = max(ans, r);\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n} Solution (ivan100sic, two pointers)#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\nint n;\nint a[200005];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n;\n\tfor (int i=1; i<=n; i++)\n\t\tcin >> a[i];\n\n\tint i = 0, j = n+1;\n\tll zi = 0, zj = 0, solidx = 0;\n\twhile (i < j) {\n\t\tif (zi < zj)\n\t\t\tzi += a[++i];\n\t\telse if (zi > zj)\n\t\t\tzj += a[--j];\n\t\telse {\n\t\t\tsolidx = i;\n\t\t\tzi += a[++i];\n\t\t\tzj += a[--j];\n\t\t}\n\t}\n\t\n\tcout << accumulate(a+1, a+solidx+1, 0ll); // here\n}"
    },
    "1006B": {
        "title": "B. Polycarp's Practice",
        "description": "Polycarp is practicing his problem solving skill. He has a list of n problems with difficulties a1,a2,\u2026,an, respectively. His plan is to practice for exactly k days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all n problems in exactly k days.\nThus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can't skip problems or solve them multiple times. As a result, in k days he will solve all the n problems.\nThe profit of the j-th day of Polycarp's practice is the maximum among all the difficulties of problems Polycarp solves during the j-th day (i.e. if he solves problems with indices from l to r during a day, then the profit of the day is maxl\u2264i\u2264rai). The total profit of his practice is the sum of the profits over all k days of his practice.\nYou want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all n problems between k days satisfying the conditions above in such a way, that the total profit is maximum.\nFor example, if n=8,k=3 and a=[5,4,2,6,5,1,9,2], one of the possible distributions with maximum total profit is: [5,4,2],[6,5],[1,9,2]. Here the total profit equals 5+6+9=20.\nThe first line of the input contains two integers n and k (1\u2264k\u2264n\u22642000) \u2014 the number of problems and the number of days, respectively.\nThe second line of the input contains n integers a1,a2,\u2026,an (1\u2264ai\u22642000) \u2014 difficulties of problems in Polycarp's list, in the order they are placed in the list (i.e. in the order Polycarp will solve them).\nIn the first line of the output print the maximum possible total profit.\nIn the second line print exactly k positive integers t1,t2,\u2026,tk (t1+t2+\u22ef+tk must equal n), where tj means the number of problems Polycarp will solve during the j-th day in order to achieve the maximum possible total profit of his practice.\nIf there are many possible answers, you may print any of them.\nThe first example is described in the problem statement.\nIn the second example there is only one possible distribution.\nIn the third example the best answer is to distribute problems in the following way: [1,2000],[2000,2]. The total profit of this distribution is 2000+2000=4000.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solutions": "1006B - Polycarp's PracticeThe maximum possible total profit you can obtain is the sum of the k largest values of the given array. This is obvious because we can always separate these k maximums and then extend the segments corresponding to them to the left or to the right and cover the entire array. I suggest the following: extract k largest values of the given array and place a separator right after each of them (except the rightmost one).Overall complexity is O(nlogn). Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin); \n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvector<pair<int, int>> res(n);\n\tvector<int> a(n); \n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> res[i].first;\n\t\ta[i] = res[i].first;\n\t\tres[i].second = i + 1;\n\t}\n\t\n\tsort(res.begin(), res.end());\n\treverse(res.begin(), res.end());\n\tsort(res.begin(), res.begin() + k, [&](pair<int, int> a, pair<int, int> b) { return a.second < b.second; });\n\t\n\tint lst = 0, sum = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t    sum += *max_element(a.begin() + lst, a.begin() + res[i].second);\n\t\tlst = res[i].second;\t\n\t}\n\tsum += *max_element(a.begin() + lst, a.end());\n\tcout << sum << endl;\n\t\n\n\tlst = 0;\n\tfor (int i = 0; i < k - 1; ++i) {\n\t\tcout << res[i].second - lst << \" \";\n\t\tlst = res[i].second;\t\n\t}\n\tcout << n - lst << endl;\n\t\n\treturn 0;\n}"
    },
    "1002D1": {
        "title": "D1. Oracle for f(x) = b * x mod 2",
        "description": "Implement a quantum oracle on N qubits which implements the following function: , where  (a vector of N integers, each of which can be 0 or 1).\nFor an explanation on how this type of quantum oracles works, see Introduction to quantum oracles.\nYou have to implement an operation which takes the following inputs:\nThe operation doesn't have an output; its \"output\" is the state in which it leaves the qubits.\nYour code should have the following signature:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1001H": {
        "title": "H. Oracle for f(x) = parity of the number of 1s in x",
        "description": "Implement a quantum oracle on N qubits which implements the following function: , i.e., the value of the function is 1 if x has odd number of 1s, and 0 otherwise.\nYou have to implement an operation which takes the following inputs:\nThe operation doesn't have an output; the \"output\" of your solution is the state in which it left the qubits.\nYour code should have the following signature:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "1001A": {
        "title": "A. Generate plus state or minus state",
        "description": "You are given a qubit in state  and an integer sign. \nYour task is to convert the given qubit to state  if sign\u2009=\u20091 or  if sign\u2009=\u2009\u2009-\u20091.\nYou have to implement an operation which takes a qubit and an integer as an input and has no output. The \"output\" of your solution is the state in which it left the input qubit.\nYour code should have the following signature:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "1000A": {
        "title": "A. Codehorses T-shirts",
        "description": "Codehorses has just hosted the second Codehorses Cup. This year, the same as the previous one, organizers are giving T-shirts for the winners.\nThe valid sizes of T-shirts are either \"M\" or from 0 to 3 \"X\" followed by \"S\" or \"L\". For example, sizes \"M\", \"XXS\", \"L\", \"XXXL\" are valid and \"XM\", \"Z\", \"XXXXL\" are not.\nThere are n winners to the cup for both the previous year and the current year. Ksenia has a list with the T-shirt sizes printed for the last year cup and is yet to send the new list to the printing office. \nOrganizers want to distribute the prizes as soon as possible, so now Ksenia is required not to write the whole list from the scratch but just make some changes to the list of the previous year. In one second she can choose arbitrary position in any word and replace its character with some uppercase Latin letter. Ksenia can't remove or add letters in any of the words.\nWhat is the minimal number of seconds Ksenia is required to spend to change the last year list to the current one?\nThe lists are unordered. That means, two lists are considered equal if and only if the number of occurrences of any string is the same in both lists.\nThe first line contains one integer n (1\u2264n\u2264100) \u2014 the number of T-shirts.\nThe i-th of the next n lines contains ai \u2014 the size of the i-th T-shirt of the list for the previous year.\nThe i-th of the next n lines contains bi \u2014 the size of the i-th T-shirt of the list for the current year.\nIt is guaranteed that all the sizes in the input are valid. It is also guaranteed that Ksenia can produce list b from the list a.\nPrint the minimal number of seconds Ksenia is required to spend to change the last year list to the current one. If the lists are already equal, print 0.\nIn the first example Ksenia can replace \"M\" with \"S\" and \"S\" in one of the occurrences of \"XS\" with \"L\".\nIn the second example Ksenia should replace \"L\" in \"XXXL\" with \"S\".\nIn the third example lists are equal.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "1000A - Codehorses T-shirtsAt first, let's remove all coinciding entries of both lists. The most convinient way is to use map/hashmap but it's not the only option. Now divide entries into categories by their length. You can notice that it takes exactly one second to remove an entry in each category (to make it equal to an entry of the opposing list). Thus the answer is n\u2212(number\u00a0of\u00a0coinciding\u00a0entries).Overall complexity: O(nlogn) or O(n). Solution#include <bits/stdc++.h>\n\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n\nusing namespace std;\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\t\n\tvector<string> a(n), b(n);\n\tforn(i, n) cin >> a[i];\n\tforn(i, n) cin >> b[i];\n\t\n\tmap<string, int> cnta, cntb;\n\tforn(i, n) ++cnta[a[i]];\n\tforn(i, n) ++cntb[b[i]];\n\t\n\tint ans = n;\n\tfor (auto it : cnta) ans -= min(it.second, cntb[it.first]);\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
    },
    "999C": {
        "title": "C. Alphabetic Removals",
        "description": "You are given a string s consisting of n lowercase Latin letters. Polycarp wants to remove exactly k characters (k\u2264n) from the string s. Polycarp uses the following algorithm k times:\nThis algorithm removes a single letter from the string. Polycarp performs this algorithm exactly k times, thus removing exactly k characters.\nHelp Polycarp find the resulting string.\nThe first line of input contains two integers n and k (1\u2264k\u2264n\u22644\u22c5105) \u2014 the length of the string and the number of letters Polycarp will remove.\nThe second line contains the string s consisting of n lowercase Latin letters.\nPrint the string that will be obtained from s after Polycarp removes exactly k letters using the above algorithm k times.\nIf the resulting string is empty, print nothing. It is allowed to print nothing or an empty line (line break).",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "999C - Alphabetic RemovalsLet the lowercase Latin letters be indexed from 0 to 25.There are exists at least two different solutions:If k=n exit the program. Otherwise, count the number of occurrences of each letter i from 0 to 25. Let it be cnt. Now, find the (alphabetically) smallest letter that will be in the resulting string. It can be done as follows: iterate over all i from 0 to 25, and if cnti\u2264k then subtract it from k, otherwise, i will be the smallest letter that will be in the resulting string. But we (possibly) need to remove some number of its leftmost occurrences. It is obvious that letters smaller than i will not appear in the resulting string. Also, the k leftmost occurrences of letter i will be removed. Now, let's iterate over all letters in string s from left to right and construct the resulting string res. If the current character of s (let it be sj) is smaller than i, then do nothing. If sj is greater than i, then add it to res. Otherwise sj=i. If k>0, then decrease k by one, otherwise, add sj to res. The time complexity is O(n).Another solution is the following. Let's carry the vector of pairs (si,i) where si is the i-th character of s and i is its position. If we sort this vector with the standard compare function, it is easy to see that the first k elements of this vector will be removed from the input string. Then if we will sort the last n\u2212k elements of this vector by its positions in the input string in increasing order, we will obtain the answer. The time complexity is O(nlogn). Solution 1 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\t\n\tvector<int> cnt(26);\n\tfor (auto c : s) ++cnt[c - 'a'];\n\n\tint pos = 26;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tif (k >= cnt[i]) {\n\t\t\tk -= cnt[i];\n\t\t} else {\n\t\t\tpos = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tstring ans;\n\tint rem = k;\n\tfor (auto c : s) {\n\t\tint cur = c - 'a';\n\t\tif (cur > pos || (cur == pos && rem == 0)) {\n\t\t\tans += c;\n\t\t} else if (cur == pos) {\n\t\t\t--rem;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n} Solution 2 (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tstring s;\n\tcin >> s;\n\n\tvector<pair<char, int>> c(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tc[i] = make_pair(s[i], i);\n\tsort(c.begin(), c.end());\n\tsort(c.begin() + k, c.end(), [&] (const pair<char, int> &a, const pair<char, int> &b) {\n\t\treturn a.second < b.second;\n\t});\n\t\n\tfor (int i = k; i < n; ++i)\n\t\tcout << c[i].first;\n\tcout << endl;\n\t\n\treturn 0;\n}"
    },
    "998B": {
        "title": "B. Cutting",
        "description": "There are a lot of things which could be cut\u00a0\u2014 trees, paper, \"the rope\". In this problem you are going to cut a sequence of integers.\nThere is a sequence of integers, which contains the equal number of even and odd numbers. Given a limited budget, you need to make maximum possible number of cuts such that each resulting segment will have the same number of odd and even integers.\nCuts separate a sequence to continuous (contiguous) segments. You may think about each cut as a break between two adjacent elements in a sequence. So after cutting each element belongs to exactly one segment. Say, [4,1,2,3,4,5,4,4,5,5] \u2192 two cuts \u2192 [4,1|2,3,4,5|4,4,5,5]. On each segment the number of even elements should be equal to the number of odd elements.\nThe cost of the cut between x and y numbers is |x\u2212y| bitcoins. Find the maximum possible number of cuts that can be made while spending no more than B bitcoins.\nFirst line of the input contains an integer n (2\u2264n\u2264100) and an integer B (1\u2264B\u2264100)\u00a0\u2014 the number of elements in the sequence and the number of bitcoins you have.\nSecond line contains n integers: a1, a2, ..., an (1\u2264ai\u2264100)\u00a0\u2014 elements of the sequence, which contains the equal number of even and odd numbers\nPrint the maximum possible number of cuts which can be made while spending no more than B bitcoins.\nIn the first sample the optimal answer is to split sequence between 2 and 5. Price of this cut is equal to 3 bitcoins.\nIn the second sample it is not possible to make even one cut even with unlimited number of bitcoins.\nIn the third sample the sequence should be cut between 2 and 3, and between 4 and 5. The total price of the cuts is 1+1=2 bitcoins.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "998B - CuttingIt is possible to proof, that cut after i-th number can be done if and only if the prefix of length i contains equal number of odd and even numbers.This way each cut can be done or not done independently of all other cuts (except the budget issue).Why it is true?Let's proof that criterion is sufficient. If you make some set of cuts, where each cut is valid according to criterion above, than the result would be correct\u00a0\u2014 each part of result lies between to cuts, and if prefixes which correspond to cuts have same number of odds-evens, than the part between also will have these numbers equal.Let's show that the condition is required\u00a0\u2014 if there is some set of cuts, which produces correct parts, than each part has same number of odds-evens, and than all prefixes, which correspond to cuts also have the same number of odds-evens.This way each cut can be done independently, so you can identify all valid cuts, order them by cut-price, and take greedy from the beginning of the list while the budget allows.Author \u2014 300iq "
    },
    "998A": {
        "title": "A. Balloons",
        "description": "There are quite a lot of ways to have fun with inflatable balloons. For example, you can fill them with water and see what happens.\nGrigory and Andrew have the same opinion. So, once upon a time, they went to the shop and bought n packets with inflatable balloons, where i-th of them has exactly ai balloons inside.\nThey want to divide the balloons among themselves. In addition, there are several conditions to hold:\nHelp them to divide the balloons or determine that it's impossible under these conditions.\nThe first line of input contains a single integer n (1\u2264n\u226410)\u00a0\u2014 the number of packets with balloons.\nThe second line contains n integers: a1, a2, \u2026, an (1\u2264ai\u22641000)\u00a0\u2014 the number of balloons inside the corresponding packet.\nIf it's impossible to divide the balloons satisfying the conditions above, print \u22121.\nOtherwise, print an integer k\u00a0\u2014 the number of packets to give to Grigory followed by k distinct integers from 1 to n\u00a0\u2014 the indices of those. The order of packets doesn't matter.\nIf there are multiple ways to divide balloons, output any of them.\nIn the first test Grigory gets 3 balloons in total while Andrey gets 1.\nIn the second test there's only one way to divide the packets which leads to equal numbers of balloons.\nIn the third test one of the boys won't get a packet at all.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1000"
        ],
        "solutions": "998A - BalloonsIt is easy to show, that if at least one solution exists, than it is possible to use the answer, which contains only one, minimal, element.Suppose, that this set is not valid. Then one of the following holds:  Either n=1, and then there is no solution  Or n=2, and other element is equal to minimum, in this case it is ease to see that there are not solution too. Also, the limits were set in such way, that solution which bruteforces all 2n subsets and checks them also passes.Author \u2014 MikeMirzayanov "
    },
    "991A": {
        "title": "A. If at first you don't succeed...",
        "description": "Each student eagerly awaits the day he would pass the exams successfully. Thus, Vasya was ready to celebrate, but, alas, he didn't pass it. However, many of Vasya's fellow students from the same group were more successful and celebrated after the exam.\nSome of them celebrated in the BugDonalds restaurant, some of them\u00a0\u2014 in the BeaverKing restaurant, the most successful ones were fast enough to celebrate in both of restaurants. Students which didn't pass the exam didn't celebrate in any of those restaurants and elected to stay home to prepare for their reexamination. However, this quickly bored Vasya and he started checking celebration photos on the Kilogramm. He found out that, in total, BugDonalds was visited by A students, BeaverKing\u00a0\u2014 by B students and C students visited both restaurants. Vasya also knows that there are N students in his group.\nBased on this info, Vasya wants to determine either if his data contradicts itself or, if it doesn't, how many students in his group didn't pass the exam. Can you help him so he won't waste his valuable preparation time?\nThe first line contains four integers\u00a0\u2014 A, B, C and N (0\u2264A,B,C,N\u2264100).\nIf a distribution of N students exists in which A students visited BugDonalds, B \u2014 BeaverKing, C \u2014 both of the restaurants and at least one student is left home (it is known that Vasya didn't pass the exam and stayed at home), output one integer\u00a0\u2014 amount of students (including Vasya) who did not pass the exam. \nIf such a distribution does not exist and Vasya made a mistake while determining the numbers A, B, C or N (as in samples 2 and 3), output \u22121.\nThe first sample describes following situation: 5 only visited BugDonalds, 5 students only visited BeaverKing, 5 visited both of them and 5 students (including Vasya) didn't pass the exam.\nIn the second sample 2 students only visited BugDonalds and 2 only visited BeaverKing, but that means all 4 students in group passed the exam which contradicts the fact that Vasya didn't pass meaning that this situation is impossible.\nThe third sample describes a situation where 2 students visited BugDonalds but the group has only 1 which makes it clearly impossible.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "991A - If at first you don't succeed... EditorialThere are 4 groups of students \u2014 those who visited only the first restaurant, who visited only the second, who visited both places and who stayed at home. One of the easiest ways to detect all the incorrect situations is to calculate number of students in each group. For the first group it is A\u2009-\u2009C, for the second: B\u2009-\u2009C, for the third: C and for the fourth: N\u2009-\u2009A\u2009-\u2009B\u2009+\u2009C. Now we must just to check that there are non-negative numbers in the first three groups and the positive number for the last group. If such conditions are met the answer is the number of students in the fourth group. \tint n1 = a - c;\n\tint n2 = b - c;\n\tint n3 = c;\n\tint n4 = n - n1 - n2 - n3;\n\n\tif (n1 >= 0 && n2 >= 0 && n3 >= 0 && n4 > 0)\n\t\tcout << n4;\n\telse\n\t\tcout << -1;In general you are recommended to view inclusion\u2013exclusion principle.Moreover the limitations allow to go over all possible numbers of students for each group (except for the third) in O(N3) and to check whether such numbers produce a correct solution. If no correct numbers found, just print \u2009-\u20091: \tint n3 = c;\n\tfor (int n1 = 0; n1 <= n; n1++)\n\t\tfor (int n2 = 0; n2 <= n; n2++)\n\t\t\tfor (int n4 = 1; n4 <= n; n4++)\n\t\t\t\tif (n1 + n3 == a && n2 + n3 == b && n1 + n2 + n3 + n4 == n) {\n\t\t\t\t\tcout << n4;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tcout << -1;Solution1Solution2"
    },
    "990B": {
        "title": "B. Micro-World",
        "description": "You have a Petri dish with bacteria and you are preparing to dive into the harsh micro-world. But, unfortunately, you don't have any microscope nearby, so you can't watch them.\nYou know that you have n bacteria in the Petri dish and size of the i-th bacteria is ai. Also you know intergalactic positive integer constant K.\nThe i-th bacteria can swallow the j-th bacteria if and only if ai>aj and ai\u2264aj+K. The j-th bacteria disappear, but the i-th bacteria doesn't change its size. The bacteria can perform multiple swallows. On each swallow operation any bacteria i can swallow any bacteria j if ai>aj and ai\u2264aj+K. The swallow operations go one after another.\nFor example, the sequence of bacteria sizes a=[101,53,42,102,101,55,54] and K=1. The one of possible sequences of swallows is: [101,53,42,102,101\u2013\u2013\u2013\u2013,55,54] \u2192 [101,53\u2013\u2013\u2013,42,102,55,54] \u2192 [101\u2013\u2013\u2013\u2013,42,102,55,54] \u2192 [42,102,55,54\u2013\u2013\u2013] \u2192 [42,102,55]. In total there are 3 bacteria remained in the Petri dish.\nSince you don't have a microscope, you can only guess, what the minimal possible number of bacteria can remain in your Petri dish when you finally will find any microscope.\nThe first line contains two space separated positive integers n and K (1\u2264n\u22642\u22c5105, 1\u2264K\u2264106) \u2014 number of bacteria and intergalactic constant K.\nThe second line contains n space separated integers a1,a2,\u2026,an (1\u2264ai\u2264106) \u2014 sizes of bacteria you have.\nPrint the only integer \u2014 minimal possible number of bacteria can remain.\nThe first example is clarified in the problem statement.\nIn the second example an optimal possible sequence of swallows is: [20,15,10,15,20\u2013\u2013\u2013,25] \u2192 [20,15,10,15\u2013\u2013\u2013,25] \u2192 [20,15,10\u2013\u2013\u2013,25] \u2192 [20,15\u2013\u2013\u2013,25] \u2192 [20\u2013\u2013\u2013,25] \u2192 [25].\nIn the third example no bacteria can swallow any other bacteria.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "990B - Micro-WorldIt can be proved that the optimal answer equals to a number of bacteria which can't be eaten by any other bacteria. So for each bacteria i you need to check existence of any bacteria j satisfying condition ai<aj\u2264ai+K.There plenty of ways to check this condition. One of them is to sort array a and for each i find minimal aj>ai with upper_bound or with two-pointers technique. Or you can use the fact that ai\u2264106 and build solution around it.Result complexity is O(nlogn). Solution (adedalic)#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200 * 1000 + 555;\nint n, k, a[N];\n\ninline bool read() {\n\tif(!(cin >> n >> k))\n\t\treturn false;\n\tfor(int i = 0; i < n; i++)\n\t\tassert(scanf(\"%d\", &a[i]) == 1);\n\treturn true;\n}\n\ninline void solve() {\n\tsort(a, a + n);\n\ta[n++] = int(2e9);\n\t\n\tint ans = 0, u = 0;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\twhile(u < n && a[i] == a[u])\n\t\t\tu++;\n\t\tif(a[u] - a[i] > k)\n\t\t\tans++;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint tt = clock();\n#endif\n\n\tif(read()) {\n\t\tsolve();\n#ifdef _DEBUG\n\t\tcerr << \"TIME = \" << clock() - tt << endl;\n#endif\n\t}\n\treturn 0;\n}"
    },
    "990A": {
        "title": "A. Commentary Boxes",
        "description": "Berland Football Cup starts really soon! Commentators from all over the world come to the event.\nOrganizers have already built n commentary boxes. m regional delegations will come to the Cup. Every delegation should get the same number of the commentary boxes. If any box is left unoccupied then the delegations will be upset. So each box should be occupied by exactly one delegation.\nIf n is not divisible by m, it is impossible to distribute the boxes to the delegations at the moment.\nOrganizers can build a new commentary box paying a burles and demolish a commentary box paying b burles. They can both build and demolish boxes arbitrary number of times (each time paying a corresponding fee). It is allowed to demolish all the existing boxes.\nWhat is the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by m)?\nThe only line contains four integer numbers n, m, a and b (1\u2264n,m\u22641012, 1\u2264a,b\u2264100), where n is the initial number of the commentary boxes, m is the number of delegations to come, a is the fee to build a box and b is the fee to demolish a box.\nOutput the minimal amount of burles organizers should pay to satisfy all the delegations (i.e. to make the number of the boxes be divisible by m). It is allowed that the final number of the boxes is equal to 0.\nIn the first example organizers can build 5 boxes to make the total of 14 paying 3 burles for the each of them.\nIn the second example organizers can demolish 2 boxes to make the total of 0 paying 7 burles for the each of them.\nIn the third example organizers are already able to distribute all the boxes equally among the delegations, each one get 5 boxes.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solutions": "990A - Commentary BoxesNotice that you need to check just two numbers: the closest one less or equal to n and the closest one greater than n. Distances to them are (nmodm) and (m\u2212(nmodm)) respectively. Now you should multiply the first result by b, the second result by a and compare the products.Overall complexity: O(1). Solution (PikMike)#include <bits/stdc++.h>\n\n#define forn(i, n) for(int i = 0; i < int(n); i++)\n \nusing namespace std;\n\nint main() {\n\tlong long n, m;\n\tint a, b;\n\t\n\tcin >> n >> m >> a >> b;\n\tcout << min(n % m * b, (m - n % m) * a) << endl;\n\treturn 0;\n}"
    },
    "989B": {
        "title": "B. A Tide of Riverscape",
        "description": "\"Time,\" Mino thinks aloud.\n\"What?\"\n\"Time and tide wait for no man,\" explains Mino. \"My name, taken from the river, always reminds me of this.\"\n\"And what are you recording?\"\n\"You see it, tide. Everything has its own period, and I think I've figured out this one,\" says Mino with confidence.\nDoubtfully, Kanno peeks at Mino's records. \nThe records are expressed as a string s of characters '0', '1' and '.', where '0' denotes a low tide, '1' denotes a high tide, and '.' denotes an unknown one (either high or low).\nYou are to help Mino determine whether it's possible that after replacing each '.' independently with '0' or '1', a given integer p is not a period of the resulting string. In case the answer is yes, please also show such a replacement to Mino.\nIn this problem, a positive integer p is considered a period of string s, if for all 1\u2264i\u2264|s|\u2212p, the i-th and (i+p)-th characters of s are the same. Here |s| is the length of s.\nThe first line contains two space-separated integers n and p (1\u2264p\u2264n\u22642000)\u00a0\u2014 the length of the given string and the supposed period, respectively.\nThe second line contains a string s of n characters\u00a0\u2014 Mino's records. s only contains characters '0', '1' and '.', and contains at least one '.' character.\nOutput one line\u00a0\u2014 if it's possible that p is not a period of the resulting string, output any one of such strings; otherwise output \"No\" (without quotes, you can print letters in any case (upper or lower)).\nIn the first example, 7 is not a period of the resulting string because the 1-st and 8-th characters of it are different.\nIn the second example, 6 is not a period of the resulting string because the 4-th and 10-th characters of it are different.\nIn the third example, 9 is always a period because the only constraint that the first and last characters are the same is already satisfied.\nNote that there are multiple acceptable answers for the first two examples, you can print any of them.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "strings",
            "*1200"
        ],
        "solutions": "989B - A Tide of RiverscapeOur very first observation is that when p\u2264n2, the answer can never be \"No\".Under this case, find any dot si=\".\". At least one of si\u2212p and si+p exists because p\u2264n2 and 1\u2264i\u2264n. We want to make si different from this character. In case this character is \"0\" or \"1\", replace the dot the other way round. In case it's a dot, replace the two dots differently with \"0\" and \"1\". After that, fill the remaining dots arbitrarily, and we obtain a valid answer.If p>n2, we'd like to find a dot with a similiar property. That is, si=\".\", and si\u2212p or si+p exists. Go over all dots, try find one, and carry out the same operation as above. If no such dot exists, the answer is \"No\".Bonus. Prove the time complexity of the seemingly-brute-force solution below.Bonus. In case the answer is \"Yes\", find the lexicographically smallest string that fulfill the requirements.Bonus. Solve the bonus challenge with n\u2264105. (Estimated difficulty: Div. 2 C) Noam's C++ solution#include <bits/stdc++.h>\n#define endl '\\n'\n#define fast ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define finish(x) return cout << x << endl, 0\nusing namespace std;\n\nstring s, t;\nint n, p;\n\nbool isperiod() {\n\tfor (int i = p; i < n; i++)\n\t\tif (t[i] != t[i - p]) return false;\n\treturn true;\n}\n\nint main() {\n\tfast;\n\tcin >> n >> p >> s;\n\n\t// attempt 1\n\tt = s;\n\tfor (auto &i : t)\n\t\tif (i == '.') i = '0';\n\tif (!isperiod()) finish(t);\n\n\t// attempt 2\n\tint i = 0;\n\twhile (i < n && s[i] != '.') i++;\n\tif (i + p < n) {\n\t\tt[i] = '1';\n\t\tfinish(t);\n\t}\n\ti = n - 1;\n\twhile (i >= 0 && s[i] != '.') i--;\n\tif (i - p >= 0) {\n\t\tt[i] = '1';\n\t\tfinish(t);\n\t}\n\n\tfinish(\"No\");\n} Python solution for the original problem as well as for the last challengen, p = map(int, input().split())\ns = input()\n\nt = s.replace('.', '0')\n\nif all(t[i] == t[i + p] for i in range(n - p)):\n    rmost = -1\n    for r in range(p - 1, -1, -1):\n        x = s[r::p].rfind('.')\n        if x != -1 and s[r::p] != '.':\n            rmost = max(rmost, x * p + r)\n    if rmost == -1:\n        print('No')\n    else:\n        print(t[:rmost] + '1' + t[(rmost + 1):])\nelse:\n    print(t) C++ seemingly-brute-force solution#include <algorithm>\n#include <cstdio>\n\nstatic const int MAXN = 2005;\n\nstatic int n, p;\nstatic char s[MAXN];\n\nstatic int dots_ct = 0, dots[MAXN];\n\nint main()\n{\n    scanf(\"%d%d%s\", &n, &p, s);\n\n    for (int i = 0; i < n; ++i) if (s[i] == '.') {\n        dots[dots_ct++] = i;\n        s[i] = '0';\n    }\n\n    for (int i = 1; i <= (1 << std::min(dots_ct, 19)); ++i) {\n        bool is_period = true;\n        for (int j = 0; j < n - p; ++j)\n            if (s[j] != s[j + p]) { is_period = false; break; }\n        if (!is_period) {\n            puts(s);\n            return 0;\n        }\n        for (int j = 0; j <= __builtin_ctz(i); ++j)\n            s[dots[j]] ^= 1;\n    }\n\n    puts(\"No\");\n    return 0;\n} "
    },
    "988B": {
        "title": "B. Substrings Sort",
        "description": "You are given n strings. Each string consists of lowercase English letters. Rearrange (reorder) the given strings in such a way that for every string, all strings that are placed before it are its substrings.\nString a is a substring of string b if it is possible to choose several consecutive letters in b in such a way that they form a. For example, string \"for\" is contained as a substring in strings \"codeforces\", \"for\" and \"therefore\", but is not contained as a substring in strings \"four\", \"fofo\" and \"rof\".\nThe first line contains an integer n (1\u2264n\u2264100) \u2014 the number of strings.\nThe next n lines contain the given strings. The number of letters in each string is from 1 to 100, inclusive. Each string consists of lowercase English letters.\nSome strings might be equal.\nIf it is impossible to reorder n given strings in required order, print \"NO\" (without quotes).\nOtherwise print \"YES\" (without quotes) and n given strings in required order.\nIn the second example you cannot reorder the strings because the string \"abab\" is not a substring of the string \"abacaba\".",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "strings",
            "*1100"
        ],
        "solutions": "988B - Substrings SortFirstly, sort all the strings by their lengths (if there are several strings of the same length, their order does not matter because if the answer is \"YES\" then all the strings of the same length should be equal). Then for each i\u2208[1..n\u22121] check that si is a substring of si+1. If it doesn't hold for some i then the answer is \"NO\". Otherwise the answer is \"YES\" and the sorted array is the correct order of strings. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n;\n\tcin >> n;\n\tvector<string> s(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\t\t\n\tsort(s.begin(), s.end(), [&] (const string &s, const string &t) {\n\t\treturn s.size() < t.size();\n\t});\n\t\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (s[i + 1].find(s[i]) == string::npos) {\n\t\t\tcout << \"NO\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tcout << \"YES\\n\";\n\tfor (auto it : s)\n\t\tcout << it << endl;\n\t\n\treturn 0;\n}"
    },
    "987B": {
        "title": "B. High School: Become Human",
        "description": "Year 2118. Androids are in mass production for decades now, and they do all the work for humans. But androids have to go to school to be able to solve creative tasks. Just like humans before.\nIt turns out that high school struggles are not gone. If someone is not like others, he is bullied. Vasya-8800 is an economy-class android which is produced by a little-known company. His design is not perfect, his characteristics also could be better. So he is bullied by other androids.\nOne of the popular pranks on Vasya is to force him to compare xy with yx. Other androids can do it in milliseconds while Vasya's memory is too small to store such big numbers.\nPlease help Vasya! Write a fast program to compare xy with yx for Vasya, maybe then other androids will respect him.\nOn the only line of input there are two integers x and y (1\u2264x,y\u2264109).\nIf xy<yx, then print '<' (without quotes). If xy>yx, then print '>' (without quotes). If xy=yx, then print '=' (without quotes).\nIn the first example 58=5\u22c55\u22c55\u22c55\u22c55\u22c55\u22c55\u22c55=390625, and 85=8\u22c58\u22c58\u22c58\u22c58=32768. So you should print '>'.\nIn the second example 103=1000<310=59049.\nIn the third example 66=46656=66.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solutions": "987B - High School: Become HumanWe need to compare xy with yx. Let's take logarithms of both sides. Now we need to compare ylnx with xlny. If you will compare this numbers with appropriate epsilon, it will get AC, but let's analyze a bit more and get solution in integers. Let's divide both sides by xy, now we need to compare lnxx with lnyy. That's the values of some function f(x)=lnxx taken in two points. Let's take a closer look on this function. You can take derivative or just look at the plot at WolframAlpha.It's clear that this function have maximum at point e, and it is increasing on [1,e] and decreasing on [e,+\u221e). Considering only integer points, f(1)=0, f(3) is maximal, f(2)=f(4) (because 24=42=16), and values in points greater than 4 are decreasing but always positive. So, the order of x from larger f(x) to smaller f(x) is 3,2=4,5,6,\u2026,+\u221e,1.38799800 \u2014 logs38799811 \u2014 case analisys "
    },
    "985B": {
        "title": "B. Switches and Lamps",
        "description": "You are given n switches and m lamps. The i-th switch turns on some subset of the lamps. This information is given as the matrix a consisting of n rows and m columns where ai,\u2009j\u2009=\u20091 if the i-th switch turns on the j-th lamp and ai,\u2009j\u2009=\u20090 if the i-th switch is not connected to the j-th lamp.\nInitially all m lamps are turned off.\nSwitches change state only from \"off\" to \"on\". It means that if you press two or more switches connected to the same lamp then the lamp will be turned on after any of this switches is pressed and will remain its state even if any switch connected to this lamp is pressed afterwards.\nIt is guaranteed that if you push all n switches then all m lamps will be turned on.\nYour think that you have too many switches and you would like to ignore one of them. \nYour task is to say if there exists such a switch that if you will ignore (not use) it but press all the other n\u2009-\u20091 switches then all the m lamps will be turned on.\nThe first line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20092000) \u2014 the number of the switches and the number of the lamps.\nThe following n lines contain m characters each. The character ai,\u2009j is equal to '1' if the i-th switch turns on the j-th lamp and '0' otherwise.\nIt is guaranteed that if you press all n switches all m lamps will be turned on.\nPrint \"YES\" if there is a switch that if you will ignore it and press all the other n\u2009-\u20091 switches then all m lamps will be turned on. Print \"NO\" if there is no such switch.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "985B - Switches and LampsLet's maintain an array cnt of size m, where cnti will be equal to the number of switches that are connected to the i-th lamp. Then answer will be \"YES\" if and only if there exists some switch such that for each lamp i that is connected to this switch cnti\u2009>\u20091. Otherwise the answer will be \"NO\". Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tvector<int> cnt(m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tif (s[i][j] == '1') ++cnt[j];\n\t}\n\t\n\tfor (int i = 0; i < n; ++i) {\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (s[i][j] == '1' && cnt[j] == 1)\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok) {\n\t\t\tputs(\"YES\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tputs(\"NO\");\n\t\n\treturn 0;\n}"
    },
    "985A": {
        "title": "A. Chess Placing",
        "description": "You are given a chessboard of size 1\u2009\u00d7\u2009n. It is guaranteed that n is even. The chessboard is painted like this: \"BWBW...BW\".\nSome cells of the board are occupied by the chess pieces. Each cell contains no more than one chess piece. It is known that the total number of pieces equals to .\nIn one step you can move one of the pieces one cell to the left or to the right. You cannot move pieces beyond the borders of the board. You also cannot move pieces to the cells that are already occupied.\nYour task is to place all the pieces in the cells of the same color using the minimum number of moves (all the pieces must occupy only the black cells or only the white cells after all the moves are made).\nThe first line of the input contains one integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009100, n is even) \u2014 the size of the chessboard. \nThe second line of the input contains  integer numbers  (1\u2009\u2264\u2009pi\u2009\u2264\u2009n) \u2014 initial positions of the pieces. It is guaranteed that all the positions are distinct.\nPrint one integer \u2014 the minimum number of moves you have to make to place all the pieces in the cells of the same color.\nIn the first example the only possible strategy is to move the piece at the position 6 to the position 5 and move the piece at the position 2 to the position 3. Notice that if you decide to place the pieces in the white cells the minimum number of moves will be 3.\nIn the second example the possible strategy is to move  in 4 moves, then  in 3 moves,  in 2 moves and  in 1 move.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "985A - Chess PlacingFirstly let's sort our array p (pay the attention that there are  elements in this array, not n). Then for 0-indexed array p answer will be equal to , where |a\u2009-\u2009b| is an absolute value of difference between a and b. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> pos(n / 2);\n\tfor (int i = 0; i < n / 2; ++i)\n\t\tcin >> pos[i];\n\tsort(pos.begin(), pos.end());\n\t\n\tint ans1 = 0, ans2 = 0;\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tans1 += abs(pos[i] - (i * 2 + 1));\n\t\tans2 += abs(pos[i] - (i * 2 + 2));\n\t}\n\t\n\tcout << min(ans1, ans2) << endl;\n\t\n\treturn 0;\n}"
    },
    "984B": {
        "title": "B. Minesweeper",
        "description": "One day Alex decided to remember childhood when computers were not too powerful and lots of people played only default games. Alex enjoyed playing Minesweeper that time. He imagined that he saved world from bombs planted by terrorists, but he rarely won.\nAlex has grown up since then, so he easily wins the most difficult levels. This quickly bored him, and he thought: what if the computer gave him invalid fields in the childhood and Alex could not win because of it?\nHe needs your help to check it.\nA Minesweeper field is a rectangle n\u00d7m, where each cell is either empty, or contains a digit from 1 to 8, or a bomb. The field is valid if for each cell: \nTwo cells are neighbors if they have a common side or a corner (i.\u00a0e. a cell has at most 8 neighboring cells).\nThe first line contains two integers n and m (1\u2264n,m\u2264100) \u2014 the sizes of the field.\nThe next n lines contain the description of the field. Each line contains m characters, each of them is \".\" (if this cell is empty), \"*\" (if there is bomb in this cell), or a digit from 1 to 8, inclusive.\nPrint \"YES\", if the field is valid and \"NO\" otherwise.\nYou can choose the case (lower or upper) for each letter arbitrarily.\nIn the second example the answer is \"NO\" because, if the positions of the bombs are preserved, the first line of the field should be *2*1.\nYou can read more about Minesweeper in Wikipedia's article.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "984B - MinesweeperLet's make two-dimensional array d[n][m]. For each cell i,j if it has bomb in it we add 1 in d[g][h] where g,h is neighboring cell for i,j. Now d[i][j] is a number of bombs in neighboring cells of i,j and we can check validity of field according to the condition of the problem:   If there is a number k in the cell, then exacly k of neighboring cells have bombs.  Otherwise, if cell has no bomb, then neighboring cells have no bombs. Solution"
    },
    "982A": {
        "title": "A. Row",
        "description": "You're given a row with n chairs. We call a seating of people \"maximal\" if the two following conditions hold:\nThe seating is given as a string consisting of zeros and ones (0 means that the corresponding seat is empty, 1 \u2014 occupied). The goal is to determine whether this seating is \"maximal\".\nNote that the first and last seats are not adjacent (if n\u22602).\nThe first line contains a single integer n (1\u2264n\u22641000)\u00a0\u2014 the number of chairs.\nThe next line contains a string of n characters, each of them is either zero or one, describing the seating.\nOutput \"Yes\" (without quotation marks) if the seating is \"maximal\". Otherwise print \"No\".\nYou are allowed to print letters in whatever case you'd like (uppercase or lowercase).\nIn sample case one the given seating is maximal.\nIn sample case two the person at chair three has a neighbour to the right.\nIn sample case three it is possible to seat yet another person into chair three.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "*1200"
        ],
        "solutions": "982A - RowSeating is the maximum when it does not exist two ones or three zeros together. It is also necessary to carefully process the ends of the series \u2014 it is necessary to check that you can not put a person on the most right or the most left chairs."
    },
    "981B": {
        "title": "B. Businessmen Problems",
        "description": "Two famous competing companies ChemForces and TopChemist decided to show their sets of recently discovered chemical elements on an exhibition. However they know that no element should be present in the sets of both companies.\nIn order to avoid this representatives of both companies decided to make an agreement on the sets the companies should present. The sets should be chosen in the way that maximizes the total income of the companies.\nAll elements are enumerated with integers. The ChemForces company has discovered n distinct chemical elements with indices a1,a2,\u2026,an, and will get an income of xi Berland rubles if the i-th element from this list is in the set of this company.\nThe TopChemist company discovered m distinct chemical elements with indices b1,b2,\u2026,bm, and it will get an income of yj Berland rubles for including the j-th element from this list to its set.\nIn other words, the first company can present any subset of elements from {a1,a2,\u2026,an} (possibly empty subset), the second company can present any subset of elements from {b1,b2,\u2026,bm} (possibly empty subset). There shouldn't be equal elements in the subsets.\nHelp the representatives select the sets in such a way that no element is presented in both sets and the total income is the maximum possible.\nThe first line contains a single integer n (1\u2264n\u2264105) \u00a0\u2014 the number of elements discovered by ChemForces.\nThe i-th of the next n lines contains two integers ai and xi (1\u2264ai\u2264109, 1\u2264xi\u2264109) \u00a0\u2014 the index of the i-th element and the income of its usage on the exhibition. It is guaranteed that all ai are distinct.\nThe next line contains a single integer m (1\u2264m\u2264105) \u00a0\u2014 the number of chemicals invented by TopChemist.\nThe j-th of the next m lines contains two integers bj and yj, (1\u2264bj\u2264109, 1\u2264yj\u2264109) \u00a0\u2014 the index of the j-th element and the income of its usage on the exhibition. It is guaranteed that all bj are distinct.\nPrint the maximum total income you can obtain by choosing the sets for both companies in such a way that no element is presented in both sets.\nIn the first example ChemForces can choose the set (3,7), while TopChemist can choose (1,2,4). This way the total income is (10+2)+(4+4+4)=24.\nIn the second example ChemForces can choose the only element 109, while TopChemist can choose (14,92,35). This way the total income is (239)+(15+65+89)=408.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "*1000"
        ],
        "solutions": "981B - Businessmen ProblemsWith map data structure for each chemical element that presents in input find maximal cost that you can get, and then just sum up these costs "
    },
    "979A": {
        "title": "A. Pizza, Pizza, Pizza!!!",
        "description": "Katie, Kuro and Shiro are best friends. They have known each other since kindergarten. That's why they often share everything with each other and work together on some very hard problems.\nToday is Shiro's birthday. She really loves pizza so she wants to invite her friends to the pizza restaurant near her house to celebrate her birthday, including her best friends Katie and Kuro.\nShe has ordered a very big round pizza, in order to serve her many friends. Exactly n of Shiro's friends are here. That's why she has to divide the pizza into n+1 slices (Shiro also needs to eat). She wants the slices to be exactly the same size and shape. If not, some of her friends will get mad and go home early, and the party will be over.\nShiro is now hungry. She wants to cut the pizza with minimum of straight cuts. A cut is a straight segment, it might have ends inside or outside the pizza. But she is too lazy to pick up the calculator.\nAs usual, she will ask Katie and Kuro for help. But they haven't come yet. Could you help Shiro with this problem?\nA single line contains one non-negative integer n (0\u2264n\u22641018)\u00a0\u2014 the number of Shiro's friends. The circular pizza has to be sliced into n+1 pieces.\nA single integer\u00a0\u2014 the number of straight cuts Shiro needs.\nTo cut the round pizza into quarters one has to make two cuts through the center with angle 90\u2218 between them.\nTo cut the round pizza into five equal parts one has to make five cuts.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test128 megabytes",
        "tags": [
            "math",
            "*1000"
        ],
        "solutions": "979A - Pizza, Pizza, Pizza!!! SolutionIf n\u2009=\u20090, the answer is obviously 0.If n\u2009+\u20091 is even, we can make  diametric cuts. Otherwise, the only way is to make n\u2009+\u20091 cuts.Time complexity: O(1). Code#include <stdio.h>\nusing namespace std;\n\nlong long n;\n\nint main()\n{\n    scanf(\"%I64d\", &n);\n    n++;\n    if (n == 1) printf(\"0\"); else if (n % 2 == 0) printf(\"%I64d\", n / 2); else printf(\"%I64d\", n);\n    return 0;\n}\n"
    },
    "978C": {
        "title": "C. Letters",
        "description": "There are n dormitories in Berland State University, they are numbered with integers from 1 to n. Each dormitory consists of rooms, there are ai rooms in i-th dormitory. The rooms in i-th dormitory are numbered from 1 to ai.\nA postman delivers letters. Sometimes there is no specific dormitory and room number in it on an envelope. Instead of it only a room number among all rooms of all n dormitories is written on an envelope. In this case, assume that all the rooms are numbered from 1 to a1+a2+\u22ef+an and the rooms of the first dormitory go first, the rooms of the second dormitory go after them and so on.\nFor example, in case n=2, a1=3 and a2=5 an envelope can have any integer from 1 to 8 written on it. If the number 7 is written on an envelope, it means that the letter should be delivered to the room number 4 of the second dormitory.\nFor each of m letters by the room number among all n dormitories, determine the particular dormitory and the room number in a dormitory where this letter should be delivered.\nThe first line contains two integers n and m (1\u2264n,m\u22642\u22c5105) \u2014 the number of dormitories and the number of letters.\nThe second line contains a sequence a1,a2,\u2026,an (1\u2264ai\u22641010), where ai equals to the number of rooms in the i-th dormitory. The third line contains a sequence b1,b2,\u2026,bm (1\u2264bj\u2264a1+a2+\u22ef+an), where bj equals to the room number (among all rooms of all dormitories) for the j-th letter. All bj are given in increasing order.\nPrint m lines. For each letter print two integers f and k \u2014 the dormitory number f (1\u2264f\u2264n) and the room number k in this dormitory (1\u2264k\u2264af) to deliver the letter.\nIn the first example letters should be delivered in the following order:",
        "time limit": "time limit per test4 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "977C": {
        "title": "C. Less or Equal",
        "description": "You are given a sequence of integers of length n and integer number k. You should print any integer number x in the range of [1;109] (i.e. 1\u2264x\u2264109) such that exactly k elements of given sequence are less than or equal to x.\nNote that the sequence can contain equal elements.\nIf there is no such x, print \"-1\" (without quotes).\nThe first line of the input contains integer numbers n and k (1\u2264n\u22642\u22c5105, 0\u2264k\u2264n). The second line of the input contains n integer numbers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 the sequence itself.\nPrint any integer number x from range [1;109] such that exactly k elements of given sequence is less or equal to x.\nIf there is no such x, print \"-1\" (without quotes).\nIn the first example 5 is also a valid answer because the elements with indices [1,3,4,6] is less than or equal to 5 and obviously less than or equal to 6.\nIn the second example you cannot choose any number that only 2 elements of the given sequence will be less than or equal to this number because 3 elements of the given sequence will be also less than or equal to this number.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "sortings",
            "*1200"
        ],
        "solutions": "977C - Less or EqualIn this problem you can do the following thing: firstly, let's sort our array.Let ans will be the answer. Then you have two cases: if k=0 then ans:=a0\u22121 otherwise ans:=ak\u22121 (for 0-indexed array).Then you need to calculate the number of the elements of the array a that are less than or equal to ans. Let it be cnt. Then if ans<1 or cnt\u2260k then print \"-1\" otherwise print ans. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\t\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\t\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\t\n\tsort(a.begin(), a.end());\n\t\n\tint ans;\n\t\n\tif (k == 0) {\n\t\tans = a[0] - 1;\n\t} else {\n\t\tans = a[k - 1];\n\t}\n\t\n\tint cnt = 0;\n\t\n\tfor (int i = 0; i < n; ++i)\n\t\tif (a[i] <= ans) ++cnt;\n\t\n\tif (cnt != k || !(1 <= ans && ans <= 1000 * 1000 * 1000)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}"
    },
    "975B": {
        "title": "B. Mancala",
        "description": "Mancala is a game famous in the Middle East. It is played on a board that consists of 14 holes. \nInitially, each hole has ai stones. When a player makes a move, he chooses a hole which contains a positive number of stones. He takes all the stones inside it and then redistributes these stones one by one in the next holes in a counter-clockwise direction.\nNote that the counter-clockwise order means if the player takes the stones from hole i, he will put one stone in the (i+1)-th hole, then in the (i+2)-th, etc. If he puts a stone in the 14-th hole, the next one will be put in the first hole.\nAfter the move, the player collects all the stones from holes that contain even number of stones. The number of stones collected by player is the score, according to Resli.\nResli is a famous Mancala player. He wants to know the maximum score he can obtain after one move.\nThe only line contains 14 integers a1,a2,\u2026,a14 (0\u2264ai\u2264109)\u00a0\u2014 the number of stones in each hole.\nIt is guaranteed that for any i (1\u2264i\u226414) ai is either zero or odd, and there is at least one stone in the board.\nOutput one integer, the maximum possible score after one move.\nIn the first test case the board after the move from the hole with 7 stones will look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1. Then the player collects the even numbers and ends up with a score equal to 4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solutions": "975B - Mancalain this problem, we brute-force on the optimal hole to choose since there are only 14 holes, but how to calculate how many stones there will be after we start from the ith hole? the process of putting stones is repeating every 14 holes, suppose k is the number of stones in hand now so k/14 will be added to all holes and we simulate adding k mod 14 then we take the maximum answer from all the holes.Solution "
    },
    "967B": {
        "title": "B. Watering System",
        "description": "Arkady wants to water his only flower. Unfortunately, he has a very poor watering system that was designed for n flowers and so it looks like a pipe with n holes. Arkady can only use the water that flows from the first hole.\nArkady can block some of the holes, and then pour A liters of water into the pipe. After that, the water will flow out from the non-blocked holes proportionally to their sizes s1,s2,\u2026,sn. In other words, if the sum of sizes of non-blocked holes is S, and the i-th hole is not blocked, si\u22c5AS liters of water will flow out of it.\nWhat is the minimum number of holes Arkady should block to make at least B liters of water flow out of the first hole?\nThe first line contains three integers n, A, B (1\u2264n\u2264100000, 1\u2264B\u2264A\u2264104)\u00a0\u2014 the number of holes, the volume of water Arkady will pour into the system, and the volume he wants to get out of the first hole.\nThe second line contains n integers s1,s2,\u2026,sn (1\u2264si\u2264104)\u00a0\u2014 the sizes of the holes.\nPrint a single integer\u00a0\u2014 the number of holes Arkady should block.\nIn the first example Arkady should block at least one hole. After that, 10\u22c526\u22483.333 liters of water will flow out of the first hole, and that suits Arkady.\nIn the second example even without blocking any hole, 80\u22c5310=24 liters will flow out of the first hole, that is not less than 20.\nIn the third example Arkady has to block all holes except the first to make all water flow out of the first hole.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "sortings",
            "*1000"
        ],
        "solutions": "967B - Watering SystemIt's obvious that we should block several largest holes. Let's first sort them. After that, let's iterate through the number of blocked holes, maintaining the sum of sizes of non-blocked holes S. With the value S it is easy to compute if the flow from the first hole is large enough or not. Just output the number of blocked pipes at the first moment when the flow is large enough. The complexity is O(n). 925A - Stairs and ElevatorsFirst thing to mention is that we can use no more than one stairs or elevator per query. Indeed, optimal path is always a few sections horizontally, then a stair of elevator, then a few sections horizontally.Then, we can note that we can always use one of the nearest stairs/elevators to start/finish. Using this fact, we can binary search in the sequence of stairs/elevators to find the optimal one, and choose the optimum between using a stairs and an elevator. Don't forget about the case where you don't have to reach any stairs/elevators.The complexity is O(qlogn). 925B - Resource DistributionSuppose that the load of the first service was divided among k1 servers and the load of the second service was divided among k2 servers. In such case first service will be running on k1 servers of resource at least p1=\u2308x1/k1\u2309 and second service will be run on k2 servers of resource at least p2=\u2308x2/k2\u2309. Suppose that p1\u2264p2, the remaining case will be dealt in the similar way. Remove all servers that have less than p1 resources, we are not going to use them. We may consider only assignments in which any server assigned to the first service has at most as many resources as any server assigned to the second service (otherwise we may swap them and the answer will still be correct). In such manner we may show that the first service may be assigned to the first k1 servers having at least p1 resource units and the second service may be assigned to the last k2 servers in ascending order of available resources.Finally notice that if we fix k1, the optimal value of k2 is minimum such that the last k2 servers have at least p2 resource units. Calculate the minimum possible k2 in linear time, after that try each possible value of k1 and check if the first k1 servers having at least p1 resource units do not intersect with the last k2 servers (it may be checked in a single binary search).We got a solution with running time of O(nlogn). 925C - Big SecretLet's assume that we've found a suitable permutation of all numbers, except all occurences of the number 1. When can we insert the 1's so that the new arrangement of numbers is again good? We can see that the XOR of all numbers before any occurence of the number 1 must be even, so there should an even number of odd numbers before it.Suppose that there are x 1's in the input, and y odd numbers greater than 1. If x>y+1, then in any arrangement there is going to be a pair of 1's such that there are no odd numbers between them, hence the condition above cannot hold for both of them simultaneously. On the other hand, if x\u2264y+1, then it is possible to insert the 1's into any permutation of greater numbers. Indeed, we can place one instance of 1 at the start, and then place remaining 1's immediately after greater odd numbers.Note that this argument works just as well if we consider numbers in the range [2k,2k+1) as \"1's\", and numbers in [2k+1,\u221e) as \"numbers greater than 1\". Note further that it doesn't matter how exactly we insert the \"1's\" since number of available gaps doesn't depend on that. Hence, we can go as follows: group the numbers by their leading bits. Make an empty list for the answer, and process the numbers in groups by decreasing of their leading bits. Suppose there are x numbers with leading bit k, and y greater numbers that have 1 in the k-th bit. If x>y+1, then there is no answer. Otherwise, insert the numbers from the current group as described above.The complexity of this solution is O(nlogA), where A is the largest value among the numbers in the input. 925D - Aztec CatacombsLet us formualate a problem in terms of graph theory and make some observation. Denote the start and the finish vertices as s and t.Observation 1. If vertices s and t are connected with a simple path consisting of k edges, then by the statement of the problem Indiana Johns may use it leading us to the answer of length k. Thus, the answer does not exceed d where d is the length of the shortest path between s and t if s and t are connected and \u221e otherwise. Let us call path consisting only of the original edges of the graph trivial and the paths including originally non-existent edges non-trivial.Observation 2. The length of any non-trivial path is at least 4. Indeed, let s=v0\u2212\u2192e1v2\u2212\u2192e2\u22ef\u2212\u2192ekvk=t be the valid path in which some of the edges ei is missing in the original graph. Notice that the edge e1 may not be missing as by the moment we follow it, nothing was flipped yet, and e2 also may not be missing as it requires e2 to be same with e1 which was just flipped. Also note that e3 may not be the last edge in our path because otherwise it must be missing in the original graph (since the path is non-trivial), and we did not visit vertex v2 yet as v2\u2260v1 and v2\u2260v0=1. Thus, k\u22654.Observation 3. If d\u22644, then the answer is d. It immediately follows from two previous observations: shortest trivial path has the length of d and shortest non-trivial has the length of at least 4.\u041d\u0430\u0431\u043b\u044e\u0434\u0435\u043d\u0438\u0435 4. If d\u22654 and there exists a vertex v2 at the distance of 2 from v0=s, then there exists a non-trivial path of length 4. Indeed, v0\u2192v1\u2192v2\u2192v0\u2192t is such path where v1 is a vertex through which the path of length 2 between v0 and v2 passes. Finally, note that v2 and v0 are not initially connected (otherwise the distance between v0 and v2 would be 1), hence when we visit v2, the edge v2\u2192v0 is present. Similarly, by the moment of second visit of vertex v0 originally missing edge v0\u2192t appears.Observation 5. Any non-trivial path of length 4 looks exactly as described in an observation 4, first two initially existent edges, then newly appeared edge leading to s and finally newly appeared edge leading to t. It immediately follows from the explanation of the observation 2.Observation 6. If d\u22654 and there no vertex v2 located at the distance 2 from s, then s is connected with all vertices in its connected component and this component does not contain t.Observation 7. If, under conditions of the previous observation, it we remove vertex s, then all the vertices initially adjacent to it will be distributed into several connected components. If all connected components are cliques, there are no valid paths. Indeed, after first transition we get into some clique and then we may only move inside it and it keeps shrinking until we get to an isolated vertex from which we can not go anywhere.Observation 8. If any of the connected components adjacent with s is not a clique, then the shortest valid non-trivial path has a length of 5. Indeed, consider a connected component C initially connected with s that is not a clique. It is not a clique, hence it contains a vertex v1 of degree less than |C|\u22121. This vertex is not connected with a whole component C, thus there are vertices v2,v3\u2208C such that v3 is not connected with v1, while v1 and v2 are connected and v2 and v3 are also connected with an edge. It means that there is a non-trivial path v0\u2192v1\u2192v2\u2192v3\u2192v1\u2192t. The observations above cover all possible cases in this problem and also yield a solution working in linear time in terms of a size of the original graph. 925E - May HolidaysIn terms of trees we have a rooted tree whose vertices may be activated and deactivated, and each vertex has a limit for the number of deactivated vertices among its descendants. We are required to switch the state of some vertex, and after each query we report the number of activated vertices unsatisfied vertices. Let the balance of a vertex be equal to the difference between its limit of deactivated descendants and the actual number of deactivated vertices among its descendants. In such terms we are interested in the number of activated vertices with the negative balance.Let's utilize the idea of sqrt-optimization. Consider a block of k consecutive queries, let us answer all of them. Suppose this query affects the state of vertices v1,v2,\u2026,vl (l\u2264k), let us call such vertices interesting. Then, during the current query block, the balance will change only for the vertices that have at least one interesting vertex in its subtree.Let's perform a classical trick of building the condensed tree containing the given interesting vertices. Namely, sort all the interesting vertices in order of their visit when doing DFS, and add all vertices of form lca(vi,vi+1) for all 1\u2264i<l to the set of interesting vertices. After such procedure all vertices whose balance may change may be splitted into O(k) vertical paths each of which ends in an interesting vertex. Now we are going to consider separately the interesting vertices and the interior vertices of all paths between interesting vertices. In each of the paths the balance of all vertices is changed simultaneously, thus we may sort all the vertices in each path by balance and then group all vertices having the same balance together. Introduce a pointer that initially stands at the first satisfied group (with non-negative balance). When the balance of all groups is changed by 1, instead of actually changing the value of balance we may just shift the pointer by at most one position to the left or to the right (artificially changing the origin) and accounting at most one group the pointer has passed in the answer. On each query we have to perform such an operation with every path and interesting vertex that is located above the queried vertex. Since each vertex and each path is processed in O(1), processing a single query takes O(k) time and processing all queries inside a block takes O(k2) time. It is possible to build all paths and groups in running time of a single DFS plus sort time (std::sort or counting sort) for grouping vertices of equal balance. This part of solution takes O(n) per each query block or O(nlogn) depending on used sorting algorithm.If we use count sort, the resulting complexity will be O(mk(k2+n)), finally we can take k=\u0398(n\u2212\u2212\u221a) and get O(mn\u2212\u2212\u221a) running time. 925F - Parametric CirculationFirst, let's use the classical reduction of lr-circulation problem to the maximum flow problem. Consider a network G\u2032=(V\u222a{s,t},E\u2032) where for each e=uv\u2208E there are three edges:  e0=uv with capacity ce0=re\u2212le  e1=sv with capacity ce1=le  e2=ut with capacity ce2=le Statement: it is possible to provide a bisection between s\u2212t flows of value \u2211e\u2208Ele in G\u2032 and lr-circulations in G. Indeed, consider a flow f\u2032 in G\u2032, that saturates all edges going from s (and all the edges leading into t at the same time). Let fe=f\u2032e0+le. Notice that it is a correct circulation: for any vertex v \u2211e\u2208\u03b4+(v)fe=\u2211e\u2208\u03b4+(v)f\u2032e0+\u2211e\u2208\u03b4+le=\u2211e\u2208\u03b4+(v)f\u2032e0+\u2211e\u2208\u03b4+fe1=\u2211e\u2208\u03b4\u2212(v)f\u2032e0+\u2211e\u2208\u03b4\u2212fe2=\u2211e\u2208\u03b4\u2212(v)f\u2032e0+\u2211e\u2208\u03b4\u2212le=\u2211e\u2208\u03b4\u2212(v)fewhere the middle equation is immediately following from the conservation condition for any vertex from V for a flow f\u2032.On the other hand, the obtained circulation is indeed an lr-circulation because of how we got values of f\u2032e. By performing all the steps in the reverse direction, we may recover a maximum flow in G\u2032 by any lr-circulation that finishes our proof.Now we are going to answer the following question: we have a parametric network G\u2032(t) in which all capacities linearly depend on t, we have to find the probability that G\u2032 allows a flow that saturates all edges from the source under condition that t is sampled from U[0,1].Let us show that the set of t that allow existence of a sought flow is a segment. It follows from the fact that the value maxflow(t) of a maximum flow in G\u2032(t) is concave: suppose f\u2032(t1) is a an admissible flow in G\u2032(t1) and f\u2032(t2) is an admissible flow in G\u2032t2. Then it is easy to see that \u03bbf\u2032(t1)+(1\u2212\u03bb)f\u2032(t2) is an admissible flow in G\u2032(\u03bbt1+(1\u2212\u03bb)t2) for any \u03bb\u2208[0,1] (as all the constraints on variables f\u2032e are linear inequalities), from which immediately follows that maxflow(\u03bbt1+(1\u2212\u03bb)t2)\u2265\u03bbmaxflow(t1)+(1\u2212\u03bb)maxflow(t2).Denote suml(t)=\u2211e\u2208El(t). Let us notices that gap(t)=suml(t)\u2212maxflow(t)\u22650 for any t and we are interested in precisely those values of t, such that gap(t)=0. Thus, the sought values of t form a segment as the function gap(t) is convex.The remaining part of the solution is very simple: find a minimum of a convexvalue gap(t) over a segment [0,1]. If it is non-zero, then the answer is 0. Otherwise, we can locate the boundaries of an answer segment using two binary searches and print the difference between them.While implementing such a solution, one may face several difficulties arising from the precision issues, so we will provide two observations that may help you deal with them.One may notice that maxflow(t) is actually a piecewise linear function, all pieces of which have the integer slope. Actually, maxflow(t)=mincut(t)=mincut\u00a0Ccost(C,t), and the cost of any fixed cut in G\u2032(t) is a linear function of t with an integer slope. Thus, maxflow(t) is a lower envelope of a family of linear functions with integer slopes. The similar fact holds for a function gap(t) also. And we are interested in a horizontal segment in gap(t) which may be found using the binary search over a sign of a derivative gap\u2032(t). Finally notice that calculating a derivative gap\u2032(t) may be done by finding a maximum flow and adding up all slopes of capacities of the edges defining a minimum cut restricting given maximum flow (since exactly this cut provides a linear constraint defining a segment of a function gap(t), which a point t belongs to).An alternative observation \u2014 consider only the points t such that t=k107 where k is integer. If we keep only such points on the sought segment, its length will decrease by no more than 2\u22c510\u22127 which is allowed by a required answer precision. Finally, we can multiply all be and de by 107 and consider t to be an integer between 0 and 107 which allows you to implement a solution that only uses integer data types.We get a solution with a running time of O(maxflow\u22c5logprec\u22121) where prec is a required precision equal to 10\u22126 under conditions of a given problem and maxflow is a running time of your favourite maximum flow algorithm. Practically you could use Dinic algorithm or Edmonds-Karp algorithm with capacity scaling."
    },
    "967A": {
        "title": "A. Mind the Gap",
        "description": "These days Arkady works as an air traffic controller at a large airport. He controls a runway which is usually used for landings only. Thus, he has a schedule of planes that are landing in the nearest future, each landing lasts 1 minute.\nHe was asked to insert one takeoff in the schedule. The takeoff takes 1 minute itself, but for safety reasons there should be a time space between the takeoff and any landing of at least s minutes from both sides.\nFind the earliest time when Arkady can insert the takeoff.\nThe first line of input contains two integers n and s (1\u2264n\u2264100, 1\u2264s\u226460)\u00a0\u2014 the number of landings on the schedule and the minimum allowed time (in minutes) between a landing and a takeoff.\nEach of next n lines contains two integers h and m (0\u2264h\u226423, 0\u2264m\u226459)\u00a0\u2014 the time, in hours and minutes, when a plane will land, starting from current moment (i.\u00a0e. the current time is 0 0). These times are given in increasing order.\nPrint two integers h and m\u00a0\u2014 the hour and the minute from the current moment of the earliest time Arkady can insert the takeoff.\nIn the first example note that there is not enough time between 1:20 and 3:21, because each landing and the takeoff take one minute.\nIn the second example there is no gaps in the schedule, so Arkady can only add takeoff after all landings. Note that it is possible that one should wait more than 24 hours to insert the takeoff.\nIn the third example Arkady can insert the takeoff even between the first landing.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "967A - Mind the GapThis problem requires you to carefully read and understand the statement. First, scan all the landing times, transforming each h and m pair into the number of minutes from the starting moment 60h+m. Then, there are three possibilities:  The first plane takes of not earlier than s+1 minutes from now. In this case we may put new takeoff right now.  Otherwise, if there is a pair of planes with at least 2+2s minutes between them. In this case we may choose the earliest such pair and put a new takeoff at 1+s minutes after the first of these planes.  Otherwise, we may always put a new plane in 1+s minutes after the last plane. Finally, print the answer in an h\u00a0m format. "
    },
    "961B": {
        "title": "B. Lecture Sleep",
        "description": "Your friend Mishka and you attend a calculus lecture. Lecture lasts n minutes. Lecturer tells ai theorems during the i-th minute.\nMishka is really interested in calculus, though it is so hard to stay awake for all the time of lecture. You are given an array t of Mishka's behavior. If Mishka is asleep during the i-th minute of the lecture then ti will be equal to 0, otherwise it will be equal to 1. When Mishka is awake he writes down all the theorems he is being told \u2014 ai during the i-th minute. Otherwise he writes nothing.\nYou know some secret technique to keep Mishka awake for k minutes straight. However you can use it only once. You can start using it at the beginning of any minute between 1 and n\u2009-\u2009k\u2009+\u20091. If you use it on some minute i then Mishka will be awake during minutes j such that  and will write down all the theorems lecturer tells.\nYou task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.\nThe first line of the input contains two integer numbers n and k (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the duration of the lecture in minutes and the number of minutes you can keep Mishka awake.\nThe second line of the input contains n integer numbers a1,\u2009a2,\u2009... an (1\u2009\u2264\u2009ai\u2009\u2264\u2009104) \u2014 the number of theorems lecturer tells during the i-th minute.\nThe third line of the input contains n integer numbers t1,\u2009t2,\u2009... tn (0\u2009\u2264\u2009ti\u2009\u2264\u20091) \u2014 type of Mishka's behavior at the i-th minute of the lecture.\nPrint only one integer \u2014 the maximum number of theorems Mishka will be able to write down if you use your technique only once to wake him up.\nIn the sample case the better way is to use the secret technique at the beginning of the third minute. Then the number of theorems Mishka will be able to write down will be equal to 16.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solutions": "961B - Lecture SleepLet's iterate over all i from 1 to n and if ti is equal to 1 then add ai to the some variable res and replace ai with 0. Then answer will be equal to , where  can be easily calculated with prefix sums for each i. Solution (Vovuh)#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\t\n\tvector<int> a(n);\n\tvector<int> t(n);\n\t\n\tint overall = 0;\n\t\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%d\", &t[i]);\n\t\t\n\tvector<int> pr(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (i) pr[i] += pr[i - 1];\n\t\tif (t[i] == 0) pr[i] += a[i];\n\t\telse overall += a[i];\n\t}\n\t\n\tint add = 0;\n\tfor (int i = k - 1; i < n; ++i)\n\t\tadd = max(add, pr[i] - (i >= k ? pr[i - k] : 0));\n\t\n\tprintf(\"%d\\n\", overall + add);\n\t\n\treturn 0;\n}"
    },
    "960A": {
        "title": "A. Check the string",
        "description": "A has a string consisting of some number of lowercase English letters 'a'. He gives it to his friend B who appends some number of letters 'b' to the end of this string. Since both A and B like the characters 'a' and 'b', they have made sure that at this point, at least one 'a' and one 'b' exist in the string.\nB now gives this string to C and he appends some number of letters 'c' to the end of the string. However, since C is a good friend of A and B, the number of letters 'c' he appends is equal to the number of 'a' or to the number of 'b' in the string. It is also possible that the number of letters 'c' equals both to the number of letters 'a' and to the number of letters 'b' at the same time.\nYou have a string in your hands, and you want to check if it is possible to obtain the string in this way or not. If it is possible to obtain the string, print \"YES\", otherwise print \"NO\" (without the quotes).\nThe first and only line consists of a string S (1\u2264|S|\u22645000). It is guaranteed that the string will only consist of the lowercase English letters 'a', 'b', 'c'.\nPrint \"YES\" or \"NO\", according to the condition.\nConsider first example: the number of 'c' is equal to the number of 'a'. \nConsider second example: although the number of 'c' is equal to the number of the 'b', the order is not correct.\nConsider third example: the number of 'c' is equal to the number of 'b'.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "960A - Check the stringTraverse the string once and check if the ASCII value of all characters is greater than or equal or the ASCII value of the previous character. This ensures that the string does not have a,b,c in wrong order.Also, while traversing the string, keep three separate counters for the number of 'a', 'b' and 'c' along.Now, do a simple check on the condition for the count of 'c'.The hack case for many solutions was to check that the count of 'a' is atleast 1 and the count of 'b' is atleast 1.Set by : vntshh Setter's solution#include<bits/stdc++.h>\n#define rep(i,start,lim) for(lld i=start;i<lim;i++)\n#define repd(i,start,lim) for(lld i=start;i>=lim;i--)\n#define scan(x) scanf(\"%lld\",&x)\n#define print(x) printf(\"%lld \",x)\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define br printf(\"\\n\")\n#define sz(a) lld((a).size())\n#define YES printf(\"YES\\n\")\n#define NO printf(\"NO\\n\")\n#define all(c) (c).begin(),(c).end()\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define EPS         (double)1e-10\n#define MOD         1000000007\n#define PI          3.14159265358979323\nusing namespace std;\ntypedef long double ldb;\ntypedef long long lld;\nlld powm(lld base,lld exp,lld mod=MOD) {lld ans=1;while(exp){if(exp&1) ans=(ans*base)%mod;exp>>=1,base=(base*base)%mod;}return ans;}\nlld ctl(char x,char an='a') {return (lld)(x-an);}\nchar ltc(lld x,char an='a') {return (char)(x+an);}\n#define bit(x,j) ((x>>j)&1)\ntypedef vector<lld> vlld;\ntypedef pair<lld,lld> plld;\ntypedef map<lld,lld> mlld;\ntypedef set<lld> slld;\n#define sync ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define mxm(a,b) a = max(a,b)\n#define mnm(a,b) a = min(a,b)\n#define endl '\\n'\n#define fre freopen(\"1.in\",\"r\",stdin); freopen(\"1.out\",\"w\",stdout);\n#define N 1000005\nint main()\n{\n    //sync;\n    string s;\n    map<char,lld> m;\n    cin>>s;\n    lld k = sz(s);\n    string tmp = \"\";\n    tmp += s[0];\n    rep(i,1,k) if(s[i]!=s[i-1]) tmp+=s[i];\n    rep(i,0,k) m[s[i]]++;\n    if(tmp != \"abc\") return 0*NO;\n    if(m['c']!=m['a'] and m['c']!=m['b']) return 0*NO;\n    if(m['a']>=1 and m['b']>=1) return 0*YES;\n    else return 0*NO;\n    return 0;\n} "
    },
    "959B": {
        "title": "B. Mahmoud and Ehab and the message",
        "description": "Mahmoud wants to send a message to his friend Ehab. Their language consists of n words numbered from 1 to n. Some words have the same meaning so there are k groups of words such that all the words in some group have the same meaning.\nMahmoud knows that the i-th word can be sent with cost ai. For each word in his message, Mahmoud can either replace it with another word of the same meaning or leave it as it is. Can you help Mahmoud determine the minimum cost of sending the message?\nThe cost of sending the message is the sum of the costs of sending every word in it.\nThe first line of input contains integers n, k and m (1\u2009\u2264\u2009k\u2009\u2264\u2009n\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009m\u2009\u2264\u2009105)\u00a0\u2014 the number of words in their language, the number of groups of words, and the number of words in Mahmoud's message respectively.\nThe second line contains n strings consisting of lowercase English letters of length not exceeding 20 which represent the words. It's guaranteed that the words are distinct.\nThe third line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109) where ai is the cost of sending the i-th word.\nThe next k lines describe the groups of words of same meaning. The next k lines each start with an integer x (1\u2009\u2264\u2009x\u2009\u2264\u2009n) which means that there are x words in this group, followed by x integers which represent the indices of words in this group. It's guaranteed that each word appears in exactly one group.\nThe next line contains m space-separated words which represent Mahmoud's message. Each of these words appears in the list of language's words.\nThe only line should contain the minimum cost to send the message after replacing some words (maybe none) with some words of the same meaning.\nIn the first sample, Mahmoud should replace the word \"second\" with the word \"loser\" because it has less cost so the cost will be 100+1+5+1=107.\nIn the second sample, Mahmoud shouldn't do any replacement so the cost will be 100+1+5+10=116.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dsu",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "959B - Mahmoud and Ehab and the messageIt's easy to see that for every word, the minimum cost of sending it is the minimum cost of sending any word in its group. For each group, we'll maintain the minimum cost for sending a word in it (let it be costi) and for each word, we'll maintain its group (let it be groupi). For every word i in the message, we'll add costgroupi to the answer.Code link (me) : https://pastebin.com/3RFeEkgDCode link (mahmoudbadawy) : https://pastebin.com/sR5eZy7dTime complexity : O((n\u2009+\u2009m)log(n)\u2009*\u2009len).Bonus task : Try to solve the problem if the input was given as pairs of words that are synonyms (assuming synonymy is transitive). SolutionUse dsu to transform the bonus task to the original problem."
    },
    "958C1": {
        "title": "C1. Encryption (easy)",
        "description": "Rebel spy Heidi has just obtained the plans for the Death Star from the Empire and, now on her way to safety, she is trying to break the encryption of the plans (of course they are encrypted \u2013 the Empire may be evil, but it is not stupid!). The encryption has several levels of security, and here is how the first one looks.\nHeidi is presented with a screen that shows her a sequence of integers A and a positive integer p. She knows that the encryption code is a single number S, which is defined as follows:\nDefine the score of X to be the sum of the elements of X modulo p.\nHeidi is given a sequence A that consists of N integers, and also given an integer p. She needs to split A into 2 parts such that: \nOutput the sum S, which is the encryption code.\nThe first line of the input contains two space-separated integer N and p (2\u2009\u2264\u2009N\u2009\u2264\u2009100\u2009000, 2\u2009\u2264\u2009p\u2009\u2264\u200910\u2009000) \u2013 the number of elements in A, and the modulo for computing scores, respectively.\nThe second line contains N space-separated integers which are the elements of A. Each integer is from the interval [1,\u20091\u2009000\u2009000].\nOutput the number S as described in the problem statement.\nIn the first example, the score is maximized if the input sequence is split into two parts as (3,\u20094), (7,\u20092). It gives the total score of .\nIn the second example, the score is maximized if the first part consists of the first three elements, and the second part consists of the rest. Then, the score is .",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "958B1": {
        "title": "B1. Maximum Control (easy)",
        "description": "The Resistance is trying to take control over all planets in a particular solar system. This solar system is shaped like a tree. More precisely, some planets are connected by bidirectional hyperspace tunnels in such a way that there is a path between every pair of the planets, but removing any tunnel would disconnect some of them.\nThe Resistance already has measures in place that will, when the time is right, enable them to control every planet that is not remote. A planet is considered to be remote if it is connected to the rest of the planets only via a single hyperspace tunnel.\nHow much work is there left to be done: that is, how many remote planets are there?\nThe first line of the input contains an integer N (2\u2009\u2264\u2009N\u2009\u2264\u20091000) \u2013 the number of planets in the galaxy.\nThe next N\u2009-\u20091 lines describe the hyperspace tunnels between the planets. Each of the N\u2009-\u20091 lines contains two space-separated integers u and v (1\u2009\u2264\u2009u,\u2009v\u2009\u2264\u2009N) indicating that there is a bidirectional hyperspace tunnel between the planets u and v. It is guaranteed that every two planets are connected by a path of tunnels, and that each tunnel connects a different pair of planets.\nA single integer denoting the number of remote planets.\nIn the first example, only planets 2, 3 and 5 are connected by a single tunnel.\nIn the second example, the remote planets are 2 and 3.\nNote that this problem has only two versions \u2013 easy and medium.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "955A": {
        "title": "A. Feed the cat",
        "description": "After waking up at hh:mm, Andrew realised that he had forgotten to feed his only cat for yet another time (guess why there's only one cat). The cat's current hunger level is H points, moreover each minute without food increases his hunger by D points.\nAt any time Andrew can visit the store where tasty buns are sold (you can assume that is doesn't take time to get to the store and back). One such bun costs C roubles and decreases hunger by N points. Since the demand for bakery drops heavily in the evening, there is a special 20% discount for buns starting from 20:00 (note that the cost might become rational). Of course, buns cannot be sold by parts.\nDetermine the minimum amount of money Andrew has to spend in order to feed his cat. The cat is considered fed if its hunger level is less than or equal to zero.\nThe first line contains two integers hh and mm (00\u2009\u2264\u2009hh\u2009\u2264\u200923,\u200900\u2009\u2264\u2009mm\u2009\u2264\u200959) \u2014 the time of Andrew's awakening.\nThe second line contains four integers H, D, C and N (1\u2009\u2264\u2009H\u2009\u2264\u2009105,\u20091\u2009\u2264\u2009D,\u2009C,\u2009N\u2009\u2264\u2009102).\nOutput the minimum amount of money to within three decimal digits. You answer is considered correct, if its absolute or relative error does not exceed 10\u2009-\u20094.\nFormally, let your answer be a, and the jury's answer be b. Your answer is considered correct if .\nIn the first sample Andrew can visit the store at exactly 20:00. The cat's hunger will be equal to 315, hence it will be necessary to purchase 315 buns. The discount makes the final answer 25200 roubles.\nIn the second sample it's optimal to visit the store right after he wakes up. Then he'll have to buy 91 bins per 15 roubles each and spend a total of 1365 roubles.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "955A - Feed the catIt's optimal to buy buns either right after waking up or at 20:00 (if possible) because between the awakening and 20:00 cost doesn't change but cat's hunger does. There was one extra case when Andrew wakes up after 20:00 and has only one possible option of buying everything since he cannot turn back time.Code: 36605296 "
    },
    "950B": {
        "title": "B. Intercepted Message",
        "description": "Hacker Zhorik wants to decipher two secret messages he intercepted yesterday. Yeah message is a sequence of encrypted blocks, each of them consists of several bytes of information.\nZhorik knows that each of the messages is an archive containing one or more files. Zhorik knows how each of these archives was transferred through the network: if an archive consists of k files of sizes l1,\u2009l2,\u2009...,\u2009lk bytes, then the i-th file is split to one or more blocks bi,\u20091,\u2009bi,\u20092,\u2009...,\u2009bi,\u2009mi (here the total length of the blocks bi,\u20091\u2009+\u2009bi,\u20092\u2009+\u2009...\u2009+\u2009bi,\u2009mi is equal to the length of the file li), and after that all blocks are transferred through the network, maintaining the order of files in the archive.\nZhorik thinks that the two messages contain the same archive, because their total lengths are equal. However, each file can be split in blocks in different ways in the two messages.\nYou are given the lengths of blocks in each of the two messages. Help Zhorik to determine what is the maximum number of files could be in the archive, if the Zhorik's assumption is correct.\nThe first line contains two integers n, m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u2009105) \u2014 the number of blocks in the first and in the second messages.\nThe second line contains n integers x1,\u2009x2,\u2009...,\u2009xn (1\u2009\u2264\u2009xi\u2009\u2264\u2009106) \u2014 the length of the blocks that form the first message.\nThe third line contains m integers y1,\u2009y2,\u2009...,\u2009ym (1\u2009\u2264\u2009yi\u2009\u2264\u2009106) \u2014 the length of the blocks that form the second message.\nIt is guaranteed that x1\u2009+\u2009...\u2009+\u2009xn\u2009=\u2009y1\u2009+\u2009...\u2009+\u2009ym. Also, it is guaranteed that x1\u2009+\u2009...\u2009+\u2009xn\u2009\u2264\u2009106.\nPrint the maximum number of files the intercepted array could consist of.\nIn the first example the maximum number of files in the archive is 3. For example, it is possible that in the archive are three files of sizes 2\u2009+\u20095\u2009=\u20097, 15\u2009=\u20093\u2009+\u20091\u2009+\u200911\u2009=\u20098\u2009+\u20092\u2009+\u20094\u2009+\u20091 and 4\u2009+\u20094\u2009=\u20098.\nIn the second example it is possible that the archive contains two files of sizes 1 and 110\u2009=\u200910\u2009+\u2009100\u2009=\u2009100\u2009+\u200910. Note that the order of files is kept while transferring archives through the network, so we can't say that there are three files of sizes 1, 10 and 100.\nIn the third example the only possibility is that the archive contains a single file of size 4.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "950B - Intercepted MessageLet's define  and  as sums of first  elements of  and  (, , , ).  and  can be same file iff this three conditions are true:   because we need to divide prefix into files.   because we need to divide suffix into files.   segments have same sum. It's easy to see that if two first conditions are true then the third are true too because  and because of this fact and condition from statement  answer is a number of non-empty prefixes with the same sum.Time complexity is  if you use two pointers or  if you use some data structure.BONUS (easy): You lost one block from second message and you interested in maximal possible number of files if you can insert this block anywhere in second message. In this case it graduated that .(Idea \u2014 meshanya, developing \u2014 Zlobober, KAN) "
    },
    "946B": {
        "title": "B. Weird Subtraction Process",
        "description": "You have two variables a and b. Consider the following sequence of actions performed with these variables:\nInitially the values of a and b are positive integers, and so the process will be finite.\nYou have to determine the values of a and b after the process ends.\nThe only line of the input contains two integers n and m (1\u2009\u2264\u2009n,\u2009m\u2009\u2264\u20091018). n is the initial value of variable a, and m is the initial value of variable b.\nPrint two integers \u2014 the values of a and b after the end of the process.\nExplanations to the samples:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solutions": "946B - Weird Subtraction ProcessThe answer can be calculated very easy by Euclid algorithm (which is described in the problem statement), but all subtractions will be replaced by taking by modulo. "
    },
    "940A": {
        "title": "A. Points on the line",
        "description": "We've got no test cases. A big olympiad is coming up. But the problemsetters' number one priority should be adding another problem to the round. \nThe diameter of a multiset of points on the line is the largest distance between two points from this set. For example, the diameter of the multiset {1,\u20093,\u20092,\u20091} is 2.\nDiameter of multiset consisting of one point is 0.\nYou are given n points on the line. What is the minimum number of points you have to remove, so that the diameter of the multiset of the remaining points will not exceed d?\nThe first line contains two integers n and d (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20090\u2009\u2264\u2009d\u2009\u2264\u2009100)\u00a0\u2014 the amount of points and the maximum allowed diameter respectively.\nThe second line contains n space separated integers (1\u2009\u2264\u2009xi\u2009\u2264\u2009100)\u00a0\u2014 the coordinates of the points.\nOutput a single integer\u00a0\u2014 the minimum number of points you have to remove.\nIn the first test case the optimal strategy is to remove the point with coordinate 4. The remaining points will have coordinates 1 and 2, so the diameter will be equal to 2\u2009-\u20091\u2009=\u20091.\nIn the second test case the diameter is equal to 0, so its is unnecessary to remove any points. \nIn the third test case the optimal strategy is to remove points with coordinates 1, 9 and 10. The remaining points will have coordinates 3, 4 and 6, so the diameter will be equal to 6\u2009-\u20093\u2009=\u20093.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solutions": "940A - Points on the lineIt's clear that diameter of the multiset of points equals to difference of coordinates of point with maximum coordinate and point with minimum coordinate. So we can iterate over all possible pairs of maximum and minimum point and check number of remaining points in O(n). This solution works in O(n3).Of course, there are faster solutions.(Developing \u2014 vintage_Vlad_Makeev, ch_egor, V--o_o--V, demon1999) "
    },
    "939B": {
        "title": "B. Hamster Farm",
        "description": "Dima has a hamsters farm. Soon N hamsters will grow up on it and Dima will sell them in a city nearby.\nHamsters should be transported in boxes. If some box is not completely full, the hamsters in it are bored, that's why each box should be completely full with hamsters.\nDima can buy boxes at a factory. The factory produces boxes of K kinds, boxes of the i-th kind can contain in themselves ai hamsters. Dima can buy any amount of boxes, but he should buy boxes of only one kind to get a wholesale discount.\nOf course, Dima would buy boxes in such a way that each box can be completely filled with hamsters and transported to the city. If there is no place for some hamsters, Dima will leave them on the farm.\nFind out how many boxes and of which type should Dima buy to transport maximum number of hamsters.\nThe first line contains two integers N and K (0\u2009\u2264\u2009N\u2009\u2264\u20091018, 1\u2009\u2264\u2009K\u2009\u2264\u2009105)\u00a0\u2014 the number of hamsters that will grow up on Dima's farm and the number of types of boxes that the factory produces.\nThe second line contains K integers a1, a2, ..., aK (1\u2009\u2264\u2009ai\u2009\u2264\u20091018 for all i)\u00a0\u2014 the capacities of boxes.\nOutput two integers: the type of boxes that Dima should buy and the number of boxes of that type Dima should buy. Types of boxes are numbered from 1 to K in the order they are given in input.\nIf there are many correct answers, output any of them.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "939B - Hamster FarmThe easies way to solve this problem is to find the minimum number of hamsters that can be left on the farm. If Dima byes boxes of the i-th type, there are  hamsters left on the farm. So we should find such a type x, that the value  is minimum among all x; The number of boxes to buy is then equal to .Problem author: KAP, preparation: KAP. "
    },
    "938B": {
        "title": "B. Run For Your Prize",
        "description": "You and your friend are participating in a TV show \"Run For Your Prize\".\nAt the start of the show n prizes are located on a straight line. i-th prize is located at position ai. Positions of all prizes are distinct. You start at position 1, your friend \u2014 at position 106 (and there is no prize in any of these two positions). You have to work as a team and collect all prizes in minimum possible time, in any order.\nYou know that it takes exactly 1 second to move from position x to position x\u2009+\u20091 or x\u2009-\u20091, both for you and your friend. You also have trained enough to instantly pick up any prize, if its position is equal to your current position (and the same is true for your friend). Carrying prizes does not affect your speed (or your friend's speed) at all.\nNow you may discuss your strategy with your friend and decide who will pick up each prize. Remember that every prize must be picked up, either by you or by your friend.\nWhat is the minimum number of seconds it will take to pick up all the prizes?\nThe first line contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number of prizes.\nThe second line contains n integers a1, a2, ..., an (2\u2009\u2264\u2009ai\u2009\u2264\u2009106\u2009-\u20091) \u2014 the positions of the prizes. No two prizes are located at the same position. Positions are given in ascending order.\nPrint one integer \u2014 the minimum number of seconds it will take to collect all prizes.\nIn the first example you take all the prizes: take the first at 1, the second at 2 and the third at 8.\nIn the second example you take the first prize in 1 second and your friend takes the other in 5 seconds, you do this simultaneously, so the total time is 5.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "934B": {
        "title": "B. A Prosperous Lot",
        "description": "Apart from Nian, there is a daemon named Sui, which terrifies children and causes them to become sick. Parents give their children money wrapped in red packets and put them under the pillow, so that when Sui tries to approach them, it will be driven away by the fairies inside.\nBig Banban is hesitating over the amount of money to give out. He considers loops to be lucky since it symbolizes unity and harmony.\nHe would like to find a positive integer n not greater than 1018, such that there are exactly k loops in the decimal representation of n, or determine that such n does not exist.\nA loop is a planar area enclosed by lines in the digits' decimal representation written in Arabic numerals. For example, there is one loop in digit 4, two loops in 8 and no loops in 5. Refer to the figure below for all exact forms.\nThe first and only line contains an integer k (1\u2009\u2264\u2009k\u2009\u2264\u2009106)\u00a0\u2014 the desired number of loops.\nOutput an integer\u00a0\u2014 if no such n exists, output -1; otherwise output any such n. In the latter case, your output should be a positive decimal integer not exceeding 1018.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1200"
        ],
        "solutions": "934B - A Prosperous LotWhat's the maximum number of loops in an integer no greater than 1018? Since 8 is the only digit with two loops, we tend to use as many eights as possible. It can be seen that the answer is 36, achieved by 888\u2009888\u2009888\u2009888\u2009888\u2009888. Thus if k\u2009>\u200936, the answer does not exist under the constraints.There are tons of approaches to the following part. Share yours in the comments!The author considers 8 and 9 as lucky numbers and uses only 8 and 9 to construct a valid answer. In particular, the output consists of  eight(s) and  nine(s).Bonus. Solve the problem with the shortest code! The tester's Python solution is 51 bytes including a line break, can you beat them? ;) Solution (Tommyr7)#include <bits/stdc++.h>\nusing namespace std;\nint n,k;\nint main()\n{\n\tscanf(\"%d\",&k);\n\tif (k>36) printf(\"%d\\n\",-1);\n\telse\n\t{\n\t\twhile (k>0)\n\t\t{\n\t\t\tif (k>=2)\n\t\t\t{\n\t\t\t\tprintf(\"%d\",8);\n\t\t\t\tk-=2;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tprintf(\"%d\",9);\n\t\t\t\tk-=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n"
    },
    "931B": {
        "title": "B. World Cup",
        "description": "The last stage of Football World Cup is played using the play-off system.\nThere are n teams left in this stage, they are enumerated from 1 to n. Several rounds are held, in each round the remaining teams are sorted in the order of their ids, then the first in this order plays with the second, the third\u00a0\u2014 with the fourth, the fifth\u00a0\u2014 with the sixth, and so on. It is guaranteed that in each round there is even number of teams. The winner of each game advances to the next round, the loser is eliminated from the tournament, there are no draws. In the last round there is the only game with two remaining teams: the round is called the Final, the winner is called the champion, and the tournament is over.\nArkady wants his two favorite teams to play in the Final. Unfortunately, the team ids are already determined, and it may happen that it is impossible for teams to meet in the Final, because they are to meet in some earlier stage, if they are strong enough. Determine, in which round the teams with ids a and b can meet.\nThe only line contains three integers n, a and b (2\u2009\u2264\u2009n\u2009\u2264\u2009256, 1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009n)\u00a0\u2014 the total number of teams, and the ids of the teams that Arkady is interested in. \nIt is guaranteed that n is such that in each round an even number of team advance, and that a and b are not equal.\nIn the only line print \"Final!\" (without quotes), if teams a and b can meet in the Final.\nOtherwise, print a single integer\u00a0\u2014 the number of the round in which teams a and b can meet. The round are enumerated from 1.\nIn the first example teams 1 and 2 meet in the first round.\nIn the second example teams 2 and 6 can only meet in the third round, which is the Final, if they win all their opponents in earlier rounds.\nIn the third example the teams with ids 7 and 5 can meet in the second round, if they win their opponents in the first round.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "928A": {
        "title": "A. Login Verification",
        "description": "When registering in a social network, users are allowed to create their own convenient login to make it easier to share contacts, print it on business cards, etc.\nLogin is an arbitrary sequence of lower and uppercase latin letters, digits and underline symbols (\u00ab_\u00bb). However, in order to decrease the number of frauds and user-inattention related issues, it is prohibited to register a login if it is similar with an already existing login. More precisely, two logins s and t are considered similar if we can transform s to t via a sequence of operations of the following types: \nFor example, logins \u00abCodeforces\u00bb and \u00abcodef0rces\u00bb as well as \u00abOO0OOO00O0OOO0O00OOO0OO_lol\u00bb and \u00abOO0OOO0O00OOO0O00OO0OOO_1oI\u00bb are considered similar whereas \u00abCodeforces\u00bb and \u00abCode_forces\u00bb are not.\nYou're given a list of existing logins with no two similar amonst and a newly created user login. Check whether this new login is similar with any of the existing ones.\nThe first line contains a non-empty string s consisting of lower and uppercase latin letters, digits and underline symbols (\u00ab_\u00bb) with length not exceeding 50 \u00a0\u2014 the login itself.\nThe second line contains a single integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091\u2009000)\u00a0\u2014 the number of existing logins.\nThe next n lines describe the existing logins, following the same constraints as the user login (refer to the first line of the input). It's guaranteed that no two existing logins are similar.\nPrint \u00abYes\u00bb (without quotes), if user can register via this login, i.e. none of the existing logins is similar with it.\nOtherwise print \u00abNo\u00bb (without quotes).\nIn the second sample case the user wants to create a login consisting of three zeros. It's impossible due to collision with the third among the existing.\nIn the third sample case the new login is similar with the second one.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "strings",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "920B": {
        "title": "B. Tea Queue",
        "description": "Recently n students from city S moved to city P to attend a programming camp.\nThey moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea.\ni-th student comes to the end of the queue at the beginning of li-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of ri-th second student i still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. \nFor each student determine the second he will use the teapot and get his tea (if he actually gets it).\nThe first line contains one integer t \u2014 the number of test cases to solve (1\u2009\u2264\u2009t\u2009\u2264\u20091000).\nThen t test cases follow. The first line of each test case contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20091000) \u2014 the number of students.\nThen n lines follow. Each line contains two integer li, ri (1\u2009\u2264\u2009li\u2009\u2264\u2009ri\u2009\u2264\u20095000) \u2014 the second i-th student comes to the end of the queue, and the second he leaves the queue if he still cannot get his tea.\nIt is guaranteed that for every  condition li\u2009-\u20091\u2009\u2264\u2009li holds.\nThe sum of n over all test cases doesn't exceed 1000.\nNote that in hacks you have to set t\u2009=\u20091.\nFor each test case print n integers. i-th of them must be equal to the second when i-th student gets his tea, or 0 if he leaves without tea.\nThe example contains 2 tests:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "920A": {
        "title": "A. Water The Garden",
        "description": "It is winter now, and Max decided it's about time he watered the garden.\nThe garden can be represented as n consecutive garden beds, numbered from 1 to n. k beds contain water taps (i-th tap is located in the bed xi), which, if turned on, start delivering water to neighbouring beds. If the tap on the bed xi is turned on, then after one second has passed, the bed xi will be watered; after two seconds have passed, the beds from the segment [xi\u2009-\u20091,\u2009xi\u2009+\u20091] will be watered (if they exist); after j seconds have passed (j is an integer number), the beds from the segment [xi\u2009-\u2009(j\u2009-\u20091),\u2009xi\u2009+\u2009(j\u2009-\u20091)] will be watered (if they exist). Nothing changes during the seconds, so, for example, we can't say that the segment [xi\u2009-\u20092.5,\u2009xi\u2009+\u20092.5] will be watered after 2.5 seconds have passed; only the segment [xi\u2009-\u20092,\u2009xi\u2009+\u20092] will be watered at that moment.\nMax wants to turn on all the water taps at the same moment, and now he wonders, what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered. Help him to find the answer!\nThe first line contains one integer t \u2014 the number of test cases to solve (1\u2009\u2264\u2009t\u2009\u2264\u2009200).\nThen t test cases follow. The first line of each test case contains two integers n and k (1\u2009\u2264\u2009n\u2009\u2264\u2009200, 1\u2009\u2264\u2009k\u2009\u2264\u2009n) \u2014 the number of garden beds and water taps, respectively.\nNext line contains k integers xi (1\u2009\u2264\u2009xi\u2009\u2264\u2009n) \u2014 the location of i-th water tap. It is guaranteed that for each  condition xi\u2009-\u20091\u2009<\u2009xi holds.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 200.\nNote that in hacks you have to set t\u2009=\u20091.\nFor each test case print one integer \u2014 the minimum number of seconds that have to pass after Max turns on some of the water taps, until the whole garden is watered.\nThe first example consists of 3 tests:",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "No solution found"
    },
    "919B": {
        "title": "B. Perfect Number",
        "description": "We consider a positive integer perfect, if and only if the sum of its digits is exactly 10. Given a positive integer k, your task is to find the k-th smallest perfect positive integer.\nA single line with a positive integer k (1\u2264k\u226410000).\nA single number, denoting the k-th smallest perfect integer.\nThe first perfect integer is 19 and the second one is 28.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "dp",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solutions": "919B - Perfect NumberLet's use brute force the find the answer.You may find the answer is not too large (i.e. not bigger than 2\u22c5107), then you can find it in the given time limit.You can check every possible answer from 1 (or from 19), until we find the k-th perfect integer.That's all what we need to do. :PTime complexity: O(answer). :PBonus1: Could you please come up with a faster brute force algorithm which doesn't need to check too many possible answers?Bonus2: Can you solve the problem with a bigger k (i.e. k\u22641018 or even bigger)? Code (C++ version)Code (Python version) "
    },
    "914B": {
        "title": "B. Conan and Agasa play a Card Game",
        "description": "Edogawa Conan got tired of solving cases, and invited his friend, Professor Agasa, over. They decided to play a game of cards. Conan has n cards, and the i-th card has a number ai written on it.\nThey take turns playing, starting with Conan. In each turn, the player chooses a card and removes it. Also, he removes all cards having a number strictly lesser than the number on the chosen card. Formally, if the player chooses the i-th card, he removes that card and removes the j-th card for all j such that aj\u2009<\u2009ai.\nA player loses if he cannot make a move on his turn, that is, he loses if there are no cards left. Predict the outcome of the game, assuming both players play optimally.\nThe first line contains an integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009105)\u00a0\u2014 the number of cards Conan has. \nThe next line contains n integers a1,\u2009a2,\u2009...,\u2009an (1\u2009\u2264\u2009ai\u2009\u2264\u2009105), where ai is the number on the i-th card.\nIf Conan wins, print \"Conan\" (without quotes), otherwise print \"Agasa\" (without quotes).\nIn the first example, Conan can just choose the card having number 7 on it and hence remove all the cards. After that, there are no cards left on Agasa's turn.\nIn the second example, no matter which card Conan chooses, there will be one one card left, which Agasa can choose. After that, there are no cards left when it becomes Conan's turn again.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "914B - Conan and Agasa play a Card GameLet A\u2009=\u2009max (a1,\u2009a2,\u2009...,\u2009an). Observe that if A occurs an odd number of times, Conan can simply begin by removing one instance of A. If there are any cards left, they all have the same number A on them. Now each player can only remove one card in their turn, and they take turns doing so. Since there were an odd number of cards having A on them initially, this keeps continuing until finally, in one of Agasa's turns, there are no cards left. However, if A occurs an even number of times, Conan cannot choose a card having A on it because it will leave Agasa with an odd number of cards having A. This will result in both players picking cards one by one, ending with Agasa picking the last card, and thus winning. In such a case, Conan can consider picking the next distinct largest number in the array, say B. If B occurs an odd number of times, then after Conan's turn there will be an even number of cards having B and an even number of cards having A. If Agasa takes a card having A then it becomes the same as the previous case and Conan wins. Otherwise, they take turns choosing a card having B until finally, on one of Agasa's turns, there are no cards having B and Agasa is forced to pick a card having A. Now it is Conan's turn and there are an odd number of cards having A, so it is again the same as the first case and Conan wins.By a similar argument, we can show that if Conan plays optimally, he starts by picking a card having the greatest number that occurs an odd number of times. Conan loses if and only if there is no such number, i.e., Conan loses if and only if every number occurs an even number of times.Author: RohanRTiwariTester: Superty Author's code#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint cnt[100005];\n\nint main() {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  while(n--) {\n    int x;\n    cin >> x;\n    cnt[x]++;\n  }\n\n  for (int i = 1; i <= 1e5; i++) {\n    if (cnt[i] % 2 == 1) {\n      cout << \"Conan\\n\";\n      return 0;\n    }\n  }\n  cout << \"Agasa\\n\";\n  return 0;\n} "
    },
    "913B": {
        "title": "B. Christmas Spruce",
        "description": "Consider a rooted tree. A rooted tree has one special vertex called the root. All edges are directed from the root. Vertex u is called a child of vertex v and vertex v is called a parent of vertex u if there exists a directed edge from v to u. A vertex is called a leaf if it doesn't have children and has a parent.\nLet's call a rooted tree a spruce if its every non-leaf vertex has at least 3 leaf children. You are given a rooted tree, check whether it's a spruce.\nThe definition of a rooted tree can be found here.\nThe first line contains one integer n\u00a0\u2014 the number of vertices in the tree (3\u2009\u2264\u2009n\u2009\u2264\u20091\u2009000). Each of the next n\u2009-\u20091 lines contains one integer pi (1\u2009\u2264\u2009i\u2009\u2264\u2009n\u2009-\u20091)\u00a0\u2014 the index of the parent of the i\u2009+\u20091-th vertex (1\u2009\u2264\u2009pi\u2009\u2264\u2009i).\nVertex 1 is the root. It's guaranteed that the root has at least 2 children.\nPrint \"Yes\" if the tree is a spruce and \"No\" otherwise.\nThe first example:\n\nThe second example:\n\nIt is not a spruce, because the non-leaf vertex 1 has only 2 leaf children.\nThe third example:\n",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "trees",
            "*1200"
        ],
        "solutions": "913B - Christmas SpruceLets calculate amount of children for each vertex. To do that lets increase by 1 c[pi] for every pi. Then iterate over all vertexes. If i-th vertex has 0 children (i.e. c[i]\u2009=\u20090), skip this vertex. Else again iterate over all vertexes and calculate number of vertexes j such that c[j]\u2009=\u20090 and pj\u2009=\u2009i. If this number is lower than 3, answer is \"No\". Else answer is \"Yes\". C++ solution#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<int> p(n), deg(n);\n  for (int i = 1; i < n; i++) {\n    cin >> p[i];\n    p[i]--;\n    deg[p[i]]++;\n  }\n  vector<int> sons_leaves(n);\n  for (int i = 0; i < n; i++) {\n    if (deg[i] == 0) {\n      sons_leaves[p[i]]++;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (deg[i] > 0 && sons_leaves[i] < 3) {\n      puts(\"No\");\n      return 0;\n    }\n  }\n  puts(\"Yes\");\n  return 0;\n} Python solutionn = int(input())\np = [int(input()) - 1 for _ in range(n - 1)]\nleafs = list(filter(lambda x: not x in p, range(n)))\nlp = [x for i, x in enumerate(p) if i + 1 in leafs]\nx = min(lp.count(k) for k in p)\nprint(\"Yes\" if x >= 3 else \"No\") Party LemonadeProblem writer: tourist "
    },
    "911B": {
        "title": "B. Two Cakes",
        "description": "It's New Year's Eve soon, so Ivan decided it's high time he started setting the table. Ivan has bought two cakes and cut them into pieces: the first cake has been cut into a pieces, and the second one \u2014 into b pieces.\nIvan knows that there will be n people at the celebration (including himself), so Ivan has set n plates for the cakes. Now he is thinking about how to distribute the cakes between the plates. Ivan wants to do it in such a way that all following conditions are met:\nTo make his guests happy, Ivan wants to distribute the cakes in such a way that the minimum number of pieces on the plate is maximized. Formally, Ivan wants to know the maximum possible number x such that he can distribute the cakes according to the aforementioned conditions, and each plate will contain at least x pieces of cake.\nHelp Ivan to calculate this number x!\nThe first line contains three integers n, a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100, 2\u2009\u2264\u2009n\u2009\u2264\u2009a\u2009+\u2009b) \u2014 the number of plates, the number of pieces of the first cake, and the number of pieces of the second cake, respectively.\nPrint the maximum possible number x such that Ivan can distribute the cake in such a way that each plate will contain at least x pieces of cake.\nIn the first example there is only one way to distribute cakes to plates, all of them will have 1 cake on it.\nIn the second example you can have two plates with 3 and 4 pieces of the first cake and two plates both with 5 pieces of the second cake. Minimal number of pieces is 3.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "911A": {
        "title": "A. Nearest Minimums",
        "description": "You are given an array of n integer numbers a0,\u2009a1,\u2009...,\u2009an\u2009-\u20091. Find the distance between two closest (nearest) minimums in it. It is guaranteed that in the array a minimum occurs at least two times.\nThe first line contains positive integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 size of the given array. The second line contains n integers a0,\u2009a1,\u2009...,\u2009an\u2009-\u20091 (1\u2009\u2264\u2009ai\u2009\u2264\u2009109) \u2014 elements of the array. It is guaranteed that in the array a minimum occurs at least two times.\nPrint the only number \u2014 distance between two nearest minimums in the array.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "No solution found"
    },
    "909A": {
        "title": "A. Generate Login",
        "description": "The preferred way to generate user login in Polygon is to concatenate a prefix of the user's first name and a prefix of their last name, in that order. Each prefix must be non-empty, and any of the prefixes can be the full name. Typically there are multiple possible logins for each person.\nYou are given the first and the last name of a user. Return the alphabetically earliest login they can get (regardless of other potential Polygon users).\nAs a reminder, a prefix of a string s is its substring which occurs at the beginning of s: \"a\", \"ab\", \"abc\" etc. are prefixes of string \"{abcdef}\" but \"b\" and 'bc\" are not. A string a is alphabetically earlier than a string b, if a is a prefix of b, or a and b coincide up to some position, and then a has a letter that is alphabetically earlier than the corresponding letter in b: \"a\" and \"ab\" are alphabetically earlier than \"ac\" but \"b\" and \"ba\" are alphabetically later than \"ac\".\nThe input consists of a single line containing two space-separated strings: the first and the last names. Each character of each string is a lowercase English letter. The length of each string is between 1 and 10, inclusive. \nOutput a single string\u00a0\u2014 alphabetically earliest possible login formed from these names. The output should be given in lowercase as well.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solutions": "909A - Generate LoginThe most straightforward solution is to generate all possible logins (by trying all non-empty prefixes of first and last names and combining them) and find the alphabetically earliest of them.To get a faster solution, several observations are required. First, in the alphabetically earliest login the prefix of the last name is always one letter long; whatever login is generated using two or more letter of the last name, can be shortened further by removing extra letter to get an alphabetically earlier login.Second, the prefix of the first name should not contain any letter greater than or equal to the first letter of the last name, other than the first letter.Thus, a better solution is: iterate over letter of the first name, starting with the second one. Once a letter which is greater than or equal to the first letter of the last name is found, stop, and return all letter until this one plus the first letter of the last name. If such a letter is not found, return the whole first name plus the first letter of the last name."
    },
    "908B": {
        "title": "B. New Year and Buggy Bot",
        "description": "Bob programmed a robot to navigate through a 2d maze.\nThe maze has some obstacles. Empty cells are denoted by the character '.', where obstacles are denoted by '#'.\nThere is a single robot in the maze. Its start position is denoted with the character 'S'. This position has no obstacle in it. There is also a single exit in the maze. Its position is denoted with the character 'E'. This position has no obstacle in it.\nThe robot can only move up, left, right, or down.\nWhen Bob programmed the robot, he wrote down a string of digits consisting of the digits 0 to 3, inclusive. He intended for each digit to correspond to a distinct direction, and the robot would follow the directions in order to reach the exit. Unfortunately, he forgot to actually assign the directions to digits.\nThe robot will choose some random mapping of digits to distinct directions. The robot will map distinct digits to distinct directions. The robot will then follow the instructions according to the given string in order and chosen mapping. If an instruction would lead the robot to go off the edge of the maze or hit an obstacle, the robot will crash and break down. If the robot reaches the exit at any point, then the robot will stop following any further instructions.\nBob is having trouble debugging his robot, so he would like to determine the number of mappings of digits to directions that would lead the robot to the exit.\nThe first line of input will contain two integers n and m (2\u2009\u2264\u2009n,\u2009m\u2009\u2264\u200950), denoting the dimensions of the maze.\nThe next n lines will contain exactly m characters each, denoting the maze.\nEach character of the maze will be '.', '#', 'S', or 'E'.\nThere will be exactly one 'S' and exactly one 'E' in the maze.\nThe last line will contain a single string s (1\u2009\u2264\u2009|s|\u2009\u2264\u2009100)\u00a0\u2014 the instructions given to the robot. Each character of s is a digit from 0 to 3.\nPrint a single integer, the number of mappings of digits to directions that will lead the robot to the exit.\nFor the first sample, the only valid mapping is , where D is down, L is left, U is up, R is right.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "903C": {
        "title": "C. Boxes Packing",
        "description": "Mishka has got n empty boxes. For every i (1\u2009\u2264\u2009i\u2009\u2264\u2009n), i-th box is a cube with side length ai.\nMishka can put a box i into another box j if the following conditions are met:\nMishka can put boxes into each other an arbitrary number of times. He wants to minimize the number of visible boxes. A box is called visible iff it is not put into some another box.\nHelp Mishka to determine the minimum possible number of visible boxes!\nThe first line contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20095000) \u2014 the number of boxes Mishka has got.\nThe second line contains n integers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u2009109), where ai is the side length of i-th box.\nPrint the minimum possible number of visible boxes.\nIn the first example it is possible to put box 1 into box 2, and 2 into 3.\nIn the second example Mishka can put box 2 into box 3, and box 4 into box 1.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1200"
        ],
        "solutions": "903C - Boxes PackingYou can always show that the answer is equal to the amount of boxes of the size appearing the most in array. Result can be easily obtained by constructive algorithm: take these most appearing boxes, put smaller boxes in decreasing order of their size into free ones (there always be space) and put resulting boxes into the larger ones in increasing order.Overall complexity: . "
    },
    "903B": {
        "title": "B. The Modcrab",
        "description": "Vova is again playing some computer game, now an RPG. In the game Vova's character received a quest: to slay the fearsome monster called Modcrab.\nAfter two hours of playing the game Vova has tracked the monster and analyzed its tactics. The Modcrab has h2 health points and an attack power of a2. Knowing that, Vova has decided to buy a lot of strong healing potions and to prepare for battle.\nVova's character has h1 health points and an attack power of a1. Also he has a large supply of healing potions, each of which increases his current amount of health points by c1 when Vova drinks a potion. All potions are identical to each other. It is guaranteed that c1\u2009>\u2009a2.\nThe battle consists of multiple phases. In the beginning of each phase, Vova can either attack the monster (thus reducing its health by a1) or drink a healing potion (it increases Vova's health by c1; Vova's health can exceed h1). Then, if the battle is not over yet, the Modcrab attacks Vova, reducing his health by a2. The battle ends when Vova's (or Modcrab's) health drops to 0 or lower. It is possible that the battle ends in a middle of a phase after Vova's attack.\nOf course, Vova wants to win the fight. But also he wants to do it as fast as possible. So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases.\nHelp Vova to make up a strategy! You may assume that Vova never runs out of healing potions, and that he can always win.\nThe first line contains three integers h1, a1, c1 (1\u2009\u2264\u2009h1,\u2009a1\u2009\u2264\u2009100, 2\u2009\u2264\u2009c1\u2009\u2264\u2009100) \u2014 Vova's health, Vova's attack power and the healing power of a potion.\nThe second line contains two integers h2, a2 (1\u2009\u2264\u2009h2\u2009\u2264\u2009100, 1\u2009\u2264\u2009a2\u2009<\u2009c1) \u2014 the Modcrab's health and his attack power.\nIn the first line print one integer n denoting the minimum number of phases required to win the battle.\nThen print n lines. i-th line must be equal to HEAL if Vova drinks a potion in i-th phase, or STRIKE if he attacks the Modcrab.\nThe strategy must be valid: Vova's character must not be defeated before slaying the Modcrab, and the monster's health must be 0 or lower after Vova's last action.\nIf there are multiple optimal solutions, print any of them.\nIn the first example Vova's character must heal before or after his first attack. Otherwise his health will drop to zero in 2 phases while he needs 3 strikes to win.\nIn the second example no healing needed, two strikes are enough to get monster to zero health and win with 6 health left.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solutions": "No solution found"
    },
    "902B": {
        "title": "B. Coloring a Tree",
        "description": "You are given a rooted tree with n vertices. The vertices are numbered from 1 to n, the root is the vertex number 1.\nEach vertex has a color, let's denote the color of vertex v by cv. Initially cv\u2009=\u20090.\nYou have to color the tree into the given colors using the smallest possible number of steps. On each step you can choose a vertex v and a color x, and then color all vectices in the subtree of v (including v itself) in color x. In other words, for every vertex u, such that the path from root to u passes through v, set cu\u2009=\u2009x.\nIt is guaranteed that you have to color each vertex in a color different from 0.\nYou can learn what a rooted tree is using the link: https://en.wikipedia.org/wiki/Tree_(graph_theory).\nThe first line contains a single integer n (2\u2009\u2264\u2009n\u2009\u2264\u2009104)\u00a0\u2014 the number of vertices in the tree.\nThe second line contains n\u2009-\u20091 integers p2,\u2009p3,\u2009...,\u2009pn (1\u2009\u2264\u2009pi\u2009<\u2009i), where pi means that there is an edge between vertices i and pi.\nThe third line contains n integers c1,\u2009c2,\u2009...,\u2009cn (1\u2009\u2264\u2009ci\u2009\u2264\u2009n), where ci is the color you should color the i-th vertex into.\nIt is guaranteed that the given graph is a tree. \nPrint a single integer\u00a0\u2014 the minimum number of steps you have to perform to color the tree into given colors.\nThe tree from the first sample is shown on the picture (numbers are vetices' indices):\n\nOn first step we color all vertices in the subtree of vertex 1 into color 2 (numbers are colors):\n\nOn seond step we color all vertices in the subtree of vertex 5 into color 1:\n\nOn third step we color all vertices in the subtree of vertex 2 into color 1:\n\nThe tree from the second sample is shown on the picture (numbers are vetices' indices):\n\nOn first step we color all vertices in the subtree of vertex 1 into color 3 (numbers are colors):\n\nOn second step we color all vertices in the subtree of vertex 3 into color 1:\n\nOn third step we color all vertices in the subtree of vertex 6 into color 2:\n\nOn fourth step we color all vertices in the subtree of vertex 4 into color 1:\n\nOn fith step we color all vertices in the subtree of vertex 7 into color 3:\n",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "dsu",
            "greedy",
            "*1200"
        ],
        "solutions": "902B - Coloring a TreeConsider the process from the end, we will \"delete\" any subtree from the tree, whose color of the ancestor of the highest vertex differs from the color of the highest vertex and the colors of all vertices in the subtree are the same. Thus, we can show that the answer is the number of edges whose ends have different colors + 1. "
    },
    "902A": {
        "title": "A. Visiting a Friend",
        "description": "Pig is visiting a friend.\nPig's house is located at point 0, and his friend's house is located at point m on an axis.\nPig can use teleports to move along the axis.\nTo use a teleport, Pig should come to a certain point (where the teleport is located) and choose where to move: for each teleport there is the rightmost point it can move Pig to, this point is known as the limit of the teleport.\nFormally, a teleport located at point x with limit y can move Pig from point x to any point within the segment [x;\u2009y], including the bounds.\nDetermine if Pig can visit the friend using teleports only, or he should use his car.\nThe first line contains two integers n and m (1\u2009\u2264\u2009n\u2009\u2264\u2009100,\u20091\u2009\u2264\u2009m\u2009\u2264\u2009100)\u00a0\u2014 the number of teleports and the location of the friend's house.\nThe next n lines contain information about teleports.\nThe i-th of these lines contains two integers ai and bi (0\u2009\u2264\u2009ai\u2009\u2264\u2009bi\u2009\u2264\u2009m), where ai is the location of the i-th teleport, and bi is its limit.\nIt is guaranteed that ai\u2009\u2265\u2009ai\u2009-\u20091 for every i (2\u2009\u2264\u2009i\u2009\u2264\u2009n).\nPrint \"YES\" if there is a path from Pig's house to his friend's house that uses only teleports, and \"NO\" otherwise.\nYou can print each letter in arbitrary case (upper or lower).\nThe first example is shown on the picture below:\nPig can use the first teleport from his house (point 0) to reach point 2, then using the second teleport go from point 2 to point 3, then using the third teleport go from point 3 to point 5, where his friend lives.\nThe second example is shown on the picture below:\nYou can see that there is no path from Pig's house to his friend's house that uses only teleports.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solutions": "902A - Visiting a FriendNote that if we can get to some point x, then we can get to all points <= x. So we can support the rightmost point where we can get to. Then if this point can use the teleport (if this point is to the right of the teleport), we'll try to move it (If the limit of the teleport is to the right of the current point, then move it there). Then in the end we need to check that the rightmost point where we can get is equal to M. "
    },
    "899B": {
        "title": "B. Months and Years",
        "description": "Everybody in Russia uses Gregorian calendar. In this calendar there are 31 days in January, 28 or 29 days in February (depending on whether the year is leap or not), 31 days in March, 30 days in April, 31 days in May, 30 in June, 31 in July, 31 in August, 30 in September, 31 in October, 30 in November, 31 in December.\nA year is leap in one of two cases: either its number is divisible by 4, but not divisible by 100, or is divisible by 400. For example, the following years are leap: 2000, 2004, but years 1900 and 2018 are not leap.\nIn this problem you are given n (1\u2009\u2264\u2009n\u2009\u2264\u200924) integers a1,\u2009a2,\u2009...,\u2009an, and you have to check if these integers could be durations in days of n consecutive months, according to Gregorian calendar. Note that these months could belong to several consecutive years. In other words, check if there is a month in some year, such that its duration is a1 days, duration of the next month is a2 days, and so on.\nThe first line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200924) \u2014 the number of integers.\nThe second line contains n integers a1,\u2009a2,\u2009...,\u2009an (28\u2009\u2264\u2009ai\u2009\u2264\u200931) \u2014 the numbers you are to check.\nIf there are several consecutive months that fit the sequence, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes).\nYou can print each letter in arbitrary case (small or large).\nIn the first example the integers can denote months July, August, September and October.\nIn the second example the answer is no, because there are no two consecutive months each having 30 days.\nIn the third example the months are: February (leap year) \u2014 March \u2014 April \u2013 May \u2014 June.\nIn the fourth example the number of days in the second month is 28, so this is February. March follows February and has 31 days, but not 30, so the answer is NO.\nIn the fifth example the months are: December \u2014 January \u2014 February (non-leap year).",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solutions": "899B - Months and YearsNote, that n\u2009\u2264\u200924, so we should consider the following cycle: not leap-year \u2014 leap-year \u2014 not leap-year \u2014 not leap-year. This cycle repeats every 4 years, except in some cases. We should generate an array describing the duration of the months in the described cycle. After that we should check that the given sequence can be found in the generated array. For example, we can brute the beginning of the sequence in the array and check the correspondence of the elements of the given sequence to the corresponding elements of the generated array. "
    },
    "898B": {
        "title": "B. Proper Nutrition",
        "description": "Vasya has n burles. One bottle of Ber-Cola costs a burles and one Bars bar costs b burles. He can buy any non-negative integer number of bottles of Ber-Cola and any non-negative integer number of Bars bars.\nFind out if it's possible to buy some amount of bottles of Ber-Cola and Bars bars and spend exactly n burles.\nIn other words, you should find two non-negative integers x and y such that Vasya can buy x bottles of Ber-Cola and y Bars bars and x\u00b7a\u2009+\u2009y\u00b7b\u2009=\u2009n or tell that it's impossible.\nFirst line contains single integer n (1\u2009\u2264\u2009n\u2009\u2264\u200910\u2009000\u2009000)\u00a0\u2014 amount of money, that Vasya has.\nSecond line contains single integer a (1\u2009\u2264\u2009a\u2009\u2264\u200910\u2009000\u2009000)\u00a0\u2014 cost of one bottle of Ber-Cola.\nThird line contains single integer b (1\u2009\u2264\u2009b\u2009\u2264\u200910\u2009000\u2009000)\u00a0\u2014 cost of one Bars bar.\nIf Vasya can't buy Bars and Ber-Cola in such a way to spend exactly n burles print \u00abNO\u00bb (without quotes).\nOtherwise in first line print \u00abYES\u00bb (without quotes). In second line print two non-negative integers x and y\u00a0\u2014 number of bottles of Ber-Cola and number of Bars bars Vasya should buy in order to spend exactly n burles, i.e. x\u00b7a\u2009+\u2009y\u00b7b\u2009=\u2009n. If there are multiple answers print any of them.\nAny of numbers x and y can be equal 0.\nIn first example Vasya can buy two bottles of Ber-Cola and one Bars bar. He will spend exactly 2\u00b72\u2009+\u20091\u00b73\u2009=\u20097 burles.\nIn second example Vasya can spend exactly n burles multiple ways: \nIn third example it's impossible to but Ber-Cola and Bars bars in order to spend exactly n burles.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solutions": "898B - Proper NutritionTo solve this problem we need to brute how many bottles of Ber-Cola Vasya will buy. Let this number equals to x. Then, if n\u2009-\u2009a\u00b7x is non-negative and divided by b we found the answer \u2014 Vasya should by x bottles of Ber-Cola and (n\u2009-\u2009a\u00b7x)\u2009/\u2009b Bars bars.In case that (n\u2009-\u2009a\u00b7x) became negative there is no answer and we should print \"NO\". "
    },
    "895A": {
        "title": "A. Pizza Separation",
        "description": "Students Vasya and Petya are studying at the BSU (Byteland State University). At one of the breaks they decided to order a pizza. In this problem pizza is a circle of some radius. The pizza was delivered already cut into n pieces. The i-th piece is a sector of angle equal to ai. Vasya and Petya want to divide all pieces of pizza into two continuous sectors in such way that the difference between angles of these sectors is minimal. Sector angle is sum of angles of all pieces in it. Pay attention, that one of sectors can be empty.\nThe first line contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009360) \u00a0\u2014 the number of pieces into which the delivered pizza was cut.\nThe second line contains n integers ai (1\u2009\u2264\u2009ai\u2009\u2264\u2009360) \u00a0\u2014 the angles of the sectors into which the pizza was cut. The sum of all ai is 360.\nPrint one integer \u00a0\u2014 the minimal difference between angles of sectors that will go to Vasya and Petya.\nIn first sample Vasya can take 1 and 2 pieces, Petya can take 3 and 4 pieces. Then the answer is |(90\u2009+\u200990)\u2009-\u2009(90\u2009+\u200990)|\u2009=\u20090.\nIn third sample there is only one piece of pizza that can be taken by only one from Vasya and Petya. So the answer is |360\u2009-\u20090|\u2009=\u2009360.\nIn fourth sample Vasya can take 1 and 4 pieces, then Petya will take 2 and 3 pieces. So the answer is |(170\u2009+\u200910)\u2009-\u2009(30\u2009+\u2009150)|\u2009=\u20090.\nPicture explaning fourth sample:\n\nBoth red and green sectors consist of two adjacent pieces of pizza. So Vasya can take green sector, then Petya will take red sector.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solutions": "895A - Pizza SeparationWe can notice that if one of the sectors is continuous then all the remaining pieces also form a continuous sector.If angle of the first sector is equal to x then difference between angles of first and second sectors is |x\u2009-\u2009(360\u2009-\u2009x)|\u2009=\u2009|2\u2009*\u2009x\u2009-\u2009360|\u2009=\u20092\u2009*\u2009|x\u2009-\u2009180|. So for each possible continuous sector we can count it's angle and update answer.Time complexity O(n2) or O(n).Solution"
    },
    "893B": {
        "title": "B. Beautiful Divisors",
        "description": "Recently Luba learned about a special kind of numbers that she calls beautiful numbers. The number is called beautiful iff its binary representation consists of k\u2009+\u20091 consecutive ones, and then k consecutive zeroes.\nSome examples of beautiful numbers: \nMore formally, the number is beautiful iff there exists some positive integer k such that the number is equal to (2k\u2009-\u20091)\u2009*\u2009(2k\u2009-\u20091).\nLuba has got an integer number n, and she wants to find its greatest beautiful divisor. Help her to find it!\nThe only line of input contains one number n (1\u2009\u2264\u2009n\u2009\u2264\u2009105) \u2014 the number Luba has got.\nOutput one number \u2014 the greatest beautiful divisor of Luba's number. It is obvious that the answer always exists.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1000"
        ],
        "solutions": "893B - Beautiful DivisorsLet's notice that there are only 8 beautiful numbers less than 105. Generate them all and select the greatest one which is also divisor of n.Overall complexity: O(1). "
    },
    "892B": {
        "title": "B. Wrath",
        "description": "Hands that shed innocent blood!\nThere are n guilty people in a line, the i-th of them holds a claw with length Li. The bell rings and every person kills some of people in front of him. All people kill others at the same time. Namely, the i-th person kills the j-th person if and only if j\u2009<\u2009i and j\u2009\u2265\u2009i\u2009-\u2009Li.\nYou are given lengths of the claws. You need to find the total number of alive people after the bell rings.\nThe first line contains one integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106) \u2014 the number of guilty people.\nSecond line contains n space-separated integers L1,\u2009L2,\u2009...,\u2009Ln (0\u2009\u2264\u2009Li\u2009\u2264\u2009109), where Li is the length of the i-th person's claw.\nPrint one integer \u2014 the total number of alive people after the bell rings.\nIn first sample the last person kills everyone in front of him.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solutions": "892B - WrathThe i'th person will be alive if min(j\u2009-\u2009Lj)\u2009>\u2009i over all j\u2009>\u2009i.Consider you know the jth person is alive or not if j\u2009>\u2009i and you have x\u2009=\u2009min(j\u2009-\u2009Lj) over all j\u2009>\u2009i. If x\u2009>\u2009i then the ith person will be alive.And you can update x easily. "
    },
    "888B": {
        "title": "B. Buggy Robot",
        "description": "Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell (0,\u20090). The robot can process commands. There are four types of commands it can perform:\nIvan entered a sequence of n commands, and the robot processed it. After this sequence the robot ended up in the starting cell (0,\u20090), but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations!\nThe first line contains one number n \u2014 the length of sequence of commands entered by Ivan (1\u2009\u2264\u2009n\u2009\u2264\u2009100).\nThe second line contains the sequence itself \u2014 a string consisting of n characters. Each character can be U, D, L or R.\nPrint the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solutions": "888B - Buggy RobotConsider the final cell after original path. It has some distance dx to x\u2009=\u20090 and dy to y\u2009=\u20090. That means the path included at least dx and dy in corresponding directions. Let's remove just these minimal numbers of moves.Finally, the answer will be n\u2009-\u2009dx\u2009-\u2009dy, where (dx,\u2009dy) are distances from the final cell of the original path to (0,\u20090).Overall complexity: O(n). "
    },
    "887A": {
        "title": "A. Div. 64",
        "description": "Top-model Izabella participates in the competition. She wants to impress judges and show her mathematical skills.\nHer problem is following: for given string, consisting of only 0 and 1, tell if it's possible to remove some digits in such a way, that remaining number is a representation of some positive integer, divisible by 64, in the binary numerical system.\nIn the only line given a non-empty binary string s with length up to 100.\nPrint \u00abyes\u00bb (without quotes) if it's possible to remove digits required way and \u00abno\u00bb otherwise.\nIn the first test case, you can get string 1 000 000 after removing two ones which is a representation of number 64 in the binary numerical system.\nYou can read more about binary numeral system representation here: https://en.wikipedia.org/wiki/Binary_system",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solutions": "887A - Div. 64Author: .31.If the string contains no ones then the answer is \"NO\" as the remainig number must be positive. Otherwise we can find the leftmost one and check if it is followed by at least six zeroes.Solution."
    },
    "886B": {
        "title": "B. Vlad and Cafes",
        "description": "Vlad likes to eat in cafes very much. During his life, he has visited cafes n times. Unfortunately, Vlad started to feel that his last visits are not any different from each other. To fix that Vlad had a small research.\nFirst of all, Vlad assigned individual indices to all cafes. Then, he wrote down indices of cafes he visited in a row, in order of visiting them. Now, Vlad wants to find such a cafe that his last visit to that cafe was before his last visits to every other cafe. In other words, he wants to find such a cafe that he hasn't been there for as long as possible. Help Vlad to find that cafe.\nIn first line there is one integer n (1\u2009\u2264\u2009n\u2009\u2264\u20092\u00b7105)\u00a0\u2014 number of cafes indices written by Vlad.\nIn second line, n numbers a1,\u2009a2,\u2009...,\u2009an (0\u2009\u2264\u2009ai\u2009\u2264\u20092\u00b7105) are written\u00a0\u2014 indices of cafes in order of being visited by Vlad. Vlad could visit some cafes more than once. Note that in numeration, some indices could be omitted.\nPrint one integer\u00a0\u2014 index of the cafe that Vlad hasn't visited for as long as possible.\nIn first test, there are three cafes, and the last visits to cafes with indices 1 and 2 were after the last visit to cafe with index 3; so this cafe is the answer. \nIn second test case, there are also three cafes, but with indices 1, 2 and 4. Cafes with indices 1 and 4 were visited after the last visit of cafe with index 2, so the answer is 2. Note that Vlad could omit some numbers while numerating the cafes.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "*1000"
        ],
        "solutions": "886B - Vlad and CafesThere are two steps to solve this problem:1. Put in array last the last time when Petya visited each cafe.2. Now you need to find the position of minimum in this array and print it. "
    },
    "886A": {
        "title": "A. ACM ICPC",
        "description": "In a small but very proud high school it was decided to win ACM ICPC. This goal requires to compose as many teams of three as possible, but since there were only 6 students who wished to participate, the decision was to build exactly two teams.\nAfter practice competition, participant number i got a score of ai. Team score is defined as sum of scores of its participants. High school management is interested if it's possible to build two teams with equal scores. Your task is to answer that question.\nThe single line contains six integers a1,\u2009...,\u2009a6 (0\u2009\u2264\u2009ai\u2009\u2264\u20091000) \u2014 scores of the participants\nPrint \"YES\" (quotes for clarity), if it is possible to build teams with equal score, and \"NO\" otherwise.\nYou can print each character either upper- or lowercase (\"YeS\" and \"yes\" are valid when the answer is \"YES\").\nIn the first sample, first team can be composed of 1st, 2nd and 6th participant, second \u2014 of 3rd, 4th and 5th: team scores are 1\u2009+\u20093\u2009+\u20091\u2009=\u20092\u2009+\u20091\u2009+\u20092\u2009=\u20095.\nIn the second sample, score of participant number 6 is too high: his team score will be definitely greater.",
        "time limit": "time limit per test2 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "*1000"
        ],
        "solutions": "886A - ACM ICPCIn this problem it's enough to iterate through all the triples checking whether its sum equals to the sum of remaining triple or not. Answer is \"YES\" if equality is possible and \"NO\" \u2014 otherwise. "
    },
    "884B": {
        "title": "B. Japanese Crosswords Strike Back",
        "description": "A one-dimensional Japanese crossword can be represented as a binary string of length x. An encoding of this crossword is an array a of size n, where n is the number of segments formed completely of 1's, and ai is the length of i-th segment. No two segments touch or intersect.\nFor example: \nMishka wants to create a new one-dimensional Japanese crossword. He has already picked the length and the encoding for this crossword. And now he needs to check if there is exactly one crossword such that its length and encoding are equal to the length and encoding he picked. Help him to check it!\nThe first line contains two integer numbers n and x (1\u2009\u2264\u2009n\u2009\u2264\u2009100000, 1\u2009\u2264\u2009x\u2009\u2264\u2009109) \u2014 the number of elements in the encoding and the length of the crossword Mishka picked.\nThe second line contains n integer numbers a1, a2, ..., an (1\u2009\u2264\u2009ai\u2009\u2264\u200910000) \u2014 the encoding.\nPrint YES if there exists exaclty one crossword with chosen length and encoding. Otherwise, print NO.",
        "time limit": "time limit per test1 second",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solutions": "884B - Japanese Crosswords Strike BackThe only answer is when no segment can be moved one cell either to the left or to the right. So there should be exactly one cell between two consecutive segments and the first and the last segments should touch the borders.Thus total count of cells needed is .Overall complexity; O(n).  "
    },
    "883M": {
        "title": "M. Quadcopter Competition",
        "description": "Polycarp takes part in a quadcopter competition. According to the rules a flying robot should:\nPolycarp knows the coordinates of the starting point (x1,\u2009y1) and the coordinates of the point where the flag is situated (x2,\u2009y2). Polycarp\u2019s quadcopter can fly only parallel to the sides of the field each tick changing exactly one coordinate by 1. It means that in one tick the quadcopter can fly from the point (x,\u2009y) to any of four points: (x\u2009-\u20091,\u2009y), (x\u2009+\u20091,\u2009y), (x,\u2009y\u2009-\u20091) or (x,\u2009y\u2009+\u20091).\nThus the quadcopter path is a closed cycle starting and finishing in (x1,\u2009y1) and containing the point (x2,\u2009y2) strictly inside.\nWhat is the minimal length of the quadcopter path?\nThe first line contains two integer numbers x1 and y1 (\u2009-\u2009100\u2009\u2264\u2009x1,\u2009y1\u2009\u2264\u2009100) \u2014 coordinates of the quadcopter starting (and finishing) point.\nThe second line contains two integer numbers x2 and y2 (\u2009-\u2009100\u2009\u2264\u2009x2,\u2009y2\u2009\u2264\u2009100) \u2014 coordinates of the flag.\nIt is guaranteed that the quadcopter starting point and the flag do not coincide.\nPrint the length of minimal path of the quadcopter to surround the flag and return back.",
        "time limit": "time limit per test3 seconds",
        "memory limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solutions": "No solution found"
    }
}